diff --git a/src/corelib/arch/qatomic_armv5.h b/src/corelib/arch/qatomic_armv5.h
index 210fbc1..c43b4de 100644
--- a/src/corelib/arch/qatomic_armv5.h
+++ b/src/corelib/arch/qatomic_armv5.h
@@ -82,13 +82,13 @@ template <int size> struct QBasicAtomicOps: QGenericAtomicOps<QBasicAtomicOps<si
 {
     // kernel places a restartable cmpxchg implementation at a fixed address
     template <typename T>
-    static int _q_cmpxchg(T oldval, T newval, volatile T *ptr)
+    static int _q_cmpxchg(T oldval, T newval, volatile T *ptr) Q_DECL_NOTHROW
     {
         typedef int (* kernel_cmpxchg_t)(T oldval, T newval, volatile T *ptr);
         kernel_cmpxchg_t kernel_cmpxchg = *reinterpret_cast<kernel_cmpxchg_t>(0xffff0fc0);
         return kernel_cmpxchg(oldval, newval, ptr);
     }
-    static void _q_dmb()
+    static void _q_dmb() Q_DECL_NOTHROW
     {
         typedef void (* kernel_dmb_t)();
         kernel_dmb_t kernel_dmb = *reinterpret_cast<kernel_dmb_t>(0xffff0fa0);
@@ -96,17 +96,17 @@ template <int size> struct QBasicAtomicOps: QGenericAtomicOps<QBasicAtomicOps<si
     }
 
     template <typename T>
-    static void orderedMemoryFence(const T &) { _q_dmb(); }
+    static void orderedMemoryFence(const T &) Q_DECL_NOTHROW { _q_dmb(); }
 
-    template <typename T> static bool ref(T &_q_value);
-    template <typename T> static bool deref(T &_q_value);
+    template <typename T> static bool ref(T &_q_value) Q_DECL_NOTHROW;
+    template <typename T> static bool deref(T &_q_value) Q_DECL_NOTHROW;
 
-    static bool isTestAndSetNative() { return false; }
-    static bool isTestAndSetWaitFree() { return false; }
-    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue);
-    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue);
+    static bool isTestAndSetNative() Q_DECL_NOTHROW { return false; }
+    static bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
+    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
+    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW;
     template <typename T> static
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
 };
 
 template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
@@ -115,7 +115,7 @@ template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
 };
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::ref(T &_q_value)
+bool QBasicAtomicOps<4>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -127,7 +127,7 @@ bool QBasicAtomicOps<4>::ref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::deref(T &_q_value)
+bool QBasicAtomicOps<4>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -139,7 +139,7 @@ bool QBasicAtomicOps<4>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     register T originalValue;
     do {
@@ -153,7 +153,7 @@ bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 // Fetch and store for integers
 #ifdef Q_CC_RVCT
 template<> template <typename T> inline
-__asm T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+__asm T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     add r2, pc, #0
     bx r2
@@ -165,7 +165,7 @@ __asm T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 #else
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     T originalValue;
     asm volatile("swp %0,%2,[%3]"
@@ -177,7 +177,7 @@ T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 #endif // Q_CC_RVCT
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
diff --git a/src/corelib/arch/qatomic_armv6.h b/src/corelib/arch/qatomic_armv6.h
index 5bf7096..95e1f28 100644
--- a/src/corelib/arch/qatomic_armv6.h
+++ b/src/corelib/arch/qatomic_armv6.h
@@ -78,22 +78,22 @@ template<> struct QAtomicIntegerTraits<unsigned int> { enum { IsInteger = 1 }; }
 template <int size> struct QBasicAtomicOps: QGenericAtomicOps<QBasicAtomicOps<size> >
 {
     template <typename T>
-    static void orderedMemoryFence(const T &);
+    static void orderedMemoryFence(const T &) Q_DECL_NOTHROW;
 
-    static inline bool isReferenceCountingNative() { return true; }
-    template <typename T> static bool ref(T &_q_value);
-    template <typename T> static bool deref(T &_q_value);
+    static inline bool isReferenceCountingNative() Q_DECL_NOTHROW { return true; }
+    template <typename T> static bool ref(T &_q_value) Q_DECL_NOTHROW;
+    template <typename T> static bool deref(T &_q_value) Q_DECL_NOTHROW;
 
-    static inline bool isTestAndSetNative() { return true; }
-    static inline bool isTestAndSetWaitFree() { return false; }
-    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue);
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
+    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndStoreNative() { return true; }
-    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue);
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return true; }
+    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndAddNative() { return true; }
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return true; }
     template <typename T> static
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
 };
 
 template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
@@ -111,7 +111,7 @@ template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
 #endif
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::ref(T &_q_value)
+bool QBasicAtomicOps<4>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -130,7 +130,7 @@ bool QBasicAtomicOps<4>::ref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::deref(T &_q_value)
+bool QBasicAtomicOps<4>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -149,7 +149,7 @@ bool QBasicAtomicOps<4>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     register int result;
     asm volatile("0:\n"
@@ -169,7 +169,7 @@ bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     register T originalValue;
     register int result;
@@ -188,7 +188,7 @@ T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -245,7 +245,7 @@ template<> struct QAtomicIntegerTraits<unsigned long long> { enum { IsInteger =
 #define Q_ATOMIC_INT64_FETCH_AND_ADD_IS_ALWAYS_NATIVE
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<1>::ref(T &_q_value)
+bool QBasicAtomicOps<1>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -264,7 +264,7 @@ bool QBasicAtomicOps<1>::ref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::deref(T &_q_value)
+bool QBasicAtomicOps<1>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -283,7 +283,7 @@ bool QBasicAtomicOps<1>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<1>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     register T result;
     asm volatile("0:\n"
@@ -303,7 +303,7 @@ bool QBasicAtomicOps<1>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<1>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     register T originalValue;
     register int result;
@@ -322,7 +322,7 @@ T QBasicAtomicOps<1>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -344,7 +344,7 @@ T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<2>::ref(T &_q_value)
+bool QBasicAtomicOps<2>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -363,7 +363,7 @@ bool QBasicAtomicOps<2>::ref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<2>::deref(T &_q_value)
+bool QBasicAtomicOps<2>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -382,7 +382,7 @@ bool QBasicAtomicOps<2>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<2>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<2>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     register T result;
     asm volatile("0:\n"
@@ -402,7 +402,7 @@ bool QBasicAtomicOps<2>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<2>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     register T originalValue;
     register int result;
@@ -421,7 +421,7 @@ T QBasicAtomicOps<2>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<2>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -451,7 +451,7 @@ T QBasicAtomicOps<2>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 // If this is a little-endian build, H and R are the same; otherwise, H and Q are the same.
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::ref(T &_q_value)
+bool QBasicAtomicOps<8>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -471,7 +471,7 @@ bool QBasicAtomicOps<8>::ref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::deref(T &_q_value)
+bool QBasicAtomicOps<8>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     register T newValue;
     register int result;
@@ -491,7 +491,7 @@ bool QBasicAtomicOps<8>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<8>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     register T result;
     asm volatile("0:\n"
@@ -513,7 +513,7 @@ bool QBasicAtomicOps<8>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<8>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     register T originalValue;
     register int result;
@@ -532,7 +532,7 @@ T QBasicAtomicOps<8>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -577,7 +577,7 @@ T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 # define Q_COMPILER_MEMORY_BARRIER __schedule_barrier()
 #endif
 
-inline bool QBasicAtomicInt::ref()
+inline bool QBasicAtomicInt::ref() Q_DECL_NOTHROW
 {
     register int newValue;
     register int result;
@@ -592,7 +592,7 @@ inline bool QBasicAtomicInt::ref()
     return newValue != 0;
 }
 
-inline bool QBasicAtomicInt::deref()
+inline bool QBasicAtomicInt::deref() Q_DECL_NOTHROW
 {
     register int newValue;
     register int result;
@@ -607,7 +607,7 @@ inline bool QBasicAtomicInt::deref()
     return newValue != 0;
 }
 
-inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue)
+inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue) Q_DECL_NOTHROW
 {
     register int result;
     retry:
@@ -621,7 +621,7 @@ inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue)
     return result == 0;
 }
 
-inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue)
+inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue) Q_DECL_NOTHROW
 {
     register int originalValue;
     register int result;
@@ -635,7 +635,7 @@ inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue)
     return originalValue;
 }
 
-inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd)
+inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd) Q_DECL_NOTHROW
 {
     register int originalValue;
     register int newValue;
@@ -652,7 +652,7 @@ inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd)
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValue, T *newValue)
+Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValue, T *newValue) Q_DECL_NOTHROW
 {
     register T *result;
     retry:
@@ -667,7 +667,7 @@ Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValu
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue)
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue) Q_DECL_NOTHROW
 {
     register T *originalValue;
     register int result;
@@ -682,7 +682,7 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue)
 }
 
 template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueToAdd)
+Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueToAdd) Q_DECL_NOTHROW
 {
     register T *originalValue;
     register T *newValue;
@@ -707,7 +707,7 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueTo
 // common code
 
 template <int size> template <typename T> inline
-void QBasicAtomicOps<size>::orderedMemoryFence(const T &)
+void QBasicAtomicOps<size>::orderedMemoryFence(const T &) Q_DECL_NOTHROW
 {
     Q_DATA_MEMORY_BARRIER;
 }
diff --git a/src/corelib/arch/qatomic_bootstrap.h b/src/corelib/arch/qatomic_bootstrap.h
index 75f328b..da6c09b 100644
--- a/src/corelib/arch/qatomic_bootstrap.h
+++ b/src/corelib/arch/qatomic_bootstrap.h
@@ -62,16 +62,16 @@ template <typename T> struct QAtomicOps: QGenericAtomicOps<QAtomicOps<T> >
 {
     typedef T Type;
 
-    static bool ref(T &_q_value)
+    static bool ref(T &_q_value) Q_DECL_NOTHROW
     {
         return ++_q_value != 0;
     }
-    static bool deref(T &_q_value)
+    static bool deref(T &_q_value) Q_DECL_NOTHROW
     {
         return --_q_value != 0;
     }
 
-    static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+    static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
     {
         if (_q_value == expectedValue) {
             _q_value = newValue;
@@ -80,7 +80,7 @@ template <typename T> struct QAtomicOps: QGenericAtomicOps<QAtomicOps<T> >
         return false;
     }
 
-    static T fetchAndStoreRelaxed(T &_q_value, T newValue)
+    static T fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
     {
         T tmp = _q_value;
         _q_value = newValue;
@@ -88,7 +88,7 @@ template <typename T> struct QAtomicOps: QGenericAtomicOps<QAtomicOps<T> >
     }
 
     static
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
     {
         T returnValue = _q_value;
         _q_value += valueToAdd;
diff --git a/src/corelib/arch/qatomic_cxx11.h b/src/corelib/arch/qatomic_cxx11.h
index ec6b3e3..98e8e70 100644
--- a/src/corelib/arch/qatomic_cxx11.h
+++ b/src/corelib/arch/qatomic_cxx11.h
@@ -109,126 +109,126 @@ template <typename T> struct QAtomicOps
     static const int AddScale = QAtomicAdditiveType<T>::AddScale;
 
     static inline
-    T load(const Type &_q_value)
+    T load(const Type &_q_value) Q_DECL_NOTHROW
     {
         return _q_value.load(std::memory_order_relaxed);
     }
 
     static inline
-    T load(const volatile Type &_q_value)
+    T load(const volatile Type &_q_value) Q_DECL_NOTHROW
     {
         return _q_value.load(std::memory_order_relaxed);
     }
 
     static inline
-    T loadAcquire(const Type &_q_value)
+    T loadAcquire(const Type &_q_value) Q_DECL_NOTHROW
     {
         return _q_value.load(std::memory_order_acquire);
     }
 
     static inline
-    T loadAcquire(const volatile Type &_q_value)
+    T loadAcquire(const volatile Type &_q_value) Q_DECL_NOTHROW
     {
         return _q_value.load(std::memory_order_acquire);
     }
 
     static inline
-    void store(Type &_q_value, T newValue)
+    void store(Type &_q_value, T newValue) Q_DECL_NOTHROW
     {
         _q_value.store(newValue, std::memory_order_relaxed);
     }
 
     static inline
-    void storeRelease(Type &_q_value, T newValue)
+    void storeRelease(Type &_q_value, T newValue) Q_DECL_NOTHROW
     {
         _q_value.store(newValue, std::memory_order_release);
     }
 
-    static inline bool isReferenceCountingNative() { return true; }
-    static inline bool isReferenceCountingWaitFree() { return false; }
+    static inline bool isReferenceCountingNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isReferenceCountingWaitFree() Q_DECL_NOTHROW { return false; }
     static inline bool ref(Type &_q_value)
     {
         return ++_q_value != 0;
     }
 
-    static inline bool deref(Type &_q_value)
+    static inline bool deref(Type &_q_value) Q_DECL_NOTHROW
     {
         return --_q_value != 0;
     }
 
-    static inline bool isTestAndSetNative() { return false; }
-    static inline bool isTestAndSetWaitFree() { return false; }
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
 
     static
-    bool testAndSetRelaxed(Type &_q_value, T expectedValue, T newValue)
+    bool testAndSetRelaxed(Type &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_relaxed);
     }
 
-    static bool testAndSetAcquire(Type &_q_value, T expectedValue, T newValue)
+    static bool testAndSetAcquire(Type &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_acquire);
     }
 
-    static bool testAndSetRelease(Type &_q_value, T expectedValue, T newValue)
+    static bool testAndSetRelease(Type &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_release);
     }
 
-    static bool testAndSetOrdered(Type &_q_value, T expectedValue, T newValue)
+    static bool testAndSetOrdered(Type &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.compare_exchange_strong(expectedValue, newValue, std::memory_order_acq_rel);
     }
 
-    static inline bool isFetchAndStoreNative() { return false; }
-    static inline bool isFetchAndStoreWaitFree() { return false; }
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isFetchAndStoreWaitFree() Q_DECL_NOTHROW { return false; }
 
-    static T fetchAndStoreRelaxed(Type &_q_value, T newValue)
+    static T fetchAndStoreRelaxed(Type &_q_value, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.exchange(newValue, std::memory_order_relaxed);
     }
 
-    static T fetchAndStoreAcquire(Type &_q_value, T newValue)
+    static T fetchAndStoreAcquire(Type &_q_value, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.exchange(newValue, std::memory_order_acquire);
     }
 
-    static T fetchAndStoreRelease(Type &_q_value, T newValue)
+    static T fetchAndStoreRelease(Type &_q_value, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.exchange(newValue, std::memory_order_release);
     }
 
-    static T fetchAndStoreOrdered(Type &_q_value, T newValue)
+    static T fetchAndStoreOrdered(Type &_q_value, T newValue) Q_DECL_NOTHROW
     {
         return _q_value.exchange(newValue, std::memory_order_acq_rel);
     }
 
-    static inline bool isFetchAndAddNative() { return false; }
-    static inline bool isFetchAndAddWaitFree() { return false; }
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isFetchAndAddWaitFree() Q_DECL_NOTHROW { return false; }
 
     static
-    T fetchAndAddRelaxed(Type &_q_value, _AdditiveType valueToAdd)
+    T fetchAndAddRelaxed(Type &_q_value, _AdditiveType valueToAdd) Q_DECL_NOTHROW
     {
         return _q_value.fetch_add(valueToAdd * AddScale,
                                   std::memory_order_relaxed);
     }
 
     static
-    T fetchAndAddAcquire(Type &_q_value, _AdditiveType valueToAdd)
+    T fetchAndAddAcquire(Type &_q_value, _AdditiveType valueToAdd) Q_DECL_NOTHROW
     {
         return _q_value.fetch_add(valueToAdd * AddScale,
                                   std::memory_order_acquire);
     }
 
     static
-    T fetchAndAddRelease(Type &_q_value, _AdditiveType valueToAdd)
+    T fetchAndAddRelease(Type &_q_value, _AdditiveType valueToAdd) Q_DECL_NOTHROW
     {
         return _q_value.fetch_add(valueToAdd * AddScale,
                                   std::memory_order_release);
     }
 
     static
-    T fetchAndAddOrdered(Type &_q_value, _AdditiveType valueToAdd)
+    T fetchAndAddOrdered(Type &_q_value, _AdditiveType valueToAdd) Q_DECL_NOTHROW
     {
         return _q_value.fetch_add(valueToAdd * AddScale,
                                   std::memory_order_acq_rel);
diff --git a/src/corelib/arch/qatomic_gcc.h b/src/corelib/arch/qatomic_gcc.h
index 9edb74f..73df3e7 100644
--- a/src/corelib/arch/qatomic_gcc.h
+++ b/src/corelib/arch/qatomic_gcc.h
@@ -84,45 +84,45 @@ template <typename T> struct QAtomicOps: QGenericAtomicOps<QAtomicOps<T> >
     typedef T Type;
 
 #ifndef __ia64__
-    static T loadAcquire(const T &_q_value)
+    static T loadAcquire(const T &_q_value) Q_DECL_NOTHROW
     {
         T tmp = _q_value;
         __sync_synchronize();
         return tmp;
     }
 
-    static void storeRelease(T &_q_value, T newValue)
+    static void storeRelease(T &_q_value, T newValue) Q_DECL_NOTHROW
     {
         __sync_synchronize();
         _q_value = newValue;
     }
 #endif
 
-    static bool isTestAndSetNative() { return false; }
-    static bool isTestAndSetWaitFree() { return false; }
-    static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+    static bool isTestAndSetNative() Q_DECL_NOTHROW { return false; }
+    static bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
+    static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
     {
         return __sync_bool_compare_and_swap(&_q_value, expectedValue, newValue);
     }
 
-    static T fetchAndStoreRelaxed(T &_q_value, T newValue)
+    static T fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
     {
         return __sync_lock_test_and_set(&_q_value, newValue);
     }
 
-    static T fetchAndStoreRelease(T &_q_value, T newValue)
+    static T fetchAndStoreRelease(T &_q_value, T newValue) Q_DECL_NOTHROW
     {
         __sync_synchronize();
         return __sync_lock_test_and_set(&_q_value, newValue);
     }
 
-    static T fetchAndStoreOrdered(T &_q_value, T newValue)
+    static T fetchAndStoreOrdered(T &_q_value, T newValue) Q_DECL_NOTHROW
     {
         return fetchAndStoreRelease(_q_value, newValue);
     }
 
     static
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
     {
         return __sync_fetch_and_add(&_q_value, valueToAdd * QAtomicAdditiveType<T>::AddScale);
     }
diff --git a/src/corelib/arch/qatomic_ia64.h b/src/corelib/arch/qatomic_ia64.h
index a2bca55..0bf3cf7 100644
--- a/src/corelib/arch/qatomic_ia64.h
+++ b/src/corelib/arch/qatomic_ia64.h
@@ -141,48 +141,48 @@ template<> struct QAtomicIntegerTraits<unsigned long long> { enum { IsInteger =
 template <int size> struct QBasicAtomicOps: QGenericAtomicOps<QBasicAtomicOps<size> >
 {
     template <typename T>
-    static void orderedMemoryFence(const T &);
+    static void orderedMemoryFence(const T &) Q_DECL_NOTHROW;
 
     template <typename T> static inline
-    T loadAcquire(const T &_q_value)
+    T loadAcquire(const T &_q_value) Q_DECL_NOTHROW
     {
         return *static_cast<const volatile T *>(&_q_value);
     }
 
     template <typename T> static inline
-    void storeRelease(T &_q_value, T newValue)
+    void storeRelease(T &_q_value, T newValue) Q_DECL_NOTHROW
     {
         *static_cast<volatile T *>(&_q_value) = newValue;
     }
-    static inline bool isReferenceCountingNative() { return true; }
-    static inline bool isReferenceCountingWaitFree() { return size == 4 || size == 8; }
-    template <typename T> static bool ref(T &_q_value);
-    template <typename T> static bool deref(T &_q_value);
-
-    static inline bool isTestAndSetNative() { return true; }
-    static inline bool isTestAndSetWaitFree() { return true; }
-    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue);
-    template <typename T> static bool testAndSetAcquire(T &_q_value, T expectedValue, T newValue);
-    template <typename T> static bool testAndSetRelease(T &_q_value, T expectedValue, T newValue);
-    template <typename T> static bool testAndSetOrdered(T &_q_value, T expectedValue, T newValue);
-
-    static inline bool isFetchAndStoreNative() { return true; }
-    static inline bool isFetchAndStoreWaitFree() { return true; }
-    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue);
-    template <typename T> static T fetchAndStoreAcquire(T &_q_value, T newValue);
-    template <typename T> static T fetchAndStoreRelease(T &_q_value, T newValue);
-    template <typename T> static T fetchAndStoreOrdered(T &_q_value, T newValue);
-
-    static inline bool isFetchAndAddNative() { return true; }
-    static inline bool isFetchAndAddWaitFree() { return false; }
+    static inline bool isReferenceCountingNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isReferenceCountingWaitFree() Q_DECL_NOTHROW { return size == 4 || size == 8; }
+    template <typename T> static bool ref(T &_q_value) Q_DECL_NOTHROW;
+    template <typename T> static bool deref(T &_q_value) Q_DECL_NOTHROW;
+
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return true; }
+    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
+    template <typename T> static bool testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
+    template <typename T> static bool testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
+    template <typename T> static bool testAndSetOrdered(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
+
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndStoreWaitFree() Q_DECL_NOTHROW { return true; }
+    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW;
+    template <typename T> static T fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW;
+    template <typename T> static T fetchAndStoreRelease(T &_q_value, T newValue) Q_DECL_NOTHROW;
+    template <typename T> static T fetchAndStoreOrdered(T &_q_value, T newValue) Q_DECL_NOTHROW;
+
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndAddWaitFree() Q_DECL_NOTHROW { return false; }
     template <typename T> static
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
     template <typename T> static
-    T fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
     template <typename T> static
-    T fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
     template <typename T> static
-    T fetchAndAddOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
 };
 
 template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
@@ -334,13 +334,13 @@ Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelease(qptrdiff valueTo
 #elif defined(Q_CC_GNU)
 
 template<int size> template <typename T> inline
-void QBasicAtomicOps<size>::orderedMemoryFence(const T &)
+void QBasicAtomicOps<size>::orderedMemoryFence(const T &) Q_DECL_NOTHROW
 {
     asm volatile("mf" ::: "memory");
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::ref(T &_q_value)
+bool QBasicAtomicOps<4>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("fetchadd4.acq %0=%1,1\n"
@@ -351,7 +351,7 @@ bool QBasicAtomicOps<4>::ref(T &_q_value)
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::deref(T &_q_value)
+bool QBasicAtomicOps<4>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("fetchadd4.rel %0=%1,-1\n"
@@ -362,7 +362,7 @@ bool QBasicAtomicOps<4>::deref(T &_q_value)
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::ref(T &_q_value)
+bool QBasicAtomicOps<8>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("fetchadd8.acq %0=%1,1\n"
@@ -373,7 +373,7 @@ bool QBasicAtomicOps<8>::ref(T &_q_value)
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::deref(T &_q_value)
+bool QBasicAtomicOps<8>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("fetchadd8.rel %0=%1,-1\n"
@@ -384,7 +384,7 @@ bool QBasicAtomicOps<8>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<1>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -397,7 +397,7 @@ bool QBasicAtomicOps<1>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<1>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -410,7 +410,7 @@ bool QBasicAtomicOps<1>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<2>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<2>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -423,7 +423,7 @@ bool QBasicAtomicOps<2>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<2>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<2>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -436,7 +436,7 @@ bool QBasicAtomicOps<2>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<4>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -449,7 +449,7 @@ bool QBasicAtomicOps<4>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<4>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -462,7 +462,7 @@ bool QBasicAtomicOps<4>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<8>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -475,7 +475,7 @@ bool QBasicAtomicOps<8>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<8>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("mov ar.ccv=%2\n"
@@ -488,7 +488,7 @@ bool QBasicAtomicOps<8>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<1>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("xchg1 %0=%1,%2\n"
@@ -499,7 +499,7 @@ T QBasicAtomicOps<1>::fetchAndStoreAcquire(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<2>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("xchg2 %0=%1,%2\n"
@@ -510,7 +510,7 @@ T QBasicAtomicOps<2>::fetchAndStoreAcquire(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<4>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("xchg4 %0=%1,%2\n"
@@ -521,7 +521,7 @@ T QBasicAtomicOps<4>::fetchAndStoreAcquire(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<8>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     T ret;
     asm volatile("xchg8 %0=%1,%2\n"
@@ -532,7 +532,7 @@ T QBasicAtomicOps<8>::fetchAndStoreAcquire(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<1>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -555,7 +555,7 @@ T QBasicAtomicOps<1>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<1>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -578,7 +578,7 @@ T QBasicAtomicOps<1>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<2>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -601,7 +601,7 @@ T QBasicAtomicOps<2>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<2>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -624,7 +624,7 @@ T QBasicAtomicOps<2>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<4>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -659,7 +659,7 @@ T QBasicAtomicOps<4>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<4>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -694,7 +694,7 @@ T QBasicAtomicOps<4>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<8>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -729,7 +729,7 @@ T QBasicAtomicOps<8>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<8>::fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T ret;
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
@@ -772,41 +772,41 @@ QT_END_INCLUDE_NAMESPACE
 #define FENCE (_Asm_fence)(_UP_CALL_FENCE | _UP_SYS_FENCE | _DOWN_CALL_FENCE | _DOWN_SYS_FENCE)
 
 template <int size> inline
-void QBasicAtomicOps<size>::orderedMemoryFence()
+void QBasicAtomicOps<size>::orderedMemoryFence() Q_DECL_NOTHROW
 {
     _Asm_mf(FENCE);
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::ref(T &_q_value)
+bool QBasicAtomicOps<4>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     return (T)_Asm_fetchadd((_Asm_fasz)_FASZ_W, (_Asm_sem)_SEM_ACQ,
                               &_q_value, 1, (_Asm_ldhint)_LDHINT_NONE, FENCE) != -1;
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::deref(T &_q_value)
+bool QBasicAtomicOps<4>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     return (T)_Asm_fetchadd((_Asm_fasz)_FASZ_W, (_Asm_sem)_SEM_REL,
                               &_q_value, -1, (_Asm_ldhint)_LDHINT_NONE, FENCE) != 1;
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::ref(T &_q_value)
+bool QBasicAtomicOps<8>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     return (T)_Asm_fetchadd((_Asm_fasz)_FASZ_D, (_Asm_sem)_SEM_ACQ,
                               &_q_value, 1, (_Asm_ldhint)_LDHINT_NONE, FENCE) != -1;
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::deref(T &_q_value)
+bool QBasicAtomicOps<8>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     return (T)_Asm_fetchadd((_Asm_fasz)_FASZ_D, (_Asm_sem)_SEM_REL,
                               &_q_value, -1, (_Asm_ldhint)_LDHINT_NONE, FENCE) != 1;
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<1>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (quint8)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_B, (_Asm_sem)_SEM_ACQ,
@@ -815,7 +815,7 @@ bool QBasicAtomicOps<1>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<1>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (quint8)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_B, (_Asm_sem)_SEM_REL,
@@ -824,7 +824,7 @@ bool QBasicAtomicOps<1>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<2>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<2>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (quint16)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_H, (_Asm_sem)_SEM_ACQ,
@@ -833,7 +833,7 @@ bool QBasicAtomicOps<2>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<2>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<2>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (quint16)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_H, (_Asm_sem)_SEM_REL,
@@ -842,7 +842,7 @@ bool QBasicAtomicOps<2>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<4>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (unsigned)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_W, (_Asm_sem)_SEM_ACQ,
@@ -851,7 +851,7 @@ bool QBasicAtomicOps<4>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<4>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (unsigned)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_W, (_Asm_sem)_SEM_REL,
@@ -860,7 +860,7 @@ bool QBasicAtomicOps<4>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<8>::testAndSetAcquire(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (quint64)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_D, (_Asm_sem)_SEM_ACQ,
@@ -869,7 +869,7 @@ bool QBasicAtomicOps<8>::testAndSetAcquire(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::testAndSetRelease(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<8>::testAndSetRelease(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     _Asm_mov_to_ar((_Asm_app_reg)_AREG_CCV, (quint64)expectedValue, FENCE);
     T ret = (T)_Asm_cmpxchg((_Asm_sz)_SZ_D, (_Asm_sem)_SEM_REL,
@@ -878,35 +878,35 @@ bool QBasicAtomicOps<8>::testAndSetRelease(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<1>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     return (T)_Asm_xchg((_Asm_sz)_SZ_B, &_q_value, (quint8)newValue,
                         (_Asm_ldhint)_LDHINT_NONE, FENCE);
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<2>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     return (T)_Asm_xchg((_Asm_sz)_SZ_H, &_q_value, (quint16)newValue,
                         (_Asm_ldhint)_LDHINT_NONE, FENCE);
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<4>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     return (T)_Asm_xchg((_Asm_sz)_SZ_W, &_q_value, (unsigned)newValue,
                         (_Asm_ldhint)_LDHINT_NONE, FENCE);
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndStoreAcquire(T &_q_value, T newValue)
+T QBasicAtomicOps<8>::fetchAndStoreAcquire(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     return (T)_Asm_xchg((_Asm_sz)_SZ_D, &_q_value, (quint64)newValue,
                         (_Asm_ldhint)_LDHINT_NONE, FENCE);
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<1>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
     // implement the test-and-set loop
@@ -921,7 +921,7 @@ T QBasicAtomicOps<1>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     // implement the test-and-set loop
     register T old, ret;
@@ -935,7 +935,7 @@ T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<2>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
     // implement the test-and-set loop
@@ -950,7 +950,7 @@ T QBasicAtomicOps<2>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<2>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<2>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     // implement the test-and-set loop
     register T old, ret;
@@ -964,7 +964,7 @@ T QBasicAtomicOps<2>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<4>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
     // implement the test-and-set loop
@@ -979,7 +979,7 @@ T QBasicAtomicOps<4>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     // implement the test-and-set loop
     register T old, ret;
@@ -993,7 +993,7 @@ T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<8>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     valueToAdd *= QAtomicAdditiveType<T>::AddScale;
     // implement the test-and-set loop
@@ -1008,7 +1008,7 @@ T QBasicAtomicOps<8>::fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveTy
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     // implement the test-and-set loop
     register T old, ret;
@@ -1024,59 +1024,59 @@ T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 #endif
 
 template<int size> template<typename T> inline
-bool QBasicAtomicOps<size>::ref(T &_q_value)
+bool QBasicAtomicOps<size>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     // no fetchadd for 1 or 2 bytes
     return fetchAndAddRelaxed(_q_value, 1) == -1;
 }
 
 template<int size> template<typename T> inline
-bool QBasicAtomicOps<size>::deref(T &_q_value)
+bool QBasicAtomicOps<size>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     // no fetchadd for 1 or 2 bytes
     return fetchAndAddRelaxed(_q_value, -1) == 1;
 }
 
 template<int size> template <typename T> inline
-bool QBasicAtomicOps<size>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<size>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     return testAndSetAcquire(_q_value, expectedValue, newValue);
 }
 
 template<int size> template <typename T> inline
-bool QBasicAtomicOps<size>::testAndSetOrdered(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<size>::testAndSetOrdered(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     orderedMemoryFence(_q_value);
     return testAndSetAcquire(_q_value, expectedValue, newValue);
 }
 
 template<int size> template <typename T> inline
-T QBasicAtomicOps<size>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<size>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     return fetchAndStoreAcquire(_q_value, newValue);
 }
 
 template<int size> template <typename T> inline
-T QBasicAtomicOps<size>::fetchAndStoreRelease(T &_q_value, T newValue)
+T QBasicAtomicOps<size>::fetchAndStoreRelease(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     orderedMemoryFence(_q_value);
     return fetchAndStoreAcquire(_q_value, newValue);
 }
 
 template<int size> template <typename T> inline
-T QBasicAtomicOps<size>::fetchAndStoreOrdered(T &_q_value, T newValue)
+T QBasicAtomicOps<size>::fetchAndStoreOrdered(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     return fetchAndStoreRelease(_q_value, newValue);
 }
 
 template<int size> template <typename T> inline
-T QBasicAtomicOps<size>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<size>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     return fetchAndAddAcquire(_q_value, valueToAdd);
 }
 
 template<int size> template <typename T> inline
-T QBasicAtomicOps<size>::fetchAndAddOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<size>::fetchAndAddOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     orderedMemoryFence(_q_value);
     return fetchAndAddRelease(_q_value, valueToAdd);
diff --git a/src/corelib/arch/qatomic_mips.h b/src/corelib/arch/qatomic_mips.h
index 116906a..9565d37 100644
--- a/src/corelib/arch/qatomic_mips.h
+++ b/src/corelib/arch/qatomic_mips.h
@@ -78,26 +78,26 @@ template<> struct QAtomicIntegerTraits<unsigned int> { enum { IsInteger = 1 }; }
 template <int size> struct QBasicAtomicOps: QGenericAtomicOps<QBasicAtomicOps<size> >
 {
     template <typename T>
-    static void acquireMemoryFence(const T &);
+    static void acquireMemoryFence(const T &) Q_DECL_NOTHROW;
     template <typename T>
-    static void releaseMemoryFence(const T &);
+    static void releaseMemoryFence(const T &) Q_DECL_NOTHROW;
     template <typename T>
-    static void orderedMemoryFence(const T &);
+    static void orderedMemoryFence(const T &) Q_DECL_NOTHROW;
 
-    static inline bool isReferenceCountingNative() { return true; }
-    template <typename T> static bool ref(T &_q_value);
-    template <typename T> static bool deref(T &_q_value);
+    static inline bool isReferenceCountingNative() Q_DECL_NOTHROW { return true; }
+    template <typename T> static bool ref(T &_q_value) Q_DECL_NOTHROW;
+    template <typename T> static bool deref(T &_q_value) Q_DECL_NOTHROW;
 
-    static inline bool isTestAndSetNative() { return true; }
-    static inline bool isTestAndSetWaitFree() { return false; }
-    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue);
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
+    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndStoreNative() { return true; }
-    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue);
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return true; }
+    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndAddNative() { return true; }
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return true; }
     template <typename T> static
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
 };
 
 template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
@@ -113,25 +113,25 @@ template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
 #endif
 
 template <int size> template <typename T> inline
-void QBasicAtomicOps<size>::acquireMemoryFence(const T &)
+void QBasicAtomicOps<size>::acquireMemoryFence(const T &) Q_DECL_NOTHROW
 {
     asm volatile ("sync 0x11" ::: "memory");
 }
 
 template <int size> template <typename T> inline
-void QBasicAtomicOps<size>::releaseMemoryFence(const T &)
+void QBasicAtomicOps<size>::releaseMemoryFence(const T &) Q_DECL_NOTHROW
 {
     asm volatile ("sync 0x12" ::: "memory");
 }
 
 template <int size> template <typename T> inline
-void QBasicAtomicOps<size>::orderedMemoryFence(const T &)
+void QBasicAtomicOps<size>::orderedMemoryFence(const T &) Q_DECL_NOTHROW
 {
     asm volatile ("sync 0" ::: "memory");
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::ref(T &_q_value)
+bool QBasicAtomicOps<4>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -150,7 +150,7 @@ bool QBasicAtomicOps<4>::ref(T &_q_value)
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::deref(T &_q_value)
+bool QBasicAtomicOps<4>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -169,7 +169,7 @@ bool QBasicAtomicOps<4>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     register T result;
     register T tempValue;
@@ -193,7 +193,7 @@ bool QBasicAtomicOps<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T tempValue;
@@ -212,7 +212,7 @@ T QBasicAtomicOps<4>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -242,7 +242,7 @@ template<> struct QAtomicIntegerTraits<long long> { enum { IsInteger = 1 }; };
 template<> struct QAtomicIntegerTraits<unsigned long long > { enum { IsInteger = 1 }; };
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::ref(T &_q_value)
+bool QBasicAtomicOps<8>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -261,7 +261,7 @@ bool QBasicAtomicOps<8>::ref(T &_q_value)
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::deref(T &_q_value)
+bool QBasicAtomicOps<8>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
@@ -280,7 +280,7 @@ bool QBasicAtomicOps<8>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<8>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     register T result;
     register T tempValue;
@@ -304,7 +304,7 @@ bool QBasicAtomicOps<8>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<8>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T tempValue;
@@ -323,7 +323,7 @@ T QBasicAtomicOps<8>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<8>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     register T originalValue;
     register T newValue;
diff --git a/src/corelib/arch/qatomic_msvc.h b/src/corelib/arch/qatomic_msvc.h
index 3e0923b..a7de122 100644
--- a/src/corelib/arch/qatomic_msvc.h
+++ b/src/corelib/arch/qatomic_msvc.h
@@ -276,49 +276,49 @@ struct QAtomicOpsBySize<4> : QGenericAtomicOps<QAtomicOpsBySize<4> >
     // The 32-bit Interlocked*() API takes parameters as longs.
     typedef long Type;
 
-    static inline bool isReferenceCountingNative() { return true; }
-    static inline bool isReferenceCountingWaitFree() { return true; }
-    static bool ref(long &_q_value);
-    static bool deref(long &_q_value);
-
-    static inline bool isTestAndSetNative() { return true; }
-    static inline bool isTestAndSetWaitFree() { return true; }
-    static bool testAndSetRelaxed(long &_q_value, long expectedValue, long newValue);
-
-    static inline bool isFetchAndStoreNative() { return true; }
-    static inline bool isFetchAndStoreWaitFree() { return true; }
-    static long fetchAndStoreRelaxed(long &_q_value, long newValue);
-
-    static inline bool isFetchAndAddNative() { return true; }
-    static inline bool isFetchAndAddWaitFree() { return true; }
-    static long fetchAndAddRelaxed(long &_q_value, QAtomicAdditiveType<long>::AdditiveT valueToAdd);
+    static inline bool isReferenceCountingNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isReferenceCountingWaitFree() Q_DECL_NOTHROW { return true; }
+    static bool ref(long &_q_value) Q_DECL_NOTHROW;
+    static bool deref(long &_q_value) Q_DECL_NOTHROW;
+
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return true; }
+    static bool testAndSetRelaxed(long &_q_value, long expectedValue, long newValue) Q_DECL_NOTHROW;
+
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndStoreWaitFree() Q_DECL_NOTHROW { return true; }
+    static long fetchAndStoreRelaxed(long &_q_value, long newValue) Q_DECL_NOTHROW;
+
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndAddWaitFree() Q_DECL_NOTHROW { return true; }
+    static long fetchAndAddRelaxed(long &_q_value, QAtomicAdditiveType<long>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
 };
 
 template <typename T>
 struct QAtomicOps : QAtomicOpsBySize<sizeof(T)>
 { };
 
-inline bool QAtomicOpsBySize<4>::ref(long &_q_value)
+inline bool QAtomicOpsBySize<4>::ref(long &_q_value) Q_DECL_NOTHROW
 {
     return QT_INTERLOCKED_INCREMENT(&_q_value) != 0;
 }
 
-inline bool QAtomicOpsBySize<4>::deref(long &_q_value)
+inline bool QAtomicOpsBySize<4>::deref(long &_q_value) Q_DECL_NOTHROW
 {
     return QT_INTERLOCKED_DECREMENT(&_q_value) != 0;
 }
 
-inline bool QAtomicOpsBySize<4>::testAndSetRelaxed(long &_q_value, long expectedValue, long newValue)
+inline bool QAtomicOpsBySize<4>::testAndSetRelaxed(long &_q_value, long expectedValue, long newValue) Q_DECL_NOTHROW
 {
     return QT_INTERLOCKED_COMPARE_EXCHANGE(&_q_value, newValue, expectedValue) == expectedValue;
 }
 
-inline long QAtomicOpsBySize<4>::fetchAndStoreRelaxed(long &_q_value, long newValue)
+inline long QAtomicOpsBySize<4>::fetchAndStoreRelaxed(long &_q_value, long newValue) Q_DECL_NOTHROW
 {
     return QT_INTERLOCKED_EXCHANGE(&_q_value, newValue);
 }
 
-inline long QAtomicOpsBySize<4>::fetchAndAddRelaxed(long &_q_value, QAtomicAdditiveType<long>::AdditiveT valueToAdd)
+inline long QAtomicOpsBySize<4>::fetchAndAddRelaxed(long &_q_value, QAtomicAdditiveType<long>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     return QT_INTERLOCKED_EXCHANGE_ADD(&_q_value, valueToAdd * QAtomicAdditiveType<long>::AddScale);
 }
@@ -329,33 +329,33 @@ struct QAtomicOps<T *> : QGenericAtomicOps<QAtomicOps<T *> >
 {
     typedef T *Type;
 
-    static inline bool isTestAndSetNative() { return true; }
-    static inline bool isTestAndSetWaitFree() { return true; }
-    static bool testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue);
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return true; }
+    static bool testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndStoreNative() { return true; }
-    static inline bool isFetchAndStoreWaitFree() { return true; }
-    static T *fetchAndStoreRelaxed(T *&_q_value, T *newValue);
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndStoreWaitFree() Q_DECL_NOTHROW { return true; }
+    static T *fetchAndStoreRelaxed(T *&_q_value, T *newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndAddNative() { return true; }
-    static inline bool isFetchAndAddWaitFree() { return true; }
-    static T *fetchAndAddRelaxed(T *&_q_value, qptrdiff valueToAdd);
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndAddWaitFree() Q_DECL_NOTHROW { return true; }
+    static T *fetchAndAddRelaxed(T *&_q_value, qptrdiff valueToAdd) Q_DECL_NOTHROW;
 };
 
 template <typename T>
-inline bool QAtomicOps<T *>::testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue)
+inline bool QAtomicOps<T *>::testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue) Q_DECL_NOTHROW
 {
     return QT_INTERLOCKED_COMPARE_EXCHANGE_POINTER(&_q_value, newValue, expectedValue) == expectedValue;
 }
 
 template <typename T>
-inline T *QAtomicOps<T *>::fetchAndStoreRelaxed(T *&_q_value, T *newValue)
+inline T *QAtomicOps<T *>::fetchAndStoreRelaxed(T *&_q_value, T *newValue) Q_DECL_NOTHROW
 {
     return reinterpret_cast<T *>(QT_INTERLOCKED_EXCHANGE_POINTER(&_q_value, newValue));
 }
 
 template <typename T>
-inline T *QAtomicOps<T *>::fetchAndAddRelaxed(T *&_q_value, qptrdiff valueToAdd)
+inline T *QAtomicOps<T *>::fetchAndAddRelaxed(T *&_q_value, qptrdiff valueToAdd) Q_DECL_NOTHROW
 {
     return reinterpret_cast<T *>(QT_INTERLOCKED_EXCHANGE_ADD_POINTER(&_q_value, valueToAdd * sizeof(T)));
 }
diff --git a/src/corelib/arch/qatomic_unix.cpp b/src/corelib/arch/qatomic_unix.cpp
index a709be3..cc929bf 100644
--- a/src/corelib/arch/qatomic_unix.cpp
+++ b/src/corelib/arch/qatomic_unix.cpp
@@ -52,7 +52,7 @@ QT_BEGIN_NAMESPACE
 static pthread_mutex_t qAtomicMutex = PTHREAD_MUTEX_INITIALIZER;
 
 Q_CORE_EXPORT
-bool QAtomicOps<int>::testAndSetRelaxed(int &_q_value, int expectedValue, int newValue)
+bool QAtomicOps<int>::testAndSetRelaxed(int &_q_value, int expectedValue, int newValue) Q_DECL_NOTHROW
 {
     bool returnValue = false;
     pthread_mutex_lock(&qAtomicMutex);
@@ -65,7 +65,7 @@ bool QAtomicOps<int>::testAndSetRelaxed(int &_q_value, int expectedValue, int ne
 }
 
 Q_CORE_EXPORT
-bool QAtomicOps<void *>::testAndSetRelaxed(void *&_q_value, void *expectedValue, void *newValue)
+bool QAtomicOps<void *>::testAndSetRelaxed(void *&_q_value, void *expectedValue, void *newValue) Q_DECL_NOTHROW
 {
     bool returnValue = false;
     pthread_mutex_lock(&qAtomicMutex);
diff --git a/src/corelib/arch/qatomic_unix.h b/src/corelib/arch/qatomic_unix.h
index 3dc168c..3450596 100644
--- a/src/corelib/arch/qatomic_unix.h
+++ b/src/corelib/arch/qatomic_unix.h
@@ -76,9 +76,9 @@ struct QAtomicOps<int> : QGenericAtomicOps<QAtomicOps<int> >
 {
     typedef int Type;
 
-    static inline bool isTestAndSetNative() { return false; }
-    static inline bool isTestAndSetWaitFree() { return false; }
-    Q_CORE_EXPORT static bool testAndSetRelaxed(int &_q_value, int expectedValue, int newValue);
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
+    Q_CORE_EXPORT static bool testAndSetRelaxed(int &_q_value, int expectedValue, int newValue) Q_DECL_NOTHROW;
 };
 
 template <>
@@ -86,9 +86,9 @@ struct QAtomicOps<void *> : QGenericAtomicOps<QAtomicOps<void *> >
 {
     typedef void *Type;
 
-    static inline bool isTestAndSetNative() { return false; }
-    static inline bool isTestAndSetWaitFree() { return false; }
-    Q_CORE_EXPORT static bool testAndSetRelaxed(void *&_q_value, void *expectedValue, void *newValue);
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
+    Q_CORE_EXPORT static bool testAndSetRelaxed(void *&_q_value, void *expectedValue, void *newValue) Q_DECL_NOTHROW;
 };
 
 template <typename T>
@@ -99,9 +99,9 @@ struct QAtomicOps<T *> : QGenericAtomicOps<QAtomicOps<T *> >
     // helper to strip cv qualifiers
     static inline void *nocv(const T *p) { return const_cast<void *>(static_cast<const volatile void *>(p)); }
 
-    static inline bool isTestAndSetNative() { return false; }
-    static inline bool isTestAndSetWaitFree() { return false; }
-    static inline bool testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue)
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return false; }
+    static inline bool testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue) Q_DECL_NOTHROW
     {
         // forward to the void* specialization
         void *voidp = nocv(_q_value);
diff --git a/src/corelib/arch/qatomic_x86.h b/src/corelib/arch/qatomic_x86.h
index 5212e80..196073a 100644
--- a/src/corelib/arch/qatomic_x86.h
+++ b/src/corelib/arch/qatomic_x86.h
@@ -97,23 +97,23 @@ template<> struct QAtomicIntegerTraits<unsigned int> { enum { IsInteger = 1 }; }
 
 template <int size> struct QBasicAtomicOps: QGenericAtomicOps<QBasicAtomicOps<size> >
 {
-    static inline bool isReferenceCountingNative() { return true; }
-    static inline bool isReferenceCountingWaitFree() { return true; }
-    template <typename T> static bool ref(T &_q_value);
-    template <typename T> static bool deref(T &_q_value);
+    static inline bool isReferenceCountingNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isReferenceCountingWaitFree() Q_DECL_NOTHROW { return true; }
+    template <typename T> static bool ref(T &_q_value) Q_DECL_NOTHROW;
+    template <typename T> static bool deref(T &_q_value) Q_DECL_NOTHROW;
 
-    static inline bool isTestAndSetNative() { return true; }
-    static inline bool isTestAndSetWaitFree() { return true; }
-    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue);
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return true; }
+    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndStoreNative() { return true; }
-    static inline bool isFetchAndStoreWaitFree() { return true; }
-    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue);
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndStoreWaitFree() Q_DECL_NOTHROW { return true; }
+    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW;
 
-    static inline bool isFetchAndAddNative() { return true; }
-    static inline bool isFetchAndAddWaitFree() { return true; }
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isFetchAndAddWaitFree() Q_DECL_NOTHROW { return true; }
     template <typename T> static
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd);
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW;
 };
 
 template <typename T> struct QAtomicOps : QBasicAtomicOps<sizeof(T)>
@@ -162,7 +162,7 @@ template<> struct QAtomicIntegerTraits<unsigned long long> { enum { IsInteger =
  */
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<1>::ref(T &_q_value)
+bool QBasicAtomicOps<1>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -175,7 +175,7 @@ bool QBasicAtomicOps<1>::ref(T &_q_value)
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<2>::ref(T &_q_value)
+bool QBasicAtomicOps<2>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -188,7 +188,7 @@ bool QBasicAtomicOps<2>::ref(T &_q_value)
 }
 
 template<> template<typename T> inline
-bool QBasicAtomicOps<4>::ref(T &_q_value)
+bool QBasicAtomicOps<4>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -201,7 +201,7 @@ bool QBasicAtomicOps<4>::ref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::deref(T &_q_value)
+bool QBasicAtomicOps<1>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -214,7 +214,7 @@ bool QBasicAtomicOps<1>::deref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<2>::deref(T &_q_value)
+bool QBasicAtomicOps<2>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -226,7 +226,7 @@ bool QBasicAtomicOps<2>::deref(T &_q_value)
     return ret != 0;
 }
 template<> template <typename T> inline
-bool QBasicAtomicOps<4>::deref(T &_q_value)
+bool QBasicAtomicOps<4>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -239,7 +239,7 @@ bool QBasicAtomicOps<4>::deref(T &_q_value)
 }
 
 template<int size> template <typename T> inline
-bool QBasicAtomicOps<size>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<size>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -252,7 +252,7 @@ bool QBasicAtomicOps<size>::testAndSetRelaxed(T &_q_value, T expectedValue, T ne
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<1>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+bool QBasicAtomicOps<1>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -265,7 +265,7 @@ bool QBasicAtomicOps<1>::testAndSetRelaxed(T &_q_value, T expectedValue, T newVa
 }
 
 template<int size> template <typename T> inline
-T QBasicAtomicOps<size>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<size>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     asm volatile("xchg %0,%1"
                  : "=r" (newValue), "+m" (_q_value)
@@ -275,7 +275,7 @@ T QBasicAtomicOps<size>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndStoreRelaxed(T &_q_value, T newValue)
+T QBasicAtomicOps<1>::fetchAndStoreRelaxed(T &_q_value, T newValue) Q_DECL_NOTHROW
 {
     asm volatile("xchg %0,%1"
                  : "=q" (newValue), "+m" (_q_value)
@@ -285,7 +285,7 @@ T QBasicAtomicOps<1>::fetchAndStoreRelaxed(T &_q_value, T newValue)
 }
 
 template<int size> template <typename T> inline
-T QBasicAtomicOps<size>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<size>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T result;
     asm volatile("lock\n"
@@ -297,7 +297,7 @@ T QBasicAtomicOps<size>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiv
 }
 
 template<> template <typename T> inline
-T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
 {
     T result;
     asm volatile("lock\n"
@@ -353,7 +353,7 @@ T QBasicAtomicOps<1>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveTy
 #ifdef Q_PROCESSOR_X86_64
 // native support for 64-bit types
 template<> template<typename T> inline
-bool QBasicAtomicOps<8>::ref(T &_q_value)
+bool QBasicAtomicOps<8>::ref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -366,7 +366,7 @@ bool QBasicAtomicOps<8>::ref(T &_q_value)
 }
 
 template<> template <typename T> inline
-bool QBasicAtomicOps<8>::deref(T &_q_value)
+bool QBasicAtomicOps<8>::deref(T &_q_value) Q_DECL_NOTHROW
 {
     unsigned char ret;
     asm volatile("lock\n"
@@ -381,10 +381,10 @@ bool QBasicAtomicOps<8>::deref(T &_q_value)
 // i386 architecture, emulate 64-bit support via cmpxchg8b
 template <> struct QBasicAtomicOps<8>: QGenericAtomicOps<QBasicAtomicOps<8> >
 {
-    static inline bool isTestAndSetNative() { return true; }
-    static inline bool isTestAndSetWaitFree() { return true; }
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW { return true; }
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW { return true; }
     template <typename T> static inline
-    bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue)
+    bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) Q_DECL_NOTHROW
     {
 #ifdef __PIC__
 # define EBX_reg "r"
diff --git a/src/corelib/thread/qgenericatomic.h b/src/corelib/thread/qgenericatomic.h
index c0e8252..46f373b 100644
--- a/src/corelib/thread/qgenericatomic.h
+++ b/src/corelib/thread/qgenericatomic.h
@@ -80,32 +80,32 @@ template <typename BaseClass> struct QGenericAtomicOps
 {
     template <typename T> struct AtomicType { typedef T Type; typedef T *PointerType; };
 
-    template <typename T> static void acquireMemoryFence(const T &_q_value)
+    template <typename T> static void acquireMemoryFence(const T &_q_value) Q_DECL_NOTHROW
     {
         BaseClass::orderedMemoryFence(_q_value);
     }
-    template <typename T> static void releaseMemoryFence(const T &_q_value)
+    template <typename T> static void releaseMemoryFence(const T &_q_value) Q_DECL_NOTHROW
     {
         BaseClass::orderedMemoryFence(_q_value);
     }
-    template <typename T> static void orderedMemoryFence(const T &)
+    template <typename T> static void orderedMemoryFence(const T &) Q_DECL_NOTHROW
     {
     }
 
     template <typename T> static inline always_inline
-    T load(const T &_q_value)
+    T load(const T &_q_value) Q_DECL_NOTHROW
     {
         return _q_value;
     }
 
     template <typename T, typename X> static inline always_inline
-    void store(T &_q_value, X newValue)
+    void store(T &_q_value, X newValue) Q_DECL_NOTHROW
     {
         _q_value = newValue;
     }
 
     template <typename T> static inline always_inline
-    T loadAcquire(const T &_q_value)
+    T loadAcquire(const T &_q_value) Q_DECL_NOTHROW
     {
         T tmp = *static_cast<const volatile T *>(&_q_value);
         BaseClass::acquireMemoryFence(_q_value);
@@ -113,24 +113,24 @@ template <typename BaseClass> struct QGenericAtomicOps
     }
 
     template <typename T, typename X> static inline always_inline
-    void storeRelease(T &_q_value, X newValue)
+    void storeRelease(T &_q_value, X newValue) Q_DECL_NOTHROW
     {
         BaseClass::releaseMemoryFence(_q_value);
         *static_cast<volatile T *>(&_q_value) = newValue;
     }
 
-    static inline bool isReferenceCountingNative()
+    static inline bool isReferenceCountingNative() Q_DECL_NOTHROW
     { return BaseClass::isFetchAndAddNative(); }
-    static inline bool isReferenceCountingWaitFree()
+    static inline bool isReferenceCountingWaitFree() Q_DECL_NOTHROW
     { return BaseClass::isFetchAndAddWaitFree(); }
     template <typename T> static inline always_inline
-    bool ref(T &_q_value)
+    bool ref(T &_q_value) Q_DECL_NOTHROW
     {
         return BaseClass::fetchAndAddRelaxed(_q_value, 1) != T(-1);
     }
 
     template <typename T> static inline always_inline
-    bool deref(T &_q_value)
+    bool deref(T &_q_value) Q_DECL_NOTHROW
     {
          return BaseClass::fetchAndAddRelaxed(_q_value, -1) != 1;
     }
@@ -138,14 +138,14 @@ template <typename BaseClass> struct QGenericAtomicOps
 #if 0
     // These functions have no default implementation
     // Archictectures must implement them
-    static inline bool isTestAndSetNative();
-    static inline bool isTestAndSetWaitFree();
+    static inline bool isTestAndSetNative() Q_DECL_NOTHROW;
+    static inline bool isTestAndSetWaitFree() Q_DECL_NOTHROW;
     template <typename T, typename X> static inline
-    bool testAndSetRelaxed(T &_q_value, X expectedValue, X newValue);
+    bool testAndSetRelaxed(T &_q_value, X expectedValue, X newValue) Q_DECL_NOTHROW;
 #endif
 
     template <typename T, typename X> static inline always_inline
-    bool testAndSetAcquire(T &_q_value, X expectedValue, X newValue)
+    bool testAndSetAcquire(T &_q_value, X expectedValue, X newValue) Q_DECL_NOTHROW
     {
         bool tmp = BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
         BaseClass::acquireMemoryFence(_q_value);
@@ -153,24 +153,24 @@ template <typename BaseClass> struct QGenericAtomicOps
     }
 
     template <typename T, typename X> static inline always_inline
-    bool testAndSetRelease(T &_q_value, X expectedValue, X newValue)
+    bool testAndSetRelease(T &_q_value, X expectedValue, X newValue) Q_DECL_NOTHROW
     {
         BaseClass::releaseMemoryFence(_q_value);
         return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
     }
 
     template <typename T, typename X> static inline always_inline
-    bool testAndSetOrdered(T &_q_value, X expectedValue, X newValue)
+    bool testAndSetOrdered(T &_q_value, X expectedValue, X newValue) Q_DECL_NOTHROW
     {
         BaseClass::orderedMemoryFence(_q_value);
         return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
     }
 
-    static inline bool isFetchAndStoreNative() { return false; }
-    static inline bool isFetchAndStoreWaitFree() { return false; }
+    static inline bool isFetchAndStoreNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isFetchAndStoreWaitFree() Q_DECL_NOTHROW { return false; }
 
     template <typename T, typename X> static inline always_inline
-    T fetchAndStoreRelaxed(T &_q_value, X newValue)
+    T fetchAndStoreRelaxed(T &_q_value, X newValue) Q_DECL_NOTHROW
     {
         // implement fetchAndStore on top of testAndSet
         Q_FOREVER {
@@ -181,7 +181,7 @@ template <typename BaseClass> struct QGenericAtomicOps
     }
 
     template <typename T, typename X> static inline always_inline
-    T fetchAndStoreAcquire(T &_q_value, X newValue)
+    T fetchAndStoreAcquire(T &_q_value, X newValue) Q_DECL_NOTHROW
     {
         T tmp = BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
         BaseClass::acquireMemoryFence(_q_value);
@@ -189,23 +189,23 @@ template <typename BaseClass> struct QGenericAtomicOps
     }
 
     template <typename T, typename X> static inline always_inline
-    T fetchAndStoreRelease(T &_q_value, X newValue)
+    T fetchAndStoreRelease(T &_q_value, X newValue) Q_DECL_NOTHROW
     {
         BaseClass::releaseMemoryFence(_q_value);
         return BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
     }
 
     template <typename T, typename X> static inline always_inline
-    T fetchAndStoreOrdered(T &_q_value, X newValue)
+    T fetchAndStoreOrdered(T &_q_value, X newValue) Q_DECL_NOTHROW
     {
         BaseClass::orderedMemoryFence(_q_value);
         return BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
     }
 
-    static inline bool isFetchAndAddNative() { return false; }
-    static inline bool isFetchAndAddWaitFree() { return false; }
+    static inline bool isFetchAndAddNative() Q_DECL_NOTHROW { return false; }
+    static inline bool isFetchAndAddWaitFree() Q_DECL_NOTHROW { return false; }
     template <typename T> static inline always_inline
-    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
     {
         // implement fetchAndAdd on top of testAndSet
         Q_FOREVER {
@@ -216,7 +216,7 @@ template <typename BaseClass> struct QGenericAtomicOps
     }
 
     template <typename T> static inline always_inline
-    T fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+    T fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
     {
         T tmp = BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
         BaseClass::acquireMemoryFence(_q_value);
@@ -224,14 +224,14 @@ template <typename BaseClass> struct QGenericAtomicOps
     }
 
     template <typename T> static inline always_inline
-    T fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+    T fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
     {
         BaseClass::releaseMemoryFence(_q_value);
         return BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
     }
 
     template <typename T> static inline always_inline
-    T fetchAndAddOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd)
+    T fetchAndAddOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) Q_DECL_NOTHROW
     {
         BaseClass::orderedMemoryFence(_q_value);
         return BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);