diff --git a/bin/rename-qtdeclarative-symbols.sh b/bin/rename-qtdeclarative-symbols.sh
index 0d521dd..c9a7012 100755
--- a/bin/rename-qtdeclarative-symbols.sh
+++ b/bin/rename-qtdeclarative-symbols.sh
@@ -154,8 +154,6 @@ QML_SYMBOLS="\
     QDeclarativeGuardedContextData
     QDeclarativeGuardImpl
     QDeclarativeHandlingSignalProfiler
-    QDeclarativeImageProvider
-    QDeclarativeImageProviderPrivate
     QDeclarativeImportDatabase
     QDeclarativeImportedNamespace
     QDeclarativeImports
@@ -319,6 +317,8 @@ QUICK_SYMBOLS="\
     QDeclarativeGestureAreaParser
     QDeclarativeGestureAreaPrivate
     QDeclarativeGraphics
+    QDeclarativeImageProvider
+    QDeclarativeImageProviderPrivate
     QDeclarativeItem
     QDeclarativeItemAccessor
     QDeclarativeItemChangeListener
diff --git a/src/qml/qml/qml.pri b/src/qml/qml/qml.pri
index 0ce7c7e..b389763 100644
--- a/src/qml/qml/qml.pri
+++ b/src/qml/qml/qml.pri
@@ -40,7 +40,6 @@ SOURCES += \
     $$PWD/qqmltypenamecache.cpp \
     $$PWD/qqmlscriptstring.cpp \
     $$PWD/qquickworkerscript.cpp \
-    $$PWD/qqmlimageprovider.cpp \
     $$PWD/qqmlnetworkaccessmanagerfactory.cpp \
     $$PWD/qqmldirparser.cpp \
     $$PWD/qqmlextensionplugin.cpp \
@@ -106,7 +105,6 @@ HEADERS += \
     $$PWD/qqmlscriptstring.h \
     $$PWD/qquickworkerscript_p.h \
     $$PWD/qqmlguard_p.h \
-    $$PWD/qqmlimageprovider.h \
     $$PWD/qqmlnetworkaccessmanagerfactory.h \
     $$PWD/qqmldirparser_p.h \
     $$PWD/qqmlextensioninterface.h \
diff --git a/src/qml/qml/qqmlengine.cpp b/src/qml/qml/qqmlengine.cpp
index ee5a0c9..54c9d04 100644
--- a/src/qml/qml/qqmlengine.cpp
+++ b/src/qml/qml/qqmlengine.cpp
@@ -60,7 +60,6 @@
 #include "qquickworkerscript_p.h"
 #include "qqmlcomponent_p.h"
 #include "qqmlnetworkaccessmanagerfactory.h"
-#include "qqmlimageprovider.h"
 #include "qqmldirparser_p.h"
 #include "qqmlextensioninterface.h"
 #include "qqmllist_p.h"
@@ -181,6 +180,12 @@ void QQmlEnginePrivate::defineModule()
     qmlRegisterUncreatableType<QQmlLocale>("QtQuick",2,0,"Locale",QQmlEngine::tr("Locale cannot be instantiated.  Use Qt.locale()"));
 }
 
+
+QQmlImageProviderBase::~QQmlImageProviderBase()
+{
+}
+
+
 /*!
 \qmlclass Qt QQmlEnginePrivate
   \ingroup qml-utility-elements
@@ -672,27 +677,29 @@ QNetworkAccessManager *QQmlEngine::networkAccessManager() const
   takes ownership of \a provider.
 
   Image providers enable support for pixmap and threaded image
-  requests. See the QQmlImageProvider documentation for details on
+  requests. See the QQuickImageProvider documentation for details on
   implementing and using image providers.
 
   All required image providers should be added to the engine before any
   QML sources files are loaded.
 
-  \sa removeImageProvider()
+  \sa removeImageProvider(), QQuickImageProvider
 */
-void QQmlEngine::addImageProvider(const QString &providerId, QQmlImageProvider *provider)
+void QQmlEngine::addImageProvider(const QString &providerId, QQmlImageProviderBase *provider)
 {
     Q_D(QQmlEngine);
     QMutexLocker locker(&d->mutex);
-    d->imageProviders.insert(providerId.toLower(), QSharedPointer<QQmlImageProvider>(provider));
+    d->imageProviders.insert(providerId.toLower(), QSharedPointer<QQmlImageProviderBase>(provider));
 }
 
 /*!
-  Returns the QQmlImageProvider set for \a providerId.
+  Returns the image provider set for \a providerId.
 
   Returns the provider if it was found; otherwise returns 0.
+
+  \sa QQuickImageProvider
 */
-QQmlImageProvider *QQmlEngine::imageProvider(const QString &providerId) const
+QQmlImageProviderBase *QQmlEngine::imageProvider(const QString &providerId) const
 {
     Q_D(const QQmlEngine);
     QMutexLocker locker(&d->mutex);
@@ -700,9 +707,9 @@ QQmlImageProvider *QQmlEngine::imageProvider(const QString &providerId) const
 }
 
 /*!
-  Removes the QQmlImageProvider for \a providerId.
+  Removes the image provider for \a providerId.
 
-  \sa addImageProvider()
+  \sa addImageProvider(), QQuickImageProvider
 */
 void QQmlEngine::removeImageProvider(const QString &providerId)
 {
@@ -711,54 +718,6 @@ void QQmlEngine::removeImageProvider(const QString &providerId)
     d->imageProviders.take(providerId);
 }
 
-QQmlImageProvider::ImageType QQmlEnginePrivate::getImageProviderType(const QUrl &url)
-{
-    QMutexLocker locker(&mutex);
-    QSharedPointer<QQmlImageProvider> provider = imageProviders.value(url.host());
-    locker.unlock();
-    if (provider)
-        return provider->imageType();
-    return QQmlImageProvider::Invalid;
-}
-
-QQuickTextureFactory *QQmlEnginePrivate::getTextureFromProvider(const QUrl &url, QSize *size, const QSize& req_size)
-{
-    QMutexLocker locker(&mutex);
-    QSharedPointer<QQmlImageProvider> provider = imageProviders.value(url.host());
-    locker.unlock();
-    if (provider) {
-        QString imageId = url.toString(QUrl::RemoveScheme | QUrl::RemoveAuthority).mid(1);
-        return provider->requestTexture(imageId, size, req_size);
-    }
-    return 0;
-}
-
-QImage QQmlEnginePrivate::getImageFromProvider(const QUrl &url, QSize *size, const QSize& req_size)
-{
-    QMutexLocker locker(&mutex);
-    QImage image;
-    QSharedPointer<QQmlImageProvider> provider = imageProviders.value(url.host());
-    locker.unlock();
-    if (provider) {
-        QString imageId = url.toString(QUrl::RemoveScheme | QUrl::RemoveAuthority).mid(1);
-        image = provider->requestImage(imageId, size, req_size);
-    }
-    return image;
-}
-
-QPixmap QQmlEnginePrivate::getPixmapFromProvider(const QUrl &url, QSize *size, const QSize& req_size)
-{
-    QMutexLocker locker(&mutex);
-    QPixmap pixmap;
-    QSharedPointer<QQmlImageProvider> provider = imageProviders.value(url.host());
-    locker.unlock();
-    if (provider) {
-        QString imageId = url.toString(QUrl::RemoveScheme | QUrl::RemoveAuthority).mid(1);
-        pixmap = provider->requestPixmap(imageId, size, req_size);
-    }
-    return pixmap;
-}
-
 /*!
   Return the base URL for this engine.  The base URL is only used to
   resolve components when a relative URL is passed to the
diff --git a/src/qml/qml/qqmlengine.h b/src/qml/qml/qqmlengine.h
index 04ac61c..4169692 100644
--- a/src/qml/qml/qqmlengine.h
+++ b/src/qml/qml/qqmlengine.h
@@ -54,6 +54,12 @@ QT_BEGIN_HEADER
 QT_BEGIN_NAMESPACE
 
 
+class Q_QML_EXPORT QQmlImageProviderBase
+{
+public:
+    virtual ~QQmlImageProviderBase();
+};
+
 class QQmlComponent;
 class QQmlEnginePrivate;
 class QQmlImportsPrivate;
@@ -62,7 +68,6 @@ class QQmlContext;
 class QQmlType;
 class QUrl;
 class QScriptContext;
-class QQmlImageProvider;
 class QNetworkAccessManager;
 class QQmlNetworkAccessManagerFactory;
 class QQmlIncubationController;
@@ -94,8 +99,8 @@ public:
 
     QNetworkAccessManager *networkAccessManager() const;
 
-    void addImageProvider(const QString &id, QQmlImageProvider *);
-    QQmlImageProvider *imageProvider(const QString &id) const;
+    void addImageProvider(const QString &id, QQmlImageProviderBase *);
+    QQmlImageProviderBase *imageProvider(const QString &id) const;
     void removeImageProvider(const QString &id);
 
     void setIncubationController(QQmlIncubationController *);
diff --git a/src/qml/qml/qqmlengine_p.h b/src/qml/qml/qqmlengine_p.h
index db83448..73a0b5a 100644
--- a/src/qml/qml/qqmlengine_p.h
+++ b/src/qml/qml/qqmlengine_p.h
@@ -63,7 +63,6 @@
 #include "qqmlcontext.h"
 #include "qqmlcontext_p.h"
 #include "qqmlexpression.h"
-#include "qqmlimageprovider.h"
 #include "qqmlproperty_p.h"
 #include "qqmlpropertycache_p.h"
 #include "qqmlmetatype_p.h"
@@ -173,11 +172,7 @@ public:
     mutable QNetworkAccessManager *networkAccessManager;
     mutable QQmlNetworkAccessManagerFactory *networkAccessManagerFactory;
 
-    QHash<QString,QSharedPointer<QQmlImageProvider> > imageProviders;
-    QQmlImageProvider::ImageType getImageProviderType(const QUrl &url);
-    QQuickTextureFactory *getTextureFromProvider(const QUrl &url, QSize *size, const QSize& req_size);
-    QImage getImageFromProvider(const QUrl &url, QSize *size, const QSize& req_size);
-    QPixmap getPixmapFromProvider(const QUrl &url, QSize *size, const QSize& req_size);
+    QHash<QString,QSharedPointer<QQmlImageProviderBase> > imageProviders;
 
     // Scarce resources are "exceptionally high cost" QVariant types where allowing the
     // normal JavaScript GC to clean them up is likely to lead to out-of-memory or other
diff --git a/src/qml/qml/qqmlimageprovider.cpp b/src/qml/qml/qqmlimageprovider.cpp
deleted file mode 100644
index 8630930..0000000
--- a/src/qml/qml/qqmlimageprovider.cpp
+++ /dev/null
@@ -1,334 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qqmlimageprovider.h"
-
-QT_BEGIN_NAMESPACE
-
-class QQmlImageProviderPrivate
-{
-public:
-    QQmlImageProvider::ImageType type;
-};
-
-/*!
-    \class QQuickTextureFactory
-    \since 5.0
-    \brief The QQuickTextureFactory class provides an interface for loading custom textures from QML.
-
-    The purpose of the texture factory is to provide a placeholder for a image
-    data that can be converted into an OpenGL texture.
-
-    Creating a texture directly is not possible as there is rarely an OpenGL context
-    available in the thread that is responsible for loading the image data.
- */
-
-QQuickTextureFactory::QQuickTextureFactory()
-{
-}
-
-QQuickTextureFactory::~QQuickTextureFactory()
-{
-}
-
-
-
-/*!
-    \fn QSGTexture *QQuickTextureFactory::createTexture() const
-
-    This function is called on the scene graph rendering thread to create a QSGTexture
-    instance from the factory.
-
-    QML will internally cache the returned texture as needed. Each call to this
-    function should return a unique instance.
-
-    The OpenGL context used for rendering is bound when this function is called.
- */
-
-/*!
-    \fn QSize QQuickTextureFactory::textureSize() const
-
-    Returns the size of the texture. This function will be called from arbitrary threads
-    and should not rely on an OpenGL context bound.
- */
-
-
-/*!
-    \class QQmlImageProvider
-    \since 4.7
-    \brief The QQmlImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.
-
-    QQmlImageProvider is used to provide advanced image loading features
-    in QML applications. It allows images in QML to be:
-
-    \list
-    \o Loaded using QPixmaps rather than actual image files
-    \o Loaded asynchronously in a separate thread, if imageType() is \l{QQmlImageProvider::ImageType}{ImageType::Image}
-    \endlist
-
-    To specify that an image should be loaded by an image provider, use the
-    \bold {"image:"} scheme for the URL source of the image, followed by the 
-    identifiers of the image provider and the requested image. For example:
-
-    \qml
-    Image { source: "image://myimageprovider/image.png" }
-    \endqml
-
-    This specifies that the image should be loaded by the image provider named 
-    "myimageprovider", and the image to be loaded is named "image.png". The QML engine 
-    invokes the appropriate image provider according to the providers that have
-    been registered through QQmlEngine::addImageProvider().
-
-    Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with
-    preserved case. For example, the below snippet would still specify that the image is loaded by the
-    image provider named "myimageprovider", but it would request a different image than the above snippet
-    ("Image.png" instead of "image.png").
-    \qml
-    Image { source: "image://MyImageProvider/Image.png" }
-    \endqml
-
-    If you want the rest of the URL to be case insensitive, you will have to take care
-    of that yourself inside your image provider.
-
-    \section2 An example
-
-    Here are two images. Their \c source values indicate they should be loaded by
-    an image provider named "colors", and the images to be loaded are "yellow"
-    and "red", respectively:
-
-    \snippet examples/declarative/cppextensions/imageprovider/imageprovider-example.qml 0
-
-    When these images are loaded by QML, it looks for a matching image provider
-    and calls its requestImage() or requestPixmap() method (depending on its
-    imageType()) to load the image. The method is called with the \c id 
-    parameter set to "yellow" for the first image, and "red" for the second.
-
-    Here is an image provider implementation that can load the images 
-    requested by the above QML. This implementation dynamically 
-    generates QPixmap images that are filled with the requested color:
-
-    \snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 0
-    \codeline
-    \snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 1
-
-    To make this provider accessible to QML, it is registered with the QML engine
-    with a "colors" identifier:
-
-    \code
-    int main(int argc, char *argv[]) 
-    {
-        ...
-
-        QQmlEngine engine;
-        engine->addImageProvider(QLatin1String("colors"), new ColorPixmapProvider);
-
-        ...
-    }
-    \endcode
-
-    Now the images can be successfully loaded in QML:
-
-    \image imageprovider.png
-
-    A complete example is available in Qt's 
-    \l {declarative/cppextensions/imageprovider}{examples/declarative/cppextensions/imageprovider}
-    directory. Note the example registers the provider via a \l{QQmlExtensionPlugin}{plugin}
-    instead of registering it in the application \c main() function as shown above.
-
-
-    \section2 Asynchronous image loading
-
-    Image providers that support QImage loading automatically include support
-    for asychronous loading of images. To enable asynchronous loading for an
-    image source, set the \c asynchronous property to \c true for the relevant
-    \l Image, \l BorderImage or \l AnimatedImage object. When this is enabled, 
-    the image request to the provider is run in a low priority thread,
-    allowing image loading to be executed in the background, and reducing the
-    performance impact on the user interface.
-
-    Asynchronous loading is not supported for image providers that provide
-    QPixmap rather than QImage values, as pixmaps can only be created in the
-    main thread. In this case, if \l {Image::}{asynchronous} is set to 
-    \c true, the value is ignored and the image is loaded
-    synchronously.
-
-
-    \section2 Image caching
-
-    Images returned by a QQmlImageProvider are automatically cached,
-    similar to any image loaded by the QML engine. When an image with a
-    "image://" prefix is loaded from cache, requestImage() and requestPixmap()
-    will not be called for the relevant image provider. If an image should always
-    be fetched from the image provider, and should not be cached at all, set the
-    \c cache property to \c false for the relevant \l Image, \l BorderImage or
-    \l AnimatedImage object.
-
-    \sa QQmlEngine::addImageProvider()
-*/
-
-/*!
-    \enum QQmlImageProvider::ImageType
-
-    Defines the type of image supported by this image provider.
-
-    \value Image The Image Provider provides QImage images. The 
-        requestImage() method will be called for all image requests.
-    \value Pixmap The Image Provider provides QPixmap images. The 
-        requestPixmap() method will be called for all image requests.
-    \value Texture The Image Provider provides QSGTextureProvider based images.
-        The requestTexture() method will be called for all image requests. \omitvalue
-*/
-
-/*!
-    Creates an image provider that will provide images of the given \a type.
-*/
-QQmlImageProvider::QQmlImageProvider(ImageType type)
-    : d(new QQmlImageProviderPrivate)
-{
-    d->type = type;
-}
-
-/*!
-    Destroys the QQmlImageProvider
-
-    \note The destructor of your derived class need to be thread safe.
-*/
-QQmlImageProvider::~QQmlImageProvider()
-{
-    delete d;
-}
-
-/*!
-    Returns the image type supported by this provider.
-*/
-QQmlImageProvider::ImageType QQmlImageProvider::imageType() const
-{
-    return d->type;
-}
-
-/*!
-    Implement this method to return the image with \a id. The default 
-    implementation returns an empty image.
-
-    The \a id is the requested image source, with the "image:" scheme and
-    provider identifier removed. For example, if the image \l{Image::}{source}
-    was "image://myprovider/icons/home", the given \a id would be "icons/home".
-
-    The \a requestedSize corresponds to the \l {Image::sourceSize} requested by
-    an Image element. If \a requestedSize is a valid size, the image
-    returned should be of that size.
-
-    In all cases, \a size must be set to the original size of the image. This
-    is used to set the \l {Item::}{width} and \l {Item::}{height} of the
-    relevant \l Image if these values have not been set explicitly.
-
-    \note this method may be called by multiple threads, so ensure the
-    implementation of this method is reentrant.
-*/
-QImage QQmlImageProvider::requestImage(const QString &id, QSize *size, const QSize& requestedSize)
-{
-    Q_UNUSED(id);
-    Q_UNUSED(size);
-    Q_UNUSED(requestedSize);
-    if (d->type == Image)
-        qWarning("ImageProvider supports Image type but has not implemented requestImage()");
-    return QImage();
-}
-
-/*!
-    Implement this method to return the pixmap with \a id. The default
-    implementation returns an empty pixmap.
-
-    The \a id is the requested image source, with the "image:" scheme and
-    provider identifier removed. For example, if the image \l{Image::}{source}
-    was "image://myprovider/icons/home", the given \a id would be "icons/home".
-
-    The \a requestedSize corresponds to the \l {Image::sourceSize} requested by
-    an Image element. If \a requestedSize is a valid size, the image
-    returned should be of that size.
-
-    In all cases, \a size must be set to the original size of the image. This
-    is used to set the \l {Item::}{width} and \l {Item::}{height} of the
-    relevant \l Image if these values have not been set explicitly.
-*/
-QPixmap QQmlImageProvider::requestPixmap(const QString &id, QSize *size, const QSize& requestedSize)
-{
-    Q_UNUSED(id);
-    Q_UNUSED(size);
-    Q_UNUSED(requestedSize);
-    if (d->type == Pixmap)
-        qWarning("ImageProvider supports Pixmap type but has not implemented requestPixmap()");
-    return QPixmap();
-}
-
-
-/*!
-    Implement this method to return the texture with \a id. The default
-    implementation returns 0.
-
-    The \a id is the requested image source, with the "image:" scheme and
-    provider identifier removed. For example, if the image \l{Image::}{source}
-    was "image://myprovider/icons/home", the given \a id would be "icons/home".
-
-    The \a requestedSize corresponds to the \l {Image::sourceSize} requested by
-    an Image element. If \a requestedSize is a valid size, the image
-    returned should be of that size.
-
-    In all cases, \a size must be set to the original size of the image. This
-    is used to set the \l {Item::}{width} and \l {Item::}{height} of the
-    relevant \l Image if these values have not been set explicitly.
-
-    \note this method may be called by multiple threads, so ensure the
-    implementation of this method is reentrant.
-*/
-
-QQuickTextureFactory *QQmlImageProvider::requestTexture(const QString &id, QSize *size, const QSize &requestedSize)
-{
-    Q_UNUSED(id);
-    Q_UNUSED(size);
-    Q_UNUSED(requestedSize);
-    if (d->type == Texture)
-        qWarning("ImageProvider supports Texture type but has not implemented requestTexture()");
-    return 0;
-}
-
-QT_END_NAMESPACE
-
diff --git a/src/qml/qml/qqmlimageprovider.h b/src/qml/qml/qqmlimageprovider.h
deleted file mode 100644
index fe06925..0000000
--- a/src/qml/qml/qqmlimageprovider.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QQMLIMAGEPROVIDER_H
-#define QQMLIMAGEPROVIDER_H
-
-#include <QtQml/qtqmlglobal.h>
-#include <QtGui/qimage.h>
-#include <QtGui/qpixmap.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-class QQmlImageProviderPrivate;
-class QSGTexture;
-class QQuickCanvas;
-
-class Q_QML_EXPORT QQuickTextureFactory : public QObject
-{
-public:
-    QQuickTextureFactory();
-    virtual ~QQuickTextureFactory();
-
-    virtual QSGTexture *createTexture(QQuickCanvas *canvas) const = 0;
-    virtual QSize textureSize() const = 0;
-    virtual int textureByteCount() const = 0;
-};
-
-class Q_QML_EXPORT QQmlImageProvider
-{
-public:
-    enum ImageType {
-        Image,
-        Pixmap,
-        Texture,
-        Invalid
-    };
-
-    QQmlImageProvider(ImageType type);
-    virtual ~QQmlImageProvider();
-
-    ImageType imageType() const;
-
-    virtual QImage requestImage(const QString &id, QSize *size, const QSize& requestedSize);
-    virtual QPixmap requestPixmap(const QString &id, QSize *size, const QSize& requestedSize);
-    virtual QQuickTextureFactory *requestTexture(const QString &id, QSize *size, const QSize &requestedSize);
-
-private:
-    QQmlImageProviderPrivate *d;
-};
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QQMLIMAGEPROVIDER
diff --git a/src/quick/scenegraph/qsgcontext.cpp b/src/quick/scenegraph/qsgcontext.cpp
index 10276c1..ffc64b6 100644
--- a/src/quick/scenegraph/qsgcontext.cpp
+++ b/src/quick/scenegraph/qsgcontext.cpp
@@ -55,7 +55,6 @@
 #include <QGuiApplication>
 #include <QOpenGLContext>
 
-#include <QQmlImageProvider>
 #include <private/qqmlglobal_p.h>
 
 #include <QtQuick/private/qsgtexture_p.h>
diff --git a/src/quick/scenegraph/qsgcontextplugin_p.h b/src/quick/scenegraph/qsgcontextplugin_p.h
index d0d8ea1..acff222 100644
--- a/src/quick/scenegraph/qsgcontextplugin_p.h
+++ b/src/quick/scenegraph/qsgcontextplugin_p.h
@@ -43,11 +43,10 @@
 #define QSGCONTEXTPLUGIN_H
 
 #include <QtQuick/qtquickglobal.h>
+#include <QtQuick/qquickimageprovider.h>
 #include <QtCore/qplugin.h>
 #include <QtCore/qfactoryinterface.h>
 
-#include <QQmlImageProvider>
-
 QT_BEGIN_HEADER
 
 QT_BEGIN_NAMESPACE
diff --git a/src/quick/util/qquickimageprovider.cpp b/src/quick/util/qquickimageprovider.cpp
new file mode 100644
index 0000000..4a1db05
--- /dev/null
+++ b/src/quick/util/qquickimageprovider.cpp
@@ -0,0 +1,334 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qquickimageprovider.h"
+
+QT_BEGIN_NAMESPACE
+
+class QQuickImageProviderPrivate
+{
+public:
+    QQuickImageProvider::ImageType type;
+};
+
+/*!
+    \class QQuickTextureFactory
+    \since 5.0
+    \brief The QQuickTextureFactory class provides an interface for loading custom textures from QML.
+
+    The purpose of the texture factory is to provide a placeholder for a image
+    data that can be converted into an OpenGL texture.
+
+    Creating a texture directly is not possible as there is rarely an OpenGL context
+    available in the thread that is responsible for loading the image data.
+ */
+
+QQuickTextureFactory::QQuickTextureFactory()
+{
+}
+
+QQuickTextureFactory::~QQuickTextureFactory()
+{
+}
+
+
+
+/*!
+    \fn QSGTexture *QQuickTextureFactory::createTexture() const
+
+    This function is called on the scene graph rendering thread to create a QSGTexture
+    instance from the factory.
+
+    QML will internally cache the returned texture as needed. Each call to this
+    function should return a unique instance.
+
+    The OpenGL context used for rendering is bound when this function is called.
+ */
+
+/*!
+    \fn QSize QQuickTextureFactory::textureSize() const
+
+    Returns the size of the texture. This function will be called from arbitrary threads
+    and should not rely on an OpenGL context bound.
+ */
+
+
+/*!
+    \class QQuickImageProvider
+    \since 4.7
+    \brief The QQuickImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.
+
+    QQuickImageProvider is used to provide advanced image loading features
+    in QML applications. It allows images in QML to be:
+
+    \list
+    \o Loaded using QPixmaps rather than actual image files
+    \o Loaded asynchronously in a separate thread, if imageType() is \l{QQuickImageProvider::ImageType}{ImageType::Image}
+    \endlist
+
+    To specify that an image should be loaded by an image provider, use the
+    \bold {"image:"} scheme for the URL source of the image, followed by the 
+    identifiers of the image provider and the requested image. For example:
+
+    \qml
+    Image { source: "image://myimageprovider/image.png" }
+    \endqml
+
+    This specifies that the image should be loaded by the image provider named 
+    "myimageprovider", and the image to be loaded is named "image.png". The QML engine 
+    invokes the appropriate image provider according to the providers that have
+    been registered through QQmlEngine::addImageProvider().
+
+    Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with
+    preserved case. For example, the below snippet would still specify that the image is loaded by the
+    image provider named "myimageprovider", but it would request a different image than the above snippet
+    ("Image.png" instead of "image.png").
+    \qml
+    Image { source: "image://MyImageProvider/Image.png" }
+    \endqml
+
+    If you want the rest of the URL to be case insensitive, you will have to take care
+    of that yourself inside your image provider.
+
+    \section2 An example
+
+    Here are two images. Their \c source values indicate they should be loaded by
+    an image provider named "colors", and the images to be loaded are "yellow"
+    and "red", respectively:
+
+    \snippet examples/declarative/cppextensions/imageprovider/imageprovider-example.qml 0
+
+    When these images are loaded by QML, it looks for a matching image provider
+    and calls its requestImage() or requestPixmap() method (depending on its
+    imageType()) to load the image. The method is called with the \c id 
+    parameter set to "yellow" for the first image, and "red" for the second.
+
+    Here is an image provider implementation that can load the images 
+    requested by the above QML. This implementation dynamically 
+    generates QPixmap images that are filled with the requested color:
+
+    \snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 0
+    \codeline
+    \snippet examples/declarative/cppextensions/imageprovider/imageprovider.cpp 1
+
+    To make this provider accessible to QML, it is registered with the QML engine
+    with a "colors" identifier:
+
+    \code
+    int main(int argc, char *argv[]) 
+    {
+        ...
+
+        QQmlEngine engine;
+        engine->addImageProvider(QLatin1String("colors"), new ColorPixmapProvider);
+
+        ...
+    }
+    \endcode
+
+    Now the images can be successfully loaded in QML:
+
+    \image imageprovider.png
+
+    A complete example is available in Qt's 
+    \l {declarative/cppextensions/imageprovider}{examples/declarative/cppextensions/imageprovider}
+    directory. Note the example registers the provider via a \l{QQmlExtensionPlugin}{plugin}
+    instead of registering it in the application \c main() function as shown above.
+
+
+    \section2 Asynchronous image loading
+
+    Image providers that support QImage loading automatically include support
+    for asychronous loading of images. To enable asynchronous loading for an
+    image source, set the \c asynchronous property to \c true for the relevant
+    \l Image, \l BorderImage or \l AnimatedImage object. When this is enabled, 
+    the image request to the provider is run in a low priority thread,
+    allowing image loading to be executed in the background, and reducing the
+    performance impact on the user interface.
+
+    Asynchronous loading is not supported for image providers that provide
+    QPixmap rather than QImage values, as pixmaps can only be created in the
+    main thread. In this case, if \l {Image::}{asynchronous} is set to 
+    \c true, the value is ignored and the image is loaded
+    synchronously.
+
+
+    \section2 Image caching
+
+    Images returned by a QQuickImageProvider are automatically cached,
+    similar to any image loaded by the QML engine. When an image with a
+    "image://" prefix is loaded from cache, requestImage() and requestPixmap()
+    will not be called for the relevant image provider. If an image should always
+    be fetched from the image provider, and should not be cached at all, set the
+    \c cache property to \c false for the relevant \l Image, \l BorderImage or
+    \l AnimatedImage object.
+
+    \sa QQmlEngine::addImageProvider()
+*/
+
+/*!
+    \enum QQuickImageProvider::ImageType
+
+    Defines the type of image supported by this image provider.
+
+    \value Image The Image Provider provides QImage images. The 
+        requestImage() method will be called for all image requests.
+    \value Pixmap The Image Provider provides QPixmap images. The 
+        requestPixmap() method will be called for all image requests.
+    \value Texture The Image Provider provides QSGTextureProvider based images.
+        The requestTexture() method will be called for all image requests. \omitvalue
+*/
+
+/*!
+    Creates an image provider that will provide images of the given \a type.
+*/
+QQuickImageProvider::QQuickImageProvider(ImageType type)
+    : d(new QQuickImageProviderPrivate)
+{
+    d->type = type;
+}
+
+/*!
+    Destroys the QQuickImageProvider
+
+    \note The destructor of your derived class need to be thread safe.
+*/
+QQuickImageProvider::~QQuickImageProvider()
+{
+    delete d;
+}
+
+/*!
+    Returns the image type supported by this provider.
+*/
+QQuickImageProvider::ImageType QQuickImageProvider::imageType() const
+{
+    return d->type;
+}
+
+/*!
+    Implement this method to return the image with \a id. The default 
+    implementation returns an empty image.
+
+    The \a id is the requested image source, with the "image:" scheme and
+    provider identifier removed. For example, if the image \l{Image::}{source}
+    was "image://myprovider/icons/home", the given \a id would be "icons/home".
+
+    The \a requestedSize corresponds to the \l {Image::sourceSize} requested by
+    an Image element. If \a requestedSize is a valid size, the image
+    returned should be of that size.
+
+    In all cases, \a size must be set to the original size of the image. This
+    is used to set the \l {Item::}{width} and \l {Item::}{height} of the
+    relevant \l Image if these values have not been set explicitly.
+
+    \note this method may be called by multiple threads, so ensure the
+    implementation of this method is reentrant.
+*/
+QImage QQuickImageProvider::requestImage(const QString &id, QSize *size, const QSize& requestedSize)
+{
+    Q_UNUSED(id);
+    Q_UNUSED(size);
+    Q_UNUSED(requestedSize);
+    if (d->type == Image)
+        qWarning("ImageProvider supports Image type but has not implemented requestImage()");
+    return QImage();
+}
+
+/*!
+    Implement this method to return the pixmap with \a id. The default
+    implementation returns an empty pixmap.
+
+    The \a id is the requested image source, with the "image:" scheme and
+    provider identifier removed. For example, if the image \l{Image::}{source}
+    was "image://myprovider/icons/home", the given \a id would be "icons/home".
+
+    The \a requestedSize corresponds to the \l {Image::sourceSize} requested by
+    an Image element. If \a requestedSize is a valid size, the image
+    returned should be of that size.
+
+    In all cases, \a size must be set to the original size of the image. This
+    is used to set the \l {Item::}{width} and \l {Item::}{height} of the
+    relevant \l Image if these values have not been set explicitly.
+*/
+QPixmap QQuickImageProvider::requestPixmap(const QString &id, QSize *size, const QSize& requestedSize)
+{
+    Q_UNUSED(id);
+    Q_UNUSED(size);
+    Q_UNUSED(requestedSize);
+    if (d->type == Pixmap)
+        qWarning("ImageProvider supports Pixmap type but has not implemented requestPixmap()");
+    return QPixmap();
+}
+
+
+/*!
+    Implement this method to return the texture with \a id. The default
+    implementation returns 0.
+
+    The \a id is the requested image source, with the "image:" scheme and
+    provider identifier removed. For example, if the image \l{Image::}{source}
+    was "image://myprovider/icons/home", the given \a id would be "icons/home".
+
+    The \a requestedSize corresponds to the \l {Image::sourceSize} requested by
+    an Image element. If \a requestedSize is a valid size, the image
+    returned should be of that size.
+
+    In all cases, \a size must be set to the original size of the image. This
+    is used to set the \l {Item::}{width} and \l {Item::}{height} of the
+    relevant \l Image if these values have not been set explicitly.
+
+    \note this method may be called by multiple threads, so ensure the
+    implementation of this method is reentrant.
+*/
+
+QQuickTextureFactory *QQuickImageProvider::requestTexture(const QString &id, QSize *size, const QSize &requestedSize)
+{
+    Q_UNUSED(id);
+    Q_UNUSED(size);
+    Q_UNUSED(requestedSize);
+    if (d->type == Texture)
+        qWarning("ImageProvider supports Texture type but has not implemented requestTexture()");
+    return 0;
+}
+
+QT_END_NAMESPACE
+
diff --git a/src/quick/util/qquickimageprovider.h b/src/quick/util/qquickimageprovider.h
new file mode 100644
index 0000000..153a4ba
--- /dev/null
+++ b/src/quick/util/qquickimageprovider.h
@@ -0,0 +1,97 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQUICKIMAGEPROVIDER_H
+#define QQUICKIMAGEPROVIDER_H
+
+#include <QtQuick/qtquickglobal.h>
+#include <QtGui/qimage.h>
+#include <QtGui/qpixmap.h>
+#include <QtQml/qqmlengine.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+
+class QQuickImageProviderPrivate;
+class QSGTexture;
+class QQuickCanvas;
+
+class Q_QUICK_EXPORT QQuickTextureFactory : public QObject
+{
+public:
+    QQuickTextureFactory();
+    virtual ~QQuickTextureFactory();
+
+    virtual QSGTexture *createTexture(QQuickCanvas *canvas) const = 0;
+    virtual QSize textureSize() const = 0;
+    virtual int textureByteCount() const = 0;
+};
+
+class Q_QUICK_EXPORT QQuickImageProvider : public QQmlImageProviderBase
+{
+public:
+    enum ImageType {
+        Image,
+        Pixmap,
+        Texture,
+        Invalid
+    };
+
+    QQuickImageProvider(ImageType type);
+    virtual ~QQuickImageProvider();
+
+    ImageType imageType() const;
+
+    virtual QImage requestImage(const QString &id, QSize *size, const QSize& requestedSize);
+    virtual QPixmap requestPixmap(const QString &id, QSize *size, const QSize& requestedSize);
+    virtual QQuickTextureFactory *requestTexture(const QString &id, QSize *size, const QSize &requestedSize);
+
+private:
+    QQuickImageProviderPrivate *d;
+};
+
+QT_END_NAMESPACE
+
+QT_END_HEADER
+
+#endif // QQUICKIMAGEPROVIDER_H
diff --git a/src/quick/util/qquickpixmapcache.cpp b/src/quick/util/qquickpixmapcache.cpp
index aae5306..350940c 100644
--- a/src/quick/util/qquickpixmapcache.cpp
+++ b/src/quick/util/qquickpixmapcache.cpp
@@ -41,7 +41,7 @@
 
 #include "qquickpixmapcache_p.h"
 #include <qqmlnetworkaccessmanagerfactory.h>
-#include <qqmlimageprovider.h>
+#include <qquickimageprovider.h>
 
 #include <qqmlengine.h>
 #include <private/qqmlglobal_p.h>
@@ -76,6 +76,16 @@ QT_BEGIN_NAMESPACE
 // The cache limit describes the maximum "junk" in the cache.
 static int cache_limit = 2048 * 1024; // 2048 KB cache limit for embedded in qpixmapcache.cpp
 
+static inline QString imageProviderId(const QUrl &url)
+{
+    return url.host();
+}
+
+static inline QString imageId(const QUrl &url)
+{
+    return url.toString(QUrl::RemoveScheme | QUrl::RemoveAuthority).mid(1);
+}
+
 QSGTexture *QQuickDefaultTextureFactory::createTexture(QQuickCanvas *) const
 {
     QSGPlainTexture *t = new QSGPlainTexture();
@@ -514,11 +524,15 @@ void QQuickPixmapReader::processJob(QQuickPixmapReply *runningJob, const QUrl &u
 {
     // fetch
     if (url.scheme() == QLatin1String("image")) {
-        // Use QmlImageProvider
+        // Use QQuickImageProvider
         QSize readSize;
-        QQmlEnginePrivate *ep = QQmlEnginePrivate::get(engine);
-        QQmlImageProvider::ImageType imageType = ep->getImageProviderType(url);
-        if (imageType == QQmlImageProvider::Invalid) {
+
+        QQuickImageProvider::ImageType imageType = QQuickImageProvider::Invalid;
+        QQuickImageProvider *provider = static_cast<QQuickImageProvider *>(engine->imageProvider(imageProviderId(url)));
+        if (provider)
+            imageType = provider->imageType();
+
+        if (imageType == QQuickImageProvider::Invalid) {
             QQuickPixmapReply::ReadError errorCode = QQuickPixmapReply::Loading;
             QString errorStr = QQuickPixmap::tr("Invalid image provider: %1").arg(url.toString());
             QImage image;
@@ -526,8 +540,8 @@ void QQuickPixmapReader::processJob(QQuickPixmapReply *runningJob, const QUrl &u
             if (!cancelled.contains(runningJob))
                 runningJob->postReply(errorCode, errorStr, readSize, image);
             mutex.unlock();
-        } else if (imageType == QQmlImageProvider::Image) {
-            QImage image = ep->getImageFromProvider(url, &readSize, requestSize);
+        } else if (imageType == QQuickImageProvider::Image) {
+            QImage image = provider->requestImage(imageId(url), &readSize, requestSize);
             QQuickPixmapReply::ReadError errorCode = QQuickPixmapReply::NoError;
             QString errorStr;
             if (image.isNull()) {
@@ -545,7 +559,7 @@ void QQuickPixmapReader::processJob(QQuickPixmapReply *runningJob, const QUrl &u
 
             mutex.unlock();
         } else {
-            QQuickTextureFactory *t = ep->getTextureFromProvider(url, &readSize, requestSize);
+            QQuickTextureFactory *t = provider->requestTexture(imageId(url), &readSize, requestSize);
             QQuickPixmapReply::ReadError errorCode = QQuickPixmapReply::NoError;
             QString errorStr;
             if (!t) {
@@ -945,33 +959,36 @@ static QQuickPixmapData* createPixmapDataSync(QQuickPixmap *declarativePixmap, Q
 {
     if (url.scheme() == QLatin1String("image")) {
         QSize readSize;
-        QQmlEnginePrivate *ep = QQmlEnginePrivate::get(engine);
-        QQmlImageProvider::ImageType imageType = ep->getImageProviderType(url);
+
+        QQuickImageProvider::ImageType imageType = QQuickImageProvider::Invalid;
+        QQuickImageProvider *provider = static_cast<QQuickImageProvider *>(engine->imageProvider(imageProviderId(url)));
+        if (provider)
+            imageType = provider->imageType();
 
         switch (imageType) {
-            case QQmlImageProvider::Invalid:
+            case QQuickImageProvider::Invalid:
                 return new QQuickPixmapData(declarativePixmap, url, requestSize,
                     QQuickPixmap::tr("Invalid image provider: %1").arg(url.toString()));
-            case QQmlImageProvider::Texture:
+            case QQuickImageProvider::Texture:
             {
-                QQuickTextureFactory *texture = ep->getTextureFromProvider(url, &readSize, requestSize);
+                QQuickTextureFactory *texture = provider->requestTexture(imageId(url), &readSize, requestSize);
                 if (texture) {
                     *ok = true;
                     return new QQuickPixmapData(declarativePixmap, url, texture, QImage(), readSize, requestSize);
                 }
             }
 
-            case QQmlImageProvider::Image:
+            case QQuickImageProvider::Image:
             {
-                QImage image = ep->getImageFromProvider(url, &readSize, requestSize);
+                QImage image = provider->requestImage(imageId(url), &readSize, requestSize);
                 if (!image.isNull()) {
                     *ok = true;
                     return new QQuickPixmapData(declarativePixmap, url, image, readSize, requestSize);
                 }
             }
-            case QQmlImageProvider::Pixmap:
+            case QQuickImageProvider::Pixmap:
             {
-                QPixmap pixmap = ep->getPixmapFromProvider(url, &readSize, requestSize);
+                QPixmap pixmap = provider->requestPixmap(imageId(url), &readSize, requestSize);
                 if (!pixmap.isNull()) {
                     *ok = true;
                     return new QQuickPixmapData(declarativePixmap, url, pixmap.toImage(), readSize, requestSize);
@@ -1180,9 +1197,11 @@ void QQuickPixmap::load(QQmlEngine *engine, const QUrl &url, const QSize &reques
     if (iter == store->m_cache.end()) {
         if (options & QQuickPixmap::Asynchronous) {
             // pixmaps can only be loaded synchronously
-            if (url.scheme() == QLatin1String("image") 
-                    && QQmlEnginePrivate::get(engine)->getImageProviderType(url) == QQmlImageProvider::Pixmap) {
-                options &= ~QQuickPixmap::Asynchronous;
+            if (url.scheme() == QLatin1String("image")) {
+                QQuickImageProvider *provider = static_cast<QQuickImageProvider *>(engine->imageProvider(imageProviderId(url)));
+                if (provider && provider->imageType() == QQuickImageProvider::Pixmap) {
+                    options &= ~QQuickPixmap::Asynchronous;
+                }
             }
         }
 
diff --git a/src/quick/util/qquickpixmapcache_p.h b/src/quick/util/qquickpixmapcache_p.h
index 0b4c2fb..ef17a12 100644
--- a/src/quick/util/qquickpixmapcache_p.h
+++ b/src/quick/util/qquickpixmapcache_p.h
@@ -47,9 +47,9 @@
 #include <QtGui/qpixmap.h>
 #include <QtCore/qurl.h>
 #include <QtQuick/qtquickglobal.h>
+#include <QtQuick/qquickimageprovider.h>
 
 #include <private/qintrusivelist_p.h>
-#include <qqmlimageprovider.h>
 
 QT_BEGIN_HEADER
 
diff --git a/src/quick/util/util.pri b/src/quick/util/util.pri
index c3cec91..d720ef0 100644
--- a/src/quick/util/util.pri
+++ b/src/quick/util/util.pri
@@ -25,6 +25,7 @@ SOURCES += \
     $$PWD/qquickchangeset.cpp \
     $$PWD/qquicklistcompositor.cpp \
     $$PWD/qquickpathinterpolator.cpp \
+    $$PWD/qquickimageprovider.cpp \
     $$PWD/qquicksvgparser.cpp
 
 HEADERS += \
@@ -58,4 +59,5 @@ HEADERS += \
     $$PWD/qquickchangeset_p.h \
     $$PWD/qquicklistcompositor_p.h \
     $$PWD/qquickpathinterpolator_p.h \
+    $$PWD/qquickimageprovider.h \
     $$PWD/qquicksvgparser_p.h
diff --git a/tests/auto/qml/qml.pro b/tests/auto/qml/qml.pro
index bcfbcbd..d58a290 100644
--- a/tests/auto/qml/qml.pro
+++ b/tests/auto/qml/qml.pro
@@ -32,7 +32,6 @@ PRIVATETESTS += \
     qqmlcpputils \
     qqmlecmascript \
     qqmlexpression \
-    qqmlimageprovider \
     qqmlinstruction \
     qqmllanguage \
     qqmlproperty \
diff --git a/tests/auto/qml/qqmlimageprovider/qqmlimageprovider.pro b/tests/auto/qml/qqmlimageprovider/qqmlimageprovider.pro
deleted file mode 100644
index 9feeee1..0000000
--- a/tests/auto/qml/qqmlimageprovider/qqmlimageprovider.pro
+++ /dev/null
@@ -1,9 +0,0 @@
-CONFIG += testcase
-TARGET = tst_qqmlimageprovider
-macx:CONFIG -= app_bundle
-
-SOURCES += tst_qqmlimageprovider.cpp
-
-CONFIG += parallel_test
-
-QT += core-private gui-private qml-private quick-private network testlib
diff --git a/tests/auto/qml/qqmlimageprovider/tst_qqmlimageprovider.cpp b/tests/auto/qml/qqmlimageprovider/tst_qqmlimageprovider.cpp
deleted file mode 100644
index bc53544..0000000
--- a/tests/auto/qml/qqmlimageprovider/tst_qqmlimageprovider.cpp
+++ /dev/null
@@ -1,424 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-#include <qtest.h>
-#include <QtTest/QtTest>
-#include <QtQml/qqmlengine.h>
-#include <QtQml/qqmlimageprovider.h>
-#include <private/qquickimage_p.h>
-#include <QImageReader>
-#include <QWaitCondition>
-
-Q_DECLARE_METATYPE(QQmlImageProvider*);
-
-class tst_qqmlimageprovider : public QObject
-{
-    Q_OBJECT
-public:
-    tst_qqmlimageprovider()
-    {
-    }
-
-private slots:
-    void requestImage_sync_data();
-    void requestImage_sync();
-    void requestImage_async_data();
-    void requestImage_async();
-
-    void requestPixmap_sync_data();
-    void requestPixmap_sync();
-    void requestPixmap_async();
-
-    void removeProvider_data();
-    void removeProvider();
-
-    void threadTest();
-
-private:
-    QString newImageFileName() const;
-    void fillRequestTestsData(const QString &id);
-    void runTest(bool async, QQmlImageProvider *provider);
-};
-
-
-class TestQImageProvider : public QQmlImageProvider
-{
-public:
-    TestQImageProvider(bool *deleteWatch = 0)
-        : QQmlImageProvider(Image), deleteWatch(deleteWatch)
-    {
-    }
-
-    ~TestQImageProvider()
-    {
-        if (deleteWatch)
-            *deleteWatch = true;
-    }
-
-    QImage requestImage(const QString &id, QSize *size, const QSize& requestedSize)
-    {
-        lastImageId = id;
-
-        if (id == QLatin1String("no-such-file.png"))
-            return QImage();
-
-        int width = 100; 
-        int height = 100;
-        QImage image(width, height, QImage::Format_RGB32);
-        if (size) 
-            *size = QSize(width, height);
-        if (requestedSize.isValid())
-            image = image.scaled(requestedSize);
-        return image;
-    }
-
-    bool *deleteWatch;
-    QString lastImageId;
-};
-Q_DECLARE_METATYPE(TestQImageProvider*);
-
-
-class TestQPixmapProvider : public QQmlImageProvider
-{
-public:
-    TestQPixmapProvider(bool *deleteWatch = 0)
-        : QQmlImageProvider(Pixmap), deleteWatch(deleteWatch)
-    {
-    }
-
-    ~TestQPixmapProvider()
-    {
-        if (deleteWatch)
-            *deleteWatch = true;
-    }
-
-    QPixmap requestPixmap(const QString &id, QSize *size, const QSize& requestedSize)
-    {
-        lastImageId = id;
-
-        if (id == QLatin1String("no-such-file.png"))
-            return QPixmap();
-
-        int width = 100; 
-        int height = 100;
-        QPixmap image(width, height);
-        if (size) 
-            *size = QSize(width, height);
-        if (requestedSize.isValid())
-            image = image.scaled(requestedSize);
-        return image;
-    }
-
-    bool *deleteWatch;
-    QString lastImageId;
-};
-Q_DECLARE_METATYPE(TestQPixmapProvider*);
-
-
-QString tst_qqmlimageprovider::newImageFileName() const
-{
-    // need to generate new filenames each time or else images are loaded
-    // from cache and we won't get loading status changes when testing 
-    // async loading
-    static int count = 0;
-    return QString("image://test/image-%1.png").arg(count++);
-}
-
-void tst_qqmlimageprovider::fillRequestTestsData(const QString &id)
-{
-    QTest::addColumn<QString>("source");
-    QTest::addColumn<QString>("imageId");
-    QTest::addColumn<QString>("properties");
-    QTest::addColumn<QSize>("size");
-    QTest::addColumn<QString>("error");
-
-    QString fileName = newImageFileName();
-    QTest::newRow(QTest::toString(id + " simple test"))
-            << "image://test/" + fileName << fileName << "" << QSize(100,100) << "";
-
-    fileName = newImageFileName();
-    QTest::newRow(QTest::toString(id + " simple test with capitalization"))//As it's a URL, should make no difference
-            << "image://Test/" + fileName << fileName << "" << QSize(100,100) << "";
-
-    fileName = newImageFileName();
-    QTest::newRow(QTest::toString(id + " url with no id"))
-        << "image://test/" + fileName << "" + fileName << "" << QSize(100,100) << "";
-
-    fileName = newImageFileName();
-    QTest::newRow(QTest::toString(id + " url with path"))
-        << "image://test/test/path" + fileName << "test/path" + fileName << "" << QSize(100,100) << "";
-
-    fileName = newImageFileName();
-    QTest::newRow(QTest::toString(id + " url with fragment"))
-        << "image://test/faq.html?#question13" + fileName << "faq.html?#question13" + fileName << "" << QSize(100,100) << "";
-
-    fileName = newImageFileName();
-    QTest::newRow(QTest::toString(id + " url with query"))
-        << "image://test/cgi-bin/drawgraph.cgi?type=pie&color=green" + fileName << "cgi-bin/drawgraph.cgi?type=pie&color=green" + fileName
-        << "" << QSize(100,100) << "";
-
-    fileName = newImageFileName();
-    QTest::newRow(QTest::toString(id + " scaled image"))
-            << "image://test/" + fileName << fileName << "sourceSize: \"80x30\"" << QSize(80,30) << "";
-
-    QTest::newRow(QTest::toString(id + " missing"))
-        << "image://test/no-such-file.png" << "no-such-file.png" << "" << QSize(100,100)
-        << "file::2:1: QML Image: Failed to get image from provider: image://test/no-such-file.png";
-
-    QTest::newRow(QTest::toString(id + " unknown provider"))
-        << "image://bogus/exists.png" << "" << "" << QSize()
-        << "file::2:1: QML Image: Invalid image provider: image://bogus/exists.png";
-}
-
-void tst_qqmlimageprovider::runTest(bool async, QQmlImageProvider *provider)
-{
-    QFETCH(QString, source);
-    QFETCH(QString, imageId);
-    QFETCH(QString, properties);
-    QFETCH(QSize, size);
-    QFETCH(QString, error);
-
-    if (!error.isEmpty())
-        QTest::ignoreMessage(QtWarningMsg, error.toUtf8());
-
-    QQmlEngine engine;
-
-    engine.addImageProvider("test", provider);
-    QVERIFY(engine.imageProvider("test") != 0);
-
-    QString componentStr = "import QtQuick 2.0\nImage { source: \"" + source + "\"; " 
-            + (async ? "asynchronous: true; " : "")
-            + properties + " }";
-    QQmlComponent component(&engine);
-    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
-    QQuickImage *obj = qobject_cast<QQuickImage*>(component.create());
-    QVERIFY(obj != 0);
-
-    if (async) 
-        QTRY_VERIFY(obj->status() == QQuickImage::Loading);
-
-    QCOMPARE(obj->source(), QUrl(source));
-
-    if (error.isEmpty()) {
-        if (async)
-            QTRY_VERIFY(obj->status() == QQuickImage::Ready);
-        else
-            QVERIFY(obj->status() == QQuickImage::Ready);
-        if (QByteArray(QTest::currentDataTag()).startsWith("qimage"))
-            QCOMPARE(static_cast<TestQImageProvider*>(provider)->lastImageId, imageId);
-        else
-            QCOMPARE(static_cast<TestQPixmapProvider*>(provider)->lastImageId, imageId);
-
-        QCOMPARE(obj->width(), qreal(size.width()));
-        QCOMPARE(obj->height(), qreal(size.height()));
-        QCOMPARE(obj->fillMode(), QQuickImage::Stretch);
-        QCOMPARE(obj->progress(), 1.0);
-    } else {
-        if (async)
-            QTRY_VERIFY(obj->status() == QQuickImage::Error);
-        else
-            QVERIFY(obj->status() == QQuickImage::Error);
-    }
-
-    delete obj;
-}
-
-void tst_qqmlimageprovider::requestImage_sync_data()
-{
-    fillRequestTestsData("qimage|sync");
-}
-
-void tst_qqmlimageprovider::requestImage_sync()
-{
-    bool deleteWatch = false;
-    runTest(false, new TestQImageProvider(&deleteWatch));
-    QVERIFY(deleteWatch);
-}
-
-void tst_qqmlimageprovider::requestImage_async_data()
-{
-    fillRequestTestsData("qimage|async");
-}
-
-void tst_qqmlimageprovider::requestImage_async()
-{
-    bool deleteWatch = false;
-    runTest(true, new TestQImageProvider(&deleteWatch));
-    QVERIFY(deleteWatch);
-}
-
-void tst_qqmlimageprovider::requestPixmap_sync_data()
-{
-    fillRequestTestsData("qpixmap");
-}
-
-void tst_qqmlimageprovider::requestPixmap_sync()
-{
-    bool deleteWatch = false;
-    runTest(false, new TestQPixmapProvider(&deleteWatch));
-    QVERIFY(deleteWatch);
-}
-
-void tst_qqmlimageprovider::requestPixmap_async()
-{
-    QQmlEngine engine;
-    QQmlImageProvider *provider = new TestQPixmapProvider();
-
-    engine.addImageProvider("test", provider);
-    QVERIFY(engine.imageProvider("test") != 0);
-
-    // pixmaps are loaded synchronously regardless of 'asynchronous' value
-    QString componentStr = "import QtQuick 2.0\nImage { asynchronous: true; source: \"image://test/pixmap-async-test.png\" }";
-    QQmlComponent component(&engine);
-    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
-    QQuickImage *obj = qobject_cast<QQuickImage*>(component.create());
-    QVERIFY(obj != 0);
-
-    delete obj;
-}
-
-void tst_qqmlimageprovider::removeProvider_data()
-{
-    QTest::addColumn<QQmlImageProvider*>("provider");
-
-    QTest::newRow("qimage") << static_cast<QQmlImageProvider*>(new TestQImageProvider);
-    QTest::newRow("qpixmap") << static_cast<QQmlImageProvider*>(new TestQPixmapProvider);
-}
-
-void tst_qqmlimageprovider::removeProvider()
-{
-    QFETCH(QQmlImageProvider*, provider);
-
-    QQmlEngine engine;
-
-    engine.addImageProvider("test", provider);
-    QVERIFY(engine.imageProvider("test") != 0);
-
-    // add provider, confirm it works
-    QString componentStr = "import QtQuick 2.0\nImage { source: \"" + newImageFileName() + "\" }";
-    QQmlComponent component(&engine);
-    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
-    QQuickImage *obj = qobject_cast<QQuickImage*>(component.create());
-    QVERIFY(obj != 0);
-
-    QCOMPARE(obj->status(), QQuickImage::Ready);
-
-    // remove the provider and confirm
-    QString fileName = newImageFileName();
-    QString error("file::2:1: QML Image: Invalid image provider: " + fileName);
-    QTest::ignoreMessage(QtWarningMsg, error.toUtf8());
-
-    engine.removeImageProvider("test");
-
-    obj->setSource(QUrl(fileName));
-    QCOMPARE(obj->status(), QQuickImage::Error);
-
-    delete obj;
-}
-
-class TestThreadProvider : public QQmlImageProvider
-{
-    public:
-        TestThreadProvider() : QQmlImageProvider(Image), ok(false) {}
-
-        ~TestThreadProvider() {}
-
-        QImage requestImage(const QString &id, QSize *size, const QSize& requestedSize)
-        {
-            mutex.lock();
-            if (!ok)
-                cond.wait(&mutex);
-            mutex.unlock();
-            QVector<int> v;
-            for (int i = 0; i < 10000; i++)
-                v.prepend(i); //do some computation
-            QImage image(50,50, QImage::Format_RGB32);
-            image.fill(QColor(id).rgb());
-            if (size)
-                *size = image.size();
-            if (requestedSize.isValid())
-                image = image.scaled(requestedSize);
-            return image;
-        }
-
-        QWaitCondition cond;
-        QMutex mutex;
-        bool ok;
-};
-
-
-void tst_qqmlimageprovider::threadTest()
-{
-    QQmlEngine engine;
-
-    TestThreadProvider *provider = new TestThreadProvider;
-
-    engine.addImageProvider("test_thread", provider);
-    QVERIFY(engine.imageProvider("test_thread") != 0);
-
-    QString componentStr = "import QtQuick 2.0\nItem { \n"
-            "Image { source: \"image://test_thread/blue\";  asynchronous: true; }\n"
-            "Image { source: \"image://test_thread/red\";  asynchronous: true; }\n"
-            "Image { source: \"image://test_thread/green\";  asynchronous: true; }\n"
-            "Image { source: \"image://test_thread/yellow\";  asynchronous: true; }\n"
-            " }";
-    QQmlComponent component(&engine);
-    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
-    QObject *obj = component.create();
-    //MUST not deadlock
-    QVERIFY(obj != 0);
-    QList<QQuickImage *> images = obj->findChildren<QQuickImage *>();
-    QCOMPARE(images.count(), 4);
-    QTest::qWait(100);
-    foreach (QQuickImage *img, images) {
-        QCOMPARE(img->status(), QQuickImage::Loading);
-    }
-    provider->ok = true;
-    provider->cond.wakeAll();
-    QTest::qWait(250);
-    foreach (QQuickImage *img, images) {
-        QTRY_VERIFY(img->status() == QQuickImage::Ready);
-    }
-}
-
-
-QTEST_MAIN(tst_qqmlimageprovider)
-
-#include "tst_qqmlimageprovider.moc"
diff --git a/tests/auto/quick/qquickimageprovider/qquickimageprovider.pro b/tests/auto/quick/qquickimageprovider/qquickimageprovider.pro
new file mode 100644
index 0000000..269f06a
--- /dev/null
+++ b/tests/auto/quick/qquickimageprovider/qquickimageprovider.pro
@@ -0,0 +1,9 @@
+CONFIG += testcase
+TARGET = tst_qquickimageprovider
+macx:CONFIG -= app_bundle
+
+SOURCES += tst_qquickimageprovider.cpp
+
+CONFIG += parallel_test
+
+QT += core-private gui-private qml-private quick-private network testlib
diff --git a/tests/auto/quick/qquickimageprovider/tst_qquickimageprovider.cpp b/tests/auto/quick/qquickimageprovider/tst_qquickimageprovider.cpp
new file mode 100644
index 0000000..7f9a0ef
--- /dev/null
+++ b/tests/auto/quick/qquickimageprovider/tst_qquickimageprovider.cpp
@@ -0,0 +1,424 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <qtest.h>
+#include <QtTest/QtTest>
+#include <QtQml/qqmlengine.h>
+#include <QtQuick/qquickimageprovider.h>
+#include <private/qquickimage_p.h>
+#include <QImageReader>
+#include <QWaitCondition>
+
+Q_DECLARE_METATYPE(QQuickImageProvider*);
+
+class tst_qquickimageprovider : public QObject
+{
+    Q_OBJECT
+public:
+    tst_qquickimageprovider()
+    {
+    }
+
+private slots:
+    void requestImage_sync_data();
+    void requestImage_sync();
+    void requestImage_async_data();
+    void requestImage_async();
+
+    void requestPixmap_sync_data();
+    void requestPixmap_sync();
+    void requestPixmap_async();
+
+    void removeProvider_data();
+    void removeProvider();
+
+    void threadTest();
+
+private:
+    QString newImageFileName() const;
+    void fillRequestTestsData(const QString &id);
+    void runTest(bool async, QQuickImageProvider *provider);
+};
+
+
+class TestQImageProvider : public QQuickImageProvider
+{
+public:
+    TestQImageProvider(bool *deleteWatch = 0)
+        : QQuickImageProvider(Image), deleteWatch(deleteWatch)
+    {
+    }
+
+    ~TestQImageProvider()
+    {
+        if (deleteWatch)
+            *deleteWatch = true;
+    }
+
+    QImage requestImage(const QString &id, QSize *size, const QSize& requestedSize)
+    {
+        lastImageId = id;
+
+        if (id == QLatin1String("no-such-file.png"))
+            return QImage();
+
+        int width = 100; 
+        int height = 100;
+        QImage image(width, height, QImage::Format_RGB32);
+        if (size) 
+            *size = QSize(width, height);
+        if (requestedSize.isValid())
+            image = image.scaled(requestedSize);
+        return image;
+    }
+
+    bool *deleteWatch;
+    QString lastImageId;
+};
+Q_DECLARE_METATYPE(TestQImageProvider*);
+
+
+class TestQPixmapProvider : public QQuickImageProvider
+{
+public:
+    TestQPixmapProvider(bool *deleteWatch = 0)
+        : QQuickImageProvider(Pixmap), deleteWatch(deleteWatch)
+    {
+    }
+
+    ~TestQPixmapProvider()
+    {
+        if (deleteWatch)
+            *deleteWatch = true;
+    }
+
+    QPixmap requestPixmap(const QString &id, QSize *size, const QSize& requestedSize)
+    {
+        lastImageId = id;
+
+        if (id == QLatin1String("no-such-file.png"))
+            return QPixmap();
+
+        int width = 100; 
+        int height = 100;
+        QPixmap image(width, height);
+        if (size) 
+            *size = QSize(width, height);
+        if (requestedSize.isValid())
+            image = image.scaled(requestedSize);
+        return image;
+    }
+
+    bool *deleteWatch;
+    QString lastImageId;
+};
+Q_DECLARE_METATYPE(TestQPixmapProvider*);
+
+
+QString tst_qquickimageprovider::newImageFileName() const
+{
+    // need to generate new filenames each time or else images are loaded
+    // from cache and we won't get loading status changes when testing 
+    // async loading
+    static int count = 0;
+    return QString("image://test/image-%1.png").arg(count++);
+}
+
+void tst_qquickimageprovider::fillRequestTestsData(const QString &id)
+{
+    QTest::addColumn<QString>("source");
+    QTest::addColumn<QString>("imageId");
+    QTest::addColumn<QString>("properties");
+    QTest::addColumn<QSize>("size");
+    QTest::addColumn<QString>("error");
+
+    QString fileName = newImageFileName();
+    QTest::newRow(QTest::toString(id + " simple test"))
+            << "image://test/" + fileName << fileName << "" << QSize(100,100) << "";
+
+    fileName = newImageFileName();
+    QTest::newRow(QTest::toString(id + " simple test with capitalization"))//As it's a URL, should make no difference
+            << "image://Test/" + fileName << fileName << "" << QSize(100,100) << "";
+
+    fileName = newImageFileName();
+    QTest::newRow(QTest::toString(id + " url with no id"))
+        << "image://test/" + fileName << "" + fileName << "" << QSize(100,100) << "";
+
+    fileName = newImageFileName();
+    QTest::newRow(QTest::toString(id + " url with path"))
+        << "image://test/test/path" + fileName << "test/path" + fileName << "" << QSize(100,100) << "";
+
+    fileName = newImageFileName();
+    QTest::newRow(QTest::toString(id + " url with fragment"))
+        << "image://test/faq.html?#question13" + fileName << "faq.html?#question13" + fileName << "" << QSize(100,100) << "";
+
+    fileName = newImageFileName();
+    QTest::newRow(QTest::toString(id + " url with query"))
+        << "image://test/cgi-bin/drawgraph.cgi?type=pie&color=green" + fileName << "cgi-bin/drawgraph.cgi?type=pie&color=green" + fileName
+        << "" << QSize(100,100) << "";
+
+    fileName = newImageFileName();
+    QTest::newRow(QTest::toString(id + " scaled image"))
+            << "image://test/" + fileName << fileName << "sourceSize: \"80x30\"" << QSize(80,30) << "";
+
+    QTest::newRow(QTest::toString(id + " missing"))
+        << "image://test/no-such-file.png" << "no-such-file.png" << "" << QSize(100,100)
+        << "file::2:1: QML Image: Failed to get image from provider: image://test/no-such-file.png";
+
+    QTest::newRow(QTest::toString(id + " unknown provider"))
+        << "image://bogus/exists.png" << "" << "" << QSize()
+        << "file::2:1: QML Image: Invalid image provider: image://bogus/exists.png";
+}
+
+void tst_qquickimageprovider::runTest(bool async, QQuickImageProvider *provider)
+{
+    QFETCH(QString, source);
+    QFETCH(QString, imageId);
+    QFETCH(QString, properties);
+    QFETCH(QSize, size);
+    QFETCH(QString, error);
+
+    if (!error.isEmpty())
+        QTest::ignoreMessage(QtWarningMsg, error.toUtf8());
+
+    QQmlEngine engine;
+
+    engine.addImageProvider("test", provider);
+    QVERIFY(engine.imageProvider("test") != 0);
+
+    QString componentStr = "import QtQuick 2.0\nImage { source: \"" + source + "\"; " 
+            + (async ? "asynchronous: true; " : "")
+            + properties + " }";
+    QQmlComponent component(&engine);
+    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
+    QQuickImage *obj = qobject_cast<QQuickImage*>(component.create());
+    QVERIFY(obj != 0);
+
+    if (async) 
+        QTRY_VERIFY(obj->status() == QQuickImage::Loading);
+
+    QCOMPARE(obj->source(), QUrl(source));
+
+    if (error.isEmpty()) {
+        if (async)
+            QTRY_VERIFY(obj->status() == QQuickImage::Ready);
+        else
+            QVERIFY(obj->status() == QQuickImage::Ready);
+        if (QByteArray(QTest::currentDataTag()).startsWith("qimage"))
+            QCOMPARE(static_cast<TestQImageProvider*>(provider)->lastImageId, imageId);
+        else
+            QCOMPARE(static_cast<TestQPixmapProvider*>(provider)->lastImageId, imageId);
+
+        QCOMPARE(obj->width(), qreal(size.width()));
+        QCOMPARE(obj->height(), qreal(size.height()));
+        QCOMPARE(obj->fillMode(), QQuickImage::Stretch);
+        QCOMPARE(obj->progress(), 1.0);
+    } else {
+        if (async)
+            QTRY_VERIFY(obj->status() == QQuickImage::Error);
+        else
+            QVERIFY(obj->status() == QQuickImage::Error);
+    }
+
+    delete obj;
+}
+
+void tst_qquickimageprovider::requestImage_sync_data()
+{
+    fillRequestTestsData("qimage|sync");
+}
+
+void tst_qquickimageprovider::requestImage_sync()
+{
+    bool deleteWatch = false;
+    runTest(false, new TestQImageProvider(&deleteWatch));
+    QVERIFY(deleteWatch);
+}
+
+void tst_qquickimageprovider::requestImage_async_data()
+{
+    fillRequestTestsData("qimage|async");
+}
+
+void tst_qquickimageprovider::requestImage_async()
+{
+    bool deleteWatch = false;
+    runTest(true, new TestQImageProvider(&deleteWatch));
+    QVERIFY(deleteWatch);
+}
+
+void tst_qquickimageprovider::requestPixmap_sync_data()
+{
+    fillRequestTestsData("qpixmap");
+}
+
+void tst_qquickimageprovider::requestPixmap_sync()
+{
+    bool deleteWatch = false;
+    runTest(false, new TestQPixmapProvider(&deleteWatch));
+    QVERIFY(deleteWatch);
+}
+
+void tst_qquickimageprovider::requestPixmap_async()
+{
+    QQmlEngine engine;
+    QQuickImageProvider *provider = new TestQPixmapProvider();
+
+    engine.addImageProvider("test", provider);
+    QVERIFY(engine.imageProvider("test") != 0);
+
+    // pixmaps are loaded synchronously regardless of 'asynchronous' value
+    QString componentStr = "import QtQuick 2.0\nImage { asynchronous: true; source: \"image://test/pixmap-async-test.png\" }";
+    QQmlComponent component(&engine);
+    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
+    QQuickImage *obj = qobject_cast<QQuickImage*>(component.create());
+    QVERIFY(obj != 0);
+
+    delete obj;
+}
+
+void tst_qquickimageprovider::removeProvider_data()
+{
+    QTest::addColumn<QQuickImageProvider*>("provider");
+
+    QTest::newRow("qimage") << static_cast<QQuickImageProvider*>(new TestQImageProvider);
+    QTest::newRow("qpixmap") << static_cast<QQuickImageProvider*>(new TestQPixmapProvider);
+}
+
+void tst_qquickimageprovider::removeProvider()
+{
+    QFETCH(QQuickImageProvider*, provider);
+
+    QQmlEngine engine;
+
+    engine.addImageProvider("test", provider);
+    QVERIFY(engine.imageProvider("test") != 0);
+
+    // add provider, confirm it works
+    QString componentStr = "import QtQuick 2.0\nImage { source: \"" + newImageFileName() + "\" }";
+    QQmlComponent component(&engine);
+    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
+    QQuickImage *obj = qobject_cast<QQuickImage*>(component.create());
+    QVERIFY(obj != 0);
+
+    QCOMPARE(obj->status(), QQuickImage::Ready);
+
+    // remove the provider and confirm
+    QString fileName = newImageFileName();
+    QString error("file::2:1: QML Image: Invalid image provider: " + fileName);
+    QTest::ignoreMessage(QtWarningMsg, error.toUtf8());
+
+    engine.removeImageProvider("test");
+
+    obj->setSource(QUrl(fileName));
+    QCOMPARE(obj->status(), QQuickImage::Error);
+
+    delete obj;
+}
+
+class TestThreadProvider : public QQuickImageProvider
+{
+    public:
+        TestThreadProvider() : QQuickImageProvider(Image), ok(false) {}
+
+        ~TestThreadProvider() {}
+
+        QImage requestImage(const QString &id, QSize *size, const QSize& requestedSize)
+        {
+            mutex.lock();
+            if (!ok)
+                cond.wait(&mutex);
+            mutex.unlock();
+            QVector<int> v;
+            for (int i = 0; i < 10000; i++)
+                v.prepend(i); //do some computation
+            QImage image(50,50, QImage::Format_RGB32);
+            image.fill(QColor(id).rgb());
+            if (size)
+                *size = image.size();
+            if (requestedSize.isValid())
+                image = image.scaled(requestedSize);
+            return image;
+        }
+
+        QWaitCondition cond;
+        QMutex mutex;
+        bool ok;
+};
+
+
+void tst_qquickimageprovider::threadTest()
+{
+    QQmlEngine engine;
+
+    TestThreadProvider *provider = new TestThreadProvider;
+
+    engine.addImageProvider("test_thread", provider);
+    QVERIFY(engine.imageProvider("test_thread") != 0);
+
+    QString componentStr = "import QtQuick 2.0\nItem { \n"
+            "Image { source: \"image://test_thread/blue\";  asynchronous: true; }\n"
+            "Image { source: \"image://test_thread/red\";  asynchronous: true; }\n"
+            "Image { source: \"image://test_thread/green\";  asynchronous: true; }\n"
+            "Image { source: \"image://test_thread/yellow\";  asynchronous: true; }\n"
+            " }";
+    QQmlComponent component(&engine);
+    component.setData(componentStr.toLatin1(), QUrl::fromLocalFile(""));
+    QObject *obj = component.create();
+    //MUST not deadlock
+    QVERIFY(obj != 0);
+    QList<QQuickImage *> images = obj->findChildren<QQuickImage *>();
+    QCOMPARE(images.count(), 4);
+    QTest::qWait(100);
+    foreach (QQuickImage *img, images) {
+        QCOMPARE(img->status(), QQuickImage::Loading);
+    }
+    provider->ok = true;
+    provider->cond.wakeAll();
+    QTest::qWait(250);
+    foreach (QQuickImage *img, images) {
+        QTRY_VERIFY(img->status() == QQuickImage::Ready);
+    }
+}
+
+
+QTEST_MAIN(tst_qquickimageprovider)
+
+#include "tst_qquickimageprovider.moc"
diff --git a/tests/auto/quick/qquickpixmapcache/tst_qquickpixmapcache.cpp b/tests/auto/quick/qquickpixmapcache/tst_qquickpixmapcache.cpp
index 855322e..8d2eb66 100644
--- a/tests/auto/quick/qquickpixmapcache/tst_qquickpixmapcache.cpp
+++ b/tests/auto/quick/qquickpixmapcache/tst_qquickpixmapcache.cpp
@@ -42,7 +42,7 @@
 #include <QtTest/QtTest>
 #include <QtQuick/private/qquickpixmapcache_p.h>
 #include <QtQml/qqmlengine.h>
-#include <QtQml/qqmlimageprovider.h>
+#include <QtQuick/qquickimageprovider.h>
 #include <QNetworkReply>
 #include "../../shared/util.h"
 #include "testhttpserver.h"
@@ -335,11 +335,11 @@ void tst_qquickpixmapcache::cancelcrash()
     }
 }
 
-class MyPixmapProvider : public QQmlImageProvider
+class MyPixmapProvider : public QQuickImageProvider
 {
 public:
     MyPixmapProvider()
-    : QQmlImageProvider(Pixmap) {}
+    : QQuickImageProvider(Pixmap) {}
 
     virtual QPixmap requestPixmap(const QString &d, QSize *, const QSize &) {
         Q_UNUSED(d)
diff --git a/tests/auto/quick/quick.pro b/tests/auto/quick/quick.pro
index 4065dbf..45fa976 100644
--- a/tests/auto/quick/quick.pro
+++ b/tests/auto/quick/quick.pro
@@ -15,6 +15,7 @@ PRIVATETESTS += \
     qquickapplication \
     qquickbehaviors \
     qquickfontloader \
+    qquickimageprovider \
     qquickpath \
     qquicksmoothedanimation \
     qquickspringanimation \