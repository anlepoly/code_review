diff --git a/src/gui/gui.pro b/src/gui/gui.pro
index 29e233d..198b588 100644
--- a/src/gui/gui.pro
+++ b/src/gui/gui.pro
@@ -59,54 +59,6 @@ win32:!contains(QT_CONFIG, directwrite) {
 }
 
     win32-g++*|!win32:!win32-icc*:!macx-icc* {
-        mmx {
-            mmx_compiler.commands = $$QMAKE_CXX -c -Winline
-            mmx_compiler.commands += -mmmx
-            mmx_compiler.commands += $(CXXFLAGS) $(INCPATH) ${QMAKE_FILE_IN} -o ${QMAKE_FILE_OUT}
-            mmx_compiler.dependency_type = TYPE_C
-            mmx_compiler.output = ${QMAKE_VAR_OBJECTS_DIR}${QMAKE_FILE_BASE}$${first(QMAKE_EXT_OBJ)}
-            mmx_compiler.input = MMX_SOURCES
-            mmx_compiler.variable_out = OBJECTS
-            mmx_compiler.name = compiling[mmx] ${QMAKE_FILE_IN}
-            silent:mmx_compiler.commands = @echo compiling[mmx] ${QMAKE_FILE_IN} && $$mmx_compiler.commands
-            QMAKE_EXTRA_COMPILERS += mmx_compiler
-        }
-        3dnow {
-            mmx3dnow_compiler.commands = $$QMAKE_CXX -c -Winline
-            mmx3dnow_compiler.commands += -m3dnow -mmmx
-            mmx3dnow_compiler.commands += $(CXXFLAGS) $(INCPATH) ${QMAKE_FILE_IN} -o ${QMAKE_FILE_OUT}
-            mmx3dnow_compiler.dependency_type = TYPE_C
-            mmx3dnow_compiler.output = ${QMAKE_VAR_OBJECTS_DIR}${QMAKE_FILE_BASE}$${first(QMAKE_EXT_OBJ)}
-            mmx3dnow_compiler.input = MMX3DNOW_SOURCES
-            mmx3dnow_compiler.variable_out = OBJECTS
-            mmx3dnow_compiler.name = compiling[mmx3dnow] ${QMAKE_FILE_IN}
-            silent:mmx3dnow_compiler.commands = @echo compiling[mmx3dnow] ${QMAKE_FILE_IN} && $$mmx3dnow_compiler.commands
-            QMAKE_EXTRA_COMPILERS += mmx3dnow_compiler
-            sse {
-                sse3dnow_compiler.commands = $$QMAKE_CXX -c -Winline
-                sse3dnow_compiler.commands += -m3dnow -msse
-                sse3dnow_compiler.commands += $(CXXFLAGS) $(INCPATH) ${QMAKE_FILE_IN} -o ${QMAKE_FILE_OUT}
-                sse3dnow_compiler.dependency_type = TYPE_C
-                sse3dnow_compiler.output = ${QMAKE_VAR_OBJECTS_DIR}${QMAKE_FILE_BASE}$${first(QMAKE_EXT_OBJ)}
-                sse3dnow_compiler.input = SSE3DNOW_SOURCES
-                sse3dnow_compiler.variable_out = OBJECTS
-                sse3dnow_compiler.name = compiling[sse3dnow] ${QMAKE_FILE_IN}
-                silent:sse3dnow_compiler.commands = @echo compiling[sse3dnow] ${QMAKE_FILE_IN} && $$sse3dnow_compiler.commands
-                QMAKE_EXTRA_COMPILERS += sse3dnow_compiler
-            }
-        }
-        sse {
-            sse_compiler.commands = $$QMAKE_CXX -c -Winline
-            sse_compiler.commands += -msse
-            sse_compiler.commands += $(CXXFLAGS) $(INCPATH) ${QMAKE_FILE_IN} -o ${QMAKE_FILE_OUT}
-            sse_compiler.dependency_type = TYPE_C
-            sse_compiler.output = ${QMAKE_VAR_OBJECTS_DIR}${QMAKE_FILE_BASE}$${first(QMAKE_EXT_OBJ)}
-            sse_compiler.input = SSE_SOURCES
-            sse_compiler.variable_out = OBJECTS
-            sse_compiler.name = compiling[sse] ${QMAKE_FILE_IN}
-            silent:sse_compiler.commands = @echo compiling[sse] ${QMAKE_FILE_IN} && $$sse_compiler.commands
-            QMAKE_EXTRA_COMPILERS += sse_compiler
-        }
         sse2 {
             sse2_compiler.commands = $$QMAKE_CXX -c -Winline
             sse2_compiler.commands += -msse2
diff --git a/src/gui/painting/painting.pri b/src/gui/painting/painting.pri
index 3ce2e5b..0792343 100644
--- a/src/gui/painting/painting.pri
+++ b/src/gui/painting/painting.pri
@@ -93,13 +93,7 @@ SOURCES += \
 
 if(mmx|3dnow|sse|sse2|iwmmxt) {
     HEADERS += painting/qdrawhelper_x86_p.h \
-               painting/qdrawhelper_mmx_p.h \
-               painting/qdrawhelper_sse_p.h \
                painting/qdrawingprimitive_sse2_p.h
-    MMX_SOURCES += painting/qdrawhelper_mmx.cpp
-    MMX3DNOW_SOURCES += painting/qdrawhelper_mmx3dnow.cpp
-    SSE3DNOW_SOURCES += painting/qdrawhelper_sse3dnow.cpp
-    SSE_SOURCES += painting/qdrawhelper_sse.cpp
     SSE2_SOURCES += painting/qdrawhelper_sse2.cpp
     SSSE3_SOURCES += painting/qdrawhelper_ssse3.cpp
     IWMMXT_SOURCES += painting/qdrawhelper_iwmmxt.cpp
diff --git a/src/gui/painting/qdrawhelper.cpp b/src/gui/painting/qdrawhelper.cpp
index 7571d81..3aea794 100644
--- a/src/gui/painting/qdrawhelper.cpp
+++ b/src/gui/painting/qdrawhelper.cpp
@@ -5862,66 +5862,7 @@ void qInitDrawhelperAsm()
         qScaleFunctions[QImage::Format_ARGB32_Premultiplied][QImage::Format_ARGB32_Premultiplied] = qt_scale_image_argb32_on_argb32_sse2;
         qScaleFunctions[QImage::Format_RGB32][QImage::Format_ARGB32_Premultiplied] = qt_scale_image_argb32_on_argb32_sse2;
 #endif
-#ifdef QT_HAVE_SSE
-    } else if (features & SSE) {
-//        qt_memfill32 = qt_memfill32_sse;
-        qDrawHelper[QImage::Format_RGB16].bitmapBlit = qt_bitmapblit16_sse;
-#ifdef QT_HAVE_3DNOW
-        if (features & MMX3DNOW) {
-            qt_memfill32 = qt_memfill32_sse3dnow;
-            qDrawHelper[QImage::Format_RGB16].bitmapBlit = qt_bitmapblit16_sse3dnow;
-        }
-#endif
-#endif // SSE
-    }
-#ifdef QT_HAVE_MMX
-    if (features & MMX) {
-        functionForModeAsm = qt_functionForMode_MMX;
-
-        functionForModeSolidAsm = qt_functionForModeSolid_MMX;
-        qDrawHelper[QImage::Format_ARGB32_Premultiplied].blendColor = qt_blend_color_argb_mmx;
-#ifdef QT_HAVE_3DNOW
-        if (features & MMX3DNOW) {
-            functionForModeAsm = qt_functionForMode_MMX3DNOW;
-            functionForModeSolidAsm = qt_functionForModeSolid_MMX3DNOW;
-            qDrawHelper[QImage::Format_ARGB32_Premultiplied].blendColor = qt_blend_color_argb_mmx3dnow;
-        }
-#endif // 3DNOW
-
-        extern void qt_blend_rgb32_on_rgb32_mmx(uchar *destPixels, int dbpl,
-                                                const uchar *srcPixels, int sbpl,
-                                                int w, int h,
-                                                int const_alpha);
-        extern void qt_blend_argb32_on_argb32_mmx(uchar *destPixels, int dbpl,
-                                                  const uchar *srcPixels, int sbpl,
-                                                  int w, int h,
-                                                  int const_alpha);
-
-        qBlendFunctions[QImage::Format_RGB32][QImage::Format_RGB32] = qt_blend_rgb32_on_rgb32_mmx;
-        qBlendFunctions[QImage::Format_ARGB32_Premultiplied][QImage::Format_RGB32] = qt_blend_rgb32_on_rgb32_mmx;
-        qBlendFunctions[QImage::Format_RGB32][QImage::Format_ARGB32_Premultiplied] = qt_blend_argb32_on_argb32_mmx;
-        qBlendFunctions[QImage::Format_ARGB32_Premultiplied][QImage::Format_ARGB32_Premultiplied] = qt_blend_argb32_on_argb32_mmx;
-
-    }
-#endif // MMX
-
-#ifdef QT_HAVE_SSE
-    if (features & SSE) {
-        extern void qt_blend_rgb32_on_rgb32_sse(uchar *destPixels, int dbpl,
-                                                const uchar *srcPixels, int sbpl,
-                                                int w, int h,
-                                                int const_alpha);
-        extern void qt_blend_argb32_on_argb32_sse(uchar *destPixels, int dbpl,
-                                                  const uchar *srcPixels, int sbpl,
-                                                  int w, int h,
-                                                  int const_alpha);
-
-        qBlendFunctions[QImage::Format_RGB32][QImage::Format_RGB32] = qt_blend_rgb32_on_rgb32_sse;
-        qBlendFunctions[QImage::Format_ARGB32_Premultiplied][QImage::Format_RGB32] = qt_blend_rgb32_on_rgb32_sse;
-        qBlendFunctions[QImage::Format_RGB32][QImage::Format_ARGB32_Premultiplied] = qt_blend_argb32_on_argb32_sse;
-        qBlendFunctions[QImage::Format_ARGB32_Premultiplied][QImage::Format_ARGB32_Premultiplied] = qt_blend_argb32_on_argb32_sse;
-    }
-#endif // SSE
+    }
 
 #ifdef QT_HAVE_SSE2
     if (features & SSE2) {
@@ -5959,44 +5900,12 @@ void qInitDrawhelperAsm()
 
 #endif // SSE2
 
-#ifdef QT_HAVE_SSE
-    if (features & SSE) {
-        functionForModeAsm = qt_functionForMode_SSE;
-        functionForModeSolidAsm = qt_functionForModeSolid_SSE;
-        qDrawHelper[QImage::Format_ARGB32_Premultiplied].blendColor = qt_blend_color_argb_sse;
-#ifdef QT_HAVE_3DNOW
-        if (features & MMX3DNOW) {
-            functionForModeAsm = qt_functionForMode_SSE3DNOW;
-            functionForModeSolidAsm = qt_functionForModeSolid_SSE3DNOW;
-            qDrawHelper[QImage::Format_ARGB32_Premultiplied].blendColor = qt_blend_color_argb_sse3dnow;
-        }
-#endif // 3DNOW
-
-
 #ifdef QT_HAVE_SSE2
-        if (features & SSE2) {
-            extern void QT_FASTCALL comp_func_SourceOver_sse2(uint *destPixels,
-                                                              const uint *srcPixels,
-                                                              int length,
-                                                              uint const_alpha);
-            extern void QT_FASTCALL comp_func_solid_SourceOver_sse2(uint *destPixels, int length, uint color, uint const_alpha);
-            extern void QT_FASTCALL comp_func_Plus_sse2(uint *dst, const uint *src, int length, uint const_alpha);
-            extern void QT_FASTCALL comp_func_Source_sse2(uint *dst, const uint *src, int length, uint const_alpha);
-
-            functionForModeAsm[0] = comp_func_SourceOver_sse2;
-            functionForModeAsm[QPainter::CompositionMode_Source] = comp_func_Source_sse2;
-            functionForModeAsm[QPainter::CompositionMode_Plus] = comp_func_Plus_sse2;
-            functionForModeSolidAsm[0] = comp_func_solid_SourceOver_sse2;
-        }
-#endif
-    }
-#elif defined(QT_HAVE_SSE2)
-    // this is the special case when SSE2 is usable but MMX/SSE is not usable (e.g.: Windows x64 + visual studio)
     if (features & SSE2) {
-        functionForModeAsm = qt_functionForMode_onlySSE2;
-        functionForModeSolidAsm = qt_functionForModeSolid_onlySSE2;
+        functionForModeAsm = qt_functionForMode_SSE2;
+        functionForModeSolidAsm = qt_functionForModeSolid_SSE2;
     }
-#endif
+#endif // SSE2
 
 #ifdef QT_HAVE_IWMMXT
     if (features & IWMMXT) {
diff --git a/src/gui/painting/qdrawhelper_mmx.cpp b/src/gui/painting/qdrawhelper_mmx.cpp
deleted file mode 100644
index 520ce6e..0000000
--- a/src/gui/painting/qdrawhelper_mmx.cpp
+++ /dev/null
@@ -1,155 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <private/qdrawhelper_p.h>
-
-#if defined(QT_HAVE_MMX)
-
-#include <private/qdrawhelper_mmx_p.h>
-
-QT_BEGIN_NAMESPACE
-
-CompositionFunctionSolid qt_functionForModeSolid_MMX[numCompositionFunctions] = {
-    comp_func_solid_SourceOver<QMMXIntrinsics>,
-    comp_func_solid_DestinationOver<QMMXIntrinsics>,
-    comp_func_solid_Clear<QMMXIntrinsics>,
-    comp_func_solid_Source<QMMXIntrinsics>,
-    0,
-    comp_func_solid_SourceIn<QMMXIntrinsics>,
-    comp_func_solid_DestinationIn<QMMXIntrinsics>,
-    comp_func_solid_SourceOut<QMMXIntrinsics>,
-    comp_func_solid_DestinationOut<QMMXIntrinsics>,
-    comp_func_solid_SourceAtop<QMMXIntrinsics>,
-    comp_func_solid_DestinationAtop<QMMXIntrinsics>,
-    comp_func_solid_XOR<QMMXIntrinsics>,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // svg 1.2 modes
-    rasterop_solid_SourceOrDestination<QMMXIntrinsics>,
-    rasterop_solid_SourceAndDestination<QMMXIntrinsics>,
-    rasterop_solid_SourceXorDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSourceAndNotDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSourceOrNotDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSourceXorDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSource<QMMXIntrinsics>,
-    rasterop_solid_NotSourceAndDestination<QMMXIntrinsics>,
-    rasterop_solid_SourceAndNotDestination<QMMXIntrinsics>
-};
-
-CompositionFunction qt_functionForMode_MMX[numCompositionFunctions] = {
-    comp_func_SourceOver<QMMXIntrinsics>,
-    comp_func_DestinationOver<QMMXIntrinsics>,
-    comp_func_Clear<QMMXIntrinsics>,
-    comp_func_Source<QMMXIntrinsics>,
-    comp_func_Destination,
-    comp_func_SourceIn<QMMXIntrinsics>,
-    comp_func_DestinationIn<QMMXIntrinsics>,
-    comp_func_SourceOut<QMMXIntrinsics>,
-    comp_func_DestinationOut<QMMXIntrinsics>,
-    comp_func_SourceAtop<QMMXIntrinsics>,
-    comp_func_DestinationAtop<QMMXIntrinsics>,
-    comp_func_XOR<QMMXIntrinsics>,
-    comp_func_Plus,
-    comp_func_Multiply,
-    comp_func_Screen,
-    comp_func_Overlay,
-    comp_func_Darken,
-    comp_func_Lighten,
-    comp_func_ColorDodge,
-    comp_func_ColorBurn,
-    comp_func_HardLight,
-    comp_func_SoftLight,
-    comp_func_Difference,
-    comp_func_Exclusion,
-    rasterop_SourceOrDestination,
-    rasterop_SourceAndDestination,
-    rasterop_SourceXorDestination,
-    rasterop_NotSourceAndNotDestination,
-    rasterop_NotSourceOrNotDestination,
-    rasterop_NotSourceXorDestination,
-    rasterop_NotSource,
-    rasterop_NotSourceAndDestination,
-    rasterop_SourceAndNotDestination
-};
-
-void qt_blend_color_argb_mmx(int count, const QSpan *spans, void *userData)
-{
-    qt_blend_color_argb_x86<QMMXIntrinsics>(count, spans, userData,
-                                            (CompositionFunctionSolid*)qt_functionForModeSolid_MMX);
-}
-
-
-void qt_blend_argb32_on_argb32_mmx(uchar *destPixels, int dbpl,
-                                   const uchar *srcPixels, int sbpl,
-                                   int w, int h,
-                                   int const_alpha)
-{
-    const uint *src = (const uint *) srcPixels;
-    uint *dst = (uint *) destPixels;
-
-    uint ca = const_alpha - 1;
-
-    for (int y=0; y<h; ++y) {
-        comp_func_SourceOver<QMMXIntrinsics>(dst, src, w, ca);
-        dst = (quint32 *)(((uchar *) dst) + dbpl);
-        src = (const quint32 *)(((const uchar *) src) + sbpl);
-    }
-}
-
-void qt_blend_rgb32_on_rgb32_mmx(uchar *destPixels, int dbpl,
-                                 const uchar *srcPixels, int sbpl,
-                                 int w, int h,
-                                 int const_alpha)
-{
-    const uint *src = (const uint *) srcPixels;
-    uint *dst = (uint *) destPixels;
-
-    uint ca = const_alpha - 1;
-
-    for (int y=0; y<h; ++y) {
-        comp_func_Source<QMMXIntrinsics>(dst, src, w, ca);
-        dst = (quint32 *)(((uchar *) dst) + dbpl);
-        src = (const quint32 *)(((const uchar *) src) + sbpl);
-    }
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_HAVE_MMX
-
diff --git a/src/gui/painting/qdrawhelper_mmx3dnow.cpp b/src/gui/painting/qdrawhelper_mmx3dnow.cpp
deleted file mode 100644
index 71469b6..0000000
--- a/src/gui/painting/qdrawhelper_mmx3dnow.cpp
+++ /dev/null
@@ -1,128 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <private/qdrawhelper_x86_p.h>
-
-#ifdef QT_HAVE_3DNOW
-
-#include <private/qdrawhelper_mmx_p.h>
-#include <mm3dnow.h>
-
-QT_BEGIN_NAMESPACE
-
-struct QMMX3DNOWIntrinsics : public QMMXCommonIntrinsics
-{
-    static inline void end() {
-        _m_femms();
-    }
-};
-
-CompositionFunctionSolid qt_functionForModeSolid_MMX3DNOW[numCompositionFunctions] = {
-    comp_func_solid_SourceOver<QMMX3DNOWIntrinsics>,
-    comp_func_solid_DestinationOver<QMMX3DNOWIntrinsics>,
-    comp_func_solid_Clear<QMMX3DNOWIntrinsics>,
-    comp_func_solid_Source<QMMX3DNOWIntrinsics>,
-    0,
-    comp_func_solid_SourceIn<QMMX3DNOWIntrinsics>,
-    comp_func_solid_DestinationIn<QMMX3DNOWIntrinsics>,
-    comp_func_solid_SourceOut<QMMX3DNOWIntrinsics>,
-    comp_func_solid_DestinationOut<QMMX3DNOWIntrinsics>,
-    comp_func_solid_SourceAtop<QMMX3DNOWIntrinsics>,
-    comp_func_solid_DestinationAtop<QMMX3DNOWIntrinsics>,
-    comp_func_solid_XOR<QMMX3DNOWIntrinsics>,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // svg 1.2 modes
-    rasterop_solid_SourceOrDestination<QMMX3DNOWIntrinsics>,
-    rasterop_solid_SourceAndDestination<QMMX3DNOWIntrinsics>,
-    rasterop_solid_SourceXorDestination<QMMX3DNOWIntrinsics>,
-    rasterop_solid_NotSourceAndNotDestination<QMMX3DNOWIntrinsics>,
-    rasterop_solid_NotSourceOrNotDestination<QMMX3DNOWIntrinsics>,
-    rasterop_solid_NotSourceXorDestination<QMMX3DNOWIntrinsics>,
-    rasterop_solid_NotSource<QMMX3DNOWIntrinsics>,
-    rasterop_solid_NotSourceAndDestination<QMMX3DNOWIntrinsics>,
-    rasterop_solid_SourceAndNotDestination<QMMX3DNOWIntrinsics>
-};
-
-CompositionFunction qt_functionForMode_MMX3DNOW[numCompositionFunctions] = {
-    comp_func_SourceOver<QMMX3DNOWIntrinsics>,
-    comp_func_DestinationOver<QMMX3DNOWIntrinsics>,
-    comp_func_Clear<QMMX3DNOWIntrinsics>,
-    comp_func_Source<QMMX3DNOWIntrinsics>,
-    comp_func_Destination,
-    comp_func_SourceIn<QMMX3DNOWIntrinsics>,
-    comp_func_DestinationIn<QMMX3DNOWIntrinsics>,
-    comp_func_SourceOut<QMMX3DNOWIntrinsics>,
-    comp_func_DestinationOut<QMMX3DNOWIntrinsics>,
-    comp_func_SourceAtop<QMMX3DNOWIntrinsics>,
-    comp_func_DestinationAtop<QMMX3DNOWIntrinsics>,
-    comp_func_XOR<QMMX3DNOWIntrinsics>,
-    comp_func_Plus,
-    comp_func_Multiply,
-    comp_func_Screen,
-    comp_func_Overlay,
-    comp_func_Darken,
-    comp_func_Lighten,
-    comp_func_ColorDodge,
-    comp_func_ColorBurn,
-    comp_func_HardLight,
-    comp_func_SoftLight,
-    comp_func_Difference,
-    comp_func_Exclusion,
-    rasterop_SourceOrDestination,
-    rasterop_SourceAndDestination,
-    rasterop_SourceXorDestination,
-    rasterop_NotSourceAndNotDestination,
-    rasterop_NotSourceOrNotDestination,
-    rasterop_NotSourceXorDestination,
-    rasterop_NotSource,
-    rasterop_NotSourceAndDestination,
-    rasterop_SourceAndNotDestination
-};
-
-void qt_blend_color_argb_mmx3dnow(int count, const QSpan *spans, void *userData)
-{
-    qt_blend_color_argb_x86<QMMX3DNOWIntrinsics>(count, spans, userData,
-                                                 (CompositionFunctionSolid*)qt_functionForModeSolid_MMX3DNOW);
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_HAVE_3DNOW
-
diff --git a/src/gui/painting/qdrawhelper_mmx_p.h b/src/gui/painting/qdrawhelper_mmx_p.h
deleted file mode 100644
index 5038292..0000000
--- a/src/gui/painting/qdrawhelper_mmx_p.h
+++ /dev/null
@@ -1,892 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QDRAWHELPER_MMX_P_H
-#define QDRAWHELPER_MMX_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <private/qdrawhelper_p.h>
-#include <private/qdrawhelper_x86_p.h>
-#include <private/qpaintengine_raster_p.h>
-
-#ifdef QT_HAVE_MMX
-#include <mmintrin.h>
-#endif
-
-#define C_FF const m64 mmx_0x00ff = _mm_set1_pi16(0xff)
-#define C_80 const m64 mmx_0x0080 = _mm_set1_pi16(0x80)
-#define C_00 const m64 mmx_0x0000 = _mm_setzero_si64()
-
-#ifdef Q_CC_MSVC
-#  pragma warning(disable: 4799) // No EMMS at end of function
-#endif
-
-typedef __m64 m64;
-
-QT_BEGIN_NAMESPACE
-
-struct QMMXCommonIntrinsics
-{
-    static inline m64 alpha(m64 x) {
-        x = _mm_unpackhi_pi16(x, x);
-        x = _mm_unpackhi_pi16(x, x);
-        return x;
-    }
-
-    static inline m64 _negate(const m64 &x, const m64 &mmx_0x00ff) {
-        return _mm_xor_si64(x, mmx_0x00ff);
-    }
-
-    static inline m64 add(const m64 &a, const m64 &b) {
-        return  _mm_adds_pu16 (a, b);
-    }
-
-    static inline m64 _byte_mul(const m64 &a, const m64 &b,
-                                const m64 &mmx_0x0080)
-    {
-        m64 res = _mm_mullo_pi16(a, b);
-        res = _mm_adds_pu16(res, mmx_0x0080);
-        res = _mm_adds_pu16(res, _mm_srli_pi16 (res, 8));
-        return _mm_srli_pi16(res, 8);
-    }
-
-    static inline m64 interpolate_pixel_256(const m64 &x, const m64 &a,
-                                           const m64 &y, const m64 &b)
-    {
-        m64 res = _mm_adds_pu16(_mm_mullo_pi16(x, a), _mm_mullo_pi16(y, b));
-        return _mm_srli_pi16(res, 8);
-    }
-
-    static inline m64 _interpolate_pixel_255(const m64 &x, const m64 &a,
-                                             const m64 &y, const m64 &b,
-                                             const m64 &mmx_0x0080)
-    {
-        m64 res = _mm_adds_pu16(_mm_mullo_pi16(x, a), _mm_mullo_pi16(y, b));
-        res = _mm_adds_pu16(res, mmx_0x0080);
-        res = _mm_adds_pu16(res, _mm_srli_pi16 (res, 8));
-        return _mm_srli_pi16(res, 8);
-    }
-
-    static inline m64 _premul(m64 x, const m64 &mmx_0x0080) {
-        m64 a = alpha(x);
-        return _byte_mul(x, a, mmx_0x0080);
-    }
-
-    static inline m64 _load(uint x, const m64 &mmx_0x0000) {
-        return _mm_unpacklo_pi8(_mm_cvtsi32_si64(x), mmx_0x0000);
-    }
-
-    static inline m64 _load_alpha(uint x, const m64 &) {
-        x |= (x << 16);
-        return _mm_set1_pi32(x);
-    }
-
-    static inline uint _store(const m64 &x, const m64 &mmx_0x0000) {
-        return _mm_cvtsi64_si32(_mm_packs_pu16(x, mmx_0x0000));
-    }
-};
-
-#define negate(x) _negate(x, mmx_0x00ff)
-#define byte_mul(a, b) _byte_mul(a, b, mmx_0x0080)
-#define interpolate_pixel_255(x, a, y, b) _interpolate_pixel_255(x, a, y, b, mmx_0x0080)
-#define premul(x) _premul(x, mmx_0x0080)
-#define load(x) _load(x, mmx_0x0000)
-#define load_alpha(x) _load_alpha(x, mmx_0x0000)
-#define store(x) _store(x, mmx_0x0000)
-
-/*
-  result = 0
-  d = d * cia
-*/
-#define comp_func_Clear_impl(dest, length, const_alpha)\
-{\
-    if (const_alpha == 255) {\
-        qt_memfill(static_cast<quint32*>(dest), quint32(0), length);\
-    } else {\
-        C_FF; C_80; C_00;\
-        m64 ia = MM::negate(MM::load_alpha(const_alpha));\
-        for (int i = 0; i < length; ++i) {\
-            dest[i] = MM::store(MM::byte_mul(MM::load(dest[i]), ia));\
-        }\
-        MM::end();\
-    }\
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_solid_Clear(uint *dest, int length, uint, uint const_alpha)
-{
-    comp_func_Clear_impl(dest, length, const_alpha);
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_Clear(uint *dest, const uint *, int length, uint const_alpha)
-{
-    comp_func_Clear_impl(dest, length, const_alpha);
-}
-
-/*
-  result = s
-  dest = s * ca + d * cia
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_Source(uint *dest, int length, uint src, uint const_alpha)
-{
-    if (const_alpha == 255) {
-        qt_memfill(static_cast<quint32*>(dest), quint32(src), length);
-    } else {
-        C_FF; C_80; C_00;
-        const m64 a = MM::load_alpha(const_alpha);
-        const m64 ia = MM::negate(a);
-        const m64 s = MM::byte_mul(MM::load(src), a);
-        for (int i = 0; i < length; ++i) {
-            dest[i] = MM::store(MM::add(s, MM::byte_mul(MM::load(dest[i]), ia)));
-        }
-        MM::end();
-    }
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_Source(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    if (const_alpha == 255) {
-        ::memcpy(dest, src, length * sizeof(uint));
-    } else {
-        C_FF; C_80; C_00;
-        const m64 a = MM::load_alpha(const_alpha);
-        const m64 ia = MM::negate(a);
-        for (int i = 0; i < length; ++i)
-            dest[i] = MM::store(MM::interpolate_pixel_255(MM::load(src[i]), a,
-                                                        MM::load(dest[i]), ia));
-    }
-    MM::end();
-}
-
-/*
-  result = s + d * sia
-  dest = (s + d * sia) * ca + d * cia
-       = s * ca + d * (sia * ca + cia)
-       = s * ca + d * (1 - sa*ca)
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_SourceOver(uint *dest, int length, uint src, uint const_alpha)
-{
-    if ((const_alpha & qAlpha(src)) == 255) {
-        qt_memfill(static_cast<quint32*>(dest), quint32(src), length);
-    } else {
-        C_FF; C_80; C_00;
-        m64 s = MM::load(src);
-        if (const_alpha != 255) {
-            m64 ca = MM::load_alpha(const_alpha);
-            s = MM::byte_mul(s, ca);
-        }
-        m64 a = MM::negate(MM::alpha(s));
-        for (int i = 0; i < length; ++i)
-            dest[i] = MM::store(MM::add(s, MM::byte_mul(MM::load(dest[i]), a)));
-        MM::end();
-    }
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_SourceOver(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            const uint alphaMaskedSource = 0xff000000 & src[i];
-            if (alphaMaskedSource == 0)
-                continue;
-            if (alphaMaskedSource == 0xff000000) {
-                dest[i] = src[i];
-            } else {
-                m64 s = MM::load(src[i]);
-                m64 ia = MM::negate(MM::alpha(s));
-                dest[i] = MM::store(MM::add(s, MM::byte_mul(MM::load(dest[i]), ia)));
-            }
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        for (int i = 0; i < length; ++i) {
-            if ((0xff000000 & src[i]) == 0)
-                continue;
-            m64 s = MM::byte_mul(MM::load(src[i]), ca);
-            m64 ia = MM::negate(MM::alpha(s));
-            dest[i] = MM::store(MM::add(s, MM::byte_mul(MM::load(dest[i]), ia)));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = d + s * dia
-  dest = (d + s * dia) * ca + d * cia
-       = d + s * dia * ca
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_DestinationOver(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    m64 s = MM::load(src);
-    if (const_alpha != 255)
-        s = MM::byte_mul(s, MM::load_alpha(const_alpha));
-
-    for (int i = 0; i < length; ++i) {
-        m64 d = MM::load(dest[i]);
-        m64 dia = MM::negate(MM::alpha(d));
-        dest[i] = MM::store(MM::add(d, MM::byte_mul(s, dia)));
-    }
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_DestinationOver(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            m64 ia = MM::negate(MM::alpha(d));
-            dest[i] = MM::store(MM::add(d, MM::byte_mul(MM::load(src[i]), ia)));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            m64 dia = MM::negate(MM::alpha(d));
-            dia = MM::byte_mul(dia, ca);
-            dest[i] = MM::store(MM::add(d, MM::byte_mul(MM::load(src[i]), dia)));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = s * da
-  dest = s * da * ca + d * cia
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_SourceIn(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_80; C_00;
-    if (const_alpha == 255) {
-        m64 s = MM::load(src);
-        for (int i = 0; i < length; ++i) {
-            m64 da = MM::alpha(MM::load(dest[i]));
-            dest[i] = MM::store(MM::byte_mul(s, da));
-        }
-    } else {
-        C_FF;
-        m64 s = MM::load(src);
-        m64 ca = MM::load_alpha(const_alpha);
-        s = MM::byte_mul(s, ca);
-        m64 cia = MM::negate(ca);
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::alpha(d), d, cia));
-        }
-    }
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_SourceIn(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 a = MM::alpha(MM::load(dest[i]));
-            dest[i] = MM::store(MM::byte_mul(MM::load(src[i]), a));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        m64 cia = MM::negate(ca);
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            m64 da = MM::byte_mul(MM::alpha(d), ca);
-            dest[i] = MM::store(MM::interpolate_pixel_255(
-                                   MM::load(src[i]), da, d, cia));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = d * sa
-  dest = d * sa * ca + d * cia
-       = d * (sa * ca + cia)
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_DestinationIn(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_80; C_00;
-    m64 a = MM::alpha(MM::load(src));
-    if (const_alpha != 255) {
-        C_FF;
-        m64 ca = MM::load_alpha(const_alpha);
-        m64 cia = MM::negate(ca);
-        a = MM::byte_mul(a, ca);
-        a = MM::add(a, cia);
-    }
-    for (int i = 0; i < length; ++i)
-        dest[i] = MM::store(MM::byte_mul(MM::load(dest[i]), a));
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_DestinationIn(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 a = MM::alpha(MM::load(src[i]));
-            dest[i] = MM::store(MM::byte_mul(MM::load(dest[i]), a));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        m64 cia = MM::negate(ca);
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            m64 a = MM::alpha(MM::load(src[i]));
-            a = MM::byte_mul(a, ca);
-            a = MM::add(a, cia);
-            dest[i] = MM::store(MM::byte_mul(d, a));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = s * dia
-  dest = s * dia * ca + d * cia
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_SourceOut(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    m64 s = MM::load(src);
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 dia = MM::negate(MM::alpha(MM::load(dest[i])));
-            dest[i] = MM::store(MM::byte_mul(s, dia));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        m64 cia = MM::negate(ca);
-        s = MM::byte_mul(s, ca);
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::negate(MM::alpha(d)), d, cia));
-        }
-    }
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_SourceOut(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 ia = MM::negate(MM::alpha(MM::load(dest[i])));
-            dest[i] = MM::store(MM::byte_mul(MM::load(src[i]), ia));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        m64 cia = MM::negate(ca);
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            m64 dia = MM::byte_mul(MM::negate(MM::alpha(d)), ca);
-            dest[i] = MM::store(MM::interpolate_pixel_255(MM::load(src[i]), dia, d, cia));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = d * sia
-  dest = d * sia * ca + d * cia
-       = d * (sia * ca + cia)
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_DestinationOut(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    m64 a = MM::negate(MM::alpha(MM::load(src)));
-    if (const_alpha != 255) {
-        m64 ca = MM::load_alpha(const_alpha);
-        a = MM::byte_mul(a, ca);
-        a = MM::add(a, MM::negate(ca));
-    }
-    for (int i = 0; i < length; ++i)
-        dest[i] = MM::store(MM::byte_mul(MM::load(dest[i]), a));
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_DestinationOut(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 a = MM::negate(MM::alpha(MM::load(src[i])));
-            dest[i] = MM::store(MM::byte_mul(MM::load(dest[i]), a));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        m64 cia = MM::negate(ca);
-        for (int i = 0; i < length; ++i) {
-            m64 d = MM::load(dest[i]);
-            m64 a = MM::negate(MM::alpha(MM::load(src[i])));
-            a = MM::byte_mul(a, ca);
-            a = MM::add(a, cia);
-            dest[i] = MM::store(MM::byte_mul(d, a));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = s*da + d*sia
-  dest = s*da*ca + d*sia*ca + d *cia
-       = s*ca * da + d * (sia*ca + cia)
-       = s*ca * da + d * (1 - sa*ca)
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_SourceAtop(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    m64 s = MM::load(src);
-    if (const_alpha != 255) {
-        m64 ca = MM::load_alpha(const_alpha);
-        s = MM::byte_mul(s, ca);
-    }
-    m64 a = MM::negate(MM::alpha(s));
-    for (int i = 0; i < length; ++i) {
-        m64 d = MM::load(dest[i]);
-        dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::alpha(d), d, a));
-    }
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_SourceAtop(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 s = MM::load(src[i]);
-            m64 d = MM::load(dest[i]);
-            dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::alpha(d), d,
-                                                        MM::negate(MM::alpha(s))));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        for (int i = 0; i < length; ++i) {
-            m64 s = MM::load(src[i]);
-            s = MM::byte_mul(s, ca);
-            m64 d = MM::load(dest[i]);
-            dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::alpha(d), d,
-                                                        MM::negate(MM::alpha(s))));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = d*sa + s*dia
-  dest = d*sa*ca + s*dia*ca + d *cia
-       = s*ca * dia + d * (sa*ca + cia)
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_DestinationAtop(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    m64 s = MM::load(src);
-    m64 a = MM::alpha(s);
-    if (const_alpha != 255) {
-        m64 ca = MM::load_alpha(const_alpha);
-        s = MM::byte_mul(s, ca);
-        a = MM::alpha(s);
-        a = MM::add(a, MM::negate(ca));
-    }
-    for (int i = 0; i < length; ++i) {
-        m64 d = MM::load(dest[i]);
-        dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::negate(MM::alpha(d)), d, a));
-    }
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_DestinationAtop(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 s = MM::load(src[i]);
-            m64 d = MM::load(dest[i]);
-            dest[i] = MM::store(MM::interpolate_pixel_255(d, MM::alpha(s), s,
-                                                        MM::negate(MM::alpha(d))));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        for (int i = 0; i < length; ++i) {
-            m64 s = MM::load(src[i]);
-            s = MM::byte_mul(s, ca);
-            m64 d = MM::load(dest[i]);
-            m64 a = MM::alpha(s);
-            a = MM::add(a, MM::negate(ca));
-            dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::negate(MM::alpha(d)),
-                                                        d, a));
-        }
-    }
-    MM::end();
-}
-
-/*
-  result = d*sia + s*dia
-  dest = d*sia*ca + s*dia*ca + d *cia
-       = s*ca * dia + d * (sia*ca + cia)
-       = s*ca * dia + d * (1 - sa*ca)
-*/
-template <class MM>
-static void QT_FASTCALL comp_func_solid_XOR(uint *dest, int length, uint src, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    m64 s = MM::load(src);
-    if (const_alpha != 255) {
-        m64 ca = MM::load_alpha(const_alpha);
-        s = MM::byte_mul(s, ca);
-    }
-    m64 a = MM::negate(MM::alpha(s));
-    for (int i = 0; i < length; ++i) {
-        m64 d = MM::load(dest[i]);
-        dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::negate(MM::alpha(d)),
-                                                    d, a));
-    }
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL comp_func_XOR(uint *dest, const uint *src, int length, uint const_alpha)
-{
-    C_FF; C_80; C_00;
-    if (const_alpha == 255) {
-        for (int i = 0; i < length; ++i) {
-            m64 s = MM::load(src[i]);
-            m64 d = MM::load(dest[i]);
-            dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::negate(MM::alpha(d)),
-                                                        d, MM::negate(MM::alpha(s))));
-        }
-    } else {
-        m64 ca = MM::load_alpha(const_alpha);
-        for (int i = 0; i < length; ++i) {
-            m64 s = MM::load(src[i]);
-            s = MM::byte_mul(s, ca);
-            m64 d = MM::load(dest[i]);
-            dest[i] = MM::store(MM::interpolate_pixel_255(s, MM::negate(MM::alpha(d)),
-                                                        d, MM::negate(MM::alpha(s))));
-        }
-    }
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_SourceOrDestination(uint *dest,
-                                                           int length,
-                                                           uint color,
-                                                           uint const_alpha)
-{
-    Q_UNUSED(const_alpha);
-
-    if ((quintptr)(dest) & 0x7) {
-        *dest++ |= color;
-        --length;
-    }
-
-    const int length64 = length / 2;
-    if (length64) {
-        __m64 *dst64 = reinterpret_cast<__m64*>(dest);
-        const __m64 color64 = _mm_set_pi32(color, color);
-
-        int n = (length64 + 3) / 4;
-        switch (length64 & 0x3) {
-        case 0: do { *dst64 = _mm_or_si64(*dst64, color64); ++dst64;
-        case 3:      *dst64 = _mm_or_si64(*dst64, color64); ++dst64;
-        case 2:      *dst64 = _mm_or_si64(*dst64, color64); ++dst64;
-        case 1:      *dst64 = _mm_or_si64(*dst64, color64); ++dst64;
-        } while (--n > 0);
-        }
-    }
-
-    if (length & 0x1) {
-        dest[length - 1] |= color;
-    }
-
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_SourceAndDestination(uint *dest,
-                                                            int length,
-                                                            uint color,
-                                                            uint const_alpha)
-{
-    Q_UNUSED(const_alpha);
-
-    color |= 0xff000000;
-
-    if ((quintptr)(dest) & 0x7) { // align
-        *dest++ &= color;
-        --length;
-    }
-
-    const int length64 = length / 2;
-    if (length64) {
-        __m64 *dst64 = reinterpret_cast<__m64*>(dest);
-        const __m64 color64 = _mm_set_pi32(color, color);
-
-        int n = (length64 + 3) / 4;
-        switch (length64 & 0x3) {
-        case 0: do { *dst64 = _mm_and_si64(*dst64, color64); ++dst64;
-        case 3:      *dst64 = _mm_and_si64(*dst64, color64); ++dst64;
-        case 2:      *dst64 = _mm_and_si64(*dst64, color64); ++dst64;
-        case 1:      *dst64 = _mm_and_si64(*dst64, color64); ++dst64;
-        } while (--n > 0);
-        }
-    }
-
-    if (length & 0x1) {
-        dest[length - 1] &= color;
-    }
-
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_SourceXorDestination(uint *dest,
-                                                            int length,
-                                                            uint color,
-                                                            uint const_alpha)
-{
-    Q_UNUSED(const_alpha);
-
-    color &= 0x00ffffff;
-
-    if ((quintptr)(dest) & 0x7) {
-        *dest++ ^= color;
-        --length;
-    }
-
-    const int length64 = length / 2;
-    if (length64) {
-        __m64 *dst64 = reinterpret_cast<__m64*>(dest);
-        const __m64 color64 = _mm_set_pi32(color, color);
-
-        int n = (length64 + 3) / 4;
-        switch (length64 & 0x3) {
-        case 0: do { *dst64 = _mm_xor_si64(*dst64, color64); ++dst64;
-        case 3:      *dst64 = _mm_xor_si64(*dst64, color64); ++dst64;
-        case 2:      *dst64 = _mm_xor_si64(*dst64, color64); ++dst64;
-        case 1:      *dst64 = _mm_xor_si64(*dst64, color64); ++dst64;
-        } while (--n > 0);
-        }
-    }
-
-    if (length & 0x1) {
-        dest[length - 1] ^= color;
-    }
-
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_SourceAndNotDestination(uint *dest,
-                                                               int length,
-                                                               uint color,
-                                                               uint const_alpha)
-{
-
-    Q_UNUSED(const_alpha);
-
-    if ((quintptr)(dest) & 0x7) {
-        *dest = (color & ~(*dest)) | 0xff000000;
-        ++dest;
-        --length;
-    }
-
-    const int length64 = length / 2;
-    if (length64) {
-        __m64 *dst64 = reinterpret_cast<__m64*>(dest);
-        const __m64 color64 = _mm_set_pi32(color, color);
-        const m64 mmx_0xff000000 = _mm_set1_pi32(0xff000000);
-        __m64 tmp1, tmp2, tmp3, tmp4;
-
-        int n = (length64 + 3) / 4;
-        switch (length64 & 0x3) {
-        case 0: do { tmp1 = _mm_andnot_si64(*dst64, color64);
-                     *dst64++ = _mm_or_si64(tmp1, mmx_0xff000000);
-        case 3:      tmp2 = _mm_andnot_si64(*dst64, color64);
-                     *dst64++ = _mm_or_si64(tmp2, mmx_0xff000000);
-        case 2:      tmp3 = _mm_andnot_si64(*dst64, color64);
-                     *dst64++ = _mm_or_si64(tmp3, mmx_0xff000000);
-        case 1:      tmp4 = _mm_andnot_si64(*dst64, color64);
-                     *dst64++ = _mm_or_si64(tmp4, mmx_0xff000000);
-        } while (--n > 0);
-        }
-    }
-
-    if (length & 0x1) {
-        dest[length - 1] = (color & ~(dest[length - 1])) | 0xff000000;
-    }
-
-    MM::end();
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_NotSourceAndNotDestination(uint *dest,
-                                                                  int length,
-                                                                  uint color,
-                                                                  uint const_alpha)
-{
-    rasterop_solid_SourceAndNotDestination<MM>(dest, length,
-                                               ~color, const_alpha);
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_NotSourceOrNotDestination(uint *dest,
-                                                                 int length,
-                                                                 uint color,
-                                                                 uint const_alpha)
-{
-    Q_UNUSED(const_alpha);
-    color = ~color | 0xff000000;
-    while (length--) {
-        *dest = color | ~(*dest);
-        ++dest;
-    }
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_NotSourceXorDestination(uint *dest,
-                                                               int length,
-                                                               uint color,
-                                                               uint const_alpha)
-{
-    rasterop_solid_SourceXorDestination<MM>(dest, length, ~color, const_alpha);
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_NotSource(uint *dest, int length,
-                                                 uint color, uint const_alpha)
-{
-    Q_UNUSED(const_alpha);
-    qt_memfill((quint32*)dest, ~color | 0xff000000, length);
-}
-
-template <class MM>
-static void QT_FASTCALL rasterop_solid_NotSourceAndDestination(uint *dest,
-                                                               int length,
-                                                               uint color,
-                                                               uint const_alpha)
-{
-    rasterop_solid_SourceAndDestination<MM>(dest, length,
-                                            ~color, const_alpha);
-}
-
-template <class MM>
-static inline void qt_blend_color_argb_x86(int count, const QSpan *spans,
-                                           void *userData,
-                                           CompositionFunctionSolid *solidFunc)
-{
-    QSpanData *data = reinterpret_cast<QSpanData *>(userData);
-    if (data->rasterBuffer->compositionMode == QPainter::CompositionMode_Source
-        || (data->rasterBuffer->compositionMode == QPainter::CompositionMode_SourceOver
-            && qAlpha(data->solid.color) == 255)) {
-        // inline for performance
-        C_FF; C_80; C_00;
-        while (count--) {
-            uint *target = ((uint *)data->rasterBuffer->scanLine(spans->y)) + spans->x;
-            if (spans->coverage == 255) {
-                qt_memfill(static_cast<quint32*>(target), quint32(data->solid.color), spans->len);
-            } else {
-                // dest = s * ca + d * (1 - sa*ca) --> dest = s * ca + d * (1-ca)
-                m64 ca = MM::load_alpha(spans->coverage);
-                m64 s = MM::byte_mul(MM::load(data->solid.color), ca);
-                m64 ica = MM::negate(ca);
-                for (int i = 0; i < spans->len; ++i)
-                    target[i] = MM::store(MM::add(s, MM::byte_mul(MM::load(target[i]), ica)));
-            }
-            ++spans;
-        }
-        MM::end();
-        return;
-    }
-    CompositionFunctionSolid func = solidFunc[data->rasterBuffer->compositionMode];
-    while (count--) {
-        uint *target = ((uint *)data->rasterBuffer->scanLine(spans->y)) + spans->x;
-        func(target, spans->len, data->solid.color, spans->coverage);
-        ++spans;
-    }
-}
-
-#ifdef QT_HAVE_MMX
-struct QMMXIntrinsics : public QMMXCommonIntrinsics
-{
-    static inline void end() {
-#if !defined(Q_OS_WINCE) || defined(_X86_)
-       _mm_empty();
-#endif
-    }
-};
-#endif // QT_HAVE_MMX
-
-QT_END_NAMESPACE
-
-#endif // QDRAWHELPER_MMX_P_H
diff --git a/src/gui/painting/qdrawhelper_sse.cpp b/src/gui/painting/qdrawhelper_sse.cpp
deleted file mode 100644
index dd83098..0000000
--- a/src/gui/painting/qdrawhelper_sse.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <private/qdrawhelper_p.h>
-
-#ifdef QT_HAVE_SSE
-
-#include <private/qdrawhelper_sse_p.h>
-
-QT_BEGIN_NAMESPACE
-
-CompositionFunctionSolid qt_functionForModeSolid_SSE[numCompositionFunctions] = {
-    comp_func_solid_SourceOver<QSSEIntrinsics>,
-    comp_func_solid_DestinationOver<QSSEIntrinsics>,
-    comp_func_solid_Clear<QSSEIntrinsics>,
-    comp_func_solid_Source<QSSEIntrinsics>,
-    0,
-    comp_func_solid_SourceIn<QSSEIntrinsics>,
-    comp_func_solid_DestinationIn<QSSEIntrinsics>,
-    comp_func_solid_SourceOut<QSSEIntrinsics>,
-    comp_func_solid_DestinationOut<QSSEIntrinsics>,
-    comp_func_solid_SourceAtop<QSSEIntrinsics>,
-    comp_func_solid_DestinationAtop<QSSEIntrinsics>,
-    comp_func_solid_XOR<QSSEIntrinsics>,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // svg 1.2 modes
-    rasterop_solid_SourceOrDestination<QMMXIntrinsics>,
-    rasterop_solid_SourceAndDestination<QMMXIntrinsics>,
-    rasterop_solid_SourceXorDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSourceAndNotDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSourceOrNotDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSourceXorDestination<QMMXIntrinsics>,
-    rasterop_solid_NotSource<QMMXIntrinsics>,
-    rasterop_solid_NotSourceAndDestination<QMMXIntrinsics>,
-    rasterop_solid_SourceAndNotDestination<QMMXIntrinsics>
-};
-
-CompositionFunction qt_functionForMode_SSE[numCompositionFunctions] = {
-    comp_func_SourceOver<QSSEIntrinsics>,
-    comp_func_DestinationOver<QSSEIntrinsics>,
-    comp_func_Clear<QSSEIntrinsics>,
-    comp_func_Source<QSSEIntrinsics>,
-    comp_func_Destination,
-    comp_func_SourceIn<QSSEIntrinsics>,
-    comp_func_DestinationIn<QSSEIntrinsics>,
-    comp_func_SourceOut<QSSEIntrinsics>,
-    comp_func_DestinationOut<QSSEIntrinsics>,
-    comp_func_SourceAtop<QSSEIntrinsics>,
-    comp_func_DestinationAtop<QSSEIntrinsics>,
-    comp_func_XOR<QSSEIntrinsics>,
-    comp_func_Plus,
-    comp_func_Multiply,
-    comp_func_Screen,
-    comp_func_Overlay,
-    comp_func_Darken,
-    comp_func_Lighten,
-    comp_func_ColorDodge,
-    comp_func_ColorBurn,
-    comp_func_HardLight,
-    comp_func_SoftLight,
-    comp_func_Difference,
-    comp_func_Exclusion,
-    rasterop_SourceOrDestination,
-    rasterop_SourceAndDestination,
-    rasterop_SourceXorDestination,
-    rasterop_NotSourceAndNotDestination,
-    rasterop_NotSourceOrNotDestination,
-    rasterop_NotSourceXorDestination,
-    rasterop_NotSource,
-    rasterop_NotSourceAndDestination,
-    rasterop_SourceAndNotDestination
-};
-
-void qt_blend_color_argb_sse(int count, const QSpan *spans, void *userData)
-{
-    qt_blend_color_argb_x86<QSSEIntrinsics>(count, spans, userData,
-                                            (CompositionFunctionSolid*)qt_functionForModeSolid_SSE);
-}
-
-void qt_memfill32_sse(quint32 *dest, quint32 value, int count)
-{
-    return qt_memfill32_sse_template<QSSEIntrinsics>(dest, value, count);
-}
-
-void qt_bitmapblit16_sse(QRasterBuffer *rasterBuffer, int x, int y,
-                         quint32 color,
-                         const uchar *src,
-                         int width, int height, int stride)
-{
-    return qt_bitmapblit16_sse_template<QSSEIntrinsics>(rasterBuffer, x,y,
-                                                        color, src, width,
-                                                        height, stride);
-}
-
-void qt_blend_argb32_on_argb32_sse(uchar *destPixels, int dbpl,
-                                   const uchar *srcPixels, int sbpl,
-                                   int w, int h,
-                                   int const_alpha)
-{
-    const uint *src = (const uint *) srcPixels;
-    uint *dst = (uint *) destPixels;
-
-    uint ca = const_alpha - 1;
-
-    for (int y=0; y<h; ++y) {
-        comp_func_SourceOver<QSSEIntrinsics>(dst, src, w, ca);
-        dst = (quint32 *)(((uchar *) dst) + dbpl);
-        src = (const quint32 *)(((const uchar *) src) + sbpl);
-    }
-}
-
-void qt_blend_rgb32_on_rgb32_sse(uchar *destPixels, int dbpl,
-                                 const uchar *srcPixels, int sbpl,
-                                 int w, int h,
-                                 int const_alpha)
-{
-    const uint *src = (const uint *) srcPixels;
-    uint *dst = (uint *) destPixels;
-
-    uint ca = const_alpha - 1;
-
-    for (int y=0; y<h; ++y) {
-        comp_func_Source<QSSEIntrinsics>(dst, src, w, ca);
-        dst = (quint32 *)(((uchar *) dst) + dbpl);
-        src = (const quint32 *)(((const uchar *) src) + sbpl);
-    }
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_HAVE_SSE
diff --git a/src/gui/painting/qdrawhelper_sse2.cpp b/src/gui/painting/qdrawhelper_sse2.cpp
index 7b57d5c..2c87aab 100644
--- a/src/gui/painting/qdrawhelper_sse2.cpp
+++ b/src/gui/painting/qdrawhelper_sse2.cpp
@@ -310,7 +310,7 @@ void QT_FASTCALL comp_func_solid_SourceOver_sse2(uint *destPixels, int length, u
     }
 }
 
-CompositionFunctionSolid qt_functionForModeSolid_onlySSE2[numCompositionFunctions] = {
+CompositionFunctionSolid qt_functionForModeSolid_SSE2[numCompositionFunctions] = {
     comp_func_solid_SourceOver_sse2,
     comp_func_solid_DestinationOver,
     comp_func_solid_Clear,
@@ -346,7 +346,7 @@ CompositionFunctionSolid qt_functionForModeSolid_onlySSE2[numCompositionFunction
     rasterop_solid_SourceAndNotDestination
 };
 
-CompositionFunction qt_functionForMode_onlySSE2[numCompositionFunctions] = {
+CompositionFunction qt_functionForMode_SSE2[numCompositionFunctions] = {
     comp_func_SourceOver_sse2,
     comp_func_DestinationOver,
     comp_func_Clear,
diff --git a/src/gui/painting/qdrawhelper_sse3dnow.cpp b/src/gui/painting/qdrawhelper_sse3dnow.cpp
deleted file mode 100644
index 1cca6b6..0000000
--- a/src/gui/painting/qdrawhelper_sse3dnow.cpp
+++ /dev/null
@@ -1,143 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <private/qdrawhelper_x86_p.h>
-
-#if defined(QT_HAVE_3DNOW) && defined(QT_HAVE_SSE)
-
-#include <private/qdrawhelper_sse_p.h>
-#include <mm3dnow.h>
-
-QT_BEGIN_NAMESPACE
-
-struct QSSE3DNOWIntrinsics : public QSSEIntrinsics
-{
-    static inline void end() {
-        _m_femms();
-    }
-};
-
-CompositionFunctionSolid qt_functionForModeSolid_SSE3DNOW[numCompositionFunctions] = {
-    comp_func_solid_SourceOver<QSSE3DNOWIntrinsics>,
-    comp_func_solid_DestinationOver<QSSE3DNOWIntrinsics>,
-    comp_func_solid_Clear<QSSE3DNOWIntrinsics>,
-    comp_func_solid_Source<QSSE3DNOWIntrinsics>,
-    0,
-    comp_func_solid_SourceIn<QSSE3DNOWIntrinsics>,
-    comp_func_solid_DestinationIn<QSSE3DNOWIntrinsics>,
-    comp_func_solid_SourceOut<QSSE3DNOWIntrinsics>,
-    comp_func_solid_DestinationOut<QSSE3DNOWIntrinsics>,
-    comp_func_solid_SourceAtop<QSSE3DNOWIntrinsics>,
-    comp_func_solid_DestinationAtop<QSSE3DNOWIntrinsics>,
-    comp_func_solid_XOR<QSSE3DNOWIntrinsics>,
-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // svg 1.2 modes
-    rasterop_solid_SourceOrDestination<QSSE3DNOWIntrinsics>,
-    rasterop_solid_SourceAndDestination<QSSE3DNOWIntrinsics>,
-    rasterop_solid_SourceXorDestination<QSSE3DNOWIntrinsics>,
-    rasterop_solid_NotSourceAndNotDestination<QSSE3DNOWIntrinsics>,
-    rasterop_solid_NotSourceOrNotDestination<QSSE3DNOWIntrinsics>,
-    rasterop_solid_NotSourceXorDestination<QSSE3DNOWIntrinsics>,
-    rasterop_solid_NotSource<QSSE3DNOWIntrinsics>,
-    rasterop_solid_NotSourceAndDestination<QSSE3DNOWIntrinsics>,
-    rasterop_solid_SourceAndNotDestination<QSSE3DNOWIntrinsics>
-};
-
-CompositionFunction qt_functionForMode_SSE3DNOW[numCompositionFunctions] = {
-    comp_func_SourceOver<QSSE3DNOWIntrinsics>,
-    comp_func_DestinationOver<QSSE3DNOWIntrinsics>,
-    comp_func_Clear<QSSE3DNOWIntrinsics>,
-    comp_func_Source<QSSE3DNOWIntrinsics>,
-    comp_func_Destination,
-    comp_func_SourceIn<QSSE3DNOWIntrinsics>,
-    comp_func_DestinationIn<QSSE3DNOWIntrinsics>,
-    comp_func_SourceOut<QSSE3DNOWIntrinsics>,
-    comp_func_DestinationOut<QSSE3DNOWIntrinsics>,
-    comp_func_SourceAtop<QSSE3DNOWIntrinsics>,
-    comp_func_DestinationAtop<QSSE3DNOWIntrinsics>,
-    comp_func_XOR<QSSE3DNOWIntrinsics>,
-    comp_func_Plus,
-    comp_func_Multiply,
-    comp_func_Screen,
-    comp_func_Overlay,
-    comp_func_Darken,
-    comp_func_Lighten,
-    comp_func_ColorDodge,
-    comp_func_ColorBurn,
-    comp_func_HardLight,
-    comp_func_SoftLight,
-    comp_func_Difference,
-    comp_func_Exclusion,
-    rasterop_SourceOrDestination,
-    rasterop_SourceAndDestination,
-    rasterop_SourceXorDestination,
-    rasterop_NotSourceAndNotDestination,
-    rasterop_NotSourceOrNotDestination,
-    rasterop_NotSourceXorDestination,
-    rasterop_NotSource,
-    rasterop_NotSourceAndDestination,
-    rasterop_SourceAndNotDestination
-};
-
-void qt_blend_color_argb_sse3dnow(int count, const QSpan *spans, void *userData)
-{
-    qt_blend_color_argb_x86<QSSE3DNOWIntrinsics>(count, spans, userData,
-                                                 (CompositionFunctionSolid*)qt_functionForModeSolid_SSE3DNOW);
-}
-
-void qt_memfill32_sse3dnow(quint32 *dest, quint32 value, int count)
-{
-    return qt_memfill32_sse_template<QSSE3DNOWIntrinsics>(dest, value, count);
-}
-
-
-void qt_bitmapblit16_sse3dnow(QRasterBuffer *rasterBuffer, int x, int y,
-                              quint32 color,
-                              const uchar *src,
-                              int width, int height, int stride)
-{
-    return qt_bitmapblit16_sse_template<QSSE3DNOWIntrinsics>(rasterBuffer, x,y,
-                                                             color, src, width,
-                                                             height, stride);
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_HAVE_3DNOW && QT_HAVE_SSE
diff --git a/src/gui/painting/qdrawhelper_x86_p.h b/src/gui/painting/qdrawhelper_x86_p.h
index ada0bec..93abaf4 100644
--- a/src/gui/painting/qdrawhelper_x86_p.h
+++ b/src/gui/painting/qdrawhelper_x86_p.h
@@ -57,54 +57,6 @@
 
 QT_BEGIN_NAMESPACE
 
-#ifdef QT_HAVE_MMX
-extern CompositionFunction qt_functionForMode_MMX[];
-extern CompositionFunctionSolid qt_functionForModeSolid_MMX[];
-void qt_blend_color_argb_mmx(int count, const QSpan *spans, void *userData);
-#endif
-
-#ifdef QT_HAVE_MMXEXT
-void qt_memfill32_mmxext(quint32 *dest, quint32 value, int count);
-void qt_bitmapblit16_mmxext(QRasterBuffer *rasterBuffer, int x, int y,
-                            quint32 color, const uchar *src,
-                            int width, int height, int stride);
-#endif
-
-#ifdef QT_HAVE_3DNOW
-#if defined(QT_HAVE_MMX) || !defined(QT_HAVE_SSE)
-extern CompositionFunction qt_functionForMode_MMX3DNOW[];
-extern CompositionFunctionSolid qt_functionForModeSolid_MMX3DNOW[];
-
-void qt_blend_color_argb_mmx3dnow(int count, const QSpan *spans,
-                                  void *userData);
-#endif // MMX
-
-#ifdef QT_HAVE_SSE
-extern CompositionFunction qt_functionForMode_SSE3DNOW[];
-extern CompositionFunctionSolid qt_functionForModeSolid_SSE3DNOW[];
-
-void qt_memfill32_sse3dnow(quint32 *dest, quint32 value, int count);
-void qt_bitmapblit16_sse3dnow(QRasterBuffer *rasterBuffer, int x, int y,
-                              quint32 color,
-                              const uchar *src, int width, int height,
-                              int stride);
-void qt_blend_color_argb_sse3dnow(int count, const QSpan *spans,
-                                  void *userData);
-#endif // SSE
-#endif // QT_HAVE_3DNOW
-
-#ifdef QT_HAVE_SSE
-void qt_memfill32_sse(quint32 *dest, quint32 value, int count);
-void qt_bitmapblit16_sse(QRasterBuffer *rasterBuffer, int x, int y,
-                         quint32 color,
-                         const uchar *src, int width, int height, int stride);
-
-void qt_blend_color_argb_sse(int count, const QSpan *spans, void *userData);
-
-extern CompositionFunction qt_functionForMode_SSE[];
-extern CompositionFunctionSolid qt_functionForModeSolid_SSE[];
-#endif // QT_HAVE_SSE
-
 #ifdef QT_HAVE_SSE2
 void qt_memfill32_sse2(quint32 *dest, quint32 value, int count);
 void qt_memfill16_sse2(quint16 *dest, quint16 value, int count);
@@ -123,8 +75,8 @@ void qt_blend_rgb32_on_rgb32_sse2(uchar *destPixels, int dbpl,
                                  int w, int h,
                                  int const_alpha);
 
-extern CompositionFunction qt_functionForMode_onlySSE2[];
-extern CompositionFunctionSolid qt_functionForModeSolid_onlySSE2[];
+extern CompositionFunction qt_functionForMode_SSE2[];
+extern CompositionFunctionSolid qt_functionForModeSolid_SSE2[];
 #endif // QT_HAVE_SSE2
 
 #ifdef QT_HAVE_IWMMXT