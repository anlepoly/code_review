diff --git a/examples/widgets/doc/src/application.qdoc b/examples/widgets/doc/src/application.qdoc
index 4d79509..ef6dabc 100644
--- a/examples/widgets/doc/src/application.qdoc
+++ b/examples/widgets/doc/src/application.qdoc
@@ -231,16 +231,9 @@
 
     Just before we create the \uicontrol{Help} menu, we call
     QMenuBar::addSeparator(). This has no effect for most widget
-    styles (e.g., Windows and Mac OS X styles), but for Motif-based
+    styles (e.g., Windows and Mac OS X styles), but for some
     styles this makes sure that \uicontrol{Help} is pushed to the right
-    side of the menu bar. Try running the application with various
-    styles and see the results:
-
-    \code
-    application -style=windows
-    application -style=motif
-    application -style=cde
-    \endcode
+    side of the menu bar.
 
     Let's now review the toolbars:
 
diff --git a/examples/widgets/doc/src/icons.qdoc b/examples/widgets/doc/src/icons.qdoc
index 04ae310..d39f104 100644
--- a/examples/widgets/doc/src/icons.qdoc
+++ b/examples/widgets/doc/src/icons.qdoc
@@ -600,8 +600,8 @@
     In particular we create the \c styleActionGroup based on the
     currently available GUI styles using
     QStyleFactory. QStyleFactory::keys() returns a list of valid keys,
-    typically including "windows", "motif", "cde", and
-    "plastique". Depending on the platform, "windowsxp" and
+    typically including "windows", "cleanlooks" and
+    "plastique". Depending on the platform, "windowsxp", "windowsvista", "gtk" and
     "macintosh" may be available.
 
     We create one action for each key, and adds the action to the
diff --git a/examples/widgets/doc/src/styles.qdoc b/examples/widgets/doc/src/styles.qdoc
index 1297356..773c7a7 100644
--- a/examples/widgets/doc/src/styles.qdoc
+++ b/examples/widgets/doc/src/styles.qdoc
@@ -42,7 +42,7 @@
     reimplementing a few virtual functions.
 
     In this example, the custom style is called \c NorwegianWoodStyle
-    and derives from QMotifStyle. Its main features are the wooden
+    and derives from QWindowsStyle. Its main features are the wooden
     textures used for filling most of the widgets and its round
     buttons and comboboxes.
 
@@ -56,7 +56,7 @@
     The example consists of the following classes:
 
     \list
-    \li \c NorwegianWoodStyle inherits from QMotifStyle and implements
+    \li \c NorwegianWoodStyle inherits from QWindowsStyle and implements
         the Norwegian Wood style.
     \li \c WidgetGallery is a \c QDialog subclass that shows the most
        common widgets and allows the user to switch style
@@ -69,8 +69,8 @@
 
     \snippet widgets/styles/norwegianwoodstyle.h 0
 
-    The public functions are all declared in QStyle (QMotifStyle's
-    grandparent class) and reimplemented here to override the Motif
+    The public functions are all declared in QStyle (QWindowsStyle's
+    grandparent class) and reimplemented here to override the Windows
     look and feel. The private functions are helper functions.
 
     \section1 NorwegianWoodStyle Class Implementation
@@ -154,7 +154,7 @@
     \image styles-disabledwood.png The Norwegian Wood style with disabled widgets
 
     Let's move on to the other functions reimplemented from
-    QMotifStyle:
+    QWindowsStyle:
 
     \snippet widgets/styles/norwegianwoodstyle.cpp 3
     \snippet widgets/styles/norwegianwoodstyle.cpp 4
@@ -186,23 +186,23 @@
     widgets are drawn and their size hint. Here, we return 8 as the
     width around a shown in a QComboBox, ensuring that there is
     enough place around the text and the arrow for the Norwegian Wood
-    round corners. The default value for this setting in the Motif
+    round corners. The default value for this setting in the Windows
     style is 2.
 
     We also change the extent of \l{QScrollBar}s, i.e., the height
     for a horizontal scroll bar and the width for a vertical scroll
-    bar, to be 4 pixels more than in the Motif style. This makes the
+    bar, to be 4 pixels more than in the Windows style. This makes the
     style a bit more distinctive.
 
-    For all other QStyle::PixelMetric elements, we use the Motif
+    For all other QStyle::PixelMetric elements, we use the Windows
     settings.
 
     \snippet widgets/styles/norwegianwoodstyle.cpp 9
     \snippet widgets/styles/norwegianwoodstyle.cpp 10
 
     The \l{QStyle::styleHint()}{styleHint()} function returns some
-    hints to widgets or to the base style (in our case QMotifStyle)
-    about how to draw the widgets. The Motif style returns \c true
+    hints to widgets or to the base style (in our case QWindowsStyle)
+    about how to draw the widgets. The Windows style returns \c true
     for the QStyle::SH_DitherDisabledText hint, resulting in a most
     unpleasing visual effect. We override this behavior and return \c
     false instead. We also return \c true for the
diff --git a/examples/widgets/widgets/styles/norwegianwoodstyle.cpp b/examples/widgets/widgets/styles/norwegianwoodstyle.cpp
index 1437329..b8a677b 100644
--- a/examples/widgets/widgets/styles/norwegianwoodstyle.cpp
+++ b/examples/widgets/widgets/styles/norwegianwoodstyle.cpp
@@ -112,9 +112,9 @@ int NorwegianWoodStyle::pixelMetric(PixelMetric metric,
     case PM_ComboBoxFrameWidth:
         return 8;
     case PM_ScrollBarExtent:
-        return QMotifStyle::pixelMetric(metric, option, widget) + 4;
+        return QWindowsStyle::pixelMetric(metric, option, widget) + 4;
     default:
-        return QMotifStyle::pixelMetric(metric, option, widget);
+        return QWindowsStyle::pixelMetric(metric, option, widget);
     }
 }
 //! [8]
@@ -131,7 +131,7 @@ int NorwegianWoodStyle::styleHint(StyleHint hint, const QStyleOption *option,
     case SH_EtchDisabledText:
         return int(true);
     default:
-        return QMotifStyle::styleHint(hint, option, widget, returnData);
+        return QWindowsStyle::styleHint(hint, option, widget, returnData);
     }
 }
 //! [10]
@@ -256,7 +256,7 @@ void NorwegianWoodStyle::drawPrimitive(PrimitiveElement element,
 //! [32] //! [33]
     default:
 //! [33] //! [34]
-        QMotifStyle::drawPrimitive(element, option, painter, widget);
+        QWindowsStyle::drawPrimitive(element, option, painter, widget);
     }
 }
 //! [34]
@@ -284,11 +284,11 @@ void NorwegianWoodStyle::drawControl(ControlElement element,
                     }
                 }
             }
-            QMotifStyle::drawControl(element, &myButtonOption, painter, widget);
+            QWindowsStyle::drawControl(element, &myButtonOption, painter, widget);
         }
         break;
     default:
-        QMotifStyle::drawControl(element, option, painter, widget);
+        QWindowsStyle::drawControl(element, option, painter, widget);
     }
 }
 //! [36]
diff --git a/examples/widgets/widgets/styles/norwegianwoodstyle.h b/examples/widgets/widgets/styles/norwegianwoodstyle.h
index 1f1e38c..84ace3b 100644
--- a/examples/widgets/widgets/styles/norwegianwoodstyle.h
+++ b/examples/widgets/widgets/styles/norwegianwoodstyle.h
@@ -41,7 +41,7 @@
 #ifndef NORWEGIANWOODSTYLE_H
 #define NORWEGIANWOODSTYLE_H
 
-#include <QMotifStyle>
+#include <QWindowsStyle>
 #include <QPalette>
 
 QT_BEGIN_NAMESPACE
@@ -49,7 +49,7 @@ class QPainterPath;
 QT_END_NAMESPACE
 
 //! [0]
-class NorwegianWoodStyle : public QMotifStyle
+class NorwegianWoodStyle : public QWindowsStyle
 {
     Q_OBJECT
 
diff --git a/examples/widgets/widgets/styles/styles.pro b/examples/widgets/widgets/styles/styles.pro
index fef1dc6..0be4f1e 100644
--- a/examples/widgets/widgets/styles/styles.pro
+++ b/examples/widgets/widgets/styles/styles.pro
@@ -5,7 +5,7 @@ SOURCES       = main.cpp \
                 widgetgallery.cpp
 RESOURCES     = styles.qrc
 
-REQUIRES += "contains(styles, motif)"
+REQUIRES += "contains(styles, windows)"
 
 # install
 target.path = $$[QT_INSTALL_EXAMPLES]/qtbase/widgets/styles
diff --git a/examples/widgets/widgets/widgets.pro b/examples/widgets/widgets/widgets.pro
index 65289da..b14a587 100644
--- a/examples/widgets/widgets/widgets.pro
+++ b/examples/widgets/widgets/widgets.pro
@@ -26,7 +26,7 @@ SUBDIRS       = analogclock \
                 wiggly \
                 windowflags
 
-contains(styles, motif): SUBDIRS += styles
+contains(styles, windows): SUBDIRS += styles
 
 # install
 sources.files = widgets.pro README
diff --git a/src/corelib/global/qfeatures.h b/src/corelib/global/qfeatures.h
index f9e2f20..160063f 100644
--- a/src/corelib/global/qfeatures.h
+++ b/src/corelib/global/qfeatures.h
@@ -196,9 +196,6 @@
 // Status Tip
 //#define QT_NO_STATUSTIP
 
-// QMotifStyle
-//#define QT_NO_STYLE_MOTIF
-
 // QWindowsStyle
 //#define QT_NO_STYLE_WINDOWS
 
@@ -339,11 +336,6 @@
 #define QT_NO_STATEMACHINE
 #endif
 
-// QCDEStyle
-#if !defined(QT_NO_STYLE_CDE) && (defined(QT_NO_STYLE_MOTIF))
-#define QT_NO_STYLE_CDE
-#endif
-
 // QWindowsXPStyle
 #if !defined(QT_NO_STYLE_WINDOWSXP) && (defined(QT_NO_STYLE_WINDOWS))
 #define QT_NO_STYLE_WINDOWSXP
diff --git a/src/tools/uic/qclass_lib_map.h b/src/tools/uic/qclass_lib_map.h
index bbfa8f6..02cd04c 100644
--- a/src/tools/uic/qclass_lib_map.h
+++ b/src/tools/uic/qclass_lib_map.h
@@ -834,12 +834,10 @@ QT_CLASS_LIB(QTransform, QtGui, qtransform.h)
 QT_CLASS_LIB(QWMatrix, QtGui, qwmatrix.h)
 QT_CLASS_LIB(QKeyEventTransition, QtWidgets, qkeyeventtransition.h)
 QT_CLASS_LIB(QMouseEventTransition, QtWidgets, qmouseeventtransition.h)
-QT_CLASS_LIB(QCDEStyle, QtWidgets, qcdestyle.h)
 QT_CLASS_LIB(QCleanlooksStyle, QtWidgets, qcleanlooksstyle.h)
 QT_CLASS_LIB(QCommonStyle, QtWidgets, qcommonstyle.h)
 QT_CLASS_LIB(QGtkStyle, QtWidgets, qgtkstyle.h)
 QT_CLASS_LIB(QMacStyle, QtWidgets, qmacstyle_mac.h)
-QT_CLASS_LIB(QMotifStyle, QtWidgets, qmotifstyle.h)
 QT_CLASS_LIB(QPlastiqueStyle, QtWidgets, qplastiquestyle.h)
 QT_CLASS_LIB(QProxyStyle, QtWidgets, qproxystyle.h)
 QT_CLASS_LIB(QStyle, QtWidgets, qstyle.h)
diff --git a/src/widgets/doc/snippets/code/src_gui_styles_qstyle.cpp b/src/widgets/doc/snippets/code/src_gui_styles_qstyle.cpp
index e1c97c3..bba4ee3 100644
--- a/src/widgets/doc/snippets/code/src_gui_styles_qstyle.cpp
+++ b/src/widgets/doc/snippets/code/src_gui_styles_qstyle.cpp
@@ -39,7 +39,7 @@
 ****************************************************************************/
 
 //! [0]
-./myapplication -style motif
+./myapplication -style windows
 //! [0]
 
 
diff --git a/src/widgets/doc/src/widgets-and-layouts/gallery.qdoc b/src/widgets/doc/src/widgets-and-layouts/gallery.qdoc
index bf1285f..64bdd3a 100644
--- a/src/widgets/doc/src/widgets-and-layouts/gallery.qdoc
+++ b/src/widgets/doc/src/widgets-and-layouts/gallery.qdoc
@@ -72,13 +72,6 @@
   \caption \l{GTK Style Widget Gallery}
 
   The GTK style is provided by QGtkStyle.
-  \li \image motif-tabwidget.png Motif Style Widget Gallery
-  \caption \l{Motif Style Widget Gallery}
 
-  The Motif style is provided by QMotifStyle.
-  \li \image cde-tabwidget.png CDE Style Widget Gallery
-  \caption \l{CDE Style Widget Gallery}
-
-  The Common Desktop Environment style is provided by QCDEStyle.
   \endtable
 */
diff --git a/src/widgets/kernel/qapplication.cpp b/src/widgets/kernel/qapplication.cpp
index b61c523..68d7ee3 100644
--- a/src/widgets/kernel/qapplication.cpp
+++ b/src/widgets/kernel/qapplication.cpp
@@ -524,7 +524,7 @@ void QApplicationPrivate::process_cmdline()
     All Qt programs automatically support the following command line options:
     \list
         \li  -style= \e style, sets the application GUI style. Possible values
-            are \c motif, \c windows, and \c platinum. If you compiled Qt with
+            depend on your system configuration. If you compiled Qt with
             additional styles or have additional styles as plugins these will
             be available to the \c -style command line option.
         \li  -style \e style, is the same as listed above.
@@ -1206,7 +1206,7 @@ void QApplication::setStyle(QStyle *style)
     Requests a QStyle object for \a style from the QStyleFactory.
 
     The string must be one of the QStyleFactory::keys(), typically one of
-    "windows", "motif", "cde", "plastique", "windowsxp", or "macintosh". Style
+    "windows", "cleanlooks", "plastique", "windowsxp", or "macintosh". Style
     names are case insensitive.
 
     Returns 0 if an unknown \a style is passed, otherwise the QStyle object
diff --git a/src/widgets/styles/qcdestyle.cpp b/src/widgets/styles/qcdestyle.cpp
deleted file mode 100644
index 58c0e8c..0000000
--- a/src/widgets/styles/qcdestyle.cpp
+++ /dev/null
@@ -1,306 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qcdestyle.h"
-
-#if !defined(QT_NO_STYLE_CDE) || defined(QT_PLUGIN)
-
-#include "qmenu.h"
-#include "qapplication.h"
-#include "qpainter.h"
-#include "qdrawutil.h"
-#include "qpixmap.h"
-#include "qpalette.h"
-#include "qwidget.h"
-#include "qpushbutton.h"
-#include "qscrollbar.h"
-#include "qtabbar.h"
-#include "qtabwidget.h"
-#include "qlistview.h"
-#include "qsplitter.h"
-#include "qslider.h"
-#include "qcombobox.h"
-#include "qlineedit.h"
-#include "qprogressbar.h"
-#include "qimage.h"
-#include "qfocusframe.h"
-#include "qpainterpath.h"
-#include "qdebug.h"
-#include <limits.h>
-
-QT_BEGIN_NAMESPACE
-
-/*!
-    \class QCDEStyle
-    \brief The QCDEStyle class provides a CDE look and feel.
-
-    \ingroup appearance
-    \inmodule QtWidgets
-
-    This style provides a slightly improved Motif look similar to some
-    versions of the Common Desktop Environment (CDE). The main
-    differences are thinner frames and more modern radio buttons and
-    checkboxes. Together with a dark background and a bright
-    text/foreground color, the style looks quite attractive (at least
-    for Motif fans).
-
-    Note that most of the functions provided by QCDEStyle are
-    reimplementations of QStyle functions; see QStyle for their
-    documentation. QCDEStyle provides overloads for drawControl() and
-    drawPrimitive() which are documented here.
-
-    \image qcdestyle.png
-    \sa QWindowsXPStyle, QMacStyle, QWindowsStyle, QPlastiqueStyle, QMotifStyle
-*/
-
-/*!
-    Constructs a QCDEStyle.
-
-    If \a useHighlightCols is false (the default), then the style will
-    polish the application's color palette to emulate the Motif way of
-    highlighting, which is a simple inversion between the base and the
-    text color.
-*/
-QCDEStyle::QCDEStyle(bool useHighlightCols)
-    : QMotifStyle(useHighlightCols)
-{
-}
-
-/*!
-    Destroys the style.
-*/
-QCDEStyle::~QCDEStyle()
-{
-}
-
-
-/*!\reimp
-*/
-int QCDEStyle::pixelMetric(PixelMetric metric, const QStyleOption *option,
-                           const QWidget *widget) const
-/*
-int QCDEStyle::pixelMetric(PixelMetric metric, const QStyleOption *option,
-                           const QWidget *widget) const
-                           */
-{
-    int ret = 0;
-
-    switch(metric) {
-    case PM_MenuBarPanelWidth:
-    case PM_DefaultFrameWidth:
-    case PM_FocusFrameVMargin:
-    case PM_FocusFrameHMargin:
-    case PM_MenuPanelWidth:
-    case PM_SpinBoxFrameWidth:
-    case PM_MenuBarVMargin:
-    case PM_MenuBarHMargin:
-    case PM_DockWidgetFrameWidth:
-        ret = 1;
-        break;
-    case PM_ScrollBarExtent:
-        ret = 13;
-        break;
-    default:
-        ret = QMotifStyle::pixelMetric(metric, option, widget);
-        break;
-    }
-    return ret;
-}
-
-/*!
-    \reimp
-*/
-void QCDEStyle::drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
-                            const QWidget *widget) const
-{
-
-    switch(element) {
-    case CE_MenuBarItem: {
-        if (opt->state & State_Selected)  // active item
-            qDrawShadePanel(p, opt->rect, opt->palette, true, 1,
-                            &opt->palette.brush(QPalette::Button));
-        else  // other item
-            p->fillRect(opt->rect, opt->palette.brush(QPalette::Button));
-        QCommonStyle::drawControl(element, opt, p, widget);
-        break; }
-    case CE_RubberBand: {
-        p->save();
-        p->setClipping(false);
-        QPainterPath path;
-        path.addRect(opt->rect);
-        path.addRect(opt->rect.adjusted(2, 2, -2, -2));
-        p->fillPath(path, opt->palette.color(QPalette::Active, QPalette::Text));
-        p->restore();
-        break; }
-    default:
-        QMotifStyle::drawControl(element, opt, p, widget);
-    break;
-    }
-}
-
-/*!
-    \reimp
-*/
-void QCDEStyle::drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
-                        const QWidget *widget) const
-{
-    switch(pe) {
-    case PE_IndicatorCheckBox: {
-        bool down = opt->state & State_Sunken;
-        bool on = opt->state & State_On;
-        bool showUp = !(down ^ on);
-        QBrush fill = (showUp || (opt->state & State_NoChange)) ? opt->palette.brush(QPalette::Button) : opt->palette.brush(QPalette::Mid);
-        qDrawShadePanel(p, opt->rect, opt->palette, !showUp, pixelMetric(PM_DefaultFrameWidth), &opt->palette.brush(QPalette::Button));
-
-        if (on || (opt->state & State_NoChange)) {
-            QRect r = opt->rect;
-            QPolygon a(7 * 2);
-            int i, xx, yy;
-            xx = r.x() + 3;
-            yy = r.y() + 5;
-            if (opt->rect.width() <= 9) {
-                // When called from CE_MenuItem in QMotifStyle
-                xx -= 2;
-                yy -= 2;
-            }
-
-            for (i = 0; i < 3; i++) {
-                a.setPoint(2 * i, xx, yy);
-                a.setPoint(2 * i + 1, xx, yy + 2);
-                xx++; yy++;
-            }
-            yy -= 2;
-            for (i = 3; i < 7; i++) {
-                a.setPoint(2 * i, xx, yy);
-                a.setPoint(2 * i + 1, xx, yy + 2);
-                xx++; yy--;
-            }
-            if (opt->state & State_NoChange)
-                p->setPen(opt->palette.dark().color());
-            else
-                p->setPen(opt->palette.foreground().color());
-            p->drawPolyline(a);
-        }
-        if (!(opt->state & State_Enabled) && styleHint(SH_DitherDisabledText))
-            p->fillRect(opt->rect, QBrush(p->background().color(), Qt::Dense5Pattern));
-    } break;
-    case PE_IndicatorRadioButton:
-        {
-            QRect r = opt->rect;
-#define INTARRLEN(x) sizeof(x)/(sizeof(int)*2)
-            static const int pts1[] = {              // up left  lines
-                1,9, 1,8, 0,7, 0,4, 1,3, 1,2, 2,1, 3,1, 4,0, 7,0, 8,1, 9,1 };
-            static const int pts4[] = {              // bottom right  lines
-                2,10, 3,10, 4,11, 7,11, 8,10, 9,10, 10,9, 10,8, 11,7,
-                11,4, 10,3, 10,2 };
-            static const int pts5[] = {              // inner fill
-                4,2, 7,2, 9,4, 9,7, 7,9, 4,9, 2,7, 2,4 };
-            bool down = opt->state & State_Sunken;
-            bool on = opt->state & State_On;
-            QPolygon a(INTARRLEN(pts1), pts1);
-
-            //center when rect is larger than indicator size
-            int xOffset = 0;
-            int yOffset = 0;
-            int indicatorWidth = pixelMetric(PM_ExclusiveIndicatorWidth);
-            int indicatorHeight = pixelMetric(PM_ExclusiveIndicatorWidth);
-            if (r.width() > indicatorWidth)
-                xOffset += (r.width() - indicatorWidth)/2;
-            if (r.height() > indicatorHeight)
-                yOffset += (r.height() - indicatorHeight)/2;
-            p->translate(xOffset, yOffset);
-
-            a.translate(r.x(), r.y());
-            QPen oldPen = p->pen();
-            QBrush oldBrush = p->brush();
-            p->setPen((down || on) ? opt->palette.dark().color() : opt->palette.light().color());
-            p->drawPolyline(a);
-            a.setPoints(INTARRLEN(pts4), pts4);
-            a.translate(r.x(), r.y());
-            p->setPen((down || on) ? opt->palette.light().color() : opt->palette.dark().color());
-            p->drawPolyline(a);
-            a.setPoints(INTARRLEN(pts5), pts5);
-            a.translate(r.x(), r.y());
-            QColor fillColor = on ? opt->palette.dark().color() : opt->palette.background().color();
-            p->setPen(fillColor);
-            p->setBrush(on ? opt->palette.brush(QPalette::Dark) :
-                         opt->palette.brush(QPalette::Window));
-            p->drawPolygon(a);
-            if (!(opt->state & State_Enabled) && styleHint(SH_DitherDisabledText))
-                p->fillRect(opt->rect, QBrush(p->background().color(), Qt::Dense5Pattern));
-            p->setPen(oldPen);
-            p->setBrush(oldBrush);
-
-            p->translate(-xOffset, -yOffset);
-
-        } break;
-    default:
-        QMotifStyle::drawPrimitive(pe, opt, p, widget);
-    }
-}
-
-/*!\reimp*/
-QPalette QCDEStyle::standardPalette() const
-{
-    QColor background(0xb6, 0xb6, 0xcf);
-    QColor light = background.lighter();
-    QColor mid = background.darker(150);
-    QColor dark = background.darker();
-    QPalette palette(Qt::black, background, light, dark, mid, Qt::black, Qt::white);
-    palette.setBrush(QPalette::Disabled, QPalette::WindowText, dark);
-    palette.setBrush(QPalette::Disabled, QPalette::Text, dark);
-    palette.setBrush(QPalette::Disabled, QPalette::ButtonText, dark);
-    palette.setBrush(QPalette::Disabled, QPalette::Base, background);
-    return palette;
-}
-
-/*!
-    \reimp
-*/
-QIcon QCDEStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption *opt,
-                                            const QWidget *widget) const
-{
-    return QMotifStyle::standardIcon(standardIcon, opt, widget);
-}
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/widgets/styles/qcdestyle.h b/src/widgets/styles/qcdestyle.h
deleted file mode 100644
index 574f0a1..0000000
--- a/src/widgets/styles/qcdestyle.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef QCDESTYLE_H
-#define QCDESTYLE_H
-
-#include <QtWidgets/qmotifstyle.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-#if !defined(QT_NO_STYLE_CDE)
-
-class Q_WIDGETS_EXPORT QCDEStyle : public QMotifStyle
-{
-    Q_OBJECT
-public:
-    explicit QCDEStyle(bool useHighlightCols = false);
-    virtual ~QCDEStyle();
-
-    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
-                    const QWidget *widget = 0) const;
-    void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
-                     const QWidget *w = 0) const;
-    void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
-                       const QWidget *w = 0) const;
-    QPalette standardPalette() const;
-    QIcon standardIcon(StandardPixmap standardIcon, const QStyleOption *opt = 0,
-                       const QWidget *widget = 0) const;
-};
-
-#endif // QT_NO_STYLE_CDE
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QCDESTYLE_H
diff --git a/src/widgets/styles/qcleanlooksstyle.cpp b/src/widgets/styles/qcleanlooksstyle.cpp
index 153b97e..99e4b17 100644
--- a/src/widgets/styles/qcleanlooksstyle.cpp
+++ b/src/widgets/styles/qcleanlooksstyle.cpp
@@ -600,7 +600,7 @@ static void qt_cleanlooks_draw_mdibutton(QPainter *painter, const QStyleOptionTi
     Stellingwerff and Daniel Borgmann.
 
     \sa {Cleanlooks Style Widget Gallery}, QWindowsXPStyle, QMacStyle, QWindowsStyle,
-        QCDEStyle, QMotifStyle, QPlastiqueStyle
+        QPlastiqueStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qcommonstyle.cpp b/src/widgets/styles/qcommonstyle.cpp
index 0460ad6..85d46bb 100644
--- a/src/widgets/styles/qcommonstyle.cpp
+++ b/src/widgets/styles/qcommonstyle.cpp
@@ -107,7 +107,7 @@ QT_BEGIN_NAMESPACE
     subElementRect() are documented here.
     \endomit
 
-    \sa QStyle, QMotifStyle, QWindowsStyle
+    \sa QStyle, QWindowsStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qgtkstyle.cpp b/src/widgets/styles/qgtkstyle.cpp
index a836a24..19da3ca 100644
--- a/src/widgets/styles/qgtkstyle.cpp
+++ b/src/widgets/styles/qgtkstyle.cpp
@@ -182,7 +182,7 @@ static GdkColor fromQColor(const QColor &color)
           The Qt3-based "Qt" GTK+ theme engine will not work with QGtkStyle.
 
     \sa {Cleanlooks Style Widget Gallery}, QWindowsXPStyle, QMacStyle, QWindowsStyle,
-        QCDEStyle, QMotifStyle, QPlastiqueStyle, QCleanlooksStyle
+        QPlastiqueStyle, QCleanlooksStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qmacstyle.qdoc b/src/widgets/styles/qmacstyle.qdoc
index 0c7da18..e419f73 100644
--- a/src/widgets/styles/qmacstyle.qdoc
+++ b/src/widgets/styles/qmacstyle.qdoc
@@ -81,7 +81,7 @@
     documentation.
 
     \image qmacstyle.png
-    \sa QWindowsXPStyle, QWindowsStyle, QPlastiqueStyle, QCDEStyle, QMotifStyle
+    \sa QWindowsXPStyle, QWindowsStyle, QPlastiqueStyle
 */
 
 
diff --git a/src/widgets/styles/qmotifstyle.cpp b/src/widgets/styles/qmotifstyle.cpp
deleted file mode 100644
index 0b9452a..0000000
--- a/src/widgets/styles/qmotifstyle.cpp
+++ /dev/null
@@ -1,2544 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qmotifstyle.h"
-#include "qcdestyle.h"
-
-#if !defined(QT_NO_STYLE_MOTIF) || defined(QT_PLUGIN)
-
-#include "qmenu.h"
-#include "qapplication.h"
-#include "qpainter.h"
-#include "qdrawutil.h"
-#include "qpixmap.h"
-#include "qpalette.h"
-#include "qwidget.h"
-#include "qpushbutton.h"
-#include "qscrollbar.h"
-#include "qtabbar.h"
-#include "qtabwidget.h"
-#include "qlistview.h"
-#include "qsplitter.h"
-#include "qslider.h"
-#include "qcombobox.h"
-#include "qlineedit.h"
-#include "qprogressbar.h"
-#include "qimage.h"
-#include "qfocusframe.h"
-#include "qdebug.h"
-#include "qpainterpath.h"
-#include "qmotifstyle_p.h"
-#include "qdialogbuttonbox.h"
-#include "qformlayout.h"
-#include <limits.h>
-#include <QtWidgets/qgraphicsproxywidget.h>
-#include <QtWidgets/qgraphicsview.h>
-
-QT_BEGIN_NAMESPACE
-
-// old constants that might still be useful...
-static const int motifItemFrame         = 2;    // menu item frame width
-static const int motifSepHeight         = 2;    // separator item height
-static const int motifItemHMargin       = 3;    // menu item hor text margin
-static const int motifItemVMargin       = 2;    // menu item ver text margin
-static const int motifArrowHMargin      = 6;    // arrow horizontal margin
-static const int motifTabSpacing        = 12;   // space between text and tab
-static const int motifCheckMarkHMargin  = 2;    // horiz. margins of check mark
-static const int motifCheckMarkSpace    = 16;
-
-
-/*!
-  \class QMotifStyle
-  \brief The QMotifStyle class provides Motif look and feel.
-
-  \ingroup appearance
-  \inmodule QtWidgets
-
-  This class implements the Motif look and feel. It closely
-  resembles the original Motif look as defined by the Open Group,
-  but with some minor improvements. The Motif style is Qt's default
-  GUI style on Unix platforms.
-
-  \image qmotifstyle.png
-  \sa QWindowsXPStyle, QMacStyle, QWindowsStyle, QPlastiqueStyle, QCDEStyle
-*/
-
-/*!
-    \variable QMotifStyle::focus
-    \internal
-*/
-
-/*!
-  Constructs a QMotifStyle.
-
-  If \a useHighlightCols is false (the default), the style will
-  polish the application's color palette to emulate the Motif way of
-  highlighting, which is a simple inversion between the base and the
-  text color.
-*/
-QMotifStyle::QMotifStyle(bool useHighlightCols)
-    : QCommonStyle(*new QMotifStylePrivate)
-{
-    focus = 0;
-    highlightCols = useHighlightCols;
-}
-
-
-/*!
-    \internal
-*/
-QMotifStyle::QMotifStyle(QMotifStylePrivate &dd, bool useHighlightColors)
-    : QCommonStyle(dd)
-{
-    focus = 0;
-    highlightCols = useHighlightColors;
-}
-
-
-/*!
-  \overload
-
-  Destroys the style.
-*/
-QMotifStyle::~QMotifStyle()
-{
-    delete focus;
-}
-
-/*!
-    \internal
-    Animate indeterminate progress bars only when visible
-*/
-bool QMotifStyle::eventFilter(QObject *o, QEvent *e)
-{
-#ifndef QT_NO_PROGRESSBAR
-    Q_D(QMotifStyle);
-    switch(e->type()) {
-    case QEvent::StyleChange:
-    case QEvent::Show:
-        if (QProgressBar *bar = qobject_cast<QProgressBar *>(o)) {
-            d->bars << bar;
-            if (d->bars.size() == 1) {
-                Q_ASSERT(d->animationFps> 0);
-                d->animateTimer = startTimer(1000 / d->animationFps);
-            }
-        }
-        break;
-    case QEvent::Destroy:
-    case QEvent::Hide:
-        // reinterpret_cast because there is no type info when getting
-        // the destroy event. We know that it is a QProgressBar.
-        if (QProgressBar *bar = reinterpret_cast<QProgressBar *>(o)) {
-            d->bars.removeAll(bar);
-            if (d->bars.isEmpty() && d->animateTimer) {
-                killTimer(d->animateTimer);
-                d->animateTimer = 0;
-            }
-        }
-    default:
-        break;
-    }
-#endif // QT_NO_PROGRESSBAR
-    return QStyle::eventFilter(o, e);
-}
-
-/*!
-    \reimp
-*/
-QIcon QMotifStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption *opt,
-                                const QWidget *widget) const
-{
-    return QCommonStyle::standardIcon(standardIcon, opt, widget);
-}
-
-/*!
-    \reimp
-*/
-void QMotifStyle::timerEvent(QTimerEvent *event)
-{
-#ifndef QT_NO_PROGRESSBAR
-    Q_D(QMotifStyle);
-    if (event->timerId() == d->animateTimer) {
-        Q_ASSERT(d->animationFps > 0);
-        d->animateStep = d->startTime.elapsed() / (1000 / d->animationFps);
-        foreach (QProgressBar *bar, d->bars) {
-            if ((bar->minimum() == 0 && bar->maximum() == 0))
-                bar->update();
-        }
-    }
-#endif // QT_NO_PROGRESSBAR
-    event->ignore();
-}
-
-
-QMotifStylePrivate::QMotifStylePrivate()
-#ifndef QT_NO_PROGRESSBAR
-    : animationFps(25), animateTimer(0), animateStep(0)
-#endif
-{
-}
-
-/*!
-  If \a arg is false, the style will polish the application's color
-  palette to emulate the Motif way of highlighting, which is a
-  simple inversion between the base and the text color.
-
-  The effect will show up the next time an application palette is
-  set via QApplication::setPalette(). The current color palette of
-  the application remains unchanged.
-
-  \sa QStyle::polish()
-*/
-void QMotifStyle::setUseHighlightColors(bool arg)
-{
-    highlightCols = arg;
-}
-
-/*!
-  Returns true if the style treats the highlight colors of the
-  palette in a Motif-like manner, which is a simple inversion
-  between the base and the text color; otherwise returns false. The
-  default is false.
-*/
-bool QMotifStyle::useHighlightColors() const
-{
-    return highlightCols;
-}
-
-/*! \reimp */
-
-void QMotifStyle::polish(QPalette& pal)
-{
-    if (pal.brush(QPalette::Active, QPalette::Light) == pal.brush(QPalette::Active, QPalette::Base)) {
-        QColor nlight = pal.color(QPalette::Active, QPalette::Light).darker(108);
-        pal.setColor(QPalette::Active, QPalette::Light, nlight) ;
-        pal.setColor(QPalette::Disabled, QPalette::Light, nlight) ;
-        pal.setColor(QPalette::Inactive, QPalette::Light, nlight) ;
-    }
-
-    if (highlightCols)
-        return;
-
-    // force the ugly motif way of highlighting *sigh*
-    pal.setColor(QPalette::Active, QPalette::Highlight,
-                 pal.color(QPalette::Active, QPalette::Text));
-    pal.setColor(QPalette::Active, QPalette::HighlightedText,
-                 pal.color(QPalette::Active, QPalette::Base));
-    pal.setColor(QPalette::Disabled, QPalette::Highlight,
-                 pal.color(QPalette::Disabled, QPalette::Text));
-    pal.setColor(QPalette::Disabled, QPalette::HighlightedText,
-                 pal.color(QPalette::Disabled, QPalette::Base));
-    pal.setColor(QPalette::Inactive, QPalette::Highlight,
-                 pal.color(QPalette::Active, QPalette::Text));
-    pal.setColor(QPalette::Inactive, QPalette::HighlightedText,
-                 pal.color(QPalette::Active, QPalette::Base));
-}
-
-/*!
-  \reimp
-  \internal
-  Keep QStyle::polish() visible.
-*/
-void QMotifStyle::polish(QWidget* widget)
-{
-    QStyle::polish(widget);
-#ifndef QT_NO_PROGRESSBAR
-    if (qobject_cast<QProgressBar *>(widget))
-        widget->installEventFilter(this);
-#endif
-}
-
-/*!
-  \reimp
-  \internal
-  Keep QStyle::polish() visible.
-*/
-void QMotifStyle::unpolish(QWidget* widget)
-{
-    QCommonStyle::unpolish(widget);
-#ifndef QT_NO_PROGRESSBAR
-    if (qobject_cast<QProgressBar *>(widget)) {
-        Q_D(QMotifStyle);
-        widget->removeEventFilter(this);
-        d->bars.removeAll(static_cast<QProgressBar*>(widget));
-     }
-#endif
-}
-
-
-/*!
-  \reimp
-  \internal
-  Keep QStyle::polish() visible.
-*/
-void QMotifStyle::polish(QApplication* a)
-{
-    QCommonStyle::polish(a);
-}
-
-
-/*!
-  \reimp
-  \internal
-  Keep QStyle::polish() visible.
-*/
-void QMotifStyle::unpolish(QApplication* a)
-{
-    QCommonStyle::unpolish(a);
-}
-
-static void rot(QPolygon& a, int n)
-{
-    QPolygon r(a.size());
-    for (int i = 0; i < (int)a.size(); i++) {
-        switch (n) {
-        case 1: r.setPoint(i,-a[i].y(),a[i].x()); break;
-        case 2: r.setPoint(i,-a[i].x(),-a[i].y()); break;
-        case 3: r.setPoint(i,a[i].y(),-a[i].x()); break;
-        }
-    }
-    a = r;
-}
-
-
-/*!
-  \reimp
-*/
-void QMotifStyle::drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
-                                const QWidget *w) const
-{
-    switch(pe) {
-    case PE_FrameTabWidget:
-    case PE_FrameWindow:
-        qDrawShadePanel(p, opt->rect, opt->palette, QStyle::State_None, proxy()->pixelMetric(PM_DefaultFrameWidth));
-        break;
-    case PE_FrameFocusRect:
-        if (const QStyleOptionFocusRect *fropt = qstyleoption_cast<const QStyleOptionFocusRect *>(opt)) {
-            if ((fropt->state & State_HasFocus) && focus && focus->isVisible()
-                    && !(fropt->state & QStyle::State_Item))
-                break;
-            QCommonStyle::drawPrimitive(pe, opt, p, w);
-        }
-        break;
-
-    case PE_IndicatorToolBarHandle: {
-        p->save();
-        p->translate(opt->rect.x(), opt->rect.y());
-
-        QColor dark(opt->palette.dark().color());
-        QColor light(opt->palette.light().color());
-        int i;
-        if (opt->state & State_Horizontal) {
-            int h = opt->rect.height();
-            if (h > 6) {
-                if (opt->state & State_On)
-                    p->fillRect(1, 1, 8, h - 2, opt->palette.highlight());
-                QPolygon a(2 * ((h-6)/3));
-                int y = 3 + (h%3)/2;
-                p->setPen(dark);
-                p->drawLine(8, 1, 8, h-2);
-                for (i=0; 2*i < a.size(); ++i) {
-                    a.setPoint(2*i, 5, y+1+3*i);
-                    a.setPoint(2*i+1, 2, y+2+3*i);
-                }
-                p->drawPoints(a);
-                p->setPen(light);
-                p->drawLine(9, 1, 9, h-2);
-                for (i=0; 2*i < a.size(); i++) {
-                    a.setPoint(2*i, 4, y+3*i);
-                    a.setPoint(2*i+1, 1, y+1+3*i);
-                }
-                p->drawPoints(a);
-                // if (drawBorder) {
-                // p->setPen(QPen(Qt::darkGray));
-                // p->drawLine(0, opt->rect.height() - 1,
-                // tbExtent, opt->rect.height() - 1);
-                // }
-            }
-        } else {
-            int w = opt->rect.width();
-            if (w > 6) {
-                if (opt->state & State_On)
-                    p->fillRect(1, 1, w - 2, 9, opt->palette.highlight());
-                QPolygon a(2 * ((w-6)/3));
-
-                int x = 3 + (w%3)/2;
-                p->setPen(dark);
-                p->drawLine(1, 8, w-2, 8);
-                for (i=0; 2*i < a.size(); ++i) {
-                    a.setPoint(2*i, x+1+3*i, 6);
-                    a.setPoint(2*i+1, x+2+3*i, 3);
-                }
-                p->drawPoints(a);
-                p->setPen(light);
-                p->drawLine(1, 9, w-2, 9);
-                for (i=0; 2*i < a.size(); ++i) {
-                    a.setPoint(2*i, x+3*i, 5);
-                    a.setPoint(2*i+1, x+1+3*i, 2);
-                }
-                p->drawPoints(a);
-                // if (drawBorder) {
-                // p->setPen(QPen(Qt::darkGray));
-                // p->drawLine(opt->rect.width() - 1, 0,
-                // opt->rect.width() - 1, tbExtent);
-                // }
-            }
-        }
-        p->restore();
-        break; }
-
-    case PE_PanelButtonCommand:
-    case PE_PanelButtonBevel:
-    case PE_PanelButtonTool: {
-        QBrush fill;
-        if (opt->state & State_Sunken)
-            fill = opt->palette.brush(QPalette::Mid);
-        else if ((opt->state & State_On) && (opt->state & State_Enabled))
-            fill = QBrush(opt->palette.mid().color(), Qt::Dense4Pattern);
-        else
-            fill = opt->palette.brush(QPalette::Button);
-         if ((opt->state & State_Enabled || opt->state & State_On) || !(opt->state & State_AutoRaise))
-             qDrawShadePanel(p, opt->rect, opt->palette, bool(opt->state & (State_Sunken | State_On)),
-                             proxy()->pixelMetric(PM_DefaultFrameWidth), &fill);
-        break; }
-
-    case PE_IndicatorCheckBox: {
-        bool on = opt->state & State_On;
-        bool down = opt->state & State_Sunken;
-        bool showUp = !(down ^ on);
-        QBrush fill = opt->palette.brush((showUp || opt->state & State_NoChange) ?QPalette::Button : QPalette::Mid);
-        if (opt->state & State_NoChange) {
-            qDrawPlainRect(p, opt->rect, opt->palette.text().color(),
-                           1, &fill);
-            p->drawLine(opt->rect.x() + opt->rect.width() - 1, opt->rect.y(),
-                        opt->rect.x(), opt->rect.y() + opt->rect.height() - 1);
-        } else {
-            qDrawShadePanel(p, opt->rect, opt->palette, !showUp,
-                            proxy()->pixelMetric(PM_DefaultFrameWidth), &fill);
-        }
-        if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText))
-            p->fillRect(opt->rect, QBrush(p->background().color(), Qt::Dense5Pattern));
-        break; }
-
-    case PE_IndicatorRadioButton: {
-#define INTARRLEN(x) sizeof(x)/(sizeof(int)*2)
-        int inner_pts[] = { // used for filling diamond
-            2,opt->rect.height()/2,
-            opt->rect.width()/2,2,
-            opt->rect.width()-3,opt->rect.height()/2,
-            opt->rect.width()/2,opt->rect.height()-3
-        };
-        int top_pts[] = { // top (^) of diamond
-            0,opt->rect.height()/2,
-            opt->rect.width()/2,0,
-            opt->rect.width()-2,opt->rect.height()/2-1,
-            opt->rect.width()-3,opt->rect.height()/2-1,
-            opt->rect.width()/2,1,
-            1,opt->rect.height()/2,
-            2,opt->rect.height()/2,
-            opt->rect.width()/2,2,
-            opt->rect.width()-4,opt->rect.height()/2-1
-        };
-        int bottom_pts[] = { // bottom (v) of diamond
-            1,opt->rect.height()/2+1,
-            opt->rect.width()/2,opt->rect.height()-1,
-            opt->rect.width()-1,opt->rect.height()/2,
-            opt->rect.width()-2,opt->rect.height()/2,
-            opt->rect.width()/2,opt->rect.height()-2,
-            2,opt->rect.height()/2+1,
-            3,opt->rect.height()/2+1,
-            opt->rect.width()/2,opt->rect.height()-3,
-            opt->rect.width()-3,opt->rect.height()/2
-        };
-        bool on = opt->state & State_On;
-        bool down = opt->state & State_Sunken;
-        bool showUp = !(down ^ on);
-        QPen oldPen = p->pen();
-        QBrush oldBrush = p->brush();
-        QPolygon a(INTARRLEN(inner_pts), inner_pts);
-        p->setPen(Qt::NoPen);
-        p->setBrush(opt->palette.brush(showUp ? QPalette::Button : QPalette::Mid));
-        a.translate(opt->rect.x(), opt->rect.y());
-        p->drawPolygon(a);
-        p->setPen(showUp ? opt->palette.light().color() : opt->palette.dark().color());
-        p->setBrush(Qt::NoBrush);
-        a.setPoints(INTARRLEN(top_pts), top_pts);
-        a.translate(opt->rect.x(), opt->rect.y());
-        p->drawPolyline(a);
-        p->setPen(showUp ? opt->palette.dark().color() : opt->palette.light().color());
-        a.setPoints(INTARRLEN(bottom_pts), bottom_pts);
-        a.translate(opt->rect.x(), opt->rect.y());
-        p->drawPolyline(a);
-        if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText))
-            p->fillRect(opt->rect, QBrush(p->background().color(), Qt::Dense5Pattern));
-        p->setPen(oldPen);
-        p->setBrush(oldBrush);
-        break; }
-
-    case PE_IndicatorSpinUp:
-    case PE_IndicatorSpinPlus:
-    case PE_IndicatorSpinDown:
-    case PE_IndicatorSpinMinus:
-    case PE_IndicatorArrowUp:
-    case PE_IndicatorArrowDown:
-    case PE_IndicatorArrowRight:
-    case PE_IndicatorArrowLeft: {
-        QRect rect = opt->rect;
-        QPolygon bFill;
-        QPolygon bTop;
-        QPolygon bBot;
-        QPolygon bLeft;
-        if (pe == PE_IndicatorSpinPlus || pe == PE_IndicatorSpinUp)
-            pe = PE_IndicatorArrowUp;
-        else if (pe == PE_IndicatorSpinMinus || pe == PE_IndicatorSpinDown)
-            pe = PE_IndicatorArrowDown;
-        bool vertical = pe == PE_IndicatorArrowUp || pe == PE_IndicatorArrowDown;
-        bool horizontal = !vertical;
-        int dim = rect.width() < rect.height() ? rect.width() : rect.height();
-        int colspec = 0x0000;
-
-        if (!(opt->state & State_Enabled))
-            dim -= 2;
-        if(dim < 2)
-           break;
-
-        // adjust size and center (to fix rotation below)
-        if (rect.width() > dim) {
-            rect.setX(rect.x() + ((rect.width() - dim) / 2));
-            rect.setWidth(dim);
-        }
-        if (rect.height() > dim) {
-            rect.setY(rect.y() + ((rect.height() - dim) / 2));
-            rect.setHeight(dim);
-        }
-
-        if (dim > 3) {
-            if (pixelMetric(PM_DefaultFrameWidth) < 2) { // thin style
-                bFill.resize( dim & 1 ? 3 : 4 );
-                bTop.resize( 2 );
-                bBot.resize( 2 );
-                bLeft.resize( 2 );
-                bLeft.putPoints( 0, 2, 0, 0, 0, dim-1 );
-                bTop.putPoints( 0, 2, 1, 0, dim-1, dim/2 );
-                bBot.putPoints( 0, 2, 1, dim-1, dim-1, dim/2 );
-
-                if ( dim > 6 ) {                        // dim>6: must fill interior
-                    bFill.putPoints( 0, 2, 0, dim-1, 0, 0 );
-                    if ( dim & 1 )                      // if size is an odd number
-                        bFill.setPoint( 2, dim - 1, dim / 2 );
-                    else
-                        bFill.putPoints( 2, 2, dim-1, dim/2-1, dim-1, dim/2 );
-                }
-            } else {
-                if (dim > 6)
-                    bFill.resize(dim & 1 ? 3 : 4);
-                bTop.resize((dim/2)*2);
-                bBot.resize(dim & 1 ? dim + 1 : dim);
-                bLeft.resize(dim > 4 ? 4 : 2);
-                bLeft.putPoints(0, 2, 0,0, 0,dim-1);
-                if (dim > 4)
-                    bLeft.putPoints(2, 2, 1,2, 1,dim-3);
-                bTop.putPoints(0, 4, 1,0, 1,1, 2,1, 3,1);
-                bBot.putPoints(0, 4, 1,dim-1, 1,dim-2, 2,dim-2, 3,dim-2);
-
-                for(int i=0; i<dim/2-2 ; i++) {
-                    bTop.putPoints(i*2+4, 2, 2+i*2,2+i, 5+i*2, 2+i);
-                    bBot.putPoints(i*2+4, 2, 2+i*2,dim-3-i, 5+i*2,dim-3-i);
-                }
-                if (dim & 1)                          // odd number size: extra line
-                    bBot.putPoints(dim-1, 2, dim-3,dim/2, dim-1,dim/2);
-                if (dim > 6) {                        // dim>6: must fill interior
-                    bFill.putPoints(0, 2, 1,dim-3, 1,2);
-                    if (dim & 1)                      // if size is an odd number
-                        bFill.setPoint(2, dim - 3, dim / 2);
-                    else
-                        bFill.putPoints(2, 2, dim-4,dim/2-1, dim-4,dim/2);
-                }
-            }
-        } else {
-            if (dim == 3) {                       // 3x3 arrow pattern
-                bLeft.setPoints(4, 0,0, 0,2, 1,1, 1,1);
-                bTop .setPoints(2, 1,0, 1,0);
-                bBot .setPoints(2, 1,2, 2,1);
-            }
-            else {                                  // 2x2 arrow pattern
-                bLeft.setPoints(2, 0,0, 0,1);
-                bTop .setPoints(2, 1,0, 1,0);
-                bBot .setPoints(2, 1,1, 1,1);
-            }
-        }
-
-        // We use rot() and translate() as it is more efficient that
-        // matrix transformations on the painter, and because it still
-        // works with QT_NO_TRANSFORMATIONS defined.
-
-        if (pe == PE_IndicatorArrowUp || pe == PE_IndicatorArrowLeft) {
-            if (vertical) {
-                rot(bFill,3);
-                rot(bLeft,3);
-                rot(bTop,3);
-                rot(bBot,3);
-                bFill.translate(0, rect.height() - 1);
-                bLeft.translate(0, rect.height() - 1);
-                bTop.translate(0, rect.height() - 1);
-                bBot.translate(0, rect.height() - 1);
-            } else {
-                rot(bFill,2);
-                rot(bLeft,2);
-                rot(bTop,2);
-                rot(bBot,2);
-                bFill.translate(rect.width() - 1, rect.height() - 1);
-                bLeft.translate(rect.width() - 1, rect.height() - 1);
-                bTop.translate(rect.width() - 1, rect.height() - 1);
-                bBot.translate(rect.width() - 1, rect.height() - 1);
-            }
-            if (opt->state & State_Sunken)
-                colspec = horizontal ? 0x2334 : 0x2343;
-            else
-                colspec = horizontal ? 0x1443 : 0x1434;
-        } else {
-            if (vertical) {
-                rot(bFill,1);
-                rot(bLeft,1);
-                rot(bTop,1);
-                rot(bBot,1);
-                bFill.translate(rect.width() - 1, 0);
-                bLeft.translate(rect.width() - 1, 0);
-                bTop.translate(rect.width() - 1, 0);
-                bBot.translate(rect.width() - 1, 0);
-            }
-            if (opt->state & State_Sunken)
-                colspec = horizontal ? 0x2443 : 0x2434;
-            else
-                colspec = horizontal ? 0x1334 : 0x1343;
-        }
-        bFill.translate(rect.x(), rect.y());
-        bLeft.translate(rect.x(), rect.y());
-        bTop.translate(rect.x(), rect.y());
-        bBot.translate(rect.x(), rect.y());
-
-        const QColor *cols[5];
-        if (opt->state & State_Enabled) {
-            cols[0] = 0;
-            cols[1] = &opt->palette.button().color();
-            cols[2] = &opt->palette.mid().color();
-            cols[3] = &opt->palette.light().color();
-            cols[4] = &opt->palette.dark().color();
-        } else {
-            cols[0] = 0;
-            cols[1] = &opt->palette.mid().color();
-            cols[2] = &opt->palette.mid().color();
-            cols[3] = &opt->palette.mid().color();
-            cols[4] = &opt->palette.mid().color();
-        }
-
-#define CMID *cols[(colspec>>12) & 0xf]
-#define CLEFT *cols[(colspec>>8) & 0xf]
-#define CTOP *cols[(colspec>>4) & 0xf]
-#define CBOT *cols[colspec & 0xf]
-
-        QPen savePen = p->pen();
-        QBrush saveBrush = p->brush();
-        QPen pen(Qt::NoPen);
-        QBrush brush = opt->palette.brush((opt->state & State_Enabled) ?
-                                          QPalette::Button : QPalette::Mid);
-        p->setPen(pen);
-        p->setBrush(brush);
-        p->drawPolygon(bFill);
-        p->setBrush(Qt::NoBrush);
-
-        p->setPen(CLEFT);
-        p->drawPolyline(bLeft);
-        p->setPen(CTOP);
-        p->drawPolyline(bTop);
-        p->setPen(CBOT);
-        p->drawPolyline(bBot);
-
-        p->setBrush(saveBrush);
-        p->setPen(savePen);
-#undef CMID
-#undef CLEFT
-#undef CTOP
-#undef CBOT
-        if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText))
-            p->fillRect(opt->rect, QBrush(p->background().color(), Qt::Dense5Pattern));
-        break; }
-
-    case PE_IndicatorDockWidgetResizeHandle: {
-        const int motifOffset = 10;
-        int sw = proxy()->pixelMetric(PM_SplitterWidth);
-        if (opt->state & State_Horizontal) {
-            int yPos = opt->rect.y() + opt->rect.height() / 2;
-            int kPos = opt->rect.right() - motifOffset - sw;
-            int kSize = sw - 2;
-
-            qDrawShadeLine(p, opt->rect.left(), yPos, kPos, yPos, opt->palette);
-            qDrawShadePanel(p, kPos, yPos - sw / 2 + 1, kSize, kSize,
-                            opt->palette, false, 1, &opt->palette.brush(QPalette::Button));
-            qDrawShadeLine(p, kPos + kSize - 1, yPos, opt->rect.right(), yPos, opt->palette);
-        } else {
-            int xPos = opt->rect.x() + opt->rect.width() / 2;
-            int kPos = motifOffset;
-            int kSize = sw - 2;
-
-            qDrawShadeLine(p, xPos, opt->rect.top() + kPos + kSize - 1, xPos, opt->rect.bottom(), opt->palette);
-            qDrawShadePanel(p, xPos - sw / 2 + 1, opt->rect.top() + kPos, kSize, kSize, opt->palette,
-                            false, 1, &opt->palette.brush(QPalette::Button));
-            qDrawShadeLine(p, xPos, opt->rect.top(), xPos, opt->rect.top() + kPos, opt->palette);
-        }
-        break; }
-
-    case PE_IndicatorMenuCheckMark: {
-        const int markW = 6;
-        const int markH = 6;
-        int posX = opt->rect.x() + (opt->rect.width()  - markW) / 2 - 1;
-        int posY = opt->rect.y() + (opt->rect.height() - markH) / 2;
-        int dfw = proxy()->pixelMetric(PM_DefaultFrameWidth);
-
-        if (dfw < 2) {
-            // Could do with some optimizing/caching...
-            QPolygon a(7*2);
-            int i, xx, yy;
-            xx = posX;
-            yy = 3 + posY;
-            for (i=0; i<3; i++) {
-                a.setPoint(2*i,   xx, yy);
-                a.setPoint(2*i+1, xx, yy+2);
-                xx++; yy++;
-            }
-            yy -= 2;
-            for (i=3; i<7; i++) {
-                a.setPoint(2*i,   xx, yy);
-                a.setPoint(2*i+1, xx, yy+2);
-                xx++; yy--;
-            }
-            if (! (opt->state & State_Enabled) && ! (opt->state & State_On)) {
-                int pnt;
-                p->setPen(opt->palette.highlightedText().color());
-                QPoint offset(1,1);
-                for (pnt = 0; pnt < (int)a.size(); pnt++)
-                    a[pnt] += offset;
-                p->drawPolyline(a);
-                for (pnt = 0; pnt < (int)a.size(); pnt++)
-                    a[pnt] -= offset;
-            }
-            p->setPen(opt->palette.text().color());
-            p->drawPolyline(a);
-
-            qDrawShadePanel(p, posX-2, posY-2, markW+4, markH+6, opt->palette, true, dfw);
-        } else
-            qDrawShadePanel(p, posX, posY, markW, markH, opt->palette, true, dfw,
-                            &opt->palette.brush(QPalette::Mid));
-
-        break; }
-
-    case PE_IndicatorProgressChunk:
-        {
-            bool vertical = false;
-            if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(opt))
-                vertical = (pb2->orientation == Qt::Vertical);
-            if (!vertical) {
-                p->fillRect(opt->rect.x(), opt->rect.y(), opt->rect.width(),
-                            opt->rect.height(), opt->palette.brush(QPalette::Highlight));
-            } else {
-                p->fillRect(opt->rect.x(), opt->rect.y(), opt->rect.width(), opt->rect.height(),
-                            opt->palette.brush(QPalette::Highlight));
-            }
-        }
-        break;
-
-    default:
-        QCommonStyle::drawPrimitive(pe, opt, p, w);
-        break;
-    }
-}
-
-
-/*!
-  \reimp
-*/
-void QMotifStyle::drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
-                              const QWidget *widget) const
-{
-    switch(element) {
-    case CE_Splitter: {
-        QStyleOption handleOpt = *opt;
-        if (handleOpt.state & State_Horizontal)
-            handleOpt.state &= ~State_Horizontal;
-        else
-            handleOpt.state |= State_Horizontal;
-        proxy()->drawPrimitive(PE_IndicatorDockWidgetResizeHandle, &handleOpt, p, widget);
-        break; }
-
-    case CE_ScrollBarSubLine:
-    case CE_ScrollBarAddLine:{
-        PrimitiveElement pe;
-        if (element == CE_ScrollBarAddLine)
-            pe = (opt->state & State_Horizontal) ? (opt->direction == Qt::LeftToRight ? PE_IndicatorArrowRight : PE_IndicatorArrowLeft) : PE_IndicatorArrowDown;
-        else
-            pe = (opt->state & State_Horizontal) ? (opt->direction == Qt::LeftToRight ? PE_IndicatorArrowLeft : PE_IndicatorArrowRight) : PE_IndicatorArrowUp;
-        QStyleOption arrowOpt = *opt;
-        arrowOpt.state |= State_Enabled;
-        proxy()->drawPrimitive(pe, &arrowOpt, p, widget);
-        if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText)) {
-            int fw = proxy()->pixelMetric(PM_DefaultFrameWidth);
-            p->fillRect(opt->rect.adjusted(fw, fw, -fw, -fw), QBrush(p->background().color(), Qt::Dense5Pattern));
-        }
-    }break;
-
-    case CE_ScrollBarSubPage:
-    case CE_ScrollBarAddPage:
-        p->fillRect(opt->rect, opt->palette.brush((opt->state & State_Enabled) ? QPalette::Mid : QPalette::Window));
-        break;
-
-    case CE_ScrollBarSlider: {
-        QStyleOption bevelOpt = *opt;
-        bevelOpt.state |= State_Raised;
-        bevelOpt.state &= ~(State_Sunken | State_On);
-        p->save();
-        p->setBrushOrigin(bevelOpt.rect.topLeft());
-        proxy()->drawPrimitive(PE_PanelButtonBevel, &bevelOpt, p, widget);
-        p->restore();
-        if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText))
-            p->fillRect(opt->rect, QBrush(p->background().color(), Qt::Dense5Pattern));
-        break; }
-
-    case CE_RadioButton:
-    case CE_CheckBox:
-        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
-            bool isRadio = (element == CE_RadioButton);
-            QStyleOptionButton subopt = *btn;
-            subopt.rect = subElementRect(isRadio ? SE_RadioButtonIndicator
-                                         : SE_CheckBoxIndicator, btn, widget);
-            proxy()->drawPrimitive(isRadio ? PE_IndicatorRadioButton : PE_IndicatorCheckBox,
-                          &subopt, p, widget);
-            subopt.rect = subElementRect(isRadio ? SE_RadioButtonContents
-                                         : SE_CheckBoxContents, btn, widget);
-            proxy()->drawControl(isRadio ? CE_RadioButtonLabel : CE_CheckBoxLabel, &subopt, p, widget);
-            if ((btn->state & State_HasFocus) && (!focus || !focus->isVisible())) {
-                QStyleOptionFocusRect fropt;
-                fropt.QStyleOption::operator=(*btn);
-                fropt.rect = subElementRect(isRadio ? SE_RadioButtonFocusRect
-                                            : SE_CheckBoxFocusRect, btn, widget);
-                proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
-            }
-        }
-        break;
-    case CE_PushButton:
-        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
-            proxy()->drawControl(CE_PushButtonBevel, btn, p, widget);
-            QStyleOptionButton subopt = *btn;
-            subopt.rect = subElementRect(SE_PushButtonContents, btn, widget);
-            proxy()->drawControl(CE_PushButtonLabel, &subopt, p, widget);
-            if ((btn->state & State_HasFocus) && (!focus || !focus->isVisible())) {
-                QStyleOptionFocusRect fropt;
-                fropt.QStyleOption::operator=(*btn);
-                fropt.rect = subElementRect(SE_PushButtonFocusRect, btn, widget);
-                proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, p, widget);
-            }
-        }
-        break;
-    case CE_PushButtonBevel:
-        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
-            int diw, x1, y1, x2, y2;
-            p->setPen(opt->palette.foreground().color());
-            p->setBrush(QBrush(opt->palette.button().color(), Qt::NoBrush));
-            diw = proxy()->pixelMetric(PM_ButtonDefaultIndicator);
-            opt->rect.getCoords(&x1, &y1, &x2, &y2);
-            if (btn->features & (QStyleOptionButton::AutoDefaultButton|QStyleOptionButton::DefaultButton)) {
-                x1 += diw;
-                y1 += diw;
-                x2 -= diw;
-                y2 -= diw;
-            }
-            if (btn->features & QStyleOptionButton::DefaultButton) {
-                if (diw == 0) {
-                    QPolygon a;
-                    a.setPoints(9,
-                                x1, y1, x2, y1, x2, y2, x1, y2, x1, y1+1,
-                                x2-1, y1+1, x2-1, y2-1, x1+1, y2-1, x1+1, y1+1);
-                    p->setPen(opt->palette.shadow().color());
-                    p->drawPolygon(a);
-                    x1 += 2;
-                    y1 += 2;
-                    x2 -= 2;
-                    y2 -= 2;
-                } else {
-                    qDrawShadePanel(p, opt->rect.adjusted(1, 1, -1, -1), opt->palette, true);
-                }
-            }
-            if (!(btn->features & QStyleOptionButton::Flat) ||
-                (btn->state & (State_Sunken | State_On))) {
-                QStyleOptionButton newOpt = *btn;
-                newOpt.rect = QRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
-                p->setBrushOrigin(p->brushOrigin());
-                proxy()->drawPrimitive(PE_PanelButtonCommand, &newOpt, p, widget);
-            }
-            if (btn->features & QStyleOptionButton::HasMenu) {
-                int mbi = proxy()->pixelMetric(PM_MenuButtonIndicator, btn, widget);
-                QRect ir = btn->rect;
-                QStyleOptionButton newBtn = *btn;
-                newBtn.rect = QRect(ir.right() - mbi - 3, ir.y() + 4,  mbi, ir.height() - 8);
-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, p, widget);
-            }
-            break;
-        }
-
-#ifndef QT_NO_TABBAR
-    case CE_TabBarTabShape:
-        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(opt)) {
-            const int default_frame = proxy()->pixelMetric(PM_DefaultFrameWidth, tab, widget);
-            const int frame_offset =  (default_frame > 1) ? 1 : 0;
-
-            if (tab->shape == QTabBar::RoundedNorth || tab->shape == QTabBar::RoundedEast ||
-                tab->shape == QTabBar::RoundedSouth || tab->shape == QTabBar::RoundedWest) {
-                p->save();
-                QRect tabRect = opt->rect;
-                QColor tabLight = opt->palette.light().color();
-                QColor tabDark = opt->palette.dark().color();
-
-                p->fillRect(opt->rect.adjusted(default_frame, default_frame,
-                                               -default_frame, -default_frame),
-                                               tab->palette.background());
-
-                if(tab->shape == QTabBar::RoundedWest) {
-                    tabDark = opt->palette.light().color();
-                    tabLight = opt->palette.dark().color();
-                    tabRect = QRect(0, 0, tabRect.height(), tabRect.width());
-                    p->translate(opt->rect.left(), opt->rect.bottom());
-                    p->rotate(-90);
-                } else if(tab->shape == QTabBar::RoundedSouth) {
-                    tabDark = opt->palette.light().color();
-                    tabLight = opt->palette.dark().color();
-                    tabRect = QRect(0, 0, tabRect.width(), tabRect.height());
-                    p->translate(opt->rect.right(), opt->rect.bottom());
-                    p->rotate(180);
-                } else if(tab->shape == QTabBar::RoundedEast) {
-                    tabRect = QRect(0, 0, tabRect.height(), tabRect.width());
-                    p->translate(opt->rect.right(), opt->rect.top());
-                    p->rotate(90);
-                }
-
-                if (default_frame > 1) {
-                    p->setPen(tabLight);
-                    p->drawLine(tabRect.left(), tabRect.bottom(),
-                                tabRect.right(), tabRect.bottom());
-                    p->setPen(tabLight);
-                    p->drawLine(tabRect.left(), tabRect.bottom()-1,
-                                tabRect.right(), tabRect.bottom()-1);
-                    if (tabRect.left() == 0)
-                        p->drawPoint(tabRect.bottomLeft());
-                } else {
-                    p->setPen(tabLight);
-                    p->drawLine(tabRect.left(), tabRect.bottom(),
-                                tabRect.right(), tabRect.bottom());
-                }
-
-                if (opt->state & State_Selected) {
-                    p->fillRect(QRect(tabRect.left()+1, tabRect.bottom()-frame_offset,
-                                      tabRect.width()-3, 2),
-                                tab->palette.brush(QPalette::Active, QPalette::Background));
-                    p->setPen(tab->palette.background().color());
-                    p->drawLine(tabRect.left()+1, tabRect.bottom(),
-                                tabRect.left()+1, tabRect.top()+2);
-                    p->setPen(tabLight);
-                } else {
-                    p->setPen(tabLight);
-                }
-                p->drawLine(tabRect.left(), tabRect.bottom()-1,
-                            tabRect.left(), tabRect.top() + 2);
-                p->drawPoint(tabRect.left()+1, tabRect.top() + 1);
-                p->drawLine(tabRect.left()+2, tabRect.top(),
-                            tabRect.right() - 2, tabRect.top());
-                p->drawPoint(tabRect.left(), tabRect.bottom());
-
-                if (default_frame > 1) {
-                    p->drawLine(tabRect.left()+1, tabRect.bottom(),
-                                tabRect.left()+1, tabRect.top() + 2);
-                    p->drawLine(tabRect.left()+2, tabRect.top()+1,
-                                tabRect.right() - 2, tabRect.top()+1);
-                }
-
-                p->setPen(tabDark);
-                p->drawLine(tabRect.right() - 1, tabRect.top() + 2,
-                            tabRect.right() - 1, tabRect.bottom() - 1 +
-                            ((opt->state & State_Selected) ? frame_offset : -frame_offset));
-                if (default_frame > 1) {
-                    p->drawPoint(tabRect.right() - 1, tabRect.top() + 1);
-                    p->drawLine(tabRect.right(), tabRect.top() + 2, tabRect.right(),
-                                tabRect.bottom() -
-                                ((opt->state & State_Selected) ?
-                                 ((tab->position == QStyleOptionTab::End) ? 0:1):1+frame_offset));
-                    p->drawPoint(tabRect.right() - 1, tabRect.top() + 1);
-                }
-                p->restore();
-            } else {
-                QCommonStyle::drawControl(element, opt, p, widget);
-            }
-            break; }
-#endif // QT_NO_TABBAR
-    case CE_ProgressBarGroove:
-        qDrawShadePanel(p, opt->rect, opt->palette, true, 2);
-        break;
-
-    case CE_ProgressBarLabel:
-        if (const QStyleOptionProgressBar *pb = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
-            QTransform oldMatrix = p->transform();
-            QRect rect = pb->rect;
-            bool vertical = false;
-            bool invert = false;
-            bool bottomToTop = false;
-            if (const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(opt)) {
-                vertical = (pb2->orientation == Qt::Vertical);
-                invert = pb2->invertedAppearance;
-                bottomToTop = pb2->bottomToTop;
-            }
-            if (vertical) {
-                QTransform m;
-                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
-                if (bottomToTop) {
-                    m.translate(0.0, rect.width());
-                    m.rotate(-90);
-                } else {
-                    m.translate(rect.height(), 0.0);
-                    m.rotate(90);
-                }
-                p->setTransform(m, true);
-            }
-            const int unit_width = proxy()->pixelMetric(PM_ProgressBarChunkWidth, opt, widget);
-            int u = rect.width() / unit_width;
-            int p_v = pb->progress - pb->minimum;
-            int t_s = qMax(0, pb->maximum - pb->minimum);
-            if (u > 0 && pb->progress >= INT_MAX / u && t_s >= u) {
-                // scale down to something usable.
-                p_v /= u;
-                t_s /= u;
-            }
-            if (pb->textVisible && t_s) {
-                int nu = (u * p_v + t_s/2) / t_s;
-                int x = unit_width * nu;
-                QRect left(rect.x(), rect.y(), x, rect.height());
-                QRect right(rect.x() + x, rect.y(), rect.width() - x, rect.height());
-                Qt::LayoutDirection dir;
-                dir = vertical ? (bottomToTop ? Qt::LeftToRight : Qt::RightToLeft) : pb->direction;
-                if (invert)
-                    dir = (dir == Qt::LeftToRight) ? Qt::RightToLeft : Qt::LeftToRight;
-                const QRect highlighted = visualRect(dir, rect, left);
-                const QRect background = visualRect(dir, rect, right);
-                p->setPen(opt->palette.highlightedText().color());
-                p->setClipRect(highlighted);
-                p->drawText(rect, Qt::AlignCenter | Qt::TextSingleLine, pb->text);
-
-                if (pb->progress != pb->maximum) {
-                    p->setClipRect(background);
-                    p->setPen(opt->palette.highlight().color());
-                    p->drawText(rect, Qt::AlignCenter | Qt::TextSingleLine, pb->text);
-                }
-            }
-            p->setTransform(oldMatrix, false);
-            break;
-        }
-
-    case CE_MenuTearoff: {
-        if(opt->state & State_Selected) {
-            if(pixelMetric(PM_MenuPanelWidth, opt, widget) > 1)
-                qDrawShadePanel(p, opt->rect.x(), opt->rect.y(), opt->rect.width(),
-                                opt->rect.height(), opt->palette, false, motifItemFrame,
-                                &opt->palette.brush(QPalette::Button));
-            else
-                qDrawShadePanel(p, opt->rect.x()+1, opt->rect.y()+1, opt->rect.width()-2,
-                                opt->rect.height()-2, opt->palette, true, 1, &opt->palette.brush(QPalette::Button));
-        } else {
-            p->fillRect(opt->rect, opt->palette.brush(QPalette::Button));
-        }
-        p->setPen(QPen(opt->palette.dark().color(), 1, Qt::DashLine));
-        p->drawLine(opt->rect.x()+2, opt->rect.y()+opt->rect.height()/2-1, opt->rect.x()+opt->rect.width()-4,
-                    opt->rect.y()+opt->rect.height()/2-1);
-        p->setPen(QPen(opt->palette.light().color(), 1, Qt::DashLine));
-        p->drawLine(opt->rect.x()+2, opt->rect.y()+opt->rect.height()/2, opt->rect.x()+opt->rect.width()-4,
-                    opt->rect.y()+opt->rect.height()/2);
-        break; }
-
-    case CE_MenuItem:
-        if (const QStyleOptionMenuItem *menuitem = qstyleoption_cast<const QStyleOptionMenuItem *>(opt)) {
-            int maxpmw = menuitem->maxIconWidth;
-            if(menuitem->menuHasCheckableItems)
-                maxpmw = qMax(maxpmw, motifCheckMarkSpace);
-
-            int x, y, w, h;
-            opt->rect.getRect(&x, &y, &w, &h);
-
-            if (menuitem->menuItemType == QStyleOptionMenuItem::Separator) {  // draw separator
-                int textWidth = 0;
-                if (!menuitem->text.isEmpty()) {
-                    QFont oldFont = p->font();
-                    p->setFont(menuitem->font);
-                    p->fillRect(x, y, w, h, opt->palette.brush(QPalette::Button));
-                    proxy()->drawItemText(p, menuitem->rect.adjusted(10, 0, -5, 0), Qt::AlignLeft | Qt::AlignVCenter,
-                                 menuitem->palette, menuitem->state & State_Enabled, menuitem->text,
-                                 QPalette::Text);
-                    textWidth = menuitem->fontMetrics.width(menuitem->text) + 10;
-                    y += menuitem->fontMetrics.height() / 2;
-                    p->setFont(oldFont);
-                }
-                p->setPen(opt->palette.dark().color());
-                p->drawLine(x, y, x + 5, y);
-                p->drawLine(x + 5 + textWidth, y, x+w, y);
-                p->setPen(opt->palette.light().color());
-                p->drawLine(x, y + 1, x + 5, y + 1);
-                p->drawLine(x + 5 + textWidth, y + 1, x+w, y + 1);
-                return;
-            }
-
-            int pw = motifItemFrame;
-            if((opt->state & State_Selected) && (opt->state & State_Enabled)) {  // active item frame
-                if(pixelMetric(PM_MenuPanelWidth, opt) > 1)
-                    qDrawShadePanel(p, x, y, w, h, opt->palette, false, pw,
-                                    &opt->palette.brush(QPalette::Button));
-                else
-                    qDrawShadePanel(p, x+1, y+1, w-2, h-2, opt->palette, true, 1,
-                                    &opt->palette.brush(QPalette::Button));
-            } else  {                               // incognito frame
-                p->fillRect(x, y, w, h, opt->palette.brush(QPalette::Button));
-            }
-
-            QRect vrect = visualRect(opt->direction, opt->rect,
-                                     QRect(x+motifItemFrame, y+motifItemFrame, maxpmw,
-                                           h-2*motifItemFrame));
-            int xvis = vrect.x();
-            if (menuitem->checked) {
-                if(!menuitem->icon.isNull())
-                    qDrawShadePanel(p, xvis, y+motifItemFrame, maxpmw, h-2*motifItemFrame,
-                                    opt->palette, true, 1, &opt->palette.brush(QPalette::Midlight));
-            } else if (!(opt->state & State_Selected)) {
-                p->fillRect(xvis, y+motifItemFrame, maxpmw, h-2*motifItemFrame,
-                            opt->palette.brush(QPalette::Button));
-            }
-
-            if(!menuitem->icon.isNull()) {              // draw icon
-                QIcon::Mode mode = QIcon::Normal; // no disabled icons in Motif
-                if ((opt->state & State_Selected) && !!(opt->state & State_Enabled))
-                    mode = QIcon::Active;
-                QPixmap pixmap;
-                if (menuitem->checkType != QStyleOptionMenuItem::NotCheckable && menuitem->checked)
-                    pixmap = menuitem->icon.pixmap(pixelMetric(PM_SmallIconSize, opt, widget), mode, QIcon::On);
-                else
-                    pixmap = menuitem->icon.pixmap(pixelMetric(PM_SmallIconSize, opt, widget), mode);
-
-                int pixw = pixmap.width();
-                int pixh = pixmap.height();
-                QRect pmr(0, 0, pixw, pixh);
-                pmr.moveCenter(vrect.center());
-                p->setPen(opt->palette.text().color());
-                p->drawPixmap(pmr.topLeft(), pixmap);
-
-            } else  if (menuitem->checkType != QStyleOptionMenuItem::NotCheckable) {  // just "checking"...
-                int mh = h - 2*motifItemFrame;
-
-                QStyleOptionButton newMenuItem;
-                newMenuItem.state = menuitem->checked ? State_On : State_None;
-                if (opt->state & State_Enabled) {
-                    newMenuItem.state |= State_Enabled;
-                    if (menuitem->state & State_Sunken)
-                        newMenuItem.state |= State_Sunken;
-                }
-                if (menuitem->checkType & QStyleOptionMenuItem::Exclusive) {
-                    newMenuItem.rect.setRect(xvis + 2, y + motifItemFrame + mh / 4, 11, 11);
-                    proxy()->drawPrimitive(PE_IndicatorRadioButton, &newMenuItem, p, widget);
-                } else {
-                    newMenuItem.rect.setRect(xvis + 5, y + motifItemFrame + mh / 4, 9, 9);
-                    proxy()->drawPrimitive(PE_IndicatorCheckBox, &newMenuItem, p, widget);
-                }
-            }
-
-            p->setPen(opt->palette.buttonText().color());
-
-            QColor discol;
-            if (!(opt->state & State_Enabled)) {
-                discol = opt->palette.text().color();
-                p->setPen(discol);
-            }
-
-            int xm = motifItemFrame + maxpmw + motifItemHMargin;
-
-            vrect = visualRect(opt->direction, opt->rect,
-                               QRect(x+xm, y+motifItemVMargin, w-xm-menuitem->tabWidth,
-                                     h-2*motifItemVMargin));
-            xvis = vrect.x();
-
-            QString s = menuitem->text;
-            if (!s.isNull()) {                        // draw text
-                int t = s.indexOf(QLatin1Char('\t'));
-                int m = motifItemVMargin;
-                int text_flags = Qt::AlignVCenter|Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
-                text_flags |= Qt::AlignLeft;
-                QFont oldFont = p->font();
-                p->setFont(menuitem->font);
-                if (t >= 0) {                         // draw tab text
-                    QRect vr = visualRect(opt->direction, opt->rect,
-                                          QRect(x+w-menuitem->tabWidth-motifItemHMargin-motifItemFrame,
-                                                y+motifItemVMargin, menuitem->tabWidth,
-                                                h-2*motifItemVMargin));
-                    int xv = vr.x();
-                    QRect tr(xv, y+m, menuitem->tabWidth, h-2*m);
-                    p->drawText(tr, text_flags, s.mid(t+1));
-                    if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText))
-                        p->fillRect(tr, QBrush(p->background().color(), Qt::Dense5Pattern));
-                    s = s.left(t);
-                }
-                QRect tr(xvis, y+m, w - xm - menuitem->tabWidth + 1, h-2*m);
-                p->drawText(tr, text_flags, s.left(t));
-                p->setFont(oldFont);
-                if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText))
-                    p->fillRect(tr, QBrush(p->background().color(), Qt::Dense5Pattern));
-            }
-            if (menuitem->menuItemType == QStyleOptionMenuItem::SubMenu) {           // draw sub menu arrow
-                int dim = (h-2*motifItemFrame) / 2;
-                QStyle::PrimitiveElement arrow = (opt->direction == Qt::RightToLeft ? PE_IndicatorArrowLeft : PE_IndicatorArrowRight);
-                QStyleOption arrowOpt = *opt;
-                arrowOpt.rect = visualRect(opt->direction, opt->rect,
-                                           QRect(x+w - motifArrowHMargin - motifItemFrame - dim,
-                                                 y+h/2-dim/2, dim, dim));
-                if ((opt->state & State_Selected))
-                    arrowOpt.state = (State_Sunken | ((opt->state & State_Enabled) ? State_Enabled : State_None));
-                else
-                    arrowOpt.state = ((opt->state & State_Enabled) ? State_Enabled : State_None);
-                proxy()->drawPrimitive(arrow, &arrowOpt, p, widget);
-            }
-            break; }
-
-    case CE_MenuBarItem:
-        if (opt->state & State_Selected)  // active item
-            qDrawShadePanel(p, opt->rect, opt->palette, false, motifItemFrame,
-                            &opt->palette.brush(QPalette::Button));
-        else  // other item
-            p->fillRect(opt->rect, opt->palette.brush(QPalette::Button));
-        QCommonStyle::drawControl(element, opt, p, widget);
-        break;
-
-    case CE_HeaderSection:
-        p->save();
-        p->setBrushOrigin(opt->rect.topLeft());
-        qDrawShadePanel(p, opt->rect, opt->palette, bool(opt->state & (State_Sunken|State_On)),
-                        proxy()->pixelMetric(PM_DefaultFrameWidth),
-                        &opt->palette.brush((opt->state & State_Sunken) ? QPalette::Mid : QPalette::Button));
-        p->restore();
-        break;
-    case CE_RubberBand: {
-        QPixmap tiledPixmap(16, 16);
-        QPainter pixmapPainter(&tiledPixmap);
-        pixmapPainter.setPen(Qt::NoPen);
-        pixmapPainter.setBrush(Qt::Dense4Pattern);
-        pixmapPainter.setBackground(QBrush(opt->palette.base()));
-        pixmapPainter.setBackgroundMode(Qt::OpaqueMode);
-        pixmapPainter.drawRect(0, 0, tiledPixmap.width(), tiledPixmap.height());
-        pixmapPainter.end();
-        // ### workaround for borked XRENDER
-        tiledPixmap = QPixmap::fromImage(tiledPixmap.toImage());
-
-        p->save();
-        QRect r = opt->rect;
-        QStyleHintReturnMask mask;
-        if (styleHint(QStyle::SH_RubberBand_Mask, opt, widget, &mask))
-            p->setClipRegion(mask.region);
-        p->drawTiledPixmap(r.x(), r.y(), r.width(), r.height(), tiledPixmap);
-        p->restore();
-        }
-        break;
-#ifndef QT_NO_PROGRESSBAR
-    case CE_ProgressBarContents:
-        if (const QStyleOptionProgressBar *pb = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
-            QRect rect = pb->rect;
-            bool vertical = false;
-            bool inverted = false;
-
-            // Get extra style options if version 2
-            const QStyleOptionProgressBarV2 *pb2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(opt);
-            if (pb2) {
-                vertical = (pb2->orientation == Qt::Vertical);
-                inverted = pb2->invertedAppearance;
-            }
-
-            QTransform m;
-            if (vertical) {
-                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
-                m.rotate(90);
-                m.translate(0, -(rect.height() + rect.y()*2));
-            }
-
-            QPalette pal2 = pb->palette;
-            // Correct the highlight color if it is the same as the background
-            if (pal2.highlight() == pal2.background())
-                pal2.setColor(QPalette::Highlight, pb->palette.color(QPalette::Active,
-                                                                     QPalette::Highlight));
-            bool reverse = ((!vertical && (pb->direction == Qt::RightToLeft)) || vertical);
-            if (inverted)
-                reverse = !reverse;
-            int w = rect.width();
-            if (pb->minimum == 0 && pb->maximum == 0) {
-                QRect progressBar;
-                Q_D(const QMotifStyle);
-                 // draw busy indicator
-                 int x = (d->animateStep*8)% (w * 2);
-                 if (x > w)
-                     x = 2 * w - x;
-                 x = reverse ? rect.right() - x : x + rect.x();
-                 p->setTransform(m, true);
-                 p->setPen(QPen(pal2.highlight().color(), 4));
-                 p->drawLine(x, rect.y(), x, rect.height());
-
-            } else
-                QCommonStyle::drawControl(element, opt, p, widget);
-        }
-        break;
-#endif // QT_NO_PROGRESSBAR
-    default:
-        QCommonStyle::drawControl(element, opt, p, widget);
-        break; }
-}
-
-static int get_combo_extra_width(int h, int w, int *return_awh=0)
-{
-    int awh,
-        tmp;
-    if (h < 8) {
-        awh = 6;
-    } else if (h < 14) {
-        awh = h - 2;
-    } else {
-        awh = h/2;
-    }
-    tmp = (awh * 3) / 2;
-    if (tmp > w / 2) {
-        awh = w / 2 - 3;
-        tmp = w / 2 + 3;
-    }
-
-    if (return_awh)
-        *return_awh = awh;
-
-    return tmp;
-}
-
-static void get_combo_parameters(const QRect &r,
-                                 int &ew, int &awh, int &ax,
-                                 int &ay, int &sh, int &dh,
-                                 int &sy)
-{
-    ew = get_combo_extra_width(r.height(), r.width(), &awh);
-
-    sh = (awh+3)/4;
-    if (sh < 3)
-        sh = 3;
-    dh = sh/2 + 1;
-
-    ay = r.y() + (r.height()-awh-sh-dh)/2;
-    if (ay < 0) {
-        //panic mode
-        ay = 0;
-        sy = r.height();
-    } else {
-        sy = ay+awh+dh;
-    }
-    ax = r.x() + r.width() - ew;
-    ax  += (ew-awh)/2;
-}
-
-/*!
-  \reimp
-*/
-void QMotifStyle::drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
-                                     const QWidget *widget) const
-{
-    switch (cc) {
-    case CC_ToolButton:
-        if (const QStyleOptionToolButton *toolbutton
-            = qstyleoption_cast<const QStyleOptionToolButton *>(opt)) {
-            QRect button, menuarea;
-            button = proxy()->subControlRect(cc, toolbutton, SC_ToolButton, widget);
-            menuarea = proxy()->subControlRect(cc, toolbutton, SC_ToolButtonMenu, widget);
-
-            State bflags = toolbutton->state & ~State_Sunken;
-            if (bflags & State_AutoRaise) {
-                if (!(bflags & State_MouseOver) || !(bflags & State_Enabled)) {
-                    bflags &= ~State_Raised;
-                }
-            }
-            State mflags = bflags;
-            if (toolbutton->state & State_Sunken) {
-                if (toolbutton->activeSubControls & SC_ToolButton)
-                    bflags |= State_Sunken;
-                mflags |= State_Sunken;
-            }
-
-            QStyleOption tool(0);
-            tool.palette = toolbutton->palette;
-            if (toolbutton->subControls & SC_ToolButton) {
-                if (bflags & (State_Sunken | State_On | State_Raised)) {
-                    tool.rect = button;
-                    tool.state = bflags;
-                    proxy()->drawPrimitive(PE_PanelButtonTool, &tool, p, widget);
-                }
-            }
-
-            if ((toolbutton->state & State_HasFocus) && (!focus || !focus->isVisible())) {
-                QStyleOptionFocusRect fr;
-                fr.QStyleOption::operator=(*toolbutton);
-                fr.rect = toolbutton->rect.adjusted(3, 3, -3, -3);
-                proxy()->drawPrimitive(PE_FrameFocusRect, &fr, p, widget);
-            }
-            QStyleOptionToolButton label = *toolbutton;
-            label.state = bflags;
-            int fw = proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
-            label.rect = button.adjusted(fw, fw, -fw, -fw);
-            proxy()->drawControl(CE_ToolButtonLabel, &label, p, widget);
-
-            if (toolbutton->subControls & SC_ToolButtonMenu) {
-                tool.rect = menuarea;
-                tool.state = mflags;
-                if (mflags & (State_Sunken | State_On | State_Raised))
-                    proxy()->drawPrimitive(PE_IndicatorButtonDropDown, &tool, p, widget);
-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &tool, p, widget);
-            } else if (toolbutton->features & QStyleOptionToolButton::HasMenu) {
-                int mbi = proxy()->pixelMetric(PM_MenuButtonIndicator, toolbutton, widget);
-                QRect ir = toolbutton->rect;
-                QStyleOptionToolButton newBtn = *toolbutton;
-                newBtn.rect = QRect(ir.right() + 5 - mbi, ir.height() - mbi + 4, mbi - 6, mbi - 6);
-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &newBtn, p, widget);
-            }
-        }
-        break;
-#ifndef QT_NO_SPINBOX
-    case CC_SpinBox:
-        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(opt)) {
-            QStyleOptionSpinBox copy = *spinbox;
-            PrimitiveElement pe;
-
-            if (spinbox->frame && (spinbox->subControls & SC_SpinBoxFrame)) {
-                QRect r = proxy()->subControlRect(CC_SpinBox, spinbox, SC_SpinBoxFrame, widget);
-                qDrawShadePanel(p, r, opt->palette, false, proxy()->pixelMetric(PM_SpinBoxFrameWidth));
-
-                int fw = proxy()->pixelMetric(QStyle::PM_DefaultFrameWidth);
-                r = proxy()->subControlRect(CC_SpinBox, spinbox, SC_SpinBoxEditField, widget).adjusted(-fw,-fw,fw,fw);
-                QStyleOptionFrame lineOpt;
-                lineOpt.QStyleOption::operator=(*opt);
-                lineOpt.rect = r;
-                lineOpt.lineWidth = fw;
-                lineOpt.midLineWidth = 0;
-                lineOpt.state |= QStyle::State_Sunken;
-                proxy()->drawPrimitive(QStyle::PE_FrameLineEdit, &lineOpt, p, widget);
-            }
-
-            if (spinbox->subControls & SC_SpinBoxUp) {
-                copy.subControls = SC_SpinBoxUp;
-                QPalette pal2 = spinbox->palette;
-                if (!(spinbox->stepEnabled & QAbstractSpinBox::StepUpEnabled)) {
-                    pal2.setCurrentColorGroup(QPalette::Disabled);
-                    copy.state &= ~State_Enabled;
-                }
-
-                copy.palette = pal2;
-
-                if (spinbox->activeSubControls == SC_SpinBoxUp && (spinbox->state & State_Sunken)) {
-                    copy.state |= State_On;
-                    copy.state |= State_Sunken;
-                } else {
-                    copy.state |= State_Raised;
-                    copy.state &= ~State_Sunken;
-                }
-                pe = (spinbox->buttonSymbols == QAbstractSpinBox::PlusMinus ? PE_IndicatorSpinPlus
-                      : PE_IndicatorSpinUp);
-
-                copy.rect = proxy()->subControlRect(CC_SpinBox, spinbox, SC_SpinBoxUp, widget);
-                proxy()->drawPrimitive(pe, &copy, p, widget);
-            }
-
-            if (spinbox->subControls & SC_SpinBoxDown) {
-                copy.subControls = SC_SpinBoxDown;
-                copy.state = spinbox->state;
-                QPalette pal2 = spinbox->palette;
-                if (!(spinbox->stepEnabled & QAbstractSpinBox::StepDownEnabled)) {
-                    pal2.setCurrentColorGroup(QPalette::Disabled);
-                    copy.state &= ~State_Enabled;
-                }
-                copy.palette = pal2;
-
-                if (spinbox->activeSubControls == SC_SpinBoxDown && (spinbox->state & State_Sunken)) {
-                    copy.state |= State_On;
-                    copy.state |= State_Sunken;
-                } else {
-                    copy.state |= State_Raised;
-                    copy.state &= ~State_Sunken;
-                }
-                pe = (spinbox->buttonSymbols == QAbstractSpinBox::PlusMinus ? PE_IndicatorSpinMinus
-                      : PE_IndicatorSpinDown);
-
-                copy.rect = proxy()->subControlRect(CC_SpinBox, spinbox, SC_SpinBoxDown, widget);
-                proxy()->drawPrimitive(pe, &copy, p, widget);
-            }
-        }
-        break;
-#endif // QT_NO_SPINBOX
-#ifndef QT_NO_SLIDER
-    case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            QRect groove = proxy()->subControlRect(CC_Slider, opt, SC_SliderGroove, widget),
-                  handle = proxy()->subControlRect(CC_Slider, opt, SC_SliderHandle, widget);
-
-            if ((opt->subControls & SC_SliderGroove) && groove.isValid()) {
-                qDrawShadePanel(p, groove, opt->palette, true, proxy()->pixelMetric(PM_DefaultFrameWidth),
-                                &opt->palette.brush((opt->state & State_Enabled) ? QPalette::Mid : QPalette::Window));
-                if ((opt->state & State_HasFocus) && (!focus || !focus->isVisible())) {
-                    QStyleOption focusOpt = *opt;
-                    focusOpt.rect = subElementRect(SE_SliderFocusRect, opt, widget);
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &focusOpt, p, widget);
-                }
-            }
-
-            if ((opt->subControls & SC_SliderHandle) && handle.isValid()) {
-                QStyleOption bevelOpt = *opt;
-                bevelOpt.state = (opt->state | State_Raised) & ~State_Sunken;
-                bevelOpt.rect = handle;
-                p->save();
-                p->setBrushOrigin(bevelOpt.rect.topLeft());
-                proxy()->drawPrimitive(PE_PanelButtonBevel, &bevelOpt, p, widget);
-                p->restore();
-
-                if (slider->orientation == Qt::Horizontal) {
-                    int mid = handle.x() + handle.width() / 2;
-                    qDrawShadeLine(p, mid, handle.y(), mid, handle.y() + handle.height() - 2,
-                                   opt->palette, true, 1);
-                } else {
-                    int mid = handle.y() + handle.height() / 2;
-                    qDrawShadeLine(p, handle.x(), mid, handle.x() + handle.width() - 2, mid, opt->palette,
-                                   true, 1);
-                }
-                if (!(opt->state & State_Enabled) && proxy()->styleHint(SH_DitherDisabledText))
-                    p->fillRect(handle, QBrush(p->background().color(), Qt::Dense5Pattern));
-            }
-
-            if (slider->subControls & SC_SliderTickmarks) {
-                QStyleOptionSlider tmpSlider = *slider;
-                tmpSlider.subControls = SC_SliderTickmarks;
-                int frameWidth = proxy()->pixelMetric(PM_DefaultFrameWidth);
-                tmpSlider.rect.translate(frameWidth - 1, 0);
-                QCommonStyle::drawComplexControl(cc, &tmpSlider, p, widget);
-            }
-        }
-        break;
-#endif // QT_NO_SLIDER
-    case CC_ComboBox:
-        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(opt)) {
-            if (opt->subControls & SC_ComboBoxArrow) {
-                int awh, ax, ay, sh, sy, dh, ew;
-                int fw = cb->frame ? proxy()->pixelMetric(PM_ComboBoxFrameWidth, opt, widget) : 0;
-
-                if (cb->frame) {
-                    QStyleOptionButton btn;
-                    btn.QStyleOption::operator=(*cb);
-                    btn.state |= QStyle::State_Raised;
-                    proxy()->drawPrimitive(PE_PanelButtonCommand, &btn, p, widget);
-                } else {
-                    p->fillRect(opt->rect, opt->palette.brush(QPalette::Button));
-                }
-
-                QRect tr = opt->rect;
-                tr.adjust(fw, fw, -fw, -fw);
-                get_combo_parameters(tr, ew, awh, ax, ay, sh, dh, sy);
-
-                QRect ar = QStyle::visualRect(opt->direction, opt->rect, QRect(ax,ay,awh,awh));
-
-                QStyleOption arrowOpt = *opt;
-                arrowOpt.rect = ar;
-                arrowOpt.state |= State_Enabled;
-                proxy()->drawPrimitive(PE_IndicatorArrowDown, &arrowOpt, p, widget);
-
-
-                // draws the shaded line under the arrow
-                p->setPen(opt->palette.light().color());
-                p->drawLine(ar.x(), sy, ar.x()+awh-1, sy);
-                p->drawLine(ar.x(), sy, ar.x(), sy+sh-1);
-                p->setPen(opt->palette.dark().color());
-                p->drawLine(ar.x()+1, sy+sh-1, ar.x()+awh-1, sy+sh-1);
-                p->drawLine(ar.x()+awh-1, sy+1, ar.x()+awh-1, sy+sh-1);
-
-                if ((cb->state & State_HasFocus) && (!focus || !focus->isVisible())) {
-                    QStyleOptionFocusRect focus;
-                    focus.QStyleOption::operator=(*opt);
-                    focus.rect = subElementRect(SE_ComboBoxFocusRect, opt, widget);
-                    focus.backgroundColor = opt->palette.button().color();
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &focus, p, widget);
-                }
-            }
-
-            if (opt->subControls & SC_ComboBoxEditField) {
-                if (cb->editable) {
-                    QRect er = proxy()->subControlRect(CC_ComboBox, opt, SC_ComboBoxEditField, widget);
-                    er.adjust(-1, -1, 1, 1);
-                    qDrawShadePanel(p, er, opt->palette, true, 1,
-                                    &opt->palette.brush(QPalette::Base));
-                }
-            }
-            p->setPen(opt->palette.buttonText().color());
-        }
-        break;
-
-#ifndef QT_NO_SCROLLBAR
-    case CC_ScrollBar: {
-        if (opt->subControls & SC_ScrollBarGroove)
-            qDrawShadePanel(p, opt->rect, opt->palette, true,
-                            proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget),
-                            &opt->palette.brush((opt->state & State_Enabled) ? QPalette::Mid : QPalette::Window));
-
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            QStyleOptionSlider newScrollbar = *scrollbar;
-            if (scrollbar->minimum == scrollbar->maximum)
-                newScrollbar.state |= State_Enabled; // make sure that the slider is drawn.
-            QCommonStyle::drawComplexControl(cc, &newScrollbar, p, widget);
-        }
-        break; }
-#endif
-
-    default:
-        QCommonStyle::drawComplexControl(cc, opt, p, widget);
-        break;
-    }
-}
-
-
-/*! \reimp */
-int QMotifStyle::pixelMetric(PixelMetric pm, const QStyleOption *opt,
-                             const QWidget *widget) const
-{
-    int ret = 0;
-
-    switch(pm) {
-    case PM_ButtonDefaultIndicator:
-        ret = 5;
-        break;
-
-    case PM_CheckBoxLabelSpacing:
-    case PM_RadioButtonLabelSpacing:
-        ret = 10;
-        break;
-
-    case PM_ToolBarFrameWidth:
-        ret = proxy()->pixelMetric(PM_DefaultFrameWidth);
-        break;
-
-    case PM_ToolBarItemMargin:
-        ret = 1;
-        break;
-
-    case PM_ButtonShiftHorizontal:
-    case PM_ButtonShiftVertical:
-        ret = 0;
-        break;
-
-    case PM_SplitterWidth:
-        ret = qMax(10, QApplication::globalStrut().width());
-        break;
-
-    case PM_SliderLength:
-        ret = 30;
-        break;
-
-    case PM_SliderThickness:
-        ret = 16 + 4 * proxy()->pixelMetric(PM_DefaultFrameWidth);
-        break;
-#ifndef QT_NO_SLIDER
-    case PM_SliderControlThickness:
-        if (const QStyleOptionSlider *sl = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            int space = (sl->orientation == Qt::Horizontal) ? sl->rect.height() : sl->rect.width();
-            int ticks = sl->tickPosition;
-            int n = 0;
-            if (ticks & QSlider::TicksAbove)
-                n++;
-            if (ticks & QSlider::TicksBelow)
-                n++;
-            if (!n) {
-                ret = space;
-                break;
-            }
-
-            int thick = 6;        // Magic constant to get 5 + 16 + 5
-
-            space -= thick;
-            //### the two sides may be unequal in size
-            if (space > 0)
-                thick += (space * 2) / (n + 2);
-            ret = thick;
-        }
-        break;
-
-    case PM_SliderSpaceAvailable:
-        if (const QStyleOptionSlider *sl = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            if (sl->orientation == Qt::Horizontal)
-                ret = sl->rect.width() - proxy()->pixelMetric(PM_SliderLength, opt, widget) - 2 * proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
-            else
-                ret = sl->rect.height() - proxy()->pixelMetric(PM_SliderLength, opt, widget) - 2 * proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
-        }
-        break;
-#endif // QT_NO_SLIDER
-    case PM_DockWidgetFrameWidth:
-        ret = 2;
-        break;
-
-    case PM_DockWidgetHandleExtent:
-        ret = 9;
-        break;
-
-    case PM_ProgressBarChunkWidth:
-        ret = 1;
-        break;
-
-    case PM_ExclusiveIndicatorWidth:
-    case PM_ExclusiveIndicatorHeight:
-        ret = 13;
-        break;
-
-    case PM_MenuBarHMargin:
-        ret = 2; // really ugly, but Motif
-        break;
-
-    case PM_MenuButtonIndicator:
-        if (!opt)
-            ret = 12;
-        else
-            ret = qMax(12, (opt->rect.height() - 4) / 3);
-        break;
-    default:
-        ret =  QCommonStyle::pixelMetric(pm, opt, widget);
-        break;
-    }
-    return ret;
-}
-
-
-/*!
-  \reimp
-*/
-QRect
-QMotifStyle::subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
-                            SubControl sc, const QWidget *widget) const
-{
-    switch (cc) {
-#ifndef QT_NO_SPINBOX
-    case CC_SpinBox:
-        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(opt)) {
-            int fw = spinbox->frame ? proxy()->pixelMetric(PM_SpinBoxFrameWidth, spinbox, widget) : 0;
-            QSize bs;
-            bs.setHeight(opt->rect.height()/2 - fw);
-            bs.setWidth(qMin(bs.height() * 8 / 5, opt->rect.width() / 4)); // 1.6 -approximate golden mean
-            bs = bs.expandedTo(QApplication::globalStrut());
-            int y = fw + spinbox->rect.y();
-            int x, lx, rx;
-            x = spinbox->rect.x() + opt->rect.width() - fw - bs.width();
-            lx = fw;
-            rx = x - fw * 2;
-            const int margin = spinbox->frame ? 4 : 0;
-            switch (sc) {
-            case SC_SpinBoxUp:
-                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
-                    return QRect();
-                return visualRect(spinbox->direction, spinbox->rect,
-                                  QRect(x, y, bs.width(), bs.height() - 1));
-            case SC_SpinBoxDown:
-                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
-                    return QRect();
-                return visualRect(spinbox->direction, spinbox->rect,
-                                  QRect(x, y + bs.height() + 1, bs.width(), bs.height() - 1));
-            case SC_SpinBoxEditField:
-                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
-                    return visualRect(spinbox->direction, spinbox->rect,
-                                      QRect(lx + margin, y + margin,
-                                            spinbox->rect.width() - 2*fw - 2*margin,
-                                            spinbox->rect.height() - 2*fw - 2*margin));
-
-                return visualRect(spinbox->direction, spinbox->rect,
-                                  QRect(lx + margin, y + margin, rx - margin,
-                                        spinbox->rect.height() - 2*fw - 2 * margin));
-            case SC_SpinBoxFrame:
-                return visualRect(spinbox->direction, spinbox->rect, spinbox->rect);
-            default:
-                break;
-            }
-            break; }
-#endif // QT_NO_SPINBOX
-#ifndef QT_NO_SLIDER
-    case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            if (sc == SC_SliderHandle) {
-                int tickOffset = proxy()->pixelMetric(PM_SliderTickmarkOffset, opt, widget);
-                int thickness = proxy()->pixelMetric(PM_SliderControlThickness, opt, widget);
-                bool horizontal = slider->orientation == Qt::Horizontal;
-                int len = proxy()->pixelMetric(PM_SliderLength, opt, widget);
-                int motifBorder = proxy()->pixelMetric(PM_DefaultFrameWidth);
-                int sliderPos = sliderPositionFromValue(slider->minimum, slider->maximum, slider->sliderPosition,
-                                                        horizontal ? slider->rect.width() - len - 2 * motifBorder
-                                                        : slider->rect.height() - len - 2 * motifBorder,
-                                                        slider->upsideDown);
-                if (horizontal)
-                    return visualRect(slider->direction, slider->rect,
-                                      QRect(sliderPos + motifBorder + slider->rect.left()
-                                            , tickOffset + motifBorder + slider->rect.top()
-                                            , len, thickness - 2 * motifBorder));
-                return visualRect(slider->direction, slider->rect,
-                                  QRect(tickOffset + motifBorder + slider->rect.left()
-                                        , sliderPos + motifBorder + slider->rect.top()
-                                        , thickness - 2 * motifBorder, len));
-            }
-        }
-        break;
-#endif // QT_NO_SLIDER
-#ifndef QT_NO_SCROLLBAR
-    case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollbar = qstyleoption_cast<const QStyleOptionSlider *>(opt)) {
-            int dfw = proxy()->pixelMetric(PM_DefaultFrameWidth);
-            QRect rect =  visualRect(scrollbar->direction, scrollbar->rect,
-                                     QCommonStyle::subControlRect(cc, scrollbar, sc, widget));
-            if (sc == SC_ScrollBarSlider) {
-                if (scrollbar->orientation == Qt::Horizontal)
-                    rect.adjust(-dfw, dfw, dfw, -dfw);
-                else
-                    rect.adjust(dfw, -dfw, -dfw, dfw);
-            } else if (sc != SC_ScrollBarGroove) {
-                if (scrollbar->orientation == Qt::Horizontal)
-                    rect.adjust(0, dfw, 0, -dfw);
-                else
-                    rect.adjust(dfw, 0, -dfw, 0);
-            }
-            return visualRect(scrollbar->direction, scrollbar->rect, rect);
-        }
-        break;
-#endif // QT_NO_SCROLLBAR
-#ifndef QT_NO_COMBOBOX
-    case CC_ComboBox:
-        if (const QStyleOptionComboBox *cb = qstyleoption_cast<const QStyleOptionComboBox *>(opt)) {
-            switch (sc) {
-            case SC_ComboBoxArrow: {
-                int ew, awh, sh, dh, ax, ay, sy;
-                int fw = cb->frame ? proxy()->pixelMetric(PM_ComboBoxFrameWidth, opt, widget) : 0;
-                QRect cr = opt->rect;
-                cr.adjust(fw, fw, -fw, -fw);
-                get_combo_parameters(cr, ew, awh, ax, ay, sh, dh, sy);
-                return visualRect(cb->direction, cb->rect, QRect(QPoint(ax, ay), cr.bottomRight()));
-            }
-
-            case SC_ComboBoxEditField: {
-                int fw = cb->frame ? proxy()->pixelMetric(PM_ComboBoxFrameWidth, opt, widget) : 0;
-                QRect rect = opt->rect;
-                rect.adjust(fw, fw, -fw, -fw);
-                int ew = get_combo_extra_width(rect.height(), rect.width());
-                rect.adjust(1, 1, -1-ew, -1);
-                return visualRect(cb->direction, cb->rect, rect);
-            }
-
-            default:
-                break;
-            }
-        }
-        break;
-#endif // QT_NO_SCROLLBAR
-    default:
-        break;
-    }
-    return QCommonStyle::subControlRect(cc, opt, sc, widget);
-}
-
-/*!
-  \reimp
-*/
-QSize
-QMotifStyle::sizeFromContents(ContentsType ct, const QStyleOption *opt,
-                              const QSize &contentsSize, const QWidget *widget) const
-{
-    QSize sz(contentsSize);
-
-    switch(ct) {
-    case CT_RadioButton:
-    case CT_CheckBox:
-        sz = QCommonStyle::sizeFromContents(ct, opt, contentsSize, widget);
-        sz.rwidth() += motifItemFrame;
-        break;
-
-    case CT_PushButton:
-        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(opt)) {
-            sz = QCommonStyle::sizeFromContents(ct, opt, contentsSize, widget);
-            if (!btn->text.isEmpty() && (btn->features & (QStyleOptionButton::AutoDefaultButton|QStyleOptionButton::DefaultButton)))
-                sz.setWidth(qMax(75, sz.width()));
-            sz += QSize(0, 1); // magical extra pixel
-        }
-        break;
-
-    case CT_MenuBarItem: {
-        if(!sz.isEmpty())
-            sz += QSize(5*motifItemHMargin+1, 2*motifItemVMargin + motifItemFrame);
-        break; }
-
-    case CT_MenuItem:
-        if (const QStyleOptionMenuItem *mi = qstyleoption_cast<const QStyleOptionMenuItem *>(opt)) {
-            sz = QCommonStyle::sizeFromContents(ct, opt, sz, widget);
-            int w = sz.width(), h = sz.height();
-
-            if (mi->menuItemType == QStyleOptionMenuItem::Separator) {
-                w = 10;
-                h = (mi->text.isEmpty()) ? motifSepHeight : mi->fontMetrics.height();
-            }
-
-            // a little bit of border can never harm
-            w += 2*motifItemHMargin + 2*motifItemFrame;
-
-            if (!mi->text.isNull() && mi->text.indexOf(QLatin1Char('\t')) >= 0)
-                // string contains tab
-                w += motifTabSpacing;
-            else if (mi->menuItemType == QStyleOptionMenuItem::SubMenu)
-                // submenu indicator needs some room if we don't have a tab column
-                w += motifArrowHMargin + 4*motifItemFrame;
-
-            int checkColumn = mi->maxIconWidth;
-            if (mi->menuHasCheckableItems)
-                checkColumn = qMax(checkColumn, motifCheckMarkSpace);
-            if (checkColumn > 0)
-                w += checkColumn + motifCheckMarkHMargin;
-
-            sz = QSize(w, h);
-        }
-        break;
-
-
-    default:
-        sz = QCommonStyle::sizeFromContents(ct, opt, contentsSize, widget);
-        break;
-    }
-
-    return sz;
-}
-
-/*!
-  \reimp
-*/
-QRect
-QMotifStyle::subElementRect(SubElement sr, const QStyleOption *opt, const QWidget *widget) const
-{
-    QRect rect;
-
-    switch (sr) {
-    case SE_SliderFocusRect:
-        rect = QCommonStyle::subElementRect(sr, opt, widget);
-        rect.adjust(2, 2, -2, -2);
-        break;
-
-    case SE_CheckBoxIndicator:
-    case SE_RadioButtonIndicator:
-        {
-            rect = visualRect(opt->direction, opt->rect,
-                              QCommonStyle::subElementRect(sr, opt, widget));
-            rect.adjust(motifItemFrame,0, motifItemFrame,0);
-            rect = visualRect(opt->direction, opt->rect, rect);
-        }
-        break;
-
-    case SE_ComboBoxFocusRect:
-    {
-        int awh, ax, ay, sh, sy, dh, ew;
-        int fw = proxy()->pixelMetric(PM_DefaultFrameWidth, opt, widget);
-        QRect tr = opt->rect;
-
-        tr.adjust(fw, fw, -fw, -fw);
-        get_combo_parameters(tr, ew, awh, ax, ay, sh, dh, sy);
-        rect.setRect(ax-2, ay-2, awh+4, awh+sh+dh+4);
-        break;
-    }
-
-    case SE_ProgressBarLabel:
-    case SE_ProgressBarGroove:
-    case SE_ProgressBarContents:
-        if (const QStyleOptionProgressBar *pb = qstyleoption_cast<const QStyleOptionProgressBar *>(opt)) {
-            int textw = 0;
-            if (pb->textVisible)
-                textw = pb->fontMetrics.width(QLatin1String("100%")) + 6;
-
-            if (pb->textAlignment == Qt::AlignLeft || pb->textAlignment == Qt::AlignCenter) {
-                rect = opt->rect;
-            } else {
-                if(sr == SE_ProgressBarLabel)
-                    rect.setCoords(opt->rect.right() - textw, opt->rect.top(),
-                                   opt->rect.right(), opt->rect.bottom());
-                else
-                    rect.setCoords(opt->rect.left(), opt->rect.top(),
-                                   opt->rect.right() - textw, opt->rect.bottom());
-            }
-            if (sr == SE_ProgressBarContents)
-                rect.adjust(2, 2, -2, -2);
-            rect = visualRect(pb->direction, pb->rect, rect);
-        }
-        break;
-    case SE_CheckBoxClickRect:
-    case SE_RadioButtonClickRect:
-        rect = visualRect(opt->direction, opt->rect, opt->rect);
-        break;
-
-    default:
-        rect = QCommonStyle::subElementRect(sr, opt, widget);
-    }
-    return rect;
-}
-
-#ifndef QT_NO_IMAGEFORMAT_XPM
-static const char * const qt_menu_xpm[] = {
-"16 16 11 1",
-"  c #000000",
-", c #336600",
-". c #99CC00",
-"X c #666600",
-"o c #999933",
-"+ c #333300",
-"@ c #669900",
-"# c #999900",
-"$ c #336633",
-"% c #666633",
-"& c #99CC33",
-"................",
-"................",
-".....#,++X#.....",
-"....X      X....",
-"...X  Xo#%  X&..",
-"..#  o..&@o  o..",
-".., X..#+ @X X..",
-"..+ o.o+ +o# +..",
-"..+ #o+  +## +..",
-".., %@ ++ +, X..",
-"..#  o@oo+   #..",
-"...X  X##$   o..",
-"....X        X..",
-"....&oX++X#oX...",
-"................",
-"................"};
-
-
-static const char * const qt_close_xpm[] = {
-    "12 12 2 1",
-    "       s None  c None",
-    ".      c black",
-    "            ",
-    "            ",
-    "   .    .   ",
-    "  ...  ...  ",
-    "   ......   ",
-    "    ....    ",
-    "    ....    ",
-    "   ......   ",
-    "  ...  ...  ",
-    "   .    .   ",
-    "            ",
-    "            "};
-
-static const char * const qt_maximize_xpm[] = {
-    "12 12 2 1",
-    "       s None  c None",
-    ".      c black",
-    "            ",
-    "            ",
-    "            ",
-    "     .      ",
-    "    ...     ",
-    "   .....    ",
-    "  .......   ",
-    " .........  ",
-    "            ",
-    "            ",
-    "            ",
-    "            "};
-
-static const char * const qt_minimize_xpm[] = {
-    "12 12 2 1",
-    "       s None  c None",
-    ".      c black",
-    "            ",
-    "            ",
-    "            ",
-    "            ",
-    " .........  ",
-    "  .......   ",
-    "   .....    ",
-    "    ...     ",
-    "     .      ",
-    "            ",
-    "            ",
-    "            "};
-
-static const char * const qt_normalizeup_xpm[] = {
-    "12 12 2 1",
-    "       s None  c None",
-    ".      c black",
-    "            ",
-    "            ",
-    "            ",
-    "  .......   ",
-    "   ......   ",
-    "    .....   ",
-    "     ....   ",
-    "      ...   ",
-    "       ..   ",
-    "        .   ",
-    "            ",
-    "            "};
-
-static const char * const qt_shade_xpm[] = {
-    "12 12 2 1", "# c #000000",
-    ". c None",
-    "............",
-    "............",
-    ".#########..",
-    ".#########..",
-    "............",
-    "............",
-    "............",
-    "............",
-    "............",
-    "............",
-    "............",
-    "............"};
-
-
-static const char * const qt_unshade_xpm[] = {
-    "12 12 2 1",
-    "# c #000000",
-    ". c None",
-    "............",
-    "............",
-    ".#########..",
-    ".#########..",
-    ".#.......#..",
-    ".#.......#..",
-    ".#.......#..",
-    ".#.......#..",
-    ".#.......#..",
-    ".#########..",
-    "............",
-    "............"};
-
-
-static const char * dock_window_close_xpm[] = {
-    "8 8 2 1",
-    "# c #000000",
-    ". c None",
-    "##....##",
-    ".##..##.",
-    "..####..",
-    "...##...",
-    "..####..",
-    ".##..##.",
-    "##....##",
-    "........"};
-
-// Message box icons, from page 210 of the Windows style guide.
-
-// Hand-drawn to resemble Microsoft's icons, but in the Mac/Netscape palette.
-// Thanks to TrueColor displays, it is slightly more efficient to have
-// them duplicated.
-/* XPM */
-static const char * const information_xpm[]={
-    "32 32 5 1",
-    ". c None",
-    "c c #000000",
-    "* c #999999",
-    "a c #ffffff",
-    "b c #0000ff",
-    "...........********.............",
-    "........***aaaaaaaa***..........",
-    "......**aaaaaaaaaaaaaa**........",
-    ".....*aaaaaaaaaaaaaaaaaa*.......",
-    "....*aaaaaaaabbbbaaaaaaaac......",
-    "...*aaaaaaaabbbbbbaaaaaaaac.....",
-    "..*aaaaaaaaabbbbbbaaaaaaaaac....",
-    ".*aaaaaaaaaaabbbbaaaaaaaaaaac...",
-    ".*aaaaaaaaaaaaaaaaaaaaaaaaaac*..",
-    "*aaaaaaaaaaaaaaaaaaaaaaaaaaaac*.",
-    "*aaaaaaaaaabbbbbbbaaaaaaaaaaac*.",
-    "*aaaaaaaaaaaabbbbbaaaaaaaaaaac**",
-    "*aaaaaaaaaaaabbbbbaaaaaaaaaaac**",
-    "*aaaaaaaaaaaabbbbbaaaaaaaaaaac**",
-    "*aaaaaaaaaaaabbbbbaaaaaaaaaaac**",
-    "*aaaaaaaaaaaabbbbbaaaaaaaaaaac**",
-    ".*aaaaaaaaaaabbbbbaaaaaaaaaac***",
-    ".*aaaaaaaaaaabbbbbaaaaaaaaaac***",
-    "..*aaaaaaaaaabbbbbaaaaaaaaac***.",
-    "...caaaaaaabbbbbbbbbaaaaaac****.",
-    "....caaaaaaaaaaaaaaaaaaaac****..",
-    ".....caaaaaaaaaaaaaaaaaac****...",
-    "......ccaaaaaaaaaaaaaacc****....",
-    ".......*cccaaaaaaaaccc*****.....",
-    "........***cccaaaac*******......",
-    "..........****caaac*****........",
-    ".............*caaac**...........",
-    "...............caac**...........",
-    "................cac**...........",
-    ".................cc**...........",
-    "..................***...........",
-    "...................**..........."};
-/* XPM */
-static const char* const warning_xpm[]={
-    "32 32 4 1",
-    ". c None",
-    "a c #ffff00",
-    "* c #000000",
-    "b c #999999",
-    ".............***................",
-    "............*aaa*...............",
-    "...........*aaaaa*b.............",
-    "...........*aaaaa*bb............",
-    "..........*aaaaaaa*bb...........",
-    "..........*aaaaaaa*bb...........",
-    ".........*aaaaaaaaa*bb..........",
-    ".........*aaaaaaaaa*bb..........",
-    "........*aaaaaaaaaaa*bb.........",
-    "........*aaaa***aaaa*bb.........",
-    ".......*aaaa*****aaaa*bb........",
-    ".......*aaaa*****aaaa*bb........",
-    "......*aaaaa*****aaaaa*bb.......",
-    "......*aaaaa*****aaaaa*bb.......",
-    ".....*aaaaaa*****aaaaaa*bb......",
-    ".....*aaaaaa*****aaaaaa*bb......",
-    "....*aaaaaaaa***aaaaaaaa*bb.....",
-    "....*aaaaaaaa***aaaaaaaa*bb.....",
-    "...*aaaaaaaaa***aaaaaaaaa*bb....",
-    "...*aaaaaaaaaa*aaaaaaaaaa*bb....",
-    "..*aaaaaaaaaaa*aaaaaaaaaaa*bb...",
-    "..*aaaaaaaaaaaaaaaaaaaaaaa*bb...",
-    ".*aaaaaaaaaaaa**aaaaaaaaaaa*bb..",
-    ".*aaaaaaaaaaa****aaaaaaaaaa*bb..",
-    "*aaaaaaaaaaaa****aaaaaaaaaaa*bb.",
-    "*aaaaaaaaaaaaa**aaaaaaaaaaaa*bb.",
-    "*aaaaaaaaaaaaaaaaaaaaaaaaaaa*bbb",
-    "*aaaaaaaaaaaaaaaaaaaaaaaaaaa*bbb",
-    ".*aaaaaaaaaaaaaaaaaaaaaaaaa*bbbb",
-    "..*************************bbbbb",
-    "....bbbbbbbbbbbbbbbbbbbbbbbbbbb.",
-    ".....bbbbbbbbbbbbbbbbbbbbbbbbb.."};
-/* XPM */
-static const char* const critical_xpm[]={
-    "32 32 4 1",
-    ". c None",
-    "a c #999999",
-    "* c #ff0000",
-    "b c #ffffff",
-    "...........********.............",
-    ".........************...........",
-    ".......****************.........",
-    "......******************........",
-    ".....********************a......",
-    "....**********************a.....",
-    "...************************a....",
-    "..*******b**********b*******a...",
-    "..******bbb********bbb******a...",
-    ".******bbbbb******bbbbb******a..",
-    ".*******bbbbb****bbbbb*******a..",
-    "*********bbbbb**bbbbb*********a.",
-    "**********bbbbbbbbbb**********a.",
-    "***********bbbbbbbb***********aa",
-    "************bbbbbb************aa",
-    "************bbbbbb************aa",
-    "***********bbbbbbbb***********aa",
-    "**********bbbbbbbbbb**********aa",
-    "*********bbbbb**bbbbb*********aa",
-    ".*******bbbbb****bbbbb*******aa.",
-    ".******bbbbb******bbbbb******aa.",
-    "..******bbb********bbb******aaa.",
-    "..*******b**********b*******aa..",
-    "...************************aaa..",
-    "....**********************aaa...",
-    "....a********************aaa....",
-    ".....a******************aaa.....",
-    "......a****************aaa......",
-    ".......aa************aaaa.......",
-    ".........aa********aaaaa........",
-    "...........aaaaaaaaaaa..........",
-    ".............aaaaaaa............"};
-/* XPM */
-static const char *const question_xpm[] = {
-    "32 32 5 1",
-    ". c None",
-    "c c #000000",
-    "* c #999999",
-    "a c #ffffff",
-    "b c #0000ff",
-    "...........********.............",
-    "........***aaaaaaaa***..........",
-    "......**aaaaaaaaaaaaaa**........",
-    ".....*aaaaaaaaaaaaaaaaaa*.......",
-    "....*aaaaaaaaaaaaaaaaaaaac......",
-    "...*aaaaaaaabbbbbbaaaaaaaac.....",
-    "..*aaaaaaaabaaabbbbaaaaaaaac....",
-    ".*aaaaaaaabbaaaabbbbaaaaaaaac...",
-    ".*aaaaaaaabbbbaabbbbaaaaaaaac*..",
-    "*aaaaaaaaabbbbaabbbbaaaaaaaaac*.",
-    "*aaaaaaaaaabbaabbbbaaaaaaaaaac*.",
-    "*aaaaaaaaaaaaabbbbaaaaaaaaaaac**",
-    "*aaaaaaaaaaaaabbbaaaaaaaaaaaac**",
-    "*aaaaaaaaaaaaabbaaaaaaaaaaaaac**",
-    "*aaaaaaaaaaaaabbaaaaaaaaaaaaac**",
-    "*aaaaaaaaaaaaaaaaaaaaaaaaaaaac**",
-    ".*aaaaaaaaaaaabbaaaaaaaaaaaac***",
-    ".*aaaaaaaaaaabbbbaaaaaaaaaaac***",
-    "..*aaaaaaaaaabbbbaaaaaaaaaac***.",
-    "...caaaaaaaaaabbaaaaaaaaaac****.",
-    "....caaaaaaaaaaaaaaaaaaaac****..",
-    ".....caaaaaaaaaaaaaaaaaac****...",
-    "......ccaaaaaaaaaaaaaacc****....",
-    ".......*cccaaaaaaaaccc*****.....",
-    "........***cccaaaac*******......",
-    "..........****caaac*****........",
-    ".............*caaac**...........",
-    "...............caac**...........",
-    "................cac**...........",
-    ".................cc**...........",
-    "..................***...........",
-    "...................**...........",
-};
-#endif
-
-/*!
-  \reimp
-*/
-QPixmap
-QMotifStyle::standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
-                            const QWidget *widget) const
-{
-#ifndef QT_NO_IMAGEFORMAT_XPM
-    switch (standardPixmap) {
-    case SP_TitleBarMenuButton:
-        return QPixmap(qt_menu_xpm);
-    case SP_TitleBarShadeButton:
-        return QPixmap(qt_shade_xpm);
-    case SP_TitleBarUnshadeButton:
-        return QPixmap(qt_unshade_xpm);
-    case SP_TitleBarNormalButton:
-        return QPixmap(qt_normalizeup_xpm);
-    case SP_TitleBarMinButton:
-        return QPixmap(qt_minimize_xpm);
-    case SP_TitleBarMaxButton:
-        return QPixmap(qt_maximize_xpm);
-    case SP_TitleBarCloseButton:
-        return QPixmap(qt_close_xpm);
-    case SP_DockWidgetCloseButton:
-        return QPixmap(dock_window_close_xpm);
-
-    case SP_MessageBoxInformation:
-    case SP_MessageBoxWarning:
-    case SP_MessageBoxCritical:
-    case SP_MessageBoxQuestion:
-    {
-        const char * const * xpm_data;
-        switch (standardPixmap) {
-        case SP_MessageBoxInformation:
-            xpm_data = information_xpm;
-            break;
-        case SP_MessageBoxWarning:
-            xpm_data = warning_xpm;
-            break;
-        case SP_MessageBoxCritical:
-            xpm_data = critical_xpm;
-            break;
-        case SP_MessageBoxQuestion:
-            xpm_data = question_xpm;
-            break;
-        default:
-            xpm_data = 0;
-            break;
-        }
-        QPixmap pm;
-        if (xpm_data) {
-            QImage image((const char **) xpm_data);
-            // All that color looks ugly in Motif
-            const QPalette &pal = QApplication::palette();
-            switch (standardPixmap) {
-            case SP_MessageBoxInformation:
-            case SP_MessageBoxQuestion:
-                image.setColor(2, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Dark).rgb());
-                image.setColor(3, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Base).rgb());
-                image.setColor(4, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Text).rgb());
-                break;
-            case SP_MessageBoxWarning:
-                image.setColor(1, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Base).rgb());
-                image.setColor(2, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Text).rgb());
-                image.setColor(3, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Dark).rgb());
-                break;
-            case SP_MessageBoxCritical:
-                image.setColor(1, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Dark).rgb());
-                image.setColor(2, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Text).rgb());
-                image.setColor(3, 0xff000000 |
-                               pal.color(QPalette::Active, QPalette::Base).rgb());
-                break;
-            default:
-                break;
-            }
-            pm = QPixmap::fromImage(image);
-        }
-        return pm;
-    }
-
-    default:
-        break;
-    }
-#endif
-
-    return QCommonStyle::standardPixmap(standardPixmap, opt, widget);
-}
-
-/*! \reimp */
-bool QMotifStyle::event(QEvent *e)
-{
-    if(e->type() == QEvent::FocusIn) {
-        if (QWidget *focusWidget = QApplication::focusWidget()) {
-#ifndef QT_NO_GRAPHICSVIEW
-            if (QGraphicsView *graphicsView = qobject_cast<QGraphicsView *>(focusWidget)) {
-                QGraphicsItem *focusItem = graphicsView->scene() ? graphicsView->scene()->focusItem() : 0;
-                if (focusItem && focusItem->type() == QGraphicsProxyWidget::Type) {
-                    QGraphicsProxyWidget *proxy = static_cast<QGraphicsProxyWidget *>(focusItem);
-                    if (proxy->widget())
-                        focusWidget = proxy->widget()->focusWidget();
-                }
-            }
-#endif
-            if(!focus)
-                focus = new QFocusFrame(focusWidget);
-            focus->setWidget(focusWidget);
-        } else {
-            if(focus)
-                focus->setWidget(0);
-        }
-    } else if(e->type() == QEvent::FocusOut) {
-        if(focus)
-            focus->setWidget(0);
-    }
-    return  QCommonStyle::event(e);
-}
-
-
-/*! \reimp */
-int
-QMotifStyle::styleHint(StyleHint hint, const QStyleOption *opt, const QWidget *widget,
-                           QStyleHintReturn *returnData) const
-{
-    int ret;
-
-    switch (hint) {
-    case SH_DrawMenuBarSeparator:
-        ret = true;
-        break;
-
-    case SH_ScrollBar_MiddleClickAbsolutePosition:
-    case SH_Slider_SloppyKeyEvents:
-    case SH_ProgressDialog_CenterCancelButton:
-    case SH_Menu_SpaceActivatesItem:
-    case SH_ScrollView_FrameOnlyAroundContents:
-    case SH_DitherDisabledText:
-        ret = 1;
-        break;
-
-    case SH_Menu_SubMenuPopupDelay:
-        ret = 96;
-        break;
-
-    case SH_ProgressDialog_TextLabelAlignment:
-        ret = Qt::AlignLeft | Qt::AlignVCenter;
-        break;
-
-    case SH_ItemView_ChangeHighlightOnFocus:
-        ret = 0;
-        break;
-
-    case SH_MessageBox_UseBorderForButtonSpacing:
-        ret = 1;
-        break;
-
-    case SH_Dial_BackgroundRole:
-        ret = QPalette::Mid;
-        break;
-
-    case SH_DialogButtonLayout:
-        ret = QDialogButtonBox::KdeLayout;
-        break;
-    case SH_LineEdit_PasswordCharacter:
-        ret = '*';
-        break;
-    case SH_DialogButtonBox_ButtonsHaveIcons:
-        ret = 0;
-        break;
-    default:
-        ret = QCommonStyle::styleHint(hint, opt, widget, returnData);
-        break;
-    }
-
-    return ret;
-}
-
-/*! \reimp */
-QPalette QMotifStyle::standardPalette() const
-{
-    QColor background(0xcf, 0xcf, 0xcf);
-    if (QPixmap::defaultDepth() <= 8)
-        background = QColor(0xc0, 0xc0, 0xc0);
-
-    QColor light = background.lighter();
-    QColor mid = QColor(0xa6, 0xa6, 0xa6);
-    QColor dark = QColor(0x79, 0x7d, 0x79);
-    QPalette palette(Qt::black, background, light, dark, mid, Qt::black, Qt::white);
-    palette.setBrush(QPalette::Disabled, QPalette::WindowText, dark);
-    palette.setBrush(QPalette::Disabled, QPalette::Text, dark);
-    palette.setBrush(QPalette::Disabled, QPalette::ButtonText, dark);
-    palette.setBrush(QPalette::Disabled, QPalette::Base, background);
-    return palette;
-}
-
-QT_END_NAMESPACE
-
-#endif // !defined(QT_NO_STYLE_MOTIF) || defined(QT_PLUGIN)
diff --git a/src/widgets/styles/qmotifstyle.h b/src/widgets/styles/qmotifstyle.h
deleted file mode 100644
index 3a80033..0000000
--- a/src/widgets/styles/qmotifstyle.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QMOTIFSTYLE_H
-#define QMOTIFSTYLE_H
-
-#include <QtWidgets/qcommonstyle.h>
-#include <QtCore/qpointer.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-#if !defined(QT_NO_STYLE_MOTIF)
-
-class QPalette;
-class QFocusFrame;
-
-class QMotifStylePrivate;
-class Q_WIDGETS_EXPORT QMotifStyle : public QCommonStyle
-{
-    Q_OBJECT
-public:
-    explicit QMotifStyle(bool useHighlightCols=false);
-    virtual ~QMotifStyle();
-
-    void setUseHighlightColors(bool);
-    bool useHighlightColors() const;
-
-    void polish(QPalette&);
-    void polish(QWidget*);
-    void unpolish(QWidget*);
-    void polish(QApplication*);
-    void unpolish(QApplication*);
-
-    void drawPrimitive(PrimitiveElement pe, const QStyleOption *opt, QPainter *p,
-                        const QWidget *w = 0) const;
-
-    void drawControl(ControlElement element, const QStyleOption *opt, QPainter *p,
-                      const QWidget *w = 0) const;
-
-    void drawComplexControl(ComplexControl cc, const QStyleOptionComplex *opt, QPainter *p,
-                            const QWidget *w = 0) const;
-
-    QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
-                         SubControl sc, const QWidget *widget = 0) const;
-
-    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0,
-                     const QWidget *widget = 0) const;
-
-    QSize sizeFromContents(ContentsType ct, const QStyleOption *opt,
-                           const QSize &contentsSize, const QWidget *widget = 0) const;
-
-    QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
-
-    QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
-                           const QWidget *widget = 0) const;
-
-    int styleHint(StyleHint hint, const QStyleOption *opt = 0, const QWidget *widget = 0,
-                  QStyleHintReturn *returnData = 0) const;
-
-    bool event(QEvent *);
-    QPalette standardPalette() const;
-    QIcon standardIcon(StandardPixmap standardIcon, const QStyleOption *opt = 0,
-                       const QWidget *widget = 0) const;
-
-protected:
-    QPointer<QFocusFrame> focus;
-    QMotifStyle(QMotifStylePrivate &dd, bool useHighlightCols = false);
-    void timerEvent(QTimerEvent *event);
-    bool eventFilter(QObject *o, QEvent *e);
-
-private:
-    Q_DECLARE_PRIVATE(QMotifStyle)
-    Q_DISABLE_COPY(QMotifStyle)
-
-    bool highlightCols;
-};
-
-#endif // QT_NO_STYLE_MOTIF
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QMOTIFSTYLE_H
diff --git a/src/widgets/styles/qplastiquestyle.cpp b/src/widgets/styles/qplastiquestyle.cpp
index 72697d6..d22f82f 100644
--- a/src/widgets/styles/qplastiquestyle.cpp
+++ b/src/widgets/styles/qplastiquestyle.cpp
@@ -1025,7 +1025,7 @@ QPlastiqueStylePrivate::~QPlastiqueStylePrivate()
     KDE 3.2.
 
     \image qplastiquestyle.png
-    \sa QWindowsXPStyle, QMacStyle, QWindowsStyle, QCDEStyle, QMotifStyle
+    \sa QWindowsXPStyle, QMacStyle, QWindowsStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qstyle.cpp b/src/widgets/styles/qstyle.cpp
index 2a0cca1..77c647e 100644
--- a/src/widgets/styles/qstyle.cpp
+++ b/src/widgets/styles/qstyle.cpp
@@ -89,7 +89,7 @@ static int unpackControlTypes(QSizePolicy::ControlTypes controls, QSizePolicy::C
 
     Qt provides a set of QStyle subclasses that emulate the native
     look of the different platforms supported by Qt (QWindowsStyle,
-    QMacStyle, QMotifStyle, etc.). These styles are built into the
+    QMacStyle, etc.). These styles are built into the
     QtGui library, other styles can be made available using Qt's
     plugin mechansim.
 
@@ -152,7 +152,7 @@ static int unpackControlTypes(QSizePolicy::ControlTypes controls, QSizePolicy::C
 
     Qt contains a set of QStyle subclasses that emulate the styles of
     the different platforms supported by Qt (QWindowsStyle,
-    QMacStyle, QMotifStyle, etc.). By default, these styles are built
+    QMacStyle etc.). By default, these styles are built
     into the QtGui library. Styles can also be made available as
     plugins.
 
@@ -1660,7 +1660,7 @@ void QStyle::drawItemPixmap(QPainter *painter, const QRect &rect, int alignment,
         manner, i.e., left on a vertical slider subtracts a line.
 
     \value SH_ProgressDialog_CenterCancelButton  Center button on
-        progress dialogs, like Motif, otherwise right aligned.
+        progress dialogs, otherwise right aligned.
 
     \value SH_ProgressDialog_TextLabelAlignment The alignment for text
     labels in progress dialogs; Qt::AlignCenter on Windows,
diff --git a/src/widgets/styles/qstylefactory.cpp b/src/widgets/styles/qstylefactory.cpp
index 2ce8890..f12ea27 100644
--- a/src/widgets/styles/qstylefactory.cpp
+++ b/src/widgets/styles/qstylefactory.cpp
@@ -46,8 +46,6 @@
 
 #include "qapplication.h"
 #include "qwindowsstyle.h"
-#include "qmotifstyle.h"
-#include "qcdestyle.h"
 #ifndef QT_NO_STYLE_PLASTIQUE
 #include "qplastiquestyle.h"
 #endif
@@ -95,7 +93,7 @@ Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
     plugin (see QStylePlugin).
 
     The valid keys can be retrieved using the keys()
-    function. Typically they include "windows", "motif", "cde",
+    function. Typically they include "windows",
     "plastique" and "cleanlooks".  Depending on the platform,
     "windowsxp", "windowsvista" and "macintosh" may be available.
     Note that keys are case insensitive.
@@ -143,16 +141,6 @@ QStyle *QStyleFactory::create(const QString& key)
         ret = new QWindowsVistaStyle;
     else
 #endif
-#ifndef QT_NO_STYLE_MOTIF
-    if (style == QLatin1String("motif"))
-        ret = new QMotifStyle;
-    else
-#endif
-#ifndef QT_NO_STYLE_CDE
-    if (style == QLatin1String("cde"))
-        ret = new QCDEStyle;
-    else
-#endif
 #ifndef QT_NO_STYLE_PLASTIQUE
     if (style == QLatin1String("plastique"))
         ret = new QPlastiqueStyle;
@@ -226,14 +214,6 @@ QStringList QStyleFactory::keys()
         (QSysInfo::WindowsVersion >= QSysInfo::WV_VISTA && (QSysInfo::WindowsVersion & QSysInfo::WV_NT_based)))
         list << QLatin1String("WindowsVista");
 #endif
-#ifndef QT_NO_STYLE_MOTIF
-    if (!list.contains(QLatin1String("Motif")))
-        list << QLatin1String("Motif");
-#endif
-#ifndef QT_NO_STYLE_CDE
-    if (!list.contains(QLatin1String("CDE")))
-        list << QLatin1String("CDE");
-#endif
 #ifndef QT_NO_STYLE_PLASTIQUE
     if (!list.contains(QLatin1String("Plastique")))
         list << QLatin1String("Plastique");
diff --git a/src/widgets/styles/qwindowsstyle.cpp b/src/widgets/styles/qwindowsstyle.cpp
index 1627c73..dccf88a 100644
--- a/src/widgets/styles/qwindowsstyle.cpp
+++ b/src/widgets/styles/qwindowsstyle.cpp
@@ -261,7 +261,7 @@ bool QWindowsStyle::eventFilter(QObject *o, QEvent *e)
     This style is Qt's default GUI style on Windows.
 
     \image qwindowsstyle.png
-    \sa QWindowsXPStyle, QMacStyle, QPlastiqueStyle, QCDEStyle, QMotifStyle
+    \sa QWindowsXPStyle, QMacStyle, QPlastiqueStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qwindowsvistastyle.cpp b/src/widgets/styles/qwindowsvistastyle.cpp
index 1208b90..cc94d67 100644
--- a/src/widgets/styles/qwindowsvistastyle.cpp
+++ b/src/widgets/styles/qwindowsvistastyle.cpp
@@ -153,7 +153,7 @@ bool QWindowsVistaStylePrivate::useVista()
   \warning This style is only available on the Windows Vista platform
   because it makes use of Windows Vista's style engine.
 
-  \sa QMacStyle, QWindowsXPStyle, QPlastiqueStyle, QCleanlooksStyle, QMotifStyle
+  \sa QMacStyle, QWindowsXPStyle, QPlastiqueStyle, QCleanlooksStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qwindowsxpstyle.cpp b/src/widgets/styles/qwindowsxpstyle.cpp
index e20b85e..c7517c6 100644
--- a/src/widgets/styles/qwindowsxpstyle.cpp
+++ b/src/widgets/styles/qwindowsxpstyle.cpp
@@ -1170,7 +1170,7 @@ void QWindowsXPStylePrivate::drawBackgroundThruNativeBuffer(XPThemeData &themeDa
     sizeFromContents(), are documented here.
 
     \image qwindowsxpstyle.png
-    \sa QMacStyle, QWindowsStyle, QPlastiqueStyle, QCDEStyle, QMotifStyle
+    \sa QMacStyle, QWindowsStyle, QPlastiqueStyle
 */
 
 /*!
diff --git a/src/widgets/styles/styles.pri b/src/widgets/styles/styles.pri
index d43d352..8d06714 100644
--- a/src/widgets/styles/styles.pri
+++ b/src/widgets/styles/styles.pri
@@ -62,19 +62,6 @@ contains( styles, mac ) {
 	DEFINES += QT_NO_STYLE_MAC
 }
 
-contains( styles, cde ) {
-	HEADERS += styles/qcdestyle.h
-	SOURCES += styles/qcdestyle.cpp
-
-	!contains( styles, motif ) {
-		message( cde requires motif )
-		styles += motif
-		DEFINES+= QT_STYLE_MOTIF
-	}
-} else {
-	DEFINES += QT_NO_STYLE_CDE
-}
-
 contains( styles, windowsvista ) {
 	HEADERS += styles/qwindowsvistastyle.h
 	HEADERS += styles/qwindowsvistastyle_p.h
@@ -146,13 +133,6 @@ contains( styles, windows ) {
 	DEFINES += QT_NO_STYLE_WINDOWS
 }
 
-contains( styles, motif ) {
-	HEADERS += styles/qmotifstyle.h
-	SOURCES += styles/qmotifstyle.cpp
-} else {
-	DEFINES += QT_NO_STYLE_MOTIF
-}
-
 contains( styles, windowsce ) {
 	HEADERS += styles/qwindowscestyle.h
 	SOURCES += styles/qwindowscestyle.cpp
diff --git a/src/widgets/widgets/qlcdnumber.cpp b/src/widgets/widgets/qlcdnumber.cpp
index 6b8c3c3..d651597 100644
--- a/src/widgets/widgets/qlcdnumber.cpp
+++ b/src/widgets/widgets/qlcdnumber.cpp
@@ -106,14 +106,12 @@ public:
     its roots back to a BASIC program on the \l{Sinclair Spectrum}{Sinclair Spectrum}.
 
     \table
-    \row \li \inlineimage motif-lcdnumber.png Screenshot of a Motif style LCD number widget
-    \inlineimage cde-lcdnumber.png Screenshot of a CDE style LCD number widget
+    \row \li
     \inlineimage windows-lcdnumber.png Screenshot of a Windows style LCD number widget
     \inlineimage windowsxp-lcdnumber.png Screenshot of a Windows XP style LCD number widget
     \inlineimage macintosh-lcdnumber.png Screenshot of a Macintosh style LCD number widget
     \inlineimage plastique-lcdnumber.png Screenshot of a Plastique style LCD number widget
     \row \li LCD number widgets shown in various widget styles (from left to right):
-    \l{Motif Style Widget Gallery}{Motif}, \l{CDE Style Widget Gallery}{CDE},
     \l{Windows Style Widget Gallery}{Windows}, \l{Windows XP Style Widget Gallery}{Windows XP},
     \l{Macintosh Style Widget Gallery}{Macintosh}, \l{Plastique Style Widget Gallery}{Plastique}.
     \endtable
diff --git a/src/widgets/widgets/qlineedit.cpp b/src/widgets/widgets/qlineedit.cpp
index ecd1f09..a06c8ed 100644
--- a/src/widgets/widgets/qlineedit.cpp
+++ b/src/widgets/widgets/qlineedit.cpp
@@ -169,8 +169,8 @@ void QLineEdit::initStyleOption(QStyleOptionFrame *option) const
     returnPressed()/editingFinished() signals will only be emitted if
     the validator returns QValidator::Acceptable.
 
-    By default, QLineEdits have a frame as specified by the Windows
-    and Motif style guides; you can turn it off by calling
+    By default, QLineEdits have a frame as specified by platform
+    style guides; you can turn it off by calling
     setFrame(false).
 
     The default key bindings are described below. The line edit also
diff --git a/src/widgets/widgets/qmenubar.cpp b/src/widgets/widgets/qmenubar.cpp
index 511b644..516c8b9 100644
--- a/src/widgets/widgets/qmenubar.cpp
+++ b/src/widgets/widgets/qmenubar.cpp
@@ -632,12 +632,6 @@ void QMenuBar::initStyleOption(QStyleOptionMenuItem *option, const QAction *acti
     other styles, handles the \uicontrol{Help} menu in the same way as it
     handles any other menu.
 
-    \row \li \inlineimage motif-menubar.png A menu bar shown in the
-    Motif widget style.
-
-    \li The \l{QMotifStyle}{Motif widget style} treats \uicontrol{Help} menus
-    in a special way, placing them at right-hand end of the menu bar.
-
     \endtable
 
     \section1 QMenuBar on Mac OS X
diff --git a/src/widgets/widgets/qprogressbar.cpp b/src/widgets/widgets/qprogressbar.cpp
index 090af52..8f0da78 100644
--- a/src/widgets/widgets/qprogressbar.cpp
+++ b/src/widgets/widgets/qprogressbar.cpp
@@ -216,7 +216,7 @@ bool QProgressBarPrivate::repaintRequired() const
     \value BottomToTop The text is rotated 90 degrees counter-clockwise.
 
     Note that whether or not the text is drawn is dependent on the style.
-    Currently CDE, CleanLooks, Motif, and Plastique draw the text. Mac, Windows
+    Currently CleanLooks and Plastique draw the text. Mac, Windows
     and WindowsXP style do not.
 
     \sa textDirection
diff --git a/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp b/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp
index 43064dd..96aba11 100644
--- a/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp
@@ -52,9 +52,6 @@
 #include <math.h>
 
 #include <QtWidgets/QLabel>
-#if !defined(QT_NO_STYLE_MOTIF)
-#include <QtWidgets/QMotifStyle>
-#endif
 #if !defined(QT_NO_STYLE_WINDOWS)
 #include <QtWidgets/QWindowsStyle>
 #endif
@@ -2736,6 +2733,23 @@ void tst_QGraphicsView::scrollBarRanges_data()
     _scrollBarRanges_data();
 }
 
+// Simulates motif scrollbar for range tests
+class FauxMotifStyle : public QCommonStyle {
+public:
+    int styleHint(StyleHint hint, const QStyleOption *option,
+                  const QWidget *widget, QStyleHintReturn *returnData) const {
+        if (hint == QStyle::SH_ScrollView_FrameOnlyAroundContents)
+            return true;
+        return QCommonStyle::styleHint(hint, option, widget, returnData);
+    }
+
+    int pixelMetric(PixelMetric m, const QStyleOption *opt, const QWidget *widget) const {
+        if (m == QStyle::PM_ScrollView_ScrollBarSpacing)
+            return 4;
+        return QCommonStyle::pixelMetric(m, opt, widget);
+    }
+};
+
 void tst_QGraphicsView::scrollBarRanges()
 {
     QFETCH(QSize, viewportSize);
@@ -2758,10 +2772,10 @@ void tst_QGraphicsView::scrollBarRanges()
     view.setFrameStyle(useStyledPanel ? QFrame::StyledPanel : QFrame::NoFrame);
 
     if (useMotif) {
-#if !defined(QT_NO_STYLE_MOTIF)
-        view.setStyle(new QMotifStyle);
+#if !defined(QT_NO_STYLE_WINDOWS)
+        view.setStyle(new FauxMotifStyle);
 #else
-        QSKIP("No Motif style compiled.");
+        QSKIP("No Windows style compiled.");
 #endif
     } else {
 #if defined(Q_OS_WINCE)
diff --git a/tests/auto/widgets/kernel/qapplication/tst_qapplication.cpp b/tests/auto/widgets/kernel/qapplication/tst_qapplication.cpp
index b9a9301..2250fe3 100644
--- a/tests/auto/widgets/kernel/qapplication/tst_qapplication.cpp
+++ b/tests/auto/widgets/kernel/qapplication/tst_qapplication.cpp
@@ -447,8 +447,8 @@ void tst_QApplication::args_data()
 
     QTest::newRow( "App name" ) << 1 << "/usr/bin/appname" << 1 << "/usr/bin/appname";
     QTest::newRow( "No arguments" ) << 0 << QString() << 0 << QString();
-    QTest::newRow( "App name, style" ) << 3 << "/usr/bin/appname -style motif" << 1 << "/usr/bin/appname";
-    QTest::newRow( "App name, style, arbitrary, reverse" ) << 5 << "/usr/bin/appname -style motif -arbitrary -reverse"
+    QTest::newRow( "App name, style" ) << 3 << "/usr/bin/appname -style windows" << 1 << "/usr/bin/appname";
+    QTest::newRow( "App name, style, arbitrary, reverse" ) << 5 << "/usr/bin/appname -style windows -arbitrary -reverse"
 							<< 2 << "/usr/bin/appname -arbitrary";
 }
 
diff --git a/tests/auto/widgets/kernel/qgridlayout/tst_qgridlayout.cpp b/tests/auto/widgets/kernel/qgridlayout/tst_qgridlayout.cpp
index 7787f79..e09a3e7 100644
--- a/tests/auto/widgets/kernel/qgridlayout/tst_qgridlayout.cpp
+++ b/tests/auto/widgets/kernel/qgridlayout/tst_qgridlayout.cpp
@@ -793,11 +793,6 @@ void tst_QGridLayout::minMaxSize_data()
                 << SizeInfo(QPoint(10, 10), QSize( 90, 90), QSize(100,100))
                 << SizeInfo(QPoint(10 + 100 + 1, 10), QSize( 90, 90))
                 );
-    QTest::newRow("2x1 grid, extend to minimumSize, motif") << QString::fromLatin1("motif") << 2 << 1
-                << int(QSizePolicy::Preferred) << QSize() << (SizeInfoList()
-                << SizeInfo(QPoint(11, 11), QSize( 90, 90), QSize(100,100))
-                << SizeInfo(QPoint(11 + 100 + 6, 11), QSize( 90, 90))
-                );
     QTest::newRow("2x1 grid, extend to minimumSize, windows") << QString::fromLatin1("windows") << 2 << 1
                 << int(QSizePolicy::Preferred) << QSize() << (SizeInfoList()
                 << SizeInfo(QPoint(11, 11), QSize( 90, 90), QSize(100,100))
diff --git a/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp b/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp
index e20891a..6bbcc4d 100644
--- a/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp
+++ b/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp
@@ -57,8 +57,6 @@
 
 #include <qplastiquestyle.h>
 #include <qwindowsstyle.h>
-#include <qcdestyle.h>
-#include <qmotifstyle.h>
 #include <qcommonstyle.h>
 #include <qproxystyle.h>
 #include <qstylefactory.h>
@@ -121,16 +119,10 @@ private slots:
     void cleanupTestCase();
     void init();
     void cleanup();
-#ifndef QT_NO_STYLE_MOTIF
-    void testMotifStyle();
-#endif
 #ifndef QT_NO_STYLE_PLASTIQUE
     void testPlastiqueStyle();
 #endif
     void testWindowsStyle();
-#ifndef QT_NO_STYLE_CDE
-    void testCDEStyle();
-#endif
 #ifndef QT_NO_STYLE_WINDOWSXP
     void testWindowsXPStyle();
 #endif
@@ -195,24 +187,15 @@ void tst_QStyle::cleanupTestCase()
 void tst_QStyle::testStyleFactory()
 {
     QStringList keys = QStyleFactory::keys();
-#ifndef QT_NO_STYLE_MOTIF
-    QVERIFY(keys.contains("Motif"));
-#endif
 #ifndef QT_NO_STYLE_CLEANLOOKS
     QVERIFY(keys.contains("Cleanlooks"));
 #endif
 #ifndef QT_NO_STYLE_PLASTIQUE
     QVERIFY(keys.contains("Plastique"));
 #endif
-#ifndef QT_NO_STYLE_CDE
-    QVERIFY(keys.contains("CDE"));
-#endif
 #ifndef QT_NO_STYLE_WINDOWS
     QVERIFY(keys.contains("Windows"));
 #endif
-#ifndef QT_NO_STYLE_MOTIF
-    QVERIFY(keys.contains("Motif"));
-#endif
 #ifdef Q_OS_WIN
     if (QSysInfo::WindowsVersion >= QSysInfo::WV_XP &&
         (QSysInfo::WindowsVersion & QSysInfo::WV_NT_based))
@@ -569,22 +552,6 @@ void tst_QStyle::testMacStyle()
 #endif
 }
 
-#ifndef QT_NO_STYLE_MOTIF
-void tst_QStyle::testMotifStyle()
-{
-    QMotifStyle mstyle;
-    QVERIFY(testAllFunctions(&mstyle));
-}
-#endif
-
-#ifndef QT_NO_STYLE_CDE
-void tst_QStyle::testCDEStyle()
-{
-    QCDEStyle cstyle;
-    QVERIFY(testAllFunctions(&cstyle));
-}
-#endif
-
 void tst_QStyle::testWindowsCEStyle()
 {
 #if defined(Q_OS_WINCE)
diff --git a/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp b/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp
index 796b405..310e43c 100644
--- a/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp
+++ b/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp
@@ -44,6 +44,7 @@
 #include <QtTest/QtTest>
 #include <QtDebug>
 #include <QMetaObject>
+#include <QPlastiqueStyle>
 
 #include <private/qstylesheetstyle_p.h>
 #include "../../../platformquirks.h"
@@ -1590,7 +1591,7 @@ class ChangeEventWidget : public QWidget
             static bool recurse = false;
             if (!recurse) {
                 recurse = true;
-                QStyle *style = new QMotifStyle;
+                QStyle *style = new QPlastiqueStyle;
                 style->setParent(this);
                 setStyle(style);
                 recurse = false;
diff --git a/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp b/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp
index 03c880a..30cc6a4 100644
--- a/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp
+++ b/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp
@@ -561,12 +561,6 @@ void tst_QPushButton::defaultAndAutoDefault()
 void tst_QPushButton::sizeHint_data()
 {
     QTest::addColumn<QString>("stylename");
-#if !defined(QT_NO_STYLE_MOTIF)
-    QTest::newRow("motif") << QString::fromLatin1("motif");
-#endif
-#if !defined(QT_NO_STYLE_CDE)
-    QTest::newRow("cde") << QString::fromLatin1("cde");
-#endif
 #if !defined(QT_NO_STYLE_WINDOWS)
     QTest::newRow("windows") << QString::fromLatin1("windows");
 #endif
diff --git a/tools/configure/configureapp.cpp b/tools/configure/configureapp.cpp
index 6e8105e..4fce6f2 100644
--- a/tools/configure/configureapp.cpp
+++ b/tools/configure/configureapp.cpp
@@ -303,8 +303,6 @@ Configure::Configure(int& argc, char** argv)
     dictionary[ "STYLE_CLEANLOOKS" ]= "yes";
     dictionary[ "STYLE_WINDOWSCE" ] = "no";
     dictionary[ "STYLE_WINDOWSMOBILE" ] = "no";
-    dictionary[ "STYLE_MOTIF" ]     = "yes";
-    dictionary[ "STYLE_CDE" ]       = "yes";
     dictionary[ "STYLE_GTK" ]       = "no";
 
     dictionary[ "SQL_MYSQL" ]       = "no";
@@ -642,16 +640,6 @@ void Configure::parseCmdLine()
         else if (configCmdLine.at(i) == "-no-style-cleanlooks")
             dictionary[ "STYLE_CLEANLOOKS" ] = "no";
 
-        else if (configCmdLine.at(i) == "-qt-style-motif")
-            dictionary[ "STYLE_MOTIF" ] = "yes";
-        else if (configCmdLine.at(i) == "-no-style-motif")
-            dictionary[ "STYLE_MOTIF" ] = "no";
-
-        else if (configCmdLine.at(i) == "-qt-style-cde")
-            dictionary[ "STYLE_CDE" ] = "yes";
-        else if (configCmdLine.at(i) == "-no-style-cde")
-            dictionary[ "STYLE_CDE" ] = "no";
-
         // Work around compiler nesting limitation
         else
             continueElse[1] = true;
@@ -1483,8 +1471,6 @@ void Configure::applySpecSpecifics()
         dictionary[ "STYLE_CLEANLOOKS" ]    = "no";
         dictionary[ "STYLE_WINDOWSCE" ]     = "yes";
         dictionary[ "STYLE_WINDOWSMOBILE" ] = "yes";
-        dictionary[ "STYLE_MOTIF" ]         = "no";
-        dictionary[ "STYLE_CDE" ]           = "no";
         dictionary[ "OPENGL" ]              = "no";
         dictionary[ "OPENSSL" ]             = "no";
         dictionary[ "RTTI" ]                = "no";
@@ -1786,8 +1772,6 @@ bool Configure::displayHelp()
         desc("STYLE_WINDOWSVISTA", "auto", "",          "  windowsvista", ' ');
         desc("STYLE_PLASTIQUE", "yes", "",              "  plastique", ' ');
         desc("STYLE_CLEANLOOKS", "yes", "",             "  cleanlooks", ' ');
-        desc("STYLE_MOTIF", "yes", "",                  "  motif", ' ');
-        desc("STYLE_CDE", "yes", "",                    "  cde", ' ');
         desc("STYLE_WINDOWSCE", "yes", "",              "  windowsce", ' ');
         desc("STYLE_WINDOWSMOBILE" , "yes", "",         "  windowsmobile\n", ' ');
         desc("NATIVE_GESTURES", "no", "-no-native-gestures", "Do not use native gestures on Windows 7.");
@@ -2363,21 +2347,12 @@ void Configure::generateOutputVars()
     if (dictionary[ "STYLE_WINDOWSVISTA" ] == "yes")
         qmakeStyles += "windowsvista";
 
-    if (dictionary[ "STYLE_MOTIF" ] == "yes")
-        qmakeStyles += "motif";
-
-    if (dictionary[ "STYLE_SGI" ] == "yes")
-        qmakeStyles += "sgi";
-
     if (dictionary[ "STYLE_WINDOWSCE" ] == "yes")
     qmakeStyles += "windowsce";
 
     if (dictionary[ "STYLE_WINDOWSMOBILE" ] == "yes")
     qmakeStyles += "windowsmobile";
 
-    if (dictionary[ "STYLE_CDE" ] == "yes")
-        qmakeStyles += "cde";
-
     // Databases ----------------------------------------------------
     if (dictionary[ "SQL_MYSQL" ] == "yes")
         qmakeSql += "mysql";
@@ -3124,8 +3099,6 @@ void Configure::generateConfigfiles()
         if (dictionary["STYLE_WINDOWSXP"] != "yes" && dictionary["STYLE_WINDOWSVISTA"] != "yes")
             qconfigList += "QT_NO_STYLE_WINDOWSXP";
         if (dictionary["STYLE_WINDOWSVISTA"] != "yes")   qconfigList += "QT_NO_STYLE_WINDOWSVISTA";
-        if (dictionary["STYLE_MOTIF"] != "yes")       qconfigList += "QT_NO_STYLE_MOTIF";
-        if (dictionary["STYLE_CDE"] != "yes")         qconfigList += "QT_NO_STYLE_CDE";
 
         // ### We still need the QT_NO_STYLE_S60 define for compiling Qt. Remove later!
         qconfigList += "QT_NO_STYLE_S60";
@@ -3324,8 +3297,6 @@ void Configure::displayConfig()
     sout << "    Windows Vista..........." << dictionary[ "STYLE_WINDOWSVISTA" ] << endl;
     sout << "    Plastique..............." << dictionary[ "STYLE_PLASTIQUE" ] << endl;
     sout << "    Cleanlooks.............." << dictionary[ "STYLE_CLEANLOOKS" ] << endl;
-    sout << "    Motif..................." << dictionary[ "STYLE_MOTIF" ] << endl;
-    sout << "    CDE....................." << dictionary[ "STYLE_CDE" ] << endl;
     sout << "    Windows CE.............." << dictionary[ "STYLE_WINDOWSCE" ] << endl;
     sout << "    Windows Mobile.........." << dictionary[ "STYLE_WINDOWSMOBILE" ] << endl << endl;