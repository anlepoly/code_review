diff --git a/src/qml/qml/qqmlglobal.cpp b/src/qml/qml/qqmlglobal.cpp
index c9ab2fa..f770f53 100644
--- a/src/qml/qml/qqmlglobal.cpp
+++ b/src/qml/qml/qqmlglobal.cpp
@@ -332,6 +332,7 @@ QObject *QQmlGuiProvider::application(QObject *) { return 0; }
 QStringList QQmlGuiProvider::fontFamilies() { return QStringList(); }
 bool QQmlGuiProvider::openUrlExternally(QUrl &) { return false; }
 
+#ifndef QT_NO_IM
 QObject *QQmlGuiProvider::inputMethod()
 {
     // We don't have any input method code by default
@@ -339,6 +340,7 @@ QObject *QQmlGuiProvider::inputMethod()
     o->setObjectName(QString::fromLatin1("No inputMethod available"));
     return o;
 }
+#endif
 
 static QQmlGuiProvider *guiProvider = 0;
 
diff --git a/src/qml/qml/qqmlglobal_p.h b/src/qml/qml/qqmlglobal_p.h
index 2777488..037323d 100644
--- a/src/qml/qml/qqmlglobal_p.h
+++ b/src/qml/qml/qqmlglobal_p.h
@@ -297,7 +297,9 @@ class Q_QML_PRIVATE_EXPORT QQmlGuiProvider
 public:
     virtual ~QQmlGuiProvider();
     virtual QObject *application(QObject *parent);
+#ifndef QT_NO_IM
     virtual QObject *inputMethod();
+#endif
     virtual QStringList fontFamilies();
     virtual bool openUrlExternally(QUrl &);
 };
diff --git a/src/qml/qml/v8/qv8engine.cpp b/src/qml/qml/v8/qv8engine.cpp
index 030cfda..1544b07 100644
--- a/src/qml/qml/v8/qv8engine.cpp
+++ b/src/qml/qml/v8/qv8engine.cpp
@@ -631,7 +631,9 @@ void QV8Engine::initializeGlobal(v8::Handle<v8::Object> global)
 
     if (m_engine) {
         qt->SetAccessor(v8::String::New("application"), getApplication, 0, v8::External::New(this));
+#ifndef QT_NO_IM
         qt->SetAccessor(v8::String::New("inputMethod"), getInputMethod, 0, v8::External::New(this));
+#endif
         qt->Set(v8::String::New("lighter"), V8FUNCTION(lighter, this));
         qt->Set(v8::String::New("darker"), V8FUNCTION(darker, this));
         qt->Set(v8::String::New("tint"), V8FUNCTION(tint, this));
@@ -1449,11 +1451,13 @@ v8::Handle<v8::Value> QV8Engine::getApplication(v8::Local<v8::String>, const v8:
     return engine->newQObject(engine->m_application);
 }
 
+#ifndef QT_NO_IM
 v8::Handle<v8::Value> QV8Engine::getInputMethod(v8::Local<v8::String>, const v8::AccessorInfo &info)
 {
     QV8Engine *engine = reinterpret_cast<QV8Engine*>(v8::External::Unwrap(info.Data()));
     return engine->newQObject(QQml_guiProvider()->inputMethod(), CppOwnership);
 }
+#endif
 
 void QV8GCCallback::registerGcPrologueCallback()
 {
diff --git a/src/qml/qml/v8/qv8engine_p.h b/src/qml/qml/v8/qv8engine_p.h
index 8320a89..12b0f4b 100644
--- a/src/qml/qml/v8/qv8engine_p.h
+++ b/src/qml/qml/v8/qv8engine_p.h
@@ -428,7 +428,9 @@ public:
     void addRelationshipForGC(QObject *object, QObject *other);
 
     static v8::Handle<v8::Value> getApplication(v8::Local<v8::String> property, const v8::AccessorInfo &info);
+#ifndef QT_NO_IM
     static v8::Handle<v8::Value> getInputMethod(v8::Local<v8::String> property, const v8::AccessorInfo &info);
+#endif
 
     struct ThreadData {
         ThreadData();
diff --git a/src/quick/items/qquickitem.cpp b/src/quick/items/qquickitem.cpp
index f213111..9180eb4 100644
--- a/src/quick/items/qquickitem.cpp
+++ b/src/quick/items/qquickitem.cpp
@@ -345,6 +345,7 @@ void QQuickItemKeyFilter::keyReleased(QKeyEvent *event, bool post)
     if (m_next) m_next->keyReleased(event, post);
 }
 
+#ifndef QT_NO_IM
 void QQuickItemKeyFilter::inputMethodEvent(QInputMethodEvent *event, bool post)
 {
     if (m_next)
@@ -358,6 +359,7 @@ QVariant QQuickItemKeyFilter::inputMethodQuery(Qt::InputMethodQuery query) const
     if (m_next) return m_next->inputMethodQuery(query);
     return QVariant();
 }
+#endif // QT_NO_IM
 
 void QQuickItemKeyFilter::componentComplete()
 {
@@ -1194,6 +1196,7 @@ void QQuickKeysAttached::setPriority(Priority order)
 void QQuickKeysAttached::componentComplete()
 {
     Q_D(QQuickKeysAttached);
+#ifndef QT_NO_IM
     if (d->item) {
         for (int ii = 0; ii < d->targets.count(); ++ii) {
             QQuickItem *targetItem = d->targets.at(ii);
@@ -1203,6 +1206,7 @@ void QQuickKeysAttached::componentComplete()
             }
         }
     }
+#endif
 }
 
 void QQuickKeysAttached::keyPressed(QKeyEvent *event, bool post)
@@ -1279,6 +1283,7 @@ void QQuickKeysAttached::keyReleased(QKeyEvent *event, bool post)
     if (!event->isAccepted()) QQuickItemKeyFilter::keyReleased(event, post);
 }
 
+#ifndef QT_NO_IM
 void QQuickKeysAttached::inputMethodEvent(QInputMethodEvent *event, bool post)
 {
     Q_D(QQuickKeysAttached);
@@ -1317,6 +1322,7 @@ QVariant QQuickKeysAttached::inputMethodQuery(Qt::InputMethodQuery query) const
     }
     return QQuickItemKeyFilter::inputMethodQuery(query);
 }
+#endif // QT_NO_IM
 
 QQuickKeysAttached *QQuickKeysAttached::qmlAttachedProperties(QObject *obj)
 {
@@ -3099,6 +3105,7 @@ void QQuickItem::keyReleaseEvent(QKeyEvent *event)
     event->ignore();
 }
 
+#ifndef QT_NO_IM
 /*!
     This event handler can be reimplemented in a subclass to receive input
     method events for an item. The event information is provided by the
@@ -3108,6 +3115,7 @@ void QQuickItem::inputMethodEvent(QInputMethodEvent *event)
 {
     event->ignore();
 }
+#endif // QT_NO_IM
 
 /*!
     This event handler can be reimplemented in a subclass to receive focus-in
@@ -3336,6 +3344,7 @@ void QQuickItem::windowDeactivateEvent()
     }
 }
 
+#ifndef QT_NO_IM
 /*!
     This method is only relevant for input items.
 
@@ -3370,6 +3379,7 @@ QVariant QQuickItem::inputMethodQuery(Qt::InputMethodQuery query) const
 
     return v;
 }
+#endif // QT_NO_IM
 
 QQuickAnchorLine QQuickItemPrivate::left() const
 {
@@ -4023,6 +4033,7 @@ void QQuickItemPrivate::deliverKeyEvent(QKeyEvent *e)
     }
 }
 
+#ifndef QT_NO_IM
 void QQuickItemPrivate::deliverInputMethodEvent(QInputMethodEvent *e)
 {
     Q_Q(QQuickItem);
@@ -4048,6 +4059,7 @@ void QQuickItemPrivate::deliverInputMethodEvent(QInputMethodEvent *e)
         extra->keyHandler->inputMethodEvent(e, true);
     }
 }
+#endif // QT_NO_IM
 
 void QQuickItemPrivate::deliverFocusEvent(QFocusEvent *e)
 {
@@ -4146,6 +4158,7 @@ void QQuickItem::itemChange(ItemChange change, const ItemChangeData &value)
     Q_UNUSED(value);
 }
 
+#ifndef QT_NO_IM
 /*!
     Notify input method on updated query values if needed. \a queries indicates
     the changed attributes.
@@ -4155,6 +4168,7 @@ void QQuickItem::updateInputMethod(Qt::InputMethodQueries queries)
     if (hasActiveFocus())
         qApp->inputMethod()->update(queries);
 }
+#endif // QT_NO_IM
 
 /*! \internal */
 // XXX todo - do we want/need this anymore?
@@ -6504,6 +6518,7 @@ bool QQuickItem::event(QEvent *ev)
         return QObject::event(ev);
     }
 #endif
+#ifndef QT_NO_IM
     if (ev->type() == QEvent::InputMethodQuery) {
         QInputMethodQueryEvent *query = static_cast<QInputMethodQueryEvent *>(ev);
         Qt::InputMethodQueries queries = query->queries();
@@ -6519,7 +6534,9 @@ bool QQuickItem::event(QEvent *ev)
     } else if (ev->type() == QEvent::InputMethod) {
         inputMethodEvent(static_cast<QInputMethodEvent *>(ev));
         return true;
-    } else if (ev->type() == QEvent::StyleAnimationUpdate) {
+    } else
+#endif // QT_NO_IM
+    if (ev->type() == QEvent::StyleAnimationUpdate) {
         update();
         return true;
     }
diff --git a/src/quick/items/qquickitem.h b/src/quick/items/qquickitem.h
index af79a08..a41aa7f 100644
--- a/src/quick/items/qquickitem.h
+++ b/src/quick/items/qquickitem.h
@@ -156,7 +156,9 @@ class Q_QUICK_EXPORT QQuickItem : public QObject, public QQmlParserStatus
 public:
     enum Flag {
         ItemClipsChildrenToShape  = 0x01,
+#ifndef QT_NO_IM
         ItemAcceptsInputMethod    = 0x02,
+#endif
         ItemIsFocusScope          = 0x04,
         ItemHasContents           = 0x08,
         ItemAcceptsDrops          = 0x10
@@ -321,7 +323,9 @@ public:
     Q_INVOKABLE void forceActiveFocus();
     Q_INVOKABLE QQuickItem *childAt(qreal x, qreal y) const;
 
+#ifndef QT_NO_IM
     virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;
+#endif
 
     struct UpdatePaintNodeData {
        QSGTransformNode *transformNode;
@@ -371,7 +375,9 @@ protected:
     bool isComponentComplete() const;
     virtual void itemChange(ItemChange, const ItemChangeData &);
 
+#ifndef QT_NO_IM
     void updateInputMethod(Qt::InputMethodQueries queries = Qt::ImQueryInput);
+#endif
 
     bool widthValid() const; // ### better name?
     bool heightValid() const; // ### better name?
@@ -382,7 +388,9 @@ protected:
 
     virtual void keyPressEvent(QKeyEvent *event);
     virtual void keyReleaseEvent(QKeyEvent *event);
+#ifndef QT_NO_IM
     virtual void inputMethodEvent(QInputMethodEvent *);
+#endif
     virtual void focusInEvent(QFocusEvent *);
     virtual void focusOutEvent(QFocusEvent *);
     virtual void mousePressEvent(QMouseEvent *event);
diff --git a/src/quick/items/qquickitem_p.h b/src/quick/items/qquickitem_p.h
index 1f372b5..363cc93 100644
--- a/src/quick/items/qquickitem_p.h
+++ b/src/quick/items/qquickitem_p.h
@@ -523,7 +523,9 @@ public:
     virtual void transformChanged();
 
     void deliverKeyEvent(QKeyEvent *);
+#ifndef QT_NO_IM
     void deliverInputMethodEvent(QInputMethodEvent *);
+#endif
     void deliverFocusEvent(QFocusEvent *);
     void deliverMouseEvent(QMouseEvent *);
     void deliverWheelEvent(QWheelEvent *);
@@ -593,8 +595,10 @@ public:
 
     virtual void keyPressed(QKeyEvent *event, bool post);
     virtual void keyReleased(QKeyEvent *event, bool post);
+#ifndef QT_NO_IM
     virtual void inputMethodEvent(QInputMethodEvent *event, bool post);
     virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;
+#endif
     virtual void componentComplete();
 
     bool m_processPost;
@@ -809,9 +813,10 @@ Q_SIGNALS:
 private:
     virtual void keyPressed(QKeyEvent *event, bool post);
     virtual void keyReleased(QKeyEvent *event, bool post);
+#ifndef QT_NO_IM
     virtual void inputMethodEvent(QInputMethodEvent *, bool post);
     virtual QVariant inputMethodQuery(Qt::InputMethodQuery query) const;
-
+#endif
     const QByteArray keyToSignal(int key) {
         QByteArray keySignal;
         if (key >= Qt::Key_0 && key <= Qt::Key_9) {
diff --git a/src/quick/items/qquicktext.cpp b/src/quick/items/qquicktext.cpp
index 01136d5..a1516ba 100644
--- a/src/quick/items/qquicktext.cpp
+++ b/src/quick/items/qquicktext.cpp
@@ -1750,7 +1750,11 @@ bool QQuickTextPrivate::setHAlign(QQuickText::HAlignment alignment, bool forceAl
 bool QQuickTextPrivate::determineHorizontalAlignment()
 {
     if (hAlignImplicit) {
+#ifndef QT_NO_IM
         bool alignToRight = text.isEmpty() ? qApp->inputMethod()->inputDirection() == Qt::RightToLeft : rightToLeftText;
+#else
+        bool alignToRight = rightToLeftText;
+#endif
         return setHAlign(alignToRight ? QQuickText::AlignRight : QQuickText::AlignLeft);
     }
     return false;
diff --git a/src/quick/items/qquicktextcontrol.cpp b/src/quick/items/qquicktextcontrol.cpp
index 1b23d5b..d4152c1 100644
--- a/src/quick/items/qquicktextcontrol.cpp
+++ b/src/quick/items/qquicktextcontrol.cpp
@@ -99,7 +99,9 @@ static QTextLine currentTextLine(const QTextCursor &cursor)
 
 QQuickTextControlPrivate::QQuickTextControlPrivate()
     : doc(0),
+#ifndef QT_NO_IM
       preeditCursor(0),
+#endif
       interactionFlags(Qt::TextEditorInteraction),
       cursorOn(false),
       cursorIsFocusIndicator(false),
@@ -285,7 +287,9 @@ void QQuickTextControlPrivate::setContent(Qt::TextFormat format, const QString &
 {
     Q_Q(QQuickTextControl);
 
+#ifndef QT_NO_IM
     cancelPreedit();
+#endif
 
     // for use when called from setPlainText. we may want to re-use the currently
     // set char format then.
@@ -397,8 +401,10 @@ void QQuickTextControlPrivate::selectionChanged(bool forceEmitSelectionChanged /
 {
     Q_Q(QQuickTextControl);
     if (forceEmitSelectionChanged) {
+#ifndef QT_NO_IM
         if (hasFocus)
             qGuiApp->inputMethod()->update(Qt::ImCurrentSelection);
+#endif
         emit q->selectionChanged();
     }
 
@@ -409,8 +415,10 @@ void QQuickTextControlPrivate::selectionChanged(bool forceEmitSelectionChanged /
     lastSelectionState = current;
     emit q->copyAvailable(current);
     if (!forceEmitSelectionChanged) {
+#ifndef QT_NO_IM
         if (hasFocus)
             qGuiApp->inputMethod()->update(Qt::ImCurrentSelection);
+#endif
         emit q->selectionChanged();
     }
     q->updateCursorRectangle(true);
@@ -611,7 +619,9 @@ void QQuickTextControl::updateCursorRectangle(bool force)
 void QQuickTextControl::setTextCursor(const QTextCursor &cursor)
 {
     Q_D(QQuickTextControl);
+#ifndef QT_NO_IM
     d->commitPreedit();
+#endif
     d->cursorIsFocusIndicator = false;
     const bool posChanged = cursor.position() != d->cursor.position();
     const QTextCursor oldSelection = d->cursor;
@@ -703,9 +713,11 @@ void QQuickTextControl::processEvent(QEvent *e, const QMatrix &matrix)
             QMouseEvent *ev = static_cast<QMouseEvent *>(e);
             d->mouseDoubleClickEvent(ev, matrix.map(ev->localPos()));
             break; }
+#ifndef QT_NO_IM
         case QEvent::InputMethod:
             d->inputMethodEvent(static_cast<QInputMethodEvent *>(e));
             break;
+#endif
         case QEvent::FocusIn:
         case QEvent::FocusOut:
             d->focusEvent(static_cast<QFocusEvent *>(e));
@@ -938,6 +950,7 @@ QRectF QQuickTextControlPrivate::rectForPosition(int position) const
     const QTextLayout *layout = block.layout();
     const QPointF layoutPos = q->blockBoundingRect(block).topLeft();
     int relativePos = position - block.position();
+#ifndef QT_NO_IM
     if (preeditCursor != 0) {
         int preeditPos = layout->preeditAreaPosition();
         if (relativePos == preeditPos)
@@ -945,6 +958,7 @@ QRectF QQuickTextControlPrivate::rectForPosition(int position) const
         else if (relativePos > preeditPos)
             relativePos += layout->preeditAreaText().length();
     }
+#endif
     QTextLine line = layout->lineForTextPosition(relativePos);
 
     int cursorWidth;
@@ -1004,7 +1018,9 @@ void QQuickTextControlPrivate::mousePressEvent(QMouseEvent *e, const QPointF &po
     const QTextCursor oldSelection = cursor;
     const int oldCursorPos = cursor.position();
 
+#ifndef QT_NO_IM
     commitPreedit();
+#endif
 
     if (trippleClickTimer.isActive()
         && ((pos - trippleClickPoint).toPoint().manhattanLength() < qApp->styleHints()->startDragDistance())) {
@@ -1076,6 +1092,7 @@ void QQuickTextControlPrivate::mouseMoveEvent(QMouseEvent *e, const QPointF &mou
 
         int newCursorPos = q->hitTest(mousePos, Qt::FuzzyHit);
 
+#ifndef QT_NO_IM
         if (isPreediting()) {
             // note: oldCursorPos not including preedit
             int selectionStartPos = q->hitTest(mousePressPos, Qt::FuzzyHit);
@@ -1087,6 +1104,7 @@ void QQuickTextControlPrivate::mouseMoveEvent(QMouseEvent *e, const QPointF &mou
                 setCursorPosition(selectionStartPos);
             }
         }
+#endif
 
         if (newCursorPos == -1)
             return;
@@ -1100,15 +1118,19 @@ void QQuickTextControlPrivate::mouseMoveEvent(QMouseEvent *e, const QPointF &mou
             extendBlockwiseSelection(newCursorPos);
         else if (selectedWordOnDoubleClick.hasSelection())
             extendWordwiseSelection(newCursorPos, mouseX);
+#ifndef QT_NO_IM
         else if (!isPreediting())
             setCursorPosition(newCursorPos, QTextCursor::KeepAnchor);
+#endif
 
         if (interactionFlags & Qt::TextEditable) {
             if (cursor.position() != oldCursorPos)
                 emit q->cursorPositionChanged();
             _q_updateCurrentCharFormatAndSelection();
+#ifndef QT_NO_IM
             if (qGuiApp)
                 qGuiApp->inputMethod()->update(Qt::ImQueryInput);
+#endif
         } else if (cursor.position() != oldCursorPos) {
             emit q->cursorPositionChanged();
         }
@@ -1180,7 +1202,9 @@ void QQuickTextControlPrivate::mouseDoubleClickEvent(QMouseEvent *e, const QPoin
     Q_Q(QQuickTextControl);
 
     if (e->button() == Qt::LeftButton && (interactionFlags & Qt::TextSelectableByMouse)) {
+#ifndef QT_NO_IM
         commitPreedit();
+#endif
 
         const QTextCursor oldSelection = cursor;
         setCursorPosition(pos);
@@ -1235,6 +1259,7 @@ bool QQuickTextControlPrivate::sendMouseEventToInputContext(QMouseEvent *e, cons
     return false;
 }
 
+#ifndef QT_NO_IM
 void QQuickTextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
 {
     Q_Q(QQuickTextControl);
@@ -1333,6 +1358,7 @@ QVariant QQuickTextControl::inputMethodQuery(Qt::InputMethodQuery property) cons
         return QVariant();
     }
 }
+#endif // QT_NO_IM
 
 void QQuickTextControlPrivate::focusEvent(QFocusEvent *e)
 {
@@ -1568,6 +1594,7 @@ void QQuickTextControlPrivate::activateLinkUnderCursor(QString href)
     emit q_func()->linkActivated(href);
 }
 
+#ifndef QT_NO_IM
 bool QQuickTextControlPrivate::isPreediting() const
 {
     QTextLayout *layout = cursor.block().layout();
@@ -1605,6 +1632,7 @@ void QQuickTextControlPrivate::cancelPreedit()
     QInputMethodEvent event;
     QCoreApplication::sendEvent(q->parent(), &event);
 }
+#endif // QT_NO_IM
 
 void QQuickTextControl::setTextInteractionFlags(Qt::TextInteractionFlags flags)
 {
diff --git a/src/quick/items/qquicktextcontrol_p.h b/src/quick/items/qquicktextcontrol_p.h
index 25c09fd..2ca56c7 100644
--- a/src/quick/items/qquicktextcontrol_p.h
+++ b/src/quick/items/qquicktextcontrol_p.h
@@ -157,7 +157,9 @@ public:
     virtual void processEvent(QEvent *e, const QMatrix &matrix);
     void processEvent(QEvent *e, const QPointF &coordinateOffset = QPointF());
 
+#ifndef QT_NO_IM
     virtual QVariant inputMethodQuery(Qt::InputMethodQuery property) const;
+#endif
 
     virtual QMimeData *createMimeDataFromSelection() const;
     virtual bool canInsertFromMimeData(const QMimeData *source) const;
diff --git a/src/quick/items/qquicktextcontrol_p_p.h b/src/quick/items/qquicktextcontrol_p_p.h
index 4a0bafb..abdad43 100644
--- a/src/quick/items/qquicktextcontrol_p_p.h
+++ b/src/quick/items/qquicktextcontrol_p_p.h
@@ -114,13 +114,17 @@ public:
     void mouseDoubleClickEvent(QMouseEvent *event, const QPointF &pos);
     bool sendMouseEventToInputContext(QMouseEvent *event, const QPointF &pos);
     void focusEvent(QFocusEvent *e);
+#ifndef QT_NO_IM
     void inputMethodEvent(QInputMethodEvent *);
+#endif
 
     void activateLinkUnderCursor(QString href = QString());
 
+#ifndef QT_NO_IM
     bool isPreediting() const;
     void commitPreedit();
     void cancelPreedit();
+#endif
 
     QPointF trippleClickPoint;
     QPointF mousePressPos;
@@ -137,7 +141,9 @@ public:
     QBasicTimer cursorBlinkTimer;
     QBasicTimer trippleClickTimer;
 
+#ifndef QT_NO_IM
     int preeditCursor;
+#endif
 
     Qt::TextInteractionFlags interactionFlags;
 
diff --git a/src/quick/items/qquicktextedit.cpp b/src/quick/items/qquicktextedit.cpp
index d886155..8cf145a 100644
--- a/src/quick/items/qquicktextedit.cpp
+++ b/src/quick/items/qquicktextedit.cpp
@@ -410,7 +410,9 @@ void QQuickTextEdit::setFont(const QFont &font)
         }
         updateSize();
         updateDocument();
+#ifndef QT_NO_IM
         updateInputMethod(Qt::ImCursorRectangle | Qt::ImFont);
+#endif
     }
     emit fontChanged(d->sourceFont);
 }
@@ -606,12 +608,14 @@ bool QQuickTextEditPrivate::determineHorizontalAlignment()
     Q_Q(QQuickTextEdit);
     if (hAlignImplicit && q->isComponentComplete()) {
         Qt::LayoutDirection direction = contentDirection;
+#ifndef QT_NO_IM
         if (direction == Qt::LayoutDirectionAuto) {
             const QString preeditText = control->textCursor().block().layout()->preeditAreaText();
             direction = textDirection(preeditText);
         }
         if (direction == Qt::LayoutDirectionAuto)
             direction = qGuiApp->inputMethod()->inputDirection();
+#endif
 
         return setHAlign(direction == Qt::RightToLeft ? QQuickTextEdit::AlignRight : QQuickTextEdit::AlignLeft);
     }
@@ -802,6 +806,7 @@ int QQuickTextEdit::positionAt(qreal x, qreal y) const
     y -= d->yoff;
 
     int r = d->document->documentLayout()->hitTest(QPointF(x, y), Qt::FuzzyHit);
+#ifndef QT_NO_IM
     QTextCursor cursor = d->control->textCursor();
     if (r > cursor.position()) {
         // The cursor position includes positions within the preedit text, but only positions in the
@@ -818,6 +823,7 @@ int QQuickTextEdit::positionAt(qreal x, qreal y) const
                     : cursor.position();
         }
     }
+#endif
     return r;
 }
 
@@ -1165,6 +1171,7 @@ void QQuickTextEdit::setTextMargin(qreal margin)
     \endlist
 */
 
+#ifndef QT_NO_IM
 Qt::InputMethodHints QQuickTextEdit::inputMethodHints() const
 {
     Q_D(const QQuickTextEdit);
@@ -1182,6 +1189,7 @@ void QQuickTextEdit::setInputMethodHints(Qt::InputMethodHints hints)
     updateInputMethod(Qt::ImHints);
     emit inputMethodHintsChanged();
 }
+#endif // QT_NO_IM
 
 void QQuickTextEdit::geometryChanged(const QRectF &newGeometry,
                                   const QRectF &oldGeometry)
@@ -1294,7 +1302,9 @@ void QQuickTextEdit::setReadOnly(bool r)
     if (r == isReadOnly())
         return;
 
+#ifndef QT_NO_IM
     setFlag(QQuickItem::ItemAcceptsInputMethod, !r);
+#endif
     Qt::TextInteractionFlags flags = Qt::LinksAccessibleByMouse;
     if (d->selectByMouse)
         flags = flags | Qt::TextSelectableByMouse;
@@ -1304,7 +1314,9 @@ void QQuickTextEdit::setReadOnly(bool r)
     if (!r)
         d->control->moveCursor(QTextCursor::End);
 
+#ifndef QT_NO_IM
     updateInputMethod(Qt::ImEnabled);
+#endif
     q_canPasteChanged();
     emit readOnlyChanged(r);
 }
@@ -1521,8 +1533,10 @@ void QQuickTextEdit::mousePressEvent(QMouseEvent *event)
         bool hadActiveFocus = hasActiveFocus();
         forceActiveFocus();
         // re-open input panel on press if already focused
+#ifndef QT_NO_IM
         if (hasActiveFocus() && hadActiveFocus && !isReadOnly())
             qGuiApp->inputMethod()->show();
+#endif
     }
     if (!event->isAccepted())
         QQuickImplicitSizeItem::mousePressEvent(event);
@@ -1565,6 +1579,7 @@ void QQuickTextEdit::mouseMoveEvent(QMouseEvent *event)
         QQuickImplicitSizeItem::mouseMoveEvent(event);
 }
 
+#ifndef QT_NO_IM
 /*!
 \overload
 Handles the given input method \a event.
@@ -1578,6 +1593,7 @@ void QQuickTextEdit::inputMethodEvent(QInputMethodEvent *event)
     if (wasComposing != isInputMethodComposing())
         emit inputMethodComposingChanged();
 }
+#endif // QT_NO_IM
 
 void QQuickTextEdit::itemChange(ItemChange change, const ItemChangeData &value)
 {
@@ -1588,16 +1604,19 @@ void QQuickTextEdit::itemChange(ItemChange change, const ItemChangeData &value)
         d->control->processEvent(&focusEvent, QPointF(-d->xoff, -d->yoff));
         if (value.boolValue) {
             q_updateAlignment();
+#ifndef QT_NO_IM
             connect(qApp->inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
                     this, SLOT(q_updateAlignment()));
         } else {
             disconnect(qApp->inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
                        this, SLOT(q_updateAlignment()));
+#endif
         }
     }
     QQuickItem::itemChange(change, value);
 }
 
+#ifndef QT_NO_IM
 /*!
 \overload
 Returns the value of the given \a property.
@@ -1621,6 +1640,7 @@ QVariant QQuickTextEdit::inputMethodQuery(Qt::InputMethodQuery property) const
     return v;
 
 }
+#endif // QT_NO_IM
 
 void QQuickTextEdit::triggerPreprocess()
 {
@@ -1726,6 +1746,7 @@ bool QQuickTextEdit::canRedo() const
     return d->document->isRedoAvailable();
 }
 
+#ifndef QT_NO_IM
 /*!
     \qmlproperty bool QtQuick2::TextEdit::inputMethodComposing
 
@@ -1743,6 +1764,7 @@ bool QQuickTextEdit::isInputMethodComposing() const
     Q_D(const QQuickTextEdit);
     return d->control->hasImState();
 }
+#endif // QT_NO_IM
 
 void QQuickTextEditPrivate::init()
 {
@@ -1755,7 +1777,9 @@ void QQuickTextEditPrivate::init()
 #endif
         q->setAcceptedMouseButtons(Qt::LeftButton);
 
+#ifndef QT_NO_IM
     q->setFlag(QQuickItem::ItemAcceptsInputMethod);
+#endif
     q->setFlag(QQuickItem::ItemHasContents);
 
     document = new QQuickTextDocumentWithImageResources(q);
@@ -1807,7 +1831,9 @@ void QQuickTextEdit::q_textChanged()
 void QQuickTextEdit::moveCursorDelegate()
 {
     Q_D(QQuickTextEdit);
+#ifndef QT_NO_IM
     updateInputMethod();
+#endif
     emit cursorRectangleChanged();
     if (!d->cursorItem)
         return;
@@ -2012,9 +2038,12 @@ void QQuickTextEditPrivate::updateDefaultTextOption()
     else
         opt.setAlignment(Qt::Alignment(vAlign));
 
+#ifndef QT_NO_IM
     if (contentDirection == Qt::LayoutDirectionAuto) {
         opt.setTextDirection(qGuiApp->inputMethod()->inputDirection());
-    } else {
+    } else
+#endif
+    {
         opt.setTextDirection(contentDirection);
     }
 
@@ -2034,8 +2063,10 @@ void QQuickTextEditPrivate::updateDefaultTextOption()
 void QQuickTextEdit::focusInEvent(QFocusEvent *event)
 {
     Q_D(const QQuickTextEdit);
+#ifndef QT_NO_IM
     if (d->focusOnPress && !isReadOnly())
         qGuiApp->inputMethod()->show();
+#endif
     QQuickImplicitSizeItem::focusInEvent(event);
 }
 
diff --git a/src/quick/items/qquicktextedit_p.h b/src/quick/items/qquicktextedit_p.h
index ae0e370..c87ac20 100644
--- a/src/quick/items/qquicktextedit_p.h
+++ b/src/quick/items/qquicktextedit_p.h
@@ -88,13 +88,17 @@ class Q_AUTOTEST_EXPORT QQuickTextEdit : public QQuickImplicitSizeItem
     Q_PROPERTY(bool activeFocusOnPress READ focusOnPress WRITE setFocusOnPress NOTIFY activeFocusOnPressChanged)
     Q_PROPERTY(bool persistentSelection READ persistentSelection WRITE setPersistentSelection NOTIFY persistentSelectionChanged)
     Q_PROPERTY(qreal textMargin READ textMargin WRITE setTextMargin NOTIFY textMarginChanged)
+#ifndef QT_NO_IM
     Q_PROPERTY(Qt::InputMethodHints inputMethodHints READ inputMethodHints WRITE setInputMethodHints NOTIFY inputMethodHintsChanged)
+#endif
     Q_PROPERTY(bool selectByMouse READ selectByMouse WRITE setSelectByMouse NOTIFY selectByMouseChanged)
     Q_PROPERTY(SelectionMode mouseSelectionMode READ mouseSelectionMode WRITE setMouseSelectionMode NOTIFY mouseSelectionModeChanged)
     Q_PROPERTY(bool canPaste READ canPaste NOTIFY canPasteChanged)
     Q_PROPERTY(bool canUndo READ canUndo NOTIFY canUndoChanged)
     Q_PROPERTY(bool canRedo READ canRedo NOTIFY canRedoChanged)
+#ifndef QT_NO_IM
     Q_PROPERTY(bool inputMethodComposing READ isInputMethodComposing NOTIFY inputMethodComposingChanged)
+#endif
     Q_PROPERTY(QUrl baseUrl READ baseUrl WRITE setBaseUrl RESET resetBaseUrl NOTIFY baseUrlChanged)
     Q_PROPERTY(RenderType renderType READ renderType WRITE setRenderType NOTIFY renderTypeChanged)
 
@@ -192,8 +196,10 @@ public:
     qreal textMargin() const;
     void setTextMargin(qreal margin);
 
+#ifndef QT_NO_IM
     Qt::InputMethodHints inputMethodHints() const;
     void setInputMethodHints(Qt::InputMethodHints hints);
+#endif
 
     bool selectByMouse() const;
     void setSelectByMouse(bool);
@@ -214,7 +220,9 @@ public:
 
     QRectF cursorRectangle() const;
 
+#ifndef QT_NO_IM
     QVariant inputMethodQuery(Qt::InputMethodQuery property) const;
+#endif
 
     qreal contentWidth() const;
     qreal contentHeight() const;
@@ -231,7 +239,9 @@ public:
     QRectF boundingRect() const;
     QRectF clipRect() const;
 
+#ifndef QT_NO_IM
     bool isInputMethodComposing() const;
+#endif
 
     RenderType renderType() const;
     void setRenderType(RenderType renderType);
@@ -268,10 +278,14 @@ Q_SIGNALS:
     void canPasteChanged();
     void canUndoChanged();
     void canRedoChanged();
+#ifndef QT_NO_IM
     void inputMethodComposingChanged();
+#endif
     void effectiveHorizontalAlignmentChanged();
     void baseUrlChanged();
+#ifndef QT_NO_IM
     void inputMethodHintsChanged();
+#endif
     void renderTypeChanged();
 
 public Q_SLOTS:
@@ -319,7 +333,9 @@ protected:
     void mouseReleaseEvent(QMouseEvent *event);
     void mouseDoubleClickEvent(QMouseEvent *event);
     void mouseMoveEvent(QMouseEvent *event);
+#ifndef QT_NO_IM
     void inputMethodEvent(QInputMethodEvent *e);
+#endif
     virtual void itemChange(ItemChange, const ItemChangeData &);
 
     QSGNode *updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData);
diff --git a/src/quick/items/qquicktextedit_p_p.h b/src/quick/items/qquicktextedit_p_p.h
index b79f470..106e8c0 100644
--- a/src/quick/items/qquicktextedit_p_p.h
+++ b/src/quick/items/qquicktextedit_p_p.h
@@ -78,7 +78,10 @@ public:
         , format(QQuickTextEdit::PlainText), wrapMode(QQuickTextEdit::NoWrap)
         , renderType(QQuickTextEdit::QtRendering)
         , contentDirection(Qt::LayoutDirectionAuto)
-        , mouseSelectionMode(QQuickTextEdit::SelectCharacters), inputMethodHints(Qt::ImhNone)
+        , mouseSelectionMode(QQuickTextEdit::SelectCharacters)
+#ifndef QT_NO_IM
+        , inputMethodHints(Qt::ImhNone)
+#endif
         , updateType(UpdatePaintNode)
         , documentDirty(true), dirty(false), richText(false), cursorVisible(false), cursorPending(false)
         , focusOnPress(true), persistentSelection(false), requireImplicitWidth(false)
@@ -139,7 +142,9 @@ public:
     QQuickTextEdit::RenderType renderType;
     Qt::LayoutDirection contentDirection;
     QQuickTextEdit::SelectionMode mouseSelectionMode;
+#ifndef QT_NO_IM
     Qt::InputMethodHints inputMethodHints;
+#endif
     UpdateType updateType;
 
     bool documentDirty : 1;
diff --git a/src/quick/items/qquicktextinput.cpp b/src/quick/items/qquicktextinput.cpp
index 88e6d75..8cee9eb 100644
--- a/src/quick/items/qquicktextinput.cpp
+++ b/src/quick/items/qquicktextinput.cpp
@@ -130,7 +130,9 @@ void QQuickTextInput::setText(const QString &s)
     if (s == text())
         return;
 
+#ifndef QT_NO_IM
     d->cancelPreedit();
+#endif
     d->internalSetText(s, -1, false);
 }
 
@@ -340,7 +342,9 @@ void QQuickTextInput::setFont(const QFont &font)
     if (oldFont != d->font) {
         d->updateLayout();
         updateCursorRectangle();
+#ifndef QT_NO_IM
         updateInputMethod(Qt::ImCursorRectangle | Qt::ImFont);
+#endif
     }
     emit fontChanged(d->sourceFont);
 }
@@ -510,8 +514,10 @@ bool QQuickTextInputPrivate::setHAlign(QQuickTextInput::HAlignment alignment, bo
 Qt::LayoutDirection QQuickTextInputPrivate::textDirection() const
 {
     QString text = m_text;
+#ifndef QT_NO_IM
     if (text.isEmpty())
         text = m_textLayout.preeditAreaText();
+#endif
 
     const QChar *character = text.constData();
     while (!character->isNull()) {
@@ -535,8 +541,10 @@ Qt::LayoutDirection QQuickTextInputPrivate::layoutDirection() const
     Qt::LayoutDirection direction = m_layoutDirection;
     if (direction == Qt::LayoutDirectionAuto) {
         direction = textDirection();
+#ifndef QT_NO_IM
         if (direction == Qt::LayoutDirectionAuto)
             direction = qApp->inputMethod()->inputDirection();
+#endif
     }
     return (direction == Qt::LayoutDirectionAuto) ? Qt::LeftToRight : direction;
 }
@@ -546,8 +554,10 @@ bool QQuickTextInputPrivate::determineHorizontalAlignment()
     if (hAlignImplicit) {
         // if no explicit alignment has been set, follow the natural layout direction of the text
         Qt::LayoutDirection direction = textDirection();
+#ifndef QT_NO_IM
         if (direction == Qt::LayoutDirectionAuto)
             direction = qApp->inputMethod()->inputDirection();
+#endif
         return setHAlign(direction == Qt::RightToLeft ? QQuickTextInput::AlignRight : QQuickTextInput::AlignLeft);
     }
     return false;
@@ -635,11 +645,15 @@ void QQuickTextInput::setReadOnly(bool ro)
     if (d->m_readOnly == ro)
         return;
 
+#ifndef QT_NO_IM
     setFlag(QQuickItem::ItemAcceptsInputMethod, !ro);
+#endif
     d->m_readOnly = ro;
     if (!ro)
         d->setCursorPosition(d->end());
+#ifndef QT_NO_IM
     updateInputMethod(Qt::ImEnabled);
+#endif
     q_canPasteChanged();
     d->emitUndoRedoChanged();
     emit readOnlyChanged(ro);
@@ -751,7 +765,10 @@ QRectF QQuickTextInput::cursorRectangle() const
 {
     Q_D(const QQuickTextInput);
 
-    int c = d->m_cursor + d->m_preeditCursor;
+    int c = d->m_cursor;
+#ifndef QT_NO_IM
+    c += d->m_preeditCursor;
+#endif
     if (d->m_echoMode == NoEcho)
         c = 0;
     QTextLine l = d->m_textLayout.lineForTextPosition(c);
@@ -1186,6 +1203,7 @@ bool QQuickTextInput::hasAcceptableInput() const
     state.
 */
 
+#ifndef QT_NO_IM
 Qt::InputMethodHints QQuickTextInputPrivate::effectiveInputMethodHints() const
 {
     Qt::InputMethodHints hints = inputMethodHints;
@@ -1197,6 +1215,8 @@ Qt::InputMethodHints QQuickTextInputPrivate::effectiveInputMethodHints() const
         hints |= (Qt::ImhNoAutoUppercase | Qt::ImhNoPredictiveText | Qt::ImhSensitiveData);
     return hints;
 }
+#endif
+
 /*!
     \qmlproperty enumeration QtQuick2::TextInput::echoMode
 
@@ -1223,13 +1243,16 @@ void QQuickTextInput::setEchoMode(QQuickTextInput::EchoMode echo)
     d->cancelPasswordEchoTimer();
     d->m_echoMode = echo;
     d->m_passwordEchoEditing = false;
+#ifndef QT_NO_IM
     updateInputMethod(Qt::ImHints);
+#endif
     d->updateDisplayText();
     updateCursorRectangle();
 
     emit echoModeChanged(echoMode());
 }
 
+#ifndef QT_NO_IM
 /*!
     \qmlproperty enumeration QtQuick2::TextInput::inputMethodHints
 
@@ -1292,6 +1315,7 @@ void QQuickTextInput::setInputMethodHints(Qt::InputMethodHints hints)
     updateInputMethod(Qt::ImHints);
     emit inputMethodHintsChanged();
 }
+#endif // QT_NO_IM
 
 /*!
     \qmlproperty Component QtQuick2::TextInput::cursorDelegate
@@ -1339,8 +1363,10 @@ QRectF QQuickTextInput::positionToRectangle(int pos) const
     Q_D(const QQuickTextInput);
     if (d->m_echoMode == NoEcho)
         pos = 0;
+#ifndef QT_NO_IM
     else if (pos > d->m_cursor)
         pos += d->preeditAreaText().length();
+#endif
     QTextLine l = d->m_textLayout.lineForTextPosition(pos);
     return l.isValid()
             ? QRectF(l.cursorToX(pos) - d->hscroll, l.y() - d->vscroll, 1, l.height())
@@ -1397,10 +1423,14 @@ void QQuickTextInput::positionAt(QQmlV8Function *args) const
     int pos = d->positionAt(x, y, position);
     const int cursor = d->m_cursor;
     if (pos > cursor) {
+#ifndef QT_NO_IM
         const int preeditLength = d->preeditAreaText().length();
         pos = pos > cursor + preeditLength
                 ? pos - preeditLength
                 : cursor;
+#else
+        pos = cursor;
+#endif
     }
     args->returnValue(v8::Int32::New(pos));
 }
@@ -1443,6 +1473,7 @@ void QQuickTextInput::keyPressEvent(QKeyEvent* ev)
         QQuickImplicitSizeItem::keyPressEvent(ev);
 }
 
+#ifndef QT_NO_IM
 void QQuickTextInput::inputMethodEvent(QInputMethodEvent *ev)
 {
     Q_D(QQuickTextInput);
@@ -1458,13 +1489,16 @@ void QQuickTextInput::inputMethodEvent(QInputMethodEvent *ev)
     if (wasComposing != d->hasImState)
         emit inputMethodComposingChanged();
 }
+#endif
 
 void QQuickTextInput::mouseDoubleClickEvent(QMouseEvent *event)
 {
     Q_D(QQuickTextInput);
 
     if (d->selectByMouse && event->button() == Qt::LeftButton) {
+#ifndef QT_NO_IM
         d->commitPreedit();
+#endif
         int cursor = d->positionAt(event->localPos());
         d->selectWordAtPos(cursor);
         event->setAccepted(true);
@@ -1507,9 +1541,11 @@ void QQuickTextInput::mousePressEvent(QMouseEvent *event)
     if (d->focusOnPress) {
         bool hadActiveFocus = hasActiveFocus();
         forceActiveFocus();
+#ifndef QT_NO_IM
         // re-open input panel on press if already focused
         if (hasActiveFocus() && hadActiveFocus && !d->m_readOnly)
             qGuiApp->inputMethod()->show();
+#endif
     }
 
     event->setAccepted(true);
@@ -1523,13 +1559,16 @@ void QQuickTextInput::mouseMoveEvent(QMouseEvent *event)
         if (qAbs(int(event->localPos().x() - d->pressPos.x())) > qApp->styleHints()->startDragDistance())
             setKeepMouseGrab(true);
 
+#ifndef QT_NO_IM
         if (d->composeMode()) {
             // start selection
             int startPos = d->positionAt(d->pressPos);
             int currentPos = d->positionAt(event->localPos());
             if (startPos != currentPos)
                 d->setSelection(startPos, currentPos - startPos);
-        } else {
+        } else
+#endif
+        {
             moveCursorSelection(d->positionAt(event->localPos()), d->mouseSelectionMode);
         }
         event->setAccepted(true);
@@ -1576,7 +1615,6 @@ bool QQuickTextInputPrivate::sendMouseEventToInputContext(QMouseEvent *event)
     }
 #else
     Q_UNUSED(event);
-    Q_UNUSED(eventType)
 #endif
 
     return false;
@@ -1656,13 +1694,21 @@ void QQuickTextInput::geometryChanged(const QRectF &newGeometry,
 void QQuickTextInputPrivate::updateHorizontalScroll()
 {
     Q_Q(QQuickTextInput);
+#ifndef QT_NO_IM
     QTextLine currentLine = m_textLayout.lineForTextPosition(m_cursor + m_preeditCursor);
     const int preeditLength = m_textLayout.preeditAreaText().length();
+#else
+    QTextLine currentLine = m_textLayout.lineForTextPosition(m_cursor);
+#endif
     const qreal width = qMax<qreal>(0, q->width());
     qreal cix = 0;
     qreal widthUsed = 0;
     if (currentLine.isValid()) {
+#ifndef QT_NO_IM
         cix = currentLine.cursorToX(m_cursor + preeditLength);
+#else
+        cix = currentLine.cursorToX(m_cursor);
+#endif
         const qreal cursorWidth = cix >= 0 ? cix : width - cix;
         widthUsed = qMax(currentLine.naturalTextWidth(), cursorWidth);
     }
@@ -1687,6 +1733,7 @@ void QQuickTextInputPrivate::updateHorizontalScroll()
             // left
             hscroll = width - widthUsed;
         }
+#ifndef QT_NO_IM
         if (preeditLength > 0) {
             // check to ensure long pre-edit text doesn't push the cursor
             // off to the left
@@ -1694,6 +1741,7 @@ void QQuickTextInputPrivate::updateHorizontalScroll()
              if (cix < hscroll)
                  hscroll = cix;
         }
+#endif
     }
     if (previousScroll != hscroll)
         textLayoutDirty = true;
@@ -1702,7 +1750,9 @@ void QQuickTextInputPrivate::updateHorizontalScroll()
 void QQuickTextInputPrivate::updateVerticalScroll()
 {
     Q_Q(QQuickTextInput);
+#ifndef QT_NO_IM
     const int preeditLength = m_textLayout.preeditAreaText().length();
+#endif
     const qreal height = qMax<qreal>(0, q->height());
     qreal heightUsed = contentSize.height();
     qreal previousScroll = vscroll;
@@ -1712,7 +1762,11 @@ void QQuickTextInputPrivate::updateVerticalScroll()
         vscroll = -QQuickTextUtil::alignedY(
                     heightUsed, height, vAlign & ~(Qt::AlignAbsolute|Qt::AlignHorizontal_Mask));
     } else {
+#ifndef QT_NO_IM
         QTextLine currentLine = m_textLayout.lineForTextPosition(m_cursor + preeditLength);
+#else
+        QTextLine currentLine = m_textLayout.lineForTextPosition(m_cursor);
+#endif
         QRectF r = currentLine.isValid() ? currentLine.rect() : QRectF();
         qreal top = r.top();
         int bottom = r.bottom();
@@ -1728,6 +1782,7 @@ void QQuickTextInputPrivate::updateVerticalScroll()
             // right
             vscroll = heightUsed - height;
         }
+#ifndef QT_NO_IM
         if (preeditLength > 0) {
             // check to ensure long pre-edit text doesn't push the cursor
             // off the top
@@ -1736,6 +1791,7 @@ void QQuickTextInputPrivate::updateVerticalScroll()
             if (top < vscroll)
                 vscroll = top;
         }
+#endif
     }
     if (previousScroll != vscroll)
         textLayoutDirty = true;
@@ -1792,7 +1848,11 @@ QSGNode *QQuickTextInput::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData
             offset = -QPoint(d->hscroll, d->vscroll);
         }
 
-        if (!d->m_textLayout.text().isEmpty() || !d->m_textLayout.preeditAreaText().isEmpty()) {
+        if (!d->m_textLayout.text().isEmpty()
+#ifndef QT_NO_IM
+                || !d->m_textLayout.preeditAreaText().isEmpty()
+#endif
+                ) {
             node->addTextLayout(offset, &d->m_textLayout, d->color,
                                 QQuickText::Normal, QColor(), QColor(),
                                 d->selectionColor, d->selectedTextColor,
@@ -1816,6 +1876,7 @@ QSGNode *QQuickTextInput::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData
     return node;
 }
 
+#ifndef QT_NO_IM
 QVariant QQuickTextInput::inputMethodQuery(Qt::InputMethodQuery property) const
 {
     Q_D(const QQuickTextInput);
@@ -1851,6 +1912,7 @@ QVariant QQuickTextInput::inputMethodQuery(Qt::InputMethodQuery property) const
         return QVariant();
     }
 }
+#endif // QT_NO_IM
 
 /*!
     \qmlmethod QtQuick2::TextInput::deselect()
@@ -2415,8 +2477,10 @@ void QQuickTextInput::moveCursorSelection(int pos, SelectionMode mode)
 void QQuickTextInput::focusInEvent(QFocusEvent *event)
 {
     Q_D(const QQuickTextInput);
+#ifndef QT_NO_IM
     if (d->focusOnPress && !d->m_readOnly)
         qGuiApp->inputMethod()->show();
+#endif
     QQuickImplicitSizeItem::focusInEvent(event);
 }
 
@@ -2433,17 +2497,22 @@ void QQuickTextInput::itemChange(ItemChange change, const ItemChangeData &value)
         if (!hasFocus) {
             if (!d->persistentSelection)
                 d->deselect();
+#ifndef QT_NO_IM
             disconnect(qApp->inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
                        this, SLOT(q_updateAlignment()));
+#endif
         } else {
             q_updateAlignment();
+#ifndef QT_NO_IM
             connect(qApp->inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
                     this, SLOT(q_updateAlignment()));
+#endif
         }
     }
     QQuickItem::itemChange(change, value);
 }
 
+#ifndef QT_NO_IM
 /*!
     \qmlproperty bool QtQuick2::TextInput::inputMethodComposing
 
@@ -2461,6 +2530,7 @@ bool QQuickTextInput::isInputMethodComposing() const
     Q_D(const QQuickTextInput);
     return d->hasImState;
 }
+#endif
 
 void QQuickTextInputPrivate::init()
 {
@@ -2472,7 +2542,9 @@ void QQuickTextInputPrivate::init()
 #endif
         q->setAcceptedMouseButtons(Qt::LeftButton);
 
+#ifndef QT_NO_IM
     q->setFlag(QQuickItem::ItemAcceptsInputMethod);
+#endif
     q->setFlag(QQuickItem::ItemHasContents);
 #ifndef QT_NO_CLIPBOARD
     q->connect(QGuiApplication::clipboard(), SIGNAL(dataChanged()),
@@ -2506,7 +2578,9 @@ void QQuickTextInput::updateCursorRectangle()
         d->cursorItem->setPos(r.topLeft());
         d->cursorItem->setHeight(r.height());
     }
+#ifndef QT_NO_IM
     updateInputMethod(Qt::ImCursorRectangle);
+#endif
 }
 
 void QQuickTextInput::selectionChanged()
@@ -2673,7 +2747,9 @@ qreal QQuickTextInputPrivate::getImplicitWidth() const
             option.setAlignment(Qt::Alignment(q->effectiveHAlign()));
             layout.setTextOption(option);
             layout.setFont(font);
+#ifndef QT_NO_IM
             layout.setPreeditArea(m_textLayout.preeditAreaPosition(), m_textLayout.preeditAreaText());
+#endif
             layout.beginLayout();
 
             QTextLine line = layout.createLine();
@@ -2789,6 +2865,7 @@ void QQuickTextInputPrivate::paste(QClipboard::Mode clipboardMode)
 
 #endif // !QT_NO_CLIPBOARD
 
+#ifndef QT_NO_IM
 /*!
     \internal
 */
@@ -2820,6 +2897,7 @@ void QQuickTextInputPrivate::cancelPreedit()
     QInputMethodEvent ev;
     QCoreApplication::sendEvent(q, &ev);
 }
+#endif // QT_NO_IM
 
 /*!
     \internal
@@ -2919,7 +2997,9 @@ void QQuickTextInputPrivate::clear()
 void QQuickTextInputPrivate::setSelection(int start, int length)
 {
     Q_Q(QQuickTextInput);
+#ifndef QT_NO_IM
     commitPreedit();
+#endif
 
     if (start < 0 || start > (int)m_text.length()){
         qWarning("QQuickTextInputPrivate::setSelection: Invalid start position");
@@ -2949,8 +3029,10 @@ void QQuickTextInputPrivate::setSelection(int start, int length)
     }
     emit q->selectionChanged();
     emitCursorPositionChanged();
+#ifndef QT_NO_IM
     q->updateInputMethod(Qt::ImCursorRectangle | Qt::ImAnchorPosition
                         | Qt::ImCursorPosition | Qt::ImCurrentSelection);
+#endif
 }
 
 /*!
@@ -3001,7 +3083,9 @@ bool QQuickTextInputPrivate::fixup() // this function assumes that validate curr
 void QQuickTextInputPrivate::moveCursor(int pos, bool mark)
 {
     Q_Q(QQuickTextInput);
+#ifndef QT_NO_IM
     commitPreedit();
+#endif
 
     if (pos != m_cursor) {
         separate();
@@ -3027,9 +3111,12 @@ void QQuickTextInputPrivate::moveCursor(int pos, bool mark)
         emit q->selectionChanged();
     }
     emitCursorPositionChanged();
+#ifndef QT_NO_IM
     q->updateInputMethod();
+#endif
 }
 
+#ifndef QT_NO_IM
 /*!
     \internal
 
@@ -3099,9 +3186,7 @@ void QQuickTextInputPrivate::processInputMethodEvent(QInputMethodEvent *event)
             cursorPositionChanged = true;
         }
     }
-#ifndef QT_NO_IM
     m_textLayout.setPreeditArea(m_cursor, event->preeditString());
-#endif //QT_NO_IM
     const int oldPreeditCursor = m_preeditCursor;
     m_preeditCursor = event->preeditString().length();
     hasImState = !event->preeditString().isEmpty();
@@ -3145,6 +3230,7 @@ void QQuickTextInputPrivate::processInputMethodEvent(QInputMethodEvent *event)
                             | Qt::ImCursorPosition | Qt::ImCurrentSelection);
     }
 }
+#endif // QT_NO_IM
 
 /*!
     \internal
@@ -3184,7 +3270,9 @@ bool QQuickTextInputPrivate::finishChange(int validateFromState, bool update, bo
     Q_Q(QQuickTextInput);
 
     Q_UNUSED(update)
+#ifndef QT_NO_IM
     bool inputMethodAttributesChanged = m_textDirty || m_selDirty;
+#endif
     bool alignmentChanged = false;
 
     if (m_textDirty) {
@@ -3221,7 +3309,9 @@ bool QQuickTextInputPrivate::finishChange(int validateFromState, bool update, bo
 
         if (m_textDirty) {
             m_textDirty = false;
+#ifndef QT_NO_IM
             m_preeditDirty = false;
+#endif
             alignmentChanged = determineHorizontalAlignment();
             emit q->textChanged();
         }
@@ -3231,6 +3321,7 @@ bool QQuickTextInputPrivate::finishChange(int validateFromState, bool update, bo
         if (m_acceptableInput != wasAcceptable)
             emit q->acceptableInputChanged();
     }
+#ifndef QT_NO_IM
     if (m_preeditDirty) {
         m_preeditDirty = false;
         if (determineHorizontalAlignment()) {
@@ -3238,15 +3329,18 @@ bool QQuickTextInputPrivate::finishChange(int validateFromState, bool update, bo
             updateLayout();
         }
     }
+#endif
 
     if (m_selDirty) {
         m_selDirty = false;
         emit q->selectionChanged();
     }
 
+#ifndef QT_NO_IM
     inputMethodAttributesChanged |= (m_cursor != m_lastCursorPos);
     if (inputMethodAttributesChanged)
         q->updateInputMethod();
+#endif
     emitUndoRedoChanged();
 
     if (!emitCursorPositionChanged() && alignmentChanged)
diff --git a/src/quick/items/qquicktextinput_p.h b/src/quick/items/qquicktextinput_p.h
index d3559f6..419ec0e 100644
--- a/src/quick/items/qquicktextinput_p.h
+++ b/src/quick/items/qquicktextinput_p.h
@@ -88,7 +88,9 @@ class Q_AUTOTEST_EXPORT QQuickTextInput : public QQuickImplicitSizeItem
     Q_PROPERTY(QValidator* validator READ validator WRITE setValidator NOTIFY validatorChanged)
 #endif
     Q_PROPERTY(QString inputMask READ inputMask WRITE setInputMask NOTIFY inputMaskChanged)
+#ifndef QT_NO_IM
     Q_PROPERTY(Qt::InputMethodHints inputMethodHints READ inputMethodHints WRITE setInputMethodHints NOTIFY inputMethodHintsChanged)
+#endif
 
     Q_PROPERTY(bool acceptableInput READ hasAcceptableInput NOTIFY acceptableInputChanged)
     Q_PROPERTY(EchoMode echoMode READ echoMode WRITE setEchoMode NOTIFY echoModeChanged)
@@ -104,7 +106,9 @@ class Q_AUTOTEST_EXPORT QQuickTextInput : public QQuickImplicitSizeItem
 #endif
     Q_PROPERTY(bool canUndo READ canUndo NOTIFY canUndoChanged)
     Q_PROPERTY(bool canRedo READ canRedo NOTIFY canRedoChanged)
+#ifndef QT_NO_IM
     Q_PROPERTY(bool inputMethodComposing READ isInputMethodComposing NOTIFY inputMethodComposingChanged)
+#endif
     Q_PROPERTY(qreal contentWidth READ contentWidth NOTIFY contentSizeChanged)
     Q_PROPERTY(qreal contentHeight READ contentHeight NOTIFY contentSizeChanged)
     Q_PROPERTY(RenderType renderType READ renderType WRITE setRenderType NOTIFY renderTypeChanged)
@@ -247,7 +251,9 @@ public:
 
     bool hasAcceptableInput() const;
 
+#ifndef QT_NO_IM
     QVariant inputMethodQuery(Qt::InputMethodQuery property) const;
+#endif
 
     QRectF boundingRect() const;
     QRectF clipRect() const;
@@ -259,10 +265,12 @@ public:
     bool canUndo() const;
     bool canRedo() const;
 
+#ifndef QT_NO_IM
     bool isInputMethodComposing() const;
 
     Qt::InputMethodHints inputMethodHints() const;
     void setInputMethodHints(Qt::InputMethodHints hints);
+#endif
 
     Q_INVOKABLE QString getText(int start, int end) const;
 
@@ -302,10 +310,14 @@ Q_SIGNALS:
     void canPasteChanged();
     void canUndoChanged();
     void canRedoChanged();
+#ifndef QT_NO_IM
     void inputMethodComposingChanged();
+#endif
     void effectiveHorizontalAlignmentChanged();
     void contentSizeChanged();
+#ifndef QT_NO_IM
     void inputMethodHintsChanged();
+#endif
     void renderTypeChanged();
 
 protected:
@@ -317,7 +329,9 @@ protected:
     void mouseReleaseEvent(QMouseEvent *event);
     void mouseDoubleClickEvent(QMouseEvent *event);
     void keyPressEvent(QKeyEvent* ev);
+#ifndef QT_NO_IM
     void inputMethodEvent(QInputMethodEvent *);
+#endif
     void mouseUngrabEvent();
     bool event(QEvent *e);
     void focusInEvent(QFocusEvent *event);
diff --git a/src/quick/items/qquicktextinput_p_p.h b/src/quick/items/qquicktextinput_p_p.h
index 0981022..cf08424 100644
--- a/src/quick/items/qquicktextinput_p_p.h
+++ b/src/quick/items/qquicktextinput_p_p.h
@@ -89,7 +89,9 @@ public:
         , selectionColor(QRgb(0xFF000080))
         , selectedTextColor(QRgb(0xFFFFFFFF))
         , m_cursor(0)
+#ifndef QT_NO_IM
         , m_preeditCursor(0)
+#endif
         , m_blinkPeriod(0)
         , m_blinkTimer(0)
         , m_maxLength(32767)
@@ -97,7 +99,9 @@ public:
         , m_undoState(0)
         , m_selstart(0)
         , m_selend(0)
+#ifndef QT_NO_IM
         , inputMethodHints(Qt::ImhNone)
+#endif
         , hAlign(QQuickTextInput::AlignLeft)
         , vAlign(QQuickTextInput::AlignTop)
         , wrapMode(QQuickTextInput::NoWrap)
@@ -124,7 +128,9 @@ public:
         , m_separator(0)
         , m_readOnly(0)
         , m_textDirty(0)
+#ifndef QT_NO_IM
         , m_preeditDirty(0)
+#endif
         , m_selDirty(0)
         , m_validInput(1)
         , m_acceptableInput(1)
@@ -147,7 +153,9 @@ public:
     bool setHAlign(QQuickTextInput::HAlignment, bool forceAlign = false);
     void mirrorChange();
     bool sendMouseEventToInputContext(QMouseEvent *event);
+#ifndef QT_NO_IM
     Qt::InputMethodHints effectiveInputMethodHints() const;
+#endif
     void hideCursor();
     void showCursor();
 
@@ -211,7 +219,9 @@ public:
     int lastSelectionStart;
     int lastSelectionEnd;
     int m_cursor;
+#ifndef QT_NO_IM
     int m_preeditCursor;
+#endif
     int m_blinkPeriod; // 0 for non-blinking cursor
     int m_blinkTimer;
     int m_maxLength;
@@ -226,7 +236,9 @@ public:
         UpdatePaintNode
     };
 
+#ifndef QT_NO_IM
     Qt::InputMethodHints inputMethodHints;
+#endif
     QQuickTextInput::HAlignment hAlign;
     QQuickTextInput::VAlignment vAlign;
     QQuickTextInput::WrapMode wrapMode;
@@ -256,7 +268,9 @@ public:
     bool m_separator : 1;
     bool m_readOnly : 1;
     bool m_textDirty : 1;
+#ifndef QT_NO_IM
     bool m_preeditDirty : 1;
+#endif
     bool m_selDirty : 1;
     bool m_validInput : 1;
     bool m_acceptableInput : 1;
@@ -327,8 +341,10 @@ public:
     void paste(QClipboard::Mode mode = QClipboard::Clipboard);
 #endif
 
+#ifndef QT_NO_IM
     void commitPreedit();
     void cancelPreedit();
+#endif
 
     Qt::CursorMoveStyle cursorMoveStyle() const { return m_textLayout.cursorMoveStyle(); }
     void setCursorMoveStyle(Qt::CursorMoveStyle style) { m_textLayout.setCursorMoveStyle(style); }
@@ -379,9 +395,9 @@ public:
     // input methods
 #ifndef QT_NO_IM
     bool composeMode() const { return !m_textLayout.preeditAreaText().isEmpty(); }
-#endif
 
     QString preeditAreaText() const { return m_textLayout.preeditAreaText(); }
+#endif
 
     void updatePasswordEchoEditing(bool editing);
 
@@ -399,7 +415,9 @@ public:
         }
     }
 
+#ifndef QT_NO_IM
     void processInputMethodEvent(QInputMethodEvent *event);
+#endif
     void processKeyEvent(QKeyEvent* ev);
 
     void setCursorBlinkPeriod(int msec);
diff --git a/src/quick/items/qquicktextnode.cpp b/src/quick/items/qquicktextnode.cpp
index 1714715..812ba12 100644
--- a/src/quick/items/qquicktextnode.cpp
+++ b/src/quick/items/qquicktextnode.cpp
@@ -1149,8 +1149,10 @@ void QQuickTextNode::addTextDocument(const QPointF &position, QTextDocument *tex
                 Q_ASSERT(!engine.currentLine().isValid());
 
                 QTextBlock block = it.currentBlock();
+#ifndef QT_NO_IM
                 int preeditLength = block.isValid() ? block.layout()->preeditAreaText().length() : 0;
                 int preeditPosition = block.isValid() ? block.layout()->preeditAreaPosition() : -1;
+#endif
 
                 QVarLengthArray<QTextLayout::FormatRange> colorChanges;
                 mergeFormats(block.layout(), &colorChanges);
@@ -1254,11 +1256,13 @@ void QQuickTextNode::addTextDocument(const QPointF &position, QTextDocument *tex
                             engine.setTextColor(textColor);
 
                         int fragmentEnd = textPos + fragment.length();
+#ifndef QT_NO_IM
                         if (preeditPosition >= 0
                          && preeditPosition >= textPos
                          && preeditPosition <= fragmentEnd) {
                             fragmentEnd += preeditLength;
                         }
+#endif
 
                         textPos = engine.addText(block, charFormat, textColor, colorChanges, textPos, fragmentEnd,
                                        selectionStart, selectionEnd);
@@ -1267,6 +1271,7 @@ void QQuickTextNode::addTextDocument(const QPointF &position, QTextDocument *tex
                     ++blockIterator;
                 }
 
+#ifndef QT_NO_IM
                 if (preeditLength >= 0 && textPos <= block.position() + preeditPosition) {
                     engine.setPosition(blockPosition);
                     textPos = block.position() + preeditPosition;
@@ -1279,6 +1284,7 @@ void QQuickTextNode::addTextDocument(const QPointF &position, QTextDocument *tex
                                              textPos, textPos + preeditLength,
                                              selectionStart, selectionEnd);
                 }
+#endif
 
                 engine.setCurrentLine(QTextLine()); // Reset current line because the text layout changed
                 ++it;
@@ -1303,8 +1309,10 @@ void QQuickTextNode::addTextLayout(const QPointF &position, QTextLayout *textLay
     engine.setAnchorColor(anchorColor);
     engine.setPosition(position);
 
+#ifndef QT_NO_IM
     int preeditLength = textLayout->preeditAreaText().length();
     int preeditPosition = textLayout->preeditAreaPosition();
+#endif
 
     QVarLengthArray<QTextLayout::FormatRange> colorChanges;
     mergeFormats(textLayout, &colorChanges);
@@ -1320,11 +1328,13 @@ void QQuickTextNode::addTextLayout(const QPointF &position, QTextLayout *textLay
         int length = line.textLength();
         int end = start + length;
 
+#ifndef QT_NO_IM
         if (preeditPosition >= 0
          && preeditPosition >= start
          && preeditPosition < end) {
             end += preeditLength;
         }
+#endif
 
         engine.setCurrentLine(line);
         engine.addGlyphsForRanges(colorChanges, start, end, selectionStart, selectionEnd);
diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
index 99db98d..2ce91cd 100644
--- a/src/quick/items/qquickwindow.cpp
+++ b/src/quick/items/qquickwindow.cpp
@@ -75,9 +75,11 @@ QT_BEGIN_NAMESPACE
 void QQuickWindowPrivate::updateFocusItemTransform()
 {
     Q_Q(QQuickWindow);
+#ifndef QT_NO_IM
     QQuickItem *focus = q->activeFocusItem();
     if (focus && qApp->focusObject() == focus)
         qApp->inputMethod()->setInputItemTransform(QQuickItemPrivate::get(focus)->itemToWindowTransform());
+#endif
 }
 
 
@@ -1146,8 +1148,10 @@ bool QQuickWindow::event(QEvent *e)
         contentItem()->windowDeactivateEvent();
         break;
     case QEvent::FocusAboutToChange:
+#ifndef QT_NO_IM
         if (d->activeFocusItem)
             qGuiApp->inputMethod()->commit();
+#endif
         break;
     default:
         break;
diff --git a/src/quick/util/qquickglobal.cpp b/src/quick/util/qquickglobal.cpp
index 3a42e30..ae5354d 100644
--- a/src/quick/util/qquickglobal.cpp
+++ b/src/quick/util/qquickglobal.cpp
@@ -964,10 +964,12 @@ public:
         return new QQuickApplication(parent);
     }
 
+#ifndef QT_NO_IM
     QInputMethod *inputMethod()
     {
         return qGuiApp->inputMethod();
     }
+#endif
 
     QStringList fontFamilies()
     {
diff --git a/src/quick/util/qquickutilmodule.cpp b/src/quick/util/qquickutilmodule.cpp
index fd2037a..7ecb792 100644
--- a/src/quick/util/qquickutilmodule.cpp
+++ b/src/quick/util/qquickutilmodule.cpp
@@ -65,8 +65,10 @@
 
 void QQuickUtilModule::defineModule()
 {
+#ifndef QT_NO_IM
     qmlRegisterUncreatableType<QInputMethod>("QtQuick",2,0,"InputMethod",
                                              QInputMethod::tr("InputMethod is an abstract class"));
+#endif
     qmlRegisterUncreatableType<QQuickAbstractAnimation>("QtQuick",2,0,"Animation",QQuickAbstractAnimation::tr("Animation is an abstract class"));
 
     qmlRegisterType<QQuickBehavior>("QtQuick",2,0,"Behavior");