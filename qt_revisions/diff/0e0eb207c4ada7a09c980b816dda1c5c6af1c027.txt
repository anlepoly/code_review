diff --git a/config.tests/unix/icd/icd.cpp b/config.tests/unix/icd/icd.cpp
deleted file mode 100644
index de550be..0000000
--- a/config.tests/unix/icd/icd.cpp
+++ /dev/null
@@ -1,55 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the config.tests of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <wlancond.h>
-
-#include <icd/dbus_api.h>
-#include <icd/network_api_defines.h>
-
-#include <icd/osso-ic.h>
-#include <icd/osso-ic-dbus.h>
-
-#include <conn_settings.h>
-
-int main(int, char **)
-{
-    return 0;
-}
diff --git a/config.tests/unix/icd/icd.pro b/config.tests/unix/icd/icd.pro
deleted file mode 100644
index d736b41..0000000
--- a/config.tests/unix/icd/icd.pro
+++ /dev/null
@@ -1,3 +0,0 @@
-SOURCES = icd.cpp
-CONFIG -= qt
-mac:CONFIG -= app_bundle
diff --git a/configure b/configure
index ce8f99c..8f4bbbe 100755
--- a/configure
+++ b/configure
@@ -815,7 +815,6 @@ CFG_SILENT=no
 CFG_ALSA=auto
 CFG_PULSEAUDIO=auto
 CFG_COREWLAN=auto
-CFG_ICD=auto
 CFG_NOPROCESS=no
 CFG_ICU=auto
 CFG_FORCE_ASSERTS=no
@@ -858,10 +857,6 @@ QT_LIBS_GLIB=
 QT_CFLAGS_GSTREAMER=
 QT_LIBS_GSTREAMER=
 
-# flags for libconnsettings0 (used for Maemo ICD bearer management plugin)
-QT_CFLAGS_CONNSETTINGS=
-QT_LIBS_CONNSETTINGS=
-
 #-------------------------------------------------------------------------------
 # check SQL drivers, mouse drivers and decorations available in this package
 #-------------------------------------------------------------------------------
@@ -5522,33 +5517,6 @@ if [ "$PLATFORM_X11" = "yes" -o "$PLATFORM_QWS" = "yes" -o "$PLATFORM_QPA" = "ye
         fi
     fi
 
-    # auto-detect icd support
-    if [ "$CFG_GLIB" = "yes" -a "$CFG_ICD" != "no" ]; then
-        if [ -n "$PKG_CONFIG" ]; then
-            QT_CFLAGS_CONNSETTINGS=`$PKG_CONFIG --cflags connsettings icd2 2>/dev/null`
-            QT_LIBS_CONNSETTINGS=`$PKG_CONFIG --libs connsettings icd2 2>/dev/null`
-        fi
-        if "$unixtests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/unix/icd "ICD" $L_FLAGS $I_FLAGS $l_FLAGS $QT_CFLAGS_CONNSETTINGS $QT_LIBS_CONNSETTINGS; then
-            [ "$CFG_ICD" = "auto" ] && CFG_ICD=yes
-            QMakeVar set QT_CFLAGS_CONNSETTINGS "$QT_CFLAGS_CONNSETTINGS"
-            QMakeVar set QT_LIBS_CONNSETTINGS "$QT_LIBS_CONNSETTINGS"
-        else
-            if [ "$CFG_ICD" = "auto" ]; then
-                CFG_ICD=no
-            elif [ "$CFG_CONFIGURE_EXIT_ON_ERROR" = "yes" ]; then
-                # CFG_ICD is "yes"
-
-                echo "The ICD Bearer Management plugin cannot be enabled because connsettings was not found."
-                echo " Turn on verbose messaging (-v) to $0 to see the final report."
-                echo " If you believe this message is in error you may use the continue"
-                echo " switch (-continue) to $0 to continue."
-                exit 101
-            fi
-        fi
-    elif [ "$CFG_GLIB" = "no" ]; then
-        CFG_ICD=no
-    fi
-
     # auto-detect libicu support
     if [ "$CFG_ICU" != "no" ]; then
         if "$unixtests/compile.test" "$XQMAKESPEC" "$QMAKE_CONFIG" $OPT_VERBOSE "$relpath" "$outpath" config.tests/unix/icu "ICU" $L_FLAGS $I_FLAGS $l_FLAGS; then
@@ -7161,10 +7129,6 @@ if [ "$CFG_COREWLAN" = "yes" ]; then
     QT_CONFIG="$QT_CONFIG corewlan"
 fi
 
-if [ "$CFG_ICD" = "yes" ]; then
-    QT_CONFIG="$QT_CONFIG icd"
-fi
-
 if [ "$CFG_ICU" = "yes" ]; then
     QT_CONFIG="$QT_CONFIG icu"
 fi
@@ -7815,7 +7779,6 @@ QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_STYLE_S60"
 [ "$CFG_ALSA" = "no" ]           && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ALSA"
 [ "$CFG_PULSEAUDIO" = "no" ]          && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_PULSEAUDIO"
 [ "$CFG_COREWLAN" = "no" ]       && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_COREWLAN"
-[ "$CFG_ICD" != "yes" ] && QCONFIG_FLAGS="$QCONFIG_FLAGS QT_NO_ICD"
 
 # sort QCONFIG_FLAGS for neatness if we can
 [ '!' -z "$AWK" ] && QCONFIG_FLAGS=`echo $QCONFIG_FLAGS | $AWK '{ gsub(" ", "\n"); print }' | sort | uniq`
@@ -8369,7 +8332,6 @@ echo "Alsa support ........... $CFG_ALSA"
 if [ "$PLATFORM_MAC" = "yes" ]; then
     echo "CoreWlan support ....... $CFG_COREWLAN"
 fi
-echo "ICD support ............ $CFG_ICD"
 echo "libICU support ......... $CFG_ICU"
 if [ "$CFG_XCB_LIMITED" = "yes" ] && [ "$CFG_XCB" = "yes" ]; then
     echo "Xcb support ............ limited (old version)"
diff --git a/src/plugins/bearer/bearer.pro b/src/plugins/bearer/bearer.pro
index ead498e..12b18ac 100644
--- a/src/plugins/bearer/bearer.pro
+++ b/src/plugins/bearer/bearer.pro
@@ -1,12 +1,8 @@
 TEMPLATE = subdirs
 
-contains(QT_CONFIG, dbus) {
-    contains(QT_CONFIG, icd) {
-        SUBDIRS += icd
-    } else:linux* {
-        SUBDIRS += generic
-        SUBDIRS += connman networkmanager
-    }
+linux*:contains(QT_CONFIG, dbus) {
+    SUBDIRS += generic
+    SUBDIRS += connman networkmanager
 }
 
 #win32:SUBDIRS += nla
diff --git a/src/plugins/bearer/icd/dbusdispatcher.cpp b/src/plugins/bearer/icd/dbusdispatcher.cpp
deleted file mode 100644
index 1f2220b..0000000
--- a/src/plugins/bearer/icd/dbusdispatcher.cpp
+++ /dev/null
@@ -1,634 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include <QDebug>
-#include <QtCore>
-#include <poll.h>
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib-lowlevel.h>
-#include <glib.h>
-#include "dbusdispatcher.h"
-
-namespace Maemo {
-
-/*!
-    \class Maemo::DBusDispatcher
-
-    \brief DBusDispatcher is a class that can send DBUS method call
-    messages and receive unicast signals from DBUS objects.
-*/
-
-class DBusDispatcherPrivate
-{
-public:
-    DBusDispatcherPrivate(const QString& service,
-                          const QString& path,
-                          const QString& interface,
-                          const QString& signalPath)
-        : service(service), path(path), interface(interface),
-          signalPath(signalPath), connection(0)
-    {
-        memset(&signal_vtable, 0, sizeof(signal_vtable));
-    }
-
-    ~DBusDispatcherPrivate()
-    {
-        foreach(DBusPendingCall *call, pending_calls) {
-            dbus_pending_call_cancel(call);
-            dbus_pending_call_unref(call);
-        }
-    }
-
-    QString service;
-    QString path;
-    QString interface;
-    QString signalPath;
-    struct DBusConnection *connection;
-    QList<DBusPendingCall *> pending_calls;
-    struct DBusObjectPathVTable signal_vtable;
-};
-
-static bool constantVariantList(const QVariantList& variantList) {
-    // Special case, empty list == empty struct
-    if (variantList.isEmpty()) {
-        return false;
-    } else {        
-        QVariant::Type type = variantList[0].type();
-        // Iterate items in the list and check if they are same type
-        foreach(QVariant variant, variantList) {
-            if (variant.type() != type) {
-                return false;
-            }
-        }
-    }
-    return true;
-}
-
-static QString variantToSignature(const QVariant& argument,
-                                  bool constantList = true) {
-    switch (argument.type()) {
-        case QVariant::Bool:
-            return "b";
-        case QVariant::ByteArray:
-            return "ay";
-        case QVariant::Char:
-            return "y";
-        case QVariant::Int:
-            return "i";
-        case QVariant::UInt:
-            return "u";
-        case QVariant::StringList:
-            return "as";
-        case QVariant::String:
-            return "s";
-        case QVariant::LongLong:
-            return "x";
-        case QVariant::ULongLong:
-            return "t";
-        case QVariant::List:
-            {
-            QString signature;
-            QVariantList variantList = argument.toList();
-            if (!constantList) {
-                signature += DBUS_STRUCT_BEGIN_CHAR_AS_STRING;
-                foreach(QVariant listItem, variantList) {
-                    signature += variantToSignature(listItem);
-                }
-                signature += DBUS_STRUCT_END_CHAR_AS_STRING;
-            } else {
-                if (variantList.isEmpty())
-                    return "";
-                signature = "a" + variantToSignature(variantList[0]);
-            }
-
-            return signature;
-            }
-        default:
-            qDebug() << "Unsupported variant type: " << argument.type();
-            break;
-    }
-
-    return "";
-}
-
-static bool appendVariantToDBusMessage(const QVariant& argument,
-                                       DBusMessageIter *dbus_iter) {
-    int idx = 0;
-    DBusMessageIter array_iter;
-    QStringList str_list;
-    dbus_bool_t bool_data;
-    dbus_int32_t int32_data;
-    dbus_uint32_t uint32_data;
-    dbus_int64_t int64_data;
-    dbus_uint64_t uint64_data;
-    char *str_data;
-    char char_data;
-
-    switch (argument.type()) {
-
-        case QVariant::Bool:
-            bool_data = argument.toBool();
-            dbus_message_iter_append_basic(dbus_iter, DBUS_TYPE_BOOLEAN, 
-                                           &bool_data);
-            break;
-
-        case QVariant::ByteArray:
-            str_data = argument.toByteArray().data();
-            dbus_message_iter_open_container(dbus_iter, DBUS_TYPE_ARRAY,
-                                             DBUS_TYPE_BYTE_AS_STRING, &array_iter);
-            dbus_message_iter_append_fixed_array(&array_iter,
-                                                 DBUS_TYPE_BYTE,
-                                                 &str_data,
-                                                 argument.toByteArray().size());
-            dbus_message_iter_close_container(dbus_iter, &array_iter);
-            break;
-
-        case QVariant::Char:
-            char_data = argument.toChar().toAscii();
-            dbus_message_iter_append_basic(dbus_iter, DBUS_TYPE_BYTE, 
-                                           &char_data);
-            break;
-
-        case QVariant::Int:
-            int32_data = argument.toInt();
-            dbus_message_iter_append_basic(dbus_iter, DBUS_TYPE_INT32, 
-                                           &int32_data);
-            break;
-
-        case QVariant::String: {
-            QByteArray data = argument.toString().toLatin1();
-            str_data = data.data();
-            dbus_message_iter_append_basic(dbus_iter, DBUS_TYPE_STRING,
-                                           &str_data);
-            break;
-        }
-
-        case QVariant::StringList:
-            str_list = argument.toStringList();
-            dbus_message_iter_open_container(dbus_iter, DBUS_TYPE_ARRAY,
-                                             "s", &array_iter);
-            for (idx = 0; idx < str_list.size(); idx++) {
-                QByteArray data = str_list.at(idx).toLatin1();
-                str_data = data.data();
-                dbus_message_iter_append_basic(&array_iter,
-                                               DBUS_TYPE_STRING,
-                                               &str_data);
-            }
-            dbus_message_iter_close_container(dbus_iter, &array_iter);
-            break;
-
-        case QVariant::UInt:
-            uint32_data = argument.toUInt();
-            dbus_message_iter_append_basic(dbus_iter, DBUS_TYPE_UINT32, 
-                                           &uint32_data);
-            break;
-
-        case QVariant::ULongLong:
-            uint64_data = argument.toULongLong();
-            dbus_message_iter_append_basic(dbus_iter, DBUS_TYPE_UINT64, 
-                                           &uint64_data);
-            break;
-
-        case QVariant::LongLong:
-            int64_data = argument.toLongLong();
-            dbus_message_iter_append_basic(dbus_iter, DBUS_TYPE_INT64, 
-                                           &int64_data);
-            break;
-
-        case QVariant::List:
-            {
-            QVariantList variantList = argument.toList();
-            bool constantList = constantVariantList(variantList);
-            DBusMessageIter array_iter;
-
-            // List is mapped either as an DBUS array (all items same type)
-            // DBUS struct (variable types) depending on constantList
-            if (constantList) {
-                // Resolve the signature for the first item
-                QString signature = "";
-                if (!variantList.isEmpty()) {
-                    signature = variantToSignature(
-                                variantList[0],
-                                constantVariantList(variantList[0].toList()));
-                }
-
-                // Mapped as DBUS array
-                dbus_message_iter_open_container(dbus_iter, DBUS_TYPE_ARRAY,
-                                                 signature.toAscii(),
-                                                 &array_iter);
-
-                foreach(QVariant listItem, variantList) {
-                    appendVariantToDBusMessage(listItem, &array_iter);
-                }
-
-                dbus_message_iter_close_container(dbus_iter, &array_iter);
-            } else {
-                // Mapped as DBUS struct
-                dbus_message_iter_open_container(dbus_iter, DBUS_TYPE_STRUCT,
-                                                 NULL,
-                                                 &array_iter);
-
-                foreach(QVariant listItem, variantList) {
-                    appendVariantToDBusMessage(listItem, &array_iter);
-                }
-
-                dbus_message_iter_close_container(dbus_iter, &array_iter);
-            }
-
-            break;
-            }
-        default:
-            qDebug() << "Unsupported variant type: " << argument.type();
-            break;
-    }
-
-    return true;
-}
-
-static QVariant getVariantFromDBusMessage(DBusMessageIter *iter) {
-    dbus_bool_t bool_data;
-    dbus_int32_t int32_data;
-    dbus_uint32_t uint32_data;
-    dbus_int64_t int64_data;
-    dbus_uint64_t uint64_data;
-    char *str_data;
-    char char_data;
-    int argtype = dbus_message_iter_get_arg_type(iter);
-
-    switch (argtype) {
-
-        case DBUS_TYPE_BOOLEAN:
-        {
-            dbus_message_iter_get_basic(iter, &bool_data);
-            QVariant variant((bool)bool_data);
-            return variant;
-        }
-
-        case DBUS_TYPE_ARRAY:
-        {
-            // Handle all arrays here
-            int elem_type = dbus_message_iter_get_element_type(iter);
-            DBusMessageIter array_iter;
-
-            dbus_message_iter_recurse(iter, &array_iter);
-
-            if (elem_type == DBUS_TYPE_BYTE) {
-                QByteArray byte_array;
-                do {
-                    dbus_message_iter_get_basic(&array_iter, &char_data);
-                    byte_array.append(char_data);
-                } while (dbus_message_iter_next(&array_iter));
-                QVariant variant(byte_array);
-                return variant;
-            } else if (elem_type == DBUS_TYPE_STRING) {
-                QStringList str_list;
-                do {
-                    dbus_message_iter_get_basic(&array_iter, &str_data);
-                    str_list.append(str_data);
-                } while (dbus_message_iter_next(&array_iter));
-                QVariant variant(str_list);
-                return variant;
-            } else {
-                QVariantList variantList;
-                do {
-                    variantList << getVariantFromDBusMessage(&array_iter);
-                } while (dbus_message_iter_next(&array_iter));
-                QVariant variant(variantList);
-                return variant;
-            }
-            break;
-        }
-
-        case DBUS_TYPE_BYTE:
-        {
-            dbus_message_iter_get_basic(iter, &char_data);
-            QChar ch(char_data);
-            QVariant variant(ch);
-            return variant;
-        }
-
-        case DBUS_TYPE_INT32:
-        {
-            dbus_message_iter_get_basic(iter, &int32_data);
-            QVariant variant((int)int32_data);
-            return variant;
-        }
-
-        case DBUS_TYPE_UINT32:
-        {
-            dbus_message_iter_get_basic(iter, &uint32_data);
-            QVariant variant((uint)uint32_data);
-            return variant;
-        }
-
-        case DBUS_TYPE_STRING:
-        {
-            dbus_message_iter_get_basic(iter, &str_data);
-            QString str(str_data);
-            QVariant variant(str);
-            return variant;
-        }
-
-        case DBUS_TYPE_INT64:
-        {
-            dbus_message_iter_get_basic(iter, &int64_data);
-            QVariant variant((qlonglong)int64_data);
-            return variant;
-        }
-
-        case DBUS_TYPE_UINT64:
-        {
-            dbus_message_iter_get_basic(iter, &uint64_data);
-            QVariant variant((qulonglong)uint64_data);
-            return variant;
-        }
-
-        case DBUS_TYPE_STRUCT:
-        {
-            // Handle all structs here
-            DBusMessageIter struct_iter;
-            dbus_message_iter_recurse(iter, &struct_iter);
-
-	    QVariantList variantList;
-	    do {
-	      variantList << getVariantFromDBusMessage(&struct_iter);
-	    } while (dbus_message_iter_next(&struct_iter));
-	    QVariant variant(variantList);
-	    return variant;
-        }
-
-        default:
-            qDebug() << "Unsupported DBUS type: " << argtype;
-    }
-
-    return QVariant();
-}
-
-static DBusHandlerResult signalHandler (DBusConnection *connection,
-                                        DBusMessage *message,
-                                        void *object_ref) {
-    (void)connection;
-    QString interface;
-    QString signal;
-    DBusDispatcher *dispatcher = (DBusDispatcher *)object_ref;
-
-    if (dbus_message_get_type(message) == DBUS_MESSAGE_TYPE_SIGNAL) {
-        interface = dbus_message_get_interface(message);
-        signal = dbus_message_get_member(message);
-        
-        QList<QVariant> arglist;
-        DBusMessageIter dbus_iter;
-
-        if (dbus_message_iter_init(message, &dbus_iter)) {
-            // Read return arguments
-            while (dbus_message_iter_get_arg_type (&dbus_iter) != DBUS_TYPE_INVALID) {
-                arglist << getVariantFromDBusMessage(&dbus_iter);
-                dbus_message_iter_next(&dbus_iter);
-            }
-        }
-
-        dispatcher->emitSignalReceived(interface, signal, arglist);
-        return DBUS_HANDLER_RESULT_HANDLED;
-    }
-    (void)message;
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-DBusDispatcher::DBusDispatcher(const QString& service,
-                               const QString& path,
-                               const QString& interface,
-                               QObject *parent)
- : QObject(parent),
-   d_ptr(new DBusDispatcherPrivate(service, path, interface, path)) {
-    setupDBus();
-}
-
-DBusDispatcher::DBusDispatcher(const QString& service,
-                               const QString& path,
-                               const QString& interface,
-                               const QString& signalPath,
-                               QObject *parent)
- : QObject(parent),
-   d_ptr(new DBusDispatcherPrivate(service, path, interface, signalPath)) {
-    setupDBus();
-}
-
-DBusDispatcher::~DBusDispatcher()
-{
-    if (d_ptr->connection) {
-        dbus_connection_close(d_ptr->connection);
-        dbus_connection_unref(d_ptr->connection);
-    }
-    delete d_ptr;
-}
-
-void DBusDispatcher::setupDBus()
-{
-    d_ptr->connection = dbus_bus_get_private(DBUS_BUS_SYSTEM, NULL);
-
-    if (d_ptr->connection == NULL)
-        qDebug() << "Unable to get DBUS connection!";
-    else {
-        d_ptr->signal_vtable.message_function = signalHandler;
-
-	dbus_connection_set_exit_on_disconnect(d_ptr->connection, FALSE);
-        dbus_connection_setup_with_g_main(d_ptr->connection, g_main_context_get_thread_default());
-        dbus_connection_register_object_path(d_ptr->connection, 
-                                             d_ptr->signalPath.toLatin1(),
-                                             &d_ptr->signal_vtable,
-                                             this);
-    }
-}
-
-static DBusMessage *prepareDBusCall(const QString& service,
-                                    const QString& path,
-                                    const QString& interface,
-                                    const QString& method, 
-                                    const QVariant& arg1 = QVariant(),
-                                    const QVariant& arg2 = QVariant(),
-                                    const QVariant& arg3 = QVariant(),
-                                    const QVariant& arg4 = QVariant(),
-                                    const QVariant& arg5 = QVariant(),
-                                    const QVariant& arg6 = QVariant(),
-                                    const QVariant& arg7 = QVariant(),
-                                    const QVariant& arg8 = QVariant()) 
-{
-    DBusMessage *message = dbus_message_new_method_call(service.toLatin1(),
-                                                        path.toLatin1(),
-                                                        interface.toLatin1(),
-                                                        method.toLatin1());
-    DBusMessageIter dbus_iter;
-
-    // Append variants to DBUS message
-    QList<QVariant> arglist;
-    if (arg1.isValid()) arglist << arg1;
-    if (arg2.isValid()) arglist << arg2;
-    if (arg3.isValid()) arglist << arg3;
-    if (arg4.isValid()) arglist << arg4;
-    if (arg5.isValid()) arglist << arg5;
-    if (arg6.isValid()) arglist << arg6;
-    if (arg7.isValid()) arglist << arg7;
-    if (arg8.isValid()) arglist << arg8;
-
-    dbus_message_iter_init_append (message, &dbus_iter);
-    
-    while (!arglist.isEmpty()) {
-        QVariant argument = arglist.takeFirst();
-        appendVariantToDBusMessage(argument, &dbus_iter);
-    }
-
-    return message;
-}
-
-QList<QVariant> DBusDispatcher::call(const QString& method, 
-                                     const QVariant& arg1,
-                                     const QVariant& arg2,
-                                     const QVariant& arg3,
-                                     const QVariant& arg4,
-                                     const QVariant& arg5,
-                                     const QVariant& arg6,
-                                     const QVariant& arg7,
-                                     const QVariant& arg8) {
-    DBusMessageIter dbus_iter;
-    DBusMessage *message = prepareDBusCall(d_ptr->service, d_ptr->path,
-                                           d_ptr->interface, method,
-                                           arg1, arg2, arg3, arg4, arg5,
-                                           arg6, arg7, arg8);
-    DBusMessage *reply = dbus_connection_send_with_reply_and_block(
-                                                    d_ptr->connection,
-                                                    message, -1, NULL);
-    dbus_message_unref(message);
-
-    QList<QVariant> replylist;
-    if (reply != NULL &&  dbus_message_iter_init(reply, &dbus_iter)) {
-        // Read return arguments
-        while (dbus_message_iter_get_arg_type (&dbus_iter) != DBUS_TYPE_INVALID) {
-            replylist << getVariantFromDBusMessage(&dbus_iter);
-            dbus_message_iter_next(&dbus_iter);
-        }
-    }
-    if (reply != NULL) dbus_message_unref(reply);
-    return replylist;
-}
-
-class PendingCallInfo {
-public:
-    QString method;
-    DBusDispatcher *dispatcher;
-    DBusDispatcherPrivate *priv;
-};
-
-static void freePendingCallInfo(void *memory) {
-    PendingCallInfo *info = (PendingCallInfo *)memory;
-    delete info;
-}
-
-static void pendingCallFunction (DBusPendingCall *pending,
-                                 void *memory) {
-    PendingCallInfo *info = (PendingCallInfo *)memory;
-    QString errorStr;
-    QList<QVariant> replyList;
-    DBusMessage *reply = dbus_pending_call_steal_reply (pending);
-
-    Q_ASSERT(reply != NULL);
-
-    if (dbus_message_get_type(reply) == DBUS_MESSAGE_TYPE_ERROR) {
-        errorStr = dbus_message_get_error_name (reply);
-    } else {
-        DBusMessageIter dbus_iter;
-        dbus_message_iter_init(reply, &dbus_iter);
-        // Read return arguments
-        while (dbus_message_iter_get_arg_type (&dbus_iter) != DBUS_TYPE_INVALID) {
-            replyList << getVariantFromDBusMessage(&dbus_iter);
-            dbus_message_iter_next(&dbus_iter);
-        }
-    }
-
-    info->priv->pending_calls.removeOne(pending);
-    info->dispatcher->emitCallReply(info->method, replyList, errorStr);
-    dbus_message_unref(reply);
-    dbus_pending_call_unref(pending);
-}
-
-bool DBusDispatcher::callAsynchronous(const QString& method, 
-                                      const QVariant& arg1,
-                                      const QVariant& arg2,
-                                      const QVariant& arg3,
-                                      const QVariant& arg4,
-                                      const QVariant& arg5,
-                                      const QVariant& arg6,
-                                      const QVariant& arg7,
-                                      const QVariant& arg8) {
-    DBusMessage *message = prepareDBusCall(d_ptr->service, d_ptr->path,
-                                           d_ptr->interface, method,
-                                           arg1, arg2, arg3, arg4, arg5,
-                                           arg6, arg7, arg8);
-    DBusPendingCall *call = NULL;
-    dbus_bool_t ret = dbus_connection_send_with_reply(d_ptr->connection,
-                                                      message, &call, -1);
-    PendingCallInfo *info = new PendingCallInfo;
-    info->method = method;
-    info->dispatcher = this;
-    info->priv = d_ptr;
-
-    dbus_pending_call_set_notify(call, pendingCallFunction, info, freePendingCallInfo);
-    d_ptr->pending_calls.append(call);
-    return (bool)ret;
-}
-
-void DBusDispatcher::emitSignalReceived(const QString& interface, 
-                                        const QString& signal,
-                                        const QList<QVariant>& args) {
-    emit signalReceived(interface, signal, args); }
-
-void DBusDispatcher::emitCallReply(const QString& method,
-                                   const QList<QVariant>& args,
-                                   const QString& error) {
-    emit callReply(method, args, error); }
-
-void DBusDispatcher::synchronousDispatch(int timeout_ms)
-{
-    dbus_connection_read_write_dispatch(d_ptr->connection, timeout_ms);
-}
-
-} // Maemo namespace
-
diff --git a/src/plugins/bearer/icd/dbusdispatcher.h b/src/plugins/bearer/icd/dbusdispatcher.h
deleted file mode 100644
index d4039eb..0000000
--- a/src/plugins/bearer/icd/dbusdispatcher.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef DBUSDISPATCHER_H
-#define DBUSDISPATCHER_H
-
-#include <QObject>
-#include <QVariant>
-
-namespace Maemo {
-
-class DBusDispatcherPrivate;
-class DBusDispatcher : public QObject
-{
-    Q_OBJECT
-
-public:
-    DBusDispatcher(const QString& service,
-                   const QString& path,
-                   const QString& interface,
-                   QObject *parent = 0);
-    DBusDispatcher(const QString& service,
-                   const QString& path,
-                   const QString& interface,
-                   const QString& signalPath,
-                   QObject *parent = 0);
-    ~DBusDispatcher();
-
-    QList<QVariant> call(const QString& method, 
-                         const QVariant& arg1 = QVariant(),
-                         const QVariant& arg2 = QVariant(),
-                         const QVariant& arg3 = QVariant(),
-                         const QVariant& arg4 = QVariant(),
-                         const QVariant& arg5 = QVariant(),
-                         const QVariant& arg6 = QVariant(),
-                         const QVariant& arg7 = QVariant(),
-                         const QVariant& arg8 = QVariant());
-    bool callAsynchronous(const QString& method, 
-                          const QVariant& arg1 = QVariant(),
-                          const QVariant& arg2 = QVariant(),
-                          const QVariant& arg3 = QVariant(),
-                          const QVariant& arg4 = QVariant(),
-                          const QVariant& arg5 = QVariant(),
-                          const QVariant& arg6 = QVariant(),
-                          const QVariant& arg7 = QVariant(),
-                          const QVariant& arg8 = QVariant());
-    void emitSignalReceived(const QString& interface, 
-                            const QString& signal,
-                            const QList<QVariant>& args);
-    void emitCallReply(const QString& method,
-                       const QList<QVariant>& args,
-                       const QString& error = "");
-    void synchronousDispatch(int timeout_ms);
-
-Q_SIGNALS:
-    void signalReceived(const QString& interface, 
-                        const QString& signal,
-                        const QList<QVariant>& args);
-    void callReply(const QString& method,
-                   const QList<QVariant>& args,
-                   const QString& error);
-
-protected:
-    void setupDBus();
-
-private:
-    DBusDispatcherPrivate *d_ptr;
-};
-
-}  // Maemo namespace
-
-#endif
diff --git a/src/plugins/bearer/icd/iapconf.cpp b/src/plugins/bearer/icd/iapconf.cpp
deleted file mode 100644
index 72eb04c..0000000
--- a/src/plugins/bearer/icd/iapconf.cpp
+++ /dev/null
@@ -1,245 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include <stdlib.h>
-#include <string.h>
-#include <conn_settings.h>
-
-#include "iapconf.h"
-
-#define QSTRING_TO_CONST_CSTR(str) \
-    str.toUtf8().constData()
-
-namespace Maemo {
-
-class IAPConfPrivate {
-public:
-    ConnSettings *settings;
-
-    ConnSettingsValue *variantToValue(const QVariant &variant);
-    QVariant valueToVariant(ConnSettingsValue *value);
-};
-
-ConnSettingsValue *IAPConfPrivate::variantToValue(const QVariant &variant)
-{
-    // Convert variant to ConnSettingsValue
-    ConnSettingsValue *value = conn_settings_value_new();
-    if (value == 0) {
-        qWarning("IAPConf: Unable to create new ConnSettingsValue");
-        return 0;
-    }
-
-    switch(variant.type()) {
-        
-    case QVariant::Invalid:
-        value->type = CONN_SETTINGS_VALUE_INVALID;
-        break;
-    
-    case QVariant::String: {
-        char *valueStr = strdup(QSTRING_TO_CONST_CSTR(variant.toString()));
-        value->type = CONN_SETTINGS_VALUE_STRING;
-        value->value.string_val = valueStr;
-        break;
-    }
-    
-    case QVariant::Int:
-        value->type = CONN_SETTINGS_VALUE_INT;
-        value->value.int_val = variant.toInt();
-        break;
-    
-    case QMetaType::Float:
-    case QVariant::Double:
-        value->type = CONN_SETTINGS_VALUE_DOUBLE;
-        value->value.double_val = variant.toDouble();
-        break;
-    
-    case QVariant::Bool:
-        value->type = CONN_SETTINGS_VALUE_BOOL;
-        value->value.bool_val = variant.toBool() ? 1 : 0;
-        break;
-    
-    case QVariant::ByteArray: {
-        QByteArray array = variant.toByteArray();
-        value->type = CONN_SETTINGS_VALUE_BYTE_ARRAY;
-        value->value.byte_array.len = array.size();
-        value->value.byte_array.val = (unsigned char *)malloc(array.size());
-        memcpy(value->value.byte_array.val, array.constData(), array.size());
-        break;
-    }
-    
-    case QVariant::List: {
-        QVariantList list = variant.toList();
-        ConnSettingsValue **list_val = (ConnSettingsValue **)malloc(
-            (list.size() + 1) * sizeof(ConnSettingsValue *));
-
-        for (int idx = 0; idx < list.size(); idx++) {
-            list_val[idx] = variantToValue(list.at(idx));
-        }
-        list_val[list.size()] = 0;
-
-        value->type = CONN_SETTINGS_VALUE_LIST;
-        value->value.list_val = list_val;
-        break;
-    }
-    
-    default:
-        qWarning("IAPConf: Can not handle QVariant of type %d",
-                 variant.type());
-        conn_settings_value_destroy(value);
-        return 0;
-    }
-
-    return value;
-}
-
-QVariant IAPConfPrivate::valueToVariant(ConnSettingsValue *value)
-{
-    if (value == 0 || value->type == CONN_SETTINGS_VALUE_INVALID) {
-        return QVariant();
-    }
-
-    switch(value->type) {
-    
-    case CONN_SETTINGS_VALUE_BOOL:
-        return QVariant(value->value.bool_val ? true : false);
-    
-    case CONN_SETTINGS_VALUE_STRING:
-        return QVariant(QString(value->value.string_val));
-    
-    case CONN_SETTINGS_VALUE_DOUBLE:
-        return QVariant(value->value.double_val);
-    
-    case CONN_SETTINGS_VALUE_INT:
-        return QVariant(value->value.int_val);
-    
-    case CONN_SETTINGS_VALUE_LIST: {
-        // At least with GConf backend connsettings returns byte array as list
-        // of ints, first check for that case
-        if (value->value.list_val && value->value.list_val[0]) {
-            bool canBeConvertedToByteArray = true;
-            for (int idx = 0; value->value.list_val[idx]; idx++) {
-                ConnSettingsValue *val = value->value.list_val[idx];
-                if (val->type != CONN_SETTINGS_VALUE_INT
-                     || val->value.int_val > 255
-                     || val->value.int_val < 0) {
-                    canBeConvertedToByteArray = false;
-                    break;
-                }
-            }
-
-            if (canBeConvertedToByteArray) {
-                QByteArray array;
-                for (int idx = 0; value->value.list_val[idx]; idx++) {
-                    array.append(value->value.list_val[idx]->value.int_val);
-                }
-                return array;
-            }
-
-	    // Create normal list
-	    QVariantList list;
-	    for (int idx = 0; value->value.list_val[idx]; idx++) {
-	      list.append(valueToVariant(value->value.list_val[idx]));
-	    }
-	    return list;
-        }
-    }
-    
-    case CONN_SETTINGS_VALUE_BYTE_ARRAY:
-        return QByteArray::fromRawData((char *)value->value.byte_array.val, 
-                                       value->value.byte_array.len);
-    
-    default:
-        return QVariant();
-    }
-}
-
-// Public class implementation
-
-IAPConf::IAPConf(const QString &iap_id)
-    : d_ptr(new IAPConfPrivate)
-{
-    d_ptr->settings = conn_settings_open(CONN_SETTINGS_CONNECTION,
-                                         QSTRING_TO_CONST_CSTR(iap_id));
-    if (d_ptr->settings == 0) {
-        qWarning("IAPConf: Unable to open ConnSettings for %s", 
-                 QSTRING_TO_CONST_CSTR(iap_id));
-    }
-}
-
-IAPConf::~IAPConf()
-{
-    conn_settings_close(d_ptr->settings);
-    delete d_ptr;
-}
-
-
-QVariant IAPConf::value(const QString& key) const
-{
-    ConnSettingsValue *val = conn_settings_get(d_ptr->settings,
-                                               QSTRING_TO_CONST_CSTR(key));
-
-    QVariant variant = d_ptr->valueToVariant(val);
-    conn_settings_value_destroy(val);
-    return variant;
-}
-
-
-void IAPConf::getAll(QList<QString> &all_iaps, bool return_path)
-{
-    Q_UNUSED(return_path); // We don't use return path currently
-
-    // Go through all available connections and add them to the list
-    char **ids = conn_settings_list_ids(CONN_SETTINGS_CONNECTION);
-    if (ids == 0) {
-        // No ids found - nothing to do
-        return;
-    }
-
-    for (int idx = 0; ids[idx]; idx++) {
-        all_iaps.append(QString(ids[idx]));
-        free(ids[idx]);
-    }
-    free(ids);
-}
-
-
-} // namespace Maemo
diff --git a/src/plugins/bearer/icd/iapconf.h b/src/plugins/bearer/icd/iapconf.h
deleted file mode 100644
index c4dd5b6..0000000
--- a/src/plugins/bearer/icd/iapconf.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef IAPCONF_H
-#define IAPCONF_H
-
-#include <QString>
-#include <QVariant>
-
-namespace Maemo {
-
-class IAPConfPrivate;
-class IAPConf {
-public:
-    IAPConf(const QString &iap_id);
-    virtual ~IAPConf();
-
-    /**
-        Get one IAP value.
-    */
-    QVariant value(const QString& key) const;
-
-    /**
-        Return all the IAPs found in the system. If return_path is true,
-	then do not strip the IAP path away.
-    */
-    static void getAll(QList<QString> &all_iaps, bool return_path=false);
-
-private:
-    IAPConfPrivate *d_ptr;
-};
-
-} // namespace Maemo
-
-#endif
diff --git a/src/plugins/bearer/icd/iapmonitor.cpp b/src/plugins/bearer/icd/iapmonitor.cpp
deleted file mode 100644
index b170361..0000000
--- a/src/plugins/bearer/icd/iapmonitor.cpp
+++ /dev/null
@@ -1,134 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include <QStringList>
-
-#include <conn_settings.h>
-#include "iapmonitor.h"
-
-namespace Maemo {
-
-
-void conn_settings_notify_func (ConnSettingsType type,
-                                const char *id,
-                                const char *key,
-                                ConnSettingsValue *value,
-                                void *user_data);
-
-class IAPMonitorPrivate {
-private:
-    IAPMonitor *monitor;
-    ConnSettings *settings;
-
-public:
-
-    IAPMonitorPrivate(IAPMonitor *monitor)
-        : monitor(monitor)
-    {
-        settings = conn_settings_open(CONN_SETTINGS_CONNECTION, NULL);
-        conn_settings_add_notify(
-                        settings,
-                        (ConnSettingsNotifyFunc *)conn_settings_notify_func,
-                        this);
-    }
-
-    ~IAPMonitorPrivate()
-    {
-        conn_settings_del_notify(settings);
-        conn_settings_close(settings);
-    }
-
-    void iapAdded(const QString &iap)
-    {
-        monitor->iapAdded(iap);
-    }
-
-    void iapRemoved(const QString &iap)
-    {
-        monitor->iapRemoved(iap);
-    }
-};
-
-void conn_settings_notify_func (ConnSettingsType type,
-                                const char *id,
-                                const char *key,
-                                ConnSettingsValue *value,
-                                void *user_data)
-{
-    Q_UNUSED(id);
-
-    if (type != CONN_SETTINGS_CONNECTION) return;
-    IAPMonitorPrivate *priv = (IAPMonitorPrivate *)user_data;
-
-    QString iapId(key);
-    iapId = iapId.split("/")[0];
-    if (value != 0) {
-        priv->iapAdded(iapId);
-    } else if (iapId == QString(key)) {
-        // IAP is removed only when the directory gets removed
-        priv->iapRemoved(iapId);
-    }
-}
-
-IAPMonitor::IAPMonitor()
-    : d_ptr(new IAPMonitorPrivate(this))
-{
-}
-
-IAPMonitor::~IAPMonitor()
-{
-    delete d_ptr;
-}
-
-void IAPMonitor::iapAdded(const QString &id)
-{
-    Q_UNUSED(id);
-    // By default do nothing
-}
-
-void IAPMonitor::iapRemoved(const QString &id)
-{
-    Q_UNUSED(id);
-    // By default do nothing
-}
-
-} // namespace Maemo
diff --git a/src/plugins/bearer/icd/iapmonitor.h b/src/plugins/bearer/icd/iapmonitor.h
deleted file mode 100644
index 5e21bcb..0000000
--- a/src/plugins/bearer/icd/iapmonitor.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef IAPMONITOR_H
-#define IAPMONITOR_H
-
-#include <QString>
-
-namespace Maemo {
-
-class IAPMonitorPrivate;
-class IAPMonitor {
-public:
-    IAPMonitor();
-    ~IAPMonitor();
-
-protected:
-    virtual void iapAdded(const QString &id);
-    virtual void iapRemoved(const QString &id);
-
-private:
-    IAPMonitorPrivate *d_ptr;
-    Q_DECLARE_PRIVATE(IAPMonitor);
-};
-
-} // namespace Maemo
-
-#endif // IAPMONITOR_H
-
diff --git a/src/plugins/bearer/icd/icd.pro b/src/plugins/bearer/icd/icd.pro
deleted file mode 100644
index 8cbf86d..0000000
--- a/src/plugins/bearer/icd/icd.pro
+++ /dev/null
@@ -1,33 +0,0 @@
-TARGET = qicdbearer
-load(qt_plugin)
-
-QT = core network network-private dbus
-
-QMAKE_CXXFLAGS *= $$QT_CFLAGS_DBUS $$QT_CFLAGS_CONNSETTINGS
-LIBS += $$QT_LIBS_CONNSETTINGS
-
-HEADERS += qicdengine.h \
-           qnetworksession_impl.h \
-           dbusdispatcher.h \
-           iapconf.h \
-           iapmonitor.h \
-           maemo_icd.h \
-           proxyconf.h \
-           wlan-utils.h
-
-SOURCES += main.cpp \
-           qicdengine.cpp \
-           qnetworksession_impl.cpp \
-           dbusdispatcher.cpp \
-           iapmonitor.cpp \
-           iapconf.cpp \
-           maemo_icd.cpp \
-           proxyconf.cpp
-
-#DEFINES += BEARER_MANAGEMENT_DEBUG
-
-include(../../../3rdparty/libgq.pri)
-
-DESTDIR = $$QT.network.plugins/bearer
-target.path += $$[QT_INSTALL_PLUGINS]/bearer
-INSTALLS += target
diff --git a/src/plugins/bearer/icd/maemo_icd.cpp b/src/plugins/bearer/icd/maemo_icd.cpp
deleted file mode 100644
index e740f48..0000000
--- a/src/plugins/bearer/icd/maemo_icd.cpp
+++ /dev/null
@@ -1,855 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include "maemo_icd.h"
-#include "dbusdispatcher.h"
-
-#include <QObject>
-#include <QTimer>
-#include <QCoreApplication>
-#include <QEventLoop>
-#include <QDebug>
-#include <dbus/dbus.h>
-#include <dbus/dbus-glib-lowlevel.h>
-
-#include <stdio.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-namespace Maemo {
-
-#undef PRINT_DEBUGINFO
-#ifdef PRINT_DEBUGINFO
-  static FILE *fdebug = NULL;
-#define PDEBUG(fmt, args...)						\
-  do {									\
-    struct timeval tv;							\
-    gettimeofday(&tv, 0);						\
-    fprintf(fdebug, "DEBUG[%d]:%ld.%ld:%s:%s():%d: " fmt,		\
-	    getpid(),							\
-	    tv.tv_sec, tv.tv_usec,					\
-	    __FILE__, __FUNCTION__, __LINE__, args);			\
-    fflush(fdebug);							\
-  } while(0)
-#else
-#define PDEBUG(fmt...)
-#endif
-
-
-class IcdPrivate
-{
-public:
-    IcdPrivate(Icd *myfriend)
-    {
-        init(10000, IcdNewDbusInterface, myfriend);
-    }
-
-    IcdPrivate(unsigned int timeout, Icd *myfriend)
-    {
-        init(timeout, IcdNewDbusInterface, myfriend);
-    }
-
-    IcdPrivate(unsigned int timeout, IcdDbusInterfaceVer ver, Icd *myfriend)
-    {
-        Q_UNUSED(ver);
-
-        /* Note that the old Icd interface is currently disabled and
-	 * the new one is always used.
-	 */
-        init(timeout, IcdNewDbusInterface, myfriend);
-    }
-
-    ~IcdPrivate()
-    {
-      QObject::disconnect(mDBus, 
-			  SIGNAL(signalReceived(const QString&, 
-						const QString&,
-						const QList<QVariant>&)),
-			  icd,
-			  SLOT(icdSignalReceived(const QString&, 
-						 const QString&,
-						 const QList<QVariant>&)));
-
-      QObject::disconnect(mDBus,
-			  SIGNAL(callReply(const QString&,
-					   const QList<QVariant>&,
-					   const QString&)),
-			  icd,
-			  SLOT(icdCallReply(const QString&,
-					    const QList<QVariant>&,
-					    const QString&)));
-
-        delete mDBus;
-        mDBus = 0;
-    }
-
-    /* Icd2 dbus API functions */
-    QStringList scan(icd_scan_request_flags flags,
-		     QStringList &network_types,
-		     QList<IcdScanResult>& scan_results,
-		     QString& error);
-
-    uint state(QString& service_type, uint service_attrs,
-	       QString& service_id, QString& network_type,
-	       uint network_attrs, QByteArray& network_id,
-	       IcdStateResult &state_result);
-
-    uint addrinfo(QString& service_type, uint service_attrs,
-		  QString& service_id, QString& network_type,
-		  uint network_attrs, QByteArray& network_id,
-		  IcdAddressInfoResult& addr_result);
-
-    uint state(QList<IcdStateResult>& state_results);
-    uint statistics(QList<IcdStatisticsResult>& stats_results);
-    uint addrinfo(QList<IcdAddressInfoResult>& addr_results);
-
-    void signalReceived(const QString& interface, 
-                        const QString& signal,
-                        const QList<QVariant>& args);
-    void callReply(const QString& method, 
-                   const QList<QVariant>& args,
-                   const QString& error);
-
-public:
-    DBusDispatcher *mDBus;
-    QString mMethod;
-    QString mInterface;
-    QString mSignal;
-    QString mError;
-    QList<QVariant> mArgs;
-    QList<QVariant> receivedSignals;
-    unsigned int timeout;
-    IcdDbusInterfaceVer icd_dbus_version;
-    Icd *icd;
-
-    void init(unsigned int dbus_timeout, IcdDbusInterfaceVer ver,
-	      Icd *myfriend)
-    {
-      if (ver == IcdNewDbusInterface) {
-	mDBus = new DBusDispatcher(ICD_DBUS_API_INTERFACE,
-				   ICD_DBUS_API_PATH,
-				   ICD_DBUS_API_INTERFACE);
-      } else {
-	mDBus = new DBusDispatcher(ICD_DBUS_SERVICE,
-				   ICD_DBUS_PATH,
-				   ICD_DBUS_INTERFACE);
-      }
-      icd_dbus_version = ver;
-
-      /* This connect has a side effect as it means that only one
-       * Icd object can exists in one time. This should be fixed!
-       */
-      QObject::connect(mDBus, 
-		       SIGNAL(signalReceived(const QString&, 
-					     const QString&,
-					     const QList<QVariant>&)),
-		       myfriend,
-		       SLOT(icdSignalReceived(const QString&, 
-					      const QString&,
-					      const QList<QVariant>&)));
-
-      QObject::connect(mDBus,
-		       SIGNAL(callReply(const QString&,
-					const QList<QVariant>&,
-					const QString&)),
-		       myfriend,
-		       SLOT(icdCallReply(const QString&,
-					 const QList<QVariant>&,
-					 const QString&)));
-
-      icd = myfriend;
-      timeout = dbus_timeout;
-
-#ifdef PRINT_DEBUGINFO
-      if (!fdebug) {
-	fdebug = fopen("/tmp/maemoicd.log", "a+");
-      }
-      PDEBUG("created %s\n", "IcdPrivate");
-#endif
-    }
-
-    void clearState()
-    {
-      mMethod.clear();
-      mInterface.clear();
-      mSignal.clear();
-      mError.clear();
-      mArgs.clear();
-      receivedSignals.clear();
-    }
-
-    bool doState();
-};
-
-
-void IcdPrivate::signalReceived(const QString& interface, 
-				const QString& signal,
-				const QList<QVariant>& args)
-{
-    // Signal handler, which simply records what has been signalled
-    mInterface = interface;
-    mSignal = signal;
-    mArgs = args;
-
-    //qDebug() << "signal" << signal << "received:" << args;
-    receivedSignals << QVariant(interface) << QVariant(signal) << QVariant(args);
-}
-
-
-void IcdPrivate::callReply(const QString& method, 
-			   const QList<QVariant>& /*args*/,
-			   const QString& error)
-{
-    mMethod = method;
-    mError = error;
-}
-
-
-static void get_scan_result(QList<QVariant>& args,
-			    IcdScanResult& ret)
-{
-    int i=0;
-
-    if (args.isEmpty())
-      return;
-
-    ret.status = args[i++].toUInt();
-    ret.timestamp = args[i++].toUInt();
-    ret.scan.service_type = args[i++].toString();
-    ret.service_name = args[i++].toString();
-    ret.scan.service_attrs = args[i++].toUInt();
-    ret.scan.service_id = args[i++].toString();
-    ret.service_priority = args[i++].toInt();
-    ret.scan.network_type = args[i++].toString();
-    ret.network_name = args[i++].toString();
-    ret.scan.network_attrs = args[i++].toUInt();
-    ret.scan.network_id = args[i++].toByteArray();
-    ret.network_priority = args[i++].toInt();
-    ret.signal_strength = args[i++].toInt();
-    ret.station_id = args[i++].toString();
-    ret.signal_dB = args[i++].toInt();
-}
-
-
-QStringList IcdPrivate::scan(icd_scan_request_flags flags,
-			     QStringList &network_types,
-			     QList<IcdScanResult>& scan_results,
-			     QString& error)
-{
-    Q_UNUSED(network_types);
-
-    QStringList scanned_types;
-    QTimer timer;
-    QVariant reply;
-    QVariantList vl;
-    bool last_result = false;
-    IcdScanResult result;
-    int all_waited;
-    
-    clearState();
-    reply = mDBus->call(ICD_DBUS_API_SCAN_REQ, (uint)flags);
-    if (reply.type() != QVariant::List)
-        return scanned_types;
-    vl = reply.toList();
-    if (vl.isEmpty()) {
-        error = "Scan did not return anything.";
-	return scanned_types;
-    }
-    reply = vl.first();
-    scanned_types = reply.toStringList();
-    //qDebug() << "Scanning:" << scanned_types;
-    all_waited = scanned_types.size();
-
-    timer.setSingleShot(true);
-    timer.start(timeout);
-
-    scan_results.clear();
-    while (!last_result) {
-	while (timer.isActive() && mInterface.isEmpty() && mError.isEmpty()) {
-	    QCoreApplication::processEvents(QEventLoop::AllEvents, 1000);
-	}
-
-	if (!timer.isActive()) {
-	    //qDebug() << "Timeout happened";
-	    break;
-	}
-
-	if (mSignal != ICD_DBUS_API_SCAN_SIG) {
-	    //qDebug() << "Received" << mSignal << "while waiting" << ICD_DBUS_API_SCAN_SIG << ", ignoring";
-	    mInterface.clear();
-	    continue;
-	}
-
-	if (mError.isEmpty()) {
-  	    QString msgInterface = receivedSignals.takeFirst().toString();
-	    QString msgSignal = receivedSignals.takeFirst().toString();
-	    QList<QVariant> msgArgs = receivedSignals.takeFirst().toList();
-	    //qDebug() << "Signal" << msgSignal << "received.";
-	    //qDebug() << "Params:" << msgArgs;
-
-	    while (!msgSignal.isEmpty()) {
-		get_scan_result(msgArgs, result);
-
-#if 0
-		qDebug() << "Received: " <<
-		    "status =" << result.status <<
-		    ", timestamp =" << result.timestamp <<
-		    ", service_type =" << result.scan.service_type <<
-		    ", service_name =" << result.service_name <<
-		    ", service_attrs =" << result.scan.service_attrs <<
-		    ", service_id =" << result.scan.service_id <<
-		    ", service_priority =" << result.service_priority <<
-		    ", network_type =" << result.scan.network_type <<
-		    ", network_name =" << result.network_name <<
-		    ", network_attrs =" << result.scan.network_attrs <<
-		    ", network_id =" << "-" <<
-		    ", network_priority =" << result.network_priority <<
-		    ", signal_strength =" << result.signal_strength <<
-		    ", station_id =" << result.station_id <<
-		    ", signal_dB =" << result.signal_dB;
-#endif
-
-		if (result.status == ICD_SCAN_COMPLETE) {
-		    //qDebug() << "waited =" << all_waited;
-		    if (--all_waited == 0) {
-		        last_result = true;
-			break;
-		    }
-		} else
-		    scan_results << result;
-
-		if (receivedSignals.isEmpty())
-		    break;
-
-		msgInterface = receivedSignals.takeFirst().toString();
-		msgSignal = receivedSignals.takeFirst().toString();
-		msgArgs = receivedSignals.takeFirst().toList();
-	    }
-	    mInterface.clear();
-
-	} else {
-	    qWarning() << "Error while scanning:" << mError;
-	    break;
-	}
-    }
-    timer.stop();
-
-    error = mError;
-    return scanned_types;
-}
-
-
-static void get_state_all_result(QList<QVariant>& args,
-				 IcdStateResult& ret)
-{
-    int i=0;
-
-    ret.params.service_type = args[i++].toString();
-    ret.params.service_attrs = args[i++].toUInt();
-    ret.params.service_id = args[i++].toString();
-    ret.params.network_type = args[i++].toString();
-    ret.params.network_attrs = args[i++].toUInt();
-    ret.params.network_id = args[i++].toByteArray();
-    ret.error = args[i++].toString();
-    ret.state = args[i++].toInt();
-}
-
-
-static void get_state_all_result2(QList<QVariant>& args,
-				 IcdStateResult& ret)
-{
-    int i=0;
-
-    ret.params.network_type = args[i++].toString();
-    ret.state = args[i++].toInt();
-
-    // Initialize the other values so that the caller can
-    // notice we only returned partial status
-    ret.params.service_type = QString();
-    ret.params.service_attrs = 0;
-    ret.params.service_id = QString();
-    ret.params.network_attrs = 0;
-    ret.params.network_id = QByteArray();
-    ret.error = QString();
-}
-
-
-uint IcdPrivate::state(QString& service_type, uint service_attrs,
-		       QString& service_id, QString& network_type,
-		       uint network_attrs, QByteArray& network_id,
-		       IcdStateResult& state_result)
-{
-    QTimer timer;
-    QVariant reply;
-    uint total_signals;
-    QVariantList vl;
-
-    clearState();
-
-    reply = mDBus->call(ICD_DBUS_API_STATE_REQ,
-			service_type, service_attrs, service_id,
-			network_type, network_attrs, network_id);
-    if (reply.type() != QVariant::List)
-        return 0;
-    vl = reply.toList();
-    if (vl.isEmpty())
-        return 0;
-    reply = vl.first();
-    total_signals = reply.toUInt();
-    if (!total_signals)
-        return 0;
-
-    timer.setSingleShot(true);
-    timer.start(timeout);
-
-    mInterface.clear();
-    while (timer.isActive() && mInterface.isEmpty()) {
-        QCoreApplication::processEvents(QEventLoop::AllEvents, 1000);
-
-	if (mSignal != ICD_DBUS_API_STATE_SIG) {
-            mInterface.clear();
-	    continue;
-	}
-    }
-
-    timer.stop();
-
-    if (mError.isEmpty()) {
-        if (!mArgs.isEmpty()) {
-	    if (mArgs.size()>2)
-	        get_state_all_result(mArgs, state_result);
-	    else {
-	        // We are not connected as we did not get the status we asked
-	        return 0;
-	    }
-	}
-    } else {
-        qWarning() << "Error:" << mError;
-    }
-
-    // The returned value should be one because we asked for one state
-    return total_signals;
-}
-
-
-/* Special version of the state() call which does not call event loop.
- * Needed in order to fix NB#175098 where Qt4.7 webkit crashes because event
- * loop is run when webkit does not expect it. This function is called from
- * bearer management API syncStateWithInterface() in QNetworkSession
- * constructor.
- */
-uint IcdPrivate::state(QList<IcdStateResult>& state_results)
-{
-    QVariant reply;
-    QVariantList vl;
-    uint signals_left, total_signals;
-    IcdStateResult result;
-    time_t started;
-    int timeout_secs = timeout / 1000;
-
-    PDEBUG("%s\n", "state_results");
-
-    clearState();
-    reply = mDBus->call(ICD_DBUS_API_STATE_REQ);
-    if (reply.type() != QVariant::List)
-        return 0;
-    vl = reply.toList();
-    if (vl.isEmpty())
-        return 0;
-    reply = vl.first();
-    signals_left = total_signals = reply.toUInt();
-    if (!signals_left)
-        return 0;
-
-    started = time(0);
-    state_results.clear();
-    mError.clear();
-    while (signals_left) {
-        mInterface.clear();
-	while ((time(0)<=(started+timeout_secs)) && mInterface.isEmpty()) {
-	    mDBus->synchronousDispatch(1000);
-        QCoreApplication::sendPostedEvents(icd, QEvent::MetaCall);
-	}
-
-        if (time(0)>(started+timeout_secs)) {
-	    total_signals = 0;
-	    break;
-	}
-
-	if (mSignal != ICD_DBUS_API_STATE_SIG) {
-	    continue;
-	}
-
-	if (mError.isEmpty()) {
-	    if (!mArgs.isEmpty()) {
-	        if (mArgs.size()==2)
-	            get_state_all_result2(mArgs, result);
-		else
-	            get_state_all_result(mArgs, result);
-		state_results << result;
-	    }
-	    signals_left--;
-	} else {
-	    qWarning() << "Error:" << mError;
-	    break;
-	}
-    }
-
-    PDEBUG("total_signals=%d\n", total_signals);
-    return total_signals;
-}
-
-
-static void get_statistics_all_result(QList<QVariant>& args,
-				      IcdStatisticsResult& ret)
-{
-    int i=0;
-
-    if (args.isEmpty())
-      return;
-
-    ret.params.service_type = args[i++].toString();
-    ret.params.service_attrs = args[i++].toUInt();
-    ret.params.service_id = args[i++].toString();
-    ret.params.network_type = args[i++].toString();
-    ret.params.network_attrs = args[i++].toUInt();
-    ret.params.network_id = args[i++].toByteArray();
-    ret.time_active = args[i++].toUInt();
-    ret.signal_strength = (enum icd_nw_levels)args[i++].toUInt();
-    ret.bytes_sent = args[i++].toUInt();
-    ret.bytes_received = args[i++].toUInt();
-}
-
-
-uint IcdPrivate::statistics(QList<IcdStatisticsResult>& stats_results)
-{
-    QTimer timer;
-    QVariant reply;
-    QVariantList vl;
-    uint signals_left, total_signals;
-    IcdStatisticsResult result;
-
-    clearState();
-    reply = mDBus->call(ICD_DBUS_API_STATISTICS_REQ);
-    if (reply.type() != QVariant::List)
-        return 0;
-    vl = reply.toList();
-    if (vl.isEmpty())
-        return 0;
-    reply = vl.first();
-    if (reply.type() != QVariant::UInt)
-        return 0;
-    signals_left = total_signals = reply.toUInt();
-
-    if (!signals_left)
-        return 0;
-
-    timer.setSingleShot(true);
-    timer.start(timeout);
-    stats_results.clear();
-    while (signals_left) {
-	mInterface.clear();
-	while (timer.isActive() && mInterface.isEmpty()) {
-	    QCoreApplication::processEvents(QEventLoop::AllEvents, 1000);
-	}
-
-	if (!timer.isActive()) {
-	    total_signals = 0;
-	    break;
-	}
-
-	if (mSignal != ICD_DBUS_API_STATISTICS_SIG) {
-	    continue;
-	}
-
-	if (mError.isEmpty()) {
-  	    get_statistics_all_result(mArgs, result);
-	    stats_results << result;
-	    signals_left--;
-	} else {
-	    qWarning() << "Error:" << mError;
-	    break;
-	}
-    }
-    timer.stop();
-
-    return total_signals;
-}
-
-
-static void get_addrinfo_all_result(QList<QVariant>& args,
-				    IcdAddressInfoResult& ret)
-{
-    int i=0;
-
-    if (args.isEmpty())
-      return;
-
-    ret.params.service_type = args[i++].toString();
-    ret.params.service_attrs = args[i++].toUInt();
-    ret.params.service_id = args[i++].toString();
-    ret.params.network_type = args[i++].toString();
-    ret.params.network_attrs = args[i++].toUInt();
-    ret.params.network_id = args[i++].toByteArray();
-
-    QVariantList vl = args[i].toList();
-    QVariant reply = vl.first();
-    QList<QVariant> lst = reply.toList();
-    for (int k=0; k<lst.size()/6; k=k+6) {
-        IcdIPInformation ip_info;
-	ip_info.address = lst[k].toString();
-	ip_info.netmask = lst[k++].toString();
-	ip_info.default_gateway = lst[k++].toString();
-	ip_info.dns1 = lst[k++].toString();
-	ip_info.dns2 = lst[k++].toString();
-	ip_info.dns3 = lst[k++].toString();
-
-	ret.ip_info << ip_info;
-    }
-}
-
-
-/* Special version of the addrinfo() call which does not call event loop.
- * Needed in order to fix NB#175098 where Qt4.7 webkit crashes because event
- * loop is run when webkit does not expect it. This function is called from
- * bearer management API syncStateWithInterface() in QNetworkSession
- * constructor.
- */
-uint IcdPrivate::addrinfo(QList<IcdAddressInfoResult>& addr_results)
-{
-    QVariant reply;
-    QVariantList vl;
-    uint signals_left, total_signals;
-    IcdAddressInfoResult result;
-    time_t started;
-    int timeout_secs = timeout / 1000;
-
-    PDEBUG("%s\n", "addr_results");
-
-    clearState();
-    reply = mDBus->call(ICD_DBUS_API_ADDRINFO_REQ);
-    if (reply.type() != QVariant::List)
-        return 0;
-    vl = reply.toList();
-    if (vl.isEmpty())
-        return 0;
-    reply = vl.first();
-    if (reply.type() != QVariant::UInt)
-        return 0;
-    signals_left = total_signals = reply.toUInt();
-    if (!signals_left)
-        return 0;
-
-    started = time(0);
-    addr_results.clear();
-    while (signals_left) {
-        mInterface.clear();
-	while ((time(0)<=(started+timeout_secs)) && mInterface.isEmpty()) {
-	    mDBus->synchronousDispatch(1000);
-        QCoreApplication::sendPostedEvents(icd, QEvent::MetaCall);
-	}
-
-        if (time(0)>(started+timeout_secs)) {
-	    total_signals = 0;
-	    break;
-	}
-
-	if (mSignal != ICD_DBUS_API_ADDRINFO_SIG) {
-	    continue;
-	}
-
-	if (mError.isEmpty()) {
-  	    get_addrinfo_all_result(mArgs, result);
-	    addr_results << result;
-	    signals_left--;
-	} else {
-	    qWarning() << "Error:" << mError;
-	    break;
-	}
-    }
-
-    PDEBUG("total_signals=%d\n", total_signals);
-    return total_signals;
-}
-
-
-uint IcdPrivate::addrinfo(QString& service_type, uint service_attrs,
-			  QString& service_id, QString& network_type,
-			  uint network_attrs, QByteArray& network_id,
-			  IcdAddressInfoResult& addr_result)
-{
-    QTimer timer;
-    QVariant reply;
-    uint total_signals;
-    QVariantList vl;
-
-    clearState();
-
-    reply = mDBus->call(ICD_DBUS_API_ADDRINFO_REQ,
-			service_type, service_attrs, service_id,
-			network_type, network_attrs, network_id);
-    if (reply.type() != QVariant::List)
-        return 0;
-    vl = reply.toList();
-    if (vl.isEmpty())
-        return 0;
-    reply = vl.first();
-    total_signals = reply.toUInt();
-
-    if (!total_signals)
-        return 0;
-
-    timer.setSingleShot(true);
-    timer.start(timeout);
-
-    mInterface.clear();
-    while (timer.isActive() && mInterface.isEmpty()) {
-        QCoreApplication::processEvents(QEventLoop::AllEvents, 1000);
-
-	if (mSignal != ICD_DBUS_API_ADDRINFO_SIG) {
-            mInterface.clear();
-	    continue;
-	}
-    }
-
-    timer.stop();
-
-    if (mError.isEmpty()) {
-        get_addrinfo_all_result(mArgs, addr_result);
-    } else {
-        qWarning() << "Error:" << mError;
-    }
-
-    // The returned value should be one because we asked for one addrinfo
-    return total_signals;
-}
-
-
-Icd::Icd(QObject *parent)
-  : QObject(parent), d(new IcdPrivate(this))
-{
-}
-
-Icd::Icd(unsigned int timeout, QObject *parent)
-  : QObject(parent), d(new IcdPrivate(timeout, this))
-{
-}
-
-Icd::Icd(unsigned int timeout, IcdDbusInterfaceVer ver, QObject *parent)
-  : QObject(parent), d(new IcdPrivate(timeout, ver, this))
-{
-}
-
-Icd::~Icd()
-{
-    delete d;
-}
-
-
-QStringList Icd::scan(icd_scan_request_flags flags,
-		      QStringList &network_types,
-		      QList<IcdScanResult>& scan_results,
-		      QString& error)
-{
-    return d->scan(flags, network_types, scan_results, error);
-}
-
-
-uint Icd::state(QString& service_type, uint service_attrs,
-		QString& service_id, QString& network_type,
-		uint network_attrs, QByteArray& network_id,
-		IcdStateResult &state_result)
-{
-    return d->state(service_type, service_attrs, service_id,
-		    network_type, network_attrs, network_id,
-		    state_result);
-}
-
-
-uint Icd::addrinfo(QString& service_type, uint service_attrs,
-		   QString& service_id, QString& network_type,
-		   uint network_attrs, QByteArray& network_id,
-		   IcdAddressInfoResult& addr_result)
-{
-    return d->addrinfo(service_type, service_attrs, service_id,
-		       network_type, network_attrs, network_id,
-		       addr_result);
-}
-
-
-uint Icd::state(QList<IcdStateResult>& state_results)
-{
-    return d->state(state_results);
-}
-
-
-uint Icd::statistics(QList<IcdStatisticsResult>& stats_results)
-{
-    return d->statistics(stats_results);
-}
-
-
-uint Icd::addrinfo(QList<IcdAddressInfoResult>& addr_results)
-{
-    return d->addrinfo(addr_results);
-}
-
-
-void Icd::icdSignalReceived(const QString& interface, 
-			 const QString& signal,
-			 const QList<QVariant>& args)
-{
-    d->signalReceived(interface, signal, args);
-}
-
-
-void Icd::icdCallReply(const QString& method, 
-		    const QList<QVariant>& args,
-		    const QString& error)
-{
-    d->callReply(method, args, error);
-}
-
-}  // Maemo namespace
-
-
diff --git a/src/plugins/bearer/icd/maemo_icd.h b/src/plugins/bearer/icd/maemo_icd.h
deleted file mode 100644
index 3be4646..0000000
--- a/src/plugins/bearer/icd/maemo_icd.h
+++ /dev/null
@@ -1,174 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef MAEMO_ICD_H
-#define MAEMO_ICD_H
-
-#include <QObject>
-#include <QStringList>
-#include <QByteArray>
-#include <QMetaType>
-#include <QtDBus>
-#include <QDBusArgument>
-
-#include <glib.h>
-#include <icd/dbus_api.h>
-#include <icd/osso-ic.h>
-#include <icd/osso-ic-dbus.h>
-#include <icd/network_api_defines.h>
-
-#define ICD_LONG_SCAN_TIMEOUT (30*1000)  /* 30sec */
-#define ICD_SHORT_SCAN_TIMEOUT (10*1000)  /* 10sec */
-#define ICD_SHORT_CONNECT_TIMEOUT (10*1000) /* 10sec */
-#define ICD_LONG_CONNECT_TIMEOUT (150*1000) /* 2.5min */
-
-namespace Maemo {
-
-struct CommonParams {
-	QString service_type;
-	uint service_attrs;
-	QString service_id;
-	QString network_type;
-	uint network_attrs;
-	QByteArray network_id;
-};
-
-struct IcdScanResult {
-	uint status; // see #icd_scan_status
-	uint timestamp; // when last seen
-	QString service_name;
-	uint service_priority; // within a service type
-	QString network_name;
-	uint network_priority;
-	struct CommonParams scan;
-	uint signal_strength; // quality, 0 (none) - 10 (good)
-	QString station_id; // e.g. MAC address or similar id
-	uint signal_dB; // use signal strength above unless you know what you are doing
-
-	IcdScanResult() {
-		status = timestamp = scan.service_attrs = service_priority =
-			scan.network_attrs = network_priority = signal_strength =
-			signal_dB = 0;
-	}
-};
-
-struct IcdStateResult {
-	struct CommonParams params;
-	QString error;
-	uint state;
-};
-
-struct IcdStatisticsResult {
-	struct CommonParams params;
-	uint time_active;  // in seconds
-	enum icd_nw_levels signal_strength; // see network_api_defines.h in icd2-dev package
-	uint bytes_sent;
-	uint bytes_received;
-};
-
-struct IcdIPInformation {
-	QString address;
-	QString netmask;
-	QString default_gateway;
-	QString dns1;
-	QString dns2;
-	QString dns3;
-};
-
-struct IcdAddressInfoResult {
-	struct CommonParams params;
-	QList<IcdIPInformation> ip_info;
-};
-
-enum IcdDbusInterfaceVer {
-	IcdOldDbusInterface = 0,  // use the old OSSO-IC interface
-	IcdNewDbusInterface       // use the new Icd2 interface (default)
-};
-
-
-class IcdPrivate;
-class Icd : public QObject
-{
-    Q_OBJECT
-
-public:
-    Icd(QObject *parent = 0);
-    Icd(unsigned int timeout, QObject *parent = 0);
-    Icd(unsigned int timeout, IcdDbusInterfaceVer ver, QObject *parent = 0);
-    ~Icd();
-
-    /* Icd2 dbus API functions */
-    QStringList scan(icd_scan_request_flags flags,
-		     QStringList &network_types,
-		     QList<IcdScanResult>& scan_results,
-		     QString& error);
-
-    uint state(QString& service_type, uint service_attrs,
-	       QString& service_id, QString& network_type,
-	       uint network_attrs, QByteArray& network_id,
-	       IcdStateResult &state_result);
-
-    uint addrinfo(QString& service_type, uint service_attrs,
-		  QString& service_id, QString& network_type,
-		  uint network_attrs, QByteArray& network_id,
-		  IcdAddressInfoResult& addr_result);
-
-    uint state(QList<IcdStateResult>& state_results);
-    uint statistics(QList<IcdStatisticsResult>& stats_results);
-    uint addrinfo(QList<IcdAddressInfoResult>& addr_results);
-
-private Q_SLOTS:
-    void icdSignalReceived(const QString& interface, 
-                        const QString& signal,
-                        const QList<QVariant>& args);
-    void icdCallReply(const QString& method, 
-                   const QList<QVariant>& args,
-                   const QString& error);
-
-private:
-    IcdPrivate *d;
-    friend class IcdPrivate;
-};
-
-}  // Maemo namespace
-
-#endif
diff --git a/src/plugins/bearer/icd/main.cpp b/src/plugins/bearer/icd/main.cpp
deleted file mode 100644
index a9fb68f..0000000
--- a/src/plugins/bearer/icd/main.cpp
+++ /dev/null
@@ -1,88 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qicdengine.h"
-
-#include <QtNetwork/private/qbearerplugin_p.h>
-
-#include <QtCore/qdebug.h>
-
-#ifndef QT_NO_BEARERMANAGEMENT
-
-QT_BEGIN_NAMESPACE
-
-class QIcdEnginePlugin : public QBearerEnginePlugin
-{
-public:
-    QIcdEnginePlugin();
-    ~QIcdEnginePlugin();
-
-    QStringList keys() const;
-    QBearerEngine *create(const QString &key) const;
-};
-
-QIcdEnginePlugin::QIcdEnginePlugin()
-{
-}
-
-QIcdEnginePlugin::~QIcdEnginePlugin()
-{
-}
-
-QStringList QIcdEnginePlugin::keys() const
-{
-    return QStringList() << QLatin1String("icd");
-}
-
-QBearerEngine *QIcdEnginePlugin::create(const QString &key) const
-{
-    if (key == QLatin1String("icd"))
-        return new QIcdEngine;
-    else
-        return 0;
-}
-
-Q_EXPORT_STATIC_PLUGIN(QIcdEnginePlugin)
-Q_EXPORT_PLUGIN2(qicdbearer, QIcdEnginePlugin)
-
-QT_END_NAMESPACE
-
-#endif
diff --git a/src/plugins/bearer/icd/proxyconf.cpp b/src/plugins/bearer/icd/proxyconf.cpp
deleted file mode 100644
index 93b6f3f..0000000
--- a/src/plugins/bearer/icd/proxyconf.cpp
+++ /dev/null
@@ -1,422 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#include <QVariant>
-#include <QStringList>
-#include <QDebug>
-#include <QWriteLocker>
-#include <QNetworkProxyFactory>
-#include <QNetworkProxy>
-#include <gconf/gconf-value.h>
-#include <gconf/gconf-client.h>
-#include "proxyconf.h"
-
-#define CONF_PROXY "/system/proxy"
-#define HTTP_PROXY "/system/http_proxy"
-
-
-namespace Maemo {
-
-static QString convertKey(const char *key)
-{
-    return QString::fromUtf8(key);
-}
-
-static QVariant convertValue(GConfValue *src)
-{
-    if (!src) {
-        return QVariant();
-    } else {
-        switch (src->type) {
-        case GCONF_VALUE_INVALID:
-            return QVariant(QVariant::Invalid);
-        case GCONF_VALUE_BOOL:
-            return QVariant((bool)gconf_value_get_bool(src));
-        case GCONF_VALUE_INT:
-            return QVariant(gconf_value_get_int(src));
-        case GCONF_VALUE_FLOAT:
-            return QVariant(gconf_value_get_float(src));
-        case GCONF_VALUE_STRING:
-            return QVariant(QString::fromUtf8(gconf_value_get_string(src)));
-        case GCONF_VALUE_LIST:
-            switch (gconf_value_get_list_type(src)) {
-            case GCONF_VALUE_STRING:
-                {
-                    QStringList result;
-                    for (GSList *elts = gconf_value_get_list(src); elts; elts = elts->next)
-                        result.append(QString::fromUtf8(gconf_value_get_string((GConfValue *)elts->data)));
-                    return QVariant(result);
-                }
-            default:
-                {
-                    QList<QVariant> result;
-                    for (GSList *elts = gconf_value_get_list(src); elts; elts = elts->next)
-                        result.append(convertValue((GConfValue *)elts->data));
-                    return QVariant(result);
-                }
-            }
-        case GCONF_VALUE_SCHEMA:
-        default:
-            return QVariant();
-        }
-    }
-}
-
-
-/* Fast version of GConfItem, allows reading subtree at a time */
-class GConfItemFast {
-public:
-  GConfItemFast(const QString &k) : key(k) {}
-  QHash<QString,QVariant> getEntries() const;
-
-private:
-  QString key;
-};
-
-#define withClient(c) for (GConfClient *c = gconf_client_get_default(); c; c=0)
-
-
-QHash<QString,QVariant> GConfItemFast::getEntries() const
-{
-    QHash<QString,QVariant> children;
-
-    withClient(client) {
-        QByteArray k = key.toUtf8();
-        GSList *entries = gconf_client_all_entries(client, k.data(), NULL);
-        for (GSList *e = entries; e; e = e->next) {
-	    char *key_name = strrchr(((GConfEntry *)e->data)->key, '/');
-	    if (!key_name)
-	        key_name = ((GConfEntry *)e->data)->key;
-	    else
-	        key_name++;
-	    QString key(convertKey(key_name));
-	    QVariant value = convertValue(((GConfEntry *)e->data)->value);
-	    gconf_entry_unref((GConfEntry *)e->data);
-	    //qDebug()<<"key="<<key<<"value="<<value;
-	    children.insert(key, value);
-        }
-        g_slist_free (entries);
-    }
-
-    return children;
-}
-
-
-
-class NetworkProxyFactory : QNetworkProxyFactory
-{
-    ProxyConf proxy_conf;
-    bool proxy_data_read;
-
-public:
-    NetworkProxyFactory() : proxy_data_read(false) {  }
-    QList<QNetworkProxy> queryProxy(const QNetworkProxyQuery &query = QNetworkProxyQuery());
-};
-
-
-QList<QNetworkProxy> NetworkProxyFactory::queryProxy(const QNetworkProxyQuery &query)
-{
-    if (proxy_data_read == false) {
-        proxy_data_read = true;
-        proxy_conf.readProxyData();
-    }
-
-    QList<QNetworkProxy> result = proxy_conf.flush(query);
-    if (result.isEmpty())
-        result << QNetworkProxy::NoProxy;
-
-    return result;
-}
-
-
-class ProxyConfPrivate {
-private:
-    // proxy values from gconf
-    QString mode;
-    bool use_http_host;
-    QString autoconfig_url;
-    QString http_proxy;
-    quint16 http_port;
-    QList<QVariant> ignore_hosts;
-    QString secure_host;
-    quint16 secure_port;
-    QString ftp_host;
-    quint16 ftp_port;
-    QString socks_host;
-    quint16 socks_port;
-    QString rtsp_host;
-    quint16 rtsp_port;
-
-    bool isHostExcluded(const QString &host);
-
-public:
-    QString prefix;
-    QString http_prefix;
-
-    void readProxyData();
-    QList<QNetworkProxy> flush(const QNetworkProxyQuery &query);
-};
-
-
-static QHash<QString,QVariant> getValues(const QString& prefix)
-{
-    GConfItemFast item(prefix);
-    return item.getEntries();
-}
-
-static QHash<QString,QVariant> getHttpValues(const QString& prefix)
-{
-    GConfItemFast item(prefix);
-    return item.getEntries();
-}
-
-#define GET(var, type)				\
-  do {						\
-    QVariant v = values.value(#var);		\
-    if (v.isValid())				\
-      var = v.to##type ();			\
-  } while(0)
-
-#define GET_HTTP(var, name, type)		\
-  do {						\
-    QVariant v = httpValues.value(#name);	\
-    if (v.isValid())				\
-      var = v.to##type ();			\
-  } while(0)
-
-
-void ProxyConfPrivate::readProxyData()
-{
-    QHash<QString,QVariant> values = getValues(prefix);
-    QHash<QString,QVariant> httpValues = getHttpValues(http_prefix);
-
-    //qDebug()<<"values="<<values;
-
-    /* Read the proxy settings from /system/proxy* */
-    GET_HTTP(http_proxy, host, String);
-    GET_HTTP(http_port, port, Int);
-    GET_HTTP(ignore_hosts, ignore_hosts, List);
-
-    GET(mode, String);
-    GET(autoconfig_url, String);
-    GET(secure_host, String);
-    GET(secure_port, Int);
-    GET(ftp_host, String);
-    GET(ftp_port, Int);
-    GET(socks_host, String);
-    GET(socks_port, Int);
-    GET(rtsp_host, String);
-    GET(rtsp_port, Int);
-
-    if (http_proxy.isEmpty())
-        use_http_host = false;
-    else
-        use_http_host = true;
-}
-
-
-bool ProxyConfPrivate::isHostExcluded(const QString &host)
-{
-    if (host.isEmpty())
-        return true;
-
-    if (ignore_hosts.isEmpty())
-        return false;
-
-    QHostAddress ipAddress;
-    bool isIpAddress = ipAddress.setAddress(host);
-
-    foreach (QVariant h, ignore_hosts) {
-        QString entry = h.toString();
-        if (isIpAddress && ipAddress.isInSubnet(QHostAddress::parseSubnet(entry))) {
-            return true;  // excluded
-        } else {
-            // do wildcard matching
-            QRegExp rx(entry, Qt::CaseInsensitive, QRegExp::Wildcard);
-            if (rx.exactMatch(host))
-                return true;
-        }
-    }
-
-    // host was not excluded
-    return false;
-}
-
-
-QList<QNetworkProxy> ProxyConfPrivate::flush(const QNetworkProxyQuery &query)
-{
-    QList<QNetworkProxy> result;
-
-#if 0
-    qDebug()<<"http_proxy" << http_proxy;
-    qDebug()<<"http_port" << http_port;
-    qDebug()<<"ignore_hosts" << ignore_hosts;
-    qDebug()<<"use_http_host" << use_http_host;
-    qDebug()<<"mode" << mode;
-    qDebug()<<"autoconfig_url" << autoconfig_url;
-    qDebug()<<"secure_host" << secure_host;
-    qDebug()<<"secure_port" << secure_port;
-    qDebug()<<"ftp_host" << ftp_host;
-    qDebug()<<"ftp_port" << ftp_port;
-    qDebug()<<"socks_host" << socks_host;
-    qDebug()<<"socks_port" << socks_port;
-    qDebug()<<"rtsp_host" << rtsp_host;
-    qDebug()<<"rtsp_port" << rtsp_port;
-#endif
-
-    if (isHostExcluded(query.peerHostName()))
-        return result;          // no proxy for this host
-
-    if (mode == QLatin1String("AUTO")) {
-        // TODO: pac currently not supported, fix me
-        return result;
-    }
-
-    if (mode == QLatin1String("MANUAL")) {
-        bool isHttps = false;
-	QString protocol = query.protocolTag().toLower();
-
-	// try the protocol-specific proxy
-	QNetworkProxy protocolSpecificProxy;
-
-	if (protocol == QLatin1String("ftp")) {
-	    if (!ftp_host.isEmpty()) {
-	        protocolSpecificProxy.setType(QNetworkProxy::FtpCachingProxy);
-		protocolSpecificProxy.setHostName(ftp_host);
-		protocolSpecificProxy.setPort(ftp_port);
-	    }
-	} else if (protocol == QLatin1String("http")) {
-	    if (!http_proxy.isEmpty()) {
-	        protocolSpecificProxy.setType(QNetworkProxy::HttpProxy);
-		protocolSpecificProxy.setHostName(http_proxy);
-		protocolSpecificProxy.setPort(http_port);
-	    }
-	} else if (protocol == QLatin1String("https")) {
-	    isHttps = true;
-	    if (!secure_host.isEmpty()) {
-	        protocolSpecificProxy.setType(QNetworkProxy::HttpProxy);
-		protocolSpecificProxy.setHostName(secure_host);
-		protocolSpecificProxy.setPort(secure_port);
-	    }
-	}
-
-	if (protocolSpecificProxy.type() != QNetworkProxy::DefaultProxy)
-	    result << protocolSpecificProxy;
-
-
-        if (!socks_host.isEmpty()) {
-	    QNetworkProxy proxy;
-	    proxy.setType(QNetworkProxy::Socks5Proxy);
-	    proxy.setHostName(socks_host);
-	    proxy.setPort(socks_port);
-	    result << proxy;
-	}
-
-
-	// Add the HTTPS proxy if present (and if we haven't added yet)
-	if (!isHttps) {
-	    QNetworkProxy https;
-	    if (!secure_host.isEmpty()) {
-	        https.setType(QNetworkProxy::HttpProxy);
-		https.setHostName(secure_host);
-		https.setPort(secure_port);
-	    }
-
-	    if (https.type() != QNetworkProxy::DefaultProxy &&
-		https != protocolSpecificProxy)
-	        result << https;
-	}
-    }
-
-    return result;
-}
-
-
-ProxyConf::ProxyConf()
-    : d_ptr(new ProxyConfPrivate)
-{
-    g_type_init();
-    d_ptr->prefix = CONF_PROXY;
-    d_ptr->http_prefix = HTTP_PROXY;
-}
-
-ProxyConf::~ProxyConf()
-{
-    delete d_ptr;
-}
-
-void ProxyConf::readProxyData()
-{
-    d_ptr->readProxyData();
-}
-
-QList<QNetworkProxy> ProxyConf::flush(const QNetworkProxyQuery &query)
-{
-    return d_ptr->flush(query);
-}
-
-
-static int refcount = 0;
-static QReadWriteLock lock;
-
-void ProxyConf::update()
-{
-    QWriteLocker locker(&lock);
-    NetworkProxyFactory *factory = new NetworkProxyFactory();
-    QNetworkProxyFactory::setApplicationProxyFactory((QNetworkProxyFactory*)factory);
-    refcount++;
-}
-
-
-void ProxyConf::clear(void)
-{
-    QWriteLocker locker(&lock);
-    refcount--;
-    if (refcount == 0)
-        QNetworkProxyFactory::setApplicationProxyFactory(NULL);
-
-    if (refcount<0)
-        refcount = 0;
-}
-
-
-} // namespace Maemo
diff --git a/src/plugins/bearer/icd/proxyconf.h b/src/plugins/bearer/icd/proxyconf.h
deleted file mode 100644
index 4564c5c..0000000
--- a/src/plugins/bearer/icd/proxyconf.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef PROXYCONF_H
-#define PROXYCONF_H
-
-#include <QString>
-#include <QNetworkProxy>
-
-namespace Maemo {
-
-class ProxyConfPrivate;
-class ProxyConf {
-private:
-    ProxyConfPrivate *d_ptr;
-
-public:
-    ProxyConf();
-    virtual ~ProxyConf();
-
-    QList<QNetworkProxy> flush(const QNetworkProxyQuery &query = QNetworkProxyQuery());  // read the proxies from db
-    void readProxyData();
-
-    /* Note that for each update() call there should be corresponding
-     * clear() call because the ProxyConf class implements a reference
-     * counting mechanism. The factory is removed only when there is
-     * no one using the factory any more.
-     */
-    static void update(void);          // this builds QNetworkProxy factory
-    static void clear(void);           // this removes QNetworkProxy factory
-};
-
-} // namespace Maemo
-
-#endif
diff --git a/src/plugins/bearer/icd/qicdengine.cpp b/src/plugins/bearer/icd/qicdengine.cpp
deleted file mode 100644
index b2693a9..0000000
--- a/src/plugins/bearer/icd/qicdengine.cpp
+++ /dev/null
@@ -1,1126 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qicdengine.h"
-#include "qnetworksession_impl.h"
-
-#include <wlancond.h>
-#include <wlan-utils.h>
-#include <iapconf.h>
-#include <iapmonitor.h>
-
-#ifndef QT_NO_BEARERMANAGEMENT
-
-QT_BEGIN_NAMESPACE
-
-IcdNetworkConfigurationPrivate::IcdNetworkConfigurationPrivate()
-:   service_attrs(0), network_attrs(0)
-{
-}
-
-IcdNetworkConfigurationPrivate::~IcdNetworkConfigurationPrivate()
-{
-}
-
-QString IcdNetworkConfigurationPrivate::bearerTypeName() const
-{
-    QMutexLocker locker(&mutex);
-
-    return iap_type;
-}
-
-/******************************************************************************/
-/** IapAddTimer specific                                                      */
-/******************************************************************************/
-
-/* The IapAddTimer is a helper class that makes sure we update
- * the configuration only after all db additions to certain
- * iap are finished (after a certain timeout)
- */
-class _IapAddTimer : public QObject
-{
-    Q_OBJECT
-
-public:
-    _IapAddTimer() {}
-    ~_IapAddTimer()
-    {
-	if (timer.isActive()) {
-	    QObject::disconnect(&timer, SIGNAL(timeout()), this, SLOT(timeout()));
-	    timer.stop();
-	}
-    }
-
-    void add(QString& iap_id, QIcdEngine *d);
-
-    QString iap_id;
-    QTimer timer;
-    QIcdEngine *d;
-
-public Q_SLOTS:
-    void timeout();
-};
-
-
-void _IapAddTimer::add(QString& id, QIcdEngine *d_ptr)
-{
-    iap_id = id;
-    d = d_ptr;
-
-    if (timer.isActive()) {
-	QObject::disconnect(&timer, SIGNAL(timeout()), this, SLOT(timeout()));
-	timer.stop();
-    }
-    timer.setSingleShot(true);
-    QObject::connect(&timer, SIGNAL(timeout()), this, SLOT(timeout()));
-    timer.start(1500);
-}
-
-
-void _IapAddTimer::timeout()
-{
-    d->addConfiguration(iap_id);
-}
-
-
-class IapAddTimer {
-    QHash<QString, _IapAddTimer* > timers;
-
-public:
-    IapAddTimer() {}
-    ~IapAddTimer() {}
-
-    void add(QString& iap_id, QIcdEngine *d);
-    void del(QString& iap_id);
-    void removeAll();
-};
-
-
-void IapAddTimer::removeAll()
-{
-    QHashIterator<QString, _IapAddTimer* > i(timers);
-    while (i.hasNext()) {
-	i.next();
-	_IapAddTimer *t = i.value();
-	delete t;
-    }
-    timers.clear();
-}
-
-
-void IapAddTimer::add(QString& iap_id, QIcdEngine *d)
-{
-    if (timers.contains(iap_id)) {
-	_IapAddTimer *iap = timers.value(iap_id);
-	iap->add(iap_id, d);
-    } else {
-	_IapAddTimer *iap = new _IapAddTimer;
-	iap->add(iap_id, d);
-	timers.insert(iap_id, iap);
-    }
-}
-
-void IapAddTimer::del(QString& iap_id)
-{
-    if (timers.contains(iap_id)) {
-	_IapAddTimer *iap = timers.take(iap_id);
-	delete iap;
-    }
-}
-
-/******************************************************************************/
-/** IAPMonitor specific                                                       */
-/******************************************************************************/
-
-class IapMonitor : public Maemo::IAPMonitor
-{
-public:
-    IapMonitor() : first_call(true) { }
-
-    void setup(QIcdEngine *d);
-    void cleanup();
-
-protected:
-    void iapAdded(const QString &iapId);
-    void iapRemoved(const QString &iapId);
-
-private:
-    bool first_call;
-
-    QIcdEngine *d;
-    IapAddTimer timers;
-};
-
-void IapMonitor::setup(QIcdEngine *d_ptr)
-{
-    if (first_call) {
-	d = d_ptr;
-	first_call = false;
-    }
-}
-
-
-void IapMonitor::cleanup()
-{
-    if (!first_call) {
-	timers.removeAll();
-	first_call = true;
-    }
-}
-
-
-void IapMonitor::iapAdded(const QString &iap_id)
-{
-    /* We cannot know when the IAP is fully added to db, so a timer is
-     * installed instead. When the timer expires we hope that IAP is added ok.
-     */
-    QString id = iap_id;
-    timers.add(id, d);
-}
-
-
-void IapMonitor::iapRemoved(const QString &iap_id)
-{
-    QString id = iap_id;
-    d->deleteConfiguration(id);
-}
-
-
-/******************************************************************************/
-/** QIcdEngine implementation                                                 */
-/******************************************************************************/
-
-QIcdEngine::QIcdEngine(QObject *parent)
-:   QBearerEngine(parent), iapMonitor(0), m_dbusInterface(0), m_icdServiceWatcher(0),
-    firstUpdate(true), m_scanGoingOn(false)
-{
-}
-
-QIcdEngine::~QIcdEngine()
-{
-    cleanup();
-    delete iapMonitor;
-}
-
-QNetworkConfigurationManager::Capabilities QIcdEngine::capabilities() const
-{
-    return QNetworkConfigurationManager::CanStartAndStopInterfaces |
-           QNetworkConfigurationManager::DataStatistics |
-           QNetworkConfigurationManager::ForcedRoaming |
-           QNetworkConfigurationManager::NetworkSessionRequired;
-}
-
-bool QIcdEngine::ensureDBusConnection()
-{
-    if (m_dbusInterface)
-        return true;
-
-    // Setup DBus Interface for ICD
-    m_dbusInterface = new QDBusInterface(ICD_DBUS_API_INTERFACE,
-                                         ICD_DBUS_API_PATH,
-                                         ICD_DBUS_API_INTERFACE,
-                                         QDBusConnection::systemBus(),
-                                         this);
-
-    if (!m_dbusInterface->isValid()) {
-        delete m_dbusInterface;
-        m_dbusInterface = 0;
-
-        if (!m_icdServiceWatcher) {
-            m_icdServiceWatcher = new QDBusServiceWatcher(ICD_DBUS_API_INTERFACE,
-                                                          QDBusConnection::systemBus(),
-                                                          QDBusServiceWatcher::WatchForOwnerChange,
-                                                          this);
-
-            connect(m_icdServiceWatcher, SIGNAL(serviceOwnerChanged(QString,QString,QString)),
-                    this, SLOT(icdServiceOwnerChanged(QString,QString,QString)));
-        }
-
-        return false;
-    }
-
-    connect(&m_scanTimer, SIGNAL(timeout()), this, SLOT(finishAsyncConfigurationUpdate()));
-    m_scanTimer.setSingleShot(true);
-
-    /* Turn on IAP state monitoring */
-    startListeningStateSignalsForAllConnections();
-
-    /* Turn on IAP add/remove monitoring */
-    iapMonitor = new IapMonitor;
-    iapMonitor->setup(this);
-
-    /* We create a default configuration which is a pseudo config */
-    QNetworkConfigurationPrivate *cpPriv = new IcdNetworkConfigurationPrivate;
-    cpPriv->name = "UserChoice";
-    cpPriv->state = QNetworkConfiguration::Discovered;
-    cpPriv->isValid = true;
-    cpPriv->id = OSSO_IAP_ANY;
-    cpPriv->type = QNetworkConfiguration::UserChoice;
-    cpPriv->purpose = QNetworkConfiguration::UnknownPurpose;
-    cpPriv->roamingSupported = false;
-
-    QNetworkConfigurationPrivatePointer ptr(cpPriv);
-    userChoiceConfigurations.insert(cpPriv->id, ptr);
-
-    doRequestUpdate();
-
-    getIcdInitialState();
-
-    return true;
-}
-
-void QIcdEngine::initialize()
-{
-    QMutexLocker locker(&mutex);
-
-    if (!ensureDBusConnection()) {
-        locker.unlock();
-        emit updateCompleted();
-        locker.relock();
-    }
-}
-
-static inline QString network_attrs_to_security(uint network_attrs)
-{
-    uint cap = 0;
-    nwattr2cap(network_attrs, &cap); /* from libicd-network-wlan-dev.h */
-    if (cap & WLANCOND_OPEN)
-        return "NONE";
-    else if (cap & WLANCOND_WEP)
-        return "WEP";
-    else if (cap & WLANCOND_WPA_PSK)
-        return "WPA_PSK";
-    else if (cap & WLANCOND_WPA_EAP)
-        return "WPA_EAP";
-    return "";
-}
-
-
-struct SSIDInfo {
-    QString iap_id;
-    QString wlan_security;
-};
-
-
-void QIcdEngine::deleteConfiguration(const QString &iap_id)
-{
-    QMutexLocker locker(&mutex);
-
-    /* Called when IAPs are deleted in db, in this case we do not scan
-     * or read all the IAPs from db because it might take too much power
-     * (multiple applications would need to scan and read all IAPs from db)
-     */
-    QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.take(iap_id);
-    if (ptr) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-        qDebug() << "IAP" << iap_id << "was removed from storage.";
-#endif
-
-        locker.unlock();
-        emit configurationRemoved(ptr);
-    } else {
-#ifdef BEARER_MANAGEMENT_DEBUG
-        qDebug("IAP: %s, already missing from the known list", iap_id.toAscii().data());
-#endif
-    }
-}
-
-
-static quint32 getNetworkAttrs(bool is_iap_id,
-                               const QString &iap_id,
-                               const QString &iap_type,
-                               QString security_method)
-{
-    guint network_attr = 0;
-    dbus_uint32_t cap = 0;
-
-    if (iap_type == "WLAN_INFRA")
-    cap |= WLANCOND_INFRA;
-    else if (iap_type == "WLAN_ADHOC")
-    cap |= WLANCOND_ADHOC;
-
-    if (security_method.isEmpty() && (cap & (WLANCOND_INFRA | WLANCOND_ADHOC))) {
-    Maemo::IAPConf saved_ap(iap_id);
-    security_method = saved_ap.value("wlan_security").toString();
-    }
-
-    if (!security_method.isEmpty()) {
-    if (security_method == "WEP")
-        cap |= WLANCOND_WEP;
-    else if (security_method == "WPA_PSK")
-        cap |= WLANCOND_WPA_PSK;
-    else if (security_method == "WPA_EAP")
-        cap |= WLANCOND_WPA_EAP;
-    else if (security_method == "NONE")
-        cap |= WLANCOND_OPEN;
-
-    if (cap & (WLANCOND_WPA_PSK | WLANCOND_WPA_EAP)) {
-        Maemo::IAPConf saved_iap(iap_id);
-        bool wpa2_only = saved_iap.value("EAP_wpa2_only_mode").toBool();
-        if (wpa2_only) {
-        cap |= WLANCOND_WPA2;
-        }
-    }
-    }
-
-    cap2nwattr(cap, &network_attr);
-    if (is_iap_id)
-    network_attr |= ICD_NW_ATTR_IAPNAME;
-
-    return quint32(network_attr);
-}
-
-
-void QIcdEngine::addConfiguration(QString& iap_id)
-{
-    // Note: When new IAP is created, this function gets called multiple times
-    //       in a row.
-    //       For example: Empty type & name for WLAN was stored into newly
-    //                    created IAP data in gconf when this function gets
-    //                    called for the first time.
-    //                    WLAN type & name are updated into IAP data in gconf
-    //                    as soon as WLAN connection is up and running.
-    //                    => And this function gets called again.
-
-    QMutexLocker locker(&mutex);
-
-    if (!accessPointConfigurations.contains(iap_id)) {
-	Maemo::IAPConf saved_iap(iap_id);
-        QString iap_type = saved_iap.value("type").toString();
-        QString iap_name = saved_iap.value("name").toString();
-        QByteArray ssid = saved_iap.value("wlan_ssid").toByteArray();
-        if (!iap_type.isEmpty() && !iap_name.isEmpty()) {
-            // Check if new IAP is actually Undefined WLAN configuration
-            // Note: SSID is used as an iap id for Undefined WLAN configurations
-            //       => configuration must be searched using SSID
-            if (!ssid.isEmpty() && accessPointConfigurations.contains(ssid)) {
-                QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.take(ssid);
-                if (ptr) {
-                    ptr->mutex.lock();
-                    ptr->id = iap_id;
-                    toIcdConfig(ptr)->iap_type = iap_type;
-                    ptr->bearerType = bearerTypeFromIapType(iap_type);
-                    toIcdConfig(ptr)->network_attrs = getNetworkAttrs(true, iap_id, iap_type, QString());
-                    toIcdConfig(ptr)->network_id = ssid;
-                    toIcdConfig(ptr)->service_id = saved_iap.value("service_id").toString();
-                    toIcdConfig(ptr)->service_type = saved_iap.value("service_type").toString();
-                    if (m_onlineIapId == iap_id) {
-                        ptr->state = QNetworkConfiguration::Active;
-                    } else {
-                        ptr->state = QNetworkConfiguration::Defined;
-                    }
-                    ptr->mutex.unlock();
-                    accessPointConfigurations.insert(iap_id, ptr);
-
-                    locker.unlock();
-                    emit configurationChanged(ptr);
-                    locker.relock();
-                }
-            } else {
-                IcdNetworkConfigurationPrivate *cpPriv = new IcdNetworkConfigurationPrivate;
-                cpPriv->name = saved_iap.value("name").toString();
-                if (cpPriv->name.isEmpty())
-                    cpPriv->name = iap_id;
-                cpPriv->isValid = true;
-                cpPriv->id = iap_id;
-                cpPriv->iap_type = iap_type;
-                cpPriv->bearerType = bearerTypeFromIapType(iap_type);
-                cpPriv->network_attrs = getNetworkAttrs(true, iap_id, iap_type, QString());
-                cpPriv->service_id = saved_iap.value("service_id").toString();
-                cpPriv->service_type = saved_iap.value("service_type").toString();
-                if (iap_type.startsWith(QLatin1String("WLAN"))) {
-                    QByteArray ssid = saved_iap.value("wlan_ssid").toByteArray();
-                    if (ssid.isEmpty()) {
-                        qWarning() << "Cannot get ssid for" << iap_id;
-                    }
-                    cpPriv->network_id = ssid;
-                }
-                cpPriv->type = QNetworkConfiguration::InternetAccessPoint;
-                if (m_onlineIapId == iap_id) {
-                    cpPriv->state = QNetworkConfiguration::Active;
-                } else {
-                    cpPriv->state = QNetworkConfiguration::Defined;
-                }
-
-                QNetworkConfigurationPrivatePointer ptr(cpPriv);
-                accessPointConfigurations.insert(iap_id, ptr);
-
-#ifdef BEARER_MANAGEMENT_DEBUG
-                qDebug("IAP: %s, name: %s, added to known list", iap_id.toAscii().data(), cpPriv->name.toAscii().data());
-#endif
-                locker.unlock();
-                emit configurationAdded(ptr);
-                locker.relock();
-            }
-        } else {
-            qWarning("IAP %s does not have \"type\" or \"name\" fields defined, skipping this IAP.", iap_id.toAscii().data());
-        }
-    } else {
-#ifdef BEARER_MANAGEMENT_DEBUG
-	qDebug() << "IAP" << iap_id << "already in db.";
-#endif
-
-	/* Check if the data in db changed and update configuration accordingly
-	 */
-    QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.value(iap_id);
-	if (ptr) {
-	    Maemo::IAPConf changed_iap(iap_id);
-	    QString iap_type = changed_iap.value("type").toString();
-	    bool update_needed = false; /* if IAP type or ssid changed, we need to change the state */
-
-        QMutexLocker configLocker(&ptr->mutex);
-
-	    toIcdConfig(ptr)->network_attrs = getNetworkAttrs(true, iap_id, iap_type, QString());
-	    toIcdConfig(ptr)->service_id = changed_iap.value("service_id").toString();
-	    toIcdConfig(ptr)->service_type = changed_iap.value("service_type").toString();
-
-	    if (!iap_type.isEmpty()) {
-            ptr->name = changed_iap.value("name").toString();
-            if (ptr->name.isEmpty())
-                ptr->name = iap_id;
-            ptr->isValid = true;
-            if (toIcdConfig(ptr)->iap_type != iap_type) {
-                toIcdConfig(ptr)->iap_type = iap_type;
-                ptr->bearerType = bearerTypeFromIapType(iap_type);
-                update_needed = true;
-            }
-            if (iap_type.startsWith(QLatin1String("WLAN"))) {
-                QByteArray ssid = changed_iap.value("wlan_ssid").toByteArray();
-                if (ssid.isEmpty()) {
-                    qWarning() << "Cannot get ssid for" << iap_id;
-                }
-                if (toIcdConfig(ptr)->network_id != ssid) {
-                    toIcdConfig(ptr)->network_id = ssid;
-                    update_needed = true;
-                }
-            }
-	    }
-
-	    if (update_needed) {
-            ptr->type = QNetworkConfiguration::InternetAccessPoint;
-            if (m_onlineIapId == iap_id) {
-                if (ptr->state < QNetworkConfiguration::Active) {
-                    ptr->state = QNetworkConfiguration::Active;
-
-                    configLocker.unlock();
-                    locker.unlock();
-                    emit configurationChanged(ptr);
-                    locker.relock();
-                }
-            } else if (ptr->state < QNetworkConfiguration::Defined) {
-                ptr->state = QNetworkConfiguration::Defined;
-
-                configLocker.unlock();
-                locker.unlock();
-                emit configurationChanged(ptr);
-                locker.relock();
-            }
-	    }
-	} else {
-	    qWarning("Cannot find IAP %s from current configuration although it should be there.", iap_id.toAscii().data());
-	}
-    }
-}
-
-void QIcdEngine::doRequestUpdate(QList<Maemo::IcdScanResult> scanned)
-{
-    /* Contains all known iap_ids from storage */
-    QList<QString> knownConfigs = accessPointConfigurations.keys();
-
-    /* Contains all known WLAN network ids (like ssid) from storage */
-    QMultiHash<QByteArray, SSIDInfo* > notDiscoveredWLANConfigs;
-
-    QList<QString> all_iaps;
-    Maemo::IAPConf::getAll(all_iaps);
-
-    foreach (const QString &iap_id, all_iaps) {
-        QByteArray ssid;
-
-        Maemo::IAPConf saved_ap(iap_id);
-        bool is_temporary = saved_ap.value("temporary").toBool();
-        if (is_temporary) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-            qDebug() << "IAP" << iap_id << "is temporary, skipping it.";
-#endif
-            continue;
-        }
-
-        QString iap_type = saved_ap.value("type").toString();
-        if (iap_type.startsWith(QLatin1String("WLAN"))) {
-            ssid = saved_ap.value("wlan_ssid").toByteArray();
-            if (ssid.isEmpty())
-                continue;
-
-            QString security_method = saved_ap.value("wlan_security").toString();
-            SSIDInfo *info = new SSIDInfo;
-            info->iap_id = iap_id;
-            info->wlan_security = security_method;
-                notDiscoveredWLANConfigs.insert(ssid, info);
-        } else if (iap_type.isEmpty()) {
-            continue;
-        } else {
-#ifdef BEARER_MANAGEMENT_DEBUG
-            qDebug() << "IAP" << iap_id << "network type is" << iap_type;
-#endif
-            ssid.clear();
-        }
-
-        if (!accessPointConfigurations.contains(iap_id)) {
-            IcdNetworkConfigurationPrivate *cpPriv = new IcdNetworkConfigurationPrivate;
-
-            cpPriv->name = saved_ap.value("name").toString();
-            if (cpPriv->name.isEmpty()) {
-                if (!ssid.isEmpty() && ssid.size() > 0)
-                    cpPriv->name = ssid.data();
-                else
-                    cpPriv->name = iap_id;
-            }
-            cpPriv->isValid = true;
-            cpPriv->id = iap_id;
-            cpPriv->network_id = ssid;
-            cpPriv->network_attrs = getNetworkAttrs(true, iap_id, iap_type, QString());
-            cpPriv->iap_type = iap_type;
-            cpPriv->bearerType = bearerTypeFromIapType(iap_type);
-            cpPriv->service_id = saved_ap.value("service_id").toString();
-            cpPriv->service_type = saved_ap.value("service_type").toString();
-            cpPriv->type = QNetworkConfiguration::InternetAccessPoint;
-            cpPriv->state = QNetworkConfiguration::Defined;
-
-            QNetworkConfigurationPrivatePointer ptr(cpPriv);
-            accessPointConfigurations.insert(iap_id, ptr);
-
-            mutex.unlock();
-            emit configurationAdded(ptr);
-            mutex.lock();
-
-#ifdef BEARER_MANAGEMENT_DEBUG
-            qDebug("IAP: %s, name: %s, ssid: %s, added to known list",
-                   iap_id.toAscii().data(), ptr->name.toAscii().data(),
-                   !ssid.isEmpty() ? ssid.data() : "-");
-#endif
-        } else {
-            knownConfigs.removeOne(iap_id);
-#ifdef BEARER_MANAGEMENT_DEBUG
-            qDebug("IAP: %s, ssid: %s, already exists in the known list",
-                   iap_id.toAscii().data(), !ssid.isEmpty() ? ssid.data() : "-");
-#endif
-        }
-    }
-
-    /* This is skipped in the first update as scanned size is zero */
-    if (!scanned.isEmpty()) {
-        for (int i=0; i<scanned.size(); ++i) {
-            const Maemo::IcdScanResult ap = scanned.at(i);
-
-            if (ap.scan.network_attrs & ICD_NW_ATTR_IAPNAME) {
-                /* The network_id is IAP id, so the IAP is a known one */
-                QString iapid = ap.scan.network_id.data();
-                QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.value(iapid);
-                if (ptr) {
-                    bool changed = false;
-
-                    ptr->mutex.lock();
-
-                    if (!ptr->isValid) {
-                        ptr->isValid = true;
-                        changed = true;
-                    }
-
-                    /* If this config is the current active one, we do not set it
-                     * to discovered.
-                     */
-                    if ((ptr->state != QNetworkConfiguration::Discovered) &&
-                        (ptr->state != QNetworkConfiguration::Active)) {
-                        ptr->state = QNetworkConfiguration::Discovered;
-                        changed = true;
-                    }
-
-                    toIcdConfig(ptr)->network_attrs = ap.scan.network_attrs;
-                    toIcdConfig(ptr)->service_id = ap.scan.service_id;
-                    toIcdConfig(ptr)->service_type = ap.scan.service_type;
-                    toIcdConfig(ptr)->service_attrs = ap.scan.service_attrs;
-
-#ifdef BEARER_MANAGEMENT_DEBUG
-                    qDebug("IAP: %s, ssid: %s, discovered",
-                           iapid.toAscii().data(), toIcdConfig(ptr)->network_id.data());
-#endif
-
-                    ptr->mutex.unlock();
-
-                    if (changed) {
-                        mutex.unlock();
-                        emit configurationChanged(ptr);
-                        mutex.lock();
-                    }
-
-                    if (!ap.scan.network_type.startsWith(QLatin1String("WLAN")))
-                        continue; // not a wlan AP
-
-                    /* Remove scanned AP from discovered WLAN configurations so that we can
-                     * emit configurationRemoved signal later
-                     */
-                    ptr->mutex.lock();
-                    QList<SSIDInfo* > known_iaps = notDiscoveredWLANConfigs.values(toIcdConfig(ptr)->network_id);
-rescan_list:
-                    if (!known_iaps.isEmpty()) {
-                        for (int k=0; k<known_iaps.size(); ++k) {
-                            SSIDInfo *iap = known_iaps.at(k);
-
-                            if (iap->wlan_security ==
-                                network_attrs_to_security(ap.scan.network_attrs)) {
-                                /* Remove IAP from the list */
-                                notDiscoveredWLANConfigs.remove(toIcdConfig(ptr)->network_id, iap);
-#ifdef BEARER_MANAGEMENT_DEBUG
-                                qDebug() << "Removed IAP" << iap->iap_id << "from unknown config";
-#endif
-                                known_iaps.removeAt(k);
-                                delete iap;
-                                goto rescan_list;
-                            }
-                        }
-                    }
-                    ptr->mutex.unlock();
-                }
-            } else {
-                /* Non saved access point data */
-                QByteArray scanned_ssid = ap.scan.network_id;
-                if (!accessPointConfigurations.contains(scanned_ssid)) {
-                    IcdNetworkConfigurationPrivate *cpPriv = new IcdNetworkConfigurationPrivate;
-                    QString hrs = scanned_ssid.data();
-
-                    cpPriv->name = ap.network_name.isEmpty() ? hrs : ap.network_name;
-                    cpPriv->isValid = true;
-                    cpPriv->id = scanned_ssid.data();  // Note: id is now ssid, it should be set to IAP id if the IAP is saved
-                    cpPriv->network_id = scanned_ssid;
-                    cpPriv->iap_type = ap.scan.network_type;
-                    cpPriv->bearerType = bearerTypeFromIapType(cpPriv->iap_type);
-                    cpPriv->network_attrs = ap.scan.network_attrs;
-                    cpPriv->service_id = ap.scan.service_id;
-                    cpPriv->service_type = ap.scan.service_type;
-                    cpPriv->service_attrs = ap.scan.service_attrs;
-
-                    cpPriv->type = QNetworkConfiguration::InternetAccessPoint;
-                    cpPriv->state = QNetworkConfiguration::Undefined;
-
-#ifdef BEARER_MANAGEMENT_DEBUG
-                    qDebug() << "IAP with network id" << cpPriv->id << "was found in the scan.";
-#endif
-
-                    QNetworkConfigurationPrivatePointer ptr(cpPriv);
-                    accessPointConfigurations.insert(ptr->id, ptr);
-
-                    mutex.unlock();
-                    emit configurationAdded(ptr);
-                    mutex.lock();
-                } else {
-                    knownConfigs.removeOne(scanned_ssid);
-                }
-            }
-        }
-    }
-
-    if (!firstUpdate) {
-        // Update Defined status to all defined WLAN IAPs which
-        // could not be found when access points were scanned
-        QHashIterator<QByteArray, SSIDInfo* > i(notDiscoveredWLANConfigs);
-        while (i.hasNext()) {
-            i.next();
-            SSIDInfo *iap = i.value();
-            QString iap_id = iap->iap_id;
-            //qDebug() << i.key() << ": " << iap_id;
-
-            QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.value(iap_id);
-            if (ptr) {
-                QMutexLocker configLocker(&ptr->mutex);
-
-                // WLAN AccessPoint configuration could not be Discovered
-                // => Make sure that configuration state is Defined
-                if (ptr->state > QNetworkConfiguration::Defined) {
-                    ptr->state = QNetworkConfiguration::Defined;
-
-                    configLocker.unlock();
-                    mutex.unlock();
-                    emit configurationChanged(ptr);
-                    mutex.lock();
-                }
-            }
-        }
-
-        /* Remove non existing iaps since last update */
-        foreach (const QString &oldIface, knownConfigs) {
-            QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.take(oldIface);
-            if (ptr) {
-                mutex.unlock();
-                emit configurationRemoved(ptr);
-                mutex.lock();
-                //if we would have SNAP support we would have to remove the references
-                //from existing ServiceNetworks to the removed access point configuration
-            }
-        }
-    }
-
-    QMutableHashIterator<QByteArray, SSIDInfo* > i(notDiscoveredWLANConfigs);
-    while (i.hasNext()) {
-        i.next();
-        SSIDInfo *iap = i.value();
-        delete iap;
-        i.remove();
-    }
-
-    if (!firstUpdate) {
-        mutex.unlock();
-        emit updateCompleted();
-        mutex.lock();
-    }
-
-    if (firstUpdate)
-        firstUpdate = false;
-}
-
-QNetworkConfigurationPrivatePointer QIcdEngine::defaultConfiguration()
-{
-    QMutexLocker locker(&mutex);
-
-    if (!ensureDBusConnection())
-        return QNetworkConfigurationPrivatePointer();
-
-    // Here we just return [ANY] request to icd and let the icd decide which IAP to connect.
-    return userChoiceConfigurations.value(OSSO_IAP_ANY);
-}
-
-void QIcdEngine::startListeningStateSignalsForAllConnections()
-{
-    // Start listening ICD_DBUS_API_STATE_SIG signals
-    m_dbusInterface->connection().connect(ICD_DBUS_API_INTERFACE,
-                                          ICD_DBUS_API_PATH,
-                                          ICD_DBUS_API_INTERFACE,
-                                          ICD_DBUS_API_STATE_SIG,
-                                          this, SLOT(connectionStateSignalsSlot(QDBusMessage)));
-}
-
-void QIcdEngine::getIcdInitialState()
-{
-    /* Instead of requesting ICD status asynchronously, we ask it synchronously.
-     * It ensures that we always get right icd status BEFORE initialize() ends.
-     * If not, initialize()  might end before we got icd status and
-     * QNetworkConfigurationManager::updateConfigurations()
-     * call from user might also end before receiving icd status.
-     * In such case, we come up to a bug:
-     * QNetworkConfigurationManagerPrivate::isOnline() will be false even
-     * if we are connected.
-     */
-    Maemo::Icd icd;
-    QList<Maemo::IcdStateResult> state_results;
-    QNetworkConfigurationPrivatePointer ptr;
-
-    if (icd.state(state_results) && !state_results.isEmpty()) {
-
-        if (!(state_results.first().params.network_attrs == 0 &&
-              state_results.first().params.network_id.isEmpty())) {
-
-            switch (state_results.first().state) {
-            case ICD_STATE_CONNECTED:
-                m_onlineIapId = state_results.first().params.network_id;
-
-                ptr = accessPointConfigurations.value(m_onlineIapId);
-                if (ptr) {
-                    QMutexLocker configLocker(&ptr->mutex);
-                    ptr->state = QNetworkConfiguration::Active;
-                    configLocker.unlock();
-
-                    mutex.unlock();
-                    emit configurationChanged(ptr);
-                    mutex.lock();
-                }
-                break;
-            default:
-                break;
-            }
-        }
-    }
-}
-
-void QIcdEngine::connectionStateSignalsSlot(QDBusMessage msg)
-{
-    QMutexLocker locker(&mutex);
-
-    QList<QVariant> arguments = msg.arguments();
-    if (arguments.count() < 8 || arguments.at(1).toUInt() != 0) {
-        return;
-    }
-
-    QString iapid = arguments[5].toByteArray().data();
-    uint icd_connection_state = arguments.at(7).toUInt();
-
-    switch (icd_connection_state) {
-    case ICD_STATE_CONNECTED:
-        {
-        QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.value(iapid);
-        if (ptr) {
-            QMutexLocker configLocker(&ptr->mutex);
-
-            ptr->type = QNetworkConfiguration::InternetAccessPoint;
-            if (ptr->state != QNetworkConfiguration::Active) {
-                ptr->state = QNetworkConfiguration::Active;
-
-                configLocker.unlock();
-                locker.unlock();
-                emit configurationChanged(ptr);
-                locker.relock();
-
-                m_onlineIapId = iapid;
-            }
-        } else {
-            // This gets called when new WLAN IAP is created using Connection dialog
-            // At this point Undefined WLAN configuration has SSID as iap id
-            // => Because of that configuration can not be found from
-            //    accessPointConfigurations using correct iap id
-            m_onlineIapId = iapid;
-        }
-        break;
-        }
-    case ICD_STATE_DISCONNECTED:
-        {
-        QNetworkConfigurationPrivatePointer ptr = accessPointConfigurations.value(iapid);
-        if (ptr) {
-            QMutexLocker configLocker(&ptr->mutex);
-
-            ptr->type = QNetworkConfiguration::InternetAccessPoint;
-            if (ptr->state == QNetworkConfiguration::Active) {
-                ptr->state = QNetworkConfiguration::Discovered;
-
-                configLocker.unlock();
-                locker.unlock();
-                emit configurationChanged(ptr);
-                locker.relock();
-
-                // Note: If ICD switches used IAP from one to another:
-                //       1) new IAP is reported to be online first
-                //       2) old IAP is reported to be offline then
-                // => Device can be reported to be offline only
-                //    if last known online IAP is reported to be disconnected
-                if (iapid == m_onlineIapId) {
-                    // It's known that there is only one global ICD connection
-                    // => Because ICD state was reported to be DISCONNECTED, Device is offline
-                    m_onlineIapId.clear();
-                }
-            }
-        } else {
-            // Disconnected IAP was not found from accessPointConfigurations
-            // => Reason: Online IAP was removed which resulted ICD to disconnect
-            if (iapid == m_onlineIapId) {
-                // It's known that there is only one global ICD connection
-                // => Because ICD state was reported to be DISCONNECTED, Device is offline
-                m_onlineIapId.clear();
-            }
-        }
-        break;
-        }
-    default:
-        break;
-    }
-    
-    locker.unlock();
-    emit iapStateChanged(iapid, icd_connection_state);
-    locker.relock();
-}
-
-void QIcdEngine::icdServiceOwnerChanged(const QString &serviceName, const QString &oldOwner,
-                                        const QString &newOwner)
-{
-    Q_UNUSED(serviceName);
-    Q_UNUSED(oldOwner);
-
-    QMutexLocker locker(&mutex);
-
-    if (newOwner.isEmpty()) {
-        // Disconnected from ICD, remove all configurations
-        cleanup();
-        delete iapMonitor;
-        iapMonitor = 0;
-        delete m_dbusInterface;
-        m_dbusInterface = 0;
-
-        QMutableHashIterator<QString, QNetworkConfigurationPrivatePointer> i(accessPointConfigurations);
-        while (i.hasNext()) {
-            i.next();
-
-            QNetworkConfigurationPrivatePointer ptr = i.value();
-            i.remove();
-
-            locker.unlock();
-            emit configurationRemoved(ptr);
-            locker.relock();
-        }
-
-        userChoiceConfigurations.clear();
-    } else {
-        // Connected to ICD ensure connection.
-        ensureDBusConnection();
-    }
-}
-
-void QIcdEngine::requestUpdate()
-{
-    QMutexLocker locker(&mutex);
-
-    if (!ensureDBusConnection()) {
-        locker.unlock();
-        emit updateCompleted();
-        locker.relock();
-        return;
-    }
-
-    if (m_scanGoingOn)
-        return;
-
-    m_scanGoingOn = true;
-
-    m_dbusInterface->connection().connect(ICD_DBUS_API_INTERFACE,
-                                          ICD_DBUS_API_PATH,
-                                          ICD_DBUS_API_INTERFACE,
-                                          ICD_DBUS_API_SCAN_SIG,
-                                          this, SLOT(asyncUpdateConfigurationsSlot(QDBusMessage)));
-
-    QDBusMessage msg = m_dbusInterface->call(ICD_DBUS_API_SCAN_REQ,
-                                             (uint)ICD_SCAN_REQUEST_ACTIVE);
-    m_typesToBeScanned = msg.arguments()[0].value<QStringList>();
-    m_scanTimer.start(ICD_SHORT_SCAN_TIMEOUT);
-}
-
-void QIcdEngine::cancelAsyncConfigurationUpdate()
-{
-    if (!ensureDBusConnection())
-        return;
-
-    if (!m_scanGoingOn)
-        return;
-
-    m_scanGoingOn = false;
-
-    if (m_scanTimer.isActive())
-        m_scanTimer.stop();
-
-    m_dbusInterface->connection().disconnect(ICD_DBUS_API_INTERFACE,
-                                             ICD_DBUS_API_PATH,
-                                             ICD_DBUS_API_INTERFACE,
-                                             ICD_DBUS_API_SCAN_SIG,
-                                             this, SLOT(asyncUpdateConfigurationsSlot(QDBusMessage)));
-
-    // Stop scanning rounds by calling ICD_DBUS_API_SCAN_CANCEL
-    // <=> If ICD_DBUS_API_SCAN_CANCEL is not called, new scanning round will
-    //     be started after the module scan timeout.
-    m_dbusInterface->call(ICD_DBUS_API_SCAN_CANCEL);
-}
-
-void QIcdEngine::finishAsyncConfigurationUpdate()
-{
-    QMutexLocker locker(&mutex);
-
-    cancelAsyncConfigurationUpdate();
-    doRequestUpdate(m_scanResult);
-    m_scanResult.clear();
-}
-
-void QIcdEngine::asyncUpdateConfigurationsSlot(QDBusMessage msg)
-{
-    QMutexLocker locker(&mutex);
-
-    QList<QVariant> arguments = msg.arguments();
-    uint icd_scan_status = arguments.takeFirst().toUInt();
-    if (icd_scan_status == ICD_SCAN_COMPLETE) {
-        m_typesToBeScanned.removeOne(arguments[6].toString());
-        if (!m_typesToBeScanned.count()) {
-            locker.unlock();
-            finishAsyncConfigurationUpdate();
-            locker.relock();
-        }
-    } else {
-        Maemo::IcdScanResult scanResult;
-        scanResult.status = icd_scan_status;
-        scanResult.timestamp = arguments.takeFirst().toUInt();
-        scanResult.scan.service_type = arguments.takeFirst().toString();
-        scanResult.service_name = arguments.takeFirst().toString();
-        scanResult.scan.service_attrs = arguments.takeFirst().toUInt();
-        scanResult.scan.service_id = arguments.takeFirst().toString();
-        scanResult.service_priority = arguments.takeFirst().toInt();
-        scanResult.scan.network_type = arguments.takeFirst().toString();
-        scanResult.network_name = arguments.takeFirst().toString();
-        scanResult.scan.network_attrs = arguments.takeFirst().toUInt();
-        scanResult.scan.network_id = arguments.takeFirst().toByteArray();
-        scanResult.network_priority = arguments.takeFirst().toInt();
-        scanResult.signal_strength = arguments.takeFirst().toInt();
-        scanResult.station_id = arguments.takeFirst().toString();
-        scanResult.signal_dB = arguments.takeFirst().toInt();
-
-        m_scanResult.append(scanResult);
-    }
-}
-
-void QIcdEngine::cleanup()
-{
-    if (m_scanGoingOn) {
-        m_scanTimer.stop();
-        m_dbusInterface->call(ICD_DBUS_API_SCAN_CANCEL);
-    }
-    if (iapMonitor)
-        iapMonitor->cleanup();
-}
-
-bool QIcdEngine::hasIdentifier(const QString &id)
-{
-    QMutexLocker locker(&mutex);
-
-    return accessPointConfigurations.contains(id) ||
-           snapConfigurations.contains(id) ||
-           userChoiceConfigurations.contains(id);
-}
-
-QNetworkSessionPrivate *QIcdEngine::createSessionBackend()
-{
-    return new QNetworkSessionPrivateImpl(this);
-}
-
-#include "qicdengine.moc"
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_BEARERMANAGEMENT
diff --git a/src/plugins/bearer/icd/qicdengine.h b/src/plugins/bearer/icd/qicdengine.h
deleted file mode 100644
index df65d01..0000000
--- a/src/plugins/bearer/icd/qicdengine.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QICDENGINE_H
-#define QICDENGINE_H
-
-#include <QtNetwork/private/qbearerengine_p.h>
-
-#include <QtCore/qtimer.h>
-
-#include "maemo_icd.h"
-
-QT_BEGIN_NAMESPACE
-
-class QNetworkConfigurationPrivate;
-class IapMonitor;
-class QDBusInterface;
-class QDBusServiceWatcher;
-
-inline QNetworkConfiguration::BearerType bearerTypeFromIapType(const QString &iapType)
-{
-    if (iapType == QLatin1String("WLAN_INFRA") ||
-        iapType == QLatin1String("WLAN_ADHOC")) {
-        return QNetworkConfiguration::BearerWLAN;
-    } else if (iapType == QLatin1String("GPRS")) {
-        return QNetworkConfiguration::BearerHSPA;
-    } else {
-        return QNetworkConfiguration::BearerUnknown;
-    }
-}
-
-class IcdNetworkConfigurationPrivate : public QNetworkConfigurationPrivate
-{
-public:
-    IcdNetworkConfigurationPrivate();
-    ~IcdNetworkConfigurationPrivate();
-
-    virtual QString bearerTypeName() const;
-
-    // In Maemo the id field (defined in QNetworkConfigurationPrivate)
-    // is the IAP id (which typically is UUID)
-    QByteArray network_id;  // typically WLAN ssid or similar
-    QString iap_type;       // is this one WLAN or GPRS
-
-    QString service_type;
-    QString service_id;
-    quint32 service_attrs;
-
-    // Network attributes for this IAP, this is the value returned by icd and
-    // passed to it when connecting.
-    quint32 network_attrs;
-};
-
-inline IcdNetworkConfigurationPrivate *toIcdConfig(QNetworkConfigurationPrivatePointer ptr)
-{
-    return static_cast<IcdNetworkConfigurationPrivate *>(ptr.data());
-}
-
-class QIcdEngine : public QBearerEngine
-{
-    Q_OBJECT
-
-public:
-    QIcdEngine(QObject *parent = 0);
-    ~QIcdEngine();
-
-    bool hasIdentifier(const QString &id);
-
-    Q_INVOKABLE void initialize();
-    Q_INVOKABLE void requestUpdate();
-
-    QNetworkConfigurationManager::Capabilities capabilities() const;
-
-    QNetworkSessionPrivate *createSessionBackend();
-
-    QNetworkConfigurationPrivatePointer defaultConfiguration();
-
-    void deleteConfiguration(const QString &iap_id);
-
-    inline QNetworkConfigurationPrivatePointer configuration(const QString &id)
-    {
-        QMutexLocker locker(&mutex);
-
-        return accessPointConfigurations.value(id);
-    }
-
-    inline void addSessionConfiguration(QNetworkConfigurationPrivatePointer ptr)
-    {
-        QMutexLocker locker(&mutex);
-
-        accessPointConfigurations.insert(ptr->id, ptr);
-
-        locker.unlock();
-        emit configurationAdded(ptr);
-    }
-
-    inline void changedSessionConfiguration(QNetworkConfigurationPrivatePointer ptr)
-    {
-        emit configurationChanged(ptr);
-    }
-
-    void cleanup();
-
-    void addConfiguration(QString &iap_id);
-
-Q_SIGNALS:
-    void iapStateChanged(const QString& iapid, uint icd_connection_state);
-
-private Q_SLOTS:
-    void finishAsyncConfigurationUpdate();
-    void asyncUpdateConfigurationsSlot(QDBusMessage msg);
-    void connectionStateSignalsSlot(QDBusMessage msg);
-    void icdServiceOwnerChanged(const QString &serviceName, const QString &oldOwner,
-                                const QString &newOwner);
-
-private:
-    void startListeningStateSignalsForAllConnections();
-    void doRequestUpdate(QList<Maemo::IcdScanResult> scanned = QList<Maemo::IcdScanResult>());
-    void cancelAsyncConfigurationUpdate();
-    void getIcdInitialState();
-    bool ensureDBusConnection();
-
-private:
-    IapMonitor *iapMonitor;
-    QDBusInterface *m_dbusInterface;
-    QTimer m_scanTimer;
-    QString m_onlineIapId;
-    QStringList m_typesToBeScanned;
-    QList<Maemo::IcdScanResult> m_scanResult;
-
-    QDBusServiceWatcher *m_icdServiceWatcher;
-
-    bool firstUpdate;
-    bool m_scanGoingOn;
-};
-
-QT_END_NAMESPACE
-
-#endif // QICDENGINE_H
diff --git a/src/plugins/bearer/icd/qnetworksession_impl.cpp b/src/plugins/bearer/icd/qnetworksession_impl.cpp
deleted file mode 100644
index e4f4eff..0000000
--- a/src/plugins/bearer/icd/qnetworksession_impl.cpp
+++ /dev/null
@@ -1,1072 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qnetworksession_impl.h"
-#include "qicdengine.h"
-
-#include <QHash>
-
-#include <maemo_icd.h>
-#include <iapconf.h>
-#include <proxyconf.h>
-
-#include <ifaddrs.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-
-#ifndef QT_NO_BEARERMANAGEMENT
-
-QT_BEGIN_NAMESPACE
-
-QDBusArgument &operator<<(QDBusArgument &argument,
-                          const ICd2DetailsDBusStruct &icd2)
-{
-    argument.beginStructure();
-
-    argument << icd2.serviceType;
-    argument << icd2.serviceAttributes;
-    argument << icd2.setviceId;
-    argument << icd2.networkType;
-    argument << icd2.networkAttributes;
-    argument << icd2.networkId;
-
-    argument.endStructure();
-
-    return argument;
-}
-
-const QDBusArgument &operator>>(const QDBusArgument &argument,
-                                ICd2DetailsDBusStruct &icd2)
-{
-    argument.beginStructure();
-
-    argument >> icd2.serviceType;
-    argument >> icd2.serviceAttributes;
-    argument >> icd2.setviceId;
-    argument >> icd2.networkType;
-    argument >> icd2.networkAttributes;
-    argument >> icd2.networkId;
-
-    argument.endStructure();
-
-    return argument;
-}
-
-const QDBusArgument &operator>>(const QDBusArgument &argument,
-                                ICd2DetailsList &detailsList)
-{
-     argument.beginArray();
-     detailsList.clear();
-
-     while (!argument.atEnd()) {
-         ICd2DetailsDBusStruct element;
-         argument >> element;
-         detailsList.append(element);
-     }
-
-     argument.endArray();
-     return argument;
-}
-
-QDBusArgument &operator<<(QDBusArgument &argument,
-                          const ICd2DetailsList &detailsList)
-{
-     argument.beginArray(qMetaTypeId<ICd2DetailsDBusStruct>());
-
-     for (int i = 0; i < detailsList.count(); ++i)
-         argument << detailsList[i];
-
-     argument.endArray();
-
-     return argument;
-}
-
-static QHash<QString, QVariant> properties;
-
-static QString get_network_interface();
-
-void QNetworkSessionPrivateImpl::iapStateChanged(const QString& iapid, uint icd_connection_state)
-{
-
-    if (((publicConfig.type() == QNetworkConfiguration::UserChoice) &&
-         (activeConfig.identifier() == iapid)) ||
-        (publicConfig.identifier() == iapid)) {
-        switch (icd_connection_state) {
-        case ICD_STATE_CONNECTING:
-            updateState(QNetworkSession::Connecting);
-            break;
-        case ICD_STATE_CONNECTED:
-            updateState(QNetworkSession::Connected);
-            break;
-        case ICD_STATE_DISCONNECTING:
-            updateState(QNetworkSession::Closing);
-            break;
-        case ICD_STATE_DISCONNECTED:
-            updateState(QNetworkSession::Disconnected);
-            break;
-        default:
-            break;
-        }
-    }
-    if (publicConfig.type() == QNetworkConfiguration::UserChoice) {
-        updateIdentifier(iapid);
-    }
-}
-
-void QNetworkSessionPrivateImpl::cleanupSession(void)
-{
-    QObject::disconnect(q, SIGNAL(stateChanged(QNetworkSession::State)),
-                        this, SLOT(updateProxies(QNetworkSession::State)));
-}
-
-
-void QNetworkSessionPrivateImpl::updateState(QNetworkSession::State newState)
-{
-    if (newState != state) {
-        if (newState == QNetworkSession::Disconnected) {
-            if (isOpen) {
-                // The Session was aborted by the user or system
-                lastError = QNetworkSession::SessionAbortedError;
-                emit QNetworkSessionPrivate::error(lastError);
-                emit closed();
-            }
-            if (m_stopTimer.isActive()) {
-                // Session was closed by calling stop()
-                m_stopTimer.stop();
-            }
-            isOpen = false;
-            opened = false;
-            currentNetworkInterface.clear();
-            if (publicConfig.type() == QNetworkConfiguration::UserChoice) {
-                copyConfig(publicConfig, activeConfig);
-                IcdNetworkConfigurationPrivate *icdConfig =
-                    toIcdConfig(privateConfiguration(activeConfig));
-
-                icdConfig->mutex.lock();
-                icdConfig->state = QNetworkConfiguration::Defined;
-                icdConfig->mutex.unlock();
-            } else {
-                if (!activeConfig.isValid()) {
-                    // Active configuration (IAP) was removed from system
-                    // => Connection was disconnected and configuration became
-                    //    invalid
-                    // => Also Session state must be changed to invalid
-                    newState = QNetworkSession::Invalid;
-                }
-            }
-        } else if (newState == QNetworkSession::Connected) {
-            if (opened) {
-                isOpen = true;
-            }
-	    if (publicConfig.type() == QNetworkConfiguration::UserChoice) {
-            IcdNetworkConfigurationPrivate *icdConfig =
-                toIcdConfig(privateConfiguration(activeConfig));
-
-            icdConfig->mutex.lock();
-            icdConfig->state = QNetworkConfiguration::Active;
-            icdConfig->type = QNetworkConfiguration::InternetAccessPoint;
-            icdConfig->mutex.unlock();
-	    }
-
-        IcdNetworkConfigurationPrivate *icdConfig =
-            toIcdConfig(privateConfiguration(publicConfig));
-
-        icdConfig->mutex.lock();
-        icdConfig->state = QNetworkConfiguration::Active;
-        icdConfig->mutex.unlock();
-	}
-
-        if (newState != state) {
-            state = newState;
-            emit stateChanged(newState);
-        }
-    }
-}
-
-
-void QNetworkSessionPrivateImpl::updateIdentifier(const QString &newId)
-{
-    if (publicConfig.type() == QNetworkConfiguration::UserChoice) {
-        IcdNetworkConfigurationPrivate *icdConfig =
-            toIcdConfig(privateConfiguration(activeConfig));
-
-        icdConfig->mutex.lock();
-        icdConfig->network_attrs |= ICD_NW_ATTR_IAPNAME;
-        icdConfig->id = newId;
-        icdConfig->mutex.unlock();
-    } else {
-        IcdNetworkConfigurationPrivate *icdConfig =
-            toIcdConfig(privateConfiguration(publicConfig));
-
-        icdConfig->mutex.lock();
-        icdConfig->network_attrs |= ICD_NW_ATTR_IAPNAME;
-        if (icdConfig->id != newId)
-            icdConfig->id = newId;
-        icdConfig->mutex.unlock();
-    }
-}
-
-
-QNetworkSessionPrivateImpl::Statistics QNetworkSessionPrivateImpl::getStatistics() const
-{
-    /* This could be also implemented by using the Maemo::Icd::statistics()
-     * that gets the statistics data for a specific IAP. Change if
-     * necessary.
-     */
-    Maemo::Icd icd;
-    QList<Maemo::IcdStatisticsResult> stats_results;
-    Statistics stats = { 0, 0, 0};
-
-    if (!icd.statistics(stats_results))
-        return stats;
-
-    foreach (const Maemo::IcdStatisticsResult &res, stats_results) {
-        if (res.params.network_attrs & ICD_NW_ATTR_IAPNAME) {
-            /* network_id is the IAP UUID */
-            if (QString(res.params.network_id.data()) == activeConfig.identifier()) {
-                stats.txData = res.bytes_sent;
-                stats.rxData = res.bytes_received;
-                stats.activeTime = res.time_active;
-            }
-        } else {
-            /* We probably will never get to this branch */
-            IcdNetworkConfigurationPrivate *icdConfig =
-                toIcdConfig(privateConfiguration(activeConfig));
-
-            icdConfig->mutex.lock();
-            if (res.params.network_id == icdConfig->network_id) {
-                stats.txData = res.bytes_sent;
-                stats.rxData = res.bytes_received;
-                stats.activeTime = res.time_active;
-            }
-            icdConfig->mutex.unlock();
-        }
-    }
-
-    return stats;
-}
-
-
-quint64 QNetworkSessionPrivateImpl::bytesWritten() const
-{
-    return getStatistics().txData;
-}
-
-quint64 QNetworkSessionPrivateImpl::bytesReceived() const
-{
-    return getStatistics().rxData;
-}
-
-quint64 QNetworkSessionPrivateImpl::activeTime() const
-{
-    return getStatistics().activeTime;
-}
-
-
-QNetworkConfiguration& QNetworkSessionPrivateImpl::copyConfig(QNetworkConfiguration &fromConfig,
-                                                              QNetworkConfiguration &toConfig,
-                                                              bool deepCopy)
-{
-    IcdNetworkConfigurationPrivate *cpPriv;
-    if (deepCopy) {
-        cpPriv = new IcdNetworkConfigurationPrivate;
-        setPrivateConfiguration(toConfig, QNetworkConfigurationPrivatePointer(cpPriv));
-    } else {
-        cpPriv = toIcdConfig(privateConfiguration(toConfig));
-    }
-
-    IcdNetworkConfigurationPrivate *fromPriv = toIcdConfig(privateConfiguration(fromConfig));
-
-    QMutexLocker toLocker(&cpPriv->mutex);
-    QMutexLocker fromLocker(&fromPriv->mutex);
-
-    cpPriv->name = fromPriv->name;
-    cpPriv->isValid = fromPriv->isValid;
-    // Note that we do not copy id field here as the publicConfig does
-    // not contain a valid IAP id.
-    cpPriv->state = fromPriv->state;
-    cpPriv->type = fromPriv->type;
-    cpPriv->roamingSupported = fromPriv->roamingSupported;
-    cpPriv->purpose = fromPriv->purpose;
-    cpPriv->network_id = fromPriv->network_id;
-    cpPriv->iap_type = fromPriv->iap_type;
-    cpPriv->bearerType = fromPriv->bearerType;
-    cpPriv->network_attrs = fromPriv->network_attrs;
-    cpPriv->service_type = fromPriv->service_type;
-    cpPriv->service_id = fromPriv->service_id;
-    cpPriv->service_attrs = fromPriv->service_attrs;
-
-    return toConfig;
-}
-
-
-/* This is called by QNetworkSession constructor and it updates the current
- * state of the configuration.
- */
-void QNetworkSessionPrivateImpl::syncStateWithInterface()
-{
-    /* Initially we are not active although the configuration might be in
-     * connected state.
-     */
-    isOpen = false;
-    opened = false;
-
-    connect(engine, SIGNAL(iapStateChanged(const QString&, uint)),
-            this, SLOT(iapStateChanged(const QString&, uint)));
-
-    QObject::connect(q, SIGNAL(stateChanged(QNetworkSession::State)), this, SLOT(updateProxies(QNetworkSession::State)));
-
-    state = QNetworkSession::Invalid;
-    lastError = QNetworkSession::UnknownSessionError;
-
-    switch (publicConfig.type()) {
-    case QNetworkConfiguration::InternetAccessPoint:
-        activeConfig = publicConfig;
-        break;
-    case QNetworkConfiguration::ServiceNetwork:
-        serviceConfig = publicConfig;
-	break;
-    case QNetworkConfiguration::UserChoice:
-	// active config will contain correct data after open() has succeeded
-        copyConfig(publicConfig, activeConfig);
-
-	/* We create new configuration that holds the actual configuration
-	 * returned by icd. This way publicConfig still contains the
-	 * original user specified configuration.
-	 *
-	 * Note that the new activeConfig configuration is not inserted
-	 * to configurationManager as manager class will get the newly
-	 * connected configuration from gconf when the IAP is saved.
-	 * This configuration manager update is done by IapMonitor class.
-	 * If the ANY connection fails in open(), then the configuration
-	 * data is not saved to gconf and will not be added to
-	 * configuration manager IAP list.
-	 */
-#ifdef BEARER_MANAGEMENT_DEBUG
-	qDebug()<<"New configuration created for" << publicConfig.identifier();
-#endif
-	break;
-    default:
-	/* Invalid configuration, no point continuing */
-	return;
-    }
-
-    if (!activeConfig.isValid())
-	return;
-
-    /* Get the initial state from icd */
-    Maemo::Icd icd;
-    QList<Maemo::IcdStateResult> state_results;
-
-    /* Update the active config from first connection, this is ok as icd
-     * supports only one connection anyway.
-     */
-    if (icd.state(state_results) && !state_results.isEmpty()) {
-	/* If we did not get full state back, then we are not
-	 * connected and can skip the next part.
-	 */
-	if (!(state_results.first().params.network_attrs == 0 &&
-		state_results.first().params.network_id.isEmpty())) {
-
-	    /* If we try to connect to specific IAP and we get results back
-	     * that tell the icd is actually connected to another IAP,
-	     * then do not update current state etc.
-	     */
-	    if (publicConfig.type() == QNetworkConfiguration::UserChoice ||
-            publicConfig.identifier() == state_results.first().params.network_id) {
-		switch (state_results.first().state) {
-		case ICD_STATE_DISCONNECTED:
-            state = QNetworkSession::Disconnected;
-            if (QNetworkConfigurationPrivatePointer ptr = privateConfiguration(activeConfig)) {
-                ptr->mutex.lock();
-                ptr->isValid = true;
-                ptr->mutex.unlock();
-            }
-            break;
-		case ICD_STATE_CONNECTING:
-            state = QNetworkSession::Connecting;
-            if (QNetworkConfigurationPrivatePointer ptr = privateConfiguration(activeConfig)) {
-                ptr->mutex.lock();
-                ptr->isValid = true;
-                ptr->mutex.unlock();
-            }
-            break;
-		case ICD_STATE_CONNECTED:
-        {
-            if (!state_results.first().error.isEmpty())
-                break;
-
-            const QString id = state_results.first().params.network_id;
-
-            QNetworkConfiguration config = manager.configurationFromIdentifier(id);
-            if (config.isValid()) {
-                //we don't want the copied data if the config is already known by the manager
-                //just reuse it so that existing references to the old data get the same update
-                setPrivateConfiguration(activeConfig, privateConfiguration(config));
-            }
-
-            QNetworkConfigurationPrivatePointer ptr = privateConfiguration(activeConfig);
-
-            QMutexLocker configLocker(&ptr->mutex);
-
-			state = QNetworkSession::Connected;
-            toIcdConfig(ptr)->network_id = state_results.first().params.network_id;
-            ptr->id = toIcdConfig(ptr)->network_id;
-            toIcdConfig(ptr)->network_attrs = state_results.first().params.network_attrs;
-            toIcdConfig(ptr)->iap_type = state_results.first().params.network_type;
-            ptr->bearerType = bearerTypeFromIapType(toIcdConfig(ptr)->iap_type);
-            toIcdConfig(ptr)->service_type = state_results.first().params.service_type;
-            toIcdConfig(ptr)->service_id = state_results.first().params.service_id;
-            toIcdConfig(ptr)->service_attrs = state_results.first().params.service_attrs;
-            ptr->type = QNetworkConfiguration::InternetAccessPoint;
-            ptr->state = QNetworkConfiguration::Active;
-            ptr->isValid = true;
-            currentNetworkInterface = get_network_interface();
-
-            Maemo::IAPConf iap_name(ptr->id);
-			QString name_value = iap_name.value("name").toString();
-			if (!name_value.isEmpty())
-                ptr->name = name_value;
-			else
-                ptr->name = ptr->id;
-
-            const QString identifier = ptr->id;
-
-            configLocker.unlock();
-
-            // Add the new active configuration to manager or update the old config
-            if (!engine->hasIdentifier(identifier))
-                engine->addSessionConfiguration(ptr);
-            else
-                engine->changedSessionConfiguration(ptr);
-        }
-        break;
-
-		case ICD_STATE_DISCONNECTING:
-            state = QNetworkSession::Closing;
-            if (QNetworkConfigurationPrivatePointer ptr = privateConfiguration(activeConfig)) {
-                ptr->mutex.lock();
-                ptr->isValid = true;
-                ptr->mutex.unlock();
-            }
-            break;
-		default:
-            break;
-		}
-    }
-	} else {
-#ifdef BEARER_MANAGEMENT_DEBUG
-	    qDebug() << "status_req tells icd is not connected";
-#endif
-	}
-    } else {
-#ifdef BEARER_MANAGEMENT_DEBUG
-	qDebug() << "status_req did not return any results from icd";
-#endif
-    }
-
-    networkConfigurationsChanged();
-}
-
-
-void QNetworkSessionPrivateImpl::networkConfigurationsChanged()
-{
-    if (serviceConfig.isValid())
-        updateStateFromServiceNetwork();
-    else
-        updateStateFromActiveConfig();
-}
-
-
-void QNetworkSessionPrivateImpl::updateStateFromServiceNetwork()
-{
-    QNetworkSession::State oldState = state;
-
-    foreach (const QNetworkConfiguration &config, serviceConfig.children()) {
-        if ((config.state() & QNetworkConfiguration::Active) != QNetworkConfiguration::Active)
-            continue;
-
-        if (activeConfig != config) {
-            activeConfig = config;
-            emit newConfigurationActivated();
-        }
-
-        state = QNetworkSession::Connected;
-        if (state != oldState)
-            emit stateChanged(state);
-
-        return;
-    }
-
-    if (serviceConfig.children().isEmpty())
-        state = QNetworkSession::NotAvailable;
-    else
-        state = QNetworkSession::Disconnected;
-
-    if (state != oldState)
-        emit stateChanged(state);
-}
-
-
-void QNetworkSessionPrivateImpl::clearConfiguration(QNetworkConfiguration &config)
-{
-    IcdNetworkConfigurationPrivate *icdConfig = toIcdConfig(privateConfiguration(config));
-
-    QMutexLocker locker(&icdConfig->mutex);
-
-    icdConfig->network_id.clear();
-    icdConfig->iap_type.clear();
-    icdConfig->network_attrs = 0;
-    icdConfig->service_type.clear();
-    icdConfig->service_id.clear();
-    icdConfig->service_attrs = 0;
-}
-
-
-void QNetworkSessionPrivateImpl::updateStateFromActiveConfig()
-{
-    QNetworkSession::State oldState = state;
-
-    bool newActive = false;
-
-    if (!activeConfig.isValid())
-        return;
-
-    if (!activeConfig.isValid()) {
-        state = QNetworkSession::Invalid;
-        clearConfiguration(activeConfig);
-    } else if ((activeConfig.state() & QNetworkConfiguration::Active) == QNetworkConfiguration::Active) {
-        state = QNetworkSession::Connected;
-        newActive = opened;
-    } else if ((activeConfig.state() & QNetworkConfiguration::Discovered) == QNetworkConfiguration::Discovered) {
-        state = QNetworkSession::Disconnected;
-    } else if ((activeConfig.state() & QNetworkConfiguration::Defined) == QNetworkConfiguration::Defined) {
-        state = QNetworkSession::NotAvailable;
-    } else if ((activeConfig.state() & QNetworkConfiguration::Undefined) == QNetworkConfiguration::Undefined) {
-        state = QNetworkSession::NotAvailable;
-    }
-
-    bool oldActive = isOpen;
-    isOpen = newActive;
-
-    if (!oldActive && isOpen)
-        emit quitPendingWaitsForOpened();
-
-    if (oldActive && !isOpen)
-        emit closed();
-
-    if (oldState != state) {
-        emit stateChanged(state);
-
-    if (state == QNetworkSession::Disconnected && oldActive) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-	    //qDebug()<<"session aborted error emitted for"<<activeConfig.identifier();
-#endif
-	    lastError = QNetworkSession::SessionAbortedError;
-        emit QNetworkSessionPrivate::error(lastError);
-	}
-    }
-
-#ifdef BEARER_MANAGEMENT_DEBUG
-    //qDebug()<<"oldState ="<<oldState<<" state ="<<state<<" oldActive ="<<oldActive<<" newActive ="<<newActive<<" opened ="<<opened;
-#endif
-}
-
-static QString get_network_interface()
-{
-    Maemo::Icd icd;
-    QList<Maemo::IcdAddressInfoResult> addr_results;
-    uint ret;
-    QString iface;
-
-    ret = icd.addrinfo(addr_results);
-    if (ret == 0) {
-	/* No results */
-#ifdef BEARER_MANAGEMENT_DEBUG
-        qDebug() << "Cannot get addrinfo from icd, are you connected or is icd running?";
-#endif
-        return iface;
-    }
-
-    if (addr_results.first().ip_info.isEmpty())
-        return QString();
-
-    QByteArray data = addr_results.first().ip_info.first().address.toAscii();
-    struct in_addr addr;
-    if (inet_aton(data.constData(), &addr) == 0) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-        qDebug() << "address" << data.constData() << "invalid";
-#endif
-        return iface;
-    }
-
-    struct ifaddrs *ifaddr, *ifa;
-    int family;
-
-    if (getifaddrs(&ifaddr) == -1) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-	qDebug() << "getifaddrs() failed";
-#endif
-	return iface;
-    }
-
-    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
-        if (ifa->ifa_addr) {
-            family = ifa->ifa_addr->sa_family;
-            if (family != AF_INET) {
-                continue; /* Currently only IPv4 is supported by icd dbus interface */
-            }
-            if (((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr == addr.s_addr) {
-                iface = QString(ifa->ifa_name);
-                break;
-            }
-        }
-    }
-
-    freeifaddrs(ifaddr);
-    return iface;
-}
-
-
-void QNetworkSessionPrivateImpl::open()
-{
-    if (m_stopTimer.isActive()) {
-        m_stopTimer.stop();
-    }
-    if (!publicConfig.isValid()) {
-        lastError = QNetworkSession::InvalidConfigurationError;
-        emit QNetworkSessionPrivate::error(lastError);
-        return;
-    }
-    if (serviceConfig.isValid()) {
-        lastError = QNetworkSession::OperationNotSupportedError;
-        emit QNetworkSessionPrivate::error(lastError);
-    } else if (!opened) {
-	if (publicConfig.type() == QNetworkConfiguration::UserChoice) {
-	    /* Caller is trying to connect to default IAP.
-	     * At this time we will not know the IAP details so we just
-	     * connect and update the active config when the IAP is
-	     * connected.
-	     */
-	    opened = true;
-            state = QNetworkSession::Connecting;
-            emit stateChanged(state);
-	    QTimer::singleShot(0, this, SLOT(do_open()));
-	    return;
-	}
-
-	/* User is connecting to one specific IAP. If that IAP is not
-	 * in discovered state we cannot continue.
-	 */
-        if ((activeConfig.state() & QNetworkConfiguration::Discovered) !=
-            QNetworkConfiguration::Discovered) {
-            lastError =QNetworkSession::InvalidConfigurationError;
-            emit QNetworkSessionPrivate::error(lastError);
-            return;
-        }
-        opened = true;
-
-        if ((activeConfig.state() & QNetworkConfiguration::Active) != QNetworkConfiguration::Active) {
-            state = QNetworkSession::Connecting;
-            emit stateChanged(state);
-            QTimer::singleShot(0, this, SLOT(do_open()));
-            return;
-        }
-        isOpen = (activeConfig.state() & QNetworkConfiguration::Active) == QNetworkConfiguration::Active;
-        if (isOpen)
-            emit quitPendingWaitsForOpened();
-    } else {
-        /* We seem to be active so inform caller */
-        emit quitPendingWaitsForOpened();
-    }
-}
-
-void QNetworkSessionPrivateImpl::do_open()
-{
-    icd_connection_flags flags = connectFlags;
-    QString iap = publicConfig.identifier();
-
-    if (state == QNetworkSession::Connected) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-        qDebug() << "Already connected to" << activeConfig.identifier();
-#endif
-        emit stateChanged(QNetworkSession::Connected);
-        emit quitPendingWaitsForOpened();
-	return;
-    }
-
-    if (publicConfig.type() == QNetworkConfiguration::UserChoice)
-        config = activeConfig;
-    else
-        config = publicConfig;
-
-    if (iap == OSSO_IAP_ANY) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-        qDebug() << "connecting to default IAP" << iap;
-#endif
-        m_connectRequestTimer.start(ICD_LONG_CONNECT_TIMEOUT);
-        m_dbusInterface->asyncCall(ICD_DBUS_API_CONNECT_REQ, (uint)flags); // Return value ignored
-        m_asynchCallActive = true;
-    } else {
-        IcdNetworkConfigurationPrivate *icdConfig = toIcdConfig(privateConfiguration(config));
-
-        icdConfig->mutex.lock();
-        ICd2DetailsDBusStruct icd2;
-        icd2.serviceType = icdConfig->service_type;
-        icd2.serviceAttributes = icdConfig->service_attrs;
-        icd2.setviceId = icdConfig->service_id;
-        icd2.networkType = icdConfig->iap_type;
-        icd2.networkAttributes = icdConfig->network_attrs;
-        if (icdConfig->network_attrs & ICD_NW_ATTR_IAPNAME) {
-            icd2.networkId  = QByteArray(iap.toLatin1());
-        } else {
-            icd2.networkId  = icdConfig->network_id;
-        }
-        icdConfig->mutex.unlock();
-
-#ifdef BEARER_MANAGEMENT_DEBUG
-    qDebug("connecting to %s/%s/0x%x/%s/0x%x/%s",
-        icd2.networkId.data(),
-        icd2.networkType.toAscii().constData(),
-        icd2.networkAttributes,
-        icd2.serviceType.toAscii().constData(),
-        icd2.serviceAttributes,
-        icd2.setviceId.toAscii().constData());
-#endif
-
-        ICd2DetailsList paramArray;
-        paramArray.append(icd2);
-        m_connectRequestTimer.start(ICD_LONG_CONNECT_TIMEOUT);
-        m_dbusInterface->asyncCall(ICD_DBUS_API_CONNECT_REQ, (uint)flags, QVariant::fromValue(paramArray)); // Return value ignored
-        m_asynchCallActive = true;
-    }
-}
-
-void QNetworkSessionPrivateImpl::stateChange(const QDBusMessage& rep)
-{
-     if (m_asynchCallActive == true) {
-        if (m_connectRequestTimer.isActive())
-            m_connectRequestTimer.stop();
-        m_asynchCallActive = false;
-
-        QString result = rep.arguments().at(5).toString(); // network id or empty string
-        QString connected_iap = result;
-        if (connected_iap.isEmpty()) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-            qDebug() << "connect to"<< publicConfig.identifier() << "failed, result is empty";
-#endif
-            updateState(QNetworkSession::Disconnected);
-            emit QNetworkSessionPrivate::error(QNetworkSession::SessionAbortedError);
-            if (publicConfig.type() == QNetworkConfiguration::UserChoice)
-                    copyConfig(publicConfig, activeConfig);
-            return;
-        }
-
-         /* If the user tried to connect to some specific connection (foo)
-         * and we were already connected to some other connection (bar),
-         * then we cannot activate this session although icd has a valid
-         * connection to somewhere.
-         */
-        if ((publicConfig.type() != QNetworkConfiguration::UserChoice) &&
-            (connected_iap != config.identifier())) {
-            updateState(QNetworkSession::Disconnected);
-            emit QNetworkSessionPrivate::error(QNetworkSession::UnknownSessionError);
-            return;
-        }
-
-        IcdNetworkConfigurationPrivate *icdConfig = toIcdConfig(privateConfiguration(config));
-
-        /* Did we connect to non saved IAP? */
-        icdConfig->mutex.lock();
-        if (!(icdConfig->network_attrs & ICD_NW_ATTR_IAPNAME)) {
-            /* Because the connection succeeded, the IAP is now known.
-             */
-            icdConfig->network_attrs |= ICD_NW_ATTR_IAPNAME;
-            icdConfig->id = connected_iap;
-        }
-
-        /* User might have changed the IAP name when a new IAP was saved */
-        Maemo::IAPConf iap_name(icdConfig->id);
-        QString name = iap_name.value("name").toString();
-        if (!name.isEmpty())
-            icdConfig->name = name;
-
-        icdConfig->iap_type = rep.arguments().at(3).toString(); // connect_result.connect.network_type;
-        icdConfig->bearerType = bearerTypeFromIapType(icdConfig->iap_type);
-        icdConfig->isValid = true;
-        icdConfig->state = QNetworkConfiguration::Active;
-        icdConfig->type = QNetworkConfiguration::InternetAccessPoint;
-
-        icdConfig->mutex.unlock();
-
-        startTime = QDateTime::currentDateTime();
-        updateState(QNetworkSession::Connected);
-        //currentNetworkInterface = get_network_interface();
-#ifdef BEARER_MANAGEMENT_DEBUG
-        //qDebug() << "connected to" << result << config.name() << "at" << currentNetworkInterface;
-#endif
-
-        /* We first check if the configuration already exists in the manager
-         * and if it is not found there, we then insert it. Note that this
-         * is only done for user choice config only because it can be missing
-         * from config manager list.
-         */
-        if (publicConfig.type() == QNetworkConfiguration::UserChoice) {
-            if (!engine->hasIdentifier(result)) {
-                engine->addSessionConfiguration(privateConfiguration(config));
-            } else {
-                QNetworkConfigurationPrivatePointer priv = engine->configuration(result);
-                QNetworkConfiguration reference;
-                setPrivateConfiguration(reference, priv);
-                copyConfig(config, reference, false);
-                privateConfiguration(reference)->id = result; // Note: Id was not copied in copyConfig() function
-                config = reference;
-                activeConfig = reference;
-                engine->changedSessionConfiguration(privateConfiguration(config));
-
-#ifdef BEARER_MANAGEMENT_DEBUG
-                qDebug()<<"Existing configuration"<<result<<"updated in manager in open";
-#endif
-            }
-        }
-
-        emit quitPendingWaitsForOpened();
-    }
-}
-
-void QNetworkSessionPrivateImpl::connectTimeout()
-{
-    updateState(QNetworkSession::Disconnected);
-    if (publicConfig.type() == QNetworkConfiguration::UserChoice)
-            copyConfig(publicConfig, activeConfig);
-        emit QNetworkSessionPrivate::error(QNetworkSession::UnknownSessionError);
-}
-
-void QNetworkSessionPrivateImpl::close()
-{
-    if (m_connectRequestTimer.isActive())
-        m_connectRequestTimer.stop();
-
-    if (serviceConfig.isValid()) {
-        lastError = QNetworkSession::OperationNotSupportedError;
-        emit QNetworkSessionPrivate::error(lastError);
-    } else if (isOpen) {
-        if ((activeConfig.state() & QNetworkConfiguration::Active) == QNetworkConfiguration::Active) {
-	    // We will not wait any disconnect from icd as it might never come
-#ifdef BEARER_MANAGEMENT_DEBUG
-	    qDebug() << "closing session" << publicConfig.identifier();
-#endif
-	    state = QNetworkSession::Closing;
-	    emit stateChanged(state);
-
-	    // we fake a disconnection, session error is sent
-	    updateState(QNetworkSession::Disconnected);
-
-	    opened = false;
-	    isOpen = false;
-
-        m_dbusInterface->call(ICD_DBUS_API_DISCONNECT_REQ, ICD_CONNECTION_FLAG_APPLICATION_EVENT);
-	    startTime = QDateTime();
-        } else {
-	    opened = false;
-	    isOpen = false;
-	    emit closed();
-	}
-    }
-}
-
-
-void QNetworkSessionPrivateImpl::stop()
-{
-    if (m_connectRequestTimer.isActive())
-        m_connectRequestTimer.stop();
-
-    if (serviceConfig.isValid()) {
-        lastError = QNetworkSession::OperationNotSupportedError;
-        emit QNetworkSessionPrivate::error(lastError);
-    } else {
-        if ((activeConfig.state() & QNetworkConfiguration::Active) == QNetworkConfiguration::Active) {
-#ifdef BEARER_MANAGEMENT_DEBUG
-	    qDebug() << "stopping session" << publicConfig.identifier();
-#endif
-	    state = QNetworkSession::Closing;
-	    emit stateChanged(state);
-
-	    // we fake a disconnection, a session error is sent also
-	    updateState(QNetworkSession::Disconnected);
-
-	    opened = false;
-	    isOpen = false;
-
-        m_dbusInterface->call(ICD_DBUS_API_DISCONNECT_REQ, ICD_CONNECTION_FLAG_APPLICATION_EVENT);
-	    startTime = QDateTime();
-        } else {
-	    opened = false;
-	    isOpen = false;
-	    emit closed();
-	}
-    }
-}
-
-void QNetworkSessionPrivateImpl::finishStopBySendingClosedSignal()
-{
-    if ((activeConfig.state() & QNetworkConfiguration::Active) == QNetworkConfiguration::Active) {
-        state = QNetworkSession::Connected;
-        emit stateChanged(state);
-    }
-
-    emit closed();
-}
-
-void QNetworkSessionPrivateImpl::migrate()
-{
-}
-
-
-void QNetworkSessionPrivateImpl::accept()
-{
-}
-
-
-void QNetworkSessionPrivateImpl::ignore()
-{
-}
-
-
-void QNetworkSessionPrivateImpl::reject()
-{
-}
-
-#ifndef QT_NO_NETWORKINTERFACE
-QNetworkInterface QNetworkSessionPrivateImpl::currentInterface() const
-{
-    if (!publicConfig.isValid() || state != QNetworkSession::Connected)
-        return QNetworkInterface();
-
-    if (currentNetworkInterface.isEmpty())
-        return QNetworkInterface();
-
-    return QNetworkInterface::interfaceFromName(currentNetworkInterface);
-}
-#endif
-
-void QNetworkSessionPrivateImpl::setSessionProperty(const QString& key, const QVariant& value)
-{
-    if (value.isValid()) {
-	properties.insert(key, value);
-
-	if (key == "ConnectInBackground") {
-	    bool v = value.toBool();
-	    if (v)
-		connectFlags = ICD_CONNECTION_FLAG_APPLICATION_EVENT;
-	    else
-		connectFlags = ICD_CONNECTION_FLAG_USER_EVENT;
-	}
-    } else {
-	properties.remove(key);
-
-	/* Set default value when property is removed */
-	if (key == "ConnectInBackground")
-	    connectFlags = ICD_CONNECTION_FLAG_USER_EVENT;
-    }
-}
-
-
-QVariant QNetworkSessionPrivateImpl::sessionProperty(const QString& key) const
-{
-    return properties.value(key);
-}
-
-
-QString QNetworkSessionPrivateImpl::errorString() const
-{
-    QString errorStr;
-    switch(q->error()) {
-    case QNetworkSession::RoamingError:
-        errorStr = QNetworkSessionPrivateImpl::tr("Roaming error");
-        break;
-    case QNetworkSession::SessionAbortedError:
-        errorStr = QNetworkSessionPrivateImpl::tr("Session aborted by user or system");
-        break;
-    case QNetworkSession::InvalidConfigurationError:
-        errorStr = QNetworkSessionPrivateImpl::tr("The specified configuration cannot be used.");
-        break;
-    default:
-    case QNetworkSession::UnknownSessionError:
-        errorStr = QNetworkSessionPrivateImpl::tr("Unidentified Error");
-        break;
-    }
-    return errorStr;
-}
-
-
-QNetworkSession::SessionError QNetworkSessionPrivateImpl::error() const
-{
-    return QNetworkSession::UnknownSessionError;
-}
-
-void QNetworkSessionPrivateImpl::updateProxies(QNetworkSession::State newState)
-{
-    if ((newState == QNetworkSession::Connected) &&
-	(newState != currentState))
-	updateProxyInformation();
-    else if ((newState == QNetworkSession::Disconnected) &&
-	    (currentState == QNetworkSession::Closing))
-	clearProxyInformation();
-
-    currentState = newState;
-}
-
-
-void QNetworkSessionPrivateImpl::updateProxyInformation()
-{
-    Maemo::ProxyConf::update();
-}
-
-
-void QNetworkSessionPrivateImpl::clearProxyInformation()
-{
-    Maemo::ProxyConf::clear();
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_BEARERMANAGEMENT
diff --git a/src/plugins/bearer/icd/qnetworksession_impl.h b/src/plugins/bearer/icd/qnetworksession_impl.h
deleted file mode 100644
index 18094e4..0000000
--- a/src/plugins/bearer/icd/qnetworksession_impl.h
+++ /dev/null
@@ -1,229 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QNETWORKSESSION_IMPL_H
-#define QNETWORKSESSION_IMPL_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of the QLibrary class.  This header file may change from
-// version to version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtNetwork/private/qnetworksession_p.h>
-#include <QtNetwork/qnetworkconfigmanager.h>
-
-#include <QtCore/qdatetime.h>
-#include <QtCore/qtimer.h>
-#include <QtCore/quuid.h>
-
-#include <QtDBus/qdbusconnection.h>
-#include <QtDBus/qdbusinterface.h>
-#include <QtDBus/qdbusmessage.h>
-#include <QtDBus/qdbusmetatype.h>
-
-#include <icd/dbus_api.h>
-
-#ifndef QT_NO_BEARERMANAGEMENT
-
-QT_BEGIN_NAMESPACE
-
-class QIcdEngine;
-
-struct ICd2DetailsDBusStruct
-{
-    QString serviceType;
-    uint serviceAttributes;
-    QString setviceId;
-    QString networkType;
-    uint networkAttributes;
-    QByteArray networkId;
-};
-
-typedef QList<ICd2DetailsDBusStruct> ICd2DetailsList;
-
-class QNetworkSessionPrivateImpl : public QNetworkSessionPrivate
-{
-    Q_OBJECT
-
-public:
-    QNetworkSessionPrivateImpl(QIcdEngine *engine)
-    :   engine(engine),
-        connectFlags(ICD_CONNECTION_FLAG_USER_EVENT),
-        currentState(QNetworkSession::Invalid),
-        m_asynchCallActive(false)
-    {
-        m_stopTimer.setSingleShot(true);
-        connect(&m_stopTimer, SIGNAL(timeout()), this, SLOT(finishStopBySendingClosedSignal()));
-
-        QDBusConnection systemBus = QDBusConnection::connectToBus(
-            QDBusConnection::SystemBus,
-            QUuid::createUuid().toString());
-
-        m_dbusInterface = new QDBusInterface(ICD_DBUS_API_INTERFACE,
-                                         ICD_DBUS_API_PATH,
-                                         ICD_DBUS_API_INTERFACE,
-                                         systemBus,
-                                         this);
-
-        systemBus.connect(ICD_DBUS_API_INTERFACE,
-                        ICD_DBUS_API_PATH,
-                        ICD_DBUS_API_INTERFACE,
-                        ICD_DBUS_API_CONNECT_SIG,
-                        this,
-                        SLOT(stateChange(const QDBusMessage&)));
-
-        qDBusRegisterMetaType<ICd2DetailsDBusStruct>();
-        qDBusRegisterMetaType<ICd2DetailsList>();
-
-        m_connectRequestTimer.setSingleShot(true);
-        connect(&m_connectRequestTimer, SIGNAL(timeout()), this, SLOT(connectTimeout()));
-    }
-
-    ~QNetworkSessionPrivateImpl()
-    {
-        cleanupSession();
-
-        QDBusConnection::disconnectFromBus(m_dbusInterface->connection().name());
-    }
-
-    //called by QNetworkSession constructor and ensures
-    //that the state is immediately updated (w/o actually opening
-    //a session). Also this function should take care of 
-    //notification hooks to discover future state changes.
-    void syncStateWithInterface();
-
-#ifndef QT_NO_NETWORKINTERFACE
-    QNetworkInterface currentInterface() const;
-#endif
-    QVariant sessionProperty(const QString& key) const;
-    void setSessionProperty(const QString& key, const QVariant& value);
-
-    void open();
-    void close();
-    void stop();
-
-    void migrate();
-    void accept();
-    void ignore();
-    void reject();
-
-    QString errorString() const; //must return translated string
-    QNetworkSession::SessionError error() const;
-
-    quint64 bytesWritten() const;
-    quint64 bytesReceived() const;
-    quint64 activeTime() const;
-
-private:
-    void updateStateFromServiceNetwork();
-    void updateStateFromActiveConfig();
-
-private Q_SLOTS:
-    void do_open();
-    void networkConfigurationsChanged();
-    void iapStateChanged(const QString& iapid, uint icd_connection_state);
-    void updateProxies(QNetworkSession::State newState);
-    void finishStopBySendingClosedSignal();
-    void stateChange(const QDBusMessage& rep);
-    void connectTimeout();
-
-private:
-    QNetworkConfigurationManager manager;
-    QIcdEngine *engine;
-
-    struct Statistics {
-        quint64 txData;
-        quint64 rxData;
-        quint64 activeTime;
-    };
-
-    // The config set on QNetworkSession.
-    QNetworkConfiguration config;
-
-    QNetworkConfiguration& copyConfig(QNetworkConfiguration &fromConfig, QNetworkConfiguration &toConfig, bool deepCopy = true);
-    void clearConfiguration(QNetworkConfiguration &config);
-
-    bool opened;
-    icd_connection_flags connectFlags;
-
-    QNetworkSession::SessionError lastError;
-
-    QDateTime startTime;
-    QString currentNetworkInterface;
-    friend class IcdListener;
-    void updateState(QNetworkSession::State);
-    void updateIdentifier(const QString &newId);
-    Statistics getStatistics() const;
-    void cleanupSession(void);
-
-    void updateProxyInformation();
-    void clearProxyInformation();
-    QNetworkSession::State currentState;
-
-    QDBusInterface *m_dbusInterface;
-
-    QTimer m_stopTimer;
-
-    bool m_asynchCallActive;
-    QTimer m_connectRequestTimer;
-};
-
-// Marshall the ICd2DetailsDBusStruct data into a D-Bus argument
-QDBusArgument &operator<<(QDBusArgument &argument, const ICd2DetailsDBusStruct &icd2);
-
-// Retrieve the ICd2DetailsDBusStruct data from the D-Bus argument
-const QDBusArgument &operator>>(const QDBusArgument &argument, ICd2DetailsDBusStruct &icd2);
-
-Q_DECLARE_METATYPE(ICd2DetailsDBusStruct);
-Q_DECLARE_METATYPE(ICd2DetailsList);
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_BEARERMANAGEMENT
-
-#endif //QNETWORKSESSIONPRIVATE_H
-
diff --git a/src/plugins/bearer/icd/wlan-utils.h b/src/plugins/bearer/icd/wlan-utils.h
deleted file mode 100644
index 5735caa..0000000
--- a/src/plugins/bearer/icd/wlan-utils.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: Nokia Corporation (qt-info@nokia.com)
-**
-** This file is part of the plugins of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-
-#ifndef WLAN_UTILS_H
-#define WLAN_UTILS_H
-
-/** Originally taken from: libicd-network-wlan-dev.h*/
-
-#include <glib.h>
-#include <dbus/dbus.h>
-#include <wlancond.h>
-#include <icd/network_api_defines.h>
-
-/* capability bits inside network attributes var */
-#define NWATTR_WPS_MASK       0x0000F000
-#define NWATTR_ALGORITHM_MASK 0x00000F00
-#define NWATTR_WPA2_MASK      0x00000080
-#define NWATTR_METHOD_MASK    0x00000078
-#define NWATTR_MODE_MASK      0x00000007
-
-#define CAP_LOCALMASK         0x0FFFE008
-
-/* how much to shift between capability and network attributes var */
-#define CAP_SHIFT_WPS        3
-#define CAP_SHIFT_ALGORITHM 20
-#define CAP_SHIFT_WPA2       1
-#define CAP_SHIFT_METHOD     1
-#define CAP_SHIFT_MODE       0
-#define CAP_SHIFT_ALWAYS_ONLINE 26
-
-/* ------------------------------------------------------------------------- */
-/* From combined to capability */
-static inline dbus_uint32_t nwattr2cap(guint nwattrs, dbus_uint32_t *cap)
-{
-	guint oldval = *cap;
-
-	*cap &= CAP_LOCALMASK; /* clear old capabilities */
-	*cap |=
-		((nwattrs & ICD_NW_ATTR_ALWAYS_ONLINE) >> CAP_SHIFT_ALWAYS_ONLINE) |
-		((nwattrs & NWATTR_WPS_MASK) >> CAP_SHIFT_WPS) |
-		((nwattrs & NWATTR_ALGORITHM_MASK) << CAP_SHIFT_ALGORITHM) |
-		((nwattrs & NWATTR_WPA2_MASK) << CAP_SHIFT_WPA2) |
-		((nwattrs & NWATTR_METHOD_MASK) << CAP_SHIFT_METHOD) |
-		(nwattrs & NWATTR_MODE_MASK);
-
-	return oldval;
-}
-
-
-/* ------------------------------------------------------------------------- */
-/* From capability to combined */
-static inline guint cap2nwattr(dbus_uint32_t cap, guint *nwattrs)
-{
-	guint oldval = *nwattrs;
-
-	*nwattrs &= ~ICD_NW_ATTR_LOCALMASK; /* clear old capabilities */
-        *nwattrs |=
-#ifdef WLANCOND_WPS_MASK
-		((cap & WLANCOND_WPS_MASK) << CAP_SHIFT_WPS) |
-#endif
-		((cap & (WLANCOND_ENCRYPT_ALG_MASK |
-			 WLANCOND_ENCRYPT_GROUP_ALG_MASK)) >> CAP_SHIFT_ALGORITHM)|
-		((cap & WLANCOND_ENCRYPT_WPA2_MASK) >> CAP_SHIFT_WPA2) |
-		((cap & WLANCOND_ENCRYPT_METHOD_MASK) >> CAP_SHIFT_METHOD) |
-		(cap & WLANCOND_MODE_MASK);
-
-	return oldval;
-}
-
-
-#endif
diff --git a/tests/auto/network/bearer/qnetworkconfiguration/qnetworkconfiguration.pro b/tests/auto/network/bearer/qnetworkconfiguration/qnetworkconfiguration.pro
index b01f8d3..cde82a4 100644
--- a/tests/auto/network/bearer/qnetworkconfiguration/qnetworkconfiguration.pro
+++ b/tests/auto/network/bearer/qnetworkconfiguration/qnetworkconfiguration.pro
@@ -4,9 +4,3 @@ SOURCES  += tst_qnetworkconfiguration.cpp
 HEADERS  += ../qbearertestcommon.h
 
 QT = core network testlib
-
-maemo6|maemo5 {
-    CONFIG += link_pkgconfig
-
-    PKGCONFIG += conninet
-}
diff --git a/tests/auto/network/bearer/qnetworkconfiguration/tst_qnetworkconfiguration.cpp b/tests/auto/network/bearer/qnetworkconfiguration/tst_qnetworkconfiguration.cpp
index 8746211..6efcfe3 100644
--- a/tests/auto/network/bearer/qnetworkconfiguration/tst_qnetworkconfiguration.cpp
+++ b/tests/auto/network/bearer/qnetworkconfiguration/tst_qnetworkconfiguration.cpp
@@ -52,136 +52,18 @@
 */
 #include <QNetworkAccessManager>
 
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-#include <stdio.h>
-#include <iapconf.h>
-#endif
-
 QT_USE_NAMESPACE
 class tst_QNetworkConfiguration : public QObject
 {
     Q_OBJECT
 
-public slots:
-    void initTestCase();
-    void cleanupTestCase();
-
 private slots:
     void invalidPoint();
     void comparison();
     void children();
     void isRoamingAvailable();
-
-private:
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    Maemo::IAPConf *iapconf;
-    Maemo::IAPConf *iapconf2;
-    Maemo::IAPConf *gprsiap;
-#define MAX_IAPS 50
-    Maemo::IAPConf *iaps[MAX_IAPS];
-    QProcess *icd_stub;
-#endif
 };
 
-void tst_QNetworkConfiguration::initTestCase()
-{
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    iapconf = new Maemo::IAPConf("007");
-    iapconf->setValue("ipv4_type", "AUTO");
-    iapconf->setValue("wlan_wepkey1", "connt");
-    iapconf->setValue("wlan_wepdefkey", 1);
-    iapconf->setValue("wlan_ssid", QByteArray("JamesBond"));
-    iapconf->setValue("name", "James Bond");
-    iapconf->setValue("type", "WLAN_INFRA");
-
-    iapconf2 = new Maemo::IAPConf("osso.net");
-    iapconf2->setValue("ipv4_type", "AUTO");
-    iapconf2->setValue("wlan_wepkey1", "osso.net");
-    iapconf2->setValue("wlan_wepdefkey", 1);
-    iapconf2->setValue("wlan_ssid", QByteArray("osso.net"));
-    iapconf2->setValue("name", "osso.net");
-    iapconf2->setValue("type", "WLAN_INFRA");
-    iapconf2->setValue("wlan_security", "WEP");
-
-    gprsiap = new Maemo::IAPConf("This-is-GPRS-IAP");
-    gprsiap->setValue("ask_password", false);
-    gprsiap->setValue("gprs_accesspointname", "internet");
-    gprsiap->setValue("gprs_password", "");
-    gprsiap->setValue("gprs_username", "");
-    gprsiap->setValue("ipv4_autodns", true);
-    gprsiap->setValue("ipv4_type", "AUTO");
-    gprsiap->setValue("sim_imsi", "244070123456789");
-    gprsiap->setValue("name", "MI6");
-    gprsiap->setValue("type", "GPRS");
-
-    /* Create large number of IAPs in the gconf and see what happens */
-    fflush(stdout);
-    printf("Creating %d IAPS: ", MAX_IAPS);
-    for (int i=0; i<MAX_IAPS; i++) {
-	QString num = QString().sprintf("%d", i);
-	QString iap = "iap-" + num;
-	iaps[i] = new Maemo::IAPConf(iap);
-	iaps[i]->setValue("name", QString("test-iap-")+num);
-	iaps[i]->setValue("type", "WLAN_INFRA");
-	iaps[i]->setValue("wlan_ssid", QString(QString("test-ssid-")+num).toAscii());
-	iaps[i]->setValue("wlan_security", "WPA_PSK");
-	iaps[i]->setValue("EAP_wpa_preshared_passphrase", QString("test-passphrase-")+num);
-	printf(".");
-	fflush(stdout);
-    }
-    printf("\n");
-    fflush(stdout);
-
-    icd_stub = new QProcess(this);
-    icd_stub->start("/usr/bin/icd2_stub.py");
-    QTest::qWait(1000);
-
-    // Add a known network to scan list that icd2 stub returns
-    QProcess dbus_send;
-    // 007 network
-    dbus_send.start("dbus-send --type=method_call --system "
-		    "--dest=com.nokia.icd2 /com/nokia/icd2 "
-		    "com.nokia.icd2.testing.add_available_network "
-		    "string:'' uint32:0 string:'' "
-		    "string:WLAN_INFRA uint32:5000011 array:byte:48,48,55");
-    dbus_send.waitForFinished();
-
-    // osso.net network
-    dbus_send.start("dbus-send --type=method_call --system "
-		    "--dest=com.nokia.icd2 /com/nokia/icd2 "
-		    "com.nokia.icd2.testing.add_available_network "
-		    "string:'' uint32:0 string:'' "
-		    "string:WLAN_INFRA uint32:83886097 array:byte:111,115,115,111,46,110,101,116");
-    dbus_send.waitForFinished();
-#endif
-}
-
-void tst_QNetworkConfiguration::cleanupTestCase()
-{
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    iapconf->clear();
-    delete iapconf;
-    iapconf2->clear();
-    delete iapconf2;
-    gprsiap->clear();
-    delete gprsiap;
-
-    printf("Deleting %d IAPS : ", MAX_IAPS);
-    for (int i=0; i<MAX_IAPS; i++) {
-	iaps[i]->clear();
-	delete iaps[i];
-	printf(".");
-	fflush(stdout);
-    }
-    printf("\n");
-    qDebug() << "Deleted" << MAX_IAPS << "IAPs";
-
-    // Terminate icd2 stub
-    icd_stub->terminate();
-    icd_stub->waitForFinished();
-#endif
-}
-
 void tst_QNetworkConfiguration::invalidPoint()
 {
     QNetworkConfiguration pt;
diff --git a/tests/auto/network/bearer/qnetworkconfigurationmanager/qnetworkconfigurationmanager.pro b/tests/auto/network/bearer/qnetworkconfigurationmanager/qnetworkconfigurationmanager.pro
index e7ff28e..52cee1f 100644
--- a/tests/auto/network/bearer/qnetworkconfigurationmanager/qnetworkconfigurationmanager.pro
+++ b/tests/auto/network/bearer/qnetworkconfigurationmanager/qnetworkconfigurationmanager.pro
@@ -4,9 +4,3 @@ SOURCES  += tst_qnetworkconfigurationmanager.cpp
 HEADERS  += ../qbearertestcommon.h
 
 QT = core network testlib
-
-maemo6|maemo5 {
-    CONFIG += link_pkgconfig
-
-    PKGCONFIG += conninet
-}
diff --git a/tests/auto/network/bearer/qnetworkconfigurationmanager/tst_qnetworkconfigurationmanager.cpp b/tests/auto/network/bearer/qnetworkconfigurationmanager/tst_qnetworkconfigurationmanager.cpp
index ff980ca..77e1616 100644
--- a/tests/auto/network/bearer/qnetworkconfigurationmanager/tst_qnetworkconfigurationmanager.cpp
+++ b/tests/auto/network/bearer/qnetworkconfigurationmanager/tst_qnetworkconfigurationmanager.cpp
@@ -45,146 +45,18 @@
 #include <QtNetwork/qnetworkconfiguration.h>
 #include <QtNetwork/qnetworkconfigmanager.h>
 
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-#include <stdio.h>
-#include <iapconf.h>
-#endif
-
 QT_USE_NAMESPACE
 class tst_QNetworkConfigurationManager : public QObject
 {
     Q_OBJECT
 
-public slots:
-    void initTestCase();
-    void cleanupTestCase();
-    void init();
-    void cleanup();
-
 private slots:
     void usedInThread(); // this test must be first, or it will falsely pass
     void allConfigurations();
     void defaultConfiguration();
     void configurationFromIdentifier();
-
-private:
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    Maemo::IAPConf *iapconf;
-    Maemo::IAPConf *iapconf2;
-    Maemo::IAPConf *gprsiap;
-#define MAX_IAPS 50
-    Maemo::IAPConf *iaps[MAX_IAPS];
-    QProcess *icd_stub;
-#endif
 };
 
-void tst_QNetworkConfigurationManager::initTestCase()
-{
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    iapconf = new Maemo::IAPConf("007");
-    iapconf->setValue("ipv4_type", "AUTO");
-    iapconf->setValue("wlan_wepkey1", "connt");
-    iapconf->setValue("wlan_wepdefkey", 1);
-    iapconf->setValue("wlan_ssid", QByteArray("JamesBond"));
-    iapconf->setValue("name", "James Bond");
-    iapconf->setValue("type", "WLAN_INFRA");
-
-    gprsiap = new Maemo::IAPConf("This-is-GPRS-IAP");
-    gprsiap->setValue("ask_password", false);
-    gprsiap->setValue("gprs_accesspointname", "internet");
-    gprsiap->setValue("gprs_password", "");
-    gprsiap->setValue("gprs_username", "");
-    gprsiap->setValue("ipv4_autodns", true);
-    gprsiap->setValue("ipv4_type", "AUTO");
-    gprsiap->setValue("sim_imsi", "244070123456789");
-    gprsiap->setValue("name", "MI6");
-    gprsiap->setValue("type", "GPRS");
-
-    iapconf2 = new Maemo::IAPConf("osso.net");
-    iapconf2->setValue("ipv4_type", "AUTO");
-    iapconf2->setValue("wlan_wepkey1", "osso.net");
-    iapconf2->setValue("wlan_wepdefkey", 1);
-    iapconf2->setValue("wlan_ssid", QByteArray("osso.net"));
-    iapconf2->setValue("name", "osso.net");
-    iapconf2->setValue("type", "WLAN_INFRA");
-    iapconf2->setValue("wlan_security", "WEP");
-
-    /* Create large number of IAPs in the gconf and see what happens */
-    fflush(stdout);
-    printf("Creating %d IAPS: ", MAX_IAPS);
-    for (int i=0; i<MAX_IAPS; i++) {
-	QString num = QString().sprintf("%d", i);
-	QString iap = "iap-" + num;
-	iaps[i] = new Maemo::IAPConf(iap);
-	iaps[i]->setValue("name", QString("test-iap-")+num);
-	iaps[i]->setValue("type", "WLAN_INFRA");
-	iaps[i]->setValue("wlan_ssid", QString(QString("test-ssid-")+num).toAscii());
-	iaps[i]->setValue("wlan_security", "WPA_PSK");
-	iaps[i]->setValue("EAP_wpa_preshared_passphrase", QString("test-passphrase-")+num);
-	printf(".");
-	fflush(stdout);
-    }
-    printf("\n");
-    fflush(stdout);
-
-    icd_stub = new QProcess(this);
-    icd_stub->start("/usr/bin/icd2_stub.py");
-    QTest::qWait(1000);
-
-    // Add a known network to scan list that icd2 stub returns
-    QProcess dbus_send;
-    // 007 network
-    dbus_send.start("dbus-send --type=method_call --system "
-		    "--dest=com.nokia.icd2 /com/nokia/icd2 "
-		    "com.nokia.icd2.testing.add_available_network "
-		    "string:'' uint32:0 string:'' "
-		    "string:WLAN_INFRA uint32:5000011 array:byte:48,48,55");
-    dbus_send.waitForFinished();
-
-    // osso.net network
-    dbus_send.start("dbus-send --type=method_call --system "
-		    "--dest=com.nokia.icd2 /com/nokia/icd2 "
-		    "com.nokia.icd2.testing.add_available_network "
-		    "string:'' uint32:0 string:'' "
-		    "string:WLAN_INFRA uint32:83886097 array:byte:111,115,115,111,46,110,101,116");
-    dbus_send.waitForFinished();
-#endif
-}
-
-
-void tst_QNetworkConfigurationManager::cleanupTestCase()
-{
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    iapconf->clear();
-    delete iapconf;
-    iapconf2->clear();
-    delete iapconf2;
-    gprsiap->clear();
-    delete gprsiap;
-
-    printf("Deleting %d IAPS : ", MAX_IAPS);
-    for (int i=0; i<MAX_IAPS; i++) {
-	iaps[i]->clear();
-	delete iaps[i];
-	printf(".");
-	fflush(stdout);
-    }
-    printf("\n");
-    qDebug() << "Deleted" << MAX_IAPS << "IAPs";
-
-    icd_stub->terminate();
-    icd_stub->waitForFinished();
-#endif
-}
-
-void tst_QNetworkConfigurationManager::init()
-{
-}
-
-void tst_QNetworkConfigurationManager::cleanup()
-{
-}
-
 void printConfigurationDetails(const QNetworkConfiguration& p)
 {
     qDebug() << p.name() <<":  isvalid->" <<p.isValid() << " type->"<< p.type() << 
diff --git a/tests/auto/network/bearer/qnetworksession/test/test.pro b/tests/auto/network/bearer/qnetworksession/test/test.pro
index ad55a42..5567e35 100644
--- a/tests/auto/network/bearer/qnetworksession/test/test.pro
+++ b/tests/auto/network/bearer/qnetworksession/test/test.pro
@@ -14,9 +14,3 @@ CONFIG(debug_and_release) {
 } else {
   DESTDIR = ..
 }
-
-maemo6|maemo5 {
-    CONFIG += link_pkgconfig
-
-    PKGCONFIG += conninet
-}
diff --git a/tests/auto/network/bearer/qnetworksession/test/tst_qnetworksession.cpp b/tests/auto/network/bearer/qnetworksession/test/tst_qnetworksession.cpp
index 544d378..76fbac3 100644
--- a/tests/auto/network/bearer/qnetworksession/test/tst_qnetworksession.cpp
+++ b/tests/auto/network/bearer/qnetworksession/test/tst_qnetworksession.cpp
@@ -48,18 +48,13 @@
 #include <QtNetwork/qnetworkconfigmanager.h>
 #include <QtNetwork/qnetworksession.h>
 
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-#include <stdio.h>
-#include <iapconf.h>
-#endif
-
 QT_USE_NAMESPACE
 
 // Can be used to configure tests that require manual attention (such as roaming)
 //#define QNETWORKSESSION_MANUAL_TESTS 1
 
 Q_DECLARE_METATYPE(QNetworkConfiguration)
-Q_DECLARE_METATYPE(QNetworkConfiguration::Type);
+Q_DECLARE_METATYPE(QNetworkConfiguration::Type)
 
 class tst_QNetworkSession : public QObject
 {
@@ -97,15 +92,6 @@ private slots:
 private:
     QNetworkConfigurationManager manager;
     int inProcessSessionManagementCount;
-
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    Maemo::IAPConf *iapconf;
-    Maemo::IAPConf *iapconf2;
-    Maemo::IAPConf *gprsiap;
-#define MAX_IAPS 10
-    Maemo::IAPConf *iaps[MAX_IAPS];
-    QProcess *icd_stub;
-#endif
 };
 
 // Helper functions
@@ -120,76 +106,6 @@ void tst_QNetworkSession::initTestCase()
     qRegisterMetaType<QNetworkConfiguration>("QNetworkConfiguration");
     qRegisterMetaType<QNetworkConfiguration::Type>("QNetworkConfiguration::Type");
 
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    iapconf = new Maemo::IAPConf("007");
-    iapconf->setValue("ipv4_type", "AUTO");
-    iapconf->setValue("wlan_wepkey1", "connt");
-    iapconf->setValue("wlan_wepdefkey", 1);
-    iapconf->setValue("wlan_ssid", QByteArray("JamesBond"));
-    iapconf->setValue("name", "James Bond");
-    iapconf->setValue("type", "WLAN_INFRA");
-
-    gprsiap = new Maemo::IAPConf("This-is-GPRS-IAP");
-    gprsiap->setValue("ask_password", false);
-    gprsiap->setValue("gprs_accesspointname", "internet");
-    gprsiap->setValue("gprs_password", "");
-    gprsiap->setValue("gprs_username", "");
-    gprsiap->setValue("ipv4_autodns", true);
-    gprsiap->setValue("ipv4_type", "AUTO");
-    gprsiap->setValue("sim_imsi", "244070123456789");
-    gprsiap->setValue("name", "MI6");
-    gprsiap->setValue("type", "GPRS");
-
-    iapconf2 = new Maemo::IAPConf("osso.net");
-    iapconf2->setValue("ipv4_type", "AUTO");
-    iapconf2->setValue("wlan_wepkey1", "osso.net");
-    iapconf2->setValue("wlan_wepdefkey", 1);
-    iapconf2->setValue("wlan_ssid", QByteArray("osso.net"));
-    iapconf2->setValue("name", "osso.net");
-    iapconf2->setValue("type", "WLAN_INFRA");
-    iapconf2->setValue("wlan_security", "WEP");
-
-    /* Create large number of IAPs in the gconf and see what happens */
-    fflush(stdout);
-    printf("Creating %d IAPS: ", MAX_IAPS);
-    for (int i=0; i<MAX_IAPS; i++) {
-	QString num = QString().sprintf("%d", i);
-	QString iap = "iap-" + num;
-	iaps[i] = new Maemo::IAPConf(iap);
-	iaps[i]->setValue("name", QString("test-iap-")+num);
-	iaps[i]->setValue("type", "WLAN_INFRA");
-	iaps[i]->setValue("wlan_ssid", QString(QString("test-ssid-")+num).toAscii());
-	iaps[i]->setValue("wlan_security", "WPA_PSK");
-	iaps[i]->setValue("EAP_wpa_preshared_passphrase", QString("test-passphrase-")+num);
-	printf(".");
-	fflush(stdout);
-    }
-    printf("\n");
-    fflush(stdout);
-
-    icd_stub = new QProcess(this);
-    icd_stub->start("/usr/bin/icd2_stub.py");
-    QTest::qWait(1000);
-
-    // Add a known network to scan list that icd2 stub returns
-    QProcess dbus_send;
-    // 007 network
-    dbus_send.start("dbus-send --type=method_call --system "
-		    "--dest=com.nokia.icd2 /com/nokia/icd2 "
-		    "com.nokia.icd2.testing.add_available_network "
-		    "string:'' uint32:0 string:'' "
-		    "string:WLAN_INFRA uint32:5000011 array:byte:48,48,55");
-    dbus_send.waitForFinished();
-
-    // osso.net network
-    dbus_send.start("dbus-send --type=method_call --system "
-		    "--dest=com.nokia.icd2 /com/nokia/icd2 "
-		    "com.nokia.icd2.testing.add_available_network "
-		    "string:'' uint32:0 string:'' "
-		    "string:WLAN_INFRA uint32:83886097 array:byte:111,115,115,111,46,110,101,116");
-    dbus_send.waitForFinished();
-#endif
-
     inProcessSessionManagementCount = -1;
 
     QSignalSpy spy(&manager, SIGNAL(updateCompleted()));
@@ -205,28 +121,6 @@ void tst_QNetworkSession::cleanupTestCase()
         qWarning("No usable configurations found to complete all possible tests in "
                  "inProcessSessionManagement()");
     }
-
-#if defined(Q_OS_UNIX) && !defined(QT_NO_ICD)
-    iapconf->clear();
-    delete iapconf;
-    iapconf2->clear();
-    delete iapconf2;
-    gprsiap->clear();
-    delete gprsiap;
-
-    printf("Deleting %d IAPS : ", MAX_IAPS);
-    for (int i=0; i<MAX_IAPS; i++) {
-	iaps[i]->clear();
-	delete iaps[i];
-	printf(".");
-	fflush(stdout);
-    }
-    printf("\n");
-    qDebug() << "Deleted" << MAX_IAPS << "IAPs";
-
-    icd_stub->terminate();
-    icd_stub->waitForFinished();
-#endif
 }
 
 // Robustness test for calling interfaces in nonsense order / with nonsense parameters