diff --git a/src/gui/egl/egl.pri b/src/gui/egl/egl.pri
deleted file mode 100644
index e4a2bbe..0000000
--- a/src/gui/egl/egl.pri
+++ /dev/null
@@ -1,26 +0,0 @@
-contains(QT_CONFIG, egl): {
-	CONFIG += egl
-
-	HEADERS += \
-	    egl/qegl_p.h \
-	    egl/qeglcontext_p.h \
-	    egl/qeglproperties_p.h
-
-        SOURCES += \
-            egl/qegl.cpp \
-            egl/qeglproperties.cpp
-        unix {
-            !isEmpty(QMAKE_INCDIR_EGL){
-                INCLUDEPATH += $$QMAKE_INCDIR_EGL
-            }
-            !isEmpty(QMAKE_LIBDIR_EGL){
-                for(p, QMAKE_LIBDIR_EGL) {
-                    exists($$p):LIBS += -L$$p
-                }
-            }
-
-            !isEmpty(QMAKE_LIBS_EGL): LIBS += $$QMAKE_LIBS_EGL
-        }
-
-        SOURCES += egl/qegl_qpa.cpp
-}
diff --git a/src/gui/egl/qegl.cpp b/src/gui/egl/qegl.cpp
deleted file mode 100644
index 067886c..0000000
--- a/src/gui/egl/qegl.cpp
+++ /dev/null
@@ -1,751 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtGui/qpaintdevice.h>
-#include <QtGui/qpixmap.h>
-#include <QtGui/qwidget.h>
-#include <QtCore/qatomic.h>
-#include <QtCore/qdebug.h>
-
-#include "qegl_p.h"
-#include "qeglcontext_p.h"
-
-
-QT_BEGIN_NAMESPACE
-
-
-/*
-    QEglContextTracker is used to track the EGL contexts that we
-    create internally in Qt, so that we can call eglTerminate() to
-    free additional EGL resources when the last context is destroyed.
-*/
-
-class QEglContextTracker
-{
-public:
-    static void ref() { contexts.ref(); }
-    static void deref() {
-        if (!contexts.deref()) {
-            eglTerminate(QEgl::display());
-            displayOpen = 0;
-        }
-    }
-    static void setDisplayOpened() { displayOpen = 1; }
-    static bool displayOpened() { return displayOpen; }
-
-private:
-    static QBasicAtomicInt contexts;
-    static QBasicAtomicInt displayOpen;
-};
-
-QBasicAtomicInt QEglContextTracker::contexts = Q_BASIC_ATOMIC_INITIALIZER(0);
-QBasicAtomicInt QEglContextTracker::displayOpen = Q_BASIC_ATOMIC_INITIALIZER(0);
-
-// Current GL and VG contexts.  These are used to determine if
-// we can avoid an eglMakeCurrent() after a call to lazyDoneCurrent().
-// If a background thread modifies the value, the worst that will
-// happen is a redundant eglMakeCurrent() in the foreground thread.
-static QEglContext * volatile currentGLContext = 0;
-static QEglContext * volatile currentVGContext = 0;
-
-QEglContext::QEglContext()
-    : apiType(QEgl::OpenGL)
-    , ctx(EGL_NO_CONTEXT)
-    , cfg(QEGL_NO_CONFIG)
-    , currentSurface(EGL_NO_SURFACE)
-    , current(false)
-    , ownsContext(true)
-    , sharing(false)
-{
-    QEglContextTracker::ref();
-}
-
-QEglContext::~QEglContext()
-{
-    destroyContext();
-
-    if (currentGLContext == this)
-        currentGLContext = 0;
-    if (currentVGContext == this)
-        currentVGContext = 0;
-    QEglContextTracker::deref();
-}
-
-bool QEglContext::isValid() const
-{
-    return (ctx != EGL_NO_CONTEXT);
-}
-
-bool QEglContext::isCurrent() const
-{
-    return current;
-}
-
-EGLConfig QEgl::defaultConfig(int devType, API api, ConfigOptions options)
-{
-    if ( (devType != QInternal::Pixmap) && ((options & Renderable) == 0))
-        qWarning("QEgl::defaultConfig() - Only configs for pixmaps make sense to be read-only!");
-
-    EGLConfig* targetConfig = 0;
-
-    static EGLConfig defaultVGConfigs[] = {
-        QEGL_NO_CONFIG, // 0    Window  Renderable  Translucent
-        QEGL_NO_CONFIG, // 1    Window  Renderable  Opaque
-        QEGL_NO_CONFIG, // 2    Pixmap  Renderable  Translucent
-        QEGL_NO_CONFIG, // 3    Pixmap  Renderable  Opaque
-        QEGL_NO_CONFIG, // 4    Pixmap  ReadOnly    Translucent
-        QEGL_NO_CONFIG  // 5    Pixmap  ReadOnly    Opaque
-    };
-    if (api == OpenVG) {
-        if (devType == QInternal::Widget) {
-            if (options & Translucent)
-                targetConfig = &(defaultVGConfigs[0]);
-            else
-                targetConfig = &(defaultVGConfigs[1]);
-        } else if (devType == QInternal::Pixmap) {
-            if (options & Renderable) {
-                if (options & Translucent)
-                    targetConfig = &(defaultVGConfigs[2]);
-                else // Opaque
-                    targetConfig = &(defaultVGConfigs[3]);
-            } else { // Read-only
-                if (options & Translucent)
-                    targetConfig = &(defaultVGConfigs[4]);
-                else // Opaque
-                    targetConfig = &(defaultVGConfigs[5]);
-            }
-        }
-    }
-
-
-    static EGLConfig defaultGLConfigs[] = {
-        QEGL_NO_CONFIG, // 0    Window  Renderable  Translucent
-        QEGL_NO_CONFIG, // 1    Window  Renderable  Opaque
-        QEGL_NO_CONFIG, // 2    PBuffer Renderable  Translucent
-        QEGL_NO_CONFIG, // 3    PBuffer Renderable  Opaque
-        QEGL_NO_CONFIG, // 4    Pixmap  Renderable  Translucent
-        QEGL_NO_CONFIG, // 5    Pixmap  Renderable  Opaque
-        QEGL_NO_CONFIG, // 6    Pixmap  ReadOnly    Translucent
-        QEGL_NO_CONFIG  // 7    Pixmap  ReadOnly    Opaque
-    };
-    if (api == OpenGL) {
-        if (devType == QInternal::Widget) {
-            if (options & Translucent)
-                targetConfig = &(defaultGLConfigs[0]);
-            else // Opaque
-                targetConfig = &(defaultGLConfigs[1]);
-        } else if (devType == QInternal::Pbuffer) {
-            if (options & Translucent)
-                targetConfig = &(defaultGLConfigs[2]);
-            else // Opaque
-                targetConfig = &(defaultGLConfigs[3]);
-        } else if (devType == QInternal::Pixmap) {
-            if (options & Renderable) {
-                if (options & Translucent)
-                    targetConfig = &(defaultGLConfigs[4]);
-                else // Opaque
-                    targetConfig = &(defaultGLConfigs[5]);
-            } else { // ReadOnly
-                if (options & Translucent)
-                    targetConfig = &(defaultGLConfigs[6]);
-                else // Opaque
-                    targetConfig = &(defaultGLConfigs[7]);
-            }
-        }
-    }
-
-    if (!targetConfig) {
-        qWarning("QEgl::defaultConfig() - No default config for device/api/options combo");
-        return QEGL_NO_CONFIG;
-    }
-    if (*targetConfig != QEGL_NO_CONFIG)
-        return *targetConfig;
-
-
-    // We haven't found an EGL config for the target config yet, so do it now:
-
-
-    // Allow overriding from an environment variable:
-    QByteArray configId;
-    if (api == OpenVG)
-        configId = qgetenv("QT_VG_EGL_CONFIG");
-    else
-        configId = qgetenv("QT_GL_EGL_CONFIG");
-    if (!configId.isEmpty()) {
-        // Overridden, so get the EGLConfig for the specified config ID:
-        EGLint properties[] = {
-            EGL_CONFIG_ID, (EGLint)configId.toInt(),
-            EGL_NONE
-        };
-        EGLint configCount = 0;
-        eglChooseConfig(display(), properties, targetConfig, 1, &configCount);
-        if (configCount > 0)
-            return *targetConfig;
-        qWarning() << "QEgl::defaultConfig() -" << configId << "appears to be invalid";
-    }
-
-    QEglProperties configAttribs;
-    configAttribs.setRenderableType(api);
-
-    EGLint surfaceType;
-    switch (devType) {
-        case QInternal::Widget:
-            surfaceType = EGL_WINDOW_BIT;
-            break;
-        case QInternal::Pixmap:
-            surfaceType = EGL_PIXMAP_BIT;
-            break;
-        case QInternal::Pbuffer:
-            surfaceType = EGL_PBUFFER_BIT;
-            break;
-        default:
-            qWarning("QEgl::defaultConfig() - Can't create EGL surface for %d device type", devType);
-            return QEGL_NO_CONFIG;
-    };
-#ifdef EGL_VG_ALPHA_FORMAT_PRE_BIT
-    // For OpenVG, we try to create a surface using a pre-multiplied format if
-    // the surface needs to have an alpha channel:
-    if (api == OpenVG && (options & Translucent))
-        surfaceType |= EGL_VG_ALPHA_FORMAT_PRE_BIT;
-#endif
-    configAttribs.setValue(EGL_SURFACE_TYPE, surfaceType);
-
-#ifdef EGL_BIND_TO_TEXTURE_RGBA
-    if (devType == QInternal::Pixmap || devType == QInternal::Pbuffer) {
-        if (options & Translucent)
-            configAttribs.setValue(EGL_BIND_TO_TEXTURE_RGBA, EGL_TRUE);
-        else
-            configAttribs.setValue(EGL_BIND_TO_TEXTURE_RGB, EGL_TRUE);
-    }
-#endif
-
-    // Add paint engine requirements
-    if (api == OpenVG) {
-#if !defined(QVG_SCISSOR_CLIP) && defined(EGL_ALPHA_MASK_SIZE)
-        configAttribs.setValue(EGL_ALPHA_MASK_SIZE, 1);
-#endif
-    } else {
-        // Both OpenGL paint engines need to have stencil and sample buffers
-        configAttribs.setValue(EGL_STENCIL_SIZE, 1);
-        configAttribs.setValue(EGL_SAMPLE_BUFFERS, 1);
-#ifndef QT_OPENGL_ES_2
-        // Additionally, the GL1 engine likes to have a depth buffer for clipping
-        configAttribs.setValue(EGL_DEPTH_SIZE, 1);
-#endif
-    }
-
-    if (options & Translucent)
-        configAttribs.setValue(EGL_ALPHA_SIZE, 1);
-
-    *targetConfig = chooseConfig(&configAttribs, QEgl::BestPixelFormat);
-    return *targetConfig;
-}
-
-
-// Choose a configuration that matches "properties".
-EGLConfig QEgl::chooseConfig(const QEglProperties* properties, QEgl::PixelFormatMatch match)
-{
-    QEglProperties props(*properties);
-    EGLConfig cfg = QEGL_NO_CONFIG;
-    do {
-        // Get the number of matching configurations for this set of properties.
-        EGLint matching = 0;
-        EGLDisplay dpy = QEgl::display();
-        if (!eglChooseConfig(dpy, props.properties(), 0, 0, &matching) || !matching)
-            continue;
-
-        // If we want the best pixel format, then return the first
-        // matching configuration.
-        if (match == QEgl::BestPixelFormat) {
-            eglChooseConfig(display(), props.properties(), &cfg, 1, &matching);
-            if (matching < 1)
-                continue;
-            return cfg;
-        }
-
-        // Fetch all of the matching configurations and find the
-        // first that matches the pixel format we wanted.
-        EGLint size = matching;
-        EGLConfig *configs = new EGLConfig [size];
-        eglChooseConfig(display(), props.properties(), configs, size, &matching);
-        for (EGLint index = 0; index < size; ++index) {
-            EGLint red, green, blue, alpha;
-            eglGetConfigAttrib(display(), configs[index], EGL_RED_SIZE, &red);
-            eglGetConfigAttrib(display(), configs[index], EGL_GREEN_SIZE, &green);
-            eglGetConfigAttrib(display(), configs[index], EGL_BLUE_SIZE, &blue);
-            eglGetConfigAttrib(display(), configs[index], EGL_ALPHA_SIZE, &alpha);
-            if (red == props.value(EGL_RED_SIZE) &&
-                    green == props.value(EGL_GREEN_SIZE) &&
-                    blue == props.value(EGL_BLUE_SIZE) &&
-                    (props.value(EGL_ALPHA_SIZE) == 0 ||
-                     alpha == props.value(EGL_ALPHA_SIZE))) {
-                cfg = configs[index];
-                delete [] configs;
-                return cfg;
-            }
-        }
-        delete [] configs;
-    } while (props.reduceConfiguration());
-
-#ifdef EGL_BIND_TO_TEXTURE_RGBA
-    // Don't report an error just yet if we failed to get a pbuffer
-    // configuration with texture rendering.  Only report failure if
-    // we cannot get any pbuffer configurations at all.
-    if (props.value(EGL_BIND_TO_TEXTURE_RGBA) == EGL_DONT_CARE &&
-        props.value(EGL_BIND_TO_TEXTURE_RGB) == EGL_DONT_CARE)
-#endif
-    {
-        qWarning() << "QEglContext::chooseConfig(): Could not find a suitable EGL configuration";
-        qWarning() << "Requested:" << props.toString();
-        qWarning() << "Available:";
-        QEgl::dumpAllConfigs();
-    }
-    return QEGL_NO_CONFIG;
-}
-
-bool QEglContext::chooseConfig(const QEglProperties& properties, QEgl::PixelFormatMatch match)
-{
-    cfg = QEgl::chooseConfig(&properties, match);
-    return cfg != QEGL_NO_CONFIG;
-}
-
-EGLSurface QEglContext::createSurface(QPaintDevice* device, const QEglProperties *properties)
-{
-    return QEgl::createSurface(device, cfg, properties);
-}
-
-
-// Create the EGLContext.
-bool QEglContext::createContext(QEglContext *shareContext, const QEglProperties *properties)
-{
-    // We need to select the correct API before calling eglCreateContext().
-#ifdef QT_OPENGL_ES
-#ifdef EGL_OPENGL_ES_API
-    if (apiType == QEgl::OpenGL)
-        eglBindAPI(EGL_OPENGL_ES_API);
-#endif
-#else
-#ifdef EGL_OPENGL_API
-    if (apiType == QEgl::OpenGL)
-        eglBindAPI(EGL_OPENGL_API);
-#endif
-#endif //defined(QT_OPENGL_ES)
-#ifdef EGL_OPENVG_API
-    if (apiType == QEgl::OpenVG)
-        eglBindAPI(EGL_OPENVG_API);
-#endif
-
-    // Create a new context for the configuration.
-    QEglProperties contextProps;
-    if (properties)
-        contextProps = *properties;
-#ifdef QT_OPENGL_ES_2
-    if (apiType == QEgl::OpenGL)
-        contextProps.setValue(EGL_CONTEXT_CLIENT_VERSION, 2);
-#endif
-    sharing = false;
-    if (shareContext && shareContext->ctx == EGL_NO_CONTEXT)
-        shareContext = 0;
-    if (shareContext) {
-        ctx = eglCreateContext(QEgl::display(), cfg, shareContext->ctx, contextProps.properties());
-        if (ctx == EGL_NO_CONTEXT) {
-            qWarning() << "QEglContext::createContext(): Could not share context:" << QEgl::errorString();
-            shareContext = 0;
-        } else {
-            sharing = true;
-        }
-    }
-    if (ctx == EGL_NO_CONTEXT) {
-        ctx = eglCreateContext(display(), cfg, EGL_NO_CONTEXT, contextProps.properties());
-        if (ctx == EGL_NO_CONTEXT) {
-            qWarning() << "QEglContext::createContext(): Unable to create EGL context:" << QEgl::errorString();
-            return false;
-        }
-    }
-    return true;
-}
-
-// Destroy an EGL surface object.  If it was current on this context
-// then call doneCurrent() for it first.
-void QEglContext::destroySurface(EGLSurface surface)
-{
-    if (surface != EGL_NO_SURFACE) {
-        if (surface == currentSurface)
-            doneCurrent();
-        eglDestroySurface(display(), surface);
-    }
-}
-
-// Destroy the context.  Note: this does not destroy the surface.
-void QEglContext::destroyContext()
-{
-    if (ctx != EGL_NO_CONTEXT && ownsContext)
-        eglDestroyContext(display(), ctx);
-    ctx = EGL_NO_CONTEXT;
-    cfg = 0;
-}
-
-bool QEglContext::makeCurrent(EGLSurface surface)
-{
-    if (ctx == EGL_NO_CONTEXT) {
-        qWarning() << "QEglContext::makeCurrent(): Cannot make invalid context current";
-        return false;
-    }
-
-    if (surface == EGL_NO_SURFACE) {
-        qWarning() << "QEglContext::makeCurrent(): Cannot make invalid surface current";
-        return false;
-    }
-
-    // If lazyDoneCurrent() was called on the surface, then we may be able
-    // to assume that it is still current within the thread.
-    if (surface == currentSurface && currentContext(apiType) == this) {
-        current = true;
-        return true;
-    }
-
-    current = true;
-    currentSurface = surface;
-    setCurrentContext(apiType, this);
-
-    // Force the right API to be bound before making the context current.
-    // The EGL implementation should be able to figure this out from ctx,
-    // but some systems require the API to be explicitly set anyway.
-#ifdef EGL_OPENGL_ES_API
-    if (apiType == QEgl::OpenGL)
-        eglBindAPI(EGL_OPENGL_ES_API);
-#endif
-#ifdef EGL_OPENVG_API
-    if (apiType == QEgl::OpenVG)
-        eglBindAPI(EGL_OPENVG_API);
-#endif
-
-    bool ok = eglMakeCurrent(QEgl::display(), surface, surface, ctx);
-    if (!ok)
-        qWarning() << "QEglContext::makeCurrent(" << surface << "):" << QEgl::errorString();
-    return ok;
-}
-
-bool QEglContext::doneCurrent()
-{
-    // If the context is invalid, we assume that an error was reported
-    // when makeCurrent() was called.
-    if (ctx == EGL_NO_CONTEXT)
-        return false;
-
-    current = false;
-    currentSurface = EGL_NO_SURFACE;
-    setCurrentContext(apiType, 0);
-
-    // We need to select the correct API before calling eglMakeCurrent()
-    // with EGL_NO_CONTEXT because threads can have both OpenGL and OpenVG
-    // contexts active at the same time.
-#ifdef EGL_OPENGL_ES_API
-    if (apiType == QEgl::OpenGL)
-        eglBindAPI(EGL_OPENGL_ES_API);
-#endif
-#ifdef EGL_OPENVG_API
-    if (apiType == QEgl::OpenVG)
-        eglBindAPI(EGL_OPENVG_API);
-#endif
-
-    bool ok = eglMakeCurrent(QEgl::display(), EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
-    if (!ok)
-        qWarning() << "QEglContext::doneCurrent():" << QEgl::errorString();
-    return ok;
-}
-
-// Act as though doneCurrent() was called, but keep the context
-// and the surface active for the moment.  This allows makeCurrent()
-// to skip a call to eglMakeCurrent() if we are using the same
-// surface as the last set of painting operations.  We leave the
-// currentContext() pointer as-is for now.
-bool QEglContext::lazyDoneCurrent()
-{
-    current = false;
-    return true;
-}
-
-bool QEglContext::swapBuffers(EGLSurface surface)
-{
-    if(ctx == EGL_NO_CONTEXT)
-        return false;
-
-    bool ok = eglSwapBuffers(QEgl::display(), surface);
-    if (!ok)
-        qWarning() << "QEglContext::swapBuffers():" << QEgl::errorString();
-    return ok;
-}
-
-bool QEglContext::swapBuffersRegion2NOK(EGLSurface surface, const QRegion *region) {
-    QVector<QRect> qrects = region->rects();
-    EGLint *gl_rects;
-    uint count;
-    uint i;
-
-    count = qrects.size();
-    QVarLengthArray <EGLint> arr(4 * count);
-    gl_rects = arr.data();
-    for (i = 0; i < count; i++) {
-      QRect qrect = qrects[i];
-
-      gl_rects[4 * i + 0] = qrect.x();
-      gl_rects[4 * i + 1] = qrect.y();
-      gl_rects[4 * i + 2] = qrect.width();
-      gl_rects[4 * i + 3] = qrect.height();
-    }
-
-    bool ok = QEgl::eglSwapBuffersRegion2NOK(QEgl::display(), surface, count, gl_rects);
-
-    if (!ok)
-        qWarning() << "QEglContext::swapBuffersRegion2NOK():" << QEgl::errorString();
-    return ok;
-}
-
-int QEglContext::configAttrib(int name) const
-{
-    EGLint value;
-    EGLBoolean success = eglGetConfigAttrib(QEgl::display(), cfg, name, &value);
-    if (success)
-        return value;
-    else
-        return EGL_DONT_CARE;
-}
-
-typedef EGLImageKHR (EGLAPIENTRY *_eglCreateImageKHR)(EGLDisplay, EGLContext, EGLenum, EGLClientBuffer, const EGLint*);
-typedef EGLBoolean (EGLAPIENTRY *_eglDestroyImageKHR)(EGLDisplay, EGLImageKHR);
-
-// Defined in qegl.cpp:
-static _eglCreateImageKHR qt_eglCreateImageKHR = 0;
-static _eglDestroyImageKHR qt_eglDestroyImageKHR = 0;
-
-typedef EGLBoolean (EGLAPIENTRY *_eglSwapBuffersRegion2NOK)(EGLDisplay, EGLSurface, EGLint, const EGLint*);
-
-static _eglSwapBuffersRegion2NOK qt_eglSwapBuffersRegion2NOK = 0;
-
-EGLDisplay QEgl::display()
-{
-    static EGLDisplay dpy = EGL_NO_DISPLAY;
-    if (!QEglContextTracker::displayOpened()) {
-        dpy = eglGetDisplay(nativeDisplay());
-        QEglContextTracker::setDisplayOpened();
-        if (dpy == EGL_NO_DISPLAY) {
-            qWarning("QEgl::display(): Falling back to EGL_DEFAULT_DISPLAY");
-            dpy = eglGetDisplay(EGLNativeDisplayType(EGL_DEFAULT_DISPLAY));
-        }
-        if (dpy == EGL_NO_DISPLAY) {
-            qWarning("QEgl::display(): Can't even open the default display");
-            return EGL_NO_DISPLAY;
-        }
-
-        if (!eglInitialize(dpy, NULL, NULL)) {
-            qWarning() << "QEgl::display(): Cannot initialize EGL display:" << QEgl::errorString();
-            return EGL_NO_DISPLAY;
-        }
-
-        // Resolve the egl extension function pointers:
-#if (defined(EGL_KHR_image) || defined(EGL_KHR_image_base)) && !defined(EGL_EGLEXT_PROTOTYPES)
-        if (QEgl::hasExtension("EGL_KHR_image") || QEgl::hasExtension("EGL_KHR_image_base")) {
-            qt_eglCreateImageKHR = (_eglCreateImageKHR) eglGetProcAddress("eglCreateImageKHR");
-            qt_eglDestroyImageKHR = (_eglDestroyImageKHR) eglGetProcAddress("eglDestroyImageKHR");
-        }
-#endif
-
-        if (QEgl::hasExtension("EGL_NOK_swap_region2")) {
-            qt_eglSwapBuffersRegion2NOK = (_eglSwapBuffersRegion2NOK) eglGetProcAddress("eglSwapBuffersRegion2NOK");
-        }
-    }
-
-    return dpy;
-}
-
-EGLImageKHR QEgl::eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list)
-{
-    if (qt_eglCreateImageKHR)
-        return qt_eglCreateImageKHR(dpy, ctx, target, buffer, attrib_list);
-
-    QEgl::display(); // Initialises function pointers
-    if (qt_eglCreateImageKHR)
-        return qt_eglCreateImageKHR(dpy, ctx, target, buffer, attrib_list);
-
-    qWarning("QEgl::eglCreateImageKHR() called but EGL_KHR_image(_base) extension not present");
-    return 0;
-}
-
-EGLBoolean QEgl::eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img)
-{
-    if (qt_eglDestroyImageKHR)
-        return qt_eglDestroyImageKHR(dpy, img);
-
-    QEgl::display(); // Initialises function pointers
-    if (qt_eglDestroyImageKHR)
-        return qt_eglDestroyImageKHR(dpy, img);
-
-    qWarning("QEgl::eglDestroyImageKHR() called but EGL_KHR_image(_base) extension not present");
-    return 0;
-}
-
-EGLBoolean QEgl::eglSwapBuffersRegion2NOK(EGLDisplay dpy, EGLSurface surface, EGLint count, const EGLint *rects)
-{
-    if (qt_eglSwapBuffersRegion2NOK)
-        return qt_eglSwapBuffersRegion2NOK(dpy, surface, count, rects);
-
-    QEgl::display(); // Initialises function pointers
-    if (qt_eglSwapBuffersRegion2NOK)
-        return qt_eglSwapBuffersRegion2NOK(dpy, surface, count, rects);
-
-    qWarning("QEgl::eglSwapBuffersRegion2NOK() called but EGL_NOK_swap_region2 extension not present");
-    return 0;
-}
-
-EGLSurface QEgl::createSurface(QPaintDevice *device, EGLConfig cfg, const QEglProperties *properties)
-{
-    // Create the native drawable for the paint device.
-    int devType = device->devType();
-    EGLNativePixmapType pixmapDrawable = 0;
-    EGLNativeWindowType windowDrawable = 0;
-    bool ok;
-    if (devType == QInternal::Pixmap) {
-        pixmapDrawable = nativePixmap(static_cast<QPixmap *>(device));
-        ok = (pixmapDrawable != 0);
-    } else if (devType == QInternal::Widget) {
-        windowDrawable = nativeWindow(static_cast<QWidget *>(device));
-        ok = (windowDrawable != 0);
-    } else {
-        ok = false;
-    }
-    if (!ok) {
-        qWarning("QEglContext::createSurface(): Cannot create the native EGL drawable");
-        return EGL_NO_SURFACE;
-    }
-
-    // Create the EGL surface to draw into, based on the native drawable.
-    const int *props;
-    if (properties)
-        props = properties->properties();
-    else
-        props = 0;
-    EGLSurface surf;
-    if (devType == QInternal::Widget)
-        surf = eglCreateWindowSurface(QEgl::display(), cfg, windowDrawable, props);
-    else
-        surf = eglCreatePixmapSurface(QEgl::display(), cfg, pixmapDrawable, props);
-    if (surf == EGL_NO_SURFACE) {
-        qWarning("QEglContext::createSurface(): Unable to create EGL surface, error = 0x%x", eglGetError());
-    }
-    return surf;
-}
-
-
-// Return the error string associated with a specific code.
-QString QEgl::errorString(EGLint code)
-{
-    static const char * const errors[] = {
-        "Success (0x3000)",                 // No tr
-        "Not initialized (0x3001)",         // No tr
-        "Bad access (0x3002)",              // No tr
-        "Bad alloc (0x3003)",               // No tr
-        "Bad attribute (0x3004)",           // No tr
-        "Bad config (0x3005)",              // No tr
-        "Bad context (0x3006)",             // No tr
-        "Bad current surface (0x3007)",     // No tr
-        "Bad display (0x3008)",             // No tr
-        "Bad match (0x3009)",               // No tr
-        "Bad native pixmap (0x300A)",       // No tr
-        "Bad native window (0x300B)",       // No tr
-        "Bad parameter (0x300C)",           // No tr
-        "Bad surface (0x300D)",             // No tr
-        "Context lost (0x300E)"             // No tr
-    };
-    if (code >= 0x3000 && code <= 0x300E) {
-        return QString::fromLatin1(errors[code - 0x3000]);
-    } else {
-        return QLatin1String("0x") + QString::number(int(code), 16);
-    }
-}
-
-// Dump all of the EGL configurations supported by the system.
-void QEgl::dumpAllConfigs()
-{
-    QEglProperties props;
-    EGLint count = 0;
-    if (!eglGetConfigs(display(), 0, 0, &count) || count < 1)
-        return;
-    EGLConfig *configs = new EGLConfig [count];
-    eglGetConfigs(display(), configs, count, &count);
-    for (EGLint index = 0; index < count; ++index) {
-        props = QEglProperties(configs[index]);
-        qWarning() << props.toString();
-    }
-    delete [] configs;
-}
-
-QString QEgl::extensions()
-{
-    const char* exts = eglQueryString(QEgl::display(), EGL_EXTENSIONS);
-    return QString(QLatin1String(exts));
-}
-
-bool QEgl::hasExtension(const char* extensionName)
-{
-    QList<QByteArray> extensions =
-        QByteArray(reinterpret_cast<const char *>
-            (eglQueryString(QEgl::display(), EGL_EXTENSIONS))).split(' ');
-    return extensions.contains(extensionName);
-}
-
-QEglContext *QEglContext::currentContext(QEgl::API api)
-{
-    if (api == QEgl::OpenGL)
-        return currentGLContext;
-    else
-        return currentVGContext;
-}
-
-void QEglContext::setCurrentContext(QEgl::API api, QEglContext *context)
-{
-    if (api == QEgl::OpenGL)
-        currentGLContext = context;
-    else
-        currentVGContext = context;
-}
-
-QT_END_NAMESPACE
diff --git a/src/gui/egl/qegl_p.h b/src/gui/egl/qegl_p.h
deleted file mode 100644
index 3e78b97..0000000
--- a/src/gui/egl/qegl_p.h
+++ /dev/null
@@ -1,191 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QEGL_P_H
-#define QEGL_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience of
-// the QtGui and QtOpenVG modules.  This header file may change from
-// version to version without notice, or even be removed.
-//
-// We mean it.
-//
-
-QT_BEGIN_INCLUDE_NAMESPACE
-
-#ifndef QT_NO_EGL
-#if defined(QT_OPENGL_ES_2)
-#   include <GLES2/gl2.h>
-#endif
-
-#if defined(QT_GLES_EGL)
-#   include <GLES/egl.h>
-#else
-#   include <EGL/egl.h>
-#endif
-#if !defined(EGL_VERSION_1_2)
-typedef unsigned int EGLenum;
-typedef void *EGLClientBuffer;
-#endif
-#else
-
-//types from egltypes.h for compiling stub without EGL headers
-typedef int EGLBoolean;
-typedef int EGLint;
-typedef int EGLenum;
-typedef int    NativeDisplayType;
-typedef void*  NativeWindowType;
-typedef void*  NativePixmapType;
-typedef int EGLDisplay;
-typedef int EGLConfig;
-typedef int EGLSurface;
-typedef int EGLContext;
-typedef int EGLClientBuffer;
-#define EGL_NONE            0x3038  /* Attrib list terminator */
-
-#endif
-
-
-// Internally we use the EGL-prefixed native types which are used in EGL >= 1.3.
-// For older versions of EGL, we have to define these types ourselves here:
-#if !defined(EGL_VERSION_1_3) && !defined(QEGL_NATIVE_TYPES_DEFINED)
-#undef EGLNativeWindowType
-#undef EGLNativePixmapType
-#undef EGLNativeDisplayType
-typedef NativeWindowType EGLNativeWindowType;
-typedef NativePixmapType EGLNativePixmapType;
-typedef NativeDisplayType EGLNativeDisplayType;
-#define QEGL_NATIVE_TYPES_DEFINED 1
-#endif
-
-QT_END_INCLUDE_NAMESPACE
-
-#include <QtGui/qpaintdevice.h>
-#include <QFlags>
-
-QT_BEGIN_NAMESPACE
-
-#define QEGL_NO_CONFIG ((EGLConfig)-1)
-
-#ifndef EGLAPIENTRY
-#define EGLAPIENTRY
-#endif
-
-// Declare/define the bits of EGL_KHR_image_base we need:
-#if !defined(EGL_KHR_image) && !defined(EGL_KHR_image_base)
-typedef void *EGLImageKHR;
-
-#define EGL_NO_IMAGE_KHR            ((EGLImageKHR)0)
-#define EGL_IMAGE_PRESERVED_KHR     0x30D2
-#define EGL_KHR_image_base
-#endif
-
-#if !defined(EGL_KHR_image) && !defined(EGL_KHR_image_pixmap)
-#define EGL_NATIVE_PIXMAP_KHR       0x30B0
-#define EGL_KHR_image_pixmap
-#endif
-
-
-class QEglProperties;
-
-namespace QEgl {
-    enum API
-    {
-        OpenGL,
-        OpenVG
-    };
-
-    enum PixelFormatMatch
-    {
-        ExactPixelFormat,
-        BestPixelFormat
-    };
-
-    enum ConfigOption
-    {
-        NoOptions   = 0,
-        Translucent = 0x01,
-        Renderable  = 0x02  // Config will be compatable with the paint engines (VG or GL)
-    };
-    Q_DECLARE_FLAGS(ConfigOptions, ConfigOption)
-
-    // Most of the time we use the same config for things like widgets & pixmaps, so rather than
-    // go through the eglChooseConfig loop every time, we use defaultConfig, which will return
-    // the config for a particular device/api/option combo. This function assumes that once a
-    // config is chosen for a particular combo, it's safe to always use that combo.
-    Q_GUI_EXPORT EGLConfig  defaultConfig(int devType, API api, ConfigOptions options);
-
-    Q_GUI_EXPORT EGLConfig  chooseConfig(const QEglProperties* configAttribs, QEgl::PixelFormatMatch match = QEgl::ExactPixelFormat);
-    Q_GUI_EXPORT EGLSurface createSurface(QPaintDevice *device, EGLConfig cfg, const QEglProperties *surfaceAttribs = 0);
-
-    Q_GUI_EXPORT void dumpAllConfigs();
-
-#ifdef QT_NO_EGL
-    Q_GUI_EXPORT QString errorString(EGLint code = 0);
-#else
-    Q_GUI_EXPORT QString errorString(EGLint code = eglGetError());
-#endif
-
-    Q_GUI_EXPORT QString extensions();
-    Q_GUI_EXPORT bool hasExtension(const char* extensionName);
-
-    Q_GUI_EXPORT EGLDisplay display();
-
-    Q_GUI_EXPORT EGLNativeDisplayType nativeDisplay();
-    Q_GUI_EXPORT EGLNativeWindowType  nativeWindow(QWidget*);
-    Q_GUI_EXPORT EGLNativePixmapType  nativePixmap(QPixmap*);
-
-    // Extension functions
-    Q_GUI_EXPORT EGLImageKHR eglCreateImageKHR(EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint *attrib_list);
-    Q_GUI_EXPORT EGLBoolean  eglDestroyImageKHR(EGLDisplay dpy, EGLImageKHR img);
-    Q_GUI_EXPORT EGLBoolean eglSwapBuffersRegion2NOK(EGLDisplay dpy, EGLSurface surface, EGLint count, const EGLint *rects);
-
-}
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(QEgl::ConfigOptions)
-
-QT_END_NAMESPACE
-
-#endif //QEGL_P_H
diff --git a/src/gui/egl/qegl_qpa.cpp b/src/gui/egl/qegl_qpa.cpp
deleted file mode 100644
index a0a16a5..0000000
--- a/src/gui/egl/qegl_qpa.cpp
+++ /dev/null
@@ -1,110 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtGui/qpaintdevice.h>
-#include <QtGui/qpixmap.h>
-#include <QtGui/qwidget.h>
-#include "qeglcontext_p.h"
-
-#if !defined(QT_NO_EGL)
-
-#include <QtGui/private/qapplication_p.h>
-#include <QtGui/qdesktopwidget.h>
-
-QT_BEGIN_NAMESPACE
-
-EGLNativeDisplayType QEgl::nativeDisplay()
-{
-    return EGLNativeDisplayType(EGL_DEFAULT_DISPLAY);
-}
-
-EGLNativeWindowType QEgl::nativeWindow(QWidget* widget)
-{
-    return (EGLNativeWindowType)(widget->winId());
-}
-
-EGLNativePixmapType QEgl::nativePixmap(QPixmap* pixmap)
-{
-    Q_UNUSED(pixmap);
-    return 0;
-}
-
-//EGLDisplay QEglContext::display()
-//{
-//    return eglGetDisplay(EGLNativeDisplayType(EGL_DEFAULT_DISPLAY));
-//}
-
-static QPlatformScreen *screenForDevice(QPaintDevice *device)
-{
-    QPlatformIntegration *pi = QGuiApplicationPrivate::platformIntegration();
-
-    QList<QPlatformScreen *> screens = pi->screens();
-
-    int screenNumber;
-    if (device && device->devType() == QInternal::Widget)
-        screenNumber = qApp->desktop()->screenNumber(static_cast<QWidget *>(device));
-    else
-        screenNumber = 0;
-    if (screenNumber < 0 || screenNumber >= screens.size())
-        return 0;
-    return screens[screenNumber];
-}
-
-// Set pixel format and other properties based on a paint device.
-void QEglProperties::setPaintDeviceFormat(QPaintDevice *dev)
-{
-    if (!dev)
-        return;
-
-    // Find the QOpenGLScreen for this paint device.
-    QPlatformScreen *screen = screenForDevice(dev);
-    if (!screen)
-        return;
-    int devType = dev->devType();
-    if (devType == QInternal::Image)
-        setPixelFormat(static_cast<QImage *>(dev)->format());
-    else
-        setPixelFormat(screen->format());
-}
-
-QT_END_NAMESPACE
-
-#endif // !QT_NO_EGL
diff --git a/src/gui/egl/qeglcontext_p.h b/src/gui/egl/qeglcontext_p.h
deleted file mode 100644
index 94654eb..0000000
--- a/src/gui/egl/qeglcontext_p.h
+++ /dev/null
@@ -1,117 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QEGLCONTEXT_P_H
-#define QEGLCONTEXT_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience of
-// the QtGui and QtOpenVG modules.  This header file may change from
-// version to version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qsize.h>
-#include <QtGui/qimage.h>
-
-#include <QtGui/private/qegl_p.h>
-#include <QtGui/private/qeglproperties_p.h>
-
-QT_BEGIN_NAMESPACE
-
-class Q_GUI_EXPORT QEglContext
-{
-public:
-    QEglContext();
-    ~QEglContext();
-
-    bool isValid() const;
-    bool isCurrent() const;
-    bool isSharing() const { return sharing; }
-
-    QEgl::API api() const { return apiType; }
-    void setApi(QEgl::API api) { apiType = api; }
-
-    bool chooseConfig(const QEglProperties& properties, QEgl::PixelFormatMatch match = QEgl::ExactPixelFormat);
-    bool createContext(QEglContext *shareContext = 0, const QEglProperties *properties = 0);
-    void destroyContext();
-    EGLSurface createSurface(QPaintDevice *device, const QEglProperties *properties = 0);
-    void destroySurface(EGLSurface surface);
-
-    bool makeCurrent(EGLSurface surface);
-    bool doneCurrent();
-    bool lazyDoneCurrent();
-    bool swapBuffers(EGLSurface surface);
-    bool swapBuffersRegion2NOK(EGLSurface surface, const QRegion *region);
-
-    int  configAttrib(int name) const;
-
-    EGLContext context() const { return ctx; }
-    void setContext(EGLContext context) { ctx = context; ownsContext = false;}
-
-    EGLDisplay display() {return QEgl::display();}
-
-    EGLConfig config() const { return cfg; }
-    void setConfig(EGLConfig config) { cfg = config; }
-
-private:
-    QEgl::API apiType;
-    EGLContext ctx;
-    EGLConfig cfg;
-    EGLSurface currentSurface;
-    bool current;
-    bool ownsContext;
-    bool sharing;
-
-    static QEglContext *currentContext(QEgl::API api);
-    static void setCurrentContext(QEgl::API api, QEglContext *context);
-
-    friend class QMeeGoGraphicsSystem;
-    friend class QMeeGoPlatformPixmap;
-};
-
-QT_END_NAMESPACE
-
-#endif // QEGLCONTEXT_P_H
diff --git a/src/gui/egl/qeglproperties.cpp b/src/gui/egl/qeglproperties.cpp
deleted file mode 100644
index 414ad8d..0000000
--- a/src/gui/egl/qeglproperties.cpp
+++ /dev/null
@@ -1,563 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QtCore/qdebug.h>
-#include <QtCore/qstringlist.h>
-
-#include "qeglproperties_p.h"
-#include "qeglcontext_p.h"
-
-QT_BEGIN_NAMESPACE
-
-// Initialize a property block.
-QEglProperties::QEglProperties()
-{
-    props.append(EGL_NONE);
-}
-
-QEglProperties::QEglProperties(EGLConfig cfg)
-{
-    props.append(EGL_NONE);
-    for (int name = 0x3020; name <= 0x304F; ++name) {
-        EGLint value;
-        if (name != EGL_NONE && eglGetConfigAttrib(QEgl::display(), cfg, name, &value))
-            setValue(name, value);
-    }
-    eglGetError();  // Clear the error state.
-}
-
-// Fetch the current value associated with a property.
-int QEglProperties::value(int name) const
-{
-    for (int index = 0; index < (props.size() - 1); index += 2) {
-        if (props[index] == name)
-            return props[index + 1];
-    }
-
-    // If the attribute has not been explicitly set, return the EGL default
-    // The following defaults were taken from the EGL 1.4 spec:
-    switch(name) {
-    case EGL_BUFFER_SIZE: return 0;
-    case EGL_RED_SIZE: return 0;
-    case EGL_GREEN_SIZE: return 0;
-    case EGL_BLUE_SIZE: return 0;
-    case EGL_ALPHA_SIZE: return 0;
-#ifdef EGL_LUMINANCE_SIZE
-    case EGL_LUMINANCE_SIZE: return 0;
-#endif
-#ifdef EGL_ALPHA_MASK_SIZE
-    case EGL_ALPHA_MASK_SIZE: return 0;
-#endif
-#ifdef EGL_BIND_TO_TEXTURE_RGB
-    case EGL_BIND_TO_TEXTURE_RGB: return EGL_DONT_CARE;
-#endif
-#ifdef EGL_BIND_TO_TEXTURE_RGBA
-    case EGL_BIND_TO_TEXTURE_RGBA: return EGL_DONT_CARE;
-#endif
-#ifdef EGL_COLOR_BUFFER_TYPE
-    case EGL_COLOR_BUFFER_TYPE: return EGL_RGB_BUFFER;
-#endif
-    case EGL_CONFIG_CAVEAT: return EGL_DONT_CARE;
-    case EGL_CONFIG_ID: return EGL_DONT_CARE;
-    case EGL_DEPTH_SIZE: return 0;
-    case EGL_LEVEL: return 0;
-    case EGL_NATIVE_RENDERABLE: return EGL_DONT_CARE;
-    case EGL_NATIVE_VISUAL_TYPE: return EGL_DONT_CARE;
-    case EGL_MAX_SWAP_INTERVAL: return EGL_DONT_CARE;
-    case EGL_MIN_SWAP_INTERVAL: return EGL_DONT_CARE;
-#ifdef EGL_RENDERABLE_TYPE
-    case EGL_RENDERABLE_TYPE: return EGL_OPENGL_ES_BIT;
-#endif
-    case EGL_SAMPLE_BUFFERS: return 0;
-    case EGL_SAMPLES: return 0;
-    case EGL_STENCIL_SIZE: return 0;
-    case EGL_SURFACE_TYPE: return EGL_WINDOW_BIT;
-    case EGL_TRANSPARENT_TYPE: return EGL_NONE;
-    case EGL_TRANSPARENT_RED_VALUE: return EGL_DONT_CARE;
-    case EGL_TRANSPARENT_GREEN_VALUE: return EGL_DONT_CARE;
-    case EGL_TRANSPARENT_BLUE_VALUE: return EGL_DONT_CARE;
-
-#ifdef EGL_VERSION_1_3
-    case EGL_CONFORMANT: return 0;
-    case EGL_MATCH_NATIVE_PIXMAP: return EGL_NONE;
-#endif
-
-    case EGL_MAX_PBUFFER_HEIGHT:
-    case EGL_MAX_PBUFFER_WIDTH:
-    case EGL_MAX_PBUFFER_PIXELS:
-    case EGL_NATIVE_VISUAL_ID:
-    case EGL_NONE:
-        // Attribute does not affect config selection.
-        return EGL_DONT_CARE;
-    default:
-        // Attribute is unknown in EGL <= 1.4.
-        return EGL_DONT_CARE;
-    }
-}
-
-// Set the value associated with a property, replacing an existing
-// value if there is one.
-void QEglProperties::setValue(int name, int value)
-{
-    for (int index = 0; index < (props.size() - 1); index += 2) {
-        if (props[index] == name) {
-            props[index + 1] = value;
-            return;
-        }
-    }
-    props[props.size() - 1] = name;
-    props.append(value);
-    props.append(EGL_NONE);
-}
-
-// Remove a property value.  Returns false if the property is not present.
-bool QEglProperties::removeValue(int name)
-{
-    for (int index = 0; index < (props.size() - 1); index += 2) {
-        if (props[index] == name) {
-            while ((index + 2) < props.size()) {
-                props[index] = props[index + 2];
-                ++index;
-            }
-            props.resize(props.size() - 2);
-            return true;
-        }
-    }
-    return false;
-}
-
-void QEglProperties::setDeviceType(int devType)
-{
-    if (devType == QInternal::Pixmap || devType == QInternal::Image)
-        setValue(EGL_SURFACE_TYPE, EGL_PIXMAP_BIT);
-    else if (devType == QInternal::Pbuffer)
-        setValue(EGL_SURFACE_TYPE, EGL_PBUFFER_BIT);
-    else
-        setValue(EGL_SURFACE_TYPE, EGL_WINDOW_BIT);
-}
-
-
-// Sets the red, green, blue, and alpha sizes based on a pixel format.
-// Normally used to match a configuration request to the screen format.
-void QEglProperties::setPixelFormat(QImage::Format pixelFormat)
-{
-    int red, green, blue, alpha;
-    switch (pixelFormat) {
-        case QImage::Format_RGB32:
-        case QImage::Format_RGB888:
-            red = green = blue = 8; alpha = 0; break;
-        case QImage::Format_ARGB32:
-        case QImage::Format_ARGB32_Premultiplied:
-            red = green = blue = alpha = 8; break;
-        case QImage::Format_RGB16:
-            red = 5; green = 6; blue = 5; alpha = 0; break;
-        case QImage::Format_ARGB8565_Premultiplied:
-            red = 5; green = 6; blue = 5; alpha = 8; break;
-        case QImage::Format_RGB666:
-            red = green = blue = 6; alpha = 0; break;
-        case QImage::Format_ARGB6666_Premultiplied:
-            red = green = blue = alpha = 6; break;
-        case QImage::Format_RGB555:
-            red = green = blue = 5; alpha = 0; break;
-        case QImage::Format_ARGB8555_Premultiplied:
-            red = green = blue = 5; alpha = 8; break;
-        case QImage::Format_RGB444:
-            red = green = blue = 4; alpha = 0; break;
-        case QImage::Format_ARGB4444_Premultiplied:
-            red = green = blue = alpha = 4; break;
-        default:
-            qWarning() << "QEglProperties::setPixelFormat(): Unsupported pixel format";
-            red = green = blue = alpha = 1; break;
-    }
-    setValue(EGL_RED_SIZE, red);
-    setValue(EGL_GREEN_SIZE, green);
-    setValue(EGL_BLUE_SIZE, blue);
-    setValue(EGL_ALPHA_SIZE, alpha);
-}
-
-void QEglProperties::setRenderableType(QEgl::API api)
-{
-#ifdef EGL_RENDERABLE_TYPE
-#if defined(QT_OPENGL_ES_2)
-    if (api == QEgl::OpenGL)
-        setValue(EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT);
-#elif defined(QT_OPENGL_ES)
-    if (api == QEgl::OpenGL)
-        setValue(EGL_RENDERABLE_TYPE, EGL_OPENGL_ES_BIT);
-#elif defined(EGL_OPENGL_BIT)
-    if (api == QEgl::OpenGL)
-        setValue(EGL_RENDERABLE_TYPE, EGL_OPENGL_BIT);
-#endif
-#ifdef EGL_OPENVG_BIT
-    if (api == QEgl::OpenVG)
-        setValue(EGL_RENDERABLE_TYPE, EGL_OPENVG_BIT);
-#endif
-#else
-    Q_UNUSED(api);
-#endif
-}
-
-// Reduce the complexity of a configuration request to ask for less
-// because the previous request did not result in success.  Returns
-// true if the complexity was reduced, or false if no further
-// reductions in complexity are possible.
-bool QEglProperties::reduceConfiguration()
-{
-#ifdef EGL_SWAP_BEHAVIOR
-    if (value(EGL_SWAP_BEHAVIOR) != EGL_DONT_CARE)
-        removeValue(EGL_SWAP_BEHAVIOR);
-#endif
-
-#ifdef EGL_VG_ALPHA_FORMAT_PRE_BIT
-    // For OpenVG, we sometimes try to create a surface using a pre-multiplied format. If we can't
-    // find a config which supports pre-multiplied formats, remove the flag on the surface type:
-    EGLint surfaceType = value(EGL_SURFACE_TYPE);
-    if (surfaceType & EGL_VG_ALPHA_FORMAT_PRE_BIT) {
-        surfaceType ^= EGL_VG_ALPHA_FORMAT_PRE_BIT;
-        setValue(EGL_SURFACE_TYPE, surfaceType);
-        return true;
-    }
-#endif
-    // EGL chooses configs with the highest color depth over
-    // those with smaller (but faster) lower color depths. One
-    // way around this is to set EGL_BUFFER_SIZE to 16, which
-    // trumps the others. Of course, there may not be a 16-bit
-    // config available, so it's the first restraint we remove.
-    if (value(EGL_BUFFER_SIZE) == 16) {
-        removeValue(EGL_BUFFER_SIZE);
-        return true;
-    }
-    if (removeValue(EGL_SAMPLE_BUFFERS)) {
-        removeValue(EGL_SAMPLES);
-        return true;
-    }
-    if (removeValue(EGL_ALPHA_SIZE)) {
-#if defined(EGL_BIND_TO_TEXTURE_RGBA) && defined(EGL_BIND_TO_TEXTURE_RGB)
-        if (removeValue(EGL_BIND_TO_TEXTURE_RGBA))
-            setValue(EGL_BIND_TO_TEXTURE_RGB, TRUE);
-#endif
-        return true;
-    }
-    if (removeValue(EGL_STENCIL_SIZE))
-        return true;
-    if (removeValue(EGL_DEPTH_SIZE))
-        return true;
-#ifdef EGL_BIND_TO_TEXTURE_RGB
-    if (removeValue(EGL_BIND_TO_TEXTURE_RGB))
-        return true;
-#endif
-    return false;
-}
-
-static void addTag(QString& str, const QString& tag)
-{
-    int lastnl = str.lastIndexOf(QLatin1String("\n"));
-    if (lastnl == -1)
-        lastnl = 0;
-    if ((str.length() - lastnl) >= 50)
-        str += QLatin1String("\n   ");
-    str += tag;
-}
-
-// Convert a property list to a string suitable for debug output.
-QString QEglProperties::toString() const
-{
-    QString str;
-    int val;
-
-    val = value(EGL_CONFIG_ID);
-    if (val != EGL_DONT_CARE) {
-        str += QLatin1String("id=");
-        str += QString::number(val);
-        str += QLatin1Char(' ');
-    }
-
-#ifdef EGL_RENDERABLE_TYPE
-    val = value(EGL_RENDERABLE_TYPE);
-    if (val != EGL_DONT_CARE) {
-        str += QLatin1String("type=");
-        QStringList types;
-        if ((val & EGL_OPENGL_ES_BIT) != 0)
-            types += QLatin1String("es1");
-#ifdef EGL_OPENGL_ES2_BIT
-        if ((val & EGL_OPENGL_ES2_BIT) != 0)
-            types += QLatin1String("es2");
-#endif
-#ifdef EGL_OPENGL_BIT
-        if ((val & EGL_OPENGL_BIT) != 0)
-            types += QLatin1String("gl");
-#endif
-        if ((val & EGL_OPENVG_BIT) != 0)
-            types += QLatin1String("vg");
-        if ((val & ~7) != 0)
-            types += QString::number(val);
-        str += types.join(QLatin1String(","));
-    } else {
-        str += QLatin1String("type=any");
-    }
-#else
-    str += QLatin1String("type=es1");
-#endif
-
-    int red = value(EGL_RED_SIZE);
-    int green = value(EGL_GREEN_SIZE);
-    int blue = value(EGL_BLUE_SIZE);
-    int alpha = value(EGL_ALPHA_SIZE);
-    int bufferSize = value(EGL_BUFFER_SIZE);
-    if (bufferSize == (red + green + blue + alpha))
-        bufferSize = 0;
-    str += QLatin1String(" rgba=");
-    str += QString::number(red);
-    str += QLatin1Char(',');
-    str += QString::number(green);
-    str += QLatin1Char(',');
-    str += QString::number(blue);
-    str += QLatin1Char(',');
-    str += QString::number(alpha);
-    if (bufferSize != 0) {
-        // Only report buffer size if different than r+g+b+a.
-        str += QLatin1String(" buffer-size=");
-        str += QString::number(bufferSize);
-    }
-
-#ifdef EGL_COLOR_BUFFER_TYPE
-    val = value(EGL_COLOR_BUFFER_TYPE);
-    if (val == EGL_LUMINANCE_BUFFER) {
-        addTag(str, QLatin1String(" color-buffer-type=luminance"));
-    } else if (val != EGL_DONT_CARE && val != EGL_RGB_BUFFER) {
-        addTag(str, QLatin1String(" color-buffer-type="));
-        str += QString::number(val, 16);
-    }
-#endif
-
-    val = value(EGL_DEPTH_SIZE);
-    if (val != 0) {
-        addTag(str, QLatin1String(" depth="));
-        str += QString::number(val);
-    }
-
-    val = value(EGL_STENCIL_SIZE);
-    if (val != 0) {
-        addTag(str, QLatin1String(" stencil="));
-        str += QString::number(val);
-    }
-
-    val = value(EGL_SURFACE_TYPE);
-    if (val != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" surface-type="));
-        QStringList types;
-        if ((val & EGL_WINDOW_BIT) != 0)
-            types += QLatin1String("window");
-        if ((val & EGL_PIXMAP_BIT) != 0)
-            types += QLatin1String("pixmap");
-        if ((val & EGL_PBUFFER_BIT) != 0)
-            types += QLatin1String("pbuffer");
-#ifdef EGL_VG_COLORSPACE_LINEAR_BIT
-        if ((val & EGL_VG_COLORSPACE_LINEAR_BIT) != 0)
-            types += QLatin1String("vg-colorspace-linear");
-#endif
-#ifdef EGL_VG_ALPHA_FORMAT_PRE_BIT
-        if ((val & EGL_VG_ALPHA_FORMAT_PRE_BIT) != 0)
-            types += QLatin1String("vg-alpha-format-pre");
-#endif
-        if ((val & ~(EGL_WINDOW_BIT | EGL_PIXMAP_BIT | EGL_PBUFFER_BIT
-#ifdef EGL_VG_COLORSPACE_LINEAR_BIT
-                     | EGL_VG_COLORSPACE_LINEAR_BIT
-#endif
-#ifdef EGL_VG_ALPHA_FORMAT_PRE_BIT
-                     | EGL_VG_ALPHA_FORMAT_PRE_BIT
-#endif
-                     )) != 0) {
-            types += QString::number(val);
-        }
-        str += types.join(QLatin1String(","));
-    }
-
-    val = value(EGL_CONFIG_CAVEAT);
-    if (val != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" caveat="));
-        if (val == EGL_NONE)
-            str += QLatin1String("none");
-        else if (val == EGL_SLOW_CONFIG)
-            str += QLatin1String("slow");
-        else if (val == EGL_NON_CONFORMANT_CONFIG)
-            str += QLatin1String("non-conformant");
-        else
-            str += QString::number(val, 16);
-    }
-
-    val = value(EGL_LEVEL);
-    if (val != 0) {
-        addTag(str, QLatin1String(" level="));
-        str += QString::number(val);
-    }
-
-    int width, height, pixels;
-    width = value(EGL_MAX_PBUFFER_WIDTH);
-    height = value(EGL_MAX_PBUFFER_HEIGHT);
-    pixels = value(EGL_MAX_PBUFFER_PIXELS);
-    if (height != EGL_DONT_CARE || width != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" max-pbuffer-size="));
-        str += QString::number(width);
-        str += QLatin1Char('x');
-        str += QString::number(height);
-        if (pixels != (width * height)) {
-            addTag(str, QLatin1String(" max-pbuffer-pixels="));
-            str += QString::number(pixels);
-        }
-    }
-
-    val = value(EGL_NATIVE_RENDERABLE);
-    if (val != EGL_DONT_CARE) {
-        if (val)
-            addTag(str, QLatin1String(" native-renderable=true"));
-        else
-            addTag(str, QLatin1String(" native-renderable=false"));
-    }
-
-    val = value(EGL_NATIVE_VISUAL_ID);
-    if (val != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" visual-id="));
-        str += QString::number(val);
-    }
-
-    val = value(EGL_NATIVE_VISUAL_TYPE);
-    if (val != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" visual-type="));
-        str += QString::number(val);
-    }
-
-#ifdef EGL_PRESERVED_RESOURCES
-    val = value(EGL_PRESERVED_RESOURCES);
-    if (val != EGL_DONT_CARE) {
-        if (val)
-            addTag(str, QLatin1String(" preserved-resources=true"));
-        else
-            addTag(str, QLatin1String(" preserved-resources=false"));
-    }
-#endif
-
-    val = value(EGL_SAMPLES);
-    if (val != 0) {
-        addTag(str, QLatin1String(" samples="));
-        str += QString::number(val);
-    }
-
-    val = value(EGL_SAMPLE_BUFFERS);
-    if (val != 0) {
-        addTag(str, QLatin1String(" sample-buffers="));
-        str += QString::number(val);
-    }
-
-    val = value(EGL_TRANSPARENT_TYPE);
-    if (val == EGL_TRANSPARENT_RGB) {
-        addTag(str, QLatin1String(" transparent-rgb="));
-        str += QString::number(value(EGL_TRANSPARENT_RED_VALUE));
-        str += QLatin1Char(',');
-        str += QString::number(value(EGL_TRANSPARENT_GREEN_VALUE));
-        str += QLatin1Char(',');
-        str += QString::number(value(EGL_TRANSPARENT_BLUE_VALUE));
-    }
-
-#if defined(EGL_BIND_TO_TEXTURE_RGB) && defined(EGL_BIND_TO_TEXTURE_RGBA)
-    val = value(EGL_BIND_TO_TEXTURE_RGB);
-    int val2 = value(EGL_BIND_TO_TEXTURE_RGBA);
-    if (val != EGL_DONT_CARE || val2 != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" bind-texture="));
-        if (val == EGL_TRUE)
-            str += QLatin1String("rgb");
-        else
-            str += QLatin1String("no-rgb");
-        if (val2 == EGL_TRUE)
-            str += QLatin1String(",rgba");
-        else
-            str += QLatin1String(",no-rgba");
-    }
-#endif
-
-#ifdef EGL_MIN_SWAP_INTERVAL
-    val = value(EGL_MIN_SWAP_INTERVAL);
-    if (val != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" min-swap-interval="));
-        str += QString::number(val);
-    }
-#endif
-
-#ifdef EGL_MIN_SWAP_INTERVAL
-    val = value(EGL_MAX_SWAP_INTERVAL);
-    if (val != EGL_DONT_CARE) {
-        addTag(str, QLatin1String(" max-swap-interval="));
-        str += QString::number(val);
-    }
-#endif
-
-#ifdef EGL_LUMINANCE_SIZE
-    val = value(EGL_LUMINANCE_SIZE);
-    if (val != 0) {
-        addTag(str, QLatin1String(" luminance="));
-        str += QString::number(val);
-    }
-#endif
-
-#ifdef EGL_ALPHA_MASK_SIZE
-    val = value(EGL_ALPHA_MASK_SIZE);
-    if (val != 0) {
-        addTag(str, QLatin1String(" alpha-mask="));
-        str += QString::number(val);
-    }
-#endif
-
-#ifdef EGL_CONFORMANT
-    val = value(EGL_CONFORMANT);
-    if (val != 0) {
-        if (val)
-            addTag(str, QLatin1String(" conformant=true"));
-        else
-            addTag(str, QLatin1String(" conformant=false"));
-    }
-#endif
-
-    return str;
-}
-
-QT_END_NAMESPACE
-
-
diff --git a/src/gui/egl/qeglproperties_p.h b/src/gui/egl/qeglproperties_p.h
deleted file mode 100644
index a5fc8f9..0000000
--- a/src/gui/egl/qeglproperties_p.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QEGLPROPERTIES_P_H
-#define QEGLPROPERTIES_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of the QtGui and QtOpenVG modules.  This header file may change from
-// version to version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include <QtCore/qvarlengtharray.h>
-#include <QtGui/qimage.h>
-
-#include <QtGui/private/qegl_p.h>
-
-QT_BEGIN_NAMESPACE
-
-class QPaintDevice;
-
-class Q_GUI_EXPORT QEglProperties
-{
-public:
-    QEglProperties();
-    QEglProperties(EGLConfig);
-    QEglProperties(const QEglProperties& other) : props(other.props) {}
-    ~QEglProperties() {}
-
-    int value(int name) const;
-    void setValue(int name, int value);
-    bool removeValue(int name);
-    bool isEmpty() const { return props[0] == EGL_NONE; }
-
-    const int *properties() const { return props.constData(); }
-
-    void setPixelFormat(QImage::Format pixelFormat);
-    void setDeviceType(int devType);
-    void setPaintDeviceFormat(QPaintDevice *dev);
-    void setRenderableType(QEgl::API api);
-
-    bool reduceConfiguration();
-
-    QString toString() const;
-
-private:
-    QVarLengthArray<int> props;
-};
-
-QT_END_NAMESPACE
-
-#endif // QEGLPROPERTIES_P_H
diff --git a/src/gui/gui.pro b/src/gui/gui.pro
index db04593..a8a7df6 100644
--- a/src/gui/gui.pro
+++ b/src/gui/gui.pro
@@ -32,8 +32,6 @@ include(util/util.pri)
 include(math3d/math3d.pri)
 include(opengl/opengl.pri)
 
-include(egl/egl.pri)
-
 QMAKE_LIBS += $$QMAKE_LIBS_GUI
 
 DEFINES += Q_INTERNAL_QAPP_SRC