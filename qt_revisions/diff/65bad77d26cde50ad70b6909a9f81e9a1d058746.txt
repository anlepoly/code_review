diff --git a/src/corelib/arch/arch.pri b/src/corelib/arch/arch.pri
index 40e16f7..2921f8e 100644
--- a/src/corelib/arch/arch.pri
+++ b/src/corelib/arch/arch.pri
@@ -11,7 +11,7 @@ vxworks:HEADERS += arch/qatomic_vxworks.h
 
 integrity:HEADERS += arch/qatomic_integrity.h
 
-!wince*:!win32:!mac:!symbian:HEADERS += arch/qatomic_alpha.h \
+!wince*:!win32:!mac:HEADERS += arch/qatomic_alpha.h \
                        arch/qatomic_avr32.h \
                        arch/qatomic_ia64.h \
                        arch/qatomic_parisc.h \
diff --git a/src/corelib/arch/generic/qatomic_generic_unix.cpp b/src/corelib/arch/generic/qatomic_generic_unix.cpp
index 346842b..64e8fb5 100644
--- a/src/corelib/arch/generic/qatomic_generic_unix.cpp
+++ b/src/corelib/arch/generic/qatomic_generic_unix.cpp
@@ -39,8 +39,6 @@
 **
 ****************************************************************************/
 
-#if !defined(Q_OS_SYMBIAN) || (defined(Q_OS_SYMBIAN) && !defined(Q_CC_RVCT))
-
 #include "qplatformdefs.h"
 
 #include <QtCore/qatomic.h>
@@ -120,4 +118,3 @@ void *QBasicAtomicPointer_fetchAndAddOrdered(void * volatile *_q_value, qptrdiff
     return returnValue;
 }
 QT_END_NAMESPACE
-#endif //!defined(Q_OS_SYMBIAN) && !defined(Q_CC_RVCT)
diff --git a/src/corelib/arch/qatomic_symbian.h b/src/corelib/arch/qatomic_symbian.h
deleted file mode 100644
index 0fd11a4..0000000
--- a/src/corelib/arch/qatomic_symbian.h
+++ /dev/null
@@ -1,313 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QATOMIC_SYMBIAN_H
-#define QATOMIC_SYMBIAN_H
-
-#include <QtCore/qglobal.h>
-#include <e32std.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-QT_MODULE(Core)
-
-#define Q_ATOMIC_INT_REFERENCE_COUNTING_IS_SOMETIMES_NATIVE
-
-inline bool QBasicAtomicInt::isReferenceCountingWaitFree()
-{ return false; }
-
-#define Q_ATOMIC_INT_TEST_AND_SET_IS_SOMETIMES_NATIVE
-
-inline bool QBasicAtomicInt::isTestAndSetWaitFree()
-{ return false; }
-
-#define Q_ATOMIC_INT_FETCH_AND_STORE_IS_SOMETIMES_NATIVE
-
-inline bool QBasicAtomicInt::isFetchAndStoreWaitFree()
-{ return false; }
-
-#define Q_ATOMIC_INT_FETCH_AND_ADD_IS_SOMETIMES_NATIVE
-
-inline bool QBasicAtomicInt::isFetchAndAddWaitFree()
-{ return false; }
-
-#define Q_ATOMIC_POINTER_TEST_AND_SET_IS_SOMETIMES_NATIVE
-
-Q_CORE_EXPORT bool QBasicAtomicPointer_isTestAndSetNative();
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::isTestAndSetNative()
-{ return QBasicAtomicPointer_isTestAndSetNative(); }
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::isTestAndSetWaitFree()
-{ return false; }
-
-#define Q_ATOMIC_POINTER_FETCH_AND_STORE_IS_SOMETIMES_NATIVE
-
-Q_CORE_EXPORT bool QBasicAtomicPointer_isFetchAndStoreNative();
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::isFetchAndStoreNative()
-{ return QBasicAtomicPointer_isFetchAndStoreNative(); }
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::isFetchAndStoreWaitFree()
-{ return false; }
-
-#define Q_ATOMIC_POINTER_FETCH_AND_ADD_IS_SOMETIMES_NATIVE
-
-Q_CORE_EXPORT bool QBasicAtomicPointer_isFetchAndAddNative();
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::isFetchAndAddNative()
-{ return QBasicAtomicPointer_isFetchAndAddNative(); }
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::isFetchAndAddWaitFree()
-{ return false; }
-
-Q_CORE_EXPORT bool QBasicAtomicInt_testAndSetOrdered(volatile int *, int, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndStoreOrdered(volatile int *, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndAddOrdered(volatile int *, int);
-Q_CORE_EXPORT bool QBasicAtomicInt_testAndSetRelaxed(volatile int *, int, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndStoreRelaxed(volatile int *, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndAddRelaxed(volatile int *, int);
-Q_CORE_EXPORT bool QBasicAtomicInt_testAndSetAcquire(volatile int *, int, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndStoreAcquire(volatile int *, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndAddAcquire(volatile int *, int);
-Q_CORE_EXPORT bool QBasicAtomicInt_testAndSetRelease(volatile int *, int, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndStoreRelease(volatile int *, int);
-Q_CORE_EXPORT int QBasicAtomicInt_fetchAndAddRelease(volatile int *, int);
-
-Q_CORE_EXPORT bool QBasicAtomicPointer_testAndSetOrdered(void * volatile *, void *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndStoreOrdered(void * volatile *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndAddOrdered(void * volatile *, qptrdiff);
-Q_CORE_EXPORT bool QBasicAtomicPointer_testAndSetRelaxed(void * volatile *, void *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndStoreRelaxed(void * volatile *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndAddRelaxed(void * volatile *, qptrdiff);
-Q_CORE_EXPORT bool QBasicAtomicPointer_testAndSetAcquire(void * volatile *, void *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndStoreAcquire(void * volatile *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndAddAcquire(void * volatile *, qptrdiff);
-Q_CORE_EXPORT bool QBasicAtomicPointer_testAndSetRelease(void * volatile *, void *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndStoreRelease(void * volatile *, void *);
-Q_CORE_EXPORT void *QBasicAtomicPointer_fetchAndAddRelease(void * volatile *, qptrdiff);
-
-// Reference counting
-
-//LockedInc and LockedDec are machine coded for ARMv6 (and future proof)
-inline bool QBasicAtomicInt::ref()
-{
-    int original = User::LockedInc((TInt&)_q_value);
-    return original != -1;
-}
-
-inline bool QBasicAtomicInt::deref()
-{
-    int original = User::LockedDec((TInt&)_q_value);
-    return original != 1;
-}
-
-// Test and set for integers
-
-inline bool QBasicAtomicInt::testAndSetOrdered(int expectedValue, int newValue)
-{
-    return QBasicAtomicInt_testAndSetOrdered(&_q_value, expectedValue, newValue);
-}
-
-inline bool QBasicAtomicInt::testAndSetRelaxed(int expectedValue, int newValue)
-{
-    return QBasicAtomicInt_testAndSetRelaxed(&_q_value, expectedValue, newValue);
-}
-
-inline bool QBasicAtomicInt::testAndSetAcquire(int expectedValue, int newValue)
-{
-    return QBasicAtomicInt_testAndSetAcquire(&_q_value, expectedValue, newValue);
-}
-
-inline bool QBasicAtomicInt::testAndSetRelease(int expectedValue, int newValue)
-{
-    return QBasicAtomicInt_testAndSetRelease(&_q_value, expectedValue, newValue);
-}
-
-// Fetch and store for integers
-
-inline int QBasicAtomicInt::fetchAndStoreOrdered(int newValue)
-{
-    return QBasicAtomicInt_fetchAndStoreOrdered(&_q_value, newValue);
-}
-
-inline int QBasicAtomicInt::fetchAndStoreRelaxed(int newValue)
-{
-    return QBasicAtomicInt_fetchAndStoreRelaxed(&_q_value, newValue);
-}
-
-inline int QBasicAtomicInt::fetchAndStoreAcquire(int newValue)
-{
-    return QBasicAtomicInt_fetchAndStoreAcquire(&_q_value, newValue);
-}
-
-inline int QBasicAtomicInt::fetchAndStoreRelease(int newValue)
-{
-    return QBasicAtomicInt_fetchAndStoreRelease(&_q_value, newValue);
-}
-
-// Fetch and add for integers
-
-inline int QBasicAtomicInt::fetchAndAddOrdered(int valueToAdd)
-{
-    return QBasicAtomicInt_fetchAndAddOrdered(&_q_value, valueToAdd);
-}
-
-inline int QBasicAtomicInt::fetchAndAddRelaxed(int valueToAdd)
-{
-    return QBasicAtomicInt_fetchAndAddRelaxed(&_q_value, valueToAdd);
-}
-
-inline int QBasicAtomicInt::fetchAndAddAcquire(int valueToAdd)
-{
-    return QBasicAtomicInt_fetchAndAddAcquire(&_q_value, valueToAdd);
-}
-
-inline int QBasicAtomicInt::fetchAndAddRelease(int valueToAdd)
-{
-    return QBasicAtomicInt_fetchAndAddRelease(&_q_value, valueToAdd);
-}
-
-// Test and set for pointers
-
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetOrdered(T *expectedValue, T *newValue)
-{
-    return QBasicAtomicPointer_testAndSetOrdered(reinterpret_cast<void * volatile *>(&_q_value),
-        expectedValue, newValue);
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelaxed(T *expectedValue, T *newValue)
-{
-    return QBasicAtomicPointer_testAndSetRelaxed(reinterpret_cast<void * volatile *>(&_q_value),
-        expectedValue, newValue);
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetAcquire(T *expectedValue, T *newValue)
-{
-    return QBasicAtomicPointer_testAndSetAcquire(reinterpret_cast<void * volatile *>(&_q_value),
-        expectedValue, newValue);
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE bool QBasicAtomicPointer<T>::testAndSetRelease(T *expectedValue, T *newValue)
-{
-    return QBasicAtomicPointer_testAndSetRelease(reinterpret_cast<void * volatile *>(&_q_value),
-        expectedValue, newValue);
-}
-
-// Fetch and store for pointers
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreOrdered(T *newValue)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndStoreOrdered(
-        reinterpret_cast<void * volatile *>(&_q_value)
-        , newValue));
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelaxed(T *newValue)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndStoreRelaxed(
-        reinterpret_cast<void * volatile *>(&_q_value)
-        , newValue));
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreAcquire(T *newValue)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndStoreAcquire(
-        reinterpret_cast<void * volatile *>(&_q_value)
-        , newValue));
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndStoreRelease(T *newValue)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndStoreRelease(
-        reinterpret_cast<void * volatile *>(&_q_value)
-        , newValue));
-}
-
-// Fetch and add for pointers
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddOrdered(qptrdiff valueToAdd)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndAddOrdered(
-        reinterpret_cast<void * volatile *>(&_q_value),
-        valueToAdd * sizeof(T)));
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelaxed(qptrdiff valueToAdd)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndAddRelaxed(
-        reinterpret_cast<void * volatile *>(&_q_value),
-        valueToAdd * sizeof(T)));
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddAcquire(qptrdiff valueToAdd)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndAddAcquire(
-        reinterpret_cast<void * volatile *>(&_q_value),
-        valueToAdd * sizeof(T)));
-}
-
-template <typename T>
-Q_INLINE_TEMPLATE T *QBasicAtomicPointer<T>::fetchAndAddRelease(qptrdiff valueToAdd)
-{
-    return static_cast<T*>(QBasicAtomicPointer_fetchAndAddRelease(
-        reinterpret_cast<void * volatile *>(&_q_value),
-        valueToAdd * sizeof(T)));
-}
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QATOMIC_SYMBIAN_H
diff --git a/src/corelib/corelib.pro b/src/corelib/corelib.pro
index 17c15d4..c84aed4 100644
--- a/src/corelib/corelib.pro
+++ b/src/corelib/corelib.pro
@@ -45,14 +45,3 @@ QMAKE_LIBS += $$QMAKE_LIBS_CORE
 QMAKE_DYNAMIC_LIST_FILE = $$PWD/QtCore.dynlist
 
 contains(DEFINES,QT_EVAL):include(eval.pri)
-
-symbian: {
-    TARGET.UID3=0x2001B2DC
-
-    # Problems using data exports from this DLL mean that we can't page it on releases that don't support
-    # data exports (currently that's any release before Symbian^3)
-    pagingBlock = "$${LITERAL_HASH}ifndef SYMBIAN_DLL_DATA_EXPORTS_SUPPORTED" \
-                  "UNPAGED" \
-                  "$${LITERAL_HASH}endif"
-    MMP_RULES += pagingBlock
-}
diff --git a/src/corelib/global/global.pri b/src/corelib/global/global.pri
index 3c0dfd2..027542c 100644
--- a/src/corelib/global/global.pri
+++ b/src/corelib/global/global.pri
@@ -19,7 +19,7 @@ INCLUDEPATH += $$QT_BUILD_TREE/src/corelib/global
 # Only used on platforms with CONFIG += precompile_header
 PRECOMPILED_HEADER = global/qt_pch.h
 
-linux*:!cross_compile:!static:!symbian-gcce:!*-armcc* {
+linux*:!cross_compile:!static:!*-armcc* {
    QMAKE_LFLAGS += -Wl,-e,qt_core_boilerplate
    prog=$$quote(if (/program interpreter: (.*)]/) { print $1; })
    DEFINES += ELF_INTERPRETER=\\\"$$system(readelf -l /bin/ls | perl -n -e \'$$prog\')\\\"
diff --git a/src/corelib/global/qnamespace.h b/src/corelib/global/qnamespace.h
index f029e6a..521e426 100644
--- a/src/corelib/global/qnamespace.h
+++ b/src/corelib/global/qnamespace.h
@@ -1416,11 +1416,7 @@ public:
     };
     Q_DECLARE_FLAGS(MatchFlags, MatchFlag)
 
-#if defined(Q_OS_SYMBIAN)
-    typedef unsigned long int HANDLE; // equivalent to TUint32
-#else
     typedef void * HANDLE;
-#endif
     typedef WindowFlags WFlags;
 
     enum WindowModality {
diff --git a/src/corelib/global/qnamespace.qdoc b/src/corelib/global/qnamespace.qdoc
index f525a8f..0e98aaa 100644
--- a/src/corelib/global/qnamespace.qdoc
+++ b/src/corelib/global/qnamespace.qdoc
@@ -150,19 +150,6 @@
            Command+C on the keyboard regardless of the value set, though what is output for
            QKeySequence::toString(QKeySequence::PortableText) will be different).
 
-    \value AA_S60DontConstructApplicationPanes Stops Qt from initializing the S60 status
-           pane and softkey pane on Symbian. This is useful to save memory and reduce
-           startup time for applications that will run in fullscreen mode during their
-           whole lifetime. This attribute must be set before QApplication is
-           constructed.
-
-    \omitvalue AA_S60DisablePartialScreenInputMode By default in Symbian^3,
-           a separate editing window is opened on top of an application. This is exactly
-           like editing on previous versions of Symbian behave. When this attribute
-           is true, a virtual keyboard window is shown on top of application and it
-           is ensured that the focused text widget is visible. This is only supported in
-           Symbian^3. (internal)
-
     \value AA_X11InitThreads Calls XInitThreads() as part of the QApplication
            construction in order to make Xlib calls thread-safe. This
            attribute must be set before QApplication is constructed.
@@ -811,7 +798,7 @@
 
     \value WA_InputMethodEnabled Enables input methods for Asian languages.
     Must be set when creating custom text editing widgets.
-    On Windows CE and Symbian this flag can be used in addition to
+    On Windows CE this flag can be used in addition to
     QApplication::autoSipEnabled to automatically display the SIP when
     entering a widget.
 
diff --git a/src/corelib/kernel/qmath.h b/src/corelib/kernel/qmath.h
index 2c98526..b45e0a7 100644
--- a/src/corelib/kernel/qmath.h
+++ b/src/corelib/kernel/qmath.h
@@ -46,10 +46,6 @@
 
 #include <QtCore/qglobal.h>
 
-#ifdef Q_OS_SYMBIAN
-#    include <e32math.h>
-#endif
-
 QT_BEGIN_HEADER
 
 QT_BEGIN_NAMESPACE
@@ -92,130 +88,82 @@ inline qreal qFabs(qreal v)
 
 inline qreal qSin(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal sin_v;
-    Math::Sin(sin_v, static_cast<TReal>(v));
-    return static_cast<qreal>(sin_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if (sizeof(qreal) == sizeof(float))
-            return sinf(float(v));
-        else
-#    endif
-            return sin(v);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return sinf(float(v));
+    else
 #endif
+        return sin(v);
 }
 
 inline qreal qCos(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal cos_v;
-    Math::Cos(cos_v, static_cast<TReal>(v));
-    return static_cast<qreal>(cos_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if (sizeof(qreal) == sizeof(float))
-            return cosf(float(v));
-        else
-#    endif
-            return cos(v);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return cosf(float(v));
+    else
 #endif
+        return cos(v);
 }
 
 inline qreal qTan(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal tan_v;
-    Math::Tan(tan_v, static_cast<TReal>(v));
-    return static_cast<qreal>(tan_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if (sizeof(qreal) == sizeof(float))
-            return tanf(float(v));
-        else
-#    endif
-            return tan(v);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return tanf(float(v));
+    else
 #endif
+        return tan(v);
 }
 
 inline qreal qAcos(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal acos_v;
-    Math::ACos(acos_v, static_cast<TReal>(v));
-    return static_cast<qreal>(acos_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if (sizeof(qreal) == sizeof(float))
-            return acosf(float(v));
-        else
-#    endif
-           return acos(v);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return acosf(float(v));
+    else
 #endif
+       return acos(v);
 }
 
 inline qreal qAsin(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal asin_v;
-    Math::ASin(asin_v, static_cast<TReal>(v));
-    return static_cast<qreal>(asin_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if (sizeof(qreal) == sizeof(float))
-            return asinf(float(v));
-        else
-#    endif
-            return asin(v);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return asinf(float(v));
+    else
 #endif
+        return asin(v);
 }
 
 inline qreal qAtan(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal atan_v;
-    Math::ATan(atan_v, static_cast<TReal>(v));
-    return static_cast<qreal>(atan_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if(sizeof(qreal) == sizeof(float))
-            return atanf(float(v));
-        else
-#    endif
-            return atan(v);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return atanf(float(v));
+    else
 #endif
+        return atan(v);
 }
 
 inline qreal qAtan2(qreal x, qreal y)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal atan2_v;
-    Math::ATan(atan2_v, static_cast<TReal>(x), static_cast<TReal>(y));
-    return static_cast<qreal>(atan2_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if(sizeof(qreal) == sizeof(float))
-            return atan2f(float(x), float(y));
-        else
-#    endif
-            return atan2(x, y);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return atan2f(float(x), float(y));
+    else
 #endif
+        return atan2(x, y);
 }
 
 inline qreal qSqrt(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal sqrt_v;
-    Math::Sqrt(sqrt_v, static_cast<TReal>(v));
-    return static_cast<qreal>(sqrt_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if (sizeof(qreal) == sizeof(float))
-            return sqrtf(float(v));
-        else
-#    endif
-            return sqrt(v);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return sqrtf(float(v));
+    else
 #endif
+        return sqrt(v);
 }
 
 inline qreal qLn(qreal v)
@@ -230,31 +178,19 @@ inline qreal qLn(qreal v)
 
 inline qreal qExp(qreal v)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal exp_v;
-    Math::Exp(exp_v, static_cast<TReal>(v));
-    return static_cast<qreal>(exp_v);
-#else
     // only one signature
     // exists, exp(double)
     return exp(v);
-#endif
 }
 
 inline qreal qPow(qreal x, qreal y)
 {
-#ifdef Q_OS_SYMBIAN
-    TReal pow_v;
-    Math::Pow(pow_v, static_cast<TReal>(x), static_cast<TReal>(y));
-    return static_cast<qreal>(pow_v);
-#else
-#    ifdef QT_USE_MATH_H_FLOATS
-        if (sizeof(qreal) == sizeof(float))
-            return powf(float(x), float(y));
-        else
-#    endif
-            return pow(x, y);
+#ifdef QT_USE_MATH_H_FLOATS
+    if (sizeof(qreal) == sizeof(float))
+        return powf(float(x), float(y));
+    else
 #endif
+        return pow(x, y);
 }
 
 #ifndef M_PI
diff --git a/src/corelib/plugin/qlibrary_unix.cpp b/src/corelib/plugin/qlibrary_unix.cpp
index 1395a86..1a1e0c0 100644
--- a/src/corelib/plugin/qlibrary_unix.cpp
+++ b/src/corelib/plugin/qlibrary_unix.cpp
@@ -86,30 +86,18 @@ bool QLibraryPrivate::load_sys()
 #if !defined(QT_NO_DYNAMIC_LIBRARY)
     QFileInfo fi(fileName);
 
-#if defined(Q_OS_SYMBIAN)
-    QString path; // In Symbian, always resolve with just the filename
-    QString name;
-
-    // Replace possible ".qtplugin" suffix with ".dll"
-    if (fi.suffix() == QLatin1String("qtplugin"))
-        name = fi.completeBaseName() + QLatin1String(".dll");
-    else
-        name = fi.fileName();
-#else
     QString path = fi.path();
     QString name = fi.fileName();
     if (path == QLatin1String(".") && !fileName.startsWith(path))
         path.clear();
     else
         path += QLatin1Char('/');
-#endif
+
     // The first filename we want to attempt to load is the filename as the callee specified.
     // Thus, the first attempt we do must be with an empty prefix and empty suffix.
     QStringList suffixes(QLatin1String("")), prefixes(QLatin1String(""));
     if (pluginState != IsAPlugin) {
-#if !defined(Q_OS_SYMBIAN)
         prefixes << QLatin1String("lib");
-#endif
 #if defined(Q_OS_HPUX)
         // according to
         // http://docs.hp.com/en/B2355-90968/linkerdifferencesiapa.htm
@@ -138,8 +126,6 @@ bool QLibraryPrivate::load_sys()
 #elif defined(Q_OS_AIX)
         suffixes << ".a";
 
-#elif defined(Q_OS_SYMBIAN)
-        suffixes << QLatin1String(".dll");
 #else
         if (!fullVersion.isEmpty()) {
             suffixes << QString::fromLatin1(".so.%1").arg(fullVersion);
@@ -209,11 +195,6 @@ bool QLibraryPrivate::load_sys()
             pHnd = dlopen(QFile::encodeName(attempt), dlFlags);
 #endif
 
-#if defined(Q_OS_SYMBIAN)
-            // Never try again in symbian, dlopen already handles the library search logic,
-            // and there is only one possible suffix.
-            retry = false;
-#else
             if (!pHnd && fileName.startsWith(QLatin1Char('/')) && QFile::exists(attempt)) {
                 // We only want to continue if dlopen failed due to that the shared library did not exist.
                 // However, we are only able to apply this check for absolute filenames (since they are
@@ -221,7 +202,6 @@ bool QLibraryPrivate::load_sys()
                 // This is all because dlerror is flawed and cannot tell us the reason why it failed.
                 retry = false;
             }
-#endif
         }
     }
 
diff --git a/src/corelib/tools/qcryptographichash.cpp b/src/corelib/tools/qcryptographichash.cpp
index bd6fd76..405a8fb 100644
--- a/src/corelib/tools/qcryptographichash.cpp
+++ b/src/corelib/tools/qcryptographichash.cpp
@@ -41,10 +41,6 @@
 
 #include <qcryptographichash.h>
 
-#ifdef Q_OS_SYMBIAN
-#define _MD5_H_ // Needed to disable system header
-#endif
-
 #include "../../3rdparty/md5/md5.h"
 #include "../../3rdparty/md5/md5.cpp"
 #include "../../3rdparty/md4/md4.h"
diff --git a/src/corelib/tools/qdatetime.cpp b/src/corelib/tools/qdatetime.cpp
index c5b35eb..eaebad1 100644
--- a/src/corelib/tools/qdatetime.cpp
+++ b/src/corelib/tools/qdatetime.cpp
@@ -73,10 +73,6 @@
 #include <private/qcore_mac_p.h>
 #endif
 
-#if defined(Q_OS_SYMBIAN)
-#include <e32std.h>
-#endif
-
 QT_BEGIN_NAMESPACE
 
 enum {
@@ -2926,76 +2922,6 @@ qint64 QDateTime::currentMSecsSinceEpoch()
                    - julianDayFromGregorianDate(1970, 1, 1)) * Q_INT64_C(86400000);
 }
 
-#elif defined(Q_OS_SYMBIAN)
-QDate QDate::currentDate()
-{
-    QDate d;
-    TTime localTime;
-    localTime.HomeTime();
-    TDateTime localDateTime = localTime.DateTime();
-    // months and days are zero indexed
-    d.jd = julianDayFromDate(localDateTime.Year(), localDateTime.Month() + 1, localDateTime.Day() + 1 );
-    return d;
-}
-
-QTime QTime::currentTime()
-{
-    QTime ct;
-    TTime localTime;
-    localTime.HomeTime();
-    TDateTime localDateTime = localTime.DateTime();
-    ct.mds = msecsFromDecomposed(localDateTime.Hour(), localDateTime.Minute(),
-                                 localDateTime.Second(), localDateTime.MicroSecond() / 1000);
-    return ct;
-}
-
-QDateTime QDateTime::currentDateTime()
-{
-    QDate d;
-    QTime ct;
-    TTime localTime;
-    localTime.HomeTime();
-    TDateTime localDateTime = localTime.DateTime();
-    // months and days are zero indexed
-    d.jd = julianDayFromDate(localDateTime.Year(), localDateTime.Month() + 1, localDateTime.Day() + 1);
-    ct.mds = msecsFromDecomposed(localDateTime.Hour(), localDateTime.Minute(),
-                                 localDateTime.Second(), localDateTime.MicroSecond() / 1000);
-    return QDateTime(d, ct);
-}
-
-QDateTime QDateTime::currentDateTimeUtc()
-{
-    QDate d;
-    QTime ct;
-    TTime gmTime;
-    gmTime.UniversalTime();
-    TDateTime gmtDateTime = gmTime.DateTime();
-    // months and days are zero indexed
-    d.jd = julianDayFromDate(gmtDateTime.Year(), gmtDateTime.Month() + 1, gmtDateTime.Day() + 1);
-    ct.mds = msecsFromDecomposed(gmtDateTime.Hour(), gmtDateTime.Minute(),
-                                 gmtDateTime.Second(), gmtDateTime.MicroSecond() / 1000);
-    return QDateTime(d, ct, Qt::UTC);
-}
-
-qint64 QDateTime::currentMSecsSinceEpoch()
-{
-    QDate d;
-    QTime ct;
-    TTime gmTime;
-    gmTime.UniversalTime();
-    TDateTime gmtDateTime = gmTime.DateTime();
-
-    // according to the documentation, the value is:
-    // "a date and time as a number of microseconds since midnight, January 1st, 0 AD nominal Gregorian"
-    qint64 value = gmTime.Int64();
-
-    // whereas 1970-01-01T00:00:00 is (in the same representation):
-    //   ((1970 * 365) + (1970 / 4) - (1970 / 100) + (1970 / 400) - 13) * 86400 * 1000000
-    static const qint64 unixEpoch = Q_INT64_C(0xdcddb30f2f8000);
-
-    return (value - unixEpoch) / 1000;
-}
-
 #elif defined(Q_OS_UNIX)
 QDate QDate::currentDate()
 {
@@ -3877,27 +3803,6 @@ static QDateTimePrivate::Spec utcToLocal(QDate &date, QTime &time)
     res.tm_mon = sysTime.wMonth - 1;
     res.tm_year = sysTime.wYear - 1900;
     brokenDown = &res;
-#elif defined(Q_OS_SYMBIAN)
-    // months and days are zero index based
-    _LIT(KUnixEpoch, "19700000:000000.000000");
-    TTimeIntervalSeconds utcOffset = User::UTCOffset();
-    TTimeIntervalSeconds tTimeIntervalSecsSince1Jan1970UTC(secsSince1Jan1970UTC);
-    TTime epochTTime;
-    TInt err = epochTTime.Set(KUnixEpoch);
-    tm res;
-    if(err == KErrNone) {
-        TTime utcTTime = epochTTime + tTimeIntervalSecsSince1Jan1970UTC;
-        utcTTime = utcTTime + utcOffset;
-        TDateTime utcDateTime = utcTTime.DateTime();
-        res.tm_sec = utcDateTime.Second();
-        res.tm_min = utcDateTime.Minute();
-        res.tm_hour = utcDateTime.Hour();
-        res.tm_mday = utcDateTime.Day() + 1; // non-zero based index for tm struct
-        res.tm_mon = utcDateTime.Month();
-        res.tm_year = utcDateTime.Year() - 1900;
-        res.tm_isdst = 0;
-        brokenDown = &res;
-    }
 #elif !defined(QT_NO_THREAD) && defined(_POSIX_THREAD_SAFE_FUNCTIONS)
     // use the reentrant version of localtime() where available
     tzset();
@@ -3943,7 +3848,7 @@ static void localToUtc(QDate &date, QTime &time, int isdst)
     localTM.tm_mon = fakeDate.month() - 1;
     localTM.tm_year = fakeDate.year() - 1900;
     localTM.tm_isdst = (int)isdst;
-#if defined(Q_OS_WINCE) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WINCE)
     time_t secsSince1Jan1970UTC = (toMSecsSinceEpoch_helper(fakeDate.toJulianDay(), QTime().msecsTo(time)) / 1000);
 #else
 #if defined(Q_OS_WIN)
@@ -3968,27 +3873,6 @@ static void localToUtc(QDate &date, QTime &time, int isdst)
     res.tm_year = sysTime.wYear - 1900;
     res.tm_isdst = (int)isdst;
     brokenDown = &res;
-#elif defined(Q_OS_SYMBIAN)
-    // months and days are zero index based
-    _LIT(KUnixEpoch, "19700000:000000.000000");
-    TTimeIntervalSeconds utcOffset = TTimeIntervalSeconds(0 - User::UTCOffset().Int());
-    TTimeIntervalSeconds tTimeIntervalSecsSince1Jan1970UTC(secsSince1Jan1970UTC);
-    TTime epochTTime;
-    TInt err = epochTTime.Set(KUnixEpoch);
-    tm res;
-    if(err == KErrNone) {
-        TTime utcTTime = epochTTime + tTimeIntervalSecsSince1Jan1970UTC;
-        utcTTime = utcTTime + utcOffset;
-        TDateTime utcDateTime = utcTTime.DateTime();
-        res.tm_sec = utcDateTime.Second();
-        res.tm_min = utcDateTime.Minute();
-        res.tm_hour = utcDateTime.Hour();
-        res.tm_mday = utcDateTime.Day() + 1; // non-zero based index for tm struct
-        res.tm_mon = utcDateTime.Month();
-        res.tm_year = utcDateTime.Year() - 1900;
-        res.tm_isdst = (int)isdst;
-        brokenDown = &res;
-    }
 #elif !defined(QT_NO_THREAD) && defined(_POSIX_THREAD_SAFE_FUNCTIONS)
     // use the reentrant version of gmtime() where available
     tm res;
@@ -5710,42 +5594,6 @@ bool operator==(const QDateTimeParser::SectionNode &s1, const QDateTimeParser::S
     return (s1.type == s2.type) && (s1.pos == s2.pos) && (s1.count == s2.count);
 }
 
-#ifdef Q_OS_SYMBIAN
-const static TTime UnixEpochOffset(I64LIT(0xdcddb30f2f8000));
-const static TInt64 MinimumMillisecondTime(KMinTInt64 / 1000);
-const static TInt64 MaximumMillisecondTime(KMaxTInt64 / 1000);
-QDateTime qt_symbian_TTime_To_QDateTime(const TTime& time)
-{
-    TTimeIntervalMicroSeconds absolute = time.MicroSecondsFrom(UnixEpochOffset);
-
-    return QDateTime::fromMSecsSinceEpoch(absolute.Int64() / 1000);
-}
-
-TTime qt_symbian_QDateTime_To_TTime(const QDateTime& datetime)
-{
-    qint64 absolute = datetime.toMSecsSinceEpoch();
-    if(absolute > MaximumMillisecondTime)
-        return TTime(KMaxTInt64);
-    if(absolute < MinimumMillisecondTime)
-        return TTime(KMinTInt64);
-    return TTime(absolute * 1000);
-}
-
-time_t qt_symbian_TTime_To_time_t(const TTime& time)
-{
-    TTimeIntervalSeconds interval;
-    TInt err = time.SecondsFrom(UnixEpochOffset, interval);
-    if (err || interval.Int() < 0)
-        return (time_t) 0;
-    return (time_t) interval.Int();
-}
-
-TTime qt_symbian_time_t_To_TTime(time_t time)
-{
-    return UnixEpochOffset + TTimeIntervalSeconds(time);
-}
-#endif //Q_OS_SYMBIAN
-
 #endif // QT_BOOTSTRAPPED
 
 QT_END_NAMESPACE
diff --git a/src/corelib/tools/qdatetime_p.h b/src/corelib/tools/qdatetime_p.h
index da062a3..9297246 100644
--- a/src/corelib/tools/qdatetime_p.h
+++ b/src/corelib/tools/qdatetime_p.h
@@ -274,13 +274,6 @@ Q_CORE_EXPORT bool operator==(const QDateTimeParser::SectionNode &s1, const QDat
 Q_DECLARE_OPERATORS_FOR_FLAGS(QDateTimeParser::Sections)
 Q_DECLARE_OPERATORS_FOR_FLAGS(QDateTimeParser::FieldInfo)
 
-#ifdef Q_OS_SYMBIAN
-QDateTime qt_symbian_TTime_To_QDateTime(const TTime& time);
-TTime qt_symbian_QDateTime_To_TTime(const QDateTime& datetime);
-time_t qt_symbian_TTime_To_time_t(const TTime& time);
-TTime qt_symbian_time_t_To_TTime(time_t time);
-#endif //Q_OS_SYMBIAN
-
 #endif // QT_BOOTSTRAPPED
 
 QT_END_NAMESPACE
diff --git a/src/corelib/tools/qelapsedtimer.cpp b/src/corelib/tools/qelapsedtimer.cpp
index ae5b78b..352cb54 100644
--- a/src/corelib/tools/qelapsedtimer.cpp
+++ b/src/corelib/tools/qelapsedtimer.cpp
@@ -138,7 +138,7 @@ QT_BEGIN_NAMESPACE
 
     \value SystemTime         The human-readable system time. This clock is not monotonic.
     \value MonotonicClock     The system's monotonic clock, usually found in Unix systems. This clock is monotonic and does not overflow.
-    \value TickCounter        The system's tick counter, used on Windows and Symbian systems. This clock may overflow.
+    \value TickCounter        The system's tick counter, used on Windows systems. This clock may overflow.
     \value MachAbsoluteTime   The Mach kernel's absolute time (Mac OS X). This clock is monotonic and does not overflow.
     \value PerformanceCounter The high-resolution performance counter provided by Windows. This clock is monotonic and does not overflow.
 
@@ -164,7 +164,7 @@ QT_BEGIN_NAMESPACE
 
     The tick counter clock type is based on the system's or the processor's
     tick counter, multiplied by the duration of a tick. This clock type is
-    used on Windows and Symbian platforms. If the high-precision performance
+    used on Windows platforms. If the high-precision performance
     counter is available on Windows, the \tt{PerformanceCounter} clock type
     is used instead.
 
@@ -178,12 +178,6 @@ QT_BEGIN_NAMESPACE
     milliseconds. When comparing such values, it's recommended that the high
     32 bits of the millisecond count be masked off.
 
-    On Symbian systems, the overflow happens after 2^32 ticks, the duration
-    of which can be obtained from the platform HAL using the constant
-    HAL::ENanoTickPeriod. When comparing values between processes, it's
-    necessary to divide the value by the tick duration and mask off the high
-    32 bits.
-
     \section2 MachAbsoluteTime
 
     This clock type is based on the absolute time presented by Mach kernels,
diff --git a/src/corelib/tools/qelapsedtimer_symbian.cpp b/src/corelib/tools/qelapsedtimer_symbian.cpp
deleted file mode 100644
index de515b3..0000000
--- a/src/corelib/tools/qelapsedtimer_symbian.cpp
+++ /dev/null
@@ -1,131 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qelapsedtimer.h"
-#include "qpair.h"
-#include <e32std.h>
-#include <sys/time.h>
-#include <hal.h>
-
-QT_BEGIN_NAMESPACE
-
-// return quint64 to avoid sign-extension
-static quint64 getMicrosecondFromTick()
-{
-    static TInt nanokernel_tick_period;
-    if (!nanokernel_tick_period)
-        HAL::Get(HAL::ENanoTickPeriod, nanokernel_tick_period);
-
-    static quint32 highdword = 0;
-    static quint32 lastval = 0;
-    quint32 val = User::NTickCount();
-    if (val < lastval)
-        ++highdword;
-    lastval = val;
-
-    return nanokernel_tick_period * (val | (quint64(highdword) << 32));
-}
-
-timeval qt_gettime()
-{
-    timeval tv;
-    quint64 now = getMicrosecondFromTick();
-    tv.tv_sec = now / 1000000;
-    tv.tv_usec = now % 1000000;
-
-    return tv;
-}
-
-QElapsedTimer::ClockType QElapsedTimer::clockType()
-{
-    return TickCounter;
-}
-
-bool QElapsedTimer::isMonotonic()
-{
-    return true;
-}
-
-void QElapsedTimer::start()
-{
-    t1 = getMicrosecondFromTick();
-    t2 = 0;
-}
-
-qint64 QElapsedTimer::restart()
-{
-    qint64 oldt1 = t1;
-    t1 = getMicrosecondFromTick();
-    t2 = 0;
-    return (t1 - oldt1) / 1000;
-}
-
-qint64 QElapsedTimer::nsecsElapsed() const
-{
-    return (getMicrosecondFromTick() - t1) * 1000;
-}
-
-qint64 QElapsedTimer::elapsed() const
-{
-    return (getMicrosecondFromTick() - t1) / 1000;
-}
-
-qint64 QElapsedTimer::msecsSinceReference() const
-{
-    return t1 / 1000;
-}
-
-qint64 QElapsedTimer::msecsTo(const QElapsedTimer &other) const
-{
-    return (other.t1 - t1) / 1000;
-}
-
-qint64 QElapsedTimer::secsTo(const QElapsedTimer &other) const
-{
-    return msecsTo(other) / 1000000;
-}
-
-bool operator<(const QElapsedTimer &v1, const QElapsedTimer &v2)
-{
-    return (v1.t1 - v2.t1) < 0;
-}
-
-QT_END_NAMESPACE
diff --git a/src/corelib/tools/qlocale.cpp b/src/corelib/tools/qlocale.cpp
index 2def77e..403a0ad 100644
--- a/src/corelib/tools/qlocale.cpp
+++ b/src/corelib/tools/qlocale.cpp
@@ -76,11 +76,6 @@ QT_END_NAMESPACE
 
 QT_BEGIN_NAMESPACE
 
-#if defined(Q_OS_SYMBIAN)
-void qt_symbianUpdateSystemPrivate();
-void qt_symbianInitSystemLocale();
-#endif
-
 #ifndef QT_NO_SYSTEMLOCALE
 static QSystemLocale *_systemLocale = 0;
 Q_GLOBAL_STATIC_WITH_ARGS(QSystemLocale, QSystemLocale_globalSystemLocale, (true))
@@ -474,9 +469,6 @@ static const QSystemLocale *systemLocale()
 {
     if (_systemLocale)
         return _systemLocale;
-#if defined(Q_OS_SYMBIAN)
-    qt_symbianInitSystemLocale();
-#endif
     return QSystemLocale_globalSystemLocale();
 }
 
@@ -491,10 +483,6 @@ void QLocalePrivate::updateSystemPrivate()
 
     *system_lp = *sys_locale->fallbackLocale().d();
 
-#if defined(Q_OS_SYMBIAN)
-    qt_symbianUpdateSystemPrivate();
-#endif
-
     QVariant res = sys_locale->query(QSystemLocale::LanguageId, QVariant());
     if (!res.isNull()) {
         system_lp->m_language_id = res.toInt();
diff --git a/src/corelib/tools/qlocale_p.h b/src/corelib/tools/qlocale_p.h
index 66daf8e..d6a0a3b 100644
--- a/src/corelib/tools/qlocale_p.h
+++ b/src/corelib/tools/qlocale_p.h
@@ -59,10 +59,6 @@
 
 #include "qlocale.h"
 
-#if defined(Q_OS_SYMBIAN) && !defined(QT_NO_SYSTEMLOCALE)
-class CEnvironmentChangeNotifier;
-#endif
-
 QT_BEGIN_NAMESPACE
 
 struct Q_CORE_EXPORT QLocalePrivate
@@ -257,20 +253,6 @@ inline char QLocalePrivate::digitToCLocale(const QChar &in) const
     return 0;
 }
 
-#if defined(Q_OS_SYMBIAN) && !defined(QT_NO_SYSTEMLOCALE)
-class QEnvironmentChangeNotifier
-{
-public:
-    QEnvironmentChangeNotifier();
-    ~QEnvironmentChangeNotifier();
-
-    static TInt localeChanged(TAny *data);
-
-private:
-    CEnvironmentChangeNotifier *iChangeNotifier;
-};
-#endif
-
 QString qt_readEscapedFormatString(const QString &format, int *idx);
 bool qt_splitLocaleName(const QString &name, QString &lang, QString &script, QString &cntry);
 int qt_repeatCount(const QString &s, int i);
diff --git a/src/corelib/tools/qlocale_symbian.cpp b/src/corelib/tools/qlocale_symbian.cpp
deleted file mode 100644
index 3e9908f..0000000
--- a/src/corelib/tools/qlocale_symbian.cpp
+++ /dev/null
@@ -1,956 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** All rights reserved.
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtCore module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <QDate>
-#include <QLocale>
-#include <QTime>
-#include <QVariant>
-#include <QThread>
-#include <QStringList>
-
-#include <e32std.h>
-#include <e32const.h>
-#include <e32base.h>
-#include <e32property.h>
-#include <bacntf.h>
-#include "private/qcore_symbian_p.h"
-#include "private/qcoreapplication_p.h"
-#include "private/qlocale_p.h"
-#include <qdebug.h>
-
-QT_BEGIN_NAMESPACE
-
-static TExtendedLocale _s60Locale;
-
-// Type definitions for runtime resolved function pointers
-typedef void (*FormatFunc)(TTime&, TDes&, const TDesC&, const TLocale&);
-typedef TPtrC (*FormatSpecFunc)(TExtendedLocale&);
-
-// Runtime resolved functions
-static FormatFunc ptrTimeFormatL = NULL;
-static FormatSpecFunc ptrGetTimeFormatSpec = NULL;
-static FormatSpecFunc ptrGetLongDateFormatSpec = NULL;
-static FormatSpecFunc ptrGetShortDateFormatSpec = NULL;
-
-// Default functions if functions cannot be resolved
-static void defaultTimeFormatL(TTime&, TDes& des, const TDesC&, const TLocale&)
-{
-    des.Zero();
-}
-
-static TPtrC defaultFormatSpec(TExtendedLocale&)
-{
-    return TPtrC(KNullDesC);
-}
-
-/*
-  Definition of struct for mapping Symbian to ISO locale
-*/
-struct symbianToISO {
-    int symbian_language;
-    char iso_name[8];
-    char uilanguage[8];
-};
-
-
-/*
-  Mapping from Symbian to ISO locale.
-  NOTE: This array should be sorted by the first column!
-*/
-static const symbianToISO symbian_to_iso_list[] = {
-    { ELangEnglish,             "en_GB", "en" },    // 1
-    { ELangFrench,              "fr_FR", "fr" },    // 2
-    { ELangGerman,              "de_DE", "de" },    // 3
-    { ELangSpanish,             "es_ES", "es" },    // 4
-    { ELangItalian,             "it_IT", "it" },    // 5
-    { ELangSwedish,             "sv_SE", "sv" },    // 6
-    { ELangDanish,              "da_DK", "da" },    // 7
-    { ELangNorwegian,           "nb_NO", "nb" },    // 8
-    { ELangFinnish,             "fi_FI", "fi" },    // 9
-    { ELangAmerican,            "en_US", "en-US" }, // 10
-    { ELangPortuguese,          "pt_PT", "pt" },    // 13
-    { ELangTurkish,             "tr_TR", "tr" },    // 14
-    { ELangIcelandic,           "is_IS", "is" },    // 15
-    { ELangRussian,             "ru_RU", "ru" },    // 16
-    { ELangHungarian,           "hu_HU", "hu" },    // 17
-    { ELangDutch,               "nl_NL", "nl" },    // 18
-    { ELangCzech,               "cs_CZ", "cs" },    // 25
-    { ELangSlovak,              "sk_SK", "sk" },    // 26
-    { ELangPolish,              "pl_PL", "pl" },    // 27
-    { ELangSlovenian,           "sl_SI", "sl" },    // 28
-    { ELangTaiwanChinese,       "zh_TW", "zh-TW" }, // 29
-    { ELangHongKongChinese,     "zh_HK", "zh-HK" }, // 30
-    { ELangPrcChinese,          "zh_CN", "zh" },    // 31
-    { ELangJapanese,            "ja_JP", "ja" },    // 32
-    { ELangThai,                "th_TH", "th" },    // 33
-    { ELangArabic,              "ar_AE", "ar" },    // 37
-    { ELangTagalog,             "tl_PH", "tl" },    // 39
-    { ELangBulgarian,           "bg_BG", "bg" },    // 42
-    { ELangCatalan,             "ca_ES", "ca" },    // 44
-    { ELangCroatian,            "hr_HR", "hr" },    // 45
-    { ELangEstonian,            "et_EE", "et" },    // 49
-    { ELangFarsi,               "fa_IR", "fa" },    // 50
-    { ELangCanadianFrench,      "fr_CA", "fr-CA" }, // 51
-    { ELangGreek,               "el_GR", "el" },    // 54
-    { ELangHebrew,              "he_IL", "he" },    // 57
-    { ELangHindi,               "hi_IN", "hi" },    // 58
-    { ELangIndonesian,          "id_ID", "id" },    // 59
-    { 63/*ELangKazakh*/,        "kk_KZ", "kk" },    // 63
-    { ELangKorean,              "ko_KO", "ko" },    // 65
-    { ELangLatvian,             "lv_LV", "lv" },    // 67
-    { ELangLithuanian,          "lt_LT", "lt" },    // 68
-    { ELangMalay,               "ms_MY", "ms" },    // 70
-    { ELangNorwegianNynorsk,    "nn_NO", "nn" },    // 75
-    { ELangBrazilianPortuguese, "pt_BR", "pt-BR" }, // 76
-    { ELangRomanian,            "ro_RO", "ro" },    // 78
-    { ELangSerbian,             "sr_RS", "sr" },    // 79
-    { ELangLatinAmericanSpanish,"es_419", "es-419" },// 83
-    { ELangUkrainian,           "uk_UA", "uk" },    // 93
-    { ELangUrdu,                "ur_PK", "ur" },    // 94 - India/Pakistan
-    { ELangVietnamese,          "vi_VN", "vi" },    // 96
-#ifdef __E32LANG_H__
-// 5.0
-    { ELangBasque,              "eu_ES", "eu" },    // 102
-    { ELangGalician,            "gl_ES", "gl" },    // 103
-#endif
-#if !defined(__SERIES60_31__)
-    { ELangEnglish_Apac,        "en_GB", "en" },     // 129
-    { ELangEnglish_Taiwan,      "en_TW", "en-TW" },  // 157 ### Not supported by CLDR
-    { ELangEnglish_HongKong,    "en_HK", "en-HK" },  // 158
-    { ELangEnglish_Prc,         "en_CN", "en-CN" },  // 159 ### Not supported by CLDR
-    { ELangEnglish_Japan,       "en_JP", "en" },     // 160 ### Not supported by CLDR
-    { ELangEnglish_Thailand,    "en_TH", "en" },     // 161 ### Not supported by CLDR
-    { 230/*ELangEnglish_India*/,"en_IN", "en" },     // 230
-    { ELangMalay_Apac,          "ms_MY", "ms" },     // 326
-#endif
-    { 327/*ELangIndonesian_Apac*/, "id_ID", "id" }   // 327 - appeared in Symbian^3
-};
-
-enum LocaleNameType {
-    ISO,
-    UILanguage
-};
-
-QByteArray qt_resolveSymbianLocaleName(int code, LocaleNameType type)
-{
-    //Number of Symbian to ISO locale mappings
-    static const int symbian_to_iso_count
-        = sizeof(symbian_to_iso_list)/sizeof(symbianToISO);
-
-    int cmp = code - symbian_to_iso_list[0].symbian_language;
-    if (cmp < 0)
-        return 0;
-
-    if (cmp == 0) {
-        if (type == ISO)
-            return symbian_to_iso_list[0].iso_name;
-        return symbian_to_iso_list[0].uilanguage;
-    }
-
-    int begin = 0;
-    int end = symbian_to_iso_count;
-
-    while (end - begin > 1) {
-        uint mid = (begin + end)/2;
-
-        const symbianToISO *elt = symbian_to_iso_list + mid;
-        int cmp = code - elt->symbian_language;
-        if (cmp < 0) {
-            end = mid;
-        } else if (cmp > 0) {
-            begin = mid;
-        } else {
-            if (type == ISO)
-                return elt->iso_name;
-            return elt->uilanguage;
-        }
-    }
-
-    return 0;
-}
-
-/*!
-    Returns ISO name corresponding to the Symbian locale code \a sys_fmt.
-*/
-QByteArray qt_symbianLocaleName(int code)
-{
-    return qt_resolveSymbianLocaleName(code, ISO);
-}
-
-// order is: normal, abbr, nmode, nmode+abbr
-static const char *us_locale_dep[] = {
-    "MM", "dd", "yyyy", "MM", "dd",
-    "M", "d", "yy", "M", "d",
-    "MMMM", "dd", "yyyy", "MMMM", "dd",
-    "MMM", "d", "yy", "MMM", "d" };
-
-static const char *eu_locale_dep[] = {
-    "dd", "MM", "yyyy", "dd", "MM",
-    "d", "M", "yy", "d", "M",
-    "dd", "MMMM", "yyyy", "dd", "MMMM",
-    "d", "MMM", "yy", "d", "MMM" };
-
-static const char *jp_locale_dep[] = {
-    "yyyy", "MM", "dd", "MM", "dd",
-    "yy", "M", "d", "M", "d",
-    "yyyy", "MMMM", "dd", "MMMM", "dd",
-    "yy", "MMM", "d", "MMM", "d" };
-
-/*!
-    Returns a Qt version of the given \a sys_fmt Symbian locale format string.
-*/
-static QString s60ToQtFormat(const QString &sys_fmt)
-{
-    TLocale *locale = _s60Locale.GetLocale();
-
-    QString result;
-    QString other;
-    QString qtformatchars = QString::fromLatin1("adhmsyzAHM");
-
-    QChar c;
-    int i = 0;
-    bool open_escape = false;
-    bool abbrev_next = false;
-    bool locale_indep_ordering = false;
-    bool minus_mode = false;
-    bool plus_mode = false;
-    bool n_mode = false;
-    TTimeFormat tf = locale->TimeFormat();
-
-    while (i < sys_fmt.size()) {
-
-        c = sys_fmt.at(i);
-
-        // let formatting thru
-        if (c.unicode() == '%') {
-            // if we have gathered string, concat it
-            if (!other.isEmpty()) {
-                result += other;
-                other.clear();
-            }
-            // if we have open escape, end it
-            if (open_escape) {
-                result += QLatin1Char('\'');
-                open_escape = false;
-            }
-
-            ++i;
-            if (i >= sys_fmt.size())
-                break;
-
-            c = sys_fmt.at(i);
-
-            // process specials
-            abbrev_next = c.unicode() == '*';
-            plus_mode = c.unicode() == '+';
-            minus_mode = c.unicode() == '-';
-
-            if (abbrev_next || plus_mode || minus_mode) {
-                ++i;
-                if (i >= sys_fmt.size())
-                    break;
-
-                c = sys_fmt.at(i);
-
-                if (plus_mode || minus_mode) {
-                    // break on undefined plus/minus mode
-                    if (c.unicode() != 'A' && c.unicode() != 'B')
-                        break;
-                }
-            }
-
-            switch (c.unicode()) {
-                case 'F':
-                {
-                    // locale indep mode on
-                    locale_indep_ordering = true;
-                    break;
-                }
-
-                case '/':
-                {
-                    // date sep 0-3
-                    ++i;
-                    if (i >= sys_fmt.size())
-                        break;
-
-                    c = sys_fmt.at(i);
-                    if (c.isDigit() && c.digitValue() <= 3) {
-                        TChar s = locale->DateSeparator(c.digitValue());
-                        TUint val = s;
-                        // some indexes return zero for empty
-                        if (val > 0)
-                            result += QChar(val);
-                    }
-                    break;
-                }
-
-                case 'D':
-                {
-                    if (!locale_indep_ordering)
-                        break;
-
-                    if (!abbrev_next)
-                        result += QLatin1String("dd");
-                    else
-                        result += QLatin1Char('d');
-
-                    break;
-                }
-
-                case 'M':
-                {
-                    if (!locale_indep_ordering)
-                        break;
-
-                    if (!n_mode) {
-                        if (!abbrev_next)
-                            result += QLatin1String("MM");
-                        else
-                            result += QLatin1String("M");
-                    } else {
-                        if (!abbrev_next)
-                            result += QLatin1String("MMMM");
-                        else
-                            result += QLatin1String("MMM");
-                    }
-
-                    break;
-                }
-
-                case 'N':
-                {
-                    n_mode = true;
-
-                    if (!locale_indep_ordering)
-                        break;
-
-                    if (!abbrev_next)
-                        result += QLatin1String("MMMM");
-                    else
-                        result += QLatin1String("MMM");
-
-                    break;
-                }
-
-                case 'Y':
-                {
-                    if (!locale_indep_ordering)
-                        break;
-
-                    if (!abbrev_next)
-                        result += QLatin1String("yyyy");
-                    else
-                        result += QLatin1String("yy");
-
-                    break;
-                }
-
-                case 'E':
-                {
-                    if (!abbrev_next)
-                        result += QLatin1String("dddd");
-                    else
-                        result += QLatin1String("ddd");
-
-                    break;
-                }
-
-                case ':':
-                {
-                    // timesep 0-3
-                    ++i;
-                    if (i >= sys_fmt.size())
-                        break;
-
-                    c = sys_fmt.at(i);
-                    if (c.isDigit() && c.digitValue() <= 3) {
-                        TChar s = locale->TimeSeparator(c.digitValue());
-                        TUint val = s;
-                        // some indexes return zero for empty
-                        if (val > 0)
-                            result += QChar(val);
-                    }
-
-                    break;
-                }
-
-                case 'J':
-                {
-                    if (tf == ETime24 && !abbrev_next)
-                        result += QLatin1String("hh");
-                    else
-                        result += QLatin1Char('h');
-
-                    break;
-                }
-
-                case 'H':
-                {
-                    if (!abbrev_next)
-                        result += QLatin1String("hh");
-                    else
-                        result += QLatin1Char('h');
-
-                    break;
-                }
-
-                case 'I':
-                {
-                    result += QLatin1Char('h');
-                    break;
-                }
-
-                case 'T':
-                {
-                    if (!abbrev_next)
-                        result += QLatin1String("mm");
-                    else
-                        result += QLatin1Char('m');
-
-                    break;
-                }
-
-                case 'S':
-                {
-                    if (!abbrev_next)
-                        result += QLatin1String("ss");
-                    else
-                        result += QLatin1Char('s');
-
-                    break;
-                }
-
-                case 'B':
-                {
-                    // only done for 12h clock
-                    if (tf == ETime24)
-                        break;
-                }
-
-                    // fallthru to A
-                case 'A': {
-                    // quickie to get capitalization, can't use s60 string as is because Qt 'hh' format's am/pm logic
-                    TAmPmName ampm = TAmPmName();
-                    TChar first(ampm[0]);
-                    QString qtampm = QString::fromLatin1(first.IsUpper() ? "AP" : "ap");
-
-                    int pos = locale->AmPmSymbolPosition();
-
-                    if ((minus_mode && pos != ELocaleBefore) ||
-                        (plus_mode && pos != ELocaleAfter))
-                        break;
-
-                    if (!abbrev_next && locale->AmPmSpaceBetween()) {
-                        if (pos == ELocaleBefore)
-                            qtampm.append(QLatin1Char(' '));
-                        else
-                            qtampm.prepend(QLatin1Char(' '));
-                    }
-
-                    result += qtampm;
-                    }
-                    break;
-
-                case '.': {
-                        // decimal sep
-                        TChar s = locale->DecimalSeparator();
-                        TUint val = s;
-                        if (val > 0)
-                            result += QChar(val);
-                    }
-                    break;
-
-                case 'C':
-                {
-                    // six digits in s60, three digits in qt
-                    if (!abbrev_next) {
-                        result += QLatin1String("zzz");
-                    } else {
-                        // next char is number from 0-6, how many digits to display
-                        ++i;
-                        if (i >= sys_fmt.size())
-                            break;
-
-                        c = sys_fmt.at(i);
-
-                        if (c.isDigit()) {
-                            // try to match wanted digits
-                            QChar val(c.digitValue());
-
-                            if (val >= 3) {
-                                result += QLatin1String("zzz");
-                            } else if (val > 0) {
-                                result += QLatin1Char('z');
-                            }
-                        }
-                    }
-                    break;
-                }
-
-                // these cases fallthru
-                case '1':
-                case '2':
-                case '3':
-                case '4':
-                case '5':
-                {
-
-                    // shouldn't parse these with %F
-                    if (locale_indep_ordering)
-                        break;
-
-                    TDateFormat df = locale->DateFormat();
-
-                    const char **locale_dep;
-                    switch (df) {
-                        default: // fallthru to american
-                        case EDateAmerican:
-                            locale_dep = us_locale_dep;
-                            break;
-                        case EDateEuropean:
-                            locale_dep = eu_locale_dep;
-                            break;
-                        case EDateJapanese:
-                            locale_dep = jp_locale_dep;
-                            break;
-                    }
-                    int offset = 0;
-                    if (abbrev_next)
-                        offset += 5;
-                    if (n_mode)
-                        offset += 10;
-
-                    result += QLatin1String(locale_dep[offset + (c.digitValue()-1)]);
-                    break;
-                }
-
-                case '%': // fallthru percent
-                {
-                // any junk gets copied as is
-                }
-                default:
-                {
-                    result += c;
-                    break;
-                }
-
-                case 'Z': // Qt doesn't support these :(
-                case 'X':
-                case 'W':
-                {
-                    break;
-                }
-            }
-        } else {
-            // double any single quotes, don't begin escape
-            if (c.unicode() == '\'') {
-                // end open escape
-                if (open_escape) {
-                    result += other;
-                    other.clear();
-                    result += QLatin1Char('\'');
-                    open_escape = false;
-                }
-
-                other += c;
-            }
-
-            // gather chars and escape them in one go if any format chars are found
-            if (!open_escape && qtformatchars.indexOf(c) != -1) {
-                result += QLatin1Char('\'');
-                open_escape = true;
-            }
-            other += c;
-        }
-
-        ++i;
-    }
-
-    if (!other.isEmpty())
-        result += other;
-    if (open_escape)
-        result += QLatin1Char('\'');
-
-    return result;
-}
-
-/*!
-    Retrieves Symbian locale decimal separator.
-*/
-static QString symbianDecimalPoint()
-{
-    TLocale *locale = _s60Locale.GetLocale();
-
-    TChar decPoint = locale->DecimalSeparator();
-    int val = decPoint;
-    return QChar(val);
-}
-
-/*!
-    Retrieves Symbian locale group separator.
-*/
-static QString symbianGroupSeparator()
-{
-    TLocale *locale = _s60Locale.GetLocale();
-
-    TChar grpSep = locale->ThousandsSeparator();
-    int val = grpSep;
-    return QChar(val);
-}
-
-/*!
-    Retrieves Symbian locale zero digit.
-*/
-static QString symbianZeroDigit()
-{
-    TLocale *locale = _s60Locale.GetLocale();
-
-    // TDigitType enumeration value returned by TLocale
-    // will always correspond to zero digit unicode value.
-    TDigitType digit = locale->DigitType();
-    return QChar(digit);
-}
-
-/*!
-    Retrieves a day name from Symbian locale. The \a day is an integer
-    from 1 to 7. When \a short_format is true the method returns
-    the day in short format. Otherwise it returns the day in a long format.
-*/
-static QString symbianDayName(int day, bool short_format)
-{
-    day -= 1;
-
-    if (day < 0 || day > 6)
-        return QString();
-
-    if (short_format) {
-        return qt_TDes2QString(TDayNameAbb(TDay(day)));
-    } else {
-        return qt_TDes2QString(TDayName(TDay(day)));
-    }
-}
-
-/*!
-    Retrieves a month name from Symbian locale. The \a month is an integer
-    from 1 to 12. When \a short_format is true the method returns
-    the month in short format. Otherwise it returns the month in a long format.
-*/
-static QString symbianMonthName(int month, bool short_format)
-{
-    month -= 1;
-    if (month < 0 || month > 11)
-        return QString();
-
-    if (short_format) {
-        return qt_TDes2QString(TMonthNameAbb(TMonth(month)));
-    } else {
-        return qt_TDes2QString(TMonthName(TMonth(month)));
-    }
-}
-
-/*!
-    Retrieves date format from Symbian locale and
-    transforms it to Qt format.
-
-    When \a short_format is true the method returns
-    short date format. Otherwise it returns the long format.
-*/
-static QString symbianDateFormat(bool short_format)
-{
-    TPtrC dateFormat;
-
-    if (short_format) {
-        dateFormat.Set(ptrGetShortDateFormatSpec(_s60Locale));
-    } else {
-        dateFormat.Set(ptrGetLongDateFormatSpec(_s60Locale));
-    }
-
-    return s60ToQtFormat(qt_TDesC2QString(dateFormat));
-}
-
-/*!
-    Retrieves time format from Symbian locale and
-    transforms it to Qt format.
-*/
-static QString symbianTimeFormat()
-{
-    return s60ToQtFormat(qt_TDesC2QString(ptrGetTimeFormatSpec(_s60Locale)));
-}
-
-/*!
-    Returns localized string representation of given \a date
-    formatted with Symbian locale date format.
-
-    If \a short_format is true the format will be a short version.
-    Otherwise it uses a longer version.
-*/
-static QString symbianDateToString(const QDate &date, bool short_format)
-{
-    int month = date.month() - 1;
-    int day = date.day() - 1;
-    int year = date.year();
-
-    TDateTime dateTime;
-    dateTime.Set(year, TMonth(month), day, 0, 0, 0, 0);
-
-    TTime timeStr(dateTime);
-    TBuf<KMaxLongDateFormatSpec*2> buffer;
-
-    TPtrC dateFormat;
-    if (short_format) {
-        dateFormat.Set(ptrGetShortDateFormatSpec(_s60Locale));
-    } else {
-        dateFormat.Set(ptrGetLongDateFormatSpec(_s60Locale));
-    }
-
-    TRAPD(err, ptrTimeFormatL(timeStr, buffer, dateFormat, *_s60Locale.GetLocale());)
-
-    if (err == KErrNone)
-        return qt_TDes2QString(buffer);
-    else
-        return QString();
-}
-
-/*!
-    Returns localized string representation of given \a time
-    formatted with Symbian locale time format.
-*/
-static QString symbianTimeToString(const QTime &time)
-{
-    int hour = time.hour();
-    int minute = time.minute();
-    int second = time.second();
-    int milliseconds = 0;
-
-    TDateTime dateTime;
-    dateTime.Set(0, TMonth(0), 0, hour, minute, second, milliseconds);
-
-    TTime timeStr(dateTime);
-    TBuf<KMaxTimeFormatSpec*2> buffer;
-
-    TRAPD(err, ptrTimeFormatL(
-        timeStr,
-        buffer,
-        ptrGetTimeFormatSpec(_s60Locale),
-        *_s60Locale.GetLocale());
-    )
-
-    if (err == KErrNone)
-        return qt_TDes2QString(buffer);
-    else
-        return QString();
-}
-
-/*!
-    Returns the measurement system stored in Symbian locale
-
-    \sa QLocale::MeasurementSystem
-*/
-static QLocale::MeasurementSystem symbianMeasurementSystem()
-{
-    TLocale *locale = _s60Locale.GetLocale();
-
-    TUnitsFormat unitFormat = locale->UnitsGeneral();
-    if (unitFormat == EUnitsImperial)
-        return QLocale::ImperialSystem;
-    else
-        return QLocale::MetricSystem;
-}
-
-void qt_symbianUpdateSystemPrivate()
-{
-    // load system data before query calls
-    _s60Locale.LoadSystemSettings();
-}
-
-void qt_symbianInitSystemLocale()
-{
-    static QBasicAtomicInt initDone = Q_BASIC_ATOMIC_INITIALIZER(0);
-    if (initDone == 2)
-        return;
-    if (initDone.testAndSetRelaxed(0, 1)) {
-        // Initialize platform version dependent function pointers
-        ptrTimeFormatL = reinterpret_cast<FormatFunc>
-            (qt_resolveS60PluginFunc(S60Plugin_TimeFormatL));
-        ptrGetTimeFormatSpec = reinterpret_cast<FormatSpecFunc>
-            (qt_resolveS60PluginFunc(S60Plugin_GetTimeFormatSpec));
-        ptrGetLongDateFormatSpec = reinterpret_cast<FormatSpecFunc>
-            (qt_resolveS60PluginFunc(S60Plugin_GetLongDateFormatSpec));
-        ptrGetShortDateFormatSpec = reinterpret_cast<FormatSpecFunc>
-            (qt_resolveS60PluginFunc(S60Plugin_GetShortDateFormatSpec));
-        if (!ptrTimeFormatL)
-            ptrTimeFormatL = &defaultTimeFormatL;
-        if (!ptrGetTimeFormatSpec)
-            ptrGetTimeFormatSpec = &defaultFormatSpec;
-        if (!ptrGetLongDateFormatSpec)
-            ptrGetLongDateFormatSpec = &defaultFormatSpec;
-        if (!ptrGetShortDateFormatSpec)
-            ptrGetShortDateFormatSpec = &defaultFormatSpec;
-        bool ret = initDone.testAndSetRelease(1, 2);
-        Q_ASSERT(ret);
-        Q_UNUSED(ret);
-    }
-    while(initDone != 2)
-        QThread::yieldCurrentThread();
-}
-
-QLocale QSystemLocale::fallbackLocale() const
-{
-    TLanguage lang = User::Language();
-    QString locale = QLatin1String(qt_symbianLocaleName(lang));
-    return QLocale(locale);
-}
-
-static QStringList symbianUILanguages()
-{
-    TLanguage lang = User::Language();
-    QString s = QLatin1String(qt_resolveSymbianLocaleName(lang, UILanguage));
-    return QStringList(s);
-}
-
-QVariant QSystemLocale::query(QueryType type, QVariant in = QVariant()) const
-{
-    switch(type) {
-        case DecimalPoint:
-            return symbianDecimalPoint();
-        case GroupSeparator:
-            return symbianGroupSeparator();
-
-        case ZeroDigit:
-             return symbianZeroDigit();
-
-        case DayNameLong:
-        case DayNameShort:
-            return symbianDayName(in.toInt(), (type == DayNameShort) );
-
-        case MonthNameLong:
-        case MonthNameShort:
-            return symbianMonthName(in.toInt(), (type == MonthNameShort) );
-
-        case DateFormatLong:
-        case DateFormatShort:
-            return symbianDateFormat( (type == DateFormatShort) );
-        case TimeFormatLong:
-        case TimeFormatShort:
-            return symbianTimeFormat();
-        case DateTimeFormatLong:
-        case DateTimeFormatShort:
-            return QString(symbianDateFormat( (type == DateTimeFormatShort) ) + QLatin1Char(' ') + symbianTimeFormat());
-        case DateToStringShort:
-        case DateToStringLong:
-             return symbianDateToString(in.toDate(), (type == DateToStringShort) );
-        case TimeToStringShort:
-        case TimeToStringLong:
-             return symbianTimeToString(in.toTime());
-        case DateTimeToStringShort:
-        case DateTimeToStringLong: {
-                const QDateTime dt = in.toDateTime();
-                return QString(symbianDateToString(dt.date(), (type == DateTimeToStringShort) )
-                       + QLatin1Char(' ') + symbianTimeToString(dt.time()));
-            }
-        case MeasurementSystem:
-            return static_cast<int>(symbianMeasurementSystem());
-        case LanguageId:
-        case CountryId: {
-                TLanguage language = User::Language();
-                QString locale = QLatin1String(qt_symbianLocaleName(language));
-                QLocale::Language lang;
-                QLocale::Script script;
-                QLocale::Country cntry;
-                QLocalePrivate::getLangAndCountry(locale, lang, script, cntry);
-                if (type == LanguageId)
-                    return lang;
-                // few iso codes have no country and will use this
-                if (cntry == QLocale::AnyCountry)
-                    return fallbackLocale().country();
-
-                return cntry;
-            }
-        case ScriptId:
-            return QVariant(QLocale::AnyScript);
-        case NegativeSign:
-        case PositiveSign:
-            break;
-        case AMText:
-            return qt_TDes2QString(TAmPmName(TAmPm(EAm)));
-        case PMText:
-            return qt_TDes2QString(TAmPmName(TAmPm(EPm)));
-        case UILanguages:
-            return QVariant(symbianUILanguages());
-        default:
-            break;
-    }
-    return QVariant();
-}
-
-#if !defined(QT_NO_SYSTEMLOCALE)
-QEnvironmentChangeNotifier::QEnvironmentChangeNotifier()
-{
-    // Create the change notifier and install the callback function
-    const TCallBack callback(&QEnvironmentChangeNotifier::localeChanged, this);
-    QT_TRAP_THROWING(iChangeNotifier = CEnvironmentChangeNotifier::NewL(CActive::EPriorityStandard, callback));
-    iChangeNotifier->Start();
-}
-
-TInt QEnvironmentChangeNotifier::localeChanged(TAny *data)
-{
-    QEnvironmentChangeNotifier *that = reinterpret_cast<QEnvironmentChangeNotifier *>(data);
-
-    TInt flag = that->iChangeNotifier->Change();
-    if (flag & EChangesLocale) {
-        static bool first = true;
-        if (!first) { // skip the first notification on app startup
-            QT_TRYCATCH_LEAVING(QLocalePrivate::updateSystemPrivate());
-            QT_TRYCATCH_LEAVING(QCoreApplication::postEvent(qApp, new QEvent(QEvent::LocaleChange)));
-        }
-        first = false;
-    }
-    return KErrNone;
-}
-
-QEnvironmentChangeNotifier::~QEnvironmentChangeNotifier()
-{
-    delete iChangeNotifier;
-}
-#endif
-
-QT_END_NAMESPACE
diff --git a/src/corelib/tools/qstring.cpp b/src/corelib/tools/qstring.cpp
index 2f9284e..3e92df7 100644
--- a/src/corelib/tools/qstring.cpp
+++ b/src/corelib/tools/qstring.cpp
@@ -69,10 +69,6 @@
 #include <winnls.h>
 #endif
 
-#ifdef Q_OS_SYMBIAN
-#include <e32cmn.h>
-#endif
-
 #include <limits.h>
 #include <string.h>
 #include <stdlib.h>
@@ -4745,10 +4741,6 @@ int QString::localeAwareCompare_helper(const QChar *data1, int length1,
     CFRelease(thisString);
     CFRelease(otherString);
     return result;
-#elif defined(Q_OS_SYMBIAN)
-    TPtrC p1 = TPtrC16(reinterpret_cast<const TUint16 *>(data1), length1);
-    TPtrC p2 = TPtrC16(reinterpret_cast<const TUint16 *>(data2), length2);
-    return p1.CompareC(p2);
 #elif defined(Q_OS_UNIX)
 #  if defined(QT_USE_ICU)
     int res;
diff --git a/src/corelib/tools/tools.pri b/src/corelib/tools/tools.pri
index 13b597d..3740975 100644
--- a/src/corelib/tools/tools.pri
+++ b/src/corelib/tools/tools.pri
@@ -92,7 +92,6 @@ SOURCES += \
     SOURCES += tools/qelapsedtimer_mac.cpp
     OBJECTIVE_SOURCES += tools/qlocale_mac.mm
 }
-else:symbian:SOURCES += tools/qelapsedtimer_symbian.cpp tools/qlocale_symbian.cpp
 else:unix:SOURCES += tools/qelapsedtimer_unix.cpp tools/qlocale_unix.cpp
 else:win32:SOURCES += tools/qelapsedtimer_win.cpp tools/qlocale_win.cpp
 else:integrity:SOURCES += tools/qelapsedtimer_unix.cpp tools/qlocale_unix.cpp
@@ -128,5 +127,5 @@ INCLUDEPATH += ../3rdparty/md5 \
                ../3rdparty/md4
 
 # Note: libm should be present by default becaue this is C++
-!macx-icc:!vxworks:!symbian:unix:LIBS_PRIVATE += -lm
+!macx-icc:!vxworks:unix:LIBS_PRIVATE += -lm