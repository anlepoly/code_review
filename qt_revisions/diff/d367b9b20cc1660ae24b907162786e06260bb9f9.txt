diff --git a/release-tools/README b/release-tools/README
new file mode 100644
index 0000000..7f9cd6a
--- /dev/null
+++ b/release-tools/README
@@ -0,0 +1,180 @@
+1.  Introduction to installer scripts
+
+    Release-tools contains scripts to generate desktop installers based on
+    Qt Installer-Framework. Example configuration templates are provided but
+    actual content that is to be installed needs to be generated separately.
+
+    For detailed usage of the Qt Installer-Framework itself please refer to the
+    Qt Installer-Framework documentation.
+
+
+2.  Quick start
+
+    To create standalone offline installer use:
+
+    Linux:      python create_installer.py linux x86 offline        OR
+                python create_installer.py linux x86_64 offline
+
+    Mac:        python create_installer.py mac x86_64 offline
+
+    Windows:    python create_installer.py mac x86 offline
+
+
+    output:
+        - SDK installer executable will be generated into the scripts root directory.
+        - "repositories" directory will be generated into the scripts root directory
+          if offline installer is made. This contains complete repository
+          structure.
+
+
+3.  General requirements
+
+    Make sure you have the following tools installed:
+    - Python 2.6 or 2.7
+    - Win: win32api python module
+    - 7z
+
+    Build requirements:
+    - Linux/Mac: gcc toolchain
+    - Windows: MinGW/Visual Studio toolchain
+
+
+4.  Files
+
+    /create_installer.py
+        - main build script
+        - creates installer binary based on Qt Installer-Framework
+    /bldinstallercommon.py
+        - common utility functions
+    /bld_ifw_tools.py
+    /bld_ifw_tools_impl.py
+        - utilities to build static Qt and Installer-Framework
+    /configurations
+        - contains all configuration files
+    /configurations/pkg
+        - contains package templates that define the SDK structure
+    /configurations/config_qt5
+        - template files, e.g. icons, xml files
+    /configurations/linux
+        - contains Linux specific configuration files
+    /configurations/linux/common
+        - common configuration data for Linux installers
+    /configurations/linux/config.xml.template.linux
+        - config.xml template
+    /configurations/linux/installer-framework
+        - configuration file for building Qt Installer-Framework
+    /configurations/linux/x86_32
+        - configuration file that defines all the SDK packages to be included
+          and other installer specific data
+
+
+5.  Using the scripts
+
+    * General usage of the SDK/installer build script is as follows:
+        > python create_installer.py <platform> <configuration file>
+
+        The <platform> is one of the following: linux/mac/windows
+            - /configurations/linux
+            - /configurations/mac
+            - /configurations/lwindows
+
+        The <configuration file> must be found under /configurations/<platform>/
+
+    * If you wish to prebuild Installer-Framework (+ static Qt) for faster
+      development cycles use the following:
+
+        > python bld_ifw_tools.py <platform>
+
+        The <platform> is linux/mac/windows.
+        Open /configurations/<platform>/installer-framework file for build
+        configuration details.
+
+    * The create_installer.py will default to online installer which would
+      require online distribution server to be in use.
+      To create offline installer, use the following:
+
+        > python create_installer.py <platform> <configuration file> offline
+
+        Optional arguments:
+        devmode     # Note! this is enabled by default, will force to build IFW and static Qt. If this option is not used
+                    # then the pre-build package must be available and defined in [InstallerFrameworkTools]
+        testclient  # When online installer is build, make it use the alternative distribution server url instead
+
+
+6.  Package configuration file syntax:
+
+    * Syntax must conform to Python configuration file format.
+    * The package configuration file (e.g. /configurations/linux/x86_64) defines
+      the components that should be included in the SDK/installer.
+
+        [PackagesNamespace]
+        name:                   com.qt                                      # defines what sections in this config file should be treated as SDK components
+
+        [com.qt]                                                            # "com.qt" matches against the namespace defined above
+        root_component:         yes                                         # used when creating online installer, only the main component is used for online installer
+        version:                1.0.0
+        version_tag:            %SDK_VERSION_NUM%                           # substitution tag in .xml/.qs files, replace this tag with given version number
+
+        [com.qt.src]                                                        # "com.qt.src" matches against the namespace defined above
+        version:                1.0.0
+        version_tag:            %SDK_VERSION_NUM%
+
+        [com.qt.src.500]                                                    # this component contains actual data
+        archives:               meta-com.qt.src.500.1                       # comma separated list of archives (.7z) that should be included in this package
+        target_install_base:    /Src/Qt/5.0.0                               # base directory structure how data will be installed in installation directory
+        version:                5.0.0
+        version_tag:            %QT_VERSION_NUM%
+        package_default:        no                                          # this value will be put into the components package.xml file
+        [meta-com.qt.src.500.1]                                             # archive defined in the "archives" list above (section name can be anything)
+        archive_uri:            qt-everywhere-opensource-src-5.0.0.tar.gz   # source uri for the archive (see further explanation below..)
+        package_strip_dirs:     1                                           # if needed, the build script will strip unnecessary folder structure from the source archive and repackage it
+        target_install_dir:     /                                           # installation path, this will be appended into "target_install_base"
+        rpath_target:                                                       # the build script will patch RPath value if needed (Linux, Solaris). Leave empty if not needed
+        archive_name:           qt-everywhere-opensource-src-5.0.0.7z       # the final archive name, this will be used in "addDownloadableArchive" in installscript.qs
+
+        [com.qt.desktop]
+        version:                1.0.0
+        version_tag:            %SDK_VERSION_NUM%
+
+        [com.qt.desktop.qt]
+        version:                1.0.0
+        version_tag:            %SDK_VERSION_NUM%
+
+        [com.qt.desktop.qt.500]
+        version:                5.0.0
+        version_tag:            %QT_VERSION_NUM%
+
+        [com.qt.desktop.qt.500.gcc]
+        archives:               meta-com.qt.desktop.qt.500.gcc.1
+        target_install_base:    /Desktop/Qt/5.0.0/gcc
+        version:                5.0.0
+        version_tag:            %QT_VERSION_NUM%
+        package_default:        yes
+        [meta-com.qt.desktop.qt.500.gcc.1]
+        archive_uri:            qt-5.0.0-desktop-gcc.7z
+        package_strip_dirs:     4                                           # e.g. strip 4 directories from the "qt-5.0.0-desktop-gcc.7z" archive
+        target_install_dir:     /                                           # extract this archive "qt-5.0.0-desktop-gcc.7z" into the root ("/") of the SDK
+        rpath_target:           /lib                                        # patch the RPath value of binaries inside the archive "qt-5.0.0-desktop-gcc.7z". "/lib" points to the directory where the RPath value should point to
+        archive_name:           qt-5.0.0-desktop-gcc.7z
+
+
+        [OfflinePackageExcludeList]
+        package_list:                                                       # comma separated list of packages which to exclude from the offline installer (repositories will always contain all packages)
+
+        [SdkUpdateRepository]
+        repository_url:                                                     # url for distribution server when using online installer
+        repository_url_rnd:                                                 # if you build the installer with "testclient" switch, this url will be used instead, can be used for testing purposes
+
+        [TargetArchitechture]
+        instruction_set:        x86_32
+
+        [ConfigDir]
+        template_name:          config_qt5                                  # points to template directory: /configurations/<template_name>
+        target_dir:             config                                      # template save as name in the scripts root directory
+
+        [ConfigXml]
+        template_name:          config.xml.template.linux                   # define the config.xml template
+
+        [WorkingDirectories]
+        packages_dir:           pkg                                         # define from which directory to search for the package templates
+
diff --git a/release-tools/bld_ifw_tools.py b/release-tools/bld_ifw_tools.py
new file mode 100644
index 0000000..05d26dc
--- /dev/null
+++ b/release-tools/bld_ifw_tools.py
@@ -0,0 +1,51 @@
+#!/usr/bin/env python
+###############################################
+#
+# Copyright (C) 2012 Digia Plc
+# For any questions to Digia, please use contact form at http://qt.digia.com
+#
+# $QT_BEGIN_LICENSE:LGPL$
+# GNU Lesser General Public License Usage
+# This file may be used under the terms of the GNU Lesser General Public
+# License version 2.1 as published by the Free Software Foundation and
+# appearing in the file LICENSE.LGPL included in the packaging of this
+# file. Please review the following information to ensure the GNU Lesser
+# General Public License version 2.1 requirements will be met:
+# http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+#
+# GNU General Public License Usage
+# Alternatively, this file may be used under the terms of the GNU General
+# Public License version 3.0 as published by the Free Software Foundation
+# and appearing in the file LICENSE.GPL included in the packaging of this
+# file. Please review the following information to ensure the GNU General
+# Public License version 3.0 requirements will be met:
+# http://www.gnu.org/copyleft/gpl.html.
+#
+# $QT_END_LICENSE$
+#
+# If you have questions regarding the use of this file, please use
+# contact form at http://qt.digia.com
+#
+###############################################
+
+import sys
+import os
+import subprocess
+import ConfigParser
+import re
+import datetime
+import time
+from datetime import date
+import urllib
+import platform
+
+import bld_ifw_tools_impl
+
+if len(sys.argv) < 2:
+    print '*** platform identifier is needed as parameter: linux/mac/windows'
+    sys.exit(-1)
+
+platformIdentifier = sys.argv[1]
+bld_ifw_tools_impl.build_ifw('release', platformIdentifier)
+
+
diff --git a/release-tools/bld_ifw_tools_impl.py b/release-tools/bld_ifw_tools_impl.py
new file mode 100644
index 0000000..04a1fac
--- /dev/null
+++ b/release-tools/bld_ifw_tools_impl.py
@@ -0,0 +1,411 @@
+#!/usr/bin/env python
+###############################################
+#
+# Copyright (C) 2012 Digia Plc
+# For any questions to Digia, please use contact form at http://qt.digia.com
+#
+# $QT_BEGIN_LICENSE:LGPL$
+# GNU Lesser General Public License Usage
+# This file may be used under the terms of the GNU Lesser General Public
+# License version 2.1 as published by the Free Software Foundation and
+# appearing in the file LICENSE.LGPL included in the packaging of this
+# file. Please review the following information to ensure the GNU Lesser
+# General Public License version 2.1 requirements will be met:
+# http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+#
+# GNU General Public License Usage
+# Alternatively, this file may be used under the terms of the GNU General
+# Public License version 3.0 as published by the Free Software Foundation
+# and appearing in the file LICENSE.GPL included in the packaging of this
+# file. Please review the following information to ensure the GNU General
+# Public License version 3.0 requirements will be met:
+# http://www.gnu.org/copyleft/gpl.html.
+#
+# $QT_END_LICENSE$
+#
+# If you have questions regarding the use of this file, please use
+# contact form at http://qt.digia.com
+#
+###############################################
+
+import sys
+import os
+import sys
+import urllib
+import shutil
+import ConfigParser
+import bldinstallercommon
+
+DEVELOPMENT_MODE                    = False
+CONFIG_IFW                          = ''
+SCRIPT_ROOT_DIR                     = os.getcwd()
+PLATFORM_IDENTIFIER                 = ''
+MAKE_CMD                            = ''
+QT_QMAKE_BIN                        = ''
+QT_CONFIGURE_BIN                    = ''
+QT_SRC_PACKAGE_URL                  = ''
+QT_SRC_PACKAGE_URL_SAVE_AS          = ''
+QT_SOURCE_DIR                       = ''
+QT_BUILD_DIR                        = ''
+QT_INSTALLERFW_QT_CONFIGURE_LINE    = ''
+INSTALLER_FRAMEWORK_URL             = ''
+INSTALLER_FRAMEWORK_SOURCE_DIR      = ''
+INSTALLER_FRAMEWORK_BUILD_DIR       = ''
+INSTALLER_FRAMEWORK_VERSION_TAG     = ''
+INSTALLER_FRAMEWORK_QMAKE_ARGS      = ''
+INSTALLER_FRAMEWORK_ARCHIVE_NAME    = ''
+INSTALLERBASE_ARCHIVE_NAME          = ''
+
+
+###############################
+# function
+###############################
+def init_config():
+    global CONFIG_IFW
+    global MAKE_CMD
+    global QT_QMAKE_BIN
+    global QT_CONFIGURE_BIN
+    global QT_SRC_PACKAGE_URL
+    global QT_SRC_PACKAGE_URL_SAVE_AS
+    global QT_SOURCE_DIR
+    global QT_BUILD_DIR
+    global QT_INSTALLERFW_QT_CONFIGURE_LINE
+    global INSTALLER_FRAMEWORK_URL
+    global INSTALLER_FRAMEWORK_SOURCE_DIR
+    global INSTALLER_FRAMEWORK_BUILD_DIR
+    global INSTALLER_FRAMEWORK_VERSION_TAG
+    global INSTALLER_FRAMEWORK_QMAKE_ARGS
+    global INSTALLER_FRAMEWORK_ARCHIVE_NAME
+    global INSTALLERBASE_ARCHIVE_NAME
+
+    conf_path = SCRIPT_ROOT_DIR + os.sep + 'configurations' + os.sep + PLATFORM_IDENTIFIER + os.sep + 'installer-framework'
+    CONFIG_IFW = ConfigParser.ConfigParser()
+    CONFIG_IFW.readfp(open(conf_path))
+
+    print '----------------------------------------'
+    print 'Installer-Framework build configuration:'
+    print ''
+    print 'Configuration file: ' + conf_path
+    print ''
+
+    MAKE_CMD                            = bldinstallercommon.config_section_map(CONFIG_IFW,'make')['make_cmd']
+    QT_SRC_PACKAGE_URL                  = bldinstallercommon.config_section_map(CONFIG_IFW,'QtForInstallerFramework')['qt_src_package_url']
+    QT_SRC_PACKAGE_URL_SAVE_AS          = SCRIPT_ROOT_DIR + os.sep + os.path.basename(QT_SRC_PACKAGE_URL)
+    QT_SOURCE_DIR                       = SCRIPT_ROOT_DIR + os.sep + bldinstallercommon.config_section_map(CONFIG_IFW,'QtForInstallerFramework')['qt_source_dir']
+    QT_BUILD_DIR                        = SCRIPT_ROOT_DIR + os.sep + bldinstallercommon.config_section_map(CONFIG_IFW,'QtForInstallerFramework')['qt_build_dir']
+    QT_INSTALLERFW_QT_CONFIGURE_LINE    = bldinstallercommon.config_section_map(CONFIG_IFW,'QtForInstallerFramework')['qt_installerfw_qt_configure_line']
+
+    QT_QMAKE_BIN                            = 'qmake'
+    if bldinstallercommon.is_win_platform():
+        QT_QMAKE_BIN += '.exe'
+    QT_CONFIGURE_BIN                        = QT_SOURCE_DIR + os.sep + 'configure'
+    if bldinstallercommon.is_win_platform():
+        QT_CONFIGURE_BIN += '.exe'
+
+    INSTALLER_FRAMEWORK_URL             = bldinstallercommon.config_section_map(CONFIG_IFW,'InstallerFramework')['installer_framework_url']
+    INSTALLER_FRAMEWORK_SOURCE_DIR      = SCRIPT_ROOT_DIR + os.sep + bldinstallercommon.config_section_map(CONFIG_IFW,'InstallerFramework')['installer_framework_source_dir']
+    INSTALLER_FRAMEWORK_BUILD_DIR       = SCRIPT_ROOT_DIR + os.sep + bldinstallercommon.config_section_map(CONFIG_IFW,'InstallerFramework')['installer_framework_build_dir']
+    INSTALLER_FRAMEWORK_VERSION_TAG     = bldinstallercommon.config_section_map(CONFIG_IFW,'InstallerFramework')['installer_framework_version_tag']
+    INSTALLER_FRAMEWORK_QMAKE_ARGS      = bldinstallercommon.config_section_map(CONFIG_IFW,'InstallerFramework')['installer_framework_qmake_args']
+    QT_SOURCE_DIR                       = os.path.normpath(QT_SOURCE_DIR)
+    QT_BUILD_DIR                        = os.path.normpath(QT_BUILD_DIR)
+    INSTALLER_FRAMEWORK_SOURCE_DIR      = os.path.normpath(INSTALLER_FRAMEWORK_SOURCE_DIR)
+    INSTALLER_FRAMEWORK_BUILD_DIR       = os.path.normpath(INSTALLER_FRAMEWORK_BUILD_DIR)
+    INSTALLER_FRAMEWORK_ARCHIVE_NAME    = bldinstallercommon.config_section_map(CONFIG_IFW,'Output')['installer_framework_archive_name']
+    INSTALLERBASE_ARCHIVE_NAME          = bldinstallercommon.config_section_map(CONFIG_IFW,'Output')['installerbase_archive_name']
+
+    print 'make:                                ' + MAKE_CMD
+    print ''
+    print 'QT_SRC_PACKAGE_URL:                  ' + QT_SRC_PACKAGE_URL
+    print 'QT_SRC_PACKAGE_URL_SAVE_ASL:         ' + QT_SRC_PACKAGE_URL_SAVE_AS
+    print 'QT_SOURCE_DIR:                       ' + QT_SOURCE_DIR
+    print 'QT_BUILD_DIR:                        ' + QT_BUILD_DIR
+    print 'QT_INSTALLERFW_QT_CONFIGURE_LINE:    [' + QT_INSTALLERFW_QT_CONFIGURE_LINE + ']'
+    print 'QT_QMAKE_BIN:                        ' + QT_QMAKE_BIN
+    print 'QT_CONFIGURE_BIN:                    ' + QT_CONFIGURE_BIN
+    print ''
+    print 'INSTALLER_FRAMEWORK_URL:             ' + INSTALLER_FRAMEWORK_URL
+    print 'INSTALLER_FRAMEWORK_SOURCE_DIR:      ' + INSTALLER_FRAMEWORK_SOURCE_DIR
+    print 'INSTALLER_FRAMEWORK_BUILD_DIR:       ' + INSTALLER_FRAMEWORK_BUILD_DIR
+    print 'INSTALLER_FRAMEWORK_VERSION_TAG:     ' + INSTALLER_FRAMEWORK_VERSION_TAG
+    print 'INSTALLER_FRAMEWORK_QMAKE_ARGS:      [' + INSTALLER_FRAMEWORK_QMAKE_ARGS + ']'
+    print ''
+    print 'Installer-Framework Output: ' + INSTALLER_FRAMEWORK_ARCHIVE_NAME
+    print 'Installerbase Output: ' + INSTALLERBASE_ARCHIVE_NAME
+    print '----------------------------------------'
+
+
+###############################
+# function
+###############################
+def prepare_qt_sources():
+    if DEVELOPMENT_MODE:
+        if os.path.exists(QT_SOURCE_DIR):
+            return
+
+    print '--------------------------------------------------------------------'
+    print 'Fetching Qt src package from: ' + QT_SRC_PACKAGE_URL
+    if not os.path.isfile(QT_SRC_PACKAGE_URL_SAVE_AS):
+        if not bldinstallercommon.is_content_url_valid(QT_SRC_PACKAGE_URL):
+            print '*** Qt src package url is invalid! Abort!'
+            sys.exit(-1)
+        urllib.urlretrieve(QT_SRC_PACKAGE_URL, QT_SRC_PACKAGE_URL_SAVE_AS)
+    else:
+        print 'Found old local package, using that: ' + QT_SRC_PACKAGE_URL_SAVE_AS
+    print 'Done'
+    print '--------------------------------------------------------------------'
+
+    bldinstallercommon.create_dirs(QT_SOURCE_DIR)
+    bldinstallercommon.extract_file(QT_SRC_PACKAGE_URL_SAVE_AS, QT_SOURCE_DIR)
+
+    l = os.listdir(QT_SOURCE_DIR)
+    items = len(l)
+    if items == 1:
+        dir_name = l[0]
+        full_dir_name = QT_SOURCE_DIR + os.sep + dir_name
+        bldinstallercommon.move_tree(full_dir_name, QT_SOURCE_DIR)
+        bldinstallercommon.remove_tree(full_dir_name)
+    else:
+        print '*** Invalid dir structure encountered?!'
+        sys.exit(-1)
+
+
+###############################
+# function
+###############################
+def build_qt():
+    if DEVELOPMENT_MODE:
+        if os.path.exists(QT_BUILD_DIR):
+            return
+
+    bldinstallercommon.create_dirs(QT_BUILD_DIR)
+    # configure first
+    print '--------------------------------------------------------------------'
+    print 'Configuring Qt'
+    # TODO, nasty hack, beucause of a bug in python ConfigParser module, loses trailing white spaces!!
+    cmd_args = ''
+    if bldinstallercommon.is_win_platform():
+        cmd_args = QT_CONFIGURE_BIN + ' ' + QT_INSTALLERFW_QT_CONFIGURE_LINE + ' ' + QT_BUILD_DIR
+    else:
+        cmd_args = QT_CONFIGURE_BIN + ' ' + QT_INSTALLERFW_QT_CONFIGURE_LINE + QT_BUILD_DIR
+    bldinstallercommon.do_execute_sub_process(cmd_args.split(' '), QT_BUILD_DIR, True)
+    print '--------------------------------------------------------------------'
+    print 'Building Qt'
+    cmd_args = MAKE_CMD
+    bldinstallercommon.do_execute_sub_process(cmd_args.split(' '), QT_BUILD_DIR, True)
+
+
+###############################
+# function
+###############################
+def prepare_installer_framework():
+    if DEVELOPMENT_MODE:
+        if os.path.exists(INSTALLER_FRAMEWORK_SOURCE_DIR):
+            return
+
+    print '--------------------------------------------------------------------'
+    print 'Prepare Installer Framework source'
+    #create dirs
+    bldinstallercommon.create_dirs(INSTALLER_FRAMEWORK_BUILD_DIR)
+    # clone repos
+    bldinstallercommon.clone_repository(INSTALLER_FRAMEWORK_URL, INSTALLER_FRAMEWORK_VERSION_TAG, INSTALLER_FRAMEWORK_SOURCE_DIR)
+
+
+###############################
+# function
+###############################
+def build_installer_framework():
+    print '--------------------------------------------------------------------'
+    print 'Building Installer Framework'
+
+    qmake_bin = QT_BUILD_DIR + os.sep + 'bin' + os.sep + QT_QMAKE_BIN
+    if not os.path.isfile(qmake_bin):
+        print '*** Unable to find qmake, aborting!'
+        print 'qmake: ' + qmake_bin
+        sys.exit(-1)
+
+    if not os.path.exists(INSTALLER_FRAMEWORK_BUILD_DIR):
+        bldinstallercommon.create_dirs(INSTALLER_FRAMEWORK_BUILD_DIR)
+
+    cmd_args = qmake_bin + ' ' + INSTALLER_FRAMEWORK_QMAKE_ARGS + ' ' + INSTALLER_FRAMEWORK_SOURCE_DIR
+    bldinstallercommon.do_execute_sub_process(cmd_args.split(' '), INSTALLER_FRAMEWORK_BUILD_DIR, True)
+    cmd_args = MAKE_CMD
+    bldinstallercommon.do_execute_sub_process(cmd_args.split(' '), INSTALLER_FRAMEWORK_BUILD_DIR, True)
+
+
+###############################
+# function
+###############################
+def clean_build_environment():
+    if DEVELOPMENT_MODE:
+        return
+
+    # delete existing stuff if exists
+    if os.path.exists(INSTALLER_FRAMEWORK_SOURCE_DIR):
+        bldinstallercommon.remove_tree(INSTALLER_FRAMEWORK_SOURCE_DIR)
+    if os.path.exists(INSTALLER_FRAMEWORK_BUILD_DIR):
+        bldinstallercommon.remove_tree(INSTALLER_FRAMEWORK_BUILD_DIR)
+    if os.path.exists(QT_SOURCE_DIR):
+        bldinstallercommon.remove_tree(QT_SOURCE_DIR)
+    if os.path.exists(QT_BUILD_DIR):
+        bldinstallercommon.remove_tree(QT_BUILD_DIR)
+    if os.path.isfile(INSTALLER_FRAMEWORK_ARCHIVE_NAME):
+        os.remove(INSTALLER_FRAMEWORK_ARCHIVE_NAME)
+    if os.path.isfile(QT_SRC_PACKAGE_URL_SAVE_AS):
+        os.remove(QT_SRC_PACKAGE_URL_SAVE_AS)
+
+
+###############################
+# function
+###############################
+def archive_installer_framework():
+    if DEVELOPMENT_MODE:
+        return
+
+    print '--------------------------------------------------------------------'
+    print 'Archive Installer Framework'
+    # first strip out all unnecessary files
+    for root, dirs, files in os.walk(INSTALLER_FRAMEWORK_BUILD_DIR):
+        for filename in files:
+            if filename.endswith(('.moc', 'Makefile', '.cpp', '.h', '.o')) or filename == 'Makefile':
+                os.remove(os.path.join(root, filename))
+    cmd_args = ['7z', 'a', INSTALLER_FRAMEWORK_ARCHIVE_NAME, os.path.basename(INSTALLER_FRAMEWORK_BUILD_DIR)]
+    bldinstallercommon.do_execute_sub_process(cmd_args, SCRIPT_ROOT_DIR, True)
+
+
+###############################
+# function
+###############################
+def archive_installerbase():
+    if DEVELOPMENT_MODE:
+        return
+
+    print '--------------------------------------------------------------------'
+    print 'Archive Installerbase'
+    cmd_args_archive = []
+    cmd_args_clean = []
+
+    bin_temp = ''
+    if bldinstallercommon.is_linux_platform() or bldinstallercommon.is_mac_platform():
+        bin_path = INSTALLER_FRAMEWORK_BUILD_DIR + os.sep + 'installerbuilder' + os.sep + 'bin' + os.sep + 'installerbase'
+        bin_temp = SCRIPT_ROOT_DIR + os.sep + '.tempSDKMaintenanceTool'
+        shutil.copy(bin_path, bin_temp)
+        cmd_args_archive = ['7z', 'a', INSTALLERBASE_ARCHIVE_NAME, bin_temp]
+        cmd_args_clean = ['rm', bin_temp]
+    if bldinstallercommon.is_win_platform():
+        bin_path = INSTALLER_FRAMEWORK_BUILD_DIR + os.sep + 'installerbuilder' + os.sep + 'bin' + os.sep + 'installerbase.exe'
+        bin_temp = SCRIPT_ROOT_DIR + os.sep + 'temp'
+        bldinstallercommon.create_dirs(bin_temp)
+        shutil.copy(bin_path, bin_temp + os.sep + 'SDKMaintenanceToolBase.exe')
+        cmd_args_archive = ['7z', 'a', INSTALLERBASE_ARCHIVE_NAME, bin_temp]
+        cmd_args_clean = ['rmdir' ,'/q/s', bin_temp]
+
+    bldinstallercommon.do_execute_sub_process(cmd_args_archive, SCRIPT_ROOT_DIR, True)
+    bldinstallercommon.do_execute_sub_process(cmd_args_clean, SCRIPT_ROOT_DIR, True)
+
+    if not os.path.isfile(INSTALLERBASE_ARCHIVE_NAME):
+        print '*** Failed to generate archive: ' + INSTALLERBASE_ARCHIVE_NAME
+        sys.exit(-1)
+
+
+###############################
+# function
+###############################
+def archive_nib():
+    print '--------------------------------------------------------------------'
+    print 'Archive qt_menu.nib'
+
+    content_parent_path = QT_SOURCE_DIR + os.sep + 'src/gui/mac'
+    content_root_path = content_parent_path + os.sep + 'qt_menu.nib'
+
+    content_parent_path = os.path.normpath(content_parent_path)
+    content_root_path = os.path.normpath(content_root_path)
+    archive_name = 'qt_menu.nib.7z'
+
+    cmd_args = ['7z', 'a', archive_name, content_root_path]
+    bldinstallercommon.do_execute_sub_process(cmd_args, SCRIPT_ROOT_DIR, True)
+
+    if not os.path.isfile(archive_name):
+        print '*** Failed to generate archive: ' + archive_name
+        sys.exit(-1)
+
+
+###############################
+# function
+###############################
+def archive_macdeployqt():
+    print '--------------------------------------------------------------------'
+    print 'Archive macdeployqt'
+
+    content_path = QT_BUILD_DIR + os.sep + 'tools/macdeployqt/macchangeqt/macchangeqt'
+    archive_name = bldinstallercommon.config_section_map(CONFIG_IFW,'Output')['macdeployqt_archive_name']
+    if not archive_name:
+        print '*** Error! macdeployqt_archive_name not defined?!'
+        sys.exit(-1)
+    cmd_args_archive = ['7z', 'a', archive_name, content_path]
+    bldinstallercommon.do_execute_sub_process(cmd_args_archive, SCRIPT_ROOT_DIR, True)
+
+    if not os.path.isfile(archive_name):
+        print '*** Failed to generate archive: ' + archive_name
+        sys.exit(-1)
+
+
+###############################
+# function
+###############################
+def archive_qt():
+    print '--------------------------------------------------------------------'
+    print 'Archive static Qt build'
+
+    content_path = QT_BUILD_DIR
+    archive_name = bldinstallercommon.config_section_map(CONFIG_IFW,'Output')['qt_archive_name']
+    if not archive_name:
+        print '*** Error! macdeployqt_archive_name not defined?!'
+        sys.exit(-1)
+    cmd_args_archive = ['7z', 'a', archive_name, content_path]
+    bldinstallercommon.do_execute_sub_process(cmd_args_archive, SCRIPT_ROOT_DIR, True)
+
+    if not os.path.isfile(archive_name):
+        print '*** Failed to generate archive: ' + archive_name
+        sys.exit(-1)
+
+
+###############################
+# main
+###############################
+def build_ifw(build_mode, platform):
+    global DEVELOPMENT_MODE
+    global PLATFORM_IDENTIFIER
+
+    if build_mode == 'devmode':
+        DEVELOPMENT_MODE = True
+    PLATFORM_IDENTIFIER = platform
+
+    # init
+    bldinstallercommon.init_common_module(SCRIPT_ROOT_DIR)
+    init_config()
+    #clean environment first
+    clean_build_environment()
+    #checkout sources
+    prepare_installer_framework()
+    # copy qt sources
+    prepare_qt_sources()
+    # build qt
+    build_qt()
+    # build installer framework
+    build_installer_framework()
+    #archive
+    archive_installerbase()
+    archive_installer_framework()
+    # for mac we do some extra work
+    if bldinstallercommon.is_mac_platform():
+        archive_nib()
+        archive_macdeployqt()
+    # archive static qt package
+    archive_qt()
+    if build_mode == 'devmode':
+        #TODO, the returned values should be in config file, not return it here!
+        return os.path.basename(INSTALLER_FRAMEWORK_BUILD_DIR)
+    else:
+        return ''
+
diff --git a/release-tools/bldinstallercommon.py b/release-tools/bldinstallercommon.py
new file mode 100644
index 0000000..f803c7b
--- /dev/null
+++ b/release-tools/bldinstallercommon.py
@@ -0,0 +1,605 @@
+#!/usr/bin/env python
+###############################################
+#
+# Copyright (C) 2012 Digia Plc
+# For any questions to Digia, please use contact form at http://qt.digia.com
+#
+# $QT_BEGIN_LICENSE:LGPL$
+# GNU Lesser General Public License Usage
+# This file may be used under the terms of the GNU Lesser General Public
+# License version 2.1 as published by the Free Software Foundation and
+# appearing in the file LICENSE.LGPL included in the packaging of this
+# file. Please review the following information to ensure the GNU Lesser
+# General Public License version 2.1 requirements will be met:
+# http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+#
+# GNU General Public License Usage
+# Alternatively, this file may be used under the terms of the GNU General
+# Public License version 3.0 as published by the Free Software Foundation
+# and appearing in the file LICENSE.GPL included in the packaging of this
+# file. Please review the following information to ensure the GNU General
+# Public License version 3.0 requirements will be met:
+# http://www.gnu.org/copyleft/gpl.html.
+#
+# $QT_END_LICENSE$
+#
+# If you have questions regarding the use of this file, please use
+# contact form at http://qt.digia.com
+#
+###############################################
+
+import errno
+import fnmatch
+import os
+import platform
+import re
+import shutil
+import subprocess
+from subprocess import PIPE, STDOUT
+import sys
+import stat
+import tarfile
+import urllib2
+import zipfile
+
+# need to include this for win platforms as long path names
+# cause problems
+if platform.system().lower().startswith('win'):
+    import win32api
+
+SCRIPT_ROOT_DIR         = ''
+PLATFORM_SUFFIX         = 'unknown'
+IS_UNIX_PLATFORM        = False
+IS_LINUX_PLATFORM       = False
+IS_SOLARIS_PLATFORM     = False
+IS_MAC_PLATFORM         = False
+IS_WIN_PLATFORM         = False
+DEBUG_RPATH             = False
+
+###############################
+# function
+###############################
+def init_common_module(root_path):
+    global SCRIPT_ROOT_DIR
+    SCRIPT_ROOT_DIR = root_path
+    set_platform_specific_data()
+
+
+###############################
+# function
+###############################
+class head_request(urllib2.Request):
+    def get_method(self):
+        return 'HEAD'
+
+def is_content_url_valid(url):
+    # check first if the url points to file on local file system
+    if (os.path.isfile(url)):
+        return True
+    # throws error if url does not point to valid object
+    result = False
+    try:
+        response = urllib2.urlopen(head_request(url))
+        result = True
+    except Exception:
+        pass
+
+    return result;
+
+
+###############################
+# function
+###############################
+def set_platform_specific_data():
+    global PLATFORM_SUFFIX
+    global IS_UNIX_PLATFORM
+    global IS_LINUX_PLATFORM
+    global IS_SOLARIS_PLATFORM
+    global IS_MAC_PLATFORM
+    global IS_WIN_PLATFORM
+    plat = platform.system().lower()
+    if plat.startswith('win'):
+        PLATFORM_SUFFIX = 'win'
+        IS_WIN_PLATFORM = True
+    elif plat.startswith('linux'):
+        PLATFORM_SUFFIX = 'linux'
+        IS_UNIX_PLATFORM = True
+        IS_LINUX_PLATFORM = True
+    elif plat.startswith('sun'):
+        PLATFORM_SUFFIX = 'solaris'
+        IS_UNIX_PLATFORM = True
+        IS_SOLARIS_PLATFORM = True
+    elif plat.startswith('darwin'):
+        PLATFORM_SUFFIX = 'mac'
+        IS_UNIX_PLATFORM = True
+        IS_MAC_PLATFORM = True
+    else:
+        print '*** Unsupported platform, abort!'
+        sys.exit(-1)
+
+
+###############################
+# function
+###############################
+def get_platform_suffix():
+    return PLATFORM_SUFFIX
+
+
+###############################
+# function
+###############################
+def is_unix_platform():
+    return IS_UNIX_PLATFORM
+
+def is_linux_platform():
+    return IS_LINUX_PLATFORM
+
+def is_solaris_platform():
+    return IS_SOLARIS_PLATFORM
+
+def is_mac_platform():
+    return IS_MAC_PLATFORM
+
+def is_win_platform():
+    return IS_WIN_PLATFORM
+
+
+###############################
+# function
+###############################
+def get_executable_suffix():
+    if IS_WIN_PLATFORM:
+        return '.exe'
+    else:
+        return ''
+
+
+###############################
+# function
+###############################
+def make_files_list(directory, rgxp):
+    """Populate and return 'fileslist[]' with all files inside 'directory' matching 'regx'"""
+    # if 'directory' is not a directory, exit with error
+    if not os.path.isdir(directory):
+        print '*** Error, Given path is not valid: ' + directory
+        sys.exit(-1)
+    regex = re.compile(rgxp)
+    filelist = []
+    for root, dirs, files in os.walk(directory):
+        for name in files:
+            if regex.search(name):
+                path = os.path.join(root, name)
+                filelist.append(path)
+
+    return filelist[:]
+
+
+###############################
+# function
+###############################
+def move_tree(srcdir, dstdir, pattern=None):
+    # windows has length limit for path names so try to truncate them as much as possible
+    global IS_WIN_PLATFORM
+    if IS_WIN_PLATFORM:
+        srcdir = win32api.GetShortPathName(srcdir)
+        dstdir = win32api.GetShortPathName(dstdir)
+    # dstdir must exist first
+    srcnames = os.listdir(srcdir)
+    for name in srcnames:
+        srcfname = os.path.join(srcdir, name)
+        dstfname = os.path.join(dstdir, name)
+        if is_win_platform():
+            if len(srcfname) > 255:
+                print 'given srcfname length (' + len(srcfname) + ') too long for Windows: ' + srcfname
+                sys.exit(-1)
+            if len(dstfname) > 255:
+                print 'given dstfname length (' + len(dstfname) + ') too long for Windows: ' + dstfname
+                sys.exit(-1)
+        if os.path.isdir(srcfname) and not os.path.islink(srcfname):
+            os.mkdir(dstfname)
+            move_tree(srcfname, dstfname)
+        elif pattern is None or fnmatch.fnmatch(name, pattern):
+            os.rename(srcfname, dstfname)
+
+
+###############################
+# function
+###############################
+def copy_tree(source_dir, dest_dir):
+    # windows has length limit for path names so try to truncate them as much as possible
+    if IS_WIN_PLATFORM:
+        source_dir = win32api.GetShortPathName(source_dir)
+        dest_dir = win32api.GetShortPathName(dest_dir)
+    src_files = os.listdir(source_dir)
+    for file_name in src_files:
+        full_file_name = os.path.join(source_dir, file_name)
+        if is_win_platform():
+            if len(full_file_name) > 255:
+                print 'given full_file_name length (' + len(full_file_name) + ') too long for Windows: ' + full_file_name
+                sys.exit(-1)
+        if (os.path.isdir(full_file_name)):
+            create_dirs(dest_dir + os.sep + file_name)
+            copy_tree(full_file_name, dest_dir + os.sep + file_name)
+        if (os.path.isfile(full_file_name)):
+            shutil.copy(full_file_name, dest_dir)
+
+
+###############################
+# function
+###############################
+def handle_remove_readonly(func, path, exc):
+  excvalue = exc[1]
+  if func in (os.rmdir, os.remove) and excvalue.errno == errno.EACCES:
+      os.chmod(path, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO) # 0777
+      func(path)
+  else:
+      raise
+
+def remove_tree(source_dir):
+    if IS_WIN_PLATFORM:
+        source_dir = win32api.GetShortPathName(source_dir)
+        shutil.rmtree(source_dir, ignore_errors=False, onerror=handle_remove_readonly)
+    else:
+        shutil.rmtree(source_dir)
+
+
+###############################
+# function
+###############################
+# substitute all matches in files with replacement_string
+def replace_in_files(filelist, regexp, replacement_string):
+    regexp_compiled=re.compile(regexp)
+    for xfile in filelist:
+        replaceflag=0
+        readlines=open(xfile,'r').readlines()
+        listindex = -1
+        for currentline in readlines:
+            listindex = listindex + 1
+            if regexp_compiled.search(currentline):
+                # substitute
+                f=re.sub(regexp,replacement_string,currentline)
+                # update the whole file variable ('readlines')
+                readlines[listindex] = f
+                replaceflag=1
+        # if some text was replaced overwrite the original file
+        if replaceflag==1:
+            # open the file for writting
+            write_file=open(xfile,'w')
+            # overwrite the file
+            for line in readlines:
+                write_file.write(line)
+            # close the file
+            write_file.close()
+
+
+###############################
+# function
+###############################
+def safe_config_key_fetch(conf, section, key):
+    if not conf.has_section(section):
+        return ''
+    if not conf.has_option(section, key):
+        return ''
+    return config_section_map(conf, section)[key]
+
+
+###############################
+# function
+###############################
+def config_section_map(conf, section):
+    dict1 = {}
+    options = conf.options(section)
+    for option in options:
+        try:
+            dict1[option] = conf.get(section, option)
+            if dict1[option] == -1:
+                print('skip: %s' % option)
+        except:
+            print('exception on %s!' % option)
+            dict1[option] = None
+    return dict1
+
+
+###############################
+# function
+###############################
+def dump_config(conf, name):
+    # dump entire config file
+    print '------------------------------'
+    print '- Config: ' + name
+    print '------------------------------'
+    for section in conf.sections():
+        print '[' + section + ']'
+        for option in conf.options(section):
+            print ' ', option, '=', conf.get(section, option)
+    print '------------------------------'
+
+
+###############################
+# function
+###############################
+def create_dirs(path_to_be_created):
+    if not os.path.exists(path_to_be_created):
+        try:
+            os.makedirs(path_to_be_created)
+        except:
+            print '*** Failed to create dir: ' + path_to_be_created
+            sys.exit(-1)
+
+
+###############################
+# Function
+###############################
+def is_executable(path):
+    plat = platform.system().lower()
+    if IS_WIN_PLATFORM:
+        if path.endswith('.exe') or path.endswith('.com'):
+            return True
+    elif IS_LINUX_PLATFORM:
+        return (re.search(r':.* ELF',
+                          subprocess.Popen(['file', '-L', path],
+                                           stdout=subprocess.PIPE).stdout.read())
+                is not None)
+    elif IS_SOLARIS_PLATFORM:
+        return (re.search(r':.* ELF',
+                          subprocess.Popen(['file', '-dh', path],
+                                           stdout=subprocess.PIPE).stdout.read())
+                is not None)
+    elif IS_MAC_PLATFORM:
+        return (re.search(r'executable',
+                          subprocess.Popen(['file', path],
+                                           stdout=subprocess.PIPE).stdout.read())
+                is not None)
+    else:
+        print '*** Error, is_executable not implemented yet!'
+        sys.exit(-1)
+
+    return False
+
+
+###############################
+# Function
+###############################
+def requires_rpath(file_path):
+    if IS_WIN_PLATFORM:
+        return False
+    elif IS_LINUX_PLATFORM or IS_SOLARIS_PLATFORM:
+        base = os.path.basename(file_path)
+        filename, ext = os.path.splitext(base)
+        # filter out some files from search, TODO
+        m = re.match('\.o|\.h|\.png|\.htm|\.html|\.qml|\.qrc|\.jpg|\.svg|\.pro|\.pri|\.desktop|\.sci|\.txt|\.qdoc', ext)
+        if m:
+            return False
+        if filename.lower() == 'qmake':
+            return False
+        elif ext.lower() == '.so':
+            return True
+        else:
+            return is_executable(file_path)
+    elif IS_MAC_PLATFORM:
+        return False
+    else:
+        print '*** Unsupported platform!'
+        sys.exit(-1)
+
+    return False
+
+
+###############################
+# Function
+###############################
+def pathsplit(p, rest=[]):
+    (h,t) = os.path.split(p)
+    if len(h) < 1: return [t]+rest
+    if len(t) < 1: return [h]+rest
+    return pathsplit(h,[t]+rest)
+
+def commonpath(l1, l2, common=[]):
+    if len(l1) < 1: return (common, l1, l2)
+    if len(l2) < 1: return (common, l1, l2)
+    if l1[0] != l2[0]: return (common, l1, l2)
+    return commonpath(l1[1:], l2[1:], common+[l1[0]])
+
+def calculate_relpath(p1, p2):
+    (common,l1,l2) = commonpath(pathsplit(p1), pathsplit(p2))
+    p = []
+    if len(l1) > 0:
+        tmp = '..' + os.sep
+        p = [ tmp * len(l1) ]
+    p = p + l2
+    return os.path.join( *p )
+
+
+##############################################################
+# Calculate the relative RPath for the given file
+##############################################################
+def calculate_rpath(file_full_path, destination_lib_path):
+    if not (os.path.isfile(file_full_path)):
+        print '*** Not a valid file: ' + file_full_path
+        sys.exit(-1)
+
+    bin_path    = os.path.dirname(file_full_path)
+    path_to_lib = os.path.abspath(destination_lib_path)
+    full_rpath = ''
+    if path_to_lib == bin_path:
+        full_rpath = '$ORIGIN'
+    else:
+        rp = calculate_relpath(bin_path, path_to_lib)
+        full_rpath = '$ORIGIN' + os.sep + rp
+
+    if DEBUG_RPATH:
+        print '        ----------------------------------------'
+        print '         RPath target folder: ' + path_to_lib
+        print '         Bin file:            ' + file_full_path
+        print '         Calculated RPath:    ' + full_rpath
+
+    return full_rpath
+
+
+##############################################################
+# Handle the RPath in the given component files
+##############################################################
+def handle_component_rpath(component_root_path, destination_lib_path):
+    print '        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@'
+    print '        Handle RPath'
+    print ''
+    print '        Component root path:  ' + component_root_path
+    print '        Destination lib path: ' + destination_lib_path
+
+    # initialize the file list
+    fileslist = []
+    # loop on all files
+    for root, dirs, files in os.walk(component_root_path):
+        for name in files:
+            file_full_path = os.path.join(root, name)
+            if not os.path.isdir(file_full_path) and not os.path.islink(file_full_path):
+                if requires_rpath(file_full_path):
+                    dst = os.path.normpath(component_root_path + os.sep + destination_lib_path)
+                    rp = calculate_rpath(file_full_path, dst)
+                    #print '         RPath value: [' + rp + '] for file: [' + file_full_path + ']'
+                    cmd_args = ['chrpath', '-r', rp, file_full_path]
+                    #force silent operation
+                    do_execute_sub_process_get_std_out(cmd_args, SCRIPT_ROOT_DIR, True, False)
+
+
+###############################
+# function
+###############################
+def do_execute_sub_process(args, execution_path, abort_on_fail):
+    print '      --------------------------------------------------------------------'
+    print '      Executing:      [' + list_as_string(args) + ']'
+    print '      Execution path: [' + execution_path + ']'
+    try:
+        os.chdir(execution_path)
+        if IS_WIN_PLATFORM:
+            theproc = subprocess.Popen(args, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=False)
+        else:
+            theproc = subprocess.Popen(args)
+        theproc.communicate()
+        if theproc.returncode:
+            print '*** Execution failed with code: %s' % str(theproc.returncode)
+            if abort_on_fail:
+                sys.exit(-1)
+        print '      --------------------------------------------------------------------'
+    except Exception:
+        print sys.exc_info()
+        if abort_on_fail:
+            sys.exit(-1)
+        else:
+            pass
+
+    os.chdir(SCRIPT_ROOT_DIR)
+    return theproc.returncode
+
+
+###############################
+# function
+###############################
+def do_execute_sub_process_2(args, execution_path, abort_on_fail):
+    print '      --------------------------------------------------------------------'
+    print '      Executing:      [' + args + ']'
+    print '      Execution path: [' + execution_path + ']'
+    try:
+        os.chdir(execution_path)
+        theproc = subprocess.Popen(args, shell=True)
+        theproc.communicate()
+        if theproc.returncode:
+            print '*** Execution failed with code: %s' % str(theproc.returncode)
+            if abort_on_fail:
+                sys.exit(-1)
+        print '      --------------------------------------------------------------------'
+    except Exception:
+        print sys.exc_info()
+        if abort_on_fail:
+            sys.exit(-1)
+        else:
+            pass
+
+    os.chdir(SCRIPT_ROOT_DIR)
+    return theproc.returncode
+
+
+###############################
+# function
+###############################
+def do_execute_sub_process_get_std_out(args, execution_path, abort_on_fail, print_debug=True):
+    if print_debug:
+        print '      --------------------------------------------------------------------'
+        print '      Executing: [' + list_as_string(args) + ']'
+        print '      Execution path: [' + execution_path + ']'
+    theproc = None
+    output = ''
+    try:
+        os.chdir(execution_path)
+        if IS_WIN_PLATFORM:
+            theproc = subprocess.Popen(args, shell=True, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=False)
+        else:
+            theproc = subprocess.Popen(args, shell=False, stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
+        output = theproc.stdout.read()
+        theproc.communicate()
+        if theproc.returncode:
+            print '*** Execution failed with code: %s' % str(theproc.returncode)
+            if abort_on_fail:
+                sys.exit(-1)
+        if print_debug:
+            print '      --------------------------------------------------------------------'
+    except Exception:
+        print sys.exc_info()
+        if abort_on_fail:
+            sys.exit(-1)
+        else:
+            pass
+
+    os.chdir(SCRIPT_ROOT_DIR)
+    return output
+
+
+###############################
+# function
+###############################
+def clone_repository(repo_url, repo_branch_or_tag, destination_folder):
+    print '--------------------------------------------------------------------'
+    print 'Cloning repository: ' + repo_url
+    print '        branch/tag: ' + repo_branch_or_tag
+    print 'Dest:               ' + destination_folder
+    print '--------------------------------------------------------------------'
+
+    cmd_args = ['git', 'clone', '--depth', '0', repo_url, destination_folder]
+    do_execute_sub_process(cmd_args, SCRIPT_ROOT_DIR, True)
+
+    cmd_args = ['git', 'checkout', repo_branch_or_tag]
+    do_execute_sub_process(cmd_args, destination_folder, True)
+
+
+###############################
+# function
+###############################
+def extract_file(path, to_directory='.'):
+    cmd_args = []
+    if path.endswith('.zip'):
+        cmd_args = ['unzip', '-qq', path]
+    elif path.endswith('.tar'):
+        cmd_args = ['tar', '-xzf', path]
+    elif path.endswith('.tar.gz') or path.endswith('.tgz'):
+        cmd_args = ['tar', '-xzf', path]
+    elif path.endswith('.tar.bz2') or path.endswith('.tbz'):
+        cmd_args = ['tar', '-xzf', path]
+    elif path.endswith('.7z'):
+        cmd_args = ['7z', 'x', path]
+        # 7z does not have silent operation so we do it the hard way....
+        do_execute_sub_process_get_std_out(cmd_args, to_directory, False)
+        return
+    else:
+        print '*** Could not extract `%s` as no appropriate extractor is found' + path
+        sys.exit(-1)
+
+    do_execute_sub_process(cmd_args, to_directory, True)
+
+
+###############################
+# function
+###############################
+def list_as_string(argument_list):
+    output= ' '.join(argument_list)
+    return output
+
diff --git a/release-tools/configurations/config_qt5/background.png b/release-tools/configurations/config_qt5/background.png
new file mode 100644
index 0000000..0360c55
Binary files /dev/null and b/release-tools/configurations/config_qt5/background.png differ
diff --git a/release-tools/configurations/config_qt5/license.txt b/release-tools/configurations/config_qt5/license.txt
new file mode 100644
index 0000000..515f97d
--- /dev/null
+++ b/release-tools/configurations/config_qt5/license.txt
@@ -0,0 +1,25 @@
+Qt SDK
+
+The Qt SDK contains software licensed under various open source licenses as well as proprietary components.  All open source software ("Open Source Software") is licensed under the open source licenses that accompany such Open Source Software.  The licenses governing the Open Source Software are listed here: (###OPENSOURCELINK###).
+
+Nokia offers to provide you with the source code as defined in the applicable license. Please send an e-mail to sourcecode.request@nokia.com or a written request to:
+Source Code Requests
+Nokia Corporation
+P.O. Box 407
+FI-00045 Nokia Group
+Finland
+
+This offer is valid for a period of three (3) years from the date of the distribution of this product by Nokia.
+
+Except for the Open Source Software contained in the Qt SDK, all other software is governed by the terms contained in the Nokia Corporation Developer Software Agreement (###EULALINK###).
+
+If you do not agree with the Open Source Software license terms or the Nokia Developer Software Agreement, you may not use the Qt SDK.
+
+Nokia and Nokia Connecting People are trademarks or registered trademarks of Nokia Corporation.
+
+Copyright 2010 Nokia. All rights reserved.
+
+Includes JavaTM ME technology. Java and all Java-based marks are trademarks or registered trademarks of Sun Microsystems, Inc.
+
+Other product and company names mentioned herein may be trademarks or trade names of their respective owners.
+
diff --git a/release-tools/configurations/config_qt5/logo-small.png b/release-tools/configurations/config_qt5/logo-small.png
new file mode 100644
index 0000000..a2bea64
Binary files /dev/null and b/release-tools/configurations/config_qt5/logo-small.png differ
diff --git a/release-tools/configurations/config_qt5/logo.png b/release-tools/configurations/config_qt5/logo.png
new file mode 100644
index 0000000..d1b2131
Binary files /dev/null and b/release-tools/configurations/config_qt5/logo.png differ
diff --git a/release-tools/configurations/config_qt5/watermark.png b/release-tools/configurations/config_qt5/watermark.png
new file mode 100644
index 0000000..fc44c44
Binary files /dev/null and b/release-tools/configurations/config_qt5/watermark.png differ
diff --git a/release-tools/configurations/linux/common b/release-tools/configurations/linux/common
new file mode 100644
index 0000000..b26888b
--- /dev/null
+++ b/release-tools/configurations/linux/common
@@ -0,0 +1,5 @@
+[SdkCommon]
+version:                            1.0.0
+name:                               QtSdk
+
+
diff --git a/release-tools/configurations/linux/config.xml.template.linux b/release-tools/configurations/linux/config.xml.template.linux
new file mode 100644
index 0000000..7d0a73e
--- /dev/null
+++ b/release-tools/configurations/linux/config.xml.template.linux
@@ -0,0 +1,26 @@
+<?xml version="1.0"?>
+<Installer>
+    <Name>Qt SDK</Name>
+    <Version>%SDK_VERSION_NUM%</Version>
+    <Title>Qt SDK</Title>
+    <MaintenanceTitle>Maintain Qt SDK</MaintenanceTitle>
+    <Publisher>Qt</Publisher>
+    <Logo>logo.png</Logo>
+    <LogoSmall>logo-small.png</LogoSmall>
+    <Icon>logo-small</Icon>
+    <License>license.txt</License>
+    <Watermark>watermark.png</Watermark>
+    <StartMenuDir>Qt SDK</StartMenuDir>
+    <ProductUrl>qt.nokia.com</ProductUrl>
+    <!--<Background>background.png</Background>-->
+    <UninstallerName>SDKMaintenanceTool</UninstallerName>
+    <RemoteRepositories>
+        <Repository>
+            <Url>%UPDATE_REPOSITORY_URL%</Url>
+            <Required>false</Required>
+        </Repository>
+    </RemoteRepositories>
+    <!-- @homeDir@ and @rootDir@ are some of the supported vars -->
+    <TargetDir>@homeDir@/QtSDK</TargetDir>
+    <AdminTargetDir>/opt/QtSDK</AdminTargetDir>
+</Installer>
diff --git a/release-tools/configurations/linux/installer-framework b/release-tools/configurations/linux/installer-framework
new file mode 100644
index 0000000..626626b
--- /dev/null
+++ b/release-tools/configurations/linux/installer-framework
@@ -0,0 +1,23 @@
+
+[make]
+make_cmd:                               make -j8
+
+[QtForInstallerFramework]
+qt_src_package_url:                     http://download.qt.nokia.com/qt/source/qt-everywhere-opensource-src-4.8.0.tar.gz
+qt_source_dir:                          qt-everywhere-src
+qt_build_dir:                           qt-everywhere-build
+qt_installerfw_qt_configure_line:       -static -release -confirm-license -silent -nomake examples -nomake demos -nomake tests -nomake docs -nomake plugins -nomake translations -qt-zlib -qt-libtiff -qt-libpng -qt-libmng -qt-libjpeg -no-webkit -no-phonon -no-dbus -no-opengl -no-qt3support -no-xmlpatterns -no-svg -no-nis -no-cups -no-multimedia -no-audio-backend -no-phonon -no-phonon-backend -no-webkit -no-declarative -no-declarative-debug -no-accessibility --prefix=
+
+[InstallerFramework]
+installer_framework_url:                git://gitorious.org/qt-labs/installer-framework.git
+installer_framework_source_dir:         installer-framework-source
+installer_framework_build_dir:          installer-framework-build
+installer_framework_version_tag:        remotes/origin/master
+installer_framework_qmake_args:         -config release -config static -r
+
+[Output]
+installer_framework_archive_name:       installer-framework-build-linux.7z
+installerbase_archive_name:             installerbase-linux.7z
+qt_archive_name:                        qt-4.8.0-linux.7z
+macdeployqt_archive_name:
+qtmenunib_archive_name:
diff --git a/release-tools/configurations/linux/x86_32 b/release-tools/configurations/linux/x86_32
new file mode 100644
index 0000000..6493512
--- /dev/null
+++ b/release-tools/configurations/linux/x86_32
@@ -0,0 +1,78 @@
+
+[com.qt]
+root_component:         yes
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src.500]
+archives:               qt.src.500
+target_install_base:    /Src/Qt/5.0.0
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        false
+[qt.src.500]
+archive_uri:            qt-everywhere-opensource-src-5.0.0.tar.gz
+package_strip_dirs:     1
+target_install_dir:     /
+rpath_target:
+archive_name:           qt-everywhere-opensource-src-5.0.0.7z
+
+[com.qt.desktop]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt.500]
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+
+[com.qt.desktop.qt.500.gcc]
+archives:               qt.500.gcc
+target_install_base:    /Desktop/Qt/5.0.0/gcc
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        true
+[qt.500.gcc]
+archive_uri:            qt-5.0.0-desktop-gcc.7z
+package_strip_dirs:     4
+target_install_dir:     /
+rpath_target:           /lib
+archive_name:           qt-5.0.0-desktop-gcc.7z
+
+
+[OfflinePackageExcludeList]
+package_list:
+
+[PackagesNamespace]
+name:                   com.qt
+
+[SdkUpdateRepository]
+repository_url:
+repository_url_rnd:
+
+[TargetArchitechture]
+instruction_set:        x86_32
+
+[ConfigDir]
+template_name:          config_qt5
+target_dir:             config
+
+[ConfigXml]
+template_name:          config.xml.template.linux
+
+[WorkingDirectories]
+packages_dir:           pkg
+
+[InstallerFrameworkTools]
+name:                   ifwt
+package_url:            http://<url_to>/installer-framework-build-linux-64bit.7z
+version:                1.2.0
+
+
diff --git a/release-tools/configurations/linux/x86_64 b/release-tools/configurations/linux/x86_64
new file mode 100644
index 0000000..d54ac6b
--- /dev/null
+++ b/release-tools/configurations/linux/x86_64
@@ -0,0 +1,78 @@
+
+[com.qt]
+root_component:         yes
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src.500]
+archives:               qt.src.500
+target_install_base:    /Src/Qt/5.0.0
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        false
+[qt.src.500]
+archive_uri:            qt-everywhere-opensource-src-5.0.0.tar.gz
+package_strip_dirs:     1
+target_install_dir:     /
+rpath_target:
+archive_name:           qt-everywhere-opensource-src-5.0.0.7z
+
+[com.qt.desktop]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt.500]
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+
+[com.qt.desktop.qt.500.gcc]
+archives:               qt.500.gcc
+target_install_base:    /Desktop/Qt/5.0.0/gcc
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        true
+[qt.500.gcc]
+archive_uri:            qt-5.0.0-desktop-gcc.7z
+package_strip_dirs:     4
+target_install_dir:     /
+rpath_target:           /lib
+archive_name:           qt-5.0.0-desktop-gcc.7z
+
+
+[OfflinePackageExcludeList]
+package_list:
+
+[PackagesNamespace]
+name:                   com.qt
+
+[SdkUpdateRepository]
+repository_url:
+repository_url_rnd:
+
+[TargetArchitechture]
+instruction_set:        x86_64
+
+[ConfigDir]
+template_name:          config_qt5
+target_dir:             config
+
+[ConfigXml]
+template_name:          config.xml.template.linux
+
+[WorkingDirectories]
+packages_dir:           pkg
+
+[InstallerFrameworkTools]
+name:                   ifwt
+package_url:            http://<url_to>/installer-framework-build-linux-32bit.7z
+version:                1.2.0
+
+
diff --git a/release-tools/configurations/mac/common b/release-tools/configurations/mac/common
new file mode 100644
index 0000000..b26888b
--- /dev/null
+++ b/release-tools/configurations/mac/common
@@ -0,0 +1,5 @@
+[SdkCommon]
+version:                            1.0.0
+name:                               QtSdk
+
+
diff --git a/release-tools/configurations/mac/config.xml.template.mac b/release-tools/configurations/mac/config.xml.template.mac
new file mode 100644
index 0000000..a44ba3b
--- /dev/null
+++ b/release-tools/configurations/mac/config.xml.template.mac
@@ -0,0 +1,25 @@
+<?xml version="1.0"?>
+<Installer>
+    <Name>Qt SDK</Name>
+    <Version>%SDK_VERSION_NUM%</Version>
+    <Title>Qt SDK</Title>
+    <MaintenanceTitle>Maintain Qt SDK</MaintenanceTitle>
+    <Publisher>Qt</Publisher>
+    <Logo>logo.png</Logo>
+    <LogoSmall>logo-small.png</LogoSmall>
+    <Icon>logo-small</Icon>
+    <License>license.txt</License>
+    <Watermark>watermark.png</Watermark>
+    <StartMenuDir>Qt SDK</StartMenuDir>
+    <ProductUrl>qt.nokia.com</ProductUrl>
+    <!--<Background>background.png</Background>-->
+    <UninstallerName>SDKMaintenanceTool</UninstallerName>
+    <RemoteRepositories>
+        <Repository>
+            <Url>%UPDATE_REPOSITORY_URL%</Url>
+            <Required>false</Required>
+        </Repository>
+    </RemoteRepositories>
+    <!-- @homeDir@ and @rootDir@ are some of the supported vars -->
+    <TargetDir>@homeDir@/QtSDK</TargetDir>
+</Installer>
diff --git a/release-tools/configurations/mac/installer-framework b/release-tools/configurations/mac/installer-framework
new file mode 100644
index 0000000..018f0ea
--- /dev/null
+++ b/release-tools/configurations/mac/installer-framework
@@ -0,0 +1,23 @@
+
+[make]
+make_cmd:                               make -j8
+
+[QtForInstallerFramework]
+qt_src_package_url:                     http://download.qt.nokia.com/qt/source/qt-everywhere-opensource-src-4.8.0.tar.gz
+qt_source_dir:                          qt-everywhere-src
+qt_build_dir:                           qt-everywhere-build
+qt_installerfw_qt_configure_line:       -static -release -confirm-license -silent -nomake examples -nomake demos -nomake tests -nomake docs -nomake plugins -nomake translations -qt-zlib -qt-libtiff -qt-libpng -qt-libmng -qt-libjpeg -no-webkit -no-phonon -no-dbus -no-opengl -no-qt3support -no-xmlpatterns -no-svg -no-nis -no-cups -no-multimedia -no-audio-backend -no-phonon -no-phonon-backend -no-webkit -no-declarative -no-declarative-debug -no-accessibility --prefix=
+
+[InstallerFramework]
+installer_framework_url:                git://gitorious.org/qt-labs/installer-framework.git
+installer_framework_source_dir:         installer-framework-source
+installer_framework_build_dir:          installer-framework-build
+installer_framework_version_tag:        remotes/origin/master
+installer_framework_qmake_args:         -config release -config static -r
+
+[Output]
+installer_framework_archive_name:       installer-framework-build-linux.7z
+installerbase_archive_name:             installerbase-mac.7z
+qt_archive_name:                        qt-4.8.0-mac.7z
+macdeployqt_archive_name:               macdeployqt.7z
+qtmenunib_archive_name:                 qtmenunib.7z
diff --git a/release-tools/configurations/mac/x86_64 b/release-tools/configurations/mac/x86_64
new file mode 100644
index 0000000..a759681
--- /dev/null
+++ b/release-tools/configurations/mac/x86_64
@@ -0,0 +1,78 @@
+
+[com.qt]
+root_component:         yes
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src.500]
+archives:               qt.src.500
+target_install_base:    /Src/Qt/5.0.0
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        false
+[qt.src.500]
+archive_uri:            qt-everywhere-opensource-src-5.0.0.tar.gz
+package_strip_dirs:     1
+target_install_dir:     /
+rpath_target:
+archive_name:           qt-everywhere-opensource-src-5.0.0.7z
+
+[com.qt.desktop]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt.500]
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+
+[com.qt.desktop.qt.500.gcc]
+archives:               qt.500.gcc
+target_install_base:    /Desktop/Qt/5.0.0/gcc
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        true
+[qt.500.gcc]
+archive_uri:            qt-5.0.0-desktop-gcc.7z
+package_strip_dirs:     4
+target_install_dir:     /
+rpath_target:           /lib
+archive_name:           qt-5.0.0-desktop-gcc.7z
+
+
+[OfflinePackageExcludeList]
+package_list:
+
+[PackagesNamespace]
+name:                   com.qt
+
+[SdkUpdateRepository]
+repository_url:
+repository_url_rnd:
+
+[TargetArchitechture]
+instruction_set:        x86_64
+
+[ConfigDir]
+template_name:          config_qt5
+target_dir:             config
+
+[ConfigXml]
+template_name:          config.xml.template.mac
+
+[WorkingDirectories]
+packages_dir:           pkg
+
+[InstallerFrameworkTools]
+name:                   ifwt
+package_url:            http://<url_to>/installer-framework-build-mac.7z
+version:                1.2.0
+
+
diff --git a/release-tools/configurations/pkg/com.qt.desktop.qt.500.gcc/meta/installscript.qs b/release-tools/configurations/pkg/com.qt.desktop.qt.500.gcc/meta/installscript.qs
new file mode 100644
index 0000000..db8acd4
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.desktop.qt.500.gcc/meta/installscript.qs
@@ -0,0 +1,60 @@
+/* This file is part of the Qt SDK
+
+*/
+
+// constructor
+function Component()
+{
+    if (installer.value("os") == "win")
+    {
+    }
+    if (component.fromOnlineRepository)
+    {
+        //%IFW_DOWNLOADABLE_ARCHIVE_NAMES%
+    }
+}
+
+
+checkWhetherStopProcessIsNeeded = function()
+{
+}
+
+
+Component.prototype.createOperations = function()
+{
+    component.createOperations();
+
+    if (installer.value("os") == "x11") {
+        try {
+            // patch Qt binaries
+            component.addOperation( "QtPatch", "linux", installer.value("TargetDir") + "%TARGET_INSTALL_DIR%" );
+        } catch( e ) {
+            print( e );
+        }
+    }
+    if (installer.value("os") == "mac") {
+        try {
+            // patch Qt binaries
+            component.addOperation( "QtPatch", "mac", installer.value("TargetDir") + "%TARGET_INSTALL_DIR%" );
+        } catch( e ) {
+            print( e );
+        }
+    }
+    if (installer.value("os") == "win") {
+        try {
+            // patch Qt binaries
+            component.addOperation( "QtPatch", "windows", installer.value("TargetDir") + "%TARGET_INSTALL_DIR%" );
+        } catch( e ) {
+            print( e );
+        }
+    }
+}
+
+
+Component.prototype.installationFinished = function()
+{
+    if (installer.isInstaller() && component.selected)
+        {
+        }
+}
+
diff --git a/release-tools/configurations/pkg/com.qt.desktop.qt.500.gcc/meta/package.xml b/release-tools/configurations/pkg/com.qt.desktop.qt.500.gcc/meta/package.xml
new file mode 100644
index 0000000..7e3fc28
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.desktop.qt.500.gcc/meta/package.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<Package>
+    <DisplayName>Qt %QT_VERSION_NUM% (gcc)</DisplayName>
+    <Description>Qt %QT_VERSION_NUM% (gcc)</Description>
+    <Version>%QT_VERSION_NUM%</Version>
+    <ReleaseDate>%PACKAGE_CREATION_DATE%</ReleaseDate>
+    <Name>com.qt.desktop.qt.500.gcc</Name>
+    <!--<Dependencies></Dependencies>--> <!-- Comma-separated list of dependencies - optional -->
+    <!--<Default></Default>-->
+    <!--<AutoSelectOn></AutoSelectOn>-->
+    <Script>installscript.qs</Script>   <!-- File name of a script being loaded - optional. -->
+    <!--<Forced></Forced>-->
+    <!--<Virtual></Virtual>--> <!-- Set to true if this is a virtual component not showing up in the installer -->
+    <!--<Important></Important>-->    <!-- The package is marked as important. This is relevant for updates found with UpdateAgent. -->
+    <!--<InstallPriority></InstallPriority>--> <!-- Priority of this component when getting installed. Lowest priority number is first. -->
+</Package>
+
+
diff --git a/release-tools/configurations/pkg/com.qt.desktop.qt.500/meta/package.xml b/release-tools/configurations/pkg/com.qt.desktop.qt.500/meta/package.xml
new file mode 100644
index 0000000..dee90b5
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.desktop.qt.500/meta/package.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<Package>
+    <DisplayName>Qt %QT_VERSION_NUM%</DisplayName>
+    <Description>Qt %QT_VERSION_NUM%</Description>
+    <Version>%QT_VERSION_NUM%</Version>
+    <ReleaseDate>%PACKAGE_CREATION_DATE%</ReleaseDate>
+    <Name>com.qt.desktop.qt.500</Name>
+    <!--<Dependencies></Dependencies>--> <!-- Comma-separated list of dependencies - optional -->
+    <!--<Default></Default>-->
+    <!--<AutoSelectOn></AutoSelectOn>-->
+    <!--<Script>installscript.qs</Script>-->   <!-- File name of a script being loaded - optional. -->
+    <!--<Forced></Forced>-->
+    <!--<Virtual></Virtual>--> <!-- Set to true if this is a virtual component not showing up in the installer -->
+    <!--<Important></Important>-->    <!-- The package is marked as important. This is relevant for updates found with UpdateAgent. -->
+    <!--<InstallPriority></InstallPriority>--> <!-- Priority of this component when getting installed. Lowest priority number is first. -->
+</Package>
+
+
diff --git a/release-tools/configurations/pkg/com.qt.desktop.qt/meta/package.xml b/release-tools/configurations/pkg/com.qt.desktop.qt/meta/package.xml
new file mode 100644
index 0000000..e1d9feb
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.desktop.qt/meta/package.xml
@@ -0,0 +1,18 @@
+<?xml version="1.0"?>
+<Package>
+    <DisplayName>Qt Desktop Qt Components</DisplayName>
+    <Description>Qt Desktop Qt Components</Description>
+    <Version>%SDK_VERSION_NUM%</Version>
+    <ReleaseDate>%PACKAGE_CREATION_DATE%</ReleaseDate>
+    <Name>com.qt.desktop.qt</Name>
+    <!--<Dependencies></Dependencies>--> <!-- Comma-separated list of dependencies - optional -->
+    <!--<Default></Default>-->
+    <!--<AutoSelectOn></AutoSelectOn>-->
+    <!--<Script>installscript.qs</Script>-->   <!-- File name of a script being loaded - optional. -->
+    <!--<Forced></Forced>-->
+    <!--<Virtual></Virtual>--> <!-- Set to true if this is a virtual component not showing up in the installer -->
+    <!--<Important></Important>-->    <!-- The package is marked as important. This is relevant for updates found with UpdateAgent. -->
+    <!--<InstallPriority></InstallPriority>--> <!-- Priority of this component when getting installed. Lowest priority number is first. -->
+</Package>
+
+
diff --git a/release-tools/configurations/pkg/com.qt.desktop/meta/package.xml b/release-tools/configurations/pkg/com.qt.desktop/meta/package.xml
new file mode 100644
index 0000000..9e9b762
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.desktop/meta/package.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0"?>
+<Package>
+    <DisplayName>Qt Desktop Components</DisplayName>
+    <Description>Qt Desktop Components</Description>
+    <Version>%SDK_VERSION_NUM%</Version>
+    <ReleaseDate>%PACKAGE_CREATION_DATE%</ReleaseDate>
+    <Name>com.qt.desktop</Name>
+    <!--<Dependencies></Dependencies>--> <!-- Comma-separated list of dependencies - optional -->
+    <!--<Default></Default>-->
+    <!--<AutoSelectOn></AutoSelectOn>-->
+    <!--<Script>installscript.qs</Script>-->   <!-- File name of a script being loaded - optional. -->
+    <!--<Forced></Forced>-->
+    <!--<Virtual></Virtual>--> <!-- Set to true if this is a virtual component not showing up in the installer -->
+    <!--<Important></Important>-->    <!-- The package is marked as important. This is relevant for updates found with UpdateAgent. -->
+    <!--<SortingPriority>0</SortingPriority>--> <!-- Priority of this component when visible in the tree. Lowest priority number is on top. -->
+    <!--<InstallPriority></InstallPriority>--> <!-- Priority of this component when getting installed. Lowest priority number is first. -->
+</Package>
+
+
diff --git a/release-tools/configurations/pkg/com.qt.src.500/meta/installscript.qs b/release-tools/configurations/pkg/com.qt.src.500/meta/installscript.qs
new file mode 100644
index 0000000..3a6e523
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.src.500/meta/installscript.qs
@@ -0,0 +1,32 @@
+/* This file is part of the Qt SDK
+
+*/
+
+// constructor
+function Component()
+{
+    if (installer.value("os") == "win")
+    {
+    }
+    if (component.fromOnlineRepository)
+    {
+        //%IFW_DOWNLOADABLE_ARCHIVE_NAMES%
+    }
+}
+
+
+checkWhetherStopProcessIsNeeded = function()
+{
+}
+
+
+Component.prototype.createOperations = function()
+{
+    component.createOperations();
+}
+
+
+Component.prototype.installationFinished = function()
+{
+}
+
diff --git a/release-tools/configurations/pkg/com.qt.src.500/meta/package.xml b/release-tools/configurations/pkg/com.qt.src.500/meta/package.xml
new file mode 100644
index 0000000..60c3319
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.src.500/meta/package.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0"?>
+<Package>
+    <DisplayName>Qt 5.0.0 Source Package</DisplayName>
+    <Description>Qt 5.0.0 Source Package</Description>
+    <Version>%QT_VERSION_NUM%</Version>
+    <ReleaseDate>%PACKAGE_CREATION_DATE%</ReleaseDate>
+    <Name>com.qt.src.500</Name>
+    <!--<Dependencies></Dependencies>--> <!-- Comma-separated list of dependencies - optional -->
+    <!--<Default></Default>-->
+    <!--<AutoSelectOn></AutoSelectOn>-->
+    <!--<Script>installscript.qs</Script>-->   <!-- File name of a script being loaded - optional. -->
+    <!--<Forced></Forced>-->
+    <!--<Virtual></Virtual>--> <!-- Set to true if this is a virtual component not showing up in the installer -->
+    <!--<Important></Important>-->    <!-- The package is marked as important. This is relevant for updates found with UpdateAgent. -->
+    <!--<SortingPriority>0</SortingPriority>--> <!-- Priority of this component when visible in the tree. Lowest priority number is on top. -->
+    <!--<InstallPriority></InstallPriority>--> <!-- Priority of this component when getting installed. Lowest priority number is first. -->
+</Package>
+
+
diff --git a/release-tools/configurations/pkg/com.qt.src/meta/package.xml b/release-tools/configurations/pkg/com.qt.src/meta/package.xml
new file mode 100644
index 0000000..cc39c0a
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt.src/meta/package.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0"?>
+<Package>
+    <DisplayName>Qt Source Components</DisplayName>
+    <Description>Qt Source Components</Description>
+    <Version>%SDK_VERSION_NUM%</Version>
+    <ReleaseDate>%PACKAGE_CREATION_DATE%</ReleaseDate>
+    <Name>com.qt.src</Name>
+    <!--<Dependencies></Dependencies>--> <!-- Comma-separated list of dependencies - optional -->
+    <!--<Default></Default>-->
+    <!--<AutoSelectOn></AutoSelectOn>-->
+    <!--<Script>installscript.qs</Script>-->   <!-- File name of a script being loaded - optional. -->
+    <!--<Forced></Forced>-->
+    <!--<Virtual></Virtual>--> <!-- Set to true if this is a virtual component not showing up in the installer -->
+    <!--<Important></Important>-->    <!-- The package is marked as important. This is relevant for updates found with UpdateAgent. -->
+    <!--<SortingPriority>0</SortingPriority>--> <!-- Priority of this component when visible in the tree. Lowest priority number is on top. -->
+    <!--<InstallPriority></InstallPriority>--> <!-- Priority of this component when getting installed. Lowest priority number is first. -->
+</Package>
+
+
diff --git a/release-tools/configurations/pkg/com.qt/meta/package.xml b/release-tools/configurations/pkg/com.qt/meta/package.xml
new file mode 100644
index 0000000..a2c44e3
--- /dev/null
+++ b/release-tools/configurations/pkg/com.qt/meta/package.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0"?>
+<Package>
+    <DisplayName>Qt Installer</DisplayName>
+    <Description>Qt Installer5</Description>
+    <Version>%SDK_VERSION_NUM%</Version>
+    <ReleaseDate>%PACKAGE_CREATION_DATE%</ReleaseDate>
+    <Name>com.qt</Name>
+    <!--<Dependencies></Dependencies>--> <!-- Comma-separated list of dependencies - optional -->
+    <!--<Default></Default>-->
+    <!--<AutoSelectOn></AutoSelectOn>-->
+    <!--<Script>installscript.qs</Script>-->   <!-- File name of a script being loaded - optional. -->
+    <!--<Forced></Forced>-->
+    <!--<Virtual></Virtual>--> <!-- Set to true if this is a virtual component not showing up in the installer -->
+    <!--<Important></Important>-->    <!-- The package is marked as important. This is relevant for updates found with UpdateAgent. -->
+    <SortingPriority>0</SortingPriority> <!-- Priority of this component when visible in the tree. Lowest priority number is on top. -->
+    <!--<InstallPriority></InstallPriority>--> <!-- Priority of this component when getting installed. Lowest priority number is first. -->
+</Package>
+
+
diff --git a/release-tools/configurations/windows/common b/release-tools/configurations/windows/common
new file mode 100644
index 0000000..b26888b
--- /dev/null
+++ b/release-tools/configurations/windows/common
@@ -0,0 +1,5 @@
+[SdkCommon]
+version:                            1.0.0
+name:                               QtSdk
+
+
diff --git a/release-tools/configurations/windows/config.xml.template.windows b/release-tools/configurations/windows/config.xml.template.windows
new file mode 100644
index 0000000..a44ba3b
--- /dev/null
+++ b/release-tools/configurations/windows/config.xml.template.windows
@@ -0,0 +1,25 @@
+<?xml version="1.0"?>
+<Installer>
+    <Name>Qt SDK</Name>
+    <Version>%SDK_VERSION_NUM%</Version>
+    <Title>Qt SDK</Title>
+    <MaintenanceTitle>Maintain Qt SDK</MaintenanceTitle>
+    <Publisher>Qt</Publisher>
+    <Logo>logo.png</Logo>
+    <LogoSmall>logo-small.png</LogoSmall>
+    <Icon>logo-small</Icon>
+    <License>license.txt</License>
+    <Watermark>watermark.png</Watermark>
+    <StartMenuDir>Qt SDK</StartMenuDir>
+    <ProductUrl>qt.nokia.com</ProductUrl>
+    <!--<Background>background.png</Background>-->
+    <UninstallerName>SDKMaintenanceTool</UninstallerName>
+    <RemoteRepositories>
+        <Repository>
+            <Url>%UPDATE_REPOSITORY_URL%</Url>
+            <Required>false</Required>
+        </Repository>
+    </RemoteRepositories>
+    <!-- @homeDir@ and @rootDir@ are some of the supported vars -->
+    <TargetDir>@homeDir@/QtSDK</TargetDir>
+</Installer>
diff --git a/release-tools/configurations/windows/installer-framework b/release-tools/configurations/windows/installer-framework
new file mode 100644
index 0000000..cf7c4d9
--- /dev/null
+++ b/release-tools/configurations/windows/installer-framework
@@ -0,0 +1,21 @@
+
+[make]
+make_cmd:                               nmake
+
+[QtForInstallerFramework]
+qt_src_package_url:                     http://download.qt.nokia.com/qt/source/qt-everywhere-opensource-src-4.8.0.tar.gz
+qt_source_dir:                          qt-src
+qt_build_dir:                           qt-bld
+qt_installerfw_qt_configure_line:       -static -release -confirm-license -nomake examples -nomake demos -nomake tests -nomake docs -no-webkit -no-phonon -no-dbus -no-opengl -no-qt3support -no-xmlpatterns -no-multimedia -no-declarative -no-declarative-debug -qt-sql-sqlite -plugin-sql-sqlite -prefix
+
+[InstallerFramework]
+installer_framework_url:                git://gitorious.org/qt-labs/installer-framework.git
+installer_framework_source_dir:         ifw-src
+installer_framework_build_dir:          ifw-bld
+installer_framework_version_tag:        remotes/origin/master
+installer_framework_qmake_args:         -config release -config static -r
+
+[Output]
+installer_framework_archive_name:       installer-framework-build-win.7z
+installerbase_archive_name:             installerbase-win.7z
+qt_archive_name:                        qt-4.8.0-win.7z
diff --git a/release-tools/configurations/windows/x86_32 b/release-tools/configurations/windows/x86_32
new file mode 100644
index 0000000..84ce877
--- /dev/null
+++ b/release-tools/configurations/windows/x86_32
@@ -0,0 +1,78 @@
+
+[com.qt]
+root_component:         yes
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.src.500]
+archives:               qt.src.500
+target_install_base:    /Src/Qt/5.0.0
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        false
+[qt.src.500]
+archive_uri:            qt-everywhere-opensource-src-5.0.0.zip
+package_strip_dirs:     1
+target_install_dir:     /
+rpath_target:
+archive_name:           qt-everywhere-opensource-src-5.0.0.7z
+
+[com.qt.desktop]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt]
+version:                1.0.0
+version_tag:            %SDK_VERSION_NUM%
+
+[com.qt.desktop.qt.500]
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+
+[com.qt.desktop.qt.500.gcc]
+archives:               qt.500.gcc
+target_install_base:    /Desktop/Qt/5.0.0/gcc
+version:                5.0.0
+version_tag:            %QT_VERSION_NUM%
+package_default:        true
+[qt.500.gcc]
+archive_uri:            qt-5.0.0-desktop-gcc.7z
+package_strip_dirs:     4
+target_install_dir:     /
+rpath_target:           /lib
+archive_name:           qt-5.0.0-desktop-gcc.7z
+
+
+[OfflinePackageExcludeList]
+package_list:
+
+[PackagesNamespace]
+name:                   com.qt
+
+[SdkUpdateRepository]
+repository_url:
+repository_url_rnd:
+
+[TargetArchitechture]
+instruction_set:        x86_32
+
+[ConfigDir]
+template_name:          config_qt5
+target_dir:             config
+
+[ConfigXml]
+template_name:          config.xml.template.windows
+
+[WorkingDirectories]
+packages_dir:           pkg
+
+[InstallerFrameworkTools]
+name:                   ifwt
+package_url:            http://<url_to>/installer-framework-build-win-32bit.7z
+version:                1.2.0
+
+
diff --git a/release-tools/create_installer.py b/release-tools/create_installer.py
new file mode 100644
index 0000000..de02460
--- /dev/null
+++ b/release-tools/create_installer.py
@@ -0,0 +1,911 @@
+#!/usr/bin/env python
+###############################################
+#
+# Copyright (C) 2012 Digia Plc
+# For any questions to Digia, please use contact form at http://qt.digia.com
+#
+# $QT_BEGIN_LICENSE:LGPL$
+# GNU Lesser General Public License Usage
+# This file may be used under the terms of the GNU Lesser General Public
+# License version 2.1 as published by the Free Software Foundation and
+# appearing in the file LICENSE.LGPL included in the packaging of this
+# file. Please review the following information to ensure the GNU Lesser
+# General Public License version 2.1 requirements will be met:
+# http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+#
+# GNU General Public License Usage
+# Alternatively, this file may be used under the terms of the GNU General
+# Public License version 3.0 as published by the Free Software Foundation
+# and appearing in the file LICENSE.GPL included in the packaging of this
+# file. Please review the following information to ensure the GNU General
+# Public License version 3.0 requirements will be met:
+# http://www.gnu.org/copyleft/gpl.html.
+#
+# $QT_END_LICENSE$
+#
+# If you have questions regarding the use of this file, please use
+# contact form at http://qt.digia.com
+#
+###############################################
+
+"""Scripts to generate SDK installer based on open source InstallerFramework"""
+import ConfigParser
+import os
+import shutil
+import sys
+from time import gmtime, strftime
+import urllib
+import bldinstallercommon
+import bld_ifw_tools_impl
+
+BUILD_TIMESTAMP         = strftime('%d-%b-%Y', gmtime())
+CONFIG_COMMON           = 0
+CONFIG_TARGET           = 0
+PLATFORM_IDENTIFIER     = ''
+CONFIG_NAME             = ''
+SCRIPT_ROOT_DIR         = os.getcwd()
+GENERAL_TAG_SUBST_LIST  = []
+CONFIGURATIONS_DIR      = 'configurations'
+COMMON_CONFIG_NAME      = 'common'
+REPO_OUTPUT_DIR         = os.path.normpath(SCRIPT_ROOT_DIR + os.sep + 'repository')
+SDK_VERSION_NUMBER      = ''
+PACKAGES_DIR_NAME       = ''
+PACKAGES_FULL_PATH_SRC  = ''
+PACKAGES_FULL_PATH_DST  = ''
+ROOT_COMPONENT_NAME     = ''
+CONFIG_XML_TARGET_DIR   = ''
+PACKAGES_NAMESPACE      = ''
+IFW_TOOLS_DIR           = ''
+ARCHIVEGEN_TOOL         = ''
+BINARYCREATOR_TOOL      = ''
+INSTALLERBASE_TOOL      = ''
+REPOGEN_TOOL            = ''
+SDK_NAME_ROOT           = ''
+SDK_NAME                = ''
+DEBUG_RPATH             = False
+DUMP_CONFIG             = False
+# force development mode as default. Change to False if using pre-built package
+DEVELOPMENT_MODE        = True
+OFFLINE_MODE            = False
+TESTCLIENT_MODE         = False
+
+IFW_DOWNLOADABLE_ARCHIVE_NAMES_TAG  = '%IFW_DOWNLOADABLE_ARCHIVE_NAMES%'
+TARGET_INSTALL_DIR_NAME_TAG         = '%TARGET_INSTALL_DIR%'
+PACKAGE_DEFAULT_TAG                 = '%PACKAGE_DEFAULT_TAG%'
+SDK_VERSION_NUM_TAG                 = '%SDK_VERSION_NUM%'
+UPDATE_REPOSITORY_URL_TAG           = '%UPDATE_REPOSITORY_URL%'
+PACKAGE_CREATION_DATE_TAG           = '%PACKAGE_CREATION_DATE%'
+
+##############################################################
+# Start
+##############################################################
+def main():
+    """ Start """
+    if parse_cmd_line():
+        create_installer()
+        sys.exit(0)
+    else:
+        printInfo()
+        sys.exit(-1)
+
+
+##############################################################
+# Print usage info
+##############################################################
+def print_info():
+    """ Print usage info """
+    print ''
+    print ''
+    print 'Invalid number of arguments!'
+    print ''
+    print 'Usage: python create_installer.py <platform> <configuration_name>'
+    print ''
+    print 'Optional arguments:'
+    print '  <offline>    Creates offline installer'
+    print '  <devmode>    Builds Qt and IFW. Enabled by default. (does not download pre-build IFW)'
+    print '  <testclient> Creates installer for RnD testing purposes only (different dist server used)'
+    print ''
+
+
+##############################################################
+# Check if valid platform identifier
+##############################################################
+def check_platform_identifier(platform_identifier):
+    """Check if given platform identifier is valid."""
+    path_to_be_checked = SCRIPT_ROOT_DIR + os.sep + CONFIGURATIONS_DIR + os.sep + platform_identifier
+    if os.path.exists(path_to_be_checked):
+        return
+    print '*** Unsupported platform identifier given: ' + platform_identifier
+    sys.exit(-1)
+
+
+##############################################################
+# Check if valid configuration file
+##############################################################
+def check_configuration_file(configuration_name):
+    """ Check if valid configuration file """
+    path_to_be_checked = SCRIPT_ROOT_DIR + os.sep + CONFIGURATIONS_DIR + os.sep + PLATFORM_IDENTIFIER + os.sep + configuration_name
+    if os.path.isfile(path_to_be_checked):
+        return
+    print '*** Unable to find given configuration file: ' + path_to_be_checked
+    sys.exit(-1)
+
+
+##############################################################
+# Parse command line arguments
+##############################################################
+def parse_cmd_line():
+    """Parse command line arguments."""
+    arg_count = len(sys.argv)
+    if arg_count < 3:
+        return False
+
+    global PLATFORM_IDENTIFIER
+    global CONFIG_NAME
+    global DEVELOPMENT_MODE
+    global OFFLINE_MODE
+    global TESTCLIENT_MODE
+
+    PLATFORM_IDENTIFIER = sys.argv[1]
+    CONFIG_NAME = sys.argv[2]
+    check_platform_identifier(PLATFORM_IDENTIFIER)
+    check_configuration_file(CONFIG_NAME)
+
+    if(arg_count > 3):
+        counter = 3
+        while(counter < arg_count):
+            argument = sys.argv[counter].lower()
+            if 'devmode' == argument:
+                DEVELOPMENT_MODE = True
+            elif 'offline' == argument:
+                OFFLINE_MODE = True
+            elif 'testclient' == argument:
+                TESTCLIENT_MODE = True
+            else:
+                print '*** Unsupported argument given: ' + argument
+                sys.exit(-1)
+
+            counter = counter + 1
+
+    return True
+
+
+##############################################################
+# Initialize config parsers
+##############################################################
+def init_data():
+    """Init data based on configuration files."""
+    print '----------------------------------------'
+    print 'Init Data'
+    global CONFIG_COMMON
+    global CONFIG_TARGET
+    global PACKAGES_DIR_NAME
+    global SDK_VERSION_NUMBER
+    global SDK_NAME
+    global SDK_NAME_ROOT
+    global PACKAGES_NAMESPACE
+    global PACKAGES_FULL_PATH_SRC
+    global PACKAGES_FULL_PATH_DST
+    global IFW_TOOLS_DIR
+
+    if DEVELOPMENT_MODE:
+        print '--------------------------'
+        print '[Development mode enabled]'
+        print '--------------------------'
+
+    common_conf_path = SCRIPT_ROOT_DIR + os.sep + CONFIGURATIONS_DIR + os.sep + PLATFORM_IDENTIFIER + os.sep + COMMON_CONFIG_NAME
+    target_conf_path = SCRIPT_ROOT_DIR + os.sep + CONFIGURATIONS_DIR + os.sep + PLATFORM_IDENTIFIER + os.sep + CONFIG_NAME
+    CONFIG_COMMON = ConfigParser.ConfigParser()
+    print 'Parsing: ' + common_conf_path
+    CONFIG_COMMON.readfp(open(common_conf_path))
+    CONFIG_TARGET = ConfigParser.ConfigParser()
+    print 'Parsing: ' + target_conf_path
+    CONFIG_TARGET.readfp(open(target_conf_path))
+
+    PACKAGES_DIR_NAME   = bldinstallercommon.config_section_map(CONFIG_TARGET,'WorkingDirectories')['packages_dir']
+    PACKAGES_DIR_NAME   = os.path.normpath(PACKAGES_DIR_NAME)
+    SDK_VERSION_NUMBER  = bldinstallercommon.config_section_map(CONFIG_COMMON,'SdkCommon')['version']
+    SDK_NAME            = bldinstallercommon.config_section_map(CONFIG_COMMON,'SdkCommon')['name']
+    SDK_NAME_ROOT       = SDK_NAME
+    PACKAGES_NAMESPACE  = bldinstallercommon.config_section_map(CONFIG_TARGET,'PackagesNamespace')['name']
+    # if the packages directory name is absolute path, then the packages templates (or static packages)
+    # can reside outside the "<script_root_dir>/configurations" folder
+    # otherwise the packages templates must be under "/configurations"
+    if os.path.isabs(PACKAGES_DIR_NAME):
+        PACKAGES_FULL_PATH_SRC = os.path.normpath(PACKAGES_DIR_NAME)
+        PACKAGES_FULL_PATH_DST = os.path.normpath(SCRIPT_ROOT_DIR + os.sep + os.path.basename(PACKAGES_DIR_NAME))
+    else:
+        PACKAGES_FULL_PATH_SRC = os.path.normpath(SCRIPT_ROOT_DIR + os.sep + CONFIGURATIONS_DIR + os.sep + PACKAGES_DIR_NAME)
+        PACKAGES_FULL_PATH_DST = os.path.normpath(SCRIPT_ROOT_DIR + os.sep + PACKAGES_DIR_NAME)
+
+    if OFFLINE_MODE:
+        SDK_NAME = SDK_NAME + '-offline'
+    else:
+        SDK_NAME = SDK_NAME + '-online'
+
+    if TESTCLIENT_MODE:
+        SDK_NAME = SDK_NAME + '-RnD_testclient'
+
+    if not DEVELOPMENT_MODE:
+        tools_dir_name = bldinstallercommon.config_section_map(CONFIG_TARGET,'InstallerFrameworkTools')['name']
+        IFW_TOOLS_DIR = SCRIPT_ROOT_DIR + os.sep + tools_dir_name
+        IFW_TOOLS_DIR = os.path.normpath(IFW_TOOLS_DIR)
+
+    if DUMP_CONFIG:
+        bldinstallercommon.dump_config(CONFIG_COMMON, COMMON_CONFIG_NAME)
+        bldinstallercommon.dump_config(CONFIG_TARGET, CONFIG_NAME)
+
+
+##############################################################
+# Cleanup
+##############################################################
+def clean_work_dirs():
+    """Clean working directories."""
+    print '----------------------------------------'
+    print 'Cleaning environment'
+
+    # delete "/packages"
+    if os.path.exists(PACKAGES_FULL_PATH_DST):
+        bldinstallercommon.remove_tree(PACKAGES_FULL_PATH_DST)
+        print '-> deleted old existing directory: ' + PACKAGES_FULL_PATH_DST
+    # delete "/ifw-tools"
+    if os.path.exists(IFW_TOOLS_DIR):
+        bldinstallercommon.remove_tree(IFW_TOOLS_DIR)
+        print '-> deleted old existing directory: ' + IFW_TOOLS_DIR
+    # delete "/repositories"
+    if os.path.exists(REPO_OUTPUT_DIR):
+        bldinstallercommon.remove_tree(REPO_OUTPUT_DIR)
+        print '-> deleted old existing directory: ' + REPO_OUTPUT_DIR
+    # delete "/config"
+    config_dir_dest = bldinstallercommon.config_section_map(CONFIG_TARGET,'ConfigDir')['target_dir']
+    config_dir_dest = os.path.normpath(SCRIPT_ROOT_DIR + os.sep + config_dir_dest)
+    if os.path.exists(config_dir_dest):
+        bldinstallercommon.remove_tree(config_dir_dest)
+        print '-> deleted old existing directory: ' + config_dir_dest
+    # delete sdk binary files
+    fileList = os.listdir(SCRIPT_ROOT_DIR)
+    for fname in fileList:
+        if fname.startswith(SDK_NAME_ROOT):
+            full_fn = SCRIPT_ROOT_DIR + os.sep + fname
+            if os.path.isdir(full_fn):
+                print '-> deleted ' + full_fn
+                bldinstallercommon.remove_tree(full_fn)
+            else:
+                print '-> deleted ' + full_fn
+                os.remove(full_fn)
+
+
+##############################################################
+# Set the config directory
+##############################################################
+def set_config_directory():
+    """Copy config directory into correct place."""
+    global CONFIG_XML_TARGET_DIR
+    config_dir_template = bldinstallercommon.config_section_map(CONFIG_TARGET,'ConfigDir')['template_name']
+    config_dir_template = os.path.normpath(SCRIPT_ROOT_DIR + os.sep + CONFIGURATIONS_DIR + os.sep + config_dir_template)
+
+    config_dir_dest = bldinstallercommon.config_section_map(CONFIG_TARGET,'ConfigDir')['target_dir']
+    config_dir_dest = os.path.normpath(SCRIPT_ROOT_DIR + os.sep + config_dir_dest)
+    CONFIG_XML_TARGET_DIR = config_dir_dest
+
+    if not os.path.exists(config_dir_dest):
+        bldinstallercommon.create_dirs(config_dir_dest)
+    bldinstallercommon.copy_tree(config_dir_template, config_dir_dest)
+
+
+##############################################################
+# Set the config.xml
+##############################################################
+def set_config_xml():
+    """Copy config.xml template into correct place."""
+    print '----------------------------------------'
+    print 'Set config.xml'
+
+    configxml_filename = bldinstallercommon.config_section_map(CONFIG_TARGET,'ConfigXml')['template_name']
+    config_template_source = SCRIPT_ROOT_DIR + os.sep + CONFIGURATIONS_DIR + os.sep + PLATFORM_IDENTIFIER + os.sep + configxml_filename
+    # if no config.xml template, we assume the "config" template dir already contains it
+    if not os.path.exists(config_template_source):
+        return
+
+    # name has to be config.xml for installer-framework
+    config_template_dest_dir = CONFIG_XML_TARGET_DIR
+    config_template_dest = config_template_dest_dir + os.sep + 'config.xml'
+
+    if os.path.exists(config_template_dest):
+        os.remove(config_template_dest)
+        print '-> deleted old existing config.xml: ' + config_template_dest
+    if not os.path.exists(config_template_dest_dir):
+        bldinstallercommon.create_dirs(config_template_dest_dir)
+    shutil.copy(config_template_source, config_template_dest)
+    print '-> copied [' + config_template_source + '] into [' + config_template_dest + ']'
+
+    update_repository_url = bldinstallercommon.config_section_map(CONFIG_TARGET,'SdkUpdateRepository')['repository_url']
+
+    fileslist = [config_template_dest]
+    bldinstallercommon.replace_in_files(fileslist, SDK_VERSION_NUM_TAG, SDK_VERSION_NUMBER)
+    bldinstallercommon.replace_in_files(fileslist, UPDATE_REPOSITORY_URL_TAG, update_repository_url)
+
+
+##############################################################
+# Substitute common version numbers etc., match against tags
+##############################################################
+def substitute_global_tags():
+    """ Substitute common version numbers etc., match against tags """
+    print '      ----------------------------------------'
+    print '      Substituting global tags:'
+    print '      %PACKAGE_CREATION_DATE% = ' + BUILD_TIMESTAMP
+    print '      %SDK_VERSION_NUM%       = ' + SDK_VERSION_NUMBER
+
+    # initialize the file list
+    fileslist = []
+    for directory in GENERAL_TAG_SUBST_LIST:
+        for root, dirs, files in os.walk(directory):
+            for name in files:
+                path = os.path.join(root, name)
+                fileslist.append(path)
+
+    bldinstallercommon.replace_in_files(fileslist, SDK_VERSION_NUM_TAG, SDK_VERSION_NUMBER)
+    bldinstallercommon.replace_in_files(fileslist, PACKAGE_CREATION_DATE_TAG, BUILD_TIMESTAMP)
+
+
+##############################################################
+# Substitute component specifig tags
+##############################################################
+def substitute_component_tags(tag_pair_list, meta_dir_dest):
+    """ Substitute component specific tags """
+    if len(tag_pair_list) == 0:
+        return
+    print '      ----------------------------------------'
+    print '      Substituting component specific tags:'
+    # initialize the file list
+    fileslist = []
+
+    for root, dirs, files in os.walk(meta_dir_dest):
+        for name in files:
+            path = os.path.join(root, name)
+            fileslist.append(path)
+
+    for pair in tag_pair_list:
+        tag = pair[0]
+        value = pair[1]
+        if tag and value:
+            print '      Matching [ ' + tag + ' ] and [ ' + value + ' ] in files list'
+            bldinstallercommon.replace_in_files(fileslist, tag, value)
+        else:
+            print '      Warning! Ignoring incomplete tag pair [ ' + tag + ' ] for [ ' + value + ' ] pair'
+
+
+##############################################################
+# Repackage content of the installable compoment
+##############################################################
+def repackage_content_for_installation(install_dir, package_raw_name, rpath_target, package_strip_dirs, package_name, archive_name):
+    """Repackage content into 7z archive."""
+    # if no data to be installed, then just return
+    if not package_raw_name:
+        return
+    if not package_strip_dirs:
+        package_strip_dirs = '0'
+
+    print '        +++++++++++++++++++++++++++++++++++++++++'
+    print '        Repackage:             ' + package_raw_name
+    print '        Location:              ' + install_dir
+    print '        Dirst to be stripped:  ' + package_strip_dirs
+    if rpath_target == '':
+        print '        Relocate RPath:        No'
+    else:
+        print '        Relocate RPath into:   ' + '(' + install_dir + ') '+ rpath_target
+    print ''
+
+    if package_raw_name.endswith('.7z') and package_strip_dirs == '0' and not rpath_target:
+        print '        No repackaging actions requred for the package'
+        return
+
+    # extract contents
+    bldinstallercommon.extract_file(install_dir + os.sep + package_raw_name, install_dir)
+    # remove old package
+    os.remove(install_dir + os.sep + package_raw_name)
+    # strip out unnecessary folder structure based on the configuration
+    count = 0
+    iterations = int(package_strip_dirs)
+    while(count < iterations):
+        #print 'Strip iteration: ' + str(count)
+        count = count + 1
+        l = os.listdir(install_dir)
+        items = len(l)
+        if items == 1:
+            dir_name = l[0]
+            os.chdir(install_dir)
+            # TODO, windows hack, on windows path+filename > 255 causes error, so truncate temp path as much as possible
+            temp_path_name = 'a'
+            os.rename(dir_name, temp_path_name)
+            bldinstallercommon.move_tree(temp_path_name, '.')
+            bldinstallercommon.remove_tree(temp_path_name)
+            os.chdir(SCRIPT_ROOT_DIR)
+        else:
+            print '*** Error: unsupported folder structure encountered, abort!'
+            print '*** Found items: ' + str(items) + ' in directory: ' + install_dir
+            sys.exit(-1)
+
+    if rpath_target:
+        if not rpath_target.startswith( os.sep ):
+            rpath_target = os.sep + rpath_target
+        if bldinstallercommon.is_linux_platform() or bldinstallercommon.is_solaris_platform():
+            bldinstallercommon.handle_component_rpath(install_dir, rpath_target)
+
+    # lastly compress the component back to .7z archive
+    archive_component(package_name, archive_name)
+
+
+##############################################################
+# Archive installable component
+##############################################################
+def archive_component(package, package_archive_name):
+    """Use archivegen tool to archive component."""
+    full_path = os.path.normpath(PACKAGES_FULL_PATH_DST + os.sep + package + os.sep + 'data')
+    content_path = full_path + os.sep + '*'
+    package_path = full_path + os.sep + package_archive_name
+    print '      --------------------------------------------------------------------'
+    print '      Archive package: ' + package
+    print '      Content from:    ' + content_path
+    print '      Final archive:   ' + package_path
+
+    saveas = os.path.normpath(PACKAGES_FULL_PATH_DST + os.sep + package + os.sep + package_archive_name)
+    cmd_args = ARCHIVEGEN_TOOL + ' ' + saveas + ' .'
+    bldinstallercommon.do_execute_sub_process_2(cmd_args, full_path, True)
+    shutil.copy(saveas, full_path + os.sep + package_archive_name)
+    os.remove(saveas)
+
+    # remove stuff after archive creation
+    ldir = os.listdir(full_path)
+    for item in ldir:
+        if not item == package_archive_name:
+            item_full_path = full_path + os.sep + item
+            if os.path.isdir(item_full_path):
+                bldinstallercommon.remove_tree(item_full_path)
+            else:
+                os.remove(item_full_path)
+
+
+##############################################################
+# Create online components
+##############################################################
+def create_online_target_components(target_config):
+    """Create installable online installer."""
+    global GENERAL_TAG_SUBST_LIST
+    bldinstallercommon.create_dirs(PACKAGES_FULL_PATH_DST)
+
+    print '=================================================='
+    print '= Creating online SDK components'
+    print '=================================================='
+    print ''
+    for section in target_config.sections():
+        if section.startswith(PACKAGES_NAMESPACE):
+            print '--------------------------------------------------------------------------------'
+            is_root_component = bldinstallercommon.safe_config_key_fetch(target_config, section, 'root_component')
+            if is_root_component == 'yes':
+                meta_dir_dest = PACKAGES_FULL_PATH_DST + os.sep + section + os.sep + 'meta'
+                meta_dir_dest = os.path.normpath(meta_dir_dest)
+                bldinstallercommon.create_dirs(meta_dir_dest)
+                print '      Created:                ' + meta_dir_dest
+                # Copy meta data
+                metadata_content_source_root = PACKAGES_FULL_PATH_SRC + os.sep + section + os.sep + "meta"
+                metadata_content_source_root = os.path.normpath(metadata_content_source_root)
+                bldinstallercommon.copy_tree(metadata_content_source_root, meta_dir_dest)
+                # substitute required tags
+                GENERAL_TAG_SUBST_LIST.append(meta_dir_dest)
+                # check for downloadableArchiveName
+                archive_name = bldinstallercommon.safe_config_key_fetch(target_config, section, 'archive_name')
+                package_url  = bldinstallercommon.safe_config_key_fetch(target_config, section, 'package_url')
+                if len(package_url) > 0 and archive_name == '':
+                    print '*** Variable [archive_name] was empty? This is required if package content is used , check config file!'
+                    print '*** Abort!'
+                    sys.exit(-1)
+                tag_pair_list = []
+                tag_pair_list.append([IFW_DOWNLOADABLE_ARCHIVE_NAME_TAG, archive_name])
+                substitute_component_tags(tag_pair_list, meta_dir_dest)
+                return
+            else:
+                continue
+
+
+##############################################################
+# Create offline static component
+##############################################################
+def create_offline_static_component(target_config, section, static_package_src):
+    """Create installable offline target component from static data."""
+    print '--------------------------------------------------------------------------------'
+    print ' Static package: [' + section + ']'
+    # Create needed dirs
+    package_dest_dir = os.path.normpath(PACKAGES_FULL_PATH_DST + os.sep + section)
+    bldinstallercommon.create_dirs(package_dest_dir)
+    # copy static content, assumption is that content is on local machine or on
+    # accessible network share
+    print '      Copying static package: '   + section
+    print '              Package source: '   + static_package_src
+    print '              Package dest:   '   + package_dest_dir
+    bldinstallercommon.copy_tree(static_package_src, package_dest_dir)
+    print '      Copying static package: Done!'
+    print '--------------------------------------------------------------------------------'
+
+
+##############################################################
+# Construct archive
+##############################################################
+def handle_archive(package_name, archive_uri, package_strip_dirs,
+                   target_install_base, target_install_dir,
+                   rpath_target, archive_name):
+    """Handle single archive."""
+    print '      --------------------------------------------------------------'
+    print '      Handle archive:        '   + archive_name
+    print '        archive_uri:         '   + archive_uri
+    print '        package_strip_dirs:  '   + package_strip_dirs
+    print '        target_install_base: '   + target_install_base
+    print '        target_install_dir:  '   + target_install_dir
+    print '        rpath_target:        '   + rpath_target
+    print ''
+
+    # sanity check
+    if len(archive_uri) > 0 and not archive_name:
+        print '*** Variable [archive_name] was empty? This is required if [archive_uri] is used , check config file!'
+        print '*** Abort!'
+        sys.exit(-1)
+
+    # Create needed data dirs
+    data_dir_dest = os.path.normpath(PACKAGES_FULL_PATH_DST + os.sep + package_name + os.sep + 'data')
+    install_dir = os.path.normpath(data_dir_dest + os.sep + target_install_base + os.sep + target_install_dir)
+    bldinstallercommon.create_dirs(install_dir)
+    print '        Created:             ' + install_dir
+
+    # transfer package from origin into destination
+    package_raw_name     = os.path.basename(archive_uri)
+    package_save_as_temp = os.path.normpath(install_dir + os.sep + os.path.basename(archive_uri))
+    if archive_uri.startswith('http'):
+        print '        Downloading:        ' + archive_uri
+        print '               into:        ' + package_save_as_temp
+        # validate url
+        res = bldinstallercommon.is_content_url_valid(archive_uri)
+        if not(res):
+            print '*** Package URL is invalid: [' + archive_uri + ']'
+            print '*** Abort!'
+            sys.exit(-1)
+        # start download
+        urllib.urlretrieve(archive_uri, package_save_as_temp)
+    else:
+        data_content_source_root = os.path.normpath(PACKAGES_FULL_PATH_SRC + os.sep + package_name + os.sep + 'data')
+        # try first if the uri points to absolute file path
+        if os.path.isfile(archive_uri):
+            print '        Copying:             ' + archive_uri
+            print '           into:             ' + package_save_as_temp
+            shutil.copy(archive_uri, package_save_as_temp)
+        else:
+            # lastly try to check if the given file exists in the templates '/data' folder
+            temp = os.path.normpath(data_content_source_root + os.sep + archive_uri)
+            if os.path.isfile( temp ):
+                print '        Copying:             ' + temp
+                print '           into:             ' + package_save_as_temp
+                shutil.copy(temp, package_save_as_temp)
+            else:
+                print '*** Error! Unable to locate file defined by archive_uri: ' + archive_uri
+                sys.exit(-1)
+
+    # repackage content so that correct dir structure will get into the package
+    repackage_content_for_installation(install_dir, package_raw_name, rpath_target, package_strip_dirs, package_name, archive_name)
+
+
+##############################################################
+# Generate java script code that is embedded into installscript.qs
+##############################################################
+def generate_downloadable_archive_list(downloadable_archive_list):
+    """Generate java script code that is embedded into installscript.qs"""
+    output = ''
+    for item in downloadable_archive_list:
+        output = output + 'component.addDownloadableArchive(\"' + item + '\");'
+
+    temp_list = []
+    temp_list.append([IFW_DOWNLOADABLE_ARCHIVE_NAMES_TAG, output])
+    return temp_list
+
+
+##############################################################
+# Create all target components
+##############################################################
+def create_offline_target_components(target_config):
+    """Create installable offline target components."""
+    global ROOT_COMPONENT_NAME
+    bldinstallercommon.create_dirs(PACKAGES_FULL_PATH_DST)
+
+    print '=================================================='
+    print '= Creating offline SDK components'
+    print '=================================================='
+    print ''
+    for section in target_config.sections():
+        if section.startswith(PACKAGES_NAMESPACE):
+            # check first for top level component
+            is_root_component = bldinstallercommon.safe_config_key_fetch(target_config, section, 'root_component')
+            if is_root_component == 'yes':
+                ROOT_COMPONENT_NAME = section
+            # check if static component or not
+            static_component = bldinstallercommon.safe_config_key_fetch(target_config, section, 'static_component')
+            if static_component:
+                create_offline_static_component(target_config, section, static_component)
+                continue
+
+            # otherwise "build" the component
+            package_name            = section
+            archives                = bldinstallercommon.safe_config_key_fetch(target_config, section, 'archives')
+            target_install_base     = bldinstallercommon.safe_config_key_fetch(target_config, section, 'target_install_base')
+            version                 = bldinstallercommon.safe_config_key_fetch(target_config, section, 'version')
+            version_tag             = bldinstallercommon.safe_config_key_fetch(target_config, section, 'version_tag')
+            package_default         = bldinstallercommon.safe_config_key_fetch(target_config, section, 'package_default')
+            if (package_default != 'true') and (package_default != 'script'):
+                package_default = 'false'
+
+            print '--------------------------------------------------------------------------------'
+            print '    '                             + package_name
+            print '      Package target_install_base:   '   + target_install_base
+            print '      Package version:               '   + version
+            print '      Package version_tag:           '   + version_tag
+            print '      Package package_default:       '   + package_default
+            print '      Package archives:              '   + archives
+
+            # create destination meta data folder
+            meta_dir_dest = os.path.normpath(PACKAGES_FULL_PATH_DST + os.sep + package_name + os.sep + 'meta')
+            bldinstallercommon.create_dirs(meta_dir_dest)
+            print '      Created:                       ' + meta_dir_dest
+            # Copy Meta data
+            metadata_content_source_root = os.path.normpath(PACKAGES_FULL_PATH_SRC + os.sep + package_name + os.sep + 'meta')
+            bldinstallercommon.copy_tree(metadata_content_source_root, meta_dir_dest)
+            print '      Copied metadata'
+            # add files into tag substitution
+            GENERAL_TAG_SUBST_LIST.append(meta_dir_dest)
+            # create lists for component specific tag substitutions
+            component_metadata_tag_pair_list = []
+
+            # version tag exists
+            if version_tag or version:
+                component_metadata_tag_pair_list.append([version_tag, version])
+            # substitute default package info
+            if package_default == 'true':
+                component_metadata_tag_pair_list.append([PACKAGE_DEFAULT_TAG, 'true'])
+            elif package_default == 'script':
+                component_metadata_tag_pair_list.append([PACKAGE_DEFAULT_TAG, 'script'])
+            else:
+                component_metadata_tag_pair_list.append([PACKAGE_DEFAULT_TAG, 'false'])
+
+            #target install dir substitution
+            if target_install_base:
+                component_metadata_tag_pair_list.append([TARGET_INSTALL_DIR_NAME_TAG, target_install_base])
+
+            # check if package contains archives i.e. 7z packages to be included
+            if archives:
+                downloadable_archive_list = []
+                archives_list = archives.split(',')
+                for archive in archives_list:
+                    archive_uri             = bldinstallercommon.config_section_map(target_config, archive)['archive_uri']
+                    package_strip_dirs      = bldinstallercommon.safe_config_key_fetch(target_config, archive, 'package_strip_dirs')
+                    # TODO, check if target_install_dir is needed at all
+                    target_install_dir      = bldinstallercommon.safe_config_key_fetch(target_config, archive, 'target_install_dir')
+                    rpath_target            = bldinstallercommon.safe_config_key_fetch(target_config, archive, 'rpath_target')
+                    archive_name            = bldinstallercommon.safe_config_key_fetch(target_config, archive, 'archive_name')
+                    # add downloadable archive name
+                    downloadable_archive_list.append(archive_name)
+                    handle_archive(package_name, archive_uri, package_strip_dirs, target_install_base, target_install_dir,
+                                   rpath_target, archive_name)
+                # substitute downloadable archive names in installscript.qs
+                downloadableArchives_list = generate_downloadable_archive_list(downloadable_archive_list)
+                substitute_component_tags(downloadableArchives_list, meta_dir_dest)
+
+            # substitute tags
+            substitute_component_tags(component_metadata_tag_pair_list, meta_dir_dest)
+
+
+##############################################################
+# Install Installer-Framework tools
+##############################################################
+def install_ifw_tools():
+    """Setup Installer-Framework tools."""
+    print '=================================================='
+    print '= Install Installer Framework tools'
+    print '=================================================='
+    global ARCHIVEGEN_TOOL
+    global BINARYCREATOR_TOOL
+    global INSTALLERBASE_TOOL
+    global REPOGEN_TOOL
+    package_save_as_temp = None
+
+    # if "devmode" mode used, then build IFW from sources
+    if DEVELOPMENT_MODE:
+        tools_dir_temp = bld_ifw_tools_impl.build_ifw('devmode', PLATFORM_IDENTIFIER)
+        tools_bin_path = SCRIPT_ROOT_DIR + os.sep + tools_dir_temp + os.sep + 'installerbuilder' + os.sep + 'bin' + os.sep
+    else:
+        tools_dir_name = bldinstallercommon.config_section_map(CONFIG_TARGET,'InstallerFrameworkTools')['name']
+        tools_dir_name = os.path.normpath(tools_dir_name)
+        package_url = bldinstallercommon.config_section_map(CONFIG_TARGET,'InstallerFrameworkTools')['package_url']
+        # create needed dirs
+        bldinstallercommon.create_dirs(IFW_TOOLS_DIR)
+        package_save_as_temp = IFW_TOOLS_DIR + os.sep + os.path.basename(package_url)
+        package_save_as_temp = os.path.normpath(package_save_as_temp)
+        print 'Source url: ' + package_url
+        print 'Install dest: ' + package_save_as_temp
+        # download IFW archive
+        if not package_url == '':
+            print 'Downloading:  ' + package_url
+            res = bldinstallercommon.is_content_url_valid(package_url)
+            if not(res):
+                print '*** Package URL is invalid: [' + package_url + ']'
+                print '*** Abort!'
+                sys.exit(-1)
+            urllib.urlretrieve(package_url, package_save_as_temp)
+        if not (os.path.isfile(package_save_as_temp)):
+            print '*** Downloading failed! Aborting!'
+            sys.exit(-1)
+        # extract IFW archive
+        bldinstallercommon.extract_file(package_save_as_temp, IFW_TOOLS_DIR)
+        os.remove(package_save_as_temp)
+        dir_items = os.listdir(IFW_TOOLS_DIR)
+        items = len(dir_items)
+        if items == 1:
+            dir_name = dir_items[0]
+            os.chdir(IFW_TOOLS_DIR)
+            bldinstallercommon.move_tree(dir_name, '.')
+            bldinstallercommon.remove_tree(dir_name)
+            os.chdir(SCRIPT_ROOT_DIR)
+        else:
+            print '*** Unsupported dir structure for installer-framework-tools package?!'
+            print '*** Abort!'
+            sys.exit(-1)
+
+        # todo, hard coded path used...
+        tools_bin_path = IFW_TOOLS_DIR + os.sep + 'installerbuilder' + os.sep + 'bin' + os.sep
+
+    executable_suffix = bldinstallercommon.get_executable_suffix()
+    ARCHIVEGEN_TOOL = tools_bin_path + 'archivegen' + executable_suffix
+    BINARYCREATOR_TOOL = tools_bin_path + 'binarycreator' + executable_suffix
+    INSTALLERBASE_TOOL = tools_bin_path + 'installerbase' + executable_suffix
+    REPOGEN_TOOL = tools_bin_path + 'repogen' + executable_suffix
+    # check
+    if not (os.path.isfile(ARCHIVEGEN_TOOL)):
+        print '*** Archivegen tool not found: ' + ARCHIVEGEN_TOOL
+        sys.exit(-1)
+    if not (os.path.isfile(BINARYCREATOR_TOOL)):
+        print '*** Binarycreator tool not found: ' + BINARYCREATOR_TOOL
+        sys.exit(-1)
+    if not (os.path.isfile(INSTALLERBASE_TOOL)):
+        print '*** Installerbase tool not found: ' + INSTALLERBASE_TOOL
+        sys.exit(-1)
+    if not (os.path.isfile(REPOGEN_TOOL)):
+        print '*** Repogen tool not found: ' + REPOGEN_TOOL
+        sys.exit(-1)
+
+    print 'ARCHIVEGEN_TOOL: ' + ARCHIVEGEN_TOOL
+    print 'BINARYCREATOR_TOOL: ' + BINARYCREATOR_TOOL
+    print 'INSTALLERBASE_TOOL: ' + INSTALLERBASE_TOOL
+    print 'REPOGEN_TOOL: ' + REPOGEN_TOOL
+
+
+##############################################################
+# Create the final installer binary
+##############################################################
+def create_installer_binary():
+    """Create installer binary files using binarycreator tool."""
+    print '=================================================='
+    print '= Create installer binary'
+    print '=================================================='
+    global SDK_NAME
+
+    instruction_set = bldinstallercommon.config_section_map(CONFIG_TARGET,'TargetArchitechture')['instruction_set']
+    cmd_args = []
+    SDK_NAME += '-' + bldinstallercommon.get_platform_suffix()
+    SDK_NAME += '-' + instruction_set
+    tmp = SDK_VERSION_NUMBER
+    if bldinstallercommon.is_win_platform():
+        tmp = SDK_VERSION_NUMBER.replace('.', '_')
+
+    SDK_NAME = SDK_NAME + '-v' + tmp
+
+    if bldinstallercommon.is_linux_platform():
+        SDK_NAME = SDK_NAME + '.run'
+
+    cmd_args = [BINARYCREATOR_TOOL, '-t', INSTALLERBASE_TOOL, '-v', '-p', PACKAGES_FULL_PATH_DST]
+    if OFFLINE_MODE:
+        # check if package exclude list should be used for offline installer
+        package_exclude_list = bldinstallercommon.safe_config_key_fetch(CONFIG_TARGET, 'OfflinePackageExcludeList', 'package_list')
+        package_exclude_list = package_exclude_list.replace('\n', '')
+        if package_exclude_list:
+            cmd_args = cmd_args + ['-e', package_exclude_list]
+    cmd_args = cmd_args + ['-c', CONFIG_XML_TARGET_DIR, SDK_NAME, ROOT_COMPONENT_NAME]
+
+    if OFFLINE_MODE:
+        cmd_args = cmd_args + ['--offline-only']
+        print 'Creating repository for the SDK ...'
+        print '    Outputdir: ' + REPO_OUTPUT_DIR
+        print '      pkg src: ' + PACKAGES_FULL_PATH_DST
+        repogen_args = [REPOGEN_TOOL, '-p', PACKAGES_FULL_PATH_DST, '-c', CONFIG_XML_TARGET_DIR, REPO_OUTPUT_DIR, ROOT_COMPONENT_NAME]
+        bldinstallercommon.do_execute_sub_process(repogen_args, SCRIPT_ROOT_DIR, True)
+        if not os.path.exists(REPO_OUTPUT_DIR):
+            print '*** Fatal error! Unable to create repository directory: ' + REPO_OUTPUT_DIR
+            sys.exit(-1)
+
+    # sanity checks
+    if not os.path.exists(PACKAGES_FULL_PATH_DST):
+        print '*** Fatal error! Could not find packages directory: ' + PACKAGES_FULL_PATH_DST
+        sys.exit(-1)
+
+    bldinstallercommon.do_execute_sub_process(cmd_args, SCRIPT_ROOT_DIR, True)
+
+
+##############################################################
+# Create the final installer binary
+##############################################################
+def create_mac_disk_image():
+    """Create Mac disk image."""
+    print '=================================================='
+    print '= Create mac disk image'
+    print '=================================================='
+
+    nib_archive_name = bldinstallercommon.safe_config_key_fetch(CONFIG_TARGET, 'qtmenunib', 'package_url')
+    package_save_as_folder = SCRIPT_ROOT_DIR + os.sep + SDK_NAME + '.app' + os.sep + 'Contents' + os.sep + 'Resources'
+    package_save_as_temp = package_save_as_folder + os.sep + os.path.basename(nib_archive_name)
+    print ' package_url: ' + nib_archive_name
+    print ' save as:     ' + package_save_as_temp
+
+    if not nib_archive_name == '':
+        print '    Downloading:            ' + nib_archive_name
+        print '           into:            ' + package_save_as_temp
+        res = bldinstallercommon.is_content_url_valid(nib_archive_name)
+        if not(res):
+            print '*** Package URL is invalid: [' + nib_archive_name + ']'
+            print '*** Abort!'
+            sys.exit(-1)
+        urllib.urlretrieve(nib_archive_name, package_save_as_temp)
+
+    # extract contents
+    bldinstallercommon.extract_file(package_save_as_temp, package_save_as_folder)
+
+    # create disk image
+    cmd_args = ['hdiutil', 'create', '-fs', 'HFS+', '-srcfolder', \
+                os.path.join(SCRIPT_ROOT_DIR, SDK_NAME + '.app'), \
+                '-volname', SDK_NAME, \
+                os.path.join(SCRIPT_ROOT_DIR, SDK_NAME + '.dmg')]
+    bldinstallercommon.do_execute_sub_process(cmd_args, SCRIPT_ROOT_DIR, True)
+
+
+##############################################################
+# All main build steps
+##############################################################
+def create_installer():
+    """Installer creation main steps."""
+    print ''
+    print ''
+    print '=================================================='
+    print '= Creating SDK'
+    print '=================================================='
+    # init
+    bldinstallercommon.init_common_module(SCRIPT_ROOT_DIR)
+    # init data
+    init_data()
+    # clean env before starting
+    clean_work_dirs()
+    # set config templates
+    set_config_directory()
+    set_config_xml()
+    # install Installer Framework tools
+    install_ifw_tools()
+    # create components
+    if OFFLINE_MODE:
+        create_offline_target_components(CONFIG_TARGET)
+    else:
+        create_online_target_components(CONFIG_TARGET)
+    # substitute global tags
+    substitute_global_tags()
+    # create the installer binary
+    create_installer_binary()
+    # for mac we need some extra work
+    if bldinstallercommon.is_mac_platform():
+        create_mac_disk_image()
+
+
+##############################################################
+# Start build process
+##############################################################
+main()