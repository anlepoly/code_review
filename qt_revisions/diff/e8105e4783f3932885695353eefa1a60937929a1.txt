diff --git a/src/widgets/dialogs/qcolordialog.cpp b/src/widgets/dialogs/qcolordialog.cpp
index 67c7ec4..e592f14 100644
--- a/src/widgets/dialogs/qcolordialog.cpp
+++ b/src/widgets/dialogs/qcolordialog.cpp
@@ -64,10 +64,6 @@
 #include "qspinbox.h"
 #include "qdialogbuttonbox.h"
 
-#ifdef MAEMO_UI
-#  define QT_SMALL_COLORDIALOG
-#endif
-
 QT_BEGIN_NAMESPACE
 
 //////////// QWellArray BEGIN
@@ -1064,14 +1060,6 @@ QColorShower::QColorShower(QColorDialog *parent)
     gl->setMargin(gl->spacing());
     lab = new QColorShowLabel(this);
 
-#ifdef QT_SMALL_COLORDIALOG
-#  ifdef Q_WS_S60
-    const bool nonTouchUI = !S60->hasTouchscreen;
-#  elif defined Q_WS_MAEMO_5
-    const bool nonTouchUI = false;
-#  endif
-#endif
-
 #ifndef Q_WS_WINCE
 #ifdef QT_SMALL_COLORDIALOG
     lab->setMinimumHeight(60);
@@ -1081,7 +1069,6 @@ QColorShower::QColorShower(QColorDialog *parent)
     lab->setMinimumWidth(20);
 #endif
 
-// In S60, due to small screen and different screen layouts need to re-arrange the widgets.
 // For QVGA screens only the comboboxes and color label are visible.
 // For nHD screens only color and luminence pickers and color label are visible.
 #if !defined(QT_SMALL_COLORDIALOG)
@@ -1480,14 +1467,6 @@ void QColorDialogPrivate::init(const QColor &initial)
         topLay->addLayout(leftLay);
     }
 
-#if defined(QT_SMALL_COLORDIALOG)
-#  if defined(Q_WS_S60)
-    const bool nonTouchUI = !S60->hasTouchscreen;
-#  elif defined(Q_WS_MAEMO_5)
-    const bool nonTouchUI = false;
-#  endif
-#endif
-
     if (!smallDisplay) {
         standard = new QColorWell(q, 6, 8, QColorDialogOptions::standardColors());
         lblBasicColors = new QLabel(q);
diff --git a/src/widgets/dialogs/qerrormessage.cpp b/src/widgets/dialogs/qerrormessage.cpp
index 110ad98..4993a6d 100644
--- a/src/widgets/dialogs/qerrormessage.cpp
+++ b/src/widgets/dialogs/qerrormessage.cpp
@@ -71,9 +71,6 @@ extern bool qt_wince_is_high_dpi();  //defined in qguifunctions_wince.cpp
 #if defined(QT_SOFTKEYS_ENABLED)
 #include <qaction.h>
 #endif
-#ifdef Q_WS_S60
-#include "private/qt_s60_p.h"
-#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -134,14 +131,7 @@ QSize QErrorMessageTextView::sizeHint() const
     else
       return QSize(300, 100);
 #else
-
-#ifdef Q_WS_S60
-    const int smallerDimension = qMin(S60->screenHeightInPixels, S60->screenWidthInPixels);
-    // In S60 layout data, error messages seem to be one third of the screen height (in portrait) minus two.
-    return QSize(smallerDimension, smallerDimension/3-2);
-#else
     return QSize(250, 75);
-#endif //Q_WS_S60
 #endif //Q_WS_WINCE
 }
 
@@ -265,7 +255,7 @@ QErrorMessage::QErrorMessage(QWidget * parent)
 #endif
 
 
-#if defined(Q_WS_WINCE) || defined(Q_WS_S60)
+#if defined(Q_WS_WINCE)
     d->ok->setFixedSize(0,0);
 #endif
     connect(d->ok, SIGNAL(clicked()), this, SLOT(accept()));
diff --git a/src/widgets/dialogs/qfiledialog.cpp b/src/widgets/dialogs/qfiledialog.cpp
index 1c0c381..0d5bb68 100644
--- a/src/widgets/dialogs/qfiledialog.cpp
+++ b/src/widgets/dialogs/qfiledialog.cpp
@@ -1723,25 +1723,6 @@ extern QStringList qt_win_get_open_file_names(const QFileDialogArgs &args,
 extern QString qt_win_get_existing_directory(const QFileDialogArgs &args);
 #endif
 
-/*
-    For Symbian file dialogs
-*/
-#if defined(Q_WS_S60)
-extern QString qtSymbianGetOpenFileName(const QString &caption,
-                                        const QString &dir,
-                                        const QString &filter);
-
-extern QStringList qtSymbianGetOpenFileNames(const QString &caption,
-                                             const QString &dir,
-                                             const QString &filter);
-
-extern QString qtSymbianGetSaveFileName(const QString &caption,
-                                        const QString &dir);
-
-extern QString qtSymbianGetExistingDirectory(const QString &caption,
-                                             const QString &dir);
-#endif
-
 /*!
     This is a convenience static function that returns an existing file
     selected by the user. If the user presses Cancel, it returns a null string.
@@ -1770,7 +1751,7 @@ extern QString qtSymbianGetExistingDirectory(const QString &caption,
     The dialog's caption is set to \a caption. If \a caption is not specified
     then a default caption will be used.
 
-    On Windows, Mac OS X and Symbian^3, this static function will use the
+    On Windows, and Mac OS X, this static function will use the
     native file dialog and not a QFileDialog.
 
     On Windows the dialog will spin a blocking modal event loop that will not
@@ -1783,10 +1764,6 @@ extern QString qtSymbianGetExistingDirectory(const QString &caption,
     \a options includes DontResolveSymlinks, the file dialog will treat
     symlinks as regular directories.
 
-    On Symbian^3 the parameter \a selectedFilter has no meaning and the
-    \a options parameter is only used to define if the native file dialog is
-    used.
-
     \warning Do not delete \a parent during the execution of the dialog. If you
     want to do this, you should create the dialog yourself using one of the
     QFileDialog constructors.
@@ -1802,10 +1779,6 @@ QString QFileDialog::getOpenFileName(QWidget *parent,
 {
     if (qt_filedialog_open_filename_hook && !(options & DontUseNativeDialog))
         return qt_filedialog_open_filename_hook(parent, caption, dir, filter, selectedFilter, options);
-#if defined(Q_WS_S60)
-    if (QSysInfo::s60Version() > QSysInfo::SV_S60_5_0 && !(options & DontUseNativeDialog))
-        return qtSymbianGetOpenFileName(caption, dir, filter);
-#endif
     QFileDialogArgs args;
     args.parent = parent;
     args.caption = caption;
@@ -1856,7 +1829,7 @@ QString QFileDialog::getOpenFileName(QWidget *parent,
     The dialog's caption is set to \a caption. If \a caption is not specified
     then a default caption will be used.
 
-    On Windows, Mac OS X and Symbian^3, this static function will use the
+    On Windows, and Mac OS X, this static function will use the
     native file dialog and not a QFileDialog.
 
     On Windows the dialog will spin a blocking modal event loop that will not
@@ -1875,10 +1848,6 @@ QString QFileDialog::getOpenFileName(QWidget *parent,
 
     \snippet doc/src/snippets/code/src_gui_dialogs_qfiledialog.cpp 10
 
-    On Symbian^3 the parameter \a selectedFilter has no meaning and the
-    \a options parameter is only used to define if the native file dialog is
-    used. On Symbian^3, this function can only return a single filename.
-
     \warning Do not delete \a parent during the execution of the dialog. If you
     want to do this, you should create the dialog yourself using one of the
     QFileDialog constructors.
@@ -1894,10 +1863,6 @@ QStringList QFileDialog::getOpenFileNames(QWidget *parent,
 {
     if (qt_filedialog_open_filenames_hook && !(options & DontUseNativeDialog))
         return qt_filedialog_open_filenames_hook(parent, caption, dir, filter, selectedFilter, options);
-#if defined(Q_WS_S60)
-    if (QSysInfo::s60Version() > QSysInfo::SV_S60_5_0 && !(options & DontUseNativeDialog))
-        return qtSymbianGetOpenFileNames(caption, dir, filter);
-#endif
     QFileDialogArgs args;
     args.parent = parent;
     args.caption = caption;
@@ -1955,7 +1920,7 @@ QStringList QFileDialog::getOpenFileNames(QWidget *parent,
     The dialog's caption is set to \a caption. If \a caption is not specified,
     a default caption will be used.
 
-    On Windows, Mac OS X and Symbian^3, this static function will use the
+    On Windows, and Mac OS X, this static function will use the
     native file dialog and not a QFileDialog.
 
     On Windows the dialog will spin a blocking modal event loop that will not
@@ -1969,10 +1934,6 @@ QStringList QFileDialog::getOpenFileNames(QWidget *parent,
     \a options includes DontResolveSymlinks the file dialog will treat symlinks
     as regular directories.
 
-    On Symbian^3 the parameters \a filter and \a selectedFilter have no
-    meaning. The \a options parameter is only used to define if the native file
-    dialog is used.
-
     \warning Do not delete \a parent during the execution of the dialog. If you
     want to do this, you should create the dialog yourself using one of the
     QFileDialog constructors.
@@ -1988,10 +1949,6 @@ QString QFileDialog::getSaveFileName(QWidget *parent,
 {
     if (qt_filedialog_save_filename_hook && !(options & DontUseNativeDialog))
         return qt_filedialog_save_filename_hook(parent, caption, dir, filter, selectedFilter, options);
-#if defined(Q_WS_S60)
-    if (QSysInfo::s60Version() > QSysInfo::SV_S60_5_0 && !(options & DontUseNativeDialog))
-        return qtSymbianGetSaveFileName(caption, dir);
-#endif
     QFileDialogArgs args;
     args.parent = parent;
     args.caption = caption;
@@ -2040,7 +1997,7 @@ QString QFileDialog::getSaveFileName(QWidget *parent,
     pass. To ensure a native file dialog, \l{QFileDialog::}{ShowDirsOnly} must
     be set.
 
-    On Windows, Mac OS X and Symbian^3, this static function will use the
+    On Windows, and Mac OS X, this static function will use the
     native file dialog and not a QFileDialog. On Windows CE, if the device has
     no native file dialog, a QFileDialog will be used.
 
@@ -2054,9 +2011,6 @@ QString QFileDialog::getSaveFileName(QWidget *parent,
     dispatch any QTimers, and if \a parent is not 0 then it will position the
     dialog just below the parent's title bar.
 
-    On Symbian^3 the \a options parameter is only used to define if the native
-    file dialog is used.
-
     \warning Do not delete \a parent during the execution of the dialog. If you
     want to do this, you should create the dialog yourself using one of the
     QFileDialog constructors.
@@ -2070,10 +2024,6 @@ QString QFileDialog::getExistingDirectory(QWidget *parent,
 {
     if (qt_filedialog_existing_directory_hook && !(options & DontUseNativeDialog))
         return qt_filedialog_existing_directory_hook(parent, caption, dir, options);
-#if defined(Q_WS_S60)
-    if (QSysInfo::s60Version() > QSysInfo::SV_S60_5_0 && !(options & DontUseNativeDialog))
-        return qtSymbianGetExistingDirectory(caption, dir);
-#endif
     QFileDialogArgs args;
     args.parent = parent;
     args.caption = caption;
@@ -3437,10 +3387,7 @@ QStringList QFSCompleter::splitPath(const QString &path) const
 
     QString pathCopy = QDir::toNativeSeparators(path);
     QString sep = QDir::separator();
-#if defined(Q_OS_SYMBIAN)
-    if (pathCopy == QLatin1String("\\"))
-        return QStringList(pathCopy);
-#elif defined(Q_OS_WIN)
+#if defined(Q_OS_WIN)
     if (pathCopy == QLatin1String("\\") || pathCopy == QLatin1String("\\\\"))
         return QStringList(pathCopy);
     QString doubleSlash(QLatin1String("\\\\"));
@@ -3463,11 +3410,7 @@ QStringList QFSCompleter::splitPath(const QString &path) const
 
     QRegExp re(QLatin1Char('[') + QRegExp::escape(sep) + QLatin1Char(']'));
 
-#if defined(Q_OS_SYMBIAN)
-    QStringList parts = pathCopy.split(re, QString::SkipEmptyParts);
-    if (pathCopy.endsWith(sep))
-        parts.append(QString());
-#elif defined(Q_OS_WIN)
+#if defined(Q_OS_WIN)
     QStringList parts = pathCopy.split(re, QString::SkipEmptyParts);
     if (!doubleSlash.isEmpty() && !parts.isEmpty())
         parts[0].prepend(doubleSlash);
diff --git a/src/widgets/dialogs/qfiledialog_p.h b/src/widgets/dialogs/qfiledialog_p.h
index f15cea5..12b2b9a 100644
--- a/src/widgets/dialogs/qfiledialog_p.h
+++ b/src/widgets/dialogs/qfiledialog_p.h
@@ -187,7 +187,7 @@ public:
 
     static inline QString toInternal(const QString &path)
     {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
         QString n(path);
         n.replace(QLatin1Char('\\'), QLatin1Char('/'));
 #if defined(Q_OS_WINCE)
diff --git a/src/widgets/dialogs/qfileinfogatherer.cpp b/src/widgets/dialogs/qfileinfogatherer.cpp
index eabd4c5..451376b 100644
--- a/src/widgets/dialogs/qfileinfogatherer.cpp
+++ b/src/widgets/dialogs/qfileinfogatherer.cpp
@@ -264,8 +264,6 @@ QString QFileInfoGatherer::translateDriveName(const QFileInfo &drive) const
 #if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
     if (driveName.startsWith(QLatin1Char('/'))) // UNC host
         return drive.fileName();
-#endif
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
     if (driveName.endsWith(QLatin1Char('/')))
         driveName.chop(1);
 #endif
diff --git a/src/widgets/dialogs/qfilesystemmodel.cpp b/src/widgets/dialogs/qfilesystemmodel.cpp
index 99243ff..ed7754d 100644
--- a/src/widgets/dialogs/qfilesystemmodel.cpp
+++ b/src/widgets/dialogs/qfilesystemmodel.cpp
@@ -367,7 +367,7 @@ QFileSystemModelPrivate::QFileSystemNode *QFileSystemModelPrivate::node(const QS
     // ### TODO can we use bool QAbstractFileEngine::caseSensitive() const?
     QStringList pathElements = absolutePath.split(QLatin1Char('/'), QString::SkipEmptyParts);
     if ((pathElements.isEmpty())
-#if (!defined(Q_OS_WIN) || defined(Q_OS_WINCE)) && !defined(Q_OS_SYMBIAN)
+#if !defined(Q_OS_WIN) || defined(Q_OS_WINCE)
         && QDir::fromNativeSeparators(longPath) != QLatin1String("/")
 #endif
         )
@@ -399,7 +399,7 @@ QFileSystemModelPrivate::QFileSystemNode *QFileSystemModelPrivate::node(const QS
     } else
 #endif
 
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
     {
         if (!pathElements.at(0).contains(QLatin1String(":"))) {
             QString rootPath = QDir(longPath).rootPath();
@@ -1312,7 +1312,7 @@ QString QFileSystemModelPrivate::filePath(const QModelIndex &index) const
     if ((fullPath.length() > 2) && fullPath[0] == QLatin1Char('/') && fullPath[1] == QLatin1Char('/'))
         fullPath = fullPath.mid(1);
 #endif
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     if (fullPath.length() == 2 && fullPath.endsWith(QLatin1Char(':')))
         fullPath.append(QLatin1Char('/'));
 #endif
@@ -1653,25 +1653,13 @@ void QFileSystemModelPrivate::_q_directoryChanged(const QString &directory, cons
     if (parentNode->children.count() == 0)
         return;
     QStringList toRemove;
-#if defined(Q_OS_SYMBIAN)
-    // Filename case must be exact in qBinaryFind below, so create a list of all lowercase names.
-    QStringList newFiles;
-    for(int i = 0; i < files.size(); i++) {
-        newFiles << files.at(i).toLower();
-    }
-#else
     QStringList newFiles = files;
-#endif
     qSort(newFiles.begin(), newFiles.end());
     QHash<QString, QFileSystemNode*>::const_iterator i = parentNode->children.constBegin();
     while (i != parentNode->children.constEnd()) {
         QStringList::iterator iterator;
         iterator = qBinaryFind(newFiles.begin(), newFiles.end(),
-#if defined(Q_OS_SYMBIAN)
-                    i.value()->fileName.toLower());
-#else
                     i.value()->fileName);
-#endif
         if (iterator == newFiles.end()) {
             toRemove.append(i.value()->fileName);
         }
diff --git a/src/widgets/dialogs/qfontdialog.cpp b/src/widgets/dialogs/qfontdialog.cpp
index 42619dc..2402f2a 100644
--- a/src/widgets/dialogs/qfontdialog.cpp
+++ b/src/widgets/dialogs/qfontdialog.cpp
@@ -65,10 +65,6 @@
 #include <private/qdialog_p.h>
 #include <private/qfont_p.h>
 
-#if defined(Q_WS_S60)
-#include <QtWidgets/qdesktopwidget.h>
-#endif
-
 QT_BEGIN_NAMESPACE
 
 class QFontListView : public QListView
@@ -322,8 +318,6 @@ void QFontDialogPrivate::init()
 
 #if defined(Q_WS_WINCE)
     q->resize(180, 120);
-#elif defined(Q_WS_S60)
-    q->resize(QApplication::desktop()->availableGeometry(QCursor::pos()).size());
 #else
     q->resize(500, 360);
 #endif // Q_WS_WINCE
@@ -765,11 +759,7 @@ void QFontDialogPrivate::retranslateStrings()
     familyAccel->setText(QFontDialog::tr("&Font"));
     styleAccel->setText(QFontDialog::tr("Font st&yle"));
     sizeAccel->setText(QFontDialog::tr("&Size"));
-#ifndef Q_WS_S60
-    // Removed the title due to lack of screen estate in small S60 screen.
-    // The effects are descriptive without a title (strikeout, underline).
     effects->setTitle(QFontDialog::tr("Effects"));
-#endif
     strikeout->setText(QFontDialog::tr("Stri&keout"));
     underline->setText(QFontDialog::tr("&Underline"));
     sample->setTitle(QFontDialog::tr("Sample"));
diff --git a/src/widgets/dialogs/qfscompleter_p.h b/src/widgets/dialogs/qfscompleter_p.h
index 99d61e9..eae972a 100644
--- a/src/widgets/dialogs/qfscompleter_p.h
+++ b/src/widgets/dialogs/qfscompleter_p.h
@@ -66,7 +66,7 @@ public:
     QFSCompleter(QFileSystemModel *model, QObject *parent = 0)
         : QCompleter(model, parent), proxyModel(0), sourceModel(model)
     {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
         setCaseSensitivity(Qt::CaseInsensitive);
 #endif
     }
diff --git a/src/widgets/dialogs/qmessagebox.cpp b/src/widgets/dialogs/qmessagebox.cpp
index 924c7d8..8a422c7 100644
--- a/src/widgets/dialogs/qmessagebox.cpp
+++ b/src/widgets/dialogs/qmessagebox.cpp
@@ -349,15 +349,6 @@ void QMessageBoxPrivate::updateSize()
             width = hardLimit;
         }
     }
-#ifdef Q_WS_S60
-        // in S60 portait messageBoxes should always occupy maximum width
-        if (QApplication::desktop()->size().height() > QApplication::desktop()->size().width()){
-            width = hardLimit;
-        } else {
-            // in landscape the messageBoxes should be of same width as in portrait
-            width = qMin(QApplication::desktop()->size().height(), hardLimit);
-        }
-#endif
 
     if (informativeLabel) {
         label->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Ignored);
@@ -388,15 +379,6 @@ void QMessageBoxPrivate::updateSize()
                      ? layout->totalHeightForWidth(width)
                      : layout->totalMinimumSize().height();
 
-#ifndef QT_NO_STYLE_S60
-        QS60Style *s60Style = 0;
-        s60Style = qobject_cast<QS60Style *>(QApplication::style());
-
-        //use custom pixel metric to deduce the minimum height of the messagebox
-        if (s60Style)
-            height = qMax(height, s60Style->pixelMetric((QStyle::PixelMetric)PM_MessageBoxHeight));
-#endif
-
     q->setFixedSize(width, height);
     QCoreApplication::removePostedEvents(q, QEvent::LayoutRequest);
 }
diff --git a/src/widgets/dialogs/qprogressdialog.cpp b/src/widgets/dialogs/qprogressdialog.cpp
index d30e860..f39a7b6 100644
--- a/src/widgets/dialogs/qprogressdialog.cpp
+++ b/src/widgets/dialogs/qprogressdialog.cpp
@@ -60,10 +60,6 @@
 #if defined(QT_SOFTKEYS_ENABLED)
 #include <qaction.h>
 #endif
-#ifdef Q_WS_S60
-#include <QtWidgets/qdesktopwidget.h>
-#endif
-
 
 QT_BEGIN_NAMESPACE
 
@@ -730,14 +726,7 @@ QSize QProgressDialog::sizeHint() const
     int h = margin * 2 + bh.height() + sh.height() + spacing;
     if (d->cancel)
         h += d->cancel->sizeHint().height() + spacing;
-#ifdef Q_WS_S60
-    if (QApplication::desktop()->size().height() > QApplication::desktop()->size().width())
-        return QSize(qMax(QApplication::desktop()->size().width(), sh.width() + 2 * margin), h);
-    else
-        return QSize(qMax(QApplication::desktop()->size().height(), sh.width() + 2 * margin), h);
-#else
     return QSize(qMax(200, sh.width() + 2 * margin), h);
-#endif
 }
 
 /*!\reimp
diff --git a/src/widgets/dialogs/qwizard.cpp b/src/widgets/dialogs/qwizard.cpp
index 4e707ab..629b682 100644
--- a/src/widgets/dialogs/qwizard.cpp
+++ b/src/widgets/dialogs/qwizard.cpp
@@ -2975,11 +2975,7 @@ QSize QWizard::sizeHint() const
 {
     Q_D(const QWizard);
     QSize result = d->mainLayout->totalSizeHint();
-#ifdef Q_WS_S60
-    QSize extra(QApplication::desktop()->availableGeometry(QCursor::pos()).size());
-#else
     QSize extra(500, 360);
-#endif
     if (d->wizStyle == MacStyle && d->current != -1) {
         QSize pixmap(currentPage()->pixmap(BackgroundPixmap).size());
         extra.setWidth(616);
diff --git a/src/widgets/itemviews/qabstractitemview.h b/src/widgets/itemviews/qabstractitemview.h
index 1fc051c..d1b8a5d 100644
--- a/src/widgets/itemviews/qabstractitemview.h
+++ b/src/widgets/itemviews/qabstractitemview.h
@@ -367,7 +367,6 @@ private:
 
     friend class QTreeViewPrivate; // needed to compile with MSVC
     friend class QListModeViewBase;
-    friend class QListViewPrivate; // needed to compile for Symbian emulator
 };
 
 Q_DECLARE_OPERATORS_FOR_FLAGS(QAbstractItemView::EditTriggers)
diff --git a/src/widgets/itemviews/qdirmodel.cpp b/src/widgets/itemviews/qdirmodel.cpp
index f156ed5..67a16a8 100644
--- a/src/widgets/itemviews/qdirmodel.cpp
+++ b/src/widgets/itemviews/qdirmodel.cpp
@@ -854,10 +854,8 @@ QModelIndex QDirModel::index(const QString &path, int column) const
         return QModelIndex();
 
     QString absolutePath = QDir(path).absolutePath();
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
-    absolutePath = absolutePath.toLower();
-#endif
 #if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
+    absolutePath = absolutePath.toLower();
     // On Windows, "filename......." and "filename" are equivalent
     if (absolutePath.endsWith(QLatin1Char('.'))) {
         int i;
@@ -899,7 +897,7 @@ QModelIndex QDirModel::index(const QString &path, int column) const
             emit const_cast<QDirModel*>(this)->layoutChanged();
     } else 
 #endif
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
     if (pathElements.at(0).endsWith(QLatin1Char(':'))) {
         pathElements[0] += QLatin1Char('/');
     }
@@ -923,7 +921,7 @@ QModelIndex QDirModel::index(const QString &path, int column) const
             const QFileInfo& fi = parent->children.at(j).info;
             QString childFileName;
             childFileName = idx.isValid() ? fi.fileName() : fi.absoluteFilePath();
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
             childFileName = childFileName.toLower();
 #endif
             if (childFileName == element) {
@@ -1299,8 +1297,6 @@ QString QDirModelPrivate::name(const QModelIndex &index) const
 #if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
         if (name.startsWith(QLatin1Char('/'))) // UNC host
             return info.fileName();
-#endif        
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
         if (name.endsWith(QLatin1Char('/')))
             name.chop(1);
 #endif
diff --git a/src/widgets/kernel/qaction.cpp b/src/widgets/kernel/qaction.cpp
index 2b8e5dd..d3d63a8 100644
--- a/src/widgets/kernel/qaction.cpp
+++ b/src/widgets/kernel/qaction.cpp
@@ -662,10 +662,6 @@ QActionGroup *QAction::actionGroup() const
     it is displayed to the left of the menu text. There is no default
     icon.
 
-    On Symbian the icons which are passed to softkeys, i.e. to actions with
-    softkey role, need to have pixmap alpha channel correctly set otherwise
-    drawing artifacts will appear when softkey is pressed down.
-
     If a null icon (QIcon::isNull() is passed into this function,
     the icon of the action is cleared.
 */
diff --git a/src/widgets/kernel/qapplication.cpp b/src/widgets/kernel/qapplication.cpp
index 0dc8794..f4d2856 100644
--- a/src/widgets/kernel/qapplication.cpp
+++ b/src/widgets/kernel/qapplication.cpp
@@ -1204,7 +1204,7 @@ bool QApplication::compressEvent(QEvent *event, QObject *receiver, QPostEventLis
     a virtual keyboard on devices which have very few or no keys.
 
     \bold{ The property only has an effect on platforms which use software input
-    panels, such as Windows CE and Symbian.}
+    panels, such as Windows CE.}
 
     The default is platform dependent.
 */
@@ -4657,19 +4657,13 @@ void QApplicationPrivate::emitLastWindowClosed()
 /*!
     Sets the kind of focus navigation Qt should use to \a mode.
 
-    This feature is available in Qt for Embedded Linux, Symbian and Windows CE
+    This feature is available in Qt for Embedded Linux, and Windows CE
     only.
 
     \note On Windows CE this feature is disabled by default for touch device
           mkspecs. To enable keypad navigation, build Qt with
           QT_KEYPAD_NAVIGATION defined.
 
-    \note On Symbian, setting the mode to Qt::NavigationModeCursorAuto will enable a
-          virtual mouse cursor on non touchscreen devices, which is controlled
-          by the cursor keys if there is no analog pointer device.
-          On other platforms and on touchscreen devices, it has the same
-          meaning as Qt::NavigationModeNone.
-
     \since 4.6
 
     \sa keypadNavigationEnabled()
@@ -4682,16 +4676,12 @@ void QApplication::setNavigationMode(Qt::NavigationMode mode)
 /*!
     Returns what kind of focus navigation Qt is using.
 
-    This feature is available in Qt for Embedded Linux, Symbian and Windows CE
-    only.
+    This feature is available in Qt for Embedded Linux, and Windows CE only.
 
     \note On Windows CE this feature is disabled by default for touch device
           mkspecs. To enable keypad navigation, build Qt with
           QT_KEYPAD_NAVIGATION defined.
 
-    \note On Symbian, the default mode is Qt::NavigationModeNone for touch
-          devices, and Qt::NavigationModeKeypadDirectional.
-
     \since 4.6
 
     \sa keypadNavigationEnabled()
@@ -4705,8 +4695,7 @@ Qt::NavigationMode QApplication::navigationMode()
     Sets whether Qt should use focus navigation suitable for use with a
     minimal keypad.
 
-    This feature is available in Qt for Embedded Linux, Symbian and Windows CE
-    only.
+    This feature is available in Qt for Embedded Linux, and Windows CE only.
 
     \note On Windows CE this feature is disabled by default for touch device
           mkspecs. To enable keypad navigation, build Qt with
@@ -4727,10 +4716,9 @@ void QApplication::setKeypadNavigationEnabled(bool enable)
 
 /*!
     Returns true if Qt is set to use keypad navigation; otherwise returns
-    false.  The default value is true on Symbian, but false on other platforms.
+    false.  The default value is false.
 
-    This feature is available in Qt for Embedded Linux, Symbian and Windows CE
-    only.
+    This feature is available in Qt for Embedded Linux, and Windows CE only.
 
     \note On Windows CE this feature is disabled by default for touch device
           mkspecs. To enable keypad navigation, build Qt with
diff --git a/src/widgets/kernel/qformlayout.cpp b/src/widgets/kernel/qformlayout.cpp
index e19128a..dd61528 100644
--- a/src/widgets/kernel/qformlayout.cpp
+++ b/src/widgets/kernel/qformlayout.cpp
@@ -1124,15 +1124,14 @@ QStyle* QFormLayoutPrivate::getStyle() const
 
     \value DontWrapRows
            Fields are always laid out next to their label.  This is
-           the default policy for all styles except Qt Extended styles
-           and QS60Style.
+           the default policy for all styles except Qt Extended styles.
 
     \value WrapLongRows
            Labels are given enough horizontal space to fit the widest label,
            and the rest of the space is given to the fields. If the minimum
            size of a field pair is wider than the available space, the field
            is wrapped to the next line.  This is the default policy for
-           Qt Extended styles and and QS60Style.
+           Qt Extended styles.
 
     \value WrapAllRows
            Fields are always laid out below their label.
@@ -1721,7 +1720,7 @@ QFormLayout::FieldGrowthPolicy QFormLayout::fieldGrowthPolicy() const
     \brief the way in which the form's rows wrap
 
     The default value depends on the widget or application style. For
-    Qt Extended styles and QS60Style, the default is WrapLongRows;
+    Qt Extended styles, the default is WrapLongRows;
     for the other styles, the default is DontWrapRows.
 
     If you want to display each label above its associated field
diff --git a/src/widgets/kernel/qsoftkeymanager.cpp b/src/widgets/kernel/qsoftkeymanager.cpp
index 351171a..c0e7260 100644
--- a/src/widgets/kernel/qsoftkeymanager.cpp
+++ b/src/widgets/kernel/qsoftkeymanager.cpp
@@ -46,14 +46,6 @@
 #include "private/qaction_p.h"
 #include "private/qsoftkeymanager_common_p.h"
 
-#ifdef Q_WS_S60
-#include "private/qsoftkeymanager_s60_p.h"
-#endif
-
-#ifdef SYMBIAN_VERSION_SYMBIAN3
-#include "private/qt_s60_p.h"
-#endif
-
 #ifndef QT_NO_SOFTKEYMANAGER
 QT_BEGIN_NAMESPACE
 
@@ -94,41 +86,13 @@ QSoftKeyManager *QSoftKeyManager::instance()
 }
 
 QSoftKeyManager::QSoftKeyManager() :
-#ifdef Q_WS_S60
-    QObject(*(new QSoftKeyManagerPrivateS60), 0)
-#else
     QObject(*(new QSoftKeyManagerPrivate), 0)
-#endif
 {
 }
 
 QAction *QSoftKeyManager::createAction(StandardSoftKey standardKey, QWidget *actionWidget)
 {
     QAction *action = new QAction(standardSoftKeyText(standardKey), actionWidget);
-#ifdef SYMBIAN_VERSION_SYMBIAN3
-    int key = 0;
-    switch (standardKey) {
-    case OkSoftKey:
-        key = EAknSoftkeyOk;
-        break;
-    case SelectSoftKey:
-        key = EAknSoftkeySelect;
-        break;
-    case DoneSoftKey:
-        key = EAknSoftkeyDone;
-        break;
-    case MenuSoftKey:
-        key = EAknSoftkeyOptions;
-        break;
-    case CancelSoftKey:
-        key = EAknSoftkeyCancel;
-        break;
-    default:
-        break;
-    };
-    if (key != 0)
-        QSoftKeyManager::instance()->d_func()->softKeyCommandActions.insert(action, key);
-#endif
     QAction::SoftKeyRole softKeyRole = QAction::NoSoftKey;
     switch (standardKey) {
     case MenuSoftKey: // FALL-THROUGH
@@ -171,9 +135,6 @@ void QSoftKeyManager::cleanupHash(QObject *obj)
     Q_D(QSoftKeyManager);
     QAction *action = qobject_cast<QAction*>(obj);
     d->keyedActions.remove(action);
-#ifdef SYMBIAN_VERSION_SYMBIAN3
-    d->softKeyCommandActions.remove(action);
-#endif
 }
 
 void QSoftKeyManager::sendKeyEvent()
@@ -305,15 +266,5 @@ bool QSoftKeyManager::event(QEvent *e)
     return false;
 }
 
-#ifdef Q_WS_S60
-bool QSoftKeyManager::handleCommand(int command)
-{
-    if (QSoftKeyManager::instance()->d_func()->pendingUpdate)
-        (void)QSoftKeyManager::instance()->handleUpdateSoftKeys();
-
-    return static_cast<QSoftKeyManagerPrivateS60*>(QSoftKeyManager::instance()->d_func())->handleCommand(command);
-}
-#endif
-
 QT_END_NAMESPACE
 #endif //QT_NO_SOFTKEYMANAGER
diff --git a/src/widgets/kernel/qsoftkeymanager_common_p.h b/src/widgets/kernel/qsoftkeymanager_common_p.h
index ae9c7c9..2a170d3 100644
--- a/src/widgets/kernel/qsoftkeymanager_common_p.h
+++ b/src/widgets/kernel/qsoftkeymanager_common_p.h
@@ -74,9 +74,6 @@ protected:
     QMultiHash<int, QAction*> requestedSoftKeyActions;
     QWidget *initialSoftKeySource;
     bool pendingUpdate;
-#ifdef SYMBIAN_VERSION_SYMBIAN3
-    QHash<QAction*, int> softKeyCommandActions;
-#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/widgets/kernel/qsoftkeymanager_p.h b/src/widgets/kernel/qsoftkeymanager_p.h
index 79a656e..2b0cea5 100644
--- a/src/widgets/kernel/qsoftkeymanager_p.h
+++ b/src/widgets/kernel/qsoftkeymanager_p.h
@@ -79,9 +79,6 @@ public:
     };
 
     static void updateSoftKeys();
-#ifdef Q_WS_S60
-    static bool handleCommand(int);
-#endif
 
     static QAction *createAction(StandardSoftKey standardKey, QWidget *actionWidget);
     static QAction *createKeyedAction(StandardSoftKey standardKey, Qt::Key key, QWidget *actionWidget);
diff --git a/src/widgets/kernel/qwidget.cpp b/src/widgets/kernel/qwidget.cpp
index 4402b49..a8f3808 100644
--- a/src/widgets/kernel/qwidget.cpp
+++ b/src/widgets/kernel/qwidget.cpp
@@ -107,9 +107,6 @@
 #include "qtabwidget.h" // Needed in inTabWidget()
 #endif // QT_KEYPAD_NAVIGATION
 
-#ifdef Q_WS_S60
-#include <aknappui.h>
-#endif
 
 // widget/widget data creation count
 //#define QWIDGET_EXTRA_DEBUG
@@ -407,8 +404,7 @@ bool QWidget::hasEditFocus() const
     normally; otherwise, Qt::Key_Up and Qt::Key_Down are used to
     change focus.
 
-    This feature is only available in Qt for Embedded Linux and Qt
-    for Symbian.
+    This feature is only available in Qt for Embedded Linux.
 
     \sa hasEditFocus(), QApplication::keypadNavigationEnabled()
 */
@@ -2052,14 +2048,6 @@ void QWidgetPrivate::updateIsOpaque()
     }
 #endif
 
-#ifdef Q_WS_S60
-    if (q->windowType() == Qt::Dialog && q->testAttribute(Qt::WA_TranslucentBackground)
-                && S60->avkonComponentsSupportTransparency) {
-        setOpaque(false);
-        return;
-    }
-#endif
-
     if (q->testAttribute(Qt::WA_OpaquePaintEvent) || q->testAttribute(Qt::WA_PaintOnScreen)) {
         setOpaque(true);
         return;
@@ -2126,11 +2114,6 @@ static inline void fillRegion(QPainter *painter, const QRegion &rgn, const QBrus
         extern void qt_mac_fill_background(QPainter *painter, const QRegion &rgn, const QBrush &brush);
         qt_mac_fill_background(painter, rgn, brush);
 #else
-#if !defined(QT_NO_STYLE_S60)
-        // Defined in qs60style.cpp
-        extern bool qt_s60_fill_background(QPainter *painter, const QRegion &rgn, const QBrush &brush);
-        if (!qt_s60_fill_background(painter, rgn, brush))
-#endif // !defined(QT_NO_STYLE_S60)
         {
             const QRect rect(rgn.boundingRect());
             painter->setClipRegion(rgn);
diff --git a/src/widgets/styles/qstylefactory.cpp b/src/widgets/styles/qstylefactory.cpp
index bd8b73b..ef555fb 100644
--- a/src/widgets/styles/qstylefactory.cpp
+++ b/src/widgets/styles/qstylefactory.cpp
@@ -69,9 +69,6 @@
 #ifndef QT_NO_STYLE_WINDOWSMOBILE
 #include "qwindowsmobilestyle.h"
 #endif
-#ifndef QT_NO_STYLE_S60
-#include "qs60style.h"
-#endif
 
 QT_BEGIN_NAMESPACE
 
@@ -158,11 +155,6 @@ QStyle *QStyleFactory::create(const QString& key)
         ret = new QCDEStyle;
     else
 #endif
-#ifndef QT_NO_STYLE_S60
-    if (style == QLatin1String("s60"))
-        ret = new QS60Style;
-    else
-#endif
 #ifndef QT_NO_STYLE_PLASTIQUE
     if (style == QLatin1String("plastique"))
         ret = new QPlastiqueStyle;
@@ -242,10 +234,6 @@ QStringList QStyleFactory::keys()
     if (!list.contains(QLatin1String("CDE")))
         list << QLatin1String("CDE");
 #endif
-#ifndef QT_NO_STYLE_S60
-    if (!list.contains(QLatin1String("S60")))
-        list << QLatin1String("S60");
-#endif
 #ifndef QT_NO_STYLE_PLASTIQUE
     if (!list.contains(QLatin1String("Plastique")))
         list << QLatin1String("Plastique");
diff --git a/src/widgets/styles/qstylesheetstyle_default.cpp b/src/widgets/styles/qstylesheetstyle_default.cpp
index f71ab3e..f22a6d1 100644
--- a/src/widgets/styles/qstylesheetstyle_default.cpp
+++ b/src/widgets/styles/qstylesheetstyle_default.cpp
@@ -158,8 +158,7 @@ StyleSheet QStyleSheetStyle::getDefaultStyleSheet() const
     // pixmap based style doesn't support any features
     bool styleIsPixmapBased = baseStyle()->inherits("QMacStyle")
                            || baseStyle()->inherits("QWindowsXPStyle")
-                           || baseStyle()->inherits("QGtkStyle")
-                           || baseStyle()->inherits("QS60Style");
+                           || baseStyle()->inherits("QGtkStyle");
 
 
     /*QLineEdit {
diff --git a/src/widgets/util/qcompleter.cpp b/src/widgets/util/qcompleter.cpp
index d8a4ceb..503e5aa 100644
--- a/src/widgets/util/qcompleter.cpp
+++ b/src/widgets/util/qcompleter.cpp
@@ -494,7 +494,7 @@ QMatchData QCompletionEngine::filterHistory()
     for (int i = 0; i < source->rowCount(); i++) {
         QString str = source->index(i, c->column).data().toString();
         if (str.startsWith(c->prefix, c->cs)
-#if (!defined(Q_OS_WIN) || defined(Q_OS_WINCE)) && !defined(Q_OS_SYMBIAN)
+#if !defined(Q_OS_WIN) || defined(Q_OS_WINCE)
             && ((!isFsModel && !isDirModel) || QDir::toNativeSeparators(str) != QDir::separator())
 #endif
             )
@@ -1036,7 +1036,7 @@ void QCompleter::setModel(QAbstractItemModel *model)
         delete oldModel;
 #ifndef QT_NO_DIRMODEL
     if (qobject_cast<QDirModel *>(model)) {
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
         setCaseSensitivity(Qt::CaseInsensitive);
 #else
         setCaseSensitivity(Qt::CaseSensitive);
@@ -1046,7 +1046,7 @@ void QCompleter::setModel(QAbstractItemModel *model)
 #ifndef QT_NO_FILESYSTEMMODEL
     QFileSystemModel *fsModel = qobject_cast<QFileSystemModel *>(model);
     if (fsModel) {
-#if (defined(Q_OS_WIN) && !defined(Q_OS_WINCE)) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
         setCaseSensitivity(Qt::CaseInsensitive);
 #else
         setCaseSensitivity(Qt::CaseSensitive);
@@ -1725,7 +1725,7 @@ QString QCompleter::pathFromIndex(const QModelIndex& index) const
         idx = parent.sibling(parent.row(), index.column());
     } while (idx.isValid());
 
-#if (!defined(Q_OS_WIN) || defined(Q_OS_WINCE)) && !defined(Q_OS_SYMBIAN)
+#if !defined(Q_OS_WIN) || defined(Q_OS_WINCE)
     if (list.count() == 1) // only the separator or some other text
         return list[0];
     list[0].clear() ; // the join below will provide the separator
@@ -1766,10 +1766,7 @@ QStringList QCompleter::splitPath(const QString& path) const
 
     QString pathCopy = QDir::toNativeSeparators(path);
     QString sep = QDir::separator();
-#if defined(Q_OS_SYMBIAN)
-    if (pathCopy == QLatin1String("\\"))
-        return QStringList(pathCopy);
-#elif defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
+#if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
     if (pathCopy == QLatin1String("\\") || pathCopy == QLatin1String("\\\\"))
         return QStringList(pathCopy);
     QString doubleSlash(QLatin1String("\\\\"));
@@ -1782,9 +1779,7 @@ QStringList QCompleter::splitPath(const QString& path) const
     QRegExp re(QLatin1Char('[') + QRegExp::escape(sep) + QLatin1Char(']'));
     QStringList parts = pathCopy.split(re);
 
-#if defined(Q_OS_SYMBIAN)
-    // Do nothing
-#elif defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
+#if defined(Q_OS_WIN) && !defined(Q_OS_WINCE)
     if (!doubleSlash.isEmpty())
         parts[0].prepend(doubleSlash);
 #else
diff --git a/src/widgets/util/qscroller.cpp b/src/widgets/util/qscroller.cpp
index 1e3ba14..4482134 100644
--- a/src/widgets/util/qscroller.cpp
+++ b/src/widgets/util/qscroller.cpp
@@ -568,7 +568,7 @@ void QScroller::stop()
 
     \note Please note that this value should be physically correct. The actual DPI settings
     that Qt returns for the display may be reported wrongly on purpose by the underlying
-    windowing system, for example on Mac OS X or Maemo 5.
+    windowing system, for example on Mac OS X.
 */
 QPointF QScroller::pixelPerMeter() const
 {
@@ -1018,16 +1018,7 @@ bool QScroller::handleInput(Input input, const QPointF &position, qint64 timesta
 
 QPointF QScrollerPrivate::realDpi(int screen)
 {
-#  ifdef Q_WS_MAEMO_5
-    Q_UNUSED(screen);
-
-    // The DPI value is hardcoded to 96 on Maemo5:
-    // https://projects.maemo.org/bugzilla/show_bug.cgi?id=152525
-    // This value (260) is only correct for the N900 though, but
-    // there's no way to get the real DPI at run time.
-    return QPointF(260, 260);
-
-#  elif defined(Q_WS_X11) && !defined(QT_NO_XRANDR)
+#  if defined(Q_WS_X11) && !defined(QT_NO_XRANDR)
     if (X11 && X11->use_xrandr && X11->ptrXRRSizes && X11->ptrXRRRootToScreen) {
         int nsizes = 0;
         // QDesktopWidget is based on Xinerama screens, which do not always
diff --git a/src/widgets/widgets/qabstractscrollarea.cpp b/src/widgets/widgets/qabstractscrollarea.cpp
index f9eda3f..ba9aa15 100644
--- a/src/widgets/widgets/qabstractscrollarea.cpp
+++ b/src/widgets/widgets/qabstractscrollarea.cpp
@@ -306,11 +306,6 @@ void QAbstractScrollAreaPrivate::init()
     viewport->grabGesture(Qt::PanGesture);
 #  endif
 #endif
-#ifdef Q_WS_MAEMO_5
-#  ifndef QT_NO_GESTURES
-    // viewport->grabGesture(Qt::TouchFlickGesture);
-#  endif
-#endif
 }
 
 #ifdef Q_WS_WIN
@@ -564,11 +559,6 @@ void QAbstractScrollArea::setViewport(QWidget *widget)
         d->viewport->grabGesture(Qt::PanGesture);
 #endif
 #endif
-#ifdef Q_WS_MAEMO_5
-#ifndef QT_NO_GESTURES
-//        d->viewport->grabGesture(Qt::TouchFlickGesture);
-#endif
-#endif
         d->layoutChildren();
         if (isVisible())
             d->viewport->show();
diff --git a/src/widgets/widgets/qcombobox.cpp b/src/widgets/widgets/qcombobox.cpp
index 32780a0..56a5995 100644
--- a/src/widgets/widgets/qcombobox.cpp
+++ b/src/widgets/widgets/qcombobox.cpp
@@ -74,9 +74,6 @@
 #ifndef QT_NO_EFFECTS
 # include <private/qeffects_p.h>
 #endif
-#if defined(Q_WS_S60)
-#include "private/qt_s60_p.h"
-#endif
 #ifndef QT_NO_ACCESSIBILITY
 #include "qaccessible.h"
 #endif
@@ -549,11 +546,9 @@ void QComboBoxPrivateContainer::setItemView(QAbstractItemView *itemView)
     QStyleOptionComboBox opt = comboStyleOption();
     const bool usePopup = combo->style()->styleHint(QStyle::SH_ComboBox_Popup, &opt, combo);
 #ifndef QT_NO_SCROLLBAR
-#ifndef Q_WS_S60
     if (usePopup)
         view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
 #endif
-#endif
     if (combo->style()->styleHint(QStyle::SH_ComboBox_ListMouseTracking, &opt, combo) ||
         usePopup) {
         view->setMouseTracking(true);
@@ -2339,11 +2334,7 @@ void QComboBox::showPopup()
     initStyleOption(&opt);
     QRect listRect(style->subControlRect(QStyle::CC_ComboBox, &opt,
                                          QStyle::SC_ComboBoxListBoxPopup, this));
-#ifndef Q_WS_S60
     QRect screen = d->popupGeometry(QApplication::desktop()->screenNumber(this));
-#else
-    QRect screen = qt_TRect2QRect(static_cast<CEikAppUi*>(S60->appUi())->ClientRect());
-#endif
 
     QPoint below = mapToGlobal(listRect.bottomLeft());
     int belowHeight = screen.bottom() - below.y();
@@ -2436,14 +2427,11 @@ void QComboBox::showPopup()
         // Position horizontally.
         listRect.moveLeft(above.x());
 
-#ifndef Q_WS_S60
         // Position vertically so the curently selected item lines up
         // with the combo box.
         const QRect currentItemRect = view()->visualRect(view()->currentIndex());
         const int offset = listRect.top() - currentItemRect.top();
         listRect.moveTop(above.y() + offset - listRect.top());
-#endif
-
 
         // Clamp the listRect height and vertical position so we don't expand outside the
         // available screen geometry.This may override the vertical position, but it is more
@@ -2457,23 +2445,6 @@ void QComboBox::showPopup()
             if (listRect.bottom() > screen.bottom())
                 listRect.moveBottom(screen.bottom());
         }
-#ifdef Q_WS_S60
-        if (screen.width() < screen.height()) {
-            // in portait, menu should be positioned above softkeys
-            listRect.moveBottom(screen.bottom());
-        } else {
-            TRect staConTopRect = TRect();
-            AknLayoutUtils::LayoutMetricsRect(AknLayoutUtils::EStaconTop, staConTopRect);
-            listRect.setWidth(listRect.height());
-            //by default popup is centered on screen in landscape
-            listRect.moveCenter(screen.center());
-            if (staConTopRect.IsEmpty() && AknLayoutUtils::CbaLocation() != AknLayoutUtils::EAknCbaLocationBottom) {
-                // landscape without stacon, menu should be at the right
-                (opt.direction == Qt::LeftToRight) ? listRect.setRight(screen.right()) :
-                                                     listRect.setLeft(screen.left());
-            }
-        }
-#endif
     } else if (!boundToScreen || listRect.height() <= belowHeight) {
         listRect.moveTopLeft(below);
     } else if (listRect.height() <= aboveHeight) {
@@ -2692,39 +2663,6 @@ void QComboBox::changeEvent(QEvent *e)
             d->updateLineEditGeometry();
         d->setLayoutItemMargins(QStyle::SE_ComboBoxLayoutItem);
 
-#ifdef Q_WS_S60
-        if (d->container) {
-            QStyleOptionComboBox opt;
-            initStyleOption(&opt);
-
-            if (style()->styleHint(QStyle::SH_ComboBox_Popup, &opt, this)) {
-                QRect screen = qt_TRect2QRect(static_cast<CEikAppUi*>(S60->appUi())->ClientRect());
-
-                QRect listRect(style()->subControlRect(QStyle::CC_ComboBox, &opt,
-                    QStyle::SC_ComboBoxListBoxPopup, this));
-                listRect.setHeight(qMin(screen.height(), screen.width()));
-
-                if (screen.width() < screen.height()) {
-                    // in portait, menu should be positioned above softkeys
-                    listRect.moveBottom(screen.bottom());
-                } else {
-                    TRect staConTopRect = TRect();
-                    AknLayoutUtils::LayoutMetricsRect(AknLayoutUtils::EStaconTop, staConTopRect);
-                    listRect.setWidth(listRect.height());
-                    //by default popup is centered on screen in landscape
-                    listRect.moveCenter(screen.center());
-                    if (staConTopRect.IsEmpty() && AknLayoutUtils::CbaLocation() != AknLayoutUtils::EAknCbaLocationBottom) {
-                        // landscape without stacon, menu should be at the right
-                        (opt.direction == Qt::LeftToRight) ? listRect.setRight(screen.right()) :
-                                                             listRect.setLeft(screen.left());
-                    }
-                }
-                
-                d->container->setGeometry(listRect);
-            }
-        }
-#endif
-
         // ### need to update scrollers etc. as well here
         break;
     case QEvent::EnabledChange:
@@ -2753,10 +2691,6 @@ void QComboBox::changeEvent(QEvent *e)
 void QComboBox::resizeEvent(QResizeEvent *)
 {
     Q_D(QComboBox);
-#ifdef Q_WS_S60
-    if (d->viewContainer() && d->viewContainer()->isVisible())
-        showPopup();
-#endif
     d->updateLineEditGeometry();
 }
 
diff --git a/src/widgets/widgets/qcombobox_p.h b/src/widgets/widgets/qcombobox_p.h
index b430a1b..68b52ae 100644
--- a/src/widgets/widgets/qcombobox_p.h
+++ b/src/widgets/widgets/qcombobox_p.h
@@ -200,9 +200,7 @@ protected:
         menuOpt.menuItemType = QStyleOptionMenuItem::Scroller;
         if (sliderAction == QAbstractSlider::SliderSingleStepAdd)
             menuOpt.state |= QStyle::State_DownArrow;
-#ifndef Q_WS_S60
         p.eraseRect(rect());
-#endif
         style()->drawControl(QStyle::CE_MenuScroller, &menuOpt, &p);
     }
 
@@ -272,9 +270,7 @@ protected:
                const QStyleOptionViewItem &option,
                const QModelIndex &index) const {
         QStyleOptionMenuItem opt = getStyleOption(option, index);
-#ifndef Q_WS_S60
         painter->fillRect(option.rect, opt.palette.background());
-#endif
         mCombo->style()->drawControl(QStyle::CE_MenuItem, &opt, painter, mCombo);
     }
     QSize sizeHint(const QStyleOptionViewItem &option,
diff --git a/src/widgets/widgets/qmenu.cpp b/src/widgets/widgets/qmenu.cpp
index d1296af..37d9e34 100644
--- a/src/widgets/widgets/qmenu.cpp
+++ b/src/widgets/widgets/qmenu.cpp
@@ -2893,16 +2893,6 @@ void QMenu::actionEvent(QActionEvent *e)
         d->wce_menu->syncAction(e->action());
 #endif
 
-#ifdef Q_WS_S60
-    if (!d->symbian_menu)
-        d->symbian_menu = new QMenuPrivate::QSymbianMenuPrivate;
-    if (e->type() == QEvent::ActionAdded)
-        d->symbian_menu->addAction(e->action(), d->symbian_menu->findAction(e->before()));
-    else if (e->type() == QEvent::ActionRemoved)
-        d->symbian_menu->removeAction(e->action());
-    else if (e->type() == QEvent::ActionChanged)
-        d->symbian_menu->syncAction(e->action());
-#endif
     if (isVisible()) {
         d->updateActionRects();
         resize(sizeHint());
diff --git a/src/widgets/widgets/qmenu_p.h b/src/widgets/widgets/qmenu_p.h
index c8db4e3..af236c1 100644
--- a/src/widgets/widgets/qmenu_p.h
+++ b/src/widgets/widgets/qmenu_p.h
@@ -61,22 +61,10 @@
 #include "QtCore/qbasictimer.h"
 #include "private/qwidget_p.h"
 
-
-#ifdef Q_WS_S60
-class CEikMenuPane;
-#define QT_SYMBIAN_FIRST_MENU_ITEM 32000
-#define QT_SYMBIAN_LAST_MENU_ITEM 41999 // 10000 items ought to be enough for anybody...
-#endif
 QT_BEGIN_NAMESPACE
 
 #ifndef QT_NO_MENU
 
-#ifdef Q_WS_S60
-void qt_symbian_next_menu_from_action(QWidget* actionContainer);
-void qt_symbian_show_toplevel(CEikMenuPane* menuPane);
-void qt_symbian_show_submenu(CEikMenuPane* menuPane, int id);
-#endif // Q_WS_S60
-
 class QTornOffMenu;
 class QEventLoop;
 
@@ -88,15 +76,6 @@ struct QWceMenuAction {
     QWceMenuAction() : menuHandle(0), command(0) {}
 };
 #endif
-#ifdef Q_WS_S60
-struct QSymbianMenuAction {
-    uint command;
-    int parent;
-    CEikMenuPane* menuPane;
-    QPointer<QAction> action;
-    QSymbianMenuAction() : command(0) {}
-};
-#endif
 
 class QMenuPrivate : public QWidgetPrivate
 {
@@ -115,9 +94,6 @@ public:
 #if defined(Q_WS_WINCE) && !defined(QT_NO_MENUBAR)
                       ,wce_menu(0)
 #endif
-#ifdef Q_WS_S60
-                      ,symbian_menu(0)
-#endif
     { }
     ~QMenuPrivate()
     {
@@ -126,10 +102,6 @@ public:
 #if defined(Q_WS_WINCE) && !defined(QT_NO_MENUBAR)
         delete wce_menu;
 #endif
-#ifdef Q_WS_S60
-        delete symbian_menu;
-#endif
-
     }
     void init();
 
@@ -281,28 +253,6 @@ public:
     HMENU wceMenu();
     QAction* wceCommands(uint command);
 #endif
-#if defined(Q_WS_S60)
-    struct QSymbianMenuPrivate {
-        QList<QSymbianMenuAction*> actionItems;
-        QSymbianMenuPrivate();
-        ~QSymbianMenuPrivate();
-        void addAction(QAction *, QSymbianMenuAction* =0);
-        void addAction(QSymbianMenuAction *, QSymbianMenuAction* =0);
-        void syncAction(QSymbianMenuAction *);
-        inline void syncAction(QAction *a) { syncAction(findAction(a)); }
-        void removeAction(QSymbianMenuAction *);
-        void rebuild(bool reCreate = false);
-        inline void removeAction(QAction *a) { removeAction(findAction(a)); }
-        inline QSymbianMenuAction *findAction(QAction *a) {
-            for(int i = 0; i < actionItems.size(); i++) {
-                QSymbianMenuAction *act = actionItems[i];
-                if(a == act->action)
-                    return act;
-            }
-            return 0;
-        }
-    } *symbian_menu;
-#endif
     QPointer<QWidget> noReplayFor;
 };
 
diff --git a/src/widgets/widgets/qmenubar.cpp b/src/widgets/widgets/qmenubar.cpp
index a0c9ae0..f353d43 100644
--- a/src/widgets/widgets/qmenubar.cpp
+++ b/src/widgets/widgets/qmenubar.cpp
@@ -788,10 +788,6 @@ QMenuBar::~QMenuBar()
     if (qt_wince_is_mobile())
         d->wceDestroyMenuBar();
 #endif
-#ifdef Q_WS_S60
-    Q_D(QMenuBar);
-    d->symbianDestroyMenuBar();
-#endif
 }
 
 /*!
@@ -1043,7 +1039,7 @@ void QMenuBar::paintEvent(QPaintEvent *e)
 */
 void QMenuBar::setVisible(bool visible)
 {
-#if defined(Q_OS_MAC) || defined(Q_OS_WINCE) || defined(Q_WS_S60)
+#if defined(Q_OS_MAC) || defined(Q_OS_WINCE)
     if (isNativeMenuBar()) {
         if (!visible)
             QWidget::setVisible(false);
@@ -1249,9 +1245,7 @@ void QMenuBar::actionEvent(QActionEvent *e)
 
     if (d->platformMenuBar) {
         QPlatformMenuBar *nativeMenuBar = d->platformMenuBar;
-#if defined(Q_WS_S60)
-        QMenuBarPrivate::QSymbianMenuBarPrivate *nativeMenuBar = d->symbian_menubar;
-#elif defined(Q_WS_WINCE)
+#if defined(Q_WS_WINCE)
         QMenuBarPrivate::QWceMenuBarPrivate *nativeMenuBar = d->wce_menubar;
 #endif
         if (!nativeMenuBar)
@@ -1348,38 +1342,6 @@ void QMenuBarPrivate::handleReparent()
     if (qt_wince_is_mobile() && wce_menubar)
         wce_menubar->rebuild();
 #endif
-#ifdef Q_WS_S60
-
-    // Construct symbian_menubar when this code path is entered first time
-    // and when newParent != NULL
-    if (!symbian_menubar)
-        symbianCreateMenuBar(newParent);
-
-    // Reparent and rebuild menubar when parent is changed
-    if (symbian_menubar) {
-        if (oldParent != newParent)
-            reparentMenuBar(oldParent, newParent);
-        q->hide();
-        symbian_menubar->rebuild();
-    }
-
-#ifdef QT_SOFTKEYS_ENABLED
-    // Constuct menuBarAction when this code path is entered first time
-    if (!menuBarAction) {
-        if (newParent) {
-            menuBarAction = QSoftKeyManager::createAction(QSoftKeyManager::MenuSoftKey, newParent);
-            newParent->addAction(menuBarAction);
-        }
-    } else {
-        // If reparenting i.e. we already have menuBarAction, remove it from old parent
-        // and add for a new parent
-        if (oldParent)
-            oldParent->removeAction(menuBarAction);
-        if (newParent)
-            newParent->addAction(menuBarAction);
-    }
-#endif // QT_SOFTKEYS_ENABLED
-#endif // Q_WS_S60
 }
 
 /*!
@@ -1564,7 +1526,7 @@ QRect QMenuBar::actionGeometry(QAction *act) const
 QSize QMenuBar::minimumSizeHint() const
 {
     Q_D(const QMenuBar);
-#if defined(Q_OS_MAC) || defined(Q_WS_WINCE) || defined(Q_WS_S60)
+#if defined(Q_OS_MAC) || defined(Q_WS_WINCE)
     const bool as_gui_menubar = !isNativeMenuBar();
 #else
     const bool as_gui_menubar = true;
@@ -1620,7 +1582,7 @@ QSize QMenuBar::minimumSizeHint() const
 QSize QMenuBar::sizeHint() const
 {
     Q_D(const QMenuBar);
-#if defined(Q_OS_MAC) || defined(Q_WS_WINCE) || defined(Q_WS_S60)
+#if defined(Q_OS_MAC) || defined(Q_WS_WINCE)
     const bool as_gui_menubar = !isNativeMenuBar();
 #else
     const bool as_gui_menubar = true;
@@ -1679,7 +1641,7 @@ QSize QMenuBar::sizeHint() const
 int QMenuBar::heightForWidth(int) const
 {
     Q_D(const QMenuBar);
-#if defined(Q_OS_MAC) || defined(Q_WS_WINCE) || defined(Q_WS_S60)
+#if defined(Q_OS_MAC) || defined(Q_WS_WINCE)
     const bool as_gui_menubar = !isNativeMenuBar();
 #else
     const bool as_gui_menubar = true;
diff --git a/src/widgets/widgets/qmenubar_p.h b/src/widgets/widgets/qmenubar_p.h
index a73ec1d..a15a1e4 100644
--- a/src/widgets/widgets/qmenubar_p.h
+++ b/src/widgets/widgets/qmenubar_p.h
@@ -61,13 +61,6 @@
 #include "qguifunctions_wince.h"
 #endif
 
-#ifndef QT_NO_MENUBAR
-#ifdef Q_WS_S60
-class CCoeControl;
-class CEikMenuBar;
-#endif
-#endif
-
 QT_BEGIN_NAMESPACE
 
 #ifndef QT_NO_MENUBAR
@@ -83,10 +76,6 @@ public:
 #ifdef Q_WS_WINCE
                          , wce_menubar(0), wceClassicMenu(false)
 #endif
-#ifdef Q_WS_S60
-                         , symbian_menubar(0)
-#endif
-
         { }
     ~QMenuBarPrivate()
         {
@@ -94,9 +83,6 @@ public:
 #ifdef Q_WS_WINCE
             delete wce_menubar;
 #endif
-#ifdef Q_WS_S60
-            delete symbian_menubar;
-#endif
         }
 
     void init();
@@ -203,35 +189,6 @@ public:
     void wceRefresh();
     bool wceEmitSignals(QList<QWceMenuAction*> actions, uint command);
 #endif
-#ifdef Q_WS_S60
-    void symbianCreateMenuBar(QWidget *);
-    void symbianDestroyMenuBar();
-    void reparentMenuBar(QWidget *oldParent, QWidget *newParent);
-    struct QSymbianMenuBarPrivate {
-        QList<QSymbianMenuAction*> actionItems;
-        QMenuBarPrivate *d;
-        QSymbianMenuBarPrivate(QMenuBarPrivate *menubar);
-        ~QSymbianMenuBarPrivate();
-        void addAction(QAction *, QSymbianMenuAction* =0);
-        void addAction(QSymbianMenuAction *, QSymbianMenuAction* =0);
-        void syncAction(QSymbianMenuAction *);
-        inline void syncAction(QAction *a) { syncAction(findAction(a)); }
-        void removeAction(QSymbianMenuAction *);
-        void rebuild();
-        inline void removeAction(QAction *a) { removeAction(findAction(a)); }
-        inline QSymbianMenuAction *findAction(QAction *a) {
-            for(int i = 0; i < actionItems.size(); i++) {
-                QSymbianMenuAction *act = actionItems[i];
-                if(a == act->action)
-                    return act;
-            }
-            return 0;
-        }
-        void insertNativeMenuItems(const QList<QAction*> &actions);
-
-    } *symbian_menubar;
-    static int symbianCommands(int command);
-#endif
 #ifdef QT_SOFTKEYS_ENABLED
     QAction *menuBarAction;
 #endif
diff --git a/src/widgets/widgets/qtabbar.cpp b/src/widgets/widgets/qtabbar.cpp
index bf9c7cc..d8dc434 100644
--- a/src/widgets/widgets/qtabbar.cpp
+++ b/src/widgets/widgets/qtabbar.cpp
@@ -67,10 +67,6 @@
 #include <private/qt_cocoa_helpers_mac_p.h>
 #endif
 
-#ifndef QT_NO_STYLE_S60
-#include "qs60style.h"
-#endif
-
 QT_BEGIN_NAMESPACE
 
 
@@ -495,9 +491,6 @@ void QTabBarPrivate::layoutTabs()
 
     if (useScrollButtons && tabList.count() && last > available) {
         int extra = extraWidth();
-#ifndef QT_NO_STYLE_S60
-        QS60Style *s60Style = qobject_cast<QS60Style*>(QApplication::style());
-#endif
         if (!vertTabs) {
             Qt::LayoutDirection ld = q->layoutDirection();
             QRect arrows = QStyle::visualRect(ld, q->rect(),
@@ -505,57 +498,25 @@ void QTabBarPrivate::layoutTabs()
             int buttonOverlap = q->style()->pixelMetric(QStyle::PM_TabBar_ScrollButtonOverlap, 0, q);
 
             if (ld == Qt::LeftToRight) {
-// In S60style, tab scroll buttons are layoutted separately, on the sides of the tabbar.
-#ifndef QT_NO_STYLE_S60
-                if (s60Style) {
-                    rightB->setGeometry(arrows.left() + extra / 2, arrows.top(), extra / 2, arrows.height());
-                    leftB->setGeometry(0, arrows.top(), extra / 2, arrows.height());
-                } else {
-#endif
                 leftB->setGeometry(arrows.left(), arrows.top(), extra/2, arrows.height());
                 rightB->setGeometry(arrows.right() - extra/2 + buttonOverlap, arrows.top(),
                                     extra/2, arrows.height());
-#ifndef QT_NO_STYLE_S60
-                }
-#endif
                 leftB->setArrowType(Qt::LeftArrow);
                 rightB->setArrowType(Qt::RightArrow);
             } else {
-#ifndef QT_NO_STYLE_S60
-                if (s60Style) {
-                    rightB->setGeometry(arrows.left() + extra / 2, arrows.top(), extra / 2, arrows.height());
-                    leftB->setGeometry(0, arrows.top(), extra / 2, arrows.height());
-                } else {
-#endif
                 rightB->setGeometry(arrows.left(), arrows.top(), extra/2, arrows.height());
                 leftB->setGeometry(arrows.right() - extra/2 + buttonOverlap, arrows.top(),
                                     extra/2, arrows.height());
-#ifndef QT_NO_STYLE_S60
-                }
-#endif
                 rightB->setArrowType(Qt::LeftArrow);
                 leftB->setArrowType(Qt::RightArrow);
             }
         } else {
-#ifndef QT_NO_STYLE_S60
-            if (s60Style) {
-                QRect arrows = QRect(0, 0, size.width(), available );
-                leftB->setGeometry(arrows.left(), arrows.top(), arrows.width(), extra / 2);
-                leftB->setArrowType(Qt::UpArrow);
-                rightB->setGeometry(arrows.left(), arrows.bottom() - extra / 2 + 1,
-                                    arrows.width(), extra / 2);
-                rightB->setArrowType(Qt::DownArrow);
-            } else {
-#endif
             QRect arrows = QRect(0, available - extra, size.width(), extra );
             leftB->setGeometry(arrows.left(), arrows.top(), arrows.width(), extra/2);
             leftB->setArrowType(Qt::UpArrow);
             rightB->setGeometry(arrows.left(), arrows.bottom() - extra/2 + 1,
                                 arrows.width(), extra/2);
             rightB->setArrowType(Qt::DownArrow);
-#ifndef QT_NO_STYLE_S60
-            }
-#endif
         }
         leftB->setEnabled(scrollOffset > 0);
         rightB->setEnabled(last - scrollOffset >= available - extra);