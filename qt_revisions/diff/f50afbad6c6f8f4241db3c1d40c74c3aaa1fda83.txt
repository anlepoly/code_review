diff --git a/src/plugins/qmltooling/qmldbg_qtquick2/qquickviewinspector.cpp b/src/plugins/qmltooling/qmldbg_qtquick2/qquickviewinspector.cpp
index dbe5119..a42663e 100644
--- a/src/plugins/qmltooling/qmldbg_qtquick2/qquickviewinspector.cpp
+++ b/src/plugins/qmltooling/qmldbg_qtquick2/qquickviewinspector.cpp
@@ -45,6 +45,7 @@
 #include "inspecttool.h"
 
 #include <QtQml/private/qqmlengine_p.h>
+#include <QtQml/private/qqmldebugservice_p.h>
 #include <QtQuick/private/qquickitem_p.h>
 
 #include <QtQuick/QQuickView>
@@ -321,6 +322,8 @@ void QQuickViewInspector::reloadQmlFile(const QHash<QString, QByteArray> &change
     // Reset the selection since we are reloading the main qml
     setSelectedItems(QList<QQuickItem *>());
 
+    QQmlDebugService::clearObjectsFromHash();
+
     QHash<QUrl, QByteArray> debugCache;
 
     foreach (const QString &str, changesHash.keys())
diff --git a/src/qml/debugger/qqmldebugservice.cpp b/src/qml/debugger/qqmldebugservice.cpp
index 511c854..d3d4df7 100644
--- a/src/qml/debugger/qqmldebugservice.cpp
+++ b/src/qml/debugger/qqmldebugservice.cpp
@@ -257,6 +257,13 @@ void QQmlDebugService::removeInvalidObjectsFromHash()
     }
 }
 
+void QQmlDebugService::clearObjectsFromHash()
+{
+    ObjectReferenceHash *hash = objectReferenceHash();
+    hash->ids.clear();
+    hash->objects.clear();
+}
+
 bool QQmlDebugService::isDebuggingEnabled()
 {
     return QQmlDebugServer::instance() != 0;
diff --git a/src/qml/debugger/qqmldebugservice_p.h b/src/qml/debugger/qqmldebugservice_p.h
index 4a0b52e..4fc37e6 100644
--- a/src/qml/debugger/qqmldebugservice_p.h
+++ b/src/qml/debugger/qqmldebugservice_p.h
@@ -88,6 +88,7 @@ public:
     static QList<QObject*> objectForLocationInfo(const QString &filename,
                                           int lineNumber, int columnNumber);
     static void removeInvalidObjectsFromHash();
+    static void clearObjectsFromHash();
 
     static QString objectToString(QObject *obj);
 
diff --git a/tests/auto/qml/debugger/debugger.pro b/tests/auto/qml/debugger/debugger.pro
index 81ca29a..8f90e4b 100644
--- a/tests/auto/qml/debugger/debugger.pro
+++ b/tests/auto/qml/debugger/debugger.pro
@@ -7,7 +7,8 @@ PUBLICTESTS += \
     qqmlprofilerservice \
     qpacketprotocol \
     qv8profilerservice \
-    qdebugmessageservice
+    qdebugmessageservice \
+    qqmlenginedebuginspectorintegrationtest
 
 PRIVATETESTS += \
     qqmldebugclient \
diff --git a/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/data/qtquick2.qml b/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/data/qtquick2.qml
new file mode 100644
index 0000000..9c36e13
--- /dev/null
+++ b/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/data/qtquick2.qml
@@ -0,0 +1,5 @@
+import QtQuick 2.0
+
+Item {
+
+}
diff --git a/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/qqmlenginedebuginspectorintegrationtest.pro b/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/qqmlenginedebuginspectorintegrationtest.pro
new file mode 100644
index 0000000..0ecb966
--- /dev/null
+++ b/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/qqmlenginedebuginspectorintegrationtest.pro
@@ -0,0 +1,15 @@
+CONFIG += testcase
+TARGET = tst_qqmlenginedebuginspectorintegration
+
+QT += qml testlib
+macx:CONFIG -= app_bundle
+
+SOURCES += tst_qqmlenginedebuginspectorintegration.cpp
+
+INCLUDEPATH += ../shared
+include(../../../shared/util.pri)
+include(../shared/qqmlinspectorclient.pri)
+include(../shared/qqmlenginedebugclient.pri)
+include(../shared/debugutil.pri)
+
+TESTDATA = data/*
diff --git a/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/tst_qqmlenginedebuginspectorintegration.cpp b/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/tst_qqmlenginedebuginspectorintegration.cpp
new file mode 100644
index 0000000..de34ba9
--- /dev/null
+++ b/tests/auto/qml/debugger/qqmlenginedebuginspectorintegrationtest/tst_qqmlenginedebuginspectorintegration.cpp
@@ -0,0 +1,200 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qtest.h>
+#include <QSignalSpy>
+#include <QTimer>
+#include <QHostAddress>
+#include <QDebug>
+#include <QThread>
+#include <QtCore/QLibraryInfo>
+
+#include "../shared/debugutil_p.h"
+#include "../../../shared/util.h"
+#include "qqmlinspectorclient.h"
+#include "qqmlenginedebugclient.h"
+
+#define PORT 3776
+#define STR_PORT "3776"
+
+class tst_QQmlEngineDebugInspectorIntegration : public QQmlDataTest
+{
+    Q_OBJECT
+
+public:
+    tst_QQmlEngineDebugInspectorIntegration()
+        : m_process(0)
+        , m_connection(0)
+        , m_inspectorClient(0)
+        , m_engineDebugClient(0)
+    {
+    }
+
+
+private:
+    QmlDebugObjectReference findRootObject();
+
+    QQmlDebugProcess *m_process;
+    QQmlDebugConnection *m_connection;
+    QQmlInspectorClient *m_inspectorClient;
+    QQmlEngineDebugClient *m_engineDebugClient;
+
+private slots:
+    void init();
+    void cleanup();
+
+    void connect();
+    void clearObjectReferenceHashonReloadQml();
+};
+
+
+QmlDebugObjectReference tst_QQmlEngineDebugInspectorIntegration::findRootObject()
+{
+    bool success = false;
+    m_engineDebugClient->queryAvailableEngines(&success);
+
+    QQmlDebugTest::waitForSignal(m_engineDebugClient, SIGNAL(result()));
+
+    m_engineDebugClient->queryRootContexts(m_engineDebugClient->engines()[0].debugId, &success);
+    QQmlDebugTest::waitForSignal(m_engineDebugClient, SIGNAL(result()));
+    int count = m_engineDebugClient->rootContext().contexts.count();
+    m_engineDebugClient->queryObject(
+                m_engineDebugClient->rootContext().contexts[count - 1].objects[0], &success);
+    QQmlDebugTest::waitForSignal(m_engineDebugClient, SIGNAL(result()));
+    return m_engineDebugClient->object();
+}
+
+
+void tst_QQmlEngineDebugInspectorIntegration::init()
+{
+    const QString argument = "-qmljsdebugger=port:"STR_PORT",block";
+
+    m_process = new QQmlDebugProcess(QLibraryInfo::location(QLibraryInfo::BinariesPath)
+                                     + "/qmlscene");
+    m_process->start(QStringList() << argument << testFile("qtquick2.qml"));
+    QVERIFY2(m_process->waitForSessionStart(),
+             "Could not launch application, or did not get 'Waiting for connection'.");
+
+    QQmlDebugConnection *m_connection = new QQmlDebugConnection(this);
+    m_inspectorClient = new QQmlInspectorClient(m_connection);
+    m_engineDebugClient = new QQmlEngineDebugClient(m_connection);
+
+    m_connection->connectToHost(QLatin1String("127.0.0.1"), PORT);
+    bool ok = m_connection->waitForConnected();
+    QVERIFY(ok);
+}
+
+void tst_QQmlEngineDebugInspectorIntegration::cleanup()
+{
+    if (QTest::currentTestFailed()) {
+        qDebug() << "Process State:" << m_process->state();
+        qDebug() << "Application Output:" << m_process->output();
+    }
+    delete m_process;
+    delete m_engineDebugClient;
+    delete m_inspectorClient;
+}
+
+void tst_QQmlEngineDebugInspectorIntegration::connect()
+{
+    QTRY_COMPARE(m_inspectorClient->state(), QQmlDebugClient::Enabled);
+    QTRY_COMPARE(m_engineDebugClient->state(), QQmlDebugClient::Enabled);
+}
+
+void tst_QQmlEngineDebugInspectorIntegration::clearObjectReferenceHashonReloadQml()
+{
+    QTRY_COMPARE(m_engineDebugClient->state(), QQmlDebugClient::Enabled);
+    bool success = false;
+    QmlDebugObjectReference rootObject = findRootObject();
+    const QString fileName = QFileInfo(rootObject.source.url.toString()).fileName();
+    int lineNumber = rootObject.source.lineNumber;
+    int columnNumber = rootObject.source.columnNumber;
+    m_engineDebugClient->queryObjectsForLocation(fileName, lineNumber,
+                                        columnNumber, &success);
+    QVERIFY(success);
+    QVERIFY(QQmlDebugTest::waitForSignal(m_engineDebugClient, SIGNAL(result())));
+
+    foreach (QmlDebugObjectReference child, rootObject.children) {
+        success = false;
+        lineNumber = child.source.lineNumber;
+        columnNumber = child.source.columnNumber;
+        m_engineDebugClient->queryObjectsForLocation(fileName, lineNumber,
+                                       columnNumber, &success);
+        QVERIFY(success);
+        QVERIFY(QQmlDebugTest::waitForSignal(m_engineDebugClient, SIGNAL(result())));
+    }
+
+    QTRY_COMPARE(m_inspectorClient->state(), QQmlDebugClient::Enabled);
+
+    QByteArray contents;
+    contents.append("import QtQuick 2.0\n"
+               "Text {"
+               "y: 10\n"
+               "text: \"test\"\n"
+               "}");
+
+    QHash<QString, QByteArray> changesHash;
+    changesHash.insert("test.qml", contents);
+    m_inspectorClient->reloadQml(changesHash);
+    QVERIFY(QQmlDebugTest::waitForSignal(m_inspectorClient, SIGNAL(responseReceived())));
+
+    lineNumber = rootObject.source.lineNumber;
+    columnNumber = rootObject.source.columnNumber;
+    success = false;
+    m_engineDebugClient->queryObjectsForLocation(fileName, lineNumber,
+                                   columnNumber, &success);
+    QVERIFY(success);
+    QVERIFY(QQmlDebugTest::waitForSignal(m_engineDebugClient, SIGNAL(result())));
+
+    foreach (QmlDebugObjectReference child, rootObject.children) {
+        success = false;
+        lineNumber = child.source.lineNumber;
+        columnNumber = child.source.columnNumber;
+        m_engineDebugClient->queryObjectsForLocation(fileName, lineNumber,
+                                       columnNumber, &success);
+        QVERIFY(success);
+        QVERIFY(QQmlDebugTest::waitForSignal(m_engineDebugClient, SIGNAL(result())));
+    }
+}
+
+QTEST_MAIN(tst_QQmlEngineDebugInspectorIntegration)
+
+#include "tst_qqmlenginedebuginspectorintegration.moc"
diff --git a/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugclient.cpp b/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugclient.cpp
deleted file mode 100644
index 3807cf5..0000000
--- a/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugclient.cpp
+++ /dev/null
@@ -1,533 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qqmlenginedebugclient.h"
-
-struct QmlObjectData {
-    QUrl url;
-    int lineNumber;
-    int columnNumber;
-    QString idString;
-    QString objectName;
-    QString objectType;
-    int objectId;
-    int contextId;
-    int parentId;
-};
-
-QDataStream &operator>>(QDataStream &ds, QmlObjectData &data)
-{
-    ds >> data.url >> data.lineNumber >> data.columnNumber >> data.idString
-       >> data.objectName >> data.objectType >> data.objectId >> data.contextId
-       >> data.parentId;
-    return ds;
-}
-
-struct QmlObjectProperty {
-    enum Type { Unknown, Basic, Object, List, SignalProperty };
-    Type type;
-    QString name;
-    QVariant value;
-    QString valueTypeName;
-    QString binding;
-    bool hasNotifySignal;
-};
-
-QDataStream &operator>>(QDataStream &ds, QmlObjectProperty &data)
-{
-    int type;
-    ds >> type >> data.name >> data.value >> data.valueTypeName
-       >> data.binding >> data.hasNotifySignal;
-    data.type = (QmlObjectProperty::Type)type;
-    return ds;
-}
-
-QQmlEngineDebugClient::QQmlEngineDebugClient(
-        QQmlDebugConnection *connection)
-    : QQmlDebugClient(QLatin1String("QmlDebugger"), connection),
-      m_nextId(0),
-      m_valid(false)
-{
-}
-
-quint32 QQmlEngineDebugClient::addWatch(
-        const QmlDebugPropertyReference &property, bool *success)
-{
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("WATCH_PROPERTY") << id << property.objectDebugId
-           << property.name.toUtf8();
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::addWatch(
-        const QmlDebugContextReference &, const QString &, bool *success)
-{
-    *success = false;
-    qWarning("QQmlEngineDebugClient::addWatch(): Not implemented");
-    return 0;
-}
-
-quint32 QQmlEngineDebugClient::addWatch(
-        const QmlDebugObjectReference &object, const QString &expr,
-        bool *success)
-{
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("WATCH_EXPR_OBJECT") << id << object.debugId << expr;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::addWatch(
-        const QmlDebugObjectReference &object, bool *success)
-{
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("WATCH_OBJECT") << id << object.debugId;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::addWatch(
-        const QmlDebugFileReference &,  bool *success)
-{
-    *success = false;
-    qWarning("QQmlEngineDebugClient::addWatch(): Not implemented");
-    return 0;
-}
-
-void QQmlEngineDebugClient::removeWatch(quint32 id, bool *success)
-{
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("NO_WATCH") << id;
-        sendMessage(message);
-        *success = true;
-    }
-}
-
-quint32 QQmlEngineDebugClient::queryAvailableEngines(bool *success)
-{
-    m_engines.clear();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("LIST_ENGINES") << id;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::queryRootContexts(
-        const QmlDebugEngineReference &engine, bool *success)
-{
-    m_rootContext = QmlDebugContextReference();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled && engine.debugId != -1) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("LIST_OBJECTS") << id << engine.debugId;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::queryObject(
-        const QmlDebugObjectReference &object, bool *success)
-{
-    m_object = QmlDebugObjectReference();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled && object.debugId != -1) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("FETCH_OBJECT") << id << object.debugId << false <<
-              true;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::queryObjectsForLocation(
-        const QString &file, int lineNumber, int columnNumber, bool *success)
-{
-    m_objects.clear();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("FETCH_OBJECTS_FOR_LOCATION") << id << file << lineNumber
-           << columnNumber << false << true;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::queryObjectRecursive(
-        const QmlDebugObjectReference &object, bool *success)
-{
-    m_object = QmlDebugObjectReference();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled && object.debugId != -1) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("FETCH_OBJECT") << id << object.debugId << true <<
-              true;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::queryObjectsForLocationRecursive(const QString &file,
-        int lineNumber, int columnNumber, bool *success)
-{
-     m_objects.clear();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("FETCH_OBJECTS_FOR_LOCATION") << id << file << lineNumber
-           << columnNumber << true << true;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::queryExpressionResult(
-        int objectDebugId, const QString &expr, bool *success)
-{
-    m_exprResult = QVariant();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("EVAL_EXPRESSION") << id << objectDebugId << expr
-           << engines()[0].debugId;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::queryExpressionResultBC(
-        int objectDebugId, const QString &expr, bool *success)
-{
-    m_exprResult = QVariant();
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("EVAL_EXPRESSION") << id << objectDebugId << expr;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::setBindingForObject(
-        int objectDebugId,
-        const QString &propertyName,
-        const QVariant &bindingExpression,
-        bool isLiteralValue,
-        QString source, int line,
-        bool *success)
-{
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("SET_BINDING") << id << objectDebugId << propertyName
-           << bindingExpression << isLiteralValue << source << line;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::resetBindingForObject(
-        int objectDebugId,
-        const QString &propertyName,
-        bool *success)
-{
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("RESET_BINDING") << id << objectDebugId << propertyName;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-quint32 QQmlEngineDebugClient::setMethodBody(
-        int objectDebugId, const QString &methodName,
-        const QString &methodBody, bool *success)
-{
-    quint32 id;
-    *success = false;
-    if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
-        id = getId();
-        QByteArray message;
-        QDataStream ds(&message, QIODevice::WriteOnly);
-        ds << QByteArray("SET_METHOD_BODY") << id << objectDebugId
-           << methodName << methodBody;
-        sendMessage(message);
-        *success = true;
-    }
-    return id;
-}
-
-void QQmlEngineDebugClient::decode(QDataStream &ds,
-                                   QmlDebugObjectReference &o,
-                                   bool simple)
-{
-    QmlObjectData data;
-    ds >> data;
-    o.debugId = data.objectId;
-    o.className = data.objectType;
-    o.idString = data.idString;
-    o.name = data.objectName;
-    o.source.url = data.url;
-    o.source.lineNumber = data.lineNumber;
-    o.source.columnNumber = data.columnNumber;
-    o.contextDebugId = data.contextId;
-
-    if (simple)
-        return;
-
-    int childCount;
-    bool recur;
-    ds >> childCount >> recur;
-
-    for (int ii = 0; ii < childCount; ++ii) {
-        o.children.append(QmlDebugObjectReference());
-        decode(ds, o.children.last(), !recur);
-    }
-
-    int propCount;
-    ds >> propCount;
-
-    for (int ii = 0; ii < propCount; ++ii) {
-        QmlObjectProperty data;
-        ds >> data;
-        QmlDebugPropertyReference prop;
-        prop.objectDebugId = o.debugId;
-        prop.name = data.name;
-        prop.binding = data.binding;
-        prop.hasNotifySignal = data.hasNotifySignal;
-        prop.valueTypeName = data.valueTypeName;
-        switch (data.type) {
-        case QmlObjectProperty::Basic:
-        case QmlObjectProperty::List:
-        case QmlObjectProperty::SignalProperty:
-        {
-            prop.value = data.value;
-            break;
-        }
-        case QmlObjectProperty::Object:
-        {
-            QmlDebugObjectReference obj;
-            obj.debugId = prop.value.toInt();
-            prop.value = qVariantFromValue(obj);
-            break;
-        }
-        case QmlObjectProperty::Unknown:
-            break;
-        }
-        o.properties << prop;
-    }
-}
-
-void QQmlEngineDebugClient::decode(QDataStream &ds,
-                                   QList<QmlDebugObjectReference> &o,
-                                   bool simple)
-{
-    int count;
-    ds >> count;
-    for (int i = 0; i < count; i++) {
-        QmlDebugObjectReference obj;
-        decode(ds, obj, simple);
-        o << obj;
-    }
-}
-
-void QQmlEngineDebugClient::decode(QDataStream &ds,
-                                   QmlDebugContextReference &c)
-{
-    ds >> c.name >> c.debugId;
-
-    int contextCount;
-    ds >> contextCount;
-
-    for (int ii = 0; ii < contextCount; ++ii) {
-        c.contexts.append(QmlDebugContextReference());
-        decode(ds, c.contexts.last());
-    }
-
-    int objectCount;
-    ds >> objectCount;
-
-    for (int ii = 0; ii < objectCount; ++ii) {
-        QmlDebugObjectReference obj;
-        decode(ds, obj, true);
-
-        obj.contextDebugId = c.debugId;
-        c.objects << obj;
-    }
-}
-
-void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
-{
-    m_valid = false;
-    QDataStream ds(data);
-    int queryId;
-    QByteArray type;
-    ds >> type >> queryId;
-
-    //qDebug() << "QQmlEngineDebugPrivate::message()" << type;
-
-    if (type == "LIST_ENGINES_R") {
-        int count;
-        ds >> count;
-
-        m_engines.clear();
-        for (int ii = 0; ii < count; ++ii) {
-            QmlDebugEngineReference eng;
-            ds >> eng.name;
-            ds >> eng.debugId;
-            m_engines << eng;
-        }
-    } else if (type == "LIST_OBJECTS_R") {
-        if (!ds.atEnd())
-            decode(ds, m_rootContext);
-
-    } else if (type == "FETCH_OBJECT_R") {
-        if (!ds.atEnd())
-            decode(ds, m_object, false);
-
-    } else if (type == "FETCH_OBJECTS_FOR_LOCATION_R") {
-        if (!ds.atEnd())
-            decode(ds, m_objects, false);
-
-    } else if (type == "EVAL_EXPRESSION_R") {;
-        ds >> m_exprResult;
-
-    } else if (type == "WATCH_PROPERTY_R") {
-        ds >> m_valid;
-
-    } else if (type == "WATCH_OBJECT_R") {
-        ds >> m_valid;
-
-    } else if (type == "WATCH_EXPR_OBJECT_R") {
-        ds >> m_valid;
-
-    } else if (type == "UPDATE_WATCH") {
-        int debugId;
-        QByteArray name;
-        QVariant value;
-        ds >> debugId >> name >> value;
-        emit valueChanged(name, value);
-        return;
-
-    } else if (type == "OBJECT_CREATED") {
-        emit newObjects();
-        return;
-    } else if (type == "SET_BINDING_R") {
-        ds >> m_valid;
-    } else if (type == "RESET_BINDING_R") {
-        ds >> m_valid;
-    } else if (type == "SET_METHOD_BODY_R") {
-        ds >> m_valid;
-    } else if (type == "NO_WATCH_R") {
-        ds >> m_valid;
-    }
-    emit result();
-}
-
diff --git a/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugclient.h b/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugclient.h
deleted file mode 100644
index be96575..0000000
--- a/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugclient.h
+++ /dev/null
@@ -1,247 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QQMLENGINEDEBUGCLIENT_H
-#define QQMLENGINEDEBUGCLIENT_H
-
-#include "qqmldebugclient.h"
-
-#include <QtCore/qurl.h>
-#include <QtCore/qvariant.h>
-
-class QQmlDebugConnection;
-
-struct QmlDebugPropertyReference
-{
-    QmlDebugPropertyReference()
-        : objectDebugId(-1), hasNotifySignal(false)
-    {
-    }
-
-    QmlDebugPropertyReference &operator=(
-            const QmlDebugPropertyReference &o)
-    {
-        objectDebugId = o.objectDebugId; name = o.name; value = o.value;
-        valueTypeName = o.valueTypeName; binding = o.binding;
-        hasNotifySignal = o.hasNotifySignal;
-        return *this;
-    }
-
-    int objectDebugId;
-    QString name;
-    QVariant value;
-    QString valueTypeName;
-    QString binding;
-    bool hasNotifySignal;
-};
-
-struct QmlDebugFileReference
-{
-    QmlDebugFileReference()
-        : lineNumber(-1), columnNumber(-1)
-    {
-    }
-
-    QmlDebugFileReference &operator=(
-            const QmlDebugFileReference &o)
-    {
-        url = o.url; lineNumber = o.lineNumber; columnNumber = o.columnNumber;
-        return *this;
-    }
-
-    QUrl url;
-    int lineNumber;
-    int columnNumber;
-};
-
-struct QmlDebugObjectReference
-{
-    QmlDebugObjectReference()
-        : debugId(-1), contextDebugId(-1)
-    {
-    }
-
-    QmlDebugObjectReference(int id)
-        : debugId(id), contextDebugId(-1)
-    {
-    }
-
-    QmlDebugObjectReference &operator=(
-            const QmlDebugObjectReference &o)
-    {
-        debugId = o.debugId; className = o.className; idString = o.idString;
-        name = o.name; source = o.source; contextDebugId = o.contextDebugId;
-        properties = o.properties; children = o.children;
-        return *this;
-    }
-    int debugId;
-    QString className;
-    QString idString;
-    QString name;
-    QmlDebugFileReference source;
-    int contextDebugId;
-    QList<QmlDebugPropertyReference> properties;
-    QList<QmlDebugObjectReference> children;
-};
-
-Q_DECLARE_METATYPE(QmlDebugObjectReference)
-
-struct QmlDebugContextReference
-{
-    QmlDebugContextReference()
-        : debugId(-1)
-    {
-    }
-
-    QmlDebugContextReference &operator=(
-            const QmlDebugContextReference &o)
-    {
-        debugId = o.debugId; name = o.name; objects = o.objects;
-        contexts = o.contexts;
-        return *this;
-    }
-
-    int debugId;
-    QString name;
-    QList<QmlDebugObjectReference> objects;
-    QList<QmlDebugContextReference> contexts;
-};
-
-struct QmlDebugEngineReference
-{
-    QmlDebugEngineReference()
-        : debugId(-1)
-    {
-    }
-
-    QmlDebugEngineReference(int id)
-        : debugId(id)
-    {
-    }
-
-    QmlDebugEngineReference &operator=(
-            const QmlDebugEngineReference &o)
-    {
-        debugId = o.debugId; name = o.name;
-        return *this;
-    }
-
-    int debugId;
-    QString name;
-};
-
-class QQmlEngineDebugClient : public QQmlDebugClient
-{
-    Q_OBJECT
-public:
-    explicit QQmlEngineDebugClient(QQmlDebugConnection *conn);
-
-    quint32 addWatch(const QmlDebugPropertyReference &,
-                     bool *success);
-    quint32 addWatch(const QmlDebugContextReference &, const QString &,
-                     bool *success);
-    quint32 addWatch(const QmlDebugObjectReference &, const QString &,
-                     bool *success);
-    quint32 addWatch(const QmlDebugObjectReference &,
-                     bool *success);
-    quint32 addWatch(const QmlDebugFileReference &,
-                     bool *success);
-
-    void removeWatch(quint32 watch, bool *success);
-
-    quint32 queryAvailableEngines(bool *success);
-    quint32 queryRootContexts(const QmlDebugEngineReference &,
-                              bool *success);
-    quint32 queryObject(const QmlDebugObjectReference &,
-                        bool *success);
-    quint32 queryObjectsForLocation(const QString &file,
-            int lineNumber, int columnNumber, bool *success);
-    quint32 queryObjectRecursive(const QmlDebugObjectReference &,
-                                 bool *success);
-    quint32 queryObjectsForLocationRecursive(const QString &file,
-            int lineNumber, int columnNumber, bool *success);
-    quint32 queryExpressionResult(int objectDebugId,
-                                  const QString &expr,
-                                  bool *success);
-    quint32 queryExpressionResultBC(int objectDebugId,
-                                  const QString &expr,
-                                  bool *success);
-    quint32 setBindingForObject(int objectDebugId, const QString &propertyName,
-                                const QVariant &bindingExpression,
-                                bool isLiteralValue,
-                                QString source, int line, bool *success);
-    quint32 resetBindingForObject(int objectDebugId,
-                                  const QString &propertyName, bool *success);
-    quint32 setMethodBody(int objectDebugId, const QString &methodName,
-                          const QString &methodBody, bool *success);
-
-    quint32 getId() { return m_nextId++; }
-
-    void decode(QDataStream &, QmlDebugContextReference &);
-    void decode(QDataStream &, QmlDebugObjectReference &, bool simple);
-    void decode(QDataStream &ds, QList<QmlDebugObjectReference> &o, bool simple);
-
-    QList<QmlDebugEngineReference> engines() { return m_engines; }
-    QmlDebugContextReference rootContext() { return m_rootContext; }
-    QmlDebugObjectReference object() { return m_object; }
-    QList<QmlDebugObjectReference> objects() { return m_objects; }
-    QVariant resultExpr() { return m_exprResult; }
-    bool valid() { return m_valid; }
-
-signals:
-    void newObjects();
-    void valueChanged(QByteArray,QVariant);
-    void result();
-
-protected:
-    void messageReceived(const QByteArray &);
-
-private:
-    quint32 m_nextId;
-    bool m_valid;
-    QList<QmlDebugEngineReference> m_engines;
-    QmlDebugContextReference m_rootContext;
-    QmlDebugObjectReference m_object;
-    QList<QmlDebugObjectReference> m_objects;
-    QVariant m_exprResult;
-};
-
-#endif // QQMLENGINEDEBUGCLIENT_H
diff --git a/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugservice.pro b/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugservice.pro
index 983fdb3..26dba8b 100644
--- a/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugservice.pro
+++ b/tests/auto/qml/debugger/qqmlenginedebugservice/qqmlenginedebugservice.pro
@@ -2,15 +2,12 @@ CONFIG += testcase
 TARGET = tst_qqmlenginedebugservice
 macx:CONFIG -= app_bundle
 
-HEADERS += \
-    qqmlenginedebugclient.h
-
 SOURCES += \
-    tst_qqmlenginedebugservice.cpp \
-    qqmlenginedebugclient.cpp
+    tst_qqmlenginedebugservice.cpp
 
 INCLUDEPATH += ../shared
 include(../../../shared/util.pri)
+include(../shared/qqmlenginedebugclient.pri)
 include(../shared/debugutil.pri)
 
 DEFINES += QT_QML_DEBUG_NO_WARNING
diff --git a/tests/auto/qml/debugger/qqmlinspector/qqmlinspector.pro b/tests/auto/qml/debugger/qqmlinspector/qqmlinspector.pro
index 1d42dde..5849d60 100644
--- a/tests/auto/qml/debugger/qqmlinspector/qqmlinspector.pro
+++ b/tests/auto/qml/debugger/qqmlinspector/qqmlinspector.pro
@@ -8,6 +8,7 @@ SOURCES += tst_qqmlinspector.cpp
 
 INCLUDEPATH += ../shared
 include(../../../shared/util.pri)
+include(../shared/qqmlinspectorclient.pri)
 include(../shared/debugutil.pri)
 
 TESTDATA = data/*
diff --git a/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.cpp b/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.cpp
index 5326a05..291939d 100644
--- a/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.cpp
+++ b/tests/auto/qml/debugger/qqmlinspector/tst_qqmlinspector.cpp
@@ -48,42 +48,12 @@
 
 #include "../shared/debugutil_p.h"
 #include "../../../shared/util.h"
+#include "qqmlinspectorclient.h"
 
 #define PORT 3772
 #define STR_PORT "3772"
 
-class QQmlInspectorClient : public QQmlDebugClient
-{
-    Q_OBJECT
-
-public:
-    QQmlInspectorClient(QQmlDebugConnection *connection)
-        : QQmlDebugClient(QLatin1String("QmlInspector"), connection)
-        , m_showAppOnTop(false)
-        , m_requestId(0)
-        , m_requestResult(false)
-        , m_responseId(-1)
-    {
-    }
-
-    void setShowAppOnTop(bool showOnTop);
-    void reloadQml(const QHash<QString, QByteArray> &changesHash);
-
-signals:
-    void responseReceived();
 
-protected:
-    void messageReceived(const QByteArray &message);
-
-private:
-    bool m_showAppOnTop;
-    int m_requestId;
-
-public:
-    bool m_requestResult;
-    int m_responseId;
-    int m_reloadRequestId;
-};
 
 class tst_QQmlInspector : public QQmlDataTest
 {
@@ -112,45 +82,6 @@ private slots:
     void reloadQml();
 };
 
-
-void QQmlInspectorClient::setShowAppOnTop(bool showOnTop)
-{
-    QByteArray message;
-    QDataStream ds(&message, QIODevice::WriteOnly);
-    ds << QByteArray("request") << m_requestId++
-       << QByteArray("showAppOnTop") << showOnTop;
-
-    sendMessage(message);
-}
-
-void QQmlInspectorClient::reloadQml(const QHash<QString, QByteArray> &changesHash)
-{
-    QByteArray message;
-    QDataStream ds(&message, QIODevice::WriteOnly);
-    m_reloadRequestId = m_requestId;
-
-    ds << QByteArray("request") << m_requestId++
-       << QByteArray("reload") << changesHash;
-
-    sendMessage(message);
-}
-
-void QQmlInspectorClient::messageReceived(const QByteArray &message)
-{
-    QDataStream ds(message);
-    QByteArray type;
-    ds >> type;
-
-    if (type != QByteArray("response")) {
-        qDebug() << "Unhandled message of type" << type;
-        return;
-    }
-
-    m_requestResult = false;
-    ds >> m_responseId >> m_requestResult;
-    emit responseReceived();
-}
-
 void tst_QQmlInspector::init()
 {
     const QString argument = "-qmljsdebugger=port:"STR_PORT",block";
diff --git a/tests/auto/qml/debugger/shared/qqmlenginedebugclient.cpp b/tests/auto/qml/debugger/shared/qqmlenginedebugclient.cpp
new file mode 100644
index 0000000..3807cf5
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlenginedebugclient.cpp
@@ -0,0 +1,533 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qqmlenginedebugclient.h"
+
+struct QmlObjectData {
+    QUrl url;
+    int lineNumber;
+    int columnNumber;
+    QString idString;
+    QString objectName;
+    QString objectType;
+    int objectId;
+    int contextId;
+    int parentId;
+};
+
+QDataStream &operator>>(QDataStream &ds, QmlObjectData &data)
+{
+    ds >> data.url >> data.lineNumber >> data.columnNumber >> data.idString
+       >> data.objectName >> data.objectType >> data.objectId >> data.contextId
+       >> data.parentId;
+    return ds;
+}
+
+struct QmlObjectProperty {
+    enum Type { Unknown, Basic, Object, List, SignalProperty };
+    Type type;
+    QString name;
+    QVariant value;
+    QString valueTypeName;
+    QString binding;
+    bool hasNotifySignal;
+};
+
+QDataStream &operator>>(QDataStream &ds, QmlObjectProperty &data)
+{
+    int type;
+    ds >> type >> data.name >> data.value >> data.valueTypeName
+       >> data.binding >> data.hasNotifySignal;
+    data.type = (QmlObjectProperty::Type)type;
+    return ds;
+}
+
+QQmlEngineDebugClient::QQmlEngineDebugClient(
+        QQmlDebugConnection *connection)
+    : QQmlDebugClient(QLatin1String("QmlDebugger"), connection),
+      m_nextId(0),
+      m_valid(false)
+{
+}
+
+quint32 QQmlEngineDebugClient::addWatch(
+        const QmlDebugPropertyReference &property, bool *success)
+{
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("WATCH_PROPERTY") << id << property.objectDebugId
+           << property.name.toUtf8();
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::addWatch(
+        const QmlDebugContextReference &, const QString &, bool *success)
+{
+    *success = false;
+    qWarning("QQmlEngineDebugClient::addWatch(): Not implemented");
+    return 0;
+}
+
+quint32 QQmlEngineDebugClient::addWatch(
+        const QmlDebugObjectReference &object, const QString &expr,
+        bool *success)
+{
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("WATCH_EXPR_OBJECT") << id << object.debugId << expr;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::addWatch(
+        const QmlDebugObjectReference &object, bool *success)
+{
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("WATCH_OBJECT") << id << object.debugId;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::addWatch(
+        const QmlDebugFileReference &,  bool *success)
+{
+    *success = false;
+    qWarning("QQmlEngineDebugClient::addWatch(): Not implemented");
+    return 0;
+}
+
+void QQmlEngineDebugClient::removeWatch(quint32 id, bool *success)
+{
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("NO_WATCH") << id;
+        sendMessage(message);
+        *success = true;
+    }
+}
+
+quint32 QQmlEngineDebugClient::queryAvailableEngines(bool *success)
+{
+    m_engines.clear();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("LIST_ENGINES") << id;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::queryRootContexts(
+        const QmlDebugEngineReference &engine, bool *success)
+{
+    m_rootContext = QmlDebugContextReference();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled && engine.debugId != -1) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("LIST_OBJECTS") << id << engine.debugId;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::queryObject(
+        const QmlDebugObjectReference &object, bool *success)
+{
+    m_object = QmlDebugObjectReference();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled && object.debugId != -1) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("FETCH_OBJECT") << id << object.debugId << false <<
+              true;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::queryObjectsForLocation(
+        const QString &file, int lineNumber, int columnNumber, bool *success)
+{
+    m_objects.clear();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("FETCH_OBJECTS_FOR_LOCATION") << id << file << lineNumber
+           << columnNumber << false << true;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::queryObjectRecursive(
+        const QmlDebugObjectReference &object, bool *success)
+{
+    m_object = QmlDebugObjectReference();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled && object.debugId != -1) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("FETCH_OBJECT") << id << object.debugId << true <<
+              true;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::queryObjectsForLocationRecursive(const QString &file,
+        int lineNumber, int columnNumber, bool *success)
+{
+     m_objects.clear();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("FETCH_OBJECTS_FOR_LOCATION") << id << file << lineNumber
+           << columnNumber << true << true;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::queryExpressionResult(
+        int objectDebugId, const QString &expr, bool *success)
+{
+    m_exprResult = QVariant();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("EVAL_EXPRESSION") << id << objectDebugId << expr
+           << engines()[0].debugId;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::queryExpressionResultBC(
+        int objectDebugId, const QString &expr, bool *success)
+{
+    m_exprResult = QVariant();
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("EVAL_EXPRESSION") << id << objectDebugId << expr;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::setBindingForObject(
+        int objectDebugId,
+        const QString &propertyName,
+        const QVariant &bindingExpression,
+        bool isLiteralValue,
+        QString source, int line,
+        bool *success)
+{
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("SET_BINDING") << id << objectDebugId << propertyName
+           << bindingExpression << isLiteralValue << source << line;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::resetBindingForObject(
+        int objectDebugId,
+        const QString &propertyName,
+        bool *success)
+{
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("RESET_BINDING") << id << objectDebugId << propertyName;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+quint32 QQmlEngineDebugClient::setMethodBody(
+        int objectDebugId, const QString &methodName,
+        const QString &methodBody, bool *success)
+{
+    quint32 id;
+    *success = false;
+    if (state() == QQmlDebugClient::Enabled && objectDebugId != -1) {
+        id = getId();
+        QByteArray message;
+        QDataStream ds(&message, QIODevice::WriteOnly);
+        ds << QByteArray("SET_METHOD_BODY") << id << objectDebugId
+           << methodName << methodBody;
+        sendMessage(message);
+        *success = true;
+    }
+    return id;
+}
+
+void QQmlEngineDebugClient::decode(QDataStream &ds,
+                                   QmlDebugObjectReference &o,
+                                   bool simple)
+{
+    QmlObjectData data;
+    ds >> data;
+    o.debugId = data.objectId;
+    o.className = data.objectType;
+    o.idString = data.idString;
+    o.name = data.objectName;
+    o.source.url = data.url;
+    o.source.lineNumber = data.lineNumber;
+    o.source.columnNumber = data.columnNumber;
+    o.contextDebugId = data.contextId;
+
+    if (simple)
+        return;
+
+    int childCount;
+    bool recur;
+    ds >> childCount >> recur;
+
+    for (int ii = 0; ii < childCount; ++ii) {
+        o.children.append(QmlDebugObjectReference());
+        decode(ds, o.children.last(), !recur);
+    }
+
+    int propCount;
+    ds >> propCount;
+
+    for (int ii = 0; ii < propCount; ++ii) {
+        QmlObjectProperty data;
+        ds >> data;
+        QmlDebugPropertyReference prop;
+        prop.objectDebugId = o.debugId;
+        prop.name = data.name;
+        prop.binding = data.binding;
+        prop.hasNotifySignal = data.hasNotifySignal;
+        prop.valueTypeName = data.valueTypeName;
+        switch (data.type) {
+        case QmlObjectProperty::Basic:
+        case QmlObjectProperty::List:
+        case QmlObjectProperty::SignalProperty:
+        {
+            prop.value = data.value;
+            break;
+        }
+        case QmlObjectProperty::Object:
+        {
+            QmlDebugObjectReference obj;
+            obj.debugId = prop.value.toInt();
+            prop.value = qVariantFromValue(obj);
+            break;
+        }
+        case QmlObjectProperty::Unknown:
+            break;
+        }
+        o.properties << prop;
+    }
+}
+
+void QQmlEngineDebugClient::decode(QDataStream &ds,
+                                   QList<QmlDebugObjectReference> &o,
+                                   bool simple)
+{
+    int count;
+    ds >> count;
+    for (int i = 0; i < count; i++) {
+        QmlDebugObjectReference obj;
+        decode(ds, obj, simple);
+        o << obj;
+    }
+}
+
+void QQmlEngineDebugClient::decode(QDataStream &ds,
+                                   QmlDebugContextReference &c)
+{
+    ds >> c.name >> c.debugId;
+
+    int contextCount;
+    ds >> contextCount;
+
+    for (int ii = 0; ii < contextCount; ++ii) {
+        c.contexts.append(QmlDebugContextReference());
+        decode(ds, c.contexts.last());
+    }
+
+    int objectCount;
+    ds >> objectCount;
+
+    for (int ii = 0; ii < objectCount; ++ii) {
+        QmlDebugObjectReference obj;
+        decode(ds, obj, true);
+
+        obj.contextDebugId = c.debugId;
+        c.objects << obj;
+    }
+}
+
+void QQmlEngineDebugClient::messageReceived(const QByteArray &data)
+{
+    m_valid = false;
+    QDataStream ds(data);
+    int queryId;
+    QByteArray type;
+    ds >> type >> queryId;
+
+    //qDebug() << "QQmlEngineDebugPrivate::message()" << type;
+
+    if (type == "LIST_ENGINES_R") {
+        int count;
+        ds >> count;
+
+        m_engines.clear();
+        for (int ii = 0; ii < count; ++ii) {
+            QmlDebugEngineReference eng;
+            ds >> eng.name;
+            ds >> eng.debugId;
+            m_engines << eng;
+        }
+    } else if (type == "LIST_OBJECTS_R") {
+        if (!ds.atEnd())
+            decode(ds, m_rootContext);
+
+    } else if (type == "FETCH_OBJECT_R") {
+        if (!ds.atEnd())
+            decode(ds, m_object, false);
+
+    } else if (type == "FETCH_OBJECTS_FOR_LOCATION_R") {
+        if (!ds.atEnd())
+            decode(ds, m_objects, false);
+
+    } else if (type == "EVAL_EXPRESSION_R") {;
+        ds >> m_exprResult;
+
+    } else if (type == "WATCH_PROPERTY_R") {
+        ds >> m_valid;
+
+    } else if (type == "WATCH_OBJECT_R") {
+        ds >> m_valid;
+
+    } else if (type == "WATCH_EXPR_OBJECT_R") {
+        ds >> m_valid;
+
+    } else if (type == "UPDATE_WATCH") {
+        int debugId;
+        QByteArray name;
+        QVariant value;
+        ds >> debugId >> name >> value;
+        emit valueChanged(name, value);
+        return;
+
+    } else if (type == "OBJECT_CREATED") {
+        emit newObjects();
+        return;
+    } else if (type == "SET_BINDING_R") {
+        ds >> m_valid;
+    } else if (type == "RESET_BINDING_R") {
+        ds >> m_valid;
+    } else if (type == "SET_METHOD_BODY_R") {
+        ds >> m_valid;
+    } else if (type == "NO_WATCH_R") {
+        ds >> m_valid;
+    }
+    emit result();
+}
+
diff --git a/tests/auto/qml/debugger/shared/qqmlenginedebugclient.h b/tests/auto/qml/debugger/shared/qqmlenginedebugclient.h
new file mode 100644
index 0000000..be96575
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlenginedebugclient.h
@@ -0,0 +1,247 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQMLENGINEDEBUGCLIENT_H
+#define QQMLENGINEDEBUGCLIENT_H
+
+#include "qqmldebugclient.h"
+
+#include <QtCore/qurl.h>
+#include <QtCore/qvariant.h>
+
+class QQmlDebugConnection;
+
+struct QmlDebugPropertyReference
+{
+    QmlDebugPropertyReference()
+        : objectDebugId(-1), hasNotifySignal(false)
+    {
+    }
+
+    QmlDebugPropertyReference &operator=(
+            const QmlDebugPropertyReference &o)
+    {
+        objectDebugId = o.objectDebugId; name = o.name; value = o.value;
+        valueTypeName = o.valueTypeName; binding = o.binding;
+        hasNotifySignal = o.hasNotifySignal;
+        return *this;
+    }
+
+    int objectDebugId;
+    QString name;
+    QVariant value;
+    QString valueTypeName;
+    QString binding;
+    bool hasNotifySignal;
+};
+
+struct QmlDebugFileReference
+{
+    QmlDebugFileReference()
+        : lineNumber(-1), columnNumber(-1)
+    {
+    }
+
+    QmlDebugFileReference &operator=(
+            const QmlDebugFileReference &o)
+    {
+        url = o.url; lineNumber = o.lineNumber; columnNumber = o.columnNumber;
+        return *this;
+    }
+
+    QUrl url;
+    int lineNumber;
+    int columnNumber;
+};
+
+struct QmlDebugObjectReference
+{
+    QmlDebugObjectReference()
+        : debugId(-1), contextDebugId(-1)
+    {
+    }
+
+    QmlDebugObjectReference(int id)
+        : debugId(id), contextDebugId(-1)
+    {
+    }
+
+    QmlDebugObjectReference &operator=(
+            const QmlDebugObjectReference &o)
+    {
+        debugId = o.debugId; className = o.className; idString = o.idString;
+        name = o.name; source = o.source; contextDebugId = o.contextDebugId;
+        properties = o.properties; children = o.children;
+        return *this;
+    }
+    int debugId;
+    QString className;
+    QString idString;
+    QString name;
+    QmlDebugFileReference source;
+    int contextDebugId;
+    QList<QmlDebugPropertyReference> properties;
+    QList<QmlDebugObjectReference> children;
+};
+
+Q_DECLARE_METATYPE(QmlDebugObjectReference)
+
+struct QmlDebugContextReference
+{
+    QmlDebugContextReference()
+        : debugId(-1)
+    {
+    }
+
+    QmlDebugContextReference &operator=(
+            const QmlDebugContextReference &o)
+    {
+        debugId = o.debugId; name = o.name; objects = o.objects;
+        contexts = o.contexts;
+        return *this;
+    }
+
+    int debugId;
+    QString name;
+    QList<QmlDebugObjectReference> objects;
+    QList<QmlDebugContextReference> contexts;
+};
+
+struct QmlDebugEngineReference
+{
+    QmlDebugEngineReference()
+        : debugId(-1)
+    {
+    }
+
+    QmlDebugEngineReference(int id)
+        : debugId(id)
+    {
+    }
+
+    QmlDebugEngineReference &operator=(
+            const QmlDebugEngineReference &o)
+    {
+        debugId = o.debugId; name = o.name;
+        return *this;
+    }
+
+    int debugId;
+    QString name;
+};
+
+class QQmlEngineDebugClient : public QQmlDebugClient
+{
+    Q_OBJECT
+public:
+    explicit QQmlEngineDebugClient(QQmlDebugConnection *conn);
+
+    quint32 addWatch(const QmlDebugPropertyReference &,
+                     bool *success);
+    quint32 addWatch(const QmlDebugContextReference &, const QString &,
+                     bool *success);
+    quint32 addWatch(const QmlDebugObjectReference &, const QString &,
+                     bool *success);
+    quint32 addWatch(const QmlDebugObjectReference &,
+                     bool *success);
+    quint32 addWatch(const QmlDebugFileReference &,
+                     bool *success);
+
+    void removeWatch(quint32 watch, bool *success);
+
+    quint32 queryAvailableEngines(bool *success);
+    quint32 queryRootContexts(const QmlDebugEngineReference &,
+                              bool *success);
+    quint32 queryObject(const QmlDebugObjectReference &,
+                        bool *success);
+    quint32 queryObjectsForLocation(const QString &file,
+            int lineNumber, int columnNumber, bool *success);
+    quint32 queryObjectRecursive(const QmlDebugObjectReference &,
+                                 bool *success);
+    quint32 queryObjectsForLocationRecursive(const QString &file,
+            int lineNumber, int columnNumber, bool *success);
+    quint32 queryExpressionResult(int objectDebugId,
+                                  const QString &expr,
+                                  bool *success);
+    quint32 queryExpressionResultBC(int objectDebugId,
+                                  const QString &expr,
+                                  bool *success);
+    quint32 setBindingForObject(int objectDebugId, const QString &propertyName,
+                                const QVariant &bindingExpression,
+                                bool isLiteralValue,
+                                QString source, int line, bool *success);
+    quint32 resetBindingForObject(int objectDebugId,
+                                  const QString &propertyName, bool *success);
+    quint32 setMethodBody(int objectDebugId, const QString &methodName,
+                          const QString &methodBody, bool *success);
+
+    quint32 getId() { return m_nextId++; }
+
+    void decode(QDataStream &, QmlDebugContextReference &);
+    void decode(QDataStream &, QmlDebugObjectReference &, bool simple);
+    void decode(QDataStream &ds, QList<QmlDebugObjectReference> &o, bool simple);
+
+    QList<QmlDebugEngineReference> engines() { return m_engines; }
+    QmlDebugContextReference rootContext() { return m_rootContext; }
+    QmlDebugObjectReference object() { return m_object; }
+    QList<QmlDebugObjectReference> objects() { return m_objects; }
+    QVariant resultExpr() { return m_exprResult; }
+    bool valid() { return m_valid; }
+
+signals:
+    void newObjects();
+    void valueChanged(QByteArray,QVariant);
+    void result();
+
+protected:
+    void messageReceived(const QByteArray &);
+
+private:
+    quint32 m_nextId;
+    bool m_valid;
+    QList<QmlDebugEngineReference> m_engines;
+    QmlDebugContextReference m_rootContext;
+    QmlDebugObjectReference m_object;
+    QList<QmlDebugObjectReference> m_objects;
+    QVariant m_exprResult;
+};
+
+#endif // QQMLENGINEDEBUGCLIENT_H
diff --git a/tests/auto/qml/debugger/shared/qqmlenginedebugclient.pri b/tests/auto/qml/debugger/shared/qqmlenginedebugclient.pri
new file mode 100644
index 0000000..a969b4f
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlenginedebugclient.pri
@@ -0,0 +1,3 @@
+HEADERS += $$PWD/qqmlenginedebugclient.h
+
+SOURCES += $$PWD/qqmlenginedebugclient.cpp
diff --git a/tests/auto/qml/debugger/shared/qqmlinspectorclient.cpp b/tests/auto/qml/debugger/shared/qqmlinspectorclient.cpp
new file mode 100644
index 0000000..604e970
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlinspectorclient.cpp
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qqmlinspectorclient.h"
+
+void QQmlInspectorClient::setShowAppOnTop(bool showOnTop)
+{
+    QByteArray message;
+    QDataStream ds(&message, QIODevice::WriteOnly);
+    ds << QByteArray("request") << m_requestId++
+       << QByteArray("showAppOnTop") << showOnTop;
+
+    sendMessage(message);
+}
+
+void QQmlInspectorClient::reloadQml(const QHash<QString, QByteArray> &changesHash)
+{
+    QByteArray message;
+    QDataStream ds(&message, QIODevice::WriteOnly);
+    m_reloadRequestId = m_requestId;
+
+    ds << QByteArray("request") << m_requestId++
+       << QByteArray("reload") << changesHash;
+
+    sendMessage(message);
+}
+
+void QQmlInspectorClient::messageReceived(const QByteArray &message)
+{
+    QDataStream ds(message);
+    QByteArray type;
+    ds >> type;
+
+    if (type != QByteArray("response")) {
+        qDebug() << "Unhandled message of type" << type;
+        return;
+    }
+
+    m_requestResult = false;
+    ds >> m_responseId >> m_requestResult;
+    emit responseReceived();
+}
diff --git a/tests/auto/qml/debugger/shared/qqmlinspectorclient.h b/tests/auto/qml/debugger/shared/qqmlinspectorclient.h
new file mode 100644
index 0000000..5eb543e
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlinspectorclient.h
@@ -0,0 +1,79 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#ifndef QQMLINSPECTORCLIENT_H
+#define QQMLINSPECTORCLIENT_H
+
+#include "qqmldebugclient.h"
+
+class QQmlInspectorClient : public QQmlDebugClient
+{
+    Q_OBJECT
+
+public:
+    QQmlInspectorClient(QQmlDebugConnection *connection)
+        : QQmlDebugClient(QLatin1String("QmlInspector"), connection)
+        , m_showAppOnTop(false)
+        , m_requestId(0)
+        , m_requestResult(false)
+        , m_responseId(-1)
+    {
+    }
+
+    void setShowAppOnTop(bool showOnTop);
+    void reloadQml(const QHash<QString, QByteArray> &changesHash);
+
+signals:
+    void responseReceived();
+
+protected:
+    void messageReceived(const QByteArray &message);
+
+private:
+    bool m_showAppOnTop;
+    int m_requestId;
+
+public:
+    bool m_requestResult;
+    int m_responseId;
+    int m_reloadRequestId;
+};
+
+#endif // QQMLINSPECTORCLIENT_H
diff --git a/tests/auto/qml/debugger/shared/qqmlinspectorclient.pri b/tests/auto/qml/debugger/shared/qqmlinspectorclient.pri
new file mode 100644
index 0000000..c136e13
--- /dev/null
+++ b/tests/auto/qml/debugger/shared/qqmlinspectorclient.pri
@@ -0,0 +1,3 @@
+HEADERS += $$PWD/qqmlinspectorclient.h
+
+SOURCES += $$PWD/qqmlinspectorclient.cpp