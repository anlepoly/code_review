diff --git a/src/corelib/kernel/qmetaobject.cpp b/src/corelib/kernel/qmetaobject.cpp
index 759dfba..75dbb49 100644
--- a/src/corelib/kernel/qmetaobject.cpp
+++ b/src/corelib/kernel/qmetaobject.cpp
@@ -162,26 +162,14 @@ static inline QByteArray toByteArray(const QByteArrayData &d)
     return QByteArray(reinterpret_cast<const QStaticByteArrayData<0> &>(d));
 }
 
-static inline const char *legacyString(const QMetaObject *mo, int index)
-{
-    Q_ASSERT(priv(mo->d.data)->revision <= 6);
-    return reinterpret_cast<const char *>(mo->d.stringdata) + index;
-}
-
 static inline const char *rawStringData(const QMetaObject *mo, int index)
 {
-    if (priv(mo->d.data)->revision >= 7)
-        return stringData(mo, index).data();
-    else
-        return legacyString(mo, index);
+    return stringData(mo, index).data();
 }
 
 static inline int stringSize(const QMetaObject *mo, int index)
 {
-    if (priv(mo->d.data)->revision >= 7)
-        return stringData(mo, index).size;
-    else
-        return qstrlen(legacyString(mo, index));
+    return stringData(mo, index).size;
 }
 
 static inline QByteArray typeNameFromTypeInfo(const QMetaObject *mo, uint typeInfo)
@@ -306,19 +294,11 @@ QObject *QMetaObject::newInstance(QGenericArgument val0,
 int QMetaObject::static_metacall(Call cl, int idx, void **argv) const
 {
     const QMetaObjectExtraData *extra = reinterpret_cast<const QMetaObjectExtraData *>(d.extradata);
-    if (priv(d.data)->revision >= 6) {
-        if (!extra || !extra->static_metacall)
-            return 0;
-        extra->static_metacall(0, cl, idx, argv);
-        return -1;
-    } else if (priv(d.data)->revision >= 2) {
-        if (!extra || !extra->static_metacall)
-            return 0;
-        typedef int (*OldMetacall)(QMetaObject::Call, int, void **);
-        OldMetacall o = reinterpret_cast<OldMetacall>(extra->static_metacall);
-        return o(cl, idx, argv);
-    }
-    return 0;
+    Q_ASSERT(priv(d.data)->revision >= 6);
+    if (!extra || !extra->static_metacall)
+        return 0;
+    extra->static_metacall(0, cl, idx, argv);
+    return -1;
 }
 
 /*!
@@ -499,8 +479,7 @@ int QMetaObject::classInfoOffset() const
 */
 int QMetaObject::constructorCount() const
 {
-    if (priv(d.data)->revision < 2)
-        return 0;
+    Q_ASSERT(priv(d.data)->revision >= 2);
     return priv(d.data)->constructorCount;
 }
 
@@ -611,58 +590,6 @@ static bool methodMatch(const QMetaObject *m, int handle,
 }
 
 /** \internal
-* \obsolete
-* helper function for indexOf{Method,Slot,Signal}, returns the relative index of the method within
-* the baseObject
-* \a MethodType might be MethodSignal or MethodSlot, or 0 to match everything.
-* \a normalizeStringData set to true if we should do a second pass for old moc generated files normalizing all the symbols.
-*/
-template<int MethodType>
-static inline int indexOfMethodRelative(const QMetaObject **baseObject,
-                                        const char *method,
-                                        bool normalizeStringData)
-{
-    QByteArray methodName;
-    QArgumentTypeArray methodArgumentTypes;
-    for (const QMetaObject *m = *baseObject; m; m = m->d.superdata) {
-        int i = (MethodType == MethodSignal && priv(m->d.data)->revision >= 4)
-                ? (priv(m->d.data)->signalCount - 1) : (priv(m->d.data)->methodCount - 1);
-        const int end = (MethodType == MethodSlot && priv(m->d.data)->revision >= 4)
-                        ? (priv(m->d.data)->signalCount) : 0;
-        if (!normalizeStringData) {
-            for (; i >= end; --i) {
-                if (priv(m->d.data)->revision >= 7) {
-                    if (methodName.isEmpty())
-                        methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodArgumentTypes);
-                    int handle = priv(m->d.data)->methodData + 5*i;
-                    if (methodMatch(m, handle, methodName, methodArgumentTypes.size(),
-                                    methodArgumentTypes.constData())) {
-                        *baseObject = m;
-                        return i;
-                    }
-                } else {
-                    const char *stringdata = legacyString(m, m->d.data[priv(m->d.data)->methodData + 5*i]);
-                    if (method[0] == stringdata[0] && strcmp(method + 1, stringdata + 1) == 0) {
-                        *baseObject = m;
-                        return i;
-                    }
-                }
-            }
-        } else if (priv(m->d.data)->revision < 5) {
-            for (; i >= end; --i) {
-                const char *stringdata = legacyString(m, m->d.data[priv(m->d.data)->methodData + 5 * i]);
-                const QByteArray normalizedSignature = QMetaObject::normalizedSignature(stringdata);
-                if (normalizedSignature == method) {
-                    *baseObject = m;
-                    return i;
-                }
-            }
-        }
-    }
-    return -1;
-}
-
-/** \internal
 * helper function for indexOf{Method,Slot,Signal}, returns the relative index of the method within
 * the baseObject
 * \a MethodType might be MethodSignal or MethodSlot, or 0 to match everything.
@@ -703,21 +630,10 @@ static inline int indexOfMethodRelative(const QMetaObject **baseObject,
 */
 int QMetaObject::indexOfConstructor(const char *constructor) const
 {
-    if (priv(d.data)->revision < 2)
-        return -1;
-    else if (priv(d.data)->revision >= 7) {
-        QArgumentTypeArray types;
-        QByteArray name = QMetaObjectPrivate::decodeMethodSignature(constructor, types);
-        return QMetaObjectPrivate::indexOfConstructor(this, name, types.size(), types.constData());
-    } else {
-        for (int i = priv(d.data)->constructorCount-1; i >= 0; --i) {
-            const char *data = legacyString(this, d.data[priv(d.data)->constructorData + 5*i]);
-            if (data[0] == constructor[0] && strcmp(constructor + 1, data + 1) == 0) {
-                return i;
-            }
-        }
-    }
-    return -1;
+    Q_ASSERT(priv(d.data)->revision >= 7);
+    QArgumentTypeArray types;
+    QByteArray name = QMetaObjectPrivate::decodeMethodSignature(constructor, types);
+    return QMetaObjectPrivate::indexOfConstructor(this, name, types.size(), types.constData());
 }
 
 /*!
@@ -732,17 +648,10 @@ int QMetaObject::indexOfMethod(const char *method) const
 {
     const QMetaObject *m = this;
     int i;
-    if (priv(m->d.data)->revision >= 7) {
-        QArgumentTypeArray types;
-        QByteArray name = QMetaObjectPrivate::decodeMethodSignature(method, types);
-        i = indexOfMethodRelative<0>(&m, name, types.size(), types.constData());
-    } else {
-        i = indexOfMethodRelative<0>(&m, method, false);
-        if (i < 0) {
-            m = this;
-            i = indexOfMethodRelative<0>(&m, method, true);
-        }
-    }
+    Q_ASSERT(priv(m->d.data)->revision >= 7);
+    QArgumentTypeArray types;
+    QByteArray name = QMetaObjectPrivate::decodeMethodSignature(method, types);
+    i = indexOfMethodRelative<0>(&m, name, types.size(), types.constData());
     if (i >= 0)
         i += m->methodOffset();
     return i;
@@ -774,6 +683,7 @@ static void argumentTypesFromString(const char *str, const char *end,
 QByteArray QMetaObjectPrivate::decodeMethodSignature(
         const char *signature, QArgumentTypeArray &types)
 {
+    Q_ASSERT(signature != 0);
     const char *lparens = strchr(signature, '(');
     if (!lparens)
         return QByteArray();
@@ -800,46 +710,16 @@ int QMetaObject::indexOfSignal(const char *signal) const
 {
     const QMetaObject *m = this;
     int i;
-    if (priv(m->d.data)->revision >= 7) {
-        QArgumentTypeArray types;
-        QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signal, types);
-        i = QMetaObjectPrivate::indexOfSignalRelative(&m, name, types.size(), types.constData());
-    } else {
-        i = QMetaObjectPrivate::indexOfSignalRelative(&m, signal, false);
-        if (i < 0) {
-            m = this;
-            i = QMetaObjectPrivate::indexOfSignalRelative(&m, signal, true);
-        }
-    }
+    Q_ASSERT(priv(m->d.data)->revision >= 7);
+    QArgumentTypeArray types;
+    QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signal, types);
+    i = QMetaObjectPrivate::indexOfSignalRelative(&m, name, types.size(), types.constData());
     if (i >= 0)
         i += m->methodOffset();
     return i;
 }
 
 /*! \internal
-    \obsolete
-    Same as QMetaObject::indexOfSignal, but the result is the local offset to the base object.
-
-    \a baseObject will be adjusted to the enclosing QMetaObject, or 0 if the signal is not found
-*/
-int QMetaObjectPrivate::indexOfSignalRelative(const QMetaObject **baseObject,
-                                              const char *signal,
-                                              bool normalizeStringData)
-{
-    int i = indexOfMethodRelative<MethodSignal>(baseObject, signal, normalizeStringData);
-#ifndef QT_NO_DEBUG
-    const QMetaObject *m = *baseObject;
-    if (i >= 0 && m && m->d.superdata) {
-        int conflict = m->d.superdata->indexOfMethod(signal);
-        if (conflict >= 0)
-            qWarning("QMetaObject::indexOfSignal: signal %s from %s redefined in %s",
-                     signal, rawStringData(m->d.superdata, 0), rawStringData(m, 0));
-    }
-#endif
-    return i;
-}
-
-/*! \internal
     Same as QMetaObject::indexOfSignal, but the result is the local offset to the base object.
 
     \a baseObject will be adjusted to the enclosing QMetaObject, or 0 if the signal is not found
@@ -876,15 +756,10 @@ int QMetaObject::indexOfSlot(const char *slot) const
 {
     const QMetaObject *m = this;
     int i;
-    if (priv(m->d.data)->revision >= 7) {
-        QArgumentTypeArray types;
-        QByteArray name = QMetaObjectPrivate::decodeMethodSignature(slot, types);
-        i = QMetaObjectPrivate::indexOfSlotRelative(&m, name, types.size(), types.constData());
-    } else {
-        i = QMetaObjectPrivate::indexOfSlotRelative(&m, slot, false);
-        if (i < 0)
-            i = QMetaObjectPrivate::indexOfSlotRelative(&m, slot, true);
-    }
+    Q_ASSERT(priv(m->d.data)->revision >= 7);
+    QArgumentTypeArray types;
+    QByteArray name = QMetaObjectPrivate::decodeMethodSignature(slot, types);
+    i = QMetaObjectPrivate::indexOfSlotRelative(&m, name, types.size(), types.constData());
     if (i >= 0)
         i += m->methodOffset();
     return i;
@@ -892,14 +767,6 @@ int QMetaObject::indexOfSlot(const char *slot) const
 
 // same as indexOfSignalRelative but for slots.
 int QMetaObjectPrivate::indexOfSlotRelative(const QMetaObject **m,
-                                    const char *slot,
-                                    bool normalizeStringData)
-{
-    return indexOfMethodRelative<MethodSlot>(m, slot, normalizeStringData);
-}
-
-// same as indexOfSignalRelative but for slots.
-int QMetaObjectPrivate::indexOfSlotRelative(const QMetaObject **m,
                                             const QByteArray &name, int argc,
                                             const QArgumentType *types)
 {
@@ -1003,13 +870,9 @@ static const QMetaObject *QMetaObject_findMetaObject(const QMetaObject *self, co
             return self;
         if (self->d.extradata) {
             const QMetaObject **e;
-            if (priv(self->d.data)->revision < 2) {
-                e = (const QMetaObject**)(self->d.extradata);
-            } else
-            {
-                const QMetaObjectExtraData *extra = (const QMetaObjectExtraData*)(self->d.extradata);
-                e = extra->objects;
-            }
+            Q_ASSERT(priv(self->d.data)->revision >= 2);
+            const QMetaObjectExtraData *extra = (const QMetaObjectExtraData*)(self->d.extradata);
+            e = extra->objects;
             if (e) {
                 while (*e) {
                     if (const QMetaObject *m =QMetaObject_findMetaObject((*e), name))
@@ -1067,7 +930,8 @@ int QMetaObject::indexOfProperty(const char *name) const
         m = m->d.superdata;
     }
 
-    if (priv(this->d.data)->revision >= 3 && (priv(this->d.data)->flags & DynamicMetaObject)) {
+    Q_ASSERT(priv(this->d.data)->revision >= 3);
+    if (priv(this->d.data)->flags & DynamicMetaObject) {
         QAbstractDynamicMetaObject *me = 
             const_cast<QAbstractDynamicMetaObject *>(static_cast<const QAbstractDynamicMetaObject *>(this));
 
@@ -1109,7 +973,8 @@ QMetaMethod QMetaObject::constructor(int index) const
 {
     int i = index;
     QMetaMethod result;
-    if (priv(d.data)->revision >= 2 && i >= 0 && i < priv(d.data)->constructorCount) {
+    Q_ASSERT(priv(d.data)->revision >= 2);
+    if (i >= 0 && i < priv(d.data)->constructorCount) {
         result.mobj = this;
         result.handle = priv(d.data)->constructorData + 5*i;
     }
@@ -1178,11 +1043,7 @@ QMetaProperty QMetaObject::property(int index) const
         result.idx = i;
 
         if (flags & EnumOrFlag) {
-            const char *type;
-            if (priv(d.data)->revision >= 7)
-                type = rawTypeNameFromTypeInfo(this, d.data[handle + 1]);
-            else
-                type = legacyString(this, d.data[handle + 1]);
+            const char *type = rawTypeNameFromTypeInfo(this, d.data[handle + 1]);
             result.menum = enumerator(indexOfEnumerator(type));
             if (!result.menum.isValid()) {
                 const char *enum_name = type;
@@ -1759,12 +1620,7 @@ QByteArray QMetaMethod::methodSignature() const
 {
     if (!mobj)
         return QByteArray();
-    if (priv(mobj->d.data)->revision >= 7) {
-        return QMetaMethodPrivate::get(this)->signature();
-    } else {
-        const char *sig = rawStringData(mobj, mobj->d.data[handle]);
-        return QByteArray::fromRawData(sig, qstrlen(sig));
-    }
+    return QMetaMethodPrivate::get(this)->signature();
 }
 
 /*!
@@ -1856,12 +1712,7 @@ QList<QByteArray> QMetaMethod::parameterTypes() const
 {
     if (!mobj)
         return QList<QByteArray>();
-    if (priv(mobj->d.data)->revision >= 7) {
-        return QMetaMethodPrivate::get(this)->parameterTypes();
-    } else {
-        return QMetaObjectPrivate::parameterTypeNamesFromSignature(
-                    legacyString(mobj, mobj->d.data[handle]));
-    }
+    return QMetaMethodPrivate::get(this)->parameterTypes();
 }
 
 /*!
@@ -1874,28 +1725,7 @@ QList<QByteArray> QMetaMethod::parameterNames() const
     QList<QByteArray> list;
     if (!mobj)
         return list;
-    if (priv(mobj->d.data)->revision >= 7) {
-        return QMetaMethodPrivate::get(this)->parameterNames();
-    } else {
-        const char *names =  rawStringData(mobj, mobj->d.data[handle + 1]);
-        if (*names == 0) {
-            // do we have one or zero arguments?
-            const char *signature = rawStringData(mobj, mobj->d.data[handle]);
-            while (*signature && *signature != '(')
-                ++signature;
-            if (*++signature != ')')
-                list += QByteArray();
-        } else {
-            --names;
-            do {
-                const char *begin = ++names;
-                while (*names && *names != ',')
-                    ++names;
-                list += QByteArray(begin, names - begin);
-            } while (*names);
-        }
-        return list;
-    }
+    return QMetaMethodPrivate::get(this)->parameterNames();
 }
 
 
@@ -1908,10 +1738,7 @@ const char *QMetaMethod::typeName() const
 {
     if (!mobj)
         return 0;
-    if (priv(mobj->d.data)->revision >= 7)
-        return QMetaMethodPrivate::get(this)->rawReturnTypeName();
-    else
-        return legacyString(mobj, mobj->d.data[handle + 2]);
+    return QMetaMethodPrivate::get(this)->rawReturnTypeName();
 }
 
 /*!
@@ -1948,10 +1775,7 @@ const char *QMetaMethod::tag() const
 {
     if (!mobj)
         return 0;
-    if (priv(mobj->d.data)->revision >= 7)
-        return QMetaMethodPrivate::get(this)->tag().constData();
-    else
-        return legacyString(mobj, mobj->d.data[handle + 3]);
+    return QMetaMethodPrivate::get(this)->tag().constData();
 }
 
 
@@ -2151,30 +1975,7 @@ bool QMetaMethod::invoke(QObject *object,
         if (qstrlen(typeNames[paramCount]) <= 0)
             break;
     }
-    int metaMethodArgumentCount = 0;
-    if (priv(mobj->d.data)->revision >= 7) {
-        metaMethodArgumentCount = QMetaMethodPrivate::get(this)->parameterCount();
-    } else {
-        // based on QMetaObject::parameterNames()
-        const char *names = rawStringData(mobj, mobj->d.data[handle + 1]);
-        if (*names == 0) {
-            // do we have one or zero arguments?
-            const char *signature = rawStringData(mobj, mobj->d.data[handle]);
-            while (*signature && *signature != '(')
-                ++signature;
-            if (*++signature != ')')
-                ++metaMethodArgumentCount;
-        } else {
-            --names;
-            do {
-                ++names;
-                while (*names && *names != ',')
-                    ++names;
-                ++metaMethodArgumentCount;
-            } while (*names);
-        }
-    }
-    if (paramCount <= metaMethodArgumentCount)
+    if (paramCount <= QMetaMethodPrivate::get(this)->parameterCount())
         return false;
 
     // check connection type
@@ -2209,8 +2010,8 @@ bool QMetaMethod::invoke(QObject *object,
     // recompute the methodIndex by reversing the arithmetic in QMetaObject::property()
     int idx_relative = ((handle - priv(mobj->d.data)->methodData) / 5);
     int idx_offset =  mobj->methodOffset();
-    QObjectPrivate::StaticMetaCallFunction callFunction =
-        (QMetaObjectPrivate::get(mobj)->revision >= 6 && mobj->d.extradata)
+    Q_ASSERT(QMetaObjectPrivate::get(mobj)->revision >= 6);
+    QObjectPrivate::StaticMetaCallFunction callFunction = mobj->d.extradata
         ? reinterpret_cast<const QMetaObjectExtraData *>(mobj->d.extradata)->static_metacall : 0;
 
     if (connectionType == Qt::DirectConnection) {
@@ -2589,10 +2390,7 @@ QByteArray QMetaEnum::valueToKeys(int value) const
             v = v & ~k;
             if (!keys.isEmpty())
                 keys += '|';
-            if (priv(mobj->d.data)->revision >= 7)
-                keys += toByteArray(stringData(mobj, mobj->d.data[data + 2*i]));
-            else
-                keys += legacyString(mobj, mobj->d.data[data + 2*i]);
+            keys += toByteArray(stringData(mobj, mobj->d.data[data + 2*i]));
         }
     }
     return keys;
@@ -2684,10 +2482,7 @@ const char *QMetaProperty::typeName() const
     if (!mobj)
         return 0;
     int handle = priv(mobj->d.data)->propertyData + 3*idx;
-    if (priv(mobj->d.data)->revision >= 7)
-        return rawTypeNameFromTypeInfo(mobj, mobj->d.data[handle + 1]);
-    else
-        return legacyString(mobj, mobj->d.data[handle + 1]);
+    return rawTypeNameFromTypeInfo(mobj, mobj->d.data[handle + 1]);
 }
 
 /*!
@@ -2702,15 +2497,10 @@ QVariant::Type QMetaProperty::type() const
         return QVariant::Invalid;
     int handle = priv(mobj->d.data)->propertyData + 3*idx;
 
-    uint type;
-    if (priv(mobj->d.data)->revision >= 7) {
-        type = typeFromTypeInfo(mobj, mobj->d.data[handle + 1]);
-        if (type >= QMetaType::User)
-            return QVariant::UserType;
-    } else {
-        uint flags = mobj->d.data[handle + 2];
-        type = flags >> 24;
-    }
+    Q_ASSERT(priv(mobj->d.data)->revision >= 7);
+    uint type = typeFromTypeInfo(mobj, mobj->d.data[handle + 1]);
+    if (type >= QMetaType::User)
+        return QVariant::UserType;
     if (type != QMetaType::UnknownType)
         return QVariant::Type(type);
     if (isEnumType()) {
@@ -2740,16 +2530,11 @@ int QMetaProperty::userType() const
 {
     if (!mobj)
         return QMetaType::UnknownType;
-    if (priv(mobj->d.data)->revision >= 7) {
-        int handle = priv(mobj->d.data)->propertyData + 3*idx;
-        int type = typeFromTypeInfo(mobj, mobj->d.data[handle + 1]);
-        if (type != QMetaType::UnknownType)
-            return type;
-    } else {
-        QVariant::Type tp = type();
-        if (tp != QVariant::UserType)
-            return tp;
-    }
+    Q_ASSERT(priv(mobj->d.data)->revision >= 7);
+    int handle = priv(mobj->d.data)->propertyData + 3*idx;
+    int type = typeFromTypeInfo(mobj, mobj->d.data[handle + 1]);
+    if (type != QMetaType::UnknownType)
+        return type;
     if (isEnumType()) {
         int enumMetaTypeId = QMetaType::type(qualifiedName(menum));
         if (enumMetaTypeId == QMetaType::UnknownType)
@@ -2854,23 +2639,13 @@ QVariant QMetaProperty::read(const QObject *object) const
     } else {
         int handle = priv(mobj->d.data)->propertyData + 3*idx;
         const char *typeName = 0;
-        if (priv(mobj->d.data)->revision >= 7) {
-            uint typeInfo = mobj->d.data[handle + 1];
-            if (!(typeInfo & IsUnresolvedType))
-                t = typeInfo;
-            else {
-                typeName = rawStringData(mobj, typeInfo & TypeNameIndexMask);
-                t = QMetaType::type(typeName);
-            }
-        } else {
-            uint flags = mobj->d.data[handle + 2];
-            t = (flags >> 24);
-            if (t == QMetaType::UnknownType) {
-                typeName = legacyString(mobj, mobj->d.data[handle + 1]);
-                t = QMetaType::type(typeName);
-                if (t == QMetaType::UnknownType)
-                    t = QVariant::nameToType(typeName);
-            }
+        Q_ASSERT(priv(mobj->d.data)->revision >= 7);
+        uint typeInfo = mobj->d.data[handle + 1];
+        if (!(typeInfo & IsUnresolvedType))
+            t = typeInfo;
+        else {
+            typeName = rawStringData(mobj, typeInfo & TypeNameIndexMask);
+            t = QMetaType::type(typeName);
         }
         if (t == QMetaType::UnknownType) {
             qWarning("QMetaProperty::read: Unable to handle unregistered datatype '%s' for property '%s::%s'", typeName, mobj->className(), name());
@@ -2935,21 +2710,16 @@ bool QMetaProperty::write(QObject *object, const QVariant &value) const
     } else {
         int handle = priv(mobj->d.data)->propertyData + 3*idx;
         const char *typeName = 0;
-        if (priv(mobj->d.data)->revision >= 7) {
-            uint typeInfo = mobj->d.data[handle + 1];
-            if (!(typeInfo & IsUnresolvedType))
-                t = typeInfo;
-            else {
-                typeName = rawStringData(mobj, typeInfo & TypeNameIndexMask);
-                t = QMetaType::type(typeName);
-            }
-        } else {
-            uint flags = mobj->d.data[handle + 2];
-            t = flags >> 24;
-            typeName = legacyString(mobj, mobj->d.data[handle + 1]);
+        Q_ASSERT(priv(mobj->d.data)->revision >= 7);
+        uint typeInfo = mobj->d.data[handle + 1];
+        if (!(typeInfo & IsUnresolvedType))
+            t = typeInfo;
+        else {
+            typeName = rawStringData(mobj, typeInfo & TypeNameIndexMask);
+            t = QMetaType::type(typeName);
         }
         if (t == QMetaType::UnknownType) {
-            const char *typeName = rawStringData(mobj, mobj->d.data[handle + 1]);
+            Q_ASSERT(typeName != 0);
             const char *vtypeName = value.typeName();
             if (vtypeName && strcmp(typeName, vtypeName) == 0)
                 t = value.userType();
diff --git a/src/corelib/kernel/qmetaobject_p.h b/src/corelib/kernel/qmetaobject_p.h
index ff8dccc..3b732b4 100644
--- a/src/corelib/kernel/qmetaobject_p.h
+++ b/src/corelib/kernel/qmetaobject_p.h
@@ -180,12 +180,6 @@ struct QMetaObjectPrivate
     static inline const QMetaObjectPrivate *get(const QMetaObject *metaobject)
     { return reinterpret_cast<const QMetaObjectPrivate*>(metaobject->d.data); }
 
-    static int indexOfSignalRelative(const QMetaObject **baseObject,
-                                     const char* name,
-                                     bool normalizeStringData);
-    static int indexOfSlotRelative(const QMetaObject **m,
-                           const char *slot,
-                           bool normalizeStringData);
     static int originalClone(const QMetaObject *obj, int local_method_index);
 
     static QByteArray decodeMethodSignature(const char *signature,
diff --git a/src/corelib/kernel/qmetaobjectbuilder.cpp b/src/corelib/kernel/qmetaobjectbuilder.cpp
index e282a22..5974096 100644
--- a/src/corelib/kernel/qmetaobjectbuilder.cpp
+++ b/src/corelib/kernel/qmetaobjectbuilder.cpp
@@ -737,16 +737,12 @@ void QMetaObjectBuilder::addMetaObject
 
     if ((members & RelatedMetaObjects) != 0) {
         const QMetaObject **objects;
-        if (priv(prototype->d.data)->revision < 2) {
-            objects = (const QMetaObject **)(prototype->d.extradata);
-        } else
-        {
-            const QMetaObjectExtraData *extra = (const QMetaObjectExtraData *)(prototype->d.extradata);
-            if (extra)
-                objects = extra->objects;
-            else
-                objects = 0;
-        }
+        Q_ASSERT(priv(prototype->d.data)->revision >= 2);
+        const QMetaObjectExtraData *extra = (const QMetaObjectExtraData *)(prototype->d.extradata);
+        if (extra)
+            objects = extra->objects;
+        else
+            objects = 0;
         if (objects) {
             while (*objects != 0) {
                 addRelatedMetaObject(*objects);
@@ -756,12 +752,11 @@ void QMetaObjectBuilder::addMetaObject
     }
 
     if ((members & StaticMetacall) != 0) {
-        if (priv(prototype->d.data)->revision >= 6) {
-            const QMetaObjectExtraData *extra =
-                (const QMetaObjectExtraData *)(prototype->d.extradata);
-            if (extra && extra->static_metacall)
-                setStaticMetacallFunction(extra->static_metacall);
-        }
+        Q_ASSERT(priv(prototype->d.data)->revision >= 6);
+        const QMetaObjectExtraData *extra =
+            (const QMetaObjectExtraData *)(prototype->d.extradata);
+        if (extra && extra->static_metacall)
+            setStaticMetacallFunction(extra->static_metacall);
     }
 }
 
diff --git a/src/corelib/kernel/qobject.cpp b/src/corelib/kernel/qobject.cpp
index a2f18ee..ae4449e 100644
--- a/src/corelib/kernel/qobject.cpp
+++ b/src/corelib/kernel/qobject.cpp
@@ -245,9 +245,8 @@ static void computeOffsets(const QMetaObject *metaobject, int *signalOffset, int
     while (m) {
         const QMetaObjectPrivate *d = QMetaObjectPrivate::get(m);
         *methodOffset += d->methodCount;
-        *signalOffset += (d->revision >= 4) ? d->signalCount : d->methodCount;
-        /*Before Qt 4.6 (revision 4), the signalCount information was not generated by moc.
-           so for compatibility we consider all the method as slot for old moc output*/
+        Q_ASSERT(d->revision >= 4);
+        *signalOffset += d->signalCount;
         m = m->d.superdata;
     }
 }
@@ -2363,40 +2362,21 @@ QMetaObject::Connection QObject::connect(const QObject *sender, const char *sign
     const QMetaObject *smeta = sender->metaObject();
     const char *signal_arg = signal;
     ++signal; //skip code
-    QByteArray signalName;
     QArgumentTypeArray signalTypes;
-    int signal_index;
-    if (QMetaObjectPrivate::get(smeta)->revision >= 7) {
+    Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
+    QByteArray signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
+    int signal_index = QMetaObjectPrivate::indexOfSignalRelative(
+            &smeta, signalName, signalTypes.size(), signalTypes.constData());
+    if (signal_index < 0) {
+        // check for normalized signatures
+        tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
+        signal = tmp_signal_name.constData() + 1;
+
+        signalTypes.clear();
         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
+        smeta = sender->metaObject();
         signal_index = QMetaObjectPrivate::indexOfSignalRelative(
                 &smeta, signalName, signalTypes.size(), signalTypes.constData());
-        if (signal_index < 0) {
-            // check for normalized signatures
-            tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
-            signal = tmp_signal_name.constData() + 1;
-
-            signalTypes.clear();
-            signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
-            smeta = sender->metaObject();
-            signal_index = QMetaObjectPrivate::indexOfSignalRelative(
-                    &smeta, signalName, signalTypes.size(), signalTypes.constData());
-        }
-    } else {
-        signal_index = QMetaObjectPrivate::indexOfSignalRelative(&smeta, signal, false);
-        if (signal_index < 0) {
-            // check for normalized signatures
-            tmp_signal_name = QMetaObject::normalizedSignature(signal - 1);
-            signal = tmp_signal_name.constData() + 1;
-
-            smeta = sender->metaObject();
-            signal_index = QMetaObjectPrivate::indexOfSignalRelative(&smeta, signal, false);
-            if (signal_index < 0) {
-                // re-use tmp_signal_name and signal from above
-
-                smeta = sender->metaObject();
-                signal_index = QMetaObjectPrivate::indexOfSignalRelative(&smeta, signal, true);
-            }
-        }
     }
     if (signal_index < 0) {
         err_method_notfound(sender, signal_arg, "connect");
@@ -2421,7 +2401,26 @@ QMetaObject::Connection QObject::connect(const QObject *sender, const char *sign
     QArgumentTypeArray methodTypes;
     const QMetaObject *rmeta = receiver->metaObject();
     int method_index_relative = -1;
-    if (QMetaObjectPrivate::get(rmeta)->revision >= 7) {
+    Q_ASSERT(QMetaObjectPrivate::get(rmeta)->revision >= 7);
+    switch (membcode) {
+    case QSLOT_CODE:
+        method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
+                &rmeta, methodName, methodTypes.size(), methodTypes.constData());
+        break;
+    case QSIGNAL_CODE:
+        method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
+                &rmeta, methodName, methodTypes.size(), methodTypes.constData());
+        break;
+    }
+    if (method_index_relative < 0) {
+        // check for normalized methods
+        tmp_method_name = QMetaObject::normalizedSignature(method);
+        method = tmp_method_name.constData();
+
+        methodTypes.clear();
+        methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
+        // rmeta may have been modified above
+        rmeta = receiver->metaObject();
         switch (membcode) {
         case QSLOT_CODE:
             method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
@@ -2432,56 +2431,6 @@ QMetaObject::Connection QObject::connect(const QObject *sender, const char *sign
                     &rmeta, methodName, methodTypes.size(), methodTypes.constData());
             break;
         }
-        if (method_index_relative < 0) {
-            // check for normalized methods
-            tmp_method_name = QMetaObject::normalizedSignature(method);
-            method = tmp_method_name.constData();
-
-            methodTypes.clear();
-            methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
-            // rmeta may have been modified above
-            rmeta = receiver->metaObject();
-            switch (membcode) {
-            case QSLOT_CODE:
-                method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(
-                        &rmeta, methodName, methodTypes.size(), methodTypes.constData());
-                break;
-            case QSIGNAL_CODE:
-                method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(
-                        &rmeta, methodName, methodTypes.size(), methodTypes.constData());
-                break;
-            }
-        }
-    } else {
-        switch (membcode) {
-        case QSLOT_CODE:
-            method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(&rmeta, method, false);
-            break;
-        case QSIGNAL_CODE:
-            method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(&rmeta, method, false);
-            break;
-        }
-
-        if (method_index_relative < 0) {
-            // check for normalized methods
-            tmp_method_name = QMetaObject::normalizedSignature(method);
-            method = tmp_method_name.constData();
-
-            // rmeta may have been modified above
-            rmeta = receiver->metaObject();
-            switch (membcode) {
-            case QSLOT_CODE:
-                method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(&rmeta, method, false);
-                if (method_index_relative < 0)
-                    method_index_relative = QMetaObjectPrivate::indexOfSlotRelative(&rmeta, method, true);
-                break;
-            case QSIGNAL_CODE:
-                method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(&rmeta, method, false);
-                if (method_index_relative < 0)
-                    method_index_relative = QMetaObjectPrivate::indexOfSignalRelative(&rmeta, method, true);
-                break;
-            }
-        }
     }
 
     if (method_index_relative < 0) {
@@ -2490,18 +2439,8 @@ QMetaObject::Connection QObject::connect(const QObject *sender, const char *sign
         return QMetaObject::Connection(0);
     }
 
-    bool compatibleArgs = true;
-    if ((QMetaObjectPrivate::get(smeta)->revision < 7) && (QMetaObjectPrivate::get(rmeta)->revision < 7)) {
-        compatibleArgs = QMetaObject::checkConnectArgs(signal, method);
-    } else {
-        if (signalName.isEmpty())
-            signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
-        if (methodName.isEmpty())
-            methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
-        compatibleArgs = QMetaObjectPrivate::checkConnectArgs(signalTypes.size(), signalTypes.constData(),
-                                                              methodTypes.size(), methodTypes.constData());
-    }
-    if (!compatibleArgs) {
+    if (!QMetaObjectPrivate::checkConnectArgs(signalTypes.size(), signalTypes.constData(),
+                                              methodTypes.size(), methodTypes.constData())) {
         qWarning("QObject::connect: Incompatible sender/receiver arguments"
                  "\n        %s::%s --> %s::%s",
                  sender->metaObject()->className(), signal,
@@ -2511,9 +2450,7 @@ QMetaObject::Connection QObject::connect(const QObject *sender, const char *sign
 
     int *types = 0;
     if ((type == Qt::QueuedConnection)
-        && ((QMetaObjectPrivate::get(smeta)->revision >= 7)
-        ? !(types = queuedConnectionTypes(signalTypes.constData(), signalTypes.size()))
-            : !(types = queuedConnectionTypes(smeta->method(signal_absolute_index).parameterTypes())))) {
+            && !(types = queuedConnectionTypes(signalTypes.constData(), signalTypes.size()))) {
         return QMetaObject::Connection(0);
     }
 
@@ -2760,23 +2697,19 @@ bool QObject::disconnect(const QObject *sender, const char *signal,
     const QMetaObject *smeta = sender->metaObject();
     QByteArray signalName;
     QArgumentTypeArray signalTypes;
-    if (signal && (QMetaObjectPrivate::get(smeta)->revision >= 7))
+    Q_ASSERT(QMetaObjectPrivate::get(smeta)->revision >= 7);
+    if (signal)
         signalName = QMetaObjectPrivate::decodeMethodSignature(signal, signalTypes);
     QByteArray methodName;
     QArgumentTypeArray methodTypes;
-    if (method && (QMetaObjectPrivate::get(receiver->metaObject())->revision >= 7))
+    Q_ASSERT(!receiver || QMetaObjectPrivate::get(receiver->metaObject())->revision >= 7);
+    if (method)
         methodName = QMetaObjectPrivate::decodeMethodSignature(method, methodTypes);
     do {
         int signal_index = -1;
         if (signal) {
-            if (QMetaObjectPrivate::get(smeta)->revision >= 7) {
-                signal_index = QMetaObjectPrivate::indexOfSignalRelative(
-                            &smeta, signalName, signalTypes.size(), signalTypes.constData());
-            } else {
-                signal_index = QMetaObjectPrivate::indexOfSignalRelative(&smeta, signal, false);
-                if (signal_index < 0)
-                    signal_index = QMetaObjectPrivate::indexOfSignalRelative(&smeta, signal, true);
-            }
+            signal_index = QMetaObjectPrivate::indexOfSignalRelative(
+                        &smeta, signalName, signalTypes.size(), signalTypes.constData());
             if (signal_index < 0)
                 break;
             signal_index = QMetaObjectPrivate::originalClone(smeta, signal_index);
@@ -2791,13 +2724,8 @@ bool QObject::disconnect(const QObject *sender, const char *signal,
         } else {
             const QMetaObject *rmeta = receiver->metaObject();
             do {
-                int method_index;
-                if (QMetaObjectPrivate::get(rmeta)->revision >= 7) {
-                    method_index = QMetaObjectPrivate::indexOfMethod(
+                int method_index = QMetaObjectPrivate::indexOfMethod(
                             rmeta, methodName, methodTypes.size(), methodTypes.constData());
-                } else {
-                    method_index = rmeta->indexOfMethod(method);
-                }
                 if (method_index >= 0)
                     while (method_index < rmeta->methodOffset())
                             rmeta = rmeta->superClass();
@@ -3033,8 +2961,9 @@ QObjectPrivate::Connection *QMetaObjectPrivate::connect(const QObject *sender, i
     QObject *r = const_cast<QObject *>(receiver);
 
     int method_offset = rmeta ? rmeta->methodOffset() : 0;
+    Q_ASSERT(!rmeta || QMetaObjectPrivate::get(rmeta)->revision >= 6);
     QObjectPrivate::StaticMetaCallFunction callFunction =
-        (rmeta && QMetaObjectPrivate::get(rmeta)->revision >= 6 && rmeta->d.extradata)
+        (rmeta && rmeta->d.extradata)
         ? reinterpret_cast<const QMetaObjectExtraData *>(rmeta->d.extradata)->static_metacall : 0;
 
     QOrderedMutexLocker locker(signalSlotLock(sender),
@@ -3480,17 +3409,11 @@ int QObjectPrivate::signalIndex(const char *signalName) const
 {
     Q_Q(const QObject);
     const QMetaObject *base = q->metaObject();
-    int relative_index;
-    if (QMetaObjectPrivate::get(base)->revision >= 7) {
-        QArgumentTypeArray types;
-        QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signalName, types);
-        relative_index = QMetaObjectPrivate::indexOfSignalRelative(
-                &base, name, types.size(), types.constData());
-    } else {
-        relative_index = QMetaObjectPrivate::indexOfSignalRelative(&base, signalName, false);
-        if (relative_index < 0)
-            relative_index = QMetaObjectPrivate::indexOfSignalRelative(&base, signalName, true);
-    }
+    Q_ASSERT(QMetaObjectPrivate::get(base)->revision >= 7);
+    QArgumentTypeArray types;
+    QByteArray name = QMetaObjectPrivate::decodeMethodSignature(signalName, types);
+    int relative_index = QMetaObjectPrivate::indexOfSignalRelative(
+            &base, name, types.size(), types.constData());
     if (relative_index < 0)
         return relative_index;
     relative_index = QMetaObjectPrivate::originalClone(base, relative_index);
@@ -4218,16 +4141,9 @@ QMetaObject::Connection QObject::connectImpl(const QObject *sender, void **signa
     locker.unlock();
 
     // reconstruct the signature to call connectNotify
-    QByteArray tmp_sig;
     const char *sig;
-    if (QMetaObjectPrivate::get(senderMetaObject)->revision >= 7) {
-        tmp_sig = senderMetaObject->method(signal_index - signalOffset + methodOffset).methodSignature();
-        sig = tmp_sig.constData();
-    } else {
-        sig = reinterpret_cast<const char *>(senderMetaObject->d.stringdata)
-              + senderMetaObject->d.data[QMetaObjectPrivate::get(senderMetaObject)->methodData
-                                         + 5 * (signal_index - signalOffset)];
-    }
+    QByteArray tmp_sig = senderMetaObject->method(signal_index - signalOffset + methodOffset).methodSignature();
+    sig = tmp_sig.constData();
     QVarLengthArray<char> signalSignature(qstrlen(sig) + 2);
     signalSignature.data()[0] = char(QSIGNAL_CODE + '0');
     strcpy(signalSignature.data() + 1 , sig);
diff --git a/tests/auto/corelib/kernel/qobject/moc_oldnormalizeobject.cpp b/tests/auto/corelib/kernel/qobject/moc_oldnormalizeobject.cpp
deleted file mode 100644
index 021079a..0000000
--- a/tests/auto/corelib/kernel/qobject/moc_oldnormalizeobject.cpp
+++ /dev/null
@@ -1,154 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-/****************************************************************************
-** Meta object code from reading C++ file 'oldnormalizeobject.h'
-**
-** Created: Wed Nov 18 11:43:05 2009
-**      by: The Qt Meta Object Compiler version 62 (Qt 4.6.0)
-**
-*****************************************************************************/
-
-// Yhis file was generated from moc version 4.6 to test binary compatibility
-// It should *not* be generated by the current moc
-
-#include "oldnormalizeobject.h"
-
-QT_BEGIN_MOC_NAMESPACE
-static const uint qt_meta_data_OldNormalizeObject[] = {
-
- // content:
-       4,       // revision
-       0,       // classname
-       0,    0, // classinfo
-       6,   14, // methods
-       0,    0, // properties
-       0,    0, // enums/sets
-       0,    0, // constructors
-       0,       // flags
-       3,       // signalCount
-
- // signals: signature, parameters, type, tag, flags
-      24,   20,   19,   19, 0x05,
-      57,   20,   19,   19, 0x05,
-     100,   20,   19,   19, 0x05,
-
- // slots: signature, parameters, type, tag, flags
-     149,   20,   19,   19, 0x0a,
-     180,   20,   19,   19, 0x0a,
-     221,   20,   19,   19, 0x0a,
-
-       0        // eod
-};
-
-static const char qt_meta_stringdata_OldNormalizeObject[] = {
-    "OldNormalizeObject\0\0ref\0"
-    "typeRefSignal(Template<Class&>&)\0"
-    "constTypeRefSignal(Template<const Class&>)\0"
-    "typeConstRefSignal(Template<const Class&>const&)\0"
-    "typeRefSlot(Template<Class&>&)\0"
-    "constTypeRefSlot(Template<const Class&>)\0"
-    "typeConstRefSlot(Template<const Class&>const&)\0"
-};
-
-const QMetaObject OldNormalizeObject::staticMetaObject = {
-    { &QObject::staticMetaObject, reinterpret_cast<const QByteArrayData *>(qt_meta_stringdata_OldNormalizeObject),
-      qt_meta_data_OldNormalizeObject, 0 }
-};
-
-#ifdef Q_NO_DATA_RELOCATION
-const QMetaObject &OldNormalizeObject::getStaticMetaObject() { return staticMetaObject; }
-#endif //Q_NO_DATA_RELOCATION
-
-const QMetaObject *OldNormalizeObject::metaObject() const
-{
-    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
-}
-
-void *OldNormalizeObject::qt_metacast(const char *_clname)
-{
-    if (!_clname) return 0;
-    if (!strcmp(_clname, qt_meta_stringdata_OldNormalizeObject))
-        return static_cast<void*>(const_cast< OldNormalizeObject*>(this));
-    return QObject::qt_metacast(_clname);
-}
-
-int OldNormalizeObject::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
-{
-    _id = QObject::qt_metacall(_c, _id, _a);
-    if (_id < 0)
-        return _id;
-    if (_c == QMetaObject::InvokeMetaMethod) {
-        switch (_id) {
-        case 0: typeRefSignal((*reinterpret_cast< Template<Class&>(*)>(_a[1]))); break;
-        case 1: constTypeRefSignal((*reinterpret_cast< const Template<const Class&>(*)>(_a[1]))); break;
-        case 2: typeConstRefSignal((*reinterpret_cast< Template<const Class&>const(*)>(_a[1]))); break;
-        case 3: typeRefSlot((*reinterpret_cast< Template<Class&>(*)>(_a[1]))); break;
-        case 4: constTypeRefSlot((*reinterpret_cast< const Template<const Class&>(*)>(_a[1]))); break;
-        case 5: typeConstRefSlot((*reinterpret_cast< Template<const Class&>const(*)>(_a[1]))); break;
-        default: ;
-        }
-        _id -= 6;
-    }
-    return _id;
-}
-
-// SIGNAL 0
-void OldNormalizeObject::typeRefSignal(Template<Class&> & _t1)
-{
-    void *_a[] = { 0, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
-    QMetaObject::activate(this, &staticMetaObject, 0, _a);
-}
-
-// SIGNAL 1
-void OldNormalizeObject::constTypeRefSignal(const Template<const Class&> & _t1)
-{
-    void *_a[] = { 0, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
-    QMetaObject::activate(this, &staticMetaObject, 1, _a);
-}
-
-// SIGNAL 2
-void OldNormalizeObject::typeConstRefSignal(Template<Class const&> const & _t1)
-{
-    void *_a[] = { 0, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
-    QMetaObject::activate(this, &staticMetaObject, 2, _a);
-}
-QT_END_MOC_NAMESPACE
diff --git a/tests/auto/corelib/kernel/qobject/oldnormalizeobject.h b/tests/auto/corelib/kernel/qobject/oldnormalizeobject.h
deleted file mode 100644
index f730277..0000000
--- a/tests/auto/corelib/kernel/qobject/oldnormalizeobject.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtTest module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef OLDNORMALIZEOBJECT_H
-#define OLDNORMALIZEOBJECT_H
-
-#include <QObject>
-
-struct Struct;
-class Class;
-template <typename T> class Template;
-
-// An object with old moc output that incorrectly normalizes 'T<C> const &' in the function
-// signatures
-class OldNormalizeObject : public QObject
-{
-    /* tmake ignore Q_OBJECT */
-    Q_OBJECT
-
-signals:
-    void typeRefSignal(Template<Class &> &ref);
-    void constTypeRefSignal(const Template<const Class &> &ref);
-    void typeConstRefSignal(Template<Class const &> const &ref);
-
-public slots:
-    void typeRefSlot(Template<Class &> &) {}
-    void constTypeRefSlot(const Template<const Class &> &) {}
-    void typeConstRefSlot(Template<Class const &> const &) {}
-};
-
-#endif // OLDNORMALIZEOBJECT_H
diff --git a/tests/auto/corelib/kernel/qobject/test/test.pro b/tests/auto/corelib/kernel/qobject/test/test.pro
index 9443b2e..9daf3d7 100644
--- a/tests/auto/corelib/kernel/qobject/test/test.pro
+++ b/tests/auto/corelib/kernel/qobject/test/test.pro
@@ -3,9 +3,5 @@ TARGET = ../tst_qobject
 QT = core-private network testlib
 SOURCES = ../tst_qobject.cpp
 
-# this is here for a reason, moc_oldnormalizedobject.cpp is not auto-generated, it was generated by
-# moc from Qt 4.6, and should *not* be generated by the current moc
-SOURCES += ../moc_oldnormalizeobject.cpp
-
 load(testcase) # for target.path and installTestHelperApp()
 installTestHelperApp("signalbug/signalbug",signalbug,signalbug)
diff --git a/tests/auto/corelib/kernel/qobject/tst_qobject.cpp b/tests/auto/corelib/kernel/qobject/tst_qobject.cpp
index fa6cf92..90d2084 100644
--- a/tests/auto/corelib/kernel/qobject/tst_qobject.cpp
+++ b/tests/auto/corelib/kernel/qobject/tst_qobject.cpp
@@ -2315,8 +2315,6 @@ public slots:
     void constTemplateSlot3(const Template< const int >) {}
 };
 
-#include "oldnormalizeobject.h"
-
 void tst_QObject::normalize()
 {
     NormalizeObject object;
@@ -2627,82 +2625,6 @@ void tst_QObject::normalize()
                            SIGNAL(typeConstRefSignal(Template<Class const &> const &)),
                            SLOT(typeConstRefSlot(Template<Class const &> const &))));
 
-    // same test again, this time with an object compiled with old moc output... we know that
-    // it is not possible to connect everything, whic is the purpose for this test
-    OldNormalizeObject oldobject;
-
-    QVERIFY(oldobject.connect(&oldobject,
-                              SIGNAL(constTypeRefSignal(const Template<const Class &> &)),
-                              SLOT(constTypeRefSlot(const Template<const Class &> &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                              SIGNAL(constTypeRefSignal(const Template<const Class &> &)),
-                              SLOT(constTypeRefSlot(const Template<Class const &> &))));
-    // this fails in older versions, but passes now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(const Template<const Class &> &)),
-                               SLOT(constTypeRefSlot(Template<Class const &> const &))));
-    // this fails in older versions, but passes now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(Template<const Class &> const &)),
-                               SLOT(constTypeRefSlot(Template<Class const &> const &))));
-    // this fails in older versions, but passes now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(Template<Class const &> const &)),
-                               SLOT(constTypeRefSlot(Template<Class const &> const &))));
-
-    // these fail in older Qt versions, but pass now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(const Template<const Class &> &)),
-                               SLOT(typeConstRefSlot(const Template<const Class &> &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(const Template<const Class &> &)),
-                               SLOT(typeConstRefSlot(const Template<Class const &> &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(const Template<const Class &> &)),
-                               SLOT(typeConstRefSlot(Template<Class const &> const &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(Template<const Class &> const &)),
-                               SLOT(typeConstRefSlot(Template<Class const &> const &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(constTypeRefSignal(Template<Class const &> const &)),
-                               SLOT(typeConstRefSlot(Template<Class const &> const &))));
-
-    // these also fail in older Qt versions, but pass now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(const Template<const Class &> &)),
-                               SLOT(constTypeRefSlot(const Template<const Class &> &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(const Template<const Class &> &)),
-                               SLOT(constTypeRefSlot(const Template<Class const &> &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(const Template<const Class &> &)),
-                               SLOT(constTypeRefSlot(Template<Class const &> const &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(Template<const Class &> const &)),
-                               SLOT(constTypeRefSlot(Template<Class const &> const &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(Template<Class const &> const &)),
-                               SLOT(constTypeRefSlot(Template<Class const &> const &))));
-
-    // this fails in older versions, but passes now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(const Template<const Class &> &)),
-                               SLOT(typeConstRefSlot(const Template<const Class &> &))));
-    // this fails in older versions, but passes now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(const Template<const Class &> &)),
-                               SLOT(typeConstRefSlot(const Template<Class const &> &))));
-    // this fails in older versions, but passes now due to proper normalizing
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(const Template<const Class &> &)),
-                               SLOT(typeConstRefSlot(Template<Class const &> const &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(Template<const Class &> const &)),
-                               SLOT(typeConstRefSlot(Template<Class const &> const &))));
-    QVERIFY(oldobject.connect(&oldobject,
-                               SIGNAL(typeConstRefSignal(Template<Class const &> const &)),
-                               SLOT(typeConstRefSlot(Template<Class const &> const &))));
-
     QVERIFY(object.connect(&object,
                            SIGNAL(typePointerConstRefSignal(Class*const&)),
                            SLOT(typePointerConstRefSlot(Class*const&))));