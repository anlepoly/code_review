diff --git a/src/qml/qml/v4/qv4bindings.cpp b/src/qml/qml/v4/qv4bindings.cpp
index 25fbbd4..3084f92 100644
--- a/src/qml/qml/v4/qv4bindings.cpp
+++ b/src/qml/qml/v4/qv4bindings.cpp
@@ -68,15 +68,15 @@ struct Register {
 
     void setUndefined() { dataType = UndefinedType; }
     void setNull() { dataType = NullType; }
-    void setNaN() { setqreal(qSNaN()); }
+    void setNaN() { setnumber(qSNaN()); }
     bool isUndefined() const { return dataType == UndefinedType; }
 
     void setQObject(QObject *o) { qobjectValue = o; dataType = QObjectStarType; }
     QObject *getQObject() const { return qobjectValue; }
 
-    void setqreal(qreal v) { qrealValue = v; dataType = QRealType; }
-    qreal getqreal() const { return qrealValue; }
-    qreal &getqrealref() { return qrealValue; }
+    void setnumber(double v) { numberValue = v; dataType = NumberType; }
+    double getnumber() const { return numberValue; }
+    double &getnumberref() { return numberValue; }
 
     void setint(int v) { intValue = v; dataType = IntType; }
     int getint() const { return intValue; }
@@ -106,7 +106,7 @@ struct Register {
     Type dataType;     // Type of data
     union {
         QObject *qobjectValue;
-        qreal qrealValue;
+        double numberValue;
         int intValue;
         bool boolValue;
         void *data[sizeof(QVariant)];
@@ -388,85 +388,6 @@ void QV4Bindings::subscribe(QObject *o, int notifyIndex, int subIndex)
         sub->disconnect();
 }
 
-// Conversion functions - these MUST match the QtScript expression path
-inline static qreal toReal(Register *reg, int type, bool *ok = 0)
-{
-    if (ok) *ok = true;
-
-    if (type == QMetaType::QReal) {
-        return reg->getqreal();
-    } else if (type == qMetaTypeId<QVariant>()) {
-        return reg->getvariantptr()->toReal();
-    } else {
-        if (ok) *ok = false;
-        return 0;
-    }
-}
-
-inline static QString toString(Register *reg, int type, bool *ok = 0)
-{
-    if (ok) *ok = true;
-
-    if (type == QMetaType::QReal) {
-        return QString::number(reg->getqreal());
-    } else if (type == QMetaType::Int) {
-        return QString::number(reg->getint());
-    } else if (type == qMetaTypeId<QVariant>()) {
-        return reg->getvariantptr()->toString();
-    } else if (type == QMetaType::QString) {
-        return *reg->getstringptr();
-    } else {
-        if (ok) *ok = false;
-        return QString();
-    }
-}
-
-inline static bool toBool(Register *reg, int type, bool *ok = 0)
-{
-    if (ok) *ok = true;
-
-    if (type == QMetaType::Bool) {
-        return reg->getbool();
-    } else if (type == qMetaTypeId<QVariant>()) {
-        return reg->getvariantptr()->toBool();
-    } else {
-        if (ok) *ok = false;
-        return false;
-    }
-}
-
-inline static QUrl toUrl(Register *reg, int type, QQmlContextData *context, bool *ok = 0)
-{
-    if (ok) *ok = true;
-
-    QUrl base;
-    if (type == qMetaTypeId<QVariant>()) {
-        QVariant *var = reg->getvariantptr();
-        int vt = var->type();
-        if (vt == QVariant::Url) {
-            base = var->toUrl();
-        } else if (vt == QVariant::ByteArray) {
-            // Preserve any valid percent-encoded octets supplied by the source
-            base.setEncodedUrl(var->toByteArray(), QUrl::TolerantMode);
-        } else if (vt == QVariant::String) {
-            base.setEncodedUrl(var->toString().toUtf8(), QUrl::TolerantMode);
-        } else {
-            if (ok) *ok = false;
-            return QUrl();
-        }
-    } else if (type == QMetaType::QString) {
-        base.setEncodedUrl(reg->getstringptr()->toUtf8(), QUrl::TolerantMode);
-    } else {
-        if (ok) *ok = false;
-        return QUrl();
-    }
-
-    if (!base.isEmpty() && base.isRelative())
-        return context->url.resolved(base);
-    else
-        return base;
-}
-
 static bool testCompareVariants(const QVariant &qtscriptRaw, const QVariant &v4)
 {
     QVariant qtscript = qtscriptRaw;
@@ -558,8 +479,8 @@ static void testBindingResult(const QString &binding, int line, int column,
         case QMetaType::Int:
             v4value = result.getint();
             break;
-        case QMetaType::QReal:
-            v4value = result.getqreal();
+        case QMetaType::Double:
+            v4value = result.getnumber();
             break;
         default:
             if (resultType == QQmlMetaType::QQuickAnchorLineMetaTypeId()) {
@@ -622,15 +543,15 @@ static void throwException(int id, QQmlDelayedError *error,
         QQmlEnginePrivate::warning(context->engine, error->error);
 }
 
-const qreal QV4Bindings::D32 = 4294967296.0;
+const double QV4Bindings::D32 = 4294967296.0;
 
-qint32 QV4Bindings::toInt32(qreal n)
+qint32 QV4Bindings::toInt32(double n)
 {
     if (qIsNaN(n) || qIsInf(n) || (n == 0))
         return 0;
 
     double sign = (n < 0) ? -1.0 : 1.0;
-    qreal abs_n = fabs(n);
+    double abs_n = fabs(n);
 
     n = ::fmod(sign * ::floor(abs_n), D32);
     const double D31 = D32 / 2.0;
@@ -644,13 +565,13 @@ qint32 QV4Bindings::toInt32(qreal n)
     return qint32 (n);
 }
 
-inline quint32 QV4Bindings::toUint32(qreal n)
+inline quint32 QV4Bindings::toUint32(double n)
 {
     if (qIsNaN(n) || qIsInf(n) || (n == 0))
         return 0;
 
     double sign = (n < 0) ? -1.0 : 1.0;
-    qreal abs_n = fabs(n);
+    double abs_n = fabs(n);
 
     n = ::fmod(sign * ::floor(abs_n), D32);
 
@@ -869,11 +790,11 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(UnaryNot, unaryop)
 
-    QML_V4_BEGIN_INSTR(UnaryMinusReal, unaryop)
+    QML_V4_BEGIN_INSTR(UnaryMinusNumber, unaryop)
     {
-        registers[instr->unaryop.output].setqreal(-registers[instr->unaryop.src].getqreal());
+        registers[instr->unaryop.output].setnumber(-registers[instr->unaryop.src].getnumber());
     }
-    QML_V4_END_INSTR(UnaryMinusReal, unaryop)
+    QML_V4_END_INSTR(UnaryMinusNumber, unaryop)
 
     QML_V4_BEGIN_INSTR(UnaryMinusInt, unaryop)
     {
@@ -881,11 +802,11 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(UnaryMinusInt, unaryop)
 
-    QML_V4_BEGIN_INSTR(UnaryPlusReal, unaryop)
+    QML_V4_BEGIN_INSTR(UnaryPlusNumber, unaryop)
     {
-        registers[instr->unaryop.output].setqreal(+registers[instr->unaryop.src].getqreal());
+        registers[instr->unaryop.output].setnumber(+registers[instr->unaryop.src].getnumber());
     }
-    QML_V4_END_INSTR(UnaryPlusReal, unaryop)
+    QML_V4_END_INSTR(UnaryPlusNumber, unaryop)
 
     QML_V4_BEGIN_INSTR(UnaryPlusInt, unaryop)
     {
@@ -902,14 +823,14 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(ConvertBoolToInt, unaryop)
 
-    QML_V4_BEGIN_INSTR(ConvertBoolToReal, unaryop)
+    QML_V4_BEGIN_INSTR(ConvertBoolToNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setqreal(src.getbool());
+        else output.setnumber(src.getbool());
     }
-    QML_V4_END_INSTR(ConvertBoolToReal, unaryop)
+    QML_V4_END_INSTR(ConvertBoolToNumber, unaryop)
 
     QML_V4_BEGIN_INSTR(ConvertBoolToString, unaryop)
     {
@@ -933,14 +854,14 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(ConvertIntToBool, unaryop)
 
-    QML_V4_BEGIN_INSTR(ConvertIntToReal, unaryop)
+    QML_V4_BEGIN_INSTR(ConvertIntToNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setqreal(qreal(src.getint()));
+        else output.setnumber(double(src.getint()));
     }
-    QML_V4_END_INSTR(ConvertIntToReal, unaryop)
+    QML_V4_END_INSTR(ConvertIntToNumber, unaryop)
 
     QML_V4_BEGIN_INSTR(ConvertIntToString, unaryop)
     {
@@ -955,25 +876,25 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(ConvertIntToString, unaryop)
 
-    QML_V4_BEGIN_INSTR(ConvertRealToBool, unaryop)
+    QML_V4_BEGIN_INSTR(ConvertNumberToBool, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setbool(src.getqreal() != 0);
+        else output.setbool(src.getnumber() != 0);
     }
-    QML_V4_END_INSTR(ConvertRealToBool, unaryop)
+    QML_V4_END_INSTR(ConvertNumberToBool, unaryop)
 
-    QML_V4_BEGIN_INSTR(ConvertRealToInt, unaryop)
+    QML_V4_BEGIN_INSTR(ConvertNumberToInt, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setint(toInt32(src.getqreal()));
+        else output.setint(toInt32(src.getnumber()));
     }
-    QML_V4_END_INSTR(ConvertRealToInt, unaryop)
+    QML_V4_END_INSTR(ConvertNumberToInt, unaryop)
 
-    QML_V4_BEGIN_INSTR(ConvertRealToString, unaryop)
+    QML_V4_BEGIN_INSTR(ConvertNumberToString, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
@@ -981,11 +902,11 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
         if (src.isUndefined()) {
             output.setUndefined();
         } else {
-            new (output.getstringptr()) QString(QString::number(src.getqreal()));
+            new (output.getstringptr()) QString(QString::number(src.getnumber()));
             STRING_REGISTER(instr->unaryop.output);
         }
     }
-    QML_V4_END_INSTR(ConvertRealToString, unaryop)
+    QML_V4_END_INSTR(ConvertNumberToString, unaryop)
 
     QML_V4_BEGIN_INSTR(ConvertStringToBool, unaryop)
     {
@@ -1027,7 +948,7 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(ConvertStringToInt, unaryop)
 
-    QML_V4_BEGIN_INSTR(ConvertStringToReal, unaryop)
+    QML_V4_BEGIN_INSTR(ConvertStringToNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
@@ -1042,10 +963,10 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
                 output.cleanupString();
                 MARK_CLEAN_REGISTER(instr->unaryop.output);
             }
-            output.setqreal(tmp.toNumber());
+            output.setnumber(tmp.toNumber());
         }
     }
-    QML_V4_END_INSTR(ConvertStringToReal, unaryop)
+    QML_V4_END_INSTR(ConvertStringToNumber, unaryop)
 
     QML_V4_BEGIN_INSTR(ConvertStringToUrl, unaryop)
     {
@@ -1198,75 +1119,75 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(ResolveUrl, unaryop)
 
-    QML_V4_BEGIN_INSTR(MathSinReal, unaryop)
+    QML_V4_BEGIN_INSTR(MathSinNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setqreal(qSin(src.getqreal()));
+        else output.setnumber(qSin(src.getnumber()));
     }
-    QML_V4_END_INSTR(MathSinReal, unaryop)
+    QML_V4_END_INSTR(MathSinNumber, unaryop)
 
-    QML_V4_BEGIN_INSTR(MathCosReal, unaryop)
+    QML_V4_BEGIN_INSTR(MathCosNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setqreal(qCos(src.getqreal()));
+        else output.setnumber(qCos(src.getnumber()));
     }
-    QML_V4_END_INSTR(MathCosReal, unaryop)
+    QML_V4_END_INSTR(MathCosNumber, unaryop)
 
-    QML_V4_BEGIN_INSTR(MathAbsReal, unaryop)
+    QML_V4_BEGIN_INSTR(MathAbsNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setqreal(qAbs(src.getqreal()));
+        else output.setnumber(qAbs(src.getnumber()));
     }
-    QML_V4_END_INSTR(MathAbsReal, unaryop)
+    QML_V4_END_INSTR(MathAbsNumber, unaryop)
 
-    QML_V4_BEGIN_INSTR(MathRoundReal, unaryop)
+    QML_V4_BEGIN_INSTR(MathRoundNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setint(qRound(src.getqreal()));
+        else output.setint(qRound(src.getnumber()));
     }
-    QML_V4_END_INSTR(MathRoundReal, unaryop)
+    QML_V4_END_INSTR(MathRoundNumber, unaryop)
 
-    QML_V4_BEGIN_INSTR(MathFloorReal, unaryop)
+    QML_V4_BEGIN_INSTR(MathFloorNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setint(qFloor(src.getqreal()));
+        else output.setint(qFloor(src.getnumber()));
     }
-    QML_V4_END_INSTR(MathFloorReal, unaryop)
+    QML_V4_END_INSTR(MathFloorNumber, unaryop)
 
-    QML_V4_BEGIN_INSTR(MathCeilReal, unaryop)
+    QML_V4_BEGIN_INSTR(MathCeilNumber, unaryop)
     {
         const Register &src = registers[instr->unaryop.src];
         Register &output = registers[instr->unaryop.output];
         if (src.isUndefined()) output.setUndefined();
-        else output.setint(qCeil(src.getqreal()));
+        else output.setint(qCeil(src.getnumber()));
     }
-    QML_V4_END_INSTR(MathCeilReal, unaryop)
+    QML_V4_END_INSTR(MathCeilNumber, unaryop)
 
-    QML_V4_BEGIN_INSTR(MathPIReal, unaryop)
+    QML_V4_BEGIN_INSTR(MathPINumber, unaryop)
     {
-        static const qreal qmlPI = 2.0 * qAsin(1.0);
+        static const double qmlPI = 2.0 * qAsin(1.0);
         Register &output = registers[instr->unaryop.output];
-        output.setqreal(qmlPI);
+        output.setnumber(qmlPI);
     }
-    QML_V4_END_INSTR(MathPIReal, unaryop)
+    QML_V4_END_INSTR(MathPINumber, unaryop)
 
     QML_V4_BEGIN_INSTR(LoadNull, null_value)
         registers[instr->null_value.reg].setNull();
     QML_V4_END_INSTR(LoadNull, null_value)
 
-    QML_V4_BEGIN_INSTR(LoadReal, real_value)
-        registers[instr->real_value.reg].setqreal(instr->real_value.value);
-    QML_V4_END_INSTR(LoadReal, real_value)
+    QML_V4_BEGIN_INSTR(LoadNumber, number_value)
+        registers[instr->number_value.reg].setnumber(instr->number_value.value);
+    QML_V4_END_INSTR(LoadNumber, number_value)
 
     QML_V4_BEGIN_INSTR(LoadInt, int_value)
         registers[instr->int_value.reg].setint(instr->int_value.value);
@@ -1313,12 +1234,12 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(BitXorInt, binaryop)
 
-    QML_V4_BEGIN_INSTR(AddReal, binaryop)
+    QML_V4_BEGIN_INSTR(AddNumber, binaryop)
     {
-        registers[instr->binaryop.output].setqreal(registers[instr->binaryop.left].getqreal() + 
-                                                   registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setnumber(registers[instr->binaryop.left].getnumber() +
+                                                   registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(AddReal, binaryop)
+    QML_V4_END_INSTR(AddNumber, binaryop)
 
     QML_V4_BEGIN_INSTR(AddString, binaryop)
     {
@@ -1332,36 +1253,33 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(AddString, binaryop)
 
-    QML_V4_BEGIN_INSTR(SubReal, binaryop)
+    QML_V4_BEGIN_INSTR(SubNumber, binaryop)
     {
-        registers[instr->binaryop.output].setqreal(registers[instr->binaryop.left].getqreal() - 
-                                                   registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setnumber(registers[instr->binaryop.left].getnumber() -
+                                                   registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(SubReal, binaryop)
+    QML_V4_END_INSTR(SubNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(MulReal, binaryop)
+    QML_V4_BEGIN_INSTR(MulNumber, binaryop)
     {
-        registers[instr->binaryop.output].setqreal(registers[instr->binaryop.left].getqreal() * 
-                                                   registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setnumber(registers[instr->binaryop.left].getnumber() *
+                                                   registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(MulReal, binaryop)
+    QML_V4_END_INSTR(MulNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(DivReal, binaryop)
+    QML_V4_BEGIN_INSTR(DivNumber, binaryop)
     {
-        registers[instr->binaryop.output].setqreal(registers[instr->binaryop.left].getqreal() / 
-                                                   registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setnumber(registers[instr->binaryop.left].getnumber() /
+                                                   registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(DivReal, binaryop)
+    QML_V4_END_INSTR(DivNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(ModReal, binaryop)
+    QML_V4_BEGIN_INSTR(ModNumber, binaryop)
     {
         Register &target = registers[instr->binaryop.output];
         const Register &left = registers[instr->binaryop.left];
         const Register &right = registers[instr->binaryop.right];
-        if (QMetaType::QReal == QMetaType::Float)
-            target.setqreal(::fmodf(left.getqreal(), right.getqreal()));
-        else
-            target.setqreal(::fmod(left.getqreal(), right.getqreal()));
+        target.setnumber(::fmod(left.getnumber(), right.getnumber()));
     }
     QML_V4_END_INSTR(ModInt, binaryop)
 
@@ -1386,61 +1304,61 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(URShiftInt, binaryop)
 
-    QML_V4_BEGIN_INSTR(GtReal, binaryop)
+    QML_V4_BEGIN_INSTR(GtNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() > 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() >
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(GtReal, binaryop)
+    QML_V4_END_INSTR(GtNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(LtReal, binaryop)
+    QML_V4_BEGIN_INSTR(LtNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() < 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() <
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(LtReal, binaryop)
+    QML_V4_END_INSTR(LtNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(GeReal, binaryop)
+    QML_V4_BEGIN_INSTR(GeNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() >= 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() >=
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(GeReal, binaryop)
+    QML_V4_END_INSTR(GeNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(LeReal, binaryop)
+    QML_V4_BEGIN_INSTR(LeNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() <= 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() <=
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(LeReal, binaryop)
+    QML_V4_END_INSTR(LeNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(EqualReal, binaryop)
+    QML_V4_BEGIN_INSTR(EqualNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() == 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() ==
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(EqualReal, binaryop)
+    QML_V4_END_INSTR(EqualNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(NotEqualReal, binaryop)
+    QML_V4_BEGIN_INSTR(NotEqualNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() != 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() !=
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(NotEqualReal, binaryop)
+    QML_V4_END_INSTR(NotEqualNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(StrictEqualReal, binaryop)
+    QML_V4_BEGIN_INSTR(StrictEqualNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() == 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() ==
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(StrictEqualReal, binaryop)
+    QML_V4_END_INSTR(StrictEqualNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(StrictNotEqualReal, binaryop)
+    QML_V4_BEGIN_INSTR(StrictNotEqualNumber, binaryop)
     {
-        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getqreal() != 
-                                                  registers[instr->binaryop.right].getqreal());
+        registers[instr->binaryop.output].setbool(registers[instr->binaryop.left].getnumber() !=
+                                                  registers[instr->binaryop.right].getnumber());
     }
-    QML_V4_END_INSTR(StrictNotEqualReal, binaryop)
+    QML_V4_END_INSTR(StrictNotEqualNumber, binaryop)
 
     QML_V4_BEGIN_INSTR(GtString, binaryop)
     {
@@ -1586,25 +1504,25 @@ void QV4Bindings::run(int instrIndex, quint32 &executedBlocks,
     }
     QML_V4_END_INSTR(StrictNotEqualObject, binaryop)
 
-    QML_V4_BEGIN_INSTR(MathMaxReal, binaryop)
+    QML_V4_BEGIN_INSTR(MathMaxNumber, binaryop)
     {
         const Register &left = registers[instr->binaryop.left];
         const Register &right = registers[instr->binaryop.right];
         Register &output = registers[instr->binaryop.output];
         if (left.isUndefined() || right.isUndefined()) output.setUndefined();
-        else output.setqreal(qMax(left.getqreal(), right.getqreal()));
+        else output.setnumber(qMax(left.getnumber(), right.getnumber()));
     }
-    QML_V4_END_INSTR(MathMaxReal, binaryop)
+    QML_V4_END_INSTR(MathMaxNumber, binaryop)
 
-    QML_V4_BEGIN_INSTR(MathMinReal, binaryop)
+    QML_V4_BEGIN_INSTR(MathMinNumber, binaryop)
     {
         const Register &left = registers[instr->binaryop.left];
         const Register &right = registers[instr->binaryop.right];
         Register &output = registers[instr->binaryop.output];
         if (left.isUndefined() || right.isUndefined()) output.setUndefined();
-        else output.setqreal(qMin(left.getqreal(), right.getqreal()));
+        else output.setnumber(qMin(left.getnumber(), right.getnumber()));
     }
-    QML_V4_END_INSTR(MathMinReal, binaryop)
+    QML_V4_END_INSTR(MathMinNumber, binaryop)
 
     QML_V4_BEGIN_INSTR(NewString, construct)
     {
diff --git a/src/qml/qml/v4/qv4bindings_p.h b/src/qml/qml/v4/qv4bindings_p.h
index 1824fa4..3a7d175 100644
--- a/src/qml/qml/v4/qv4bindings_p.h
+++ b/src/qml/qml/v4/qv4bindings_p.h
@@ -141,9 +141,9 @@ private:
     inline void subscribeId(QQmlContextData *p, int idIndex, int subIndex);
     inline void subscribe(QObject *o, int notifyIndex, int subIndex);
 
-    inline static qint32 toInt32(qreal n);
-    static const qreal D32;
-    static quint32 toUint32(qreal n);
+    inline static qint32 toInt32(double n);
+    static const double D32;
+    static quint32 toUint32(double n);
 
 };
 
diff --git a/src/qml/qml/v4/qv4compiler.cpp b/src/qml/qml/v4/qv4compiler.cpp
index ba7c2ed..f046a56 100644
--- a/src/qml/qml/v4/qv4compiler.cpp
+++ b/src/qml/qml/v4/qv4compiler.cpp
@@ -226,8 +226,8 @@ void QV4CompilerPrivate::visitConst(IR::Const *e)
         gen(i);
         } break;
 
-    case IR::RealType: {
-        Instr::LoadReal i;
+    case IR::NumberType: {
+        Instr::LoadNumber i;
         i.reg = currentReg;
         i.value = e->value;
         gen(i);
@@ -351,8 +351,8 @@ void QV4CompilerPrivate::visitName(IR::Name *e)
         QQmlRegisterType regType;
 
         switch (propTy) {
-        case QMetaType::QReal:
-            regType = QRealType;
+        case QMetaType::Double:
+            regType = NumberType;
             break;
         case QMetaType::Bool:
             regType = BoolType;
@@ -458,14 +458,14 @@ void QV4CompilerPrivate::visitUnop(IR::Unop *e)
         } break;
 
     case IR::OpUMinus:
-        if (e->expr->type == IR::RealType) {
-            Instr::UnaryMinusReal i;
+        if (e->expr->type == IR::NumberType) {
+            Instr::UnaryMinusNumber i;
             i.output = currentReg;
             i.src = src;
             gen(i);
         } else if (e->expr->type == IR::IntType) {
-            convertToReal(e->expr, currentReg);
-            Instr::UnaryMinusReal i;
+            convertToNumber(e->expr, currentReg);
+            Instr::UnaryMinusNumber i;
             i.output = currentReg;
             i.src = src;
             gen(i);
@@ -475,14 +475,14 @@ void QV4CompilerPrivate::visitUnop(IR::Unop *e)
         break;
 
     case IR::OpUPlus:
-        if (e->expr->type == IR::RealType) {
-            Instr::UnaryPlusReal i;
+        if (e->expr->type == IR::NumberType) {
+            Instr::UnaryPlusNumber i;
             i.output = currentReg;
             i.src = src;
             gen(i);
         } else if (e->expr->type == IR::IntType) {
-            convertToReal(e->expr, currentReg);
-            Instr::UnaryPlusReal i;
+            convertToNumber(e->expr, currentReg);
+            Instr::UnaryPlusNumber i;
             i.output = currentReg;
             i.src = src;
             gen(i);
@@ -522,25 +522,25 @@ void QV4CompilerPrivate::visitUnop(IR::Unop *e)
     } // switch
 }
 
-void QV4CompilerPrivate::convertToReal(IR::Expr *expr, int reg)
+void QV4CompilerPrivate::convertToNumber(IR::Expr *expr, int reg)
 {
-    if (expr->type == IR::RealType)
+    if (expr->type == IR::NumberType)
         return;
 
     switch (expr->type) {
     case IR::BoolType: {
-        Instr::ConvertBoolToReal i;
+        Instr::ConvertBoolToNumber i;
         i.output = i.src = reg;
         gen(i);
         } break;
 
     case IR::IntType: {
-        Instr::ConvertIntToReal i;
+        Instr::ConvertIntToNumber i;
         i.output = i.src = reg;
         gen(i);
         } break;
 
-    case IR::RealType:
+    case IR::NumberType:
         // nothing to do
         return;
 
@@ -566,8 +566,8 @@ void QV4CompilerPrivate::convertToInt(IR::Expr *expr, int reg)
         // nothing to do
         return;
 
-    case IR::RealType: {
-        Instr::ConvertRealToInt i;
+    case IR::NumberType: {
+        Instr::ConvertNumberToInt i;
         i.output = i.src = reg;
         gen(i);
         } break;
@@ -594,8 +594,8 @@ void QV4CompilerPrivate::convertToBool(IR::Expr *expr, int reg)
         gen(i);
         } break;
 
-    case IR::RealType: {
-        Instr::ConvertRealToBool i;
+    case IR::NumberType: {
+        Instr::ConvertNumberToBool i;
         i.output = i.src = reg;
         gen(i);
         } return;
@@ -643,19 +643,19 @@ quint8 QV4CompilerPrivate::instructionOpcode(IR::Binop *e)
     case IR::OpAdd:
         if (e->type == IR::StringType)
             return V4Instr::AddString;
-        return V4Instr::AddReal;
+        return V4Instr::AddNumber;
 
     case IR::OpSub:
-        return V4Instr::SubReal;
+        return V4Instr::SubNumber;
 
     case IR::OpMul:
-        return V4Instr::MulReal;
+        return V4Instr::MulNumber;
 
     case IR::OpDiv:
-        return V4Instr::DivReal;
+        return V4Instr::DivNumber;
 
     case IR::OpMod:
-        return V4Instr::ModReal;
+        return V4Instr::ModNumber;
 
     case IR::OpLShift:
         return V4Instr::LShiftInt;
@@ -669,50 +669,50 @@ quint8 QV4CompilerPrivate::instructionOpcode(IR::Binop *e)
     case IR::OpGt:
         if (e->left->type == IR::StringType)
             return V4Instr::GtString;
-        return V4Instr::GtReal;
+        return V4Instr::GtNumber;
 
     case IR::OpLt:
         if (e->left->type == IR::StringType)
             return V4Instr::LtString;
-        return V4Instr::LtReal;
+        return V4Instr::LtNumber;
 
     case IR::OpGe:
         if (e->left->type == IR::StringType)
             return V4Instr::GeString;
-        return V4Instr::GeReal;
+        return V4Instr::GeNumber;
 
     case IR::OpLe:
         if (e->left->type == IR::StringType)
             return V4Instr::LeString;
-        return V4Instr::LeReal;
+        return V4Instr::LeNumber;
 
     case IR::OpEqual:
         if (e->left->type == IR::ObjectType || e->right->type == IR::ObjectType)
             return V4Instr::EqualObject;
         if (e->left->type == IR::StringType)
             return V4Instr::EqualString;
-        return V4Instr::EqualReal;
+        return V4Instr::EqualNumber;
 
     case IR::OpNotEqual:
         if (e->left->type == IR::ObjectType || e->right->type == IR::ObjectType)
             return V4Instr::NotEqualObject;
         if (e->left->type == IR::StringType)
             return V4Instr::NotEqualString;
-        return V4Instr::NotEqualReal;
+        return V4Instr::NotEqualNumber;
 
     case IR::OpStrictEqual:
         if (e->left->type == IR::ObjectType || e->right->type == IR::ObjectType)
             return V4Instr::StrictEqualObject;
         if (e->left->type == IR::StringType)
             return V4Instr::StrictEqualString;
-        return V4Instr::StrictEqualReal;
+        return V4Instr::StrictEqualNumber;
 
     case IR::OpStrictNotEqual:
         if (e->left->type == IR::ObjectType || e->right->type == IR::ObjectType)
             return V4Instr::StrictNotEqualObject;
         if (e->left->type == IR::StringType)
             return V4Instr::StrictNotEqualString;
-        return V4Instr::StrictNotEqualReal;
+        return V4Instr::StrictNotEqualNumber;
 
     case IR::OpAnd:
     case IR::OpOr:
@@ -766,8 +766,8 @@ void QV4CompilerPrivate::visitBinop(IR::Binop *e)
 
     case IR::OpAdd:
         if (e->type != IR::StringType) {
-            convertToReal(e->left, left);
-            convertToReal(e->right, right);
+            convertToNumber(e->left, left);
+            convertToNumber(e->right, right);
         }
         break;
 
@@ -775,8 +775,8 @@ void QV4CompilerPrivate::visitBinop(IR::Binop *e)
     case IR::OpMul:
     case IR::OpDiv:
     case IR::OpMod:
-        convertToReal(e->left, left);
-        convertToReal(e->right, right);
+        convertToNumber(e->left, left);
+        convertToNumber(e->right, right);
         break;
 
     case IR::OpGt:
@@ -788,8 +788,8 @@ void QV4CompilerPrivate::visitBinop(IR::Binop *e)
     case IR::OpStrictEqual:
     case IR::OpStrictNotEqual:
         if (e->left->type >= IR::FirstNumberType) {
-            convertToReal(e->left, left);
-            convertToReal(e->right, right);
+            convertToNumber(e->left, left);
+            convertToNumber(e->right, right);
         }
         break;
 
@@ -813,7 +813,7 @@ void QV4CompilerPrivate::visitCall(IR::Call *call)
 {
     if (IR::Name *name = call->base->asName()) {
         IR::Expr *arg = call->onlyArgument();
-        if (arg != 0 && arg->type == IR::RealType) {
+        if (arg != 0 && arg->type == IR::NumberType) {
             traceExpression(arg, currentReg);
 
             switch (name->builtin) {
@@ -821,37 +821,37 @@ void QV4CompilerPrivate::visitCall(IR::Call *call)
                 break;
 
             case IR::MathSinBultinFunction: {
-                Instr::MathSinReal i;
+                Instr::MathSinNumber i;
                 i.output = i.src = currentReg;
                 gen(i);
                 } return;
 
             case IR::MathCosBultinFunction: {
-                Instr::MathCosReal i;
+                Instr::MathCosNumber i;
                 i.output = i.src = currentReg;
                 gen(i);
                 } return;
 
             case IR::MathAbsBuiltinFunction: {
-                Instr::MathAbsReal i;
+                Instr::MathAbsNumber i;
                 i.output = i.src = currentReg;
                 gen(i);
                 } return;
 
             case IR::MathRoundBultinFunction: {
-                Instr::MathRoundReal i;
+                Instr::MathRoundNumber i;
                 i.output = i.src = currentReg;
                 gen(i);
                 } return;
 
             case IR::MathFloorBultinFunction: {
-                Instr::MathFloorReal i;
+                Instr::MathFloorNumber i;
                 i.output = i.src = currentReg;
                 gen(i);
                 } return;
 
             case IR::MathCeilBuiltinFunction: {
-                Instr::MathCeilReal i;
+                Instr::MathCeilNumber i;
                 i.output = i.src = currentReg;
                 gen(i);
                 } return;
@@ -869,21 +869,21 @@ void QV4CompilerPrivate::visitCall(IR::Call *call)
                     IR::Expr *arg1 = call->args->expr;
                     IR::Expr *arg2 = call->args->next->expr;
 
-                    if (arg1 != 0 && arg1->type == IR::RealType &&
-                        arg2 != 0 && arg2->type == IR::RealType) {
+                    if (arg1 != 0 && arg1->type == IR::NumberType &&
+                        arg2 != 0 && arg2->type == IR::NumberType) {
 
                         traceExpression(arg1, currentReg);
                         traceExpression(arg2, currentReg + 1);
 
                         if (name->builtin == IR::MathMaxBuiltinFunction) {
-                            Instr::MathMaxReal i;
+                            Instr::MathMaxNumber i;
                             i.left = currentReg;
                             i.right = currentReg + 1;
                             i.output = currentReg;
                             gen(i);
                             return;
                         } else if (name->builtin == IR::MathMinBuiltinFunction) {
-                            Instr::MathMinReal i;
+                            Instr::MathMinNumber i;
                             i.left = currentReg;
                             i.right = currentReg + 1;
                             i.output = currentReg;
@@ -952,7 +952,7 @@ void QV4CompilerPrivate::visitMove(IR::Move *s)
         if (targetTy == IR::BoolType) {
             switch (sourceTy) {
             case IR::IntType: opcode = V4Instr::ConvertIntToBool; break;
-            case IR::RealType: opcode = V4Instr::ConvertRealToBool; break;
+            case IR::NumberType: opcode = V4Instr::ConvertNumberToBool; break;
             case IR::StringType: opcode = V4Instr::ConvertStringToBool; break;
             case IR::UrlType: opcode = V4Instr::ConvertUrlToBool; break;
             case IR::ColorType: opcode = V4Instr::ConvertColorToBool; break;
@@ -962,28 +962,28 @@ void QV4CompilerPrivate::visitMove(IR::Move *s)
         } else if (targetTy == IR::IntType) {
             switch (sourceTy) {
             case IR::BoolType: opcode = V4Instr::ConvertBoolToInt; break;
-            case IR::RealType: {
+            case IR::NumberType: {
                 if (s->isMoveForReturn)
-                    opcode = V4Instr::MathRoundReal;
+                    opcode = V4Instr::MathRoundNumber;
                 else
-                    opcode = V4Instr::ConvertRealToInt;
+                    opcode = V4Instr::ConvertNumberToInt;
                 break;
             }
             case IR::StringType: opcode = V4Instr::ConvertStringToInt; break;
             default: break;
             } // switch
-        } else if (targetTy == IR::RealType) {
+        } else if (targetTy == IR::NumberType) {
             switch (sourceTy) {
-            case IR::BoolType: opcode = V4Instr::ConvertBoolToReal; break;
-            case IR::IntType: opcode = V4Instr::ConvertIntToReal; break;
-            case IR::StringType: opcode = V4Instr::ConvertStringToReal; break;
+            case IR::BoolType: opcode = V4Instr::ConvertBoolToNumber; break;
+            case IR::IntType: opcode = V4Instr::ConvertIntToNumber; break;
+            case IR::StringType: opcode = V4Instr::ConvertStringToNumber; break;
             default: break;
             } // switch
         } else if (targetTy == IR::StringType) {
             switch (sourceTy) {
             case IR::BoolType: opcode = V4Instr::ConvertBoolToString; break;
             case IR::IntType:  opcode = V4Instr::ConvertIntToString; break;
-            case IR::RealType: opcode = V4Instr::ConvertRealToString; break;
+            case IR::NumberType: opcode = V4Instr::ConvertNumberToString; break;
             case IR::UrlType: opcode = V4Instr::ConvertUrlToString; break;
             case IR::ColorType: opcode = V4Instr::ConvertColorToString; break;
             default: break;
@@ -997,7 +997,7 @@ void QV4CompilerPrivate::visitMove(IR::Move *s)
             switch (sourceTy) {
             case IR::BoolType: gen(V4Instr::ConvertBoolToString, convToString); sourceTy = IR::StringType; break;
             case IR::IntType:  gen(V4Instr::ConvertIntToString,  convToString); sourceTy = IR::StringType; break;
-            case IR::RealType: gen(V4Instr::ConvertRealToString, convToString); sourceTy = IR::StringType; break;
+            case IR::NumberType: gen(V4Instr::ConvertNumberToString, convToString); sourceTy = IR::StringType; break;
             case IR::ColorType: gen(V4Instr::ConvertColorToString, convToString); sourceTy = IR::StringType; break;
             default: break;
             } // switch
@@ -1093,8 +1093,8 @@ void QV4CompilerPrivate::visitRet(IR::Ret *s)
         case IR::IntType:
             test.regType = QMetaType::Int;
             break;
-        case IR::RealType:
-            test.regType = QMetaType::QReal;
+        case IR::NumberType:
+            test.regType = QMetaType::Double;
             break;
         default:
             discard();
diff --git a/src/qml/qml/v4/qv4compiler_p_p.h b/src/qml/qml/v4/qv4compiler_p_p.h
index a9209d9..984f20b 100644
--- a/src/qml/qml/v4/qv4compiler_p_p.h
+++ b/src/qml/qml/v4/qv4compiler_p_p.h
@@ -174,7 +174,7 @@ public:
     QByteArray buildSignalTable() const;
     QByteArray buildExceptionData() const;
 
-    void convertToReal(QQmlJS::IR::Expr *expr, int reg);    
+    void convertToNumber(QQmlJS::IR::Expr *expr, int reg);
     void convertToInt(QQmlJS::IR::Expr *expr, int reg);
     void convertToBool(QQmlJS::IR::Expr *expr, int reg);
     quint8 instructionOpcode(QQmlJS::IR::Binop *e);
diff --git a/src/qml/qml/v4/qv4instruction.cpp b/src/qml/qml/v4/qv4instruction.cpp
index cb6ff40..2602904 100644
--- a/src/qml/qml/v4/qv4instruction.cpp
+++ b/src/qml/qml/v4/qv4instruction.cpp
@@ -123,14 +123,14 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::UnaryNot:
         INSTR_DUMP << "\t" << "UnaryNot" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::UnaryMinusReal:
-        INSTR_DUMP << "\t" << "UnaryMinusReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::UnaryMinusNumber:
+        INSTR_DUMP << "\t" << "UnaryMinusNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
     case V4Instr::UnaryMinusInt:
         INSTR_DUMP << "\t" << "UnaryMinusInt" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::UnaryPlusReal:
-        INSTR_DUMP << "\t" << "UnaryPlusReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::UnaryPlusNumber:
+        INSTR_DUMP << "\t" << "UnaryPlusNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
     case V4Instr::UnaryPlusInt:
         INSTR_DUMP << "\t" << "UnaryPlusInt" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
@@ -138,8 +138,8 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::ConvertBoolToInt:
         INSTR_DUMP << "\t" << "ConvertBoolToInt" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::ConvertBoolToReal:
-        INSTR_DUMP << "\t" << "ConvertBoolToReal" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::ConvertBoolToNumber:
+        INSTR_DUMP << "\t" << "ConvertBoolToNumber" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
     case V4Instr::ConvertBoolToString:
         INSTR_DUMP << "\t" << "ConvertBoolToString" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
@@ -147,20 +147,20 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::ConvertIntToBool:
         INSTR_DUMP << "\t" << "ConvertIntToBool" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::ConvertIntToReal:
-        INSTR_DUMP << "\t" << "ConvertIntToReal" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::ConvertIntToNumber:
+        INSTR_DUMP << "\t" << "ConvertIntToNumber" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
     case V4Instr::ConvertIntToString:
         INSTR_DUMP << "\t" << "ConvertIntToString" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::ConvertRealToBool:
-        INSTR_DUMP << "\t" << "ConvertRealToBool" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::ConvertNumberToBool:
+        INSTR_DUMP << "\t" << "ConvertNumberToBool" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::ConvertRealToInt:
-        INSTR_DUMP << "\t" << "ConvertRealToInt" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::ConvertNumberToInt:
+        INSTR_DUMP << "\t" << "ConvertNumberToInt" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::ConvertRealToString:
-        INSTR_DUMP << "\t" << "ConvertRealToString" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::ConvertNumberToString:
+        INSTR_DUMP << "\t" << "ConvertNumberToString" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
     case V4Instr::ConvertStringToBool:
         INSTR_DUMP << "\t" << "ConvertStringToBool" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
@@ -168,8 +168,8 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::ConvertStringToInt:
         INSTR_DUMP << "\t" << "ConvertStringToInt" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::ConvertStringToReal:
-        INSTR_DUMP << "\t" << "ConvertStringToReal" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::ConvertStringToNumber:
+        INSTR_DUMP << "\t" << "ConvertStringToNumber" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
     case V4Instr::ConvertStringToUrl:
         INSTR_DUMP << "\t" << "ConvertStringToUrl" << "\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
@@ -198,32 +198,32 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::ResolveUrl:
         INSTR_DUMP << "\t" << "ResolveUrl" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::MathSinReal:
-        INSTR_DUMP << "\t" << "MathSinReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::MathSinNumber:
+        INSTR_DUMP << "\t" << "MathSinNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::MathCosReal:
-        INSTR_DUMP << "\t" << "MathCosReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::MathCosNumber:
+        INSTR_DUMP << "\t" << "MathCosNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::MathAbsReal:
-        INSTR_DUMP << "\t" << "MathAbsReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::MathAbsNumber:
+        INSTR_DUMP << "\t" << "MathAbsNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::MathRoundReal:
-        INSTR_DUMP << "\t" << "MathRoundReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::MathRoundNumber:
+        INSTR_DUMP << "\t" << "MathRoundNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::MathFloorReal:
-        INSTR_DUMP << "\t" << "MathFloorReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::MathFloorNumber:
+        INSTR_DUMP << "\t" << "MathFloorNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::MathCeilReal:
-        INSTR_DUMP << "\t" << "MathCeilReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::MathCeilNumber:
+        INSTR_DUMP << "\t" << "MathCeilNumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
-    case V4Instr::MathPIReal:
-        INSTR_DUMP << "\t" << "MathPIReal" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
+    case V4Instr::MathPINumber:
+        INSTR_DUMP << "\t" << "MathPINumber" << "\t\t" << "Input_Reg(" << i->unaryop.src << ") -> Output_Reg(" << i->unaryop.output << ")";
         break;
     case V4Instr::LoadNull:
         INSTR_DUMP << "\t" << "LoadNull" << "\t\t" << "Constant(null) -> Output_Reg(" << i->null_value.reg << ")";
         break;
-    case V4Instr::LoadReal:
-        INSTR_DUMP << "\t" << "LoadReal" << "\t\t" << "Constant(" << i->real_value.value << ") -> Output_Reg(" << i->real_value.reg << ")";
+    case V4Instr::LoadNumber:
+        INSTR_DUMP << "\t" << "LoadNumber" << "\t\t" << "Constant(" << i->number_value.value << ") -> Output_Reg(" << i->number_value.reg << ")";
         break;
     case V4Instr::LoadInt:
         INSTR_DUMP << "\t" << "LoadInt" << "\t\t\t" << "Constant(" << i->int_value.value << ") -> Output_Reg(" << i->int_value.reg << ")";
@@ -249,23 +249,23 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::BitXorInt:
         INSTR_DUMP << "\t" << "BitXorInt" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::AddReal:
-        INSTR_DUMP << "\t" << "AddReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::AddNumber:
+        INSTR_DUMP << "\t" << "AddNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
     case V4Instr::AddString:
         INSTR_DUMP << "\t" << "AddString" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::SubReal:
-        INSTR_DUMP << "\t" << "SubReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::SubNumber:
+        INSTR_DUMP << "\t" << "SubNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::MulReal:
-        INSTR_DUMP << "\t" << "MulReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::MulNumber:
+        INSTR_DUMP << "\t" << "MulNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::DivReal:
-        INSTR_DUMP << "\t" << "DivReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::DivNumber:
+        INSTR_DUMP << "\t" << "DivNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::ModReal:
-        INSTR_DUMP << "\t" << "ModReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::ModNumber:
+        INSTR_DUMP << "\t" << "ModNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
     case V4Instr::LShiftInt:
         INSTR_DUMP << "\t" << "LShiftInt" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
@@ -276,29 +276,29 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::URShiftInt:
         INSTR_DUMP << "\t" << "URShiftInt" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::GtReal:
-        INSTR_DUMP << "\t" << "GtReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::GtNumber:
+        INSTR_DUMP << "\t" << "GtNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::LtReal:
-        INSTR_DUMP << "\t" << "LtReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::LtNumber:
+        INSTR_DUMP << "\t" << "LtNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::GeReal:
-        INSTR_DUMP << "\t" << "GeReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::GeNumber:
+        INSTR_DUMP << "\t" << "GeNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::LeReal:
-        INSTR_DUMP << "\t" << "LeReal" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::LeNumber:
+        INSTR_DUMP << "\t" << "LeNumber" << "\t\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::EqualReal:
-        INSTR_DUMP << "\t" << "EqualReal" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::EqualNumber:
+        INSTR_DUMP << "\t" << "EqualNumber" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::NotEqualReal:
-        INSTR_DUMP << "\t" << "NotEqualReal" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::NotEqualNumber:
+        INSTR_DUMP << "\t" << "NotEqualNumber" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::StrictEqualReal:
-        INSTR_DUMP << "\t" << "StrictEqualReal" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::StrictEqualNumber:
+        INSTR_DUMP << "\t" << "StrictEqualNumber" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::StrictNotEqualReal:
-        INSTR_DUMP << "\t" << "StrictNotEqualReal" << "\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::StrictNotEqualNumber:
+        INSTR_DUMP << "\t" << "StrictNotEqualNumber" << "\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
     case V4Instr::GtString:
         INSTR_DUMP << "\t" << "GtString" << "\t\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
@@ -336,11 +336,11 @@ void Bytecode::dump(const V4Instr *i, int address) const
     case V4Instr::StrictNotEqualObject:
         INSTR_DUMP << "\t" << "StrictNotEqualObject" << "\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::MathMaxReal:
-        INSTR_DUMP << "\t" << "MathMaxReal" << "\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::MathMaxNumber:
+        INSTR_DUMP << "\t" << "MathMaxNumber" << "\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
-    case V4Instr::MathMinReal:
-        INSTR_DUMP << "\t" << "MathMinReal" << "\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
+    case V4Instr::MathMinNumber:
+        INSTR_DUMP << "\t" << "MathMinNumber" << "\t" << "Input_Reg(" << i->binaryop.left << ") Input_Reg(" << i->binaryop.right << ") -> Output_Reg(" << i->binaryop.output << ")";
         break;
     case V4Instr::NewString:
         INSTR_DUMP << "\t" << "NewString" << "\t\t" << "Register(" << i->construct.reg << ")";
diff --git a/src/qml/qml/v4/qv4instruction_p.h b/src/qml/qml/v4/qv4instruction_p.h
index 6b09a67..a2a466e 100644
--- a/src/qml/qml/v4/qv4instruction_p.h
+++ b/src/qml/qml/v4/qv4instruction_p.h
@@ -76,22 +76,22 @@ QT_BEGIN_NAMESPACE
     F(LoadModuleObject, load) \
     F(LoadAttached, attached) \
     F(UnaryNot, unaryop) \
-    F(UnaryMinusReal, unaryop) \
+    F(UnaryMinusNumber, unaryop) \
     F(UnaryMinusInt, unaryop) \
-    F(UnaryPlusReal, unaryop) \
+    F(UnaryPlusNumber, unaryop) \
     F(UnaryPlusInt, unaryop) \
     F(ConvertBoolToInt, unaryop) \
-    F(ConvertBoolToReal, unaryop) \
+    F(ConvertBoolToNumber, unaryop) \
     F(ConvertBoolToString, unaryop) \
     F(ConvertIntToBool, unaryop) \
-    F(ConvertIntToReal, unaryop) \
+    F(ConvertIntToNumber, unaryop) \
     F(ConvertIntToString, unaryop) \
-    F(ConvertRealToBool, unaryop) \
-    F(ConvertRealToInt, unaryop) \
-    F(ConvertRealToString, unaryop) \
+    F(ConvertNumberToBool, unaryop) \
+    F(ConvertNumberToInt, unaryop) \
+    F(ConvertNumberToString, unaryop) \
     F(ConvertStringToBool, unaryop) \
     F(ConvertStringToInt, unaryop) \
-    F(ConvertStringToReal, unaryop) \
+    F(ConvertStringToNumber, unaryop) \
     F(ConvertStringToUrl, unaryop) \
     F(ConvertStringToColor, unaryop) \
     F(ConvertUrlToBool, unaryop) \
@@ -101,15 +101,15 @@ QT_BEGIN_NAMESPACE
     F(ConvertObjectToBool, unaryop) \
     F(ConvertNullToObject, unaryop) \
     F(ResolveUrl, unaryop) \
-    F(MathSinReal, unaryop) \
-    F(MathCosReal, unaryop) \
-    F(MathAbsReal, unaryop) \
-    F(MathRoundReal, unaryop) \
-    F(MathFloorReal, unaryop) \
-    F(MathCeilReal, unaryop) \
-    F(MathPIReal, unaryop) \
+    F(MathSinNumber, unaryop) \
+    F(MathCosNumber, unaryop) \
+    F(MathAbsNumber, unaryop) \
+    F(MathRoundNumber, unaryop) \
+    F(MathFloorNumber, unaryop) \
+    F(MathCeilNumber, unaryop) \
+    F(MathPINumber, unaryop) \
     F(LoadNull, null_value) \
-    F(LoadReal, real_value) \
+    F(LoadNumber, number_value) \
     F(LoadInt, int_value) \
     F(LoadBool, bool_value) \
     F(LoadString, string_value) \
@@ -118,23 +118,23 @@ QT_BEGIN_NAMESPACE
     F(BitAndInt, binaryop) \
     F(BitOrInt, binaryop) \
     F(BitXorInt, binaryop) \
-    F(AddReal, binaryop) \
+    F(AddNumber, binaryop) \
     F(AddString, binaryop) \
-    F(SubReal, binaryop) \
-    F(MulReal, binaryop) \
-    F(DivReal, binaryop) \
-    F(ModReal, binaryop) \
+    F(SubNumber, binaryop) \
+    F(MulNumber, binaryop) \
+    F(DivNumber, binaryop) \
+    F(ModNumber, binaryop) \
     F(LShiftInt, binaryop) \
     F(RShiftInt, binaryop) \
     F(URShiftInt, binaryop) \
-    F(GtReal, binaryop) \
-    F(LtReal, binaryop) \
-    F(GeReal, binaryop) \
-    F(LeReal, binaryop) \
-    F(EqualReal, binaryop) \
-    F(NotEqualReal, binaryop) \
-    F(StrictEqualReal, binaryop) \
-    F(StrictNotEqualReal, binaryop) \
+    F(GtNumber, binaryop) \
+    F(LtNumber, binaryop) \
+    F(GeNumber, binaryop) \
+    F(LeNumber, binaryop) \
+    F(EqualNumber, binaryop) \
+    F(NotEqualNumber, binaryop) \
+    F(StrictEqualNumber, binaryop) \
+    F(StrictNotEqualNumber, binaryop) \
     F(GtString, binaryop) \
     F(LtString, binaryop) \
     F(GeString, binaryop) \
@@ -147,8 +147,8 @@ QT_BEGIN_NAMESPACE
     F(NotEqualObject, binaryop) \
     F(StrictEqualObject, binaryop) \
     F(StrictNotEqualObject, binaryop) \
-    F(MathMaxReal, binaryop) \
-    F(MathMinReal, binaryop) \
+    F(MathMaxNumber, binaryop) \
+    F(MathMinNumber, binaryop) \
     F(NewString, construct) \
     F(NewUrl, construct) \
     F(CleanupRegister, cleanup) \
@@ -283,10 +283,10 @@ union Q_AUTOTEST_EXPORT V4Instr {
         qint8 reg;
     };
 
-    struct instr_real_value {
+    struct instr_number_value {
         QML_V4_INSTR_HEADER
         qint8 reg;
-        qreal value; // XXX Makes the instruction 12 bytes
+        double value; // XXX Makes the instruction 12 bytes
     };
 
     struct instr_int_value {
@@ -371,7 +371,7 @@ union Q_AUTOTEST_EXPORT V4Instr {
     instr_copy copy;
     instr_construct construct;
     instr_null_value null_value;
-    instr_real_value real_value;
+    instr_number_value number_value;
     instr_int_value int_value;
     instr_bool_value bool_value;
     instr_string_value string_value;
diff --git a/src/qml/qml/v4/qv4ir.cpp b/src/qml/qml/v4/qv4ir.cpp
index 34245f5..69de522 100644
--- a/src/qml/qml/v4/qv4ir.cpp
+++ b/src/qml/qml/v4/qv4ir.cpp
@@ -65,8 +65,7 @@ inline const char *typeName(Type t)
     case ObjectType: return "object";
     case BoolType: return "bool";
     case IntType: return "int";
-    case RealType: return "qreal";
-    case RealNaNType: return "NaN";
+    case NumberType: return "number";
     default: return "invalid";
     }
 }
@@ -233,7 +232,7 @@ void Name::init(Name *base, Type type, const QString *id, Symbol symbol, quint32
         builtin = MathMinBuiltinFunction;
     } else if (id->length() == 7 && *id == QLatin1String("Math.PI")) {
         builtin = MathPIBuiltinConstant;
-        this->type = RealType;
+        this->type = NumberType;
     }
 }
 
@@ -267,7 +266,7 @@ Type Unop::typeForOp(AluOp op, Expr *expr)
     case OpUMinus:
     case OpUPlus:
     case OpCompl:
-        return maxType(expr->type, RealType);
+        return maxType(expr->type, NumberType);
 
     default:
         break;
@@ -309,13 +308,13 @@ Type Binop::typeForOp(AluOp op, Expr *left, Expr *right)
     case OpAdd:
         if (left->type == StringType)
             return StringType;
-        return RealType;
+        return NumberType;
 
     case OpSub:
     case OpMul:
     case OpDiv:
     case OpMod:
-        return RealType;
+        return NumberType;
 
     case OpLShift:
     case OpRShift:
@@ -364,7 +363,7 @@ Type Call::typeForFunction(Expr *base)
         case MathAbsBuiltinFunction:    //### type could also be Int if input was Int
         case MathMaxBuiltinFunction:
         case MathMinBuiltinFunction:
-            return RealType;
+            return NumberType;
 
         case MathRoundBultinFunction:
         case MathFloorBultinFunction:
diff --git a/src/qml/qml/v4/qv4ir_p.h b/src/qml/qml/v4/qv4ir_p.h
index 4e9f9fa..3a68695 100644
--- a/src/qml/qml/v4/qv4ir_p.h
+++ b/src/qml/qml/v4/qv4ir_p.h
@@ -150,8 +150,7 @@ enum Type {
     FirstNumberType,
     BoolType = FirstNumberType,
     IntType,
-    RealType,
-    RealNaNType
+    NumberType
 };
 Type maxType(IR::Type left, IR::Type right);
 
diff --git a/src/qml/qml/v4/qv4irbuilder.cpp b/src/qml/qml/v4/qv4irbuilder.cpp
index 453120c..57cea57 100644
--- a/src/qml/qml/v4/qv4irbuilder.cpp
+++ b/src/qml/qml/v4/qv4irbuilder.cpp
@@ -61,8 +61,8 @@ static IR::Type irTypeFromVariantType(int t, QQmlEnginePrivate *engine, const QM
     case QMetaType::Int:
         return IR::IntType;
 
-    case QMetaType::QReal:
-        return IR::RealType;
+    case QMetaType::Double:
+        return IR::NumberType;
 
     case QMetaType::QString:
         return IR::StringType;
@@ -542,7 +542,7 @@ bool QV4IRBuilder::visit(AST::NumericLiteral *ast)
         _expr.format = ExprResult::cx;
         _block->JUMP(ast->value ? _expr.iftrue : _expr.iffalse);
     } else {
-        _expr.code = _block->CONST(IR::RealType, ast->value);
+        _expr.code = _block->CONST(IR::NumberType, ast->value);
     }
     return false;
 }
@@ -977,8 +977,8 @@ bool QV4IRBuilder::visit(AST::BinaryExpression *ast)
         if (left.type() == IR::StringType && right.type() == IR::StringType) {
             binop(ast, left, right);
         } else if (left.isValid() && right.isValid()) {
-            implicitCvt(left, IR::RealType);
-            implicitCvt(right, IR::RealType);
+            implicitCvt(left, IR::NumberType);
+            implicitCvt(right, IR::NumberType);
             binop(ast, left, right);
         }
     } break;
@@ -998,8 +998,8 @@ bool QV4IRBuilder::visit(AST::BinaryExpression *ast)
             }
         } else if ((left.type() == IR::StringType && right.type() >= IR::FirstNumberType) ||
                    (left.type() >= IR::FirstNumberType && right.type() == IR::StringType)) {
-            implicitCvt(left, IR::RealType);
-            implicitCvt(right, IR::RealType);
+            implicitCvt(left, IR::NumberType);
+            implicitCvt(right, IR::NumberType);
             binop(ast, left, right);
         } else if (left.isValid() && right.isValid()) {
             binop(ast, left, right);
@@ -1086,8 +1086,8 @@ bool QV4IRBuilder::visit(AST::BinaryExpression *ast)
 
         IR::Type t = maxType(left.type(), right.type());
         if (t >= IR::FirstNumberType) {
-            implicitCvt(left, IR::RealType);
-            implicitCvt(right, IR::RealType);
+            implicitCvt(left, IR::NumberType);
+            implicitCvt(right, IR::NumberType);
 
             IR::Expr *code = _block->BINOP(IR::binaryOperator(ast->op), left, right);
             _expr.code = _block->TEMP(code->type);
diff --git a/src/qml/qml/v4/qv4irbuilder_p.h b/src/qml/qml/v4/qv4irbuilder_p.h
index 2b338c0..f519209 100644
--- a/src/qml/qml/v4/qv4irbuilder_p.h
+++ b/src/qml/qml/v4/qv4irbuilder_p.h
@@ -95,8 +95,7 @@ protected:
             case QQmlJS::IR::StringType:
             case QQmlJS::IR::BoolType:
             case QQmlJS::IR::IntType:
-            case QQmlJS::IR::RealType:
-            case QQmlJS::IR::RealNaNType:
+            case QQmlJS::IR::NumberType:
                 return true;
 
             default:
diff --git a/src/qml/qml/v4/qv4program_p.h b/src/qml/qml/v4/qv4program_p.h
index 60e7403..659f9f2 100644
--- a/src/qml/qml/v4/qv4program_p.h
+++ b/src/qml/qml/v4/qv4program_p.h
@@ -87,7 +87,7 @@ enum QQmlRegisterType {
     UndefinedType,
     NullType,
     QObjectStarType,
-    QRealType,
+    NumberType,
     IntType,
     BoolType,