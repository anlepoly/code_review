diff --git a/config.tests/unix/libmng/libmng.cpp b/config.tests/unix/libmng/libmng.cpp
new file mode 100644
index 0000000..8f1c85a
--- /dev/null
+++ b/config.tests/unix/libmng/libmng.cpp
@@ -0,0 +1,54 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the config.tests of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <libmng.h>
+
+int main(int, char **)
+{
+    mng_handle hMNG;
+    mng_cleanup(&hMNG);
+
+#if MNG_VERSION_MAJOR < 1 || (MNG_VERSION_MAJOR == 1 && MNG_VERSION_MINOR == 0 && MNG_VERSION_RELEASE < 9)
+#error System libmng version is less than 1.0.9; using built-in version instead.
+#endif
+
+    return 0;
+}
diff --git a/config.tests/unix/libmng/libmng.pro b/config.tests/unix/libmng/libmng.pro
new file mode 100644
index 0000000..ee57ecd
--- /dev/null
+++ b/config.tests/unix/libmng/libmng.pro
@@ -0,0 +1,4 @@
+SOURCES = libmng.cpp
+CONFIG -= qt dylib
+mac:CONFIG -= app_bundle
+LIBS += -lmng
diff --git a/doc/doc.pri b/doc/doc.pri
new file mode 100644
index 0000000..e87ab19
--- /dev/null
+++ b/doc/doc.pri
@@ -0,0 +1,15 @@
+OTHER_FILES += \
+               $$PWD/qtimageformats.qdocconf \
+               $$PWD/qtimageformats-dita.qdocconf
+
+docs_target.target = docs
+docs_target.commands = qdoc3 $$PWD/qtimageformats.qdocconf
+
+ditadocs_target.target = ditadocs
+ditadocs_target.commands = qdoc3 $$PWD/qtimageformats-dita.qdocconf
+
+QMAKE_EXTRA_TARGETS = docs_target ditadocs_target
+QMAKE_CLEAN += \
+               "-r $$PWD/html" \
+               "-r $$PWD/ditaxml"
+
diff --git a/doc/qtimageformats-dita.qdocconf b/doc/qtimageformats-dita.qdocconf
new file mode 100644
index 0000000..82f9fdc
--- /dev/null
+++ b/doc/qtimageformats-dita.qdocconf
@@ -0,0 +1,21 @@
+# Name of the project.
+project = QtImageFormats
+
+
+
+#Do not change the variables after this line unless you know what you are doing.
+
+outputdir = ditaxml
+outputformats = DITAXML
+
+exampledirs += ../examples
+# headerdirs +=
+# sourcedirs +=
+
+HTML.nobreadcrumbs = "true"
+
+examples.fileextensions = "*.cpp *.h *.js *.svg *.xml *.ui *.qml"
+examples.imageextensions = "*.png *.jpeg *.jpg *.gif *.mng"
+headers.fileextensions = "*.h *.ch *.h++ *.hh *.hpp *.hxx"
+sources.fileextensions = "*.cpp *.qdoc *.mm *.qml"
+
diff --git a/doc/qtimageformats.qdocconf b/doc/qtimageformats.qdocconf
new file mode 100644
index 0000000..5f5f946
--- /dev/null
+++ b/doc/qtimageformats.qdocconf
@@ -0,0 +1,64 @@
+# Name of the project.
+project = QtImageFormats
+
+# Directories in which to search for files to document.
+# Paths are relative to the location of this file.
+exampledirs += ../examples
+# headerdirs +=
+imagedirs += images
+# sourcedirs +=
+
+# The following parameters are for creating a qhp file, the qhelpgenerator
+# program can convert the qhp file into a qch file which can be opened in
+# Qt Assistant and/or Qt Creator.
+
+# Defines the name of the project. You cannot use operators (+, =, -) in
+# the name. Properties for this project are set using a qhp.<projectname>.property
+# format.
+qhp.projects = QtImageFormats
+
+# Sets the name of the output qhp file.
+qhp.QtImageFormats.file = QtImageFormats.qhp
+
+# Namespace for the output file. This namespace is used to distinguish between
+# different documentation files in Creator/Assistant. The namespace ends with
+# a version being a number containing a major, minor and revision element.
+# E.g. version 1.0 becomes 100.
+qhp.QtImageFormats.namespace = com.nokia.qtimageformats.100
+
+# Title for the package, will be the main title for the package in
+# Assistant/Creator.
+qhp.QtImageFormats.indexTitle = Qt Image Formats Reference Documentation
+
+# Extra files to add to the output which are not linked to from anywhere
+# using a qdoc \l command.
+qhp.QtImageFormats.extraFiles = style/style.css \
+                        index.html
+
+# Only updtae the name of the project for the next variables.
+qhp.QtImageFormats.virtualFolder  = qdoc
+qhp.QtImageFormats.subprojects = classes
+qhp.QtImageFormats.subprojects.classes.title = Classes
+qhp.QtImageFormats.subprojects.classes.selectors = class fake:headerfile
+qhp.QtImageFormats.subprojects.classes.sortPages = true
+
+
+
+
+# Do NOT change the variables after this line unless you know what you are doing.
+
+outputdir = html
+outputformats = HTML
+
+examples.fileextensions = "*.cpp *.h *.js *.svg *.xml *.ui *.qml"
+examples.imageextensions = "*.png *.jpeg *.jpg *.gif *.mng"
+headers.fileextensions = "*.h *.ch *.h++ *.hh *.hpp *.hxx"
+sources.fileextensions = "*.cpp *.qdoc *.mm *.qml"
+
+HTML.nobreadcrumbs = "true"
+
+HTML.templatedir = .
+HTML.stylesheets = style/style.css
+
+HTML.headerstyles = "  <link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\" />\n"
+HTML.endheader = "</head>\n"
diff --git a/qtimageformats.pro b/qtimageformats.pro
new file mode 100644
index 0000000..aceb208
--- /dev/null
+++ b/qtimageformats.pro
@@ -0,0 +1,18 @@
+TEMPLATE = subdirs
+
+module_qtimageformats_src.subdir = src
+module_qtimageformats_src.target = module-qtimageformats-src
+
+module_qtimageformats_tools.subdir = tools
+module_qtimageformats_tools.target = module-qtimageformats-tools
+module_qtimageformats_tools.depends = module_qtimageformats_src
+
+module_qtimageformats_tests.subdir = tests
+module_qtimageformats_tests.target = module-qtimageformats-tests
+module_qtimageformats_tests.depends = module_qtimageformats_src
+module_qtimageformats_tests.CONFIG = no_default_install
+!contains(QT_BUILD_PARTS,tests):module_qtimageformats_tests.CONFIG += no_default_target
+SUBDIRS += module_qtimageformats_src \
+           module_qtimageformats_tests
+
+include(doc/doc.pri)
diff --git a/src/3rdparty/libmng.pri b/src/3rdparty/libmng.pri
new file mode 100644
index 0000000..7b68210
--- /dev/null
+++ b/src/3rdparty/libmng.pri
@@ -0,0 +1,25 @@
+DEFINES += MNG_BUILD_SO
+DEFINES += MNG_NO_INCLUDE_JNG
+INCLUDEPATH += $$PWD/libmng
+SOURCES += \
+    $$PWD/libmng/libmng_callback_xs.c \
+    $$PWD/libmng/libmng_chunk_io.c \
+    $$PWD/libmng/libmng_chunk_descr.c \
+    $$PWD/libmng/libmng_chunk_prc.c \
+    $$PWD/libmng/libmng_chunk_xs.c \
+    $$PWD/libmng/libmng_cms.c \
+    $$PWD/libmng/libmng_display.c \
+    $$PWD/libmng/libmng_dither.c \
+    $$PWD/libmng/libmng_error.c \
+    $$PWD/libmng/libmng_filter.c \
+    $$PWD/libmng/libmng_hlapi.c \
+    $$PWD/libmng/libmng_jpeg.c \
+    $$PWD/libmng/libmng_object_prc.c \
+    $$PWD/libmng/libmng_pixels.c \
+    $$PWD/libmng/libmng_prop_xs.c \
+    $$PWD/libmng/libmng_read.c \
+    $$PWD/libmng/libmng_trace.c \
+    $$PWD/libmng/libmng_write.c \
+    $$PWD/libmng/libmng_zlib.c
+
+include($$PWD/zlib_dependency.pri)
diff --git a/src/3rdparty/libmng/CHANGES b/src/3rdparty/libmng/CHANGES
new file mode 100644
index 0000000..eeacf33
--- /dev/null
+++ b/src/3rdparty/libmng/CHANGES
@@ -0,0 +1,1447 @@
+-----------------------------------------------------------
+
+1.0.10 (Jul 13th 2007)
+----------------------
+
+in short:
+
+intermediate CVS
+
+-------------------
+
+bugfixes:
+
+core:
+- fixed some compiler-warnings
+- fixed display routines called twice for FULL_MNG support in mozlibmngconf.h
+- standard windows dll upgraded to zlib 1.2.3
+- fixed problem with CLON object during readdisplay() (thanks Winfried!)
+- added typecast to appease the compiler (G R-P)
+- added more SKIPCHUNK conditionals (G R-P)
+- added MORE MNG_NO_1_2_4BIT_SUPPORT (G R-P)
+- added provisional support for anIM(mpNG) proposal
+- added provisional support for ANG proposal
+
+samples:
+- xmngview upgraded to 0.6 (thanks Winfried!)
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.9 (jan 30th 2005)
+---------------------
+
+in short:
+
+New optimizations save over 20KB on footprint.
+Also a few bugfixes and several patches.
+
+Thanks to those sending in their additions and for testing!
+
+To turn on the optimizations do:
+
+#DEFINE MNG_OPTIMIZE_CHUNKINITFREE
+#DEFINE MNG_OPTIMIZE_OBJCLEANUP
+#DEFINE MNG_OPTIMIZE_CHUNKASSIGN
+#DEFINE MNG_OPTIMIZE_CHUNKREADER
+
+(eg. they're not on by default (yet) !)
+
+-------------------
+
+bugfixes:
+- fixed chunk pushing mechanism
+- fixed bug in writing sBIT for indexed color
+- fixed PPLT getchunk/putchunk routines
+- fixed MNG_NO_1_2_4BIT_SUPPORT for TBBN1G04.PNG
+- cleaned up macro-invocations (thanks to D. Airlie)
+
+core:
+- added more SKIPCHUNK conditionals
+- replaced MNG_TWEAK_LARGE_FILES with permanent solution
+- improved handling of cheap transparency when 16-bit support is disabled
+- added some MNG_SUPPORT_WRITE conditionals
+- added function to retrieve current FRAM delay
+- added MNG_NO_1_2_4BIT_SUPPORT
+- added bgr565_a8 canvas-style (thanks to J. Elvander)
+- standard windows dll upgraded to zlib 1.2.2
+- added LITTLEENDIAN/BIGENDIAN fixtures (thanks J.Stiles)
+- inclusion of zlib/lcms/ijgsrc6b with <> instead of ""
+- added conditional MNG_OPTIMIZE_CHUNKINITFREE
+- added conditional MNG_OPTIMIZE_OBJCLEANUP
+- added conditional MNG_OPTIMIZE_CHUNKASSIGN
+- added conditional MNG_OPTIMIZE_CHUNKREADER
+- fixed problem with global PLTE/tRNS
+
+samples:
+
+contrib:
+
+doc:
+- patched jng & mng manual pages (Thanks Peter Breitenlohner)
+
+makefiles:
+
+autoconf:
+- patched makefile.am & configure.in (Thanks Peter Breitenlohner)
+
+-----------------------------------------------------------
+
+1.0.8 (aug 5th 2004)
+--------------------
+
+in short:
+
+added special data-pushing mechanisms and a few other tid-bits
+
+-------------------
+
+bugfixes:
+- fixed problem with PAST usage where source > dest
+
+core:
+- added missing get-/put-chunk-jdaa
+- added CRC existence & checking flags
+- added data-push mechanisms for specialized decoders
+- some speed optimizations (thanks to John Stiles)
+- defend against using undefined closestream function
+- defend against using undefined openstream function
+- added check for extreme chunk-lengths
+- change worst-case iAlphadepth to 1 for standalone PNGs
+- added support for 3+byte pixelsize for JPEG's
+- added conditional to allow easier writing of large MNG's
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.7 (March 21st 2004)
+-----------------------
+
+in short:
+
+A bunch of new canvas-styles, some bug-fixes, upgraded to latest zlib/lcms
+and yet more work to please the Mozilla crowd.
+Releasing beta's doesn't seem very responsive, and this one's hardly changed
+much anyway. I just wanted to bump to a regular version for Mozilla
+re-integration.
+
+-------------------
+
+bugfixes:
+- fixed inclusion of IJNG chunk for non-JNG use (J.S)
+- fixed bug in chunk-storage of SHOW chunk (where from == to)
+- fixed bug in promote_g8_g8 with 16bit support off
+
+core:
+- added CANVAS_RGB565 and CANVAS_BGR565 (big thanx to Raphael Assenat!!)
+- added CANVAS_RGBA565 and CANVAS_BGRA565 ( -- ditto -- )
+- upgraded to zlib 1.2.1
+- upgraded to lcms 1.11
+- added premultiplied alpha canvas' for RGBA, ARGB, ABGR (thx to John Stiles)
+- more optimizations with 16bit support off
+- put conditionals around openstream/closestream callbacks.
+- fixed typo (MNG_SKIPCHUNK_SAVE -> MNG_SKIPCHUNK_nEED)
+- fixed some 64-bit platform compiler warnings
+
+samples:
+
+contrib:
+- fixed mngtree sample (Raphael)
+- added 5-6-5 canvas to SDL sample (Raphael)
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.6 (oct 19th 2003)
+---------------------
+
+in short:
+
+Final release from beta1. No feedback is good feedback I presume,
+so here's 1.0.6-final!
+
+
+-------------------
+
+bugfixes:
+
+core:
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.6-beta1 (sep 14th 2003)
+---------------------------
+
+in short:
+
+further footprint-reductions
+removing email-addresses
+
+1.0.6 (final) will be out shortly
+
+-------------------
+
+bugfixes:
+
+core:
+- added support for reducing the footprint of libmng by macros that optionally
+  skip unused chunks, remove 16-bit sample support, remove Delta support, and
+  remove JNG support, to accomodate Mozilla/Firebird.
+- further optional removal of unused functions
+- added MNG_NO_SUPPORT_FUNCQUERY conditional
+- added iPNGdepth member to pData structure
+- added conditionals around MAGN chunk support
+- added conditionals around non-VLC chunk support
+- added conditionals around "mng_display_go*" and other unused functions
+- added more conditionals around "promote" functions
+- removed email references as appropriate
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.6-alpha1 (aug 2nd 2003)
+---------------------------
+
+in short:
+
+This is mostly in the light of footprint-reduction to please the Mozilla
+crew with a leaner and meaner libmng. See bug 18574 if you're interested:
+http://bugzilla.mozilla.org/show_bug.cgi?id=18574
+
+-------------------
+
+bugfixes:
+- B719420 - fixed several MNG_APP_CMS problems
+
+core:
+- removed some compiler-warnings
+- hiding 12-bit JPEG stuff
+- fixed problem with infinite loops during readdisplay()
+- added size-optimiation COMPOSE routine usage
+- added conditionals around canvas update routines
+- added MNG_SKIPCHUNK_cHNK footprint optimizations
+- added conditionals around some JNG-supporting code      
+- added conditionals around 16-bit supporting code        
+- combined init functions into one function
+- replaced nested switches with simple init setup function
+- added conditionals zlib and jpeg property accessors
+- added size-optimization DIV255B8 routine usage
+- added conditionals around 8-bit magn routines
+- removed conditionals around 8-bit magn routines
+- added MNG_NO_16BIT_SUPPORT and MNG_NO_DELTA_PNG conditionals
+- reversed many loops to use decrementing counter
+- converted some switches to array references
+- removed some redundant checks for iRawlen==0
+- optionally use zlib's crc32 function instead of local mng_update_crc
+- bugfix empty "if" statement when 16-bit code is enabled
+- restored two misplaced #else/#endif blocks
+- added conditionals around "mng_display_go*" and other unused functions
+- added MNG_NO_LOOP_SIGNALS_SUPPORTED conditional
+- fixed duplicate for-loop
+- fixed invalid test in promote_imageobject
+- added conditionals around PAST chunk support
+- fixed "FOOTPRINT_COMPOSEIV" typo (now "FOOTPRINT_DIV")
+
+samples:
+
+contrib:
+- updated xmngview
+- added MSVC project for creating delta-MNGs: makemng (thanks Alex!)
+- added MSVC lib-file for use with the standard libmng.dll (again thanks Alex)
+
+doc:
+- updated readme.contrib
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.5 (mar 1st 2003)
+--------------------
+
+in short:
+
+Only a small fix for progressive jpeg suspension problem.
+
+This is the long-awaited final release containing the new 'dynamic MNG' feature
+and bringing MNG compliance to near 100%!
+
+-------------------
+
+bugfixes:
+- B683152 - libjpeg suspension not always honored correctly
+
+core:
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.5-rc3 (jan 20th 2003)
+-------------------------
+
+in short:
+
+Third release-candidate for the upcoming 1.0.5 version.
+
+Minor bug-fixes and finalizing the accepted proposal (by official vote) for
+the TERM/frame_delay changes on mng-list (nov-dec/2002).
+
+-------------------
+
+bugfixes:
+- B654627 - fixed SEGV when no gettickcount callback (thanks Adam!)
+- B664383 - fixed typo (thanks Dimitri)
+- B664911 - fixed buffer overflow during init (thanks Alex!)
+
+core:
+- finalized changes in TERM/final_delay to elected proposal (positive vote)
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.5-rc2 (dec 9th 2002)
+------------------------
+
+in short:
+
+Second release-candidate for the upcoming 1.0.5 version.
+This contains fixes for a few minor details reported by the loyal testers.
+It fixes some issues with the goframe/golayer/gotime processing and related
+stuff. And it adds a way to disable playback-caching from within the MNG,
+which is very useful for streaming-MNG encoders (such as gserver!).
+
+-------------------
+
+bugfixes:
+
+core:
+- fixed layer- & frame-counting during read()
+- changed FRAMECOUNT/LAYERCOUNT/PLAYTIME error to warning
+- fixed goframe/golayer/gotime processing
+- added support for nEED "MNG 1.1"
+- added support for nEED "CACHEOFF"; turn playback caching off for streaming MNG
+- fixed magnification bug with object 0
+- added support to get totals for frames/layers/playtime after mng_read()
+- fixed some issues in init_app_cms()
+- fixed goxxxxx() support for zero values
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.5-rc1 (nov 1st 2002)
+------------------------
+
+in short:
+
+First release-candidate for the upcoming 1.0.5 version.
+This fixes a few small problems and brings the TERM/MEND processing, with
+respect to interframe_delay as per the current discussion on MNG-list,
+up-to-date with the latest proposal.
+
+-------------------
+
+bugfixes:
+
+core:
+- fixed initialization of pIds in dISC read routine (Thanks Winfried!)
+- fixed issue in freeing evNT chunk (Thanks Winfried!)
+- fixed clipping-problem with BACK tiling (Thanks Sakura!)
+- fixed processing for multiple objects in MAGN (Thanks Sakura!)
+- fixed display of visible target of PAST operation (Thanks Sakura!)
+- modified TERM/MEND processing for max(1, TERM_delay, interframe_delay)
+
+samples:
+
+contrib:
+- fixed typo in Makefile for gtk-mng-view sample
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.5-b3 (oct 15th 2002)
+------------------------
+
+in short:
+
+Fairly quick after beta2, since that introduced a couple of unfortunate
+booboo's and wasn't very workable. It also changes the standard configure
+script to build a standard shared object similar to what I intended.
+
+-------------------
+
+bugfixes:
+
+core:
+- fixed support for condition=2 in TERM chunk
+- fixed trace-constants for PAST chunk
+- added mng_status_dynamic to supports function
+
+samples:
+
+contrib:
+
+doc:
+- small cosmetic changes in man/libmng.3
+
+makefiles:
+
+autoconf:
+- fixed configure.in to build a 'standard' SO primarily
+
+-----------------------------------------------------------
+
+1.0.5-b2 (oct 9th 2002)
+------------------------
+
+in short:
+
+Second beta for next 1.0.5 release. This addresses some minor problems
+detected during testing. It adds the proposed change to the MNG spec as
+discussed on the "mng-list" recently; eg. Adam's option 4.
+And it adds a little function to check at run-time if the lib is a beta or not.
+
+-------------------
+
+bugfixes:
+
+core:
+- fixed chunk-storage for evNT chunk
+- fixed dropping mix of frozen/unfrozen objects
+- fixed problem with cloned objects marked as invalid
+- fixed problem cloning frozen object_buffers
+- fixed DISC support
+- added proposed change in handling of TERM- & interframe-delay
+- added another fix for misplaced TERM chunk
+- added check for TERM placement during create/write
+- completed support for condition=2 in TERM chunk
+- added beta version function & constant
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.5-b1 (sep 24th 2002)
+------------------------
+
+in short:
+
+First beta of a large maintenance release. This completes support of the MNG
+specification to nearly 100% (PAST, PROM, delta-images, BACK image+tile).
+It adds "dynamic" MNG and a few other neat routines as well as fixes several
+bugs reported through SourceForge or to me directly.
+
+-------------------
+
+bugfixes:
+- B575832 - library has wrong patch version number
+- B578572 - remove in 1.0.0!
+- B578940 - some functions not implemented
+- B581625 - large chunks fail with suspension reads
+- B597134 - libmng pollutes the linker namespace
+
+core:
+- added sanity check for improbable chunklengths
+- removed eMNGma hack (thanks Dimitri!)
+- unimplemented functions return an errorcode now
+- added test-option for PNG filter method 192 (= levelling)
+- added test-option for PNG filter method 193 (= no filtering)
+  (both are conditional and only for testing purposes!!!)
+- completed PROM support
+- completed delta-image support
+- completed MAGN support (16-bit functions)
+- added HLAPI function to copy a chunk from a read MNG to a newly created MNG
+- added option for soft-handling of errors (only for repair software!!!)
+- fixed some routine inclusion/exclusion for undefined conditionals 
+- pre-fixed all internal routines with mng_
+- added symbol MNG_LOCAL (= static) to really local functions
+- fixed reading of FRAM with just frame_mode and name
+- fixed read/write of MAGN chunk
+- added event handling for dynamic MNG
+- added 'supports' call to check function availability
+- fixed copyright notice in the headers of all libmng modules
+- fixed LOOP iteration=0 special case
+- re-compiled standard Windows dll with lcms-1.0.9
+- added warning for too much IDAT data
+- warnings are ignored by default now
+- misplaced TERM is now treated as warning
+- fixed color-correction for restore-background handling
+- optimized restore-background for bKGD cases
+- cleaned up some old stuff
+- completed support for BACK image & tiling
+- completed support for PAST
+- added bgrx8 canvas (filler byte)
+- fixed reset_object_detail to clear old buffer
+- added in-memory color-correction of abstract images
+- added compose over/under routines for PAST processing
+- added flip & tile routines for PAST processing
+
+samples:
+- Added new BCB sample for fixing invalid JASC Animation Shop files
+  (shows new copy_chunks function; use of MNG_SOFTERRORS & static linking)
+
+contrib:
+- added xmngview by Winfried Szukalski (Vielen dank!)
+- Updated the Delphi mngview sample to handle dynamic MNGs
+- Added Kylix example (simplified port of the Delphi mngview sample)
+
+doc:
+- added diff to add MNG&JNG to a systems 'magic' file (Thanks Winfried)
+- fixed docs about using mng_display_resume after display_reset
+  (should read to use mng_display!)
+
+makefiles:
+- added makefile to build a libmng.dll for MingW
+  (makefile.mingwdll - thanks to Frank Richter!)
+
+autoconf:
+- fixing libtool version-number to be in line with what it should be
+
+-----------------------------------------------------------
+
+1.0.4 (Jun 23rd 2002)
+---------------------
+
+in short:
+
+Just some small fixes
+Standard dll now compiled with zlib 1.1.4 and lcms 1.0.8
+
+-------------------
+
+bugfixes:
+- B495442 - invalid returnvalue in mng_get_suspensionmode
+- B495443 - incorrect suspend check in read_databuffer
+- B526138 - returned IJGSRC6B calling convention to default for MSVC
+- B558212 - off by one error
+- B557677 - can't find lcms.h
+
+core:
+- fixed possible compile-problem in cleanup_rowproc
+- MNG subimage alpha composite wrong for rgba8 images
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+- fixed check for lcms.h in configure.in
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.3 (Sep 18th 2001)
+---------------------
+
+in short:
+
+Small cosmetic changes. Cleaning up the contributions.
+New makefile for mingw32, and new fbcon example.
+Major thanks to Greg for helping out with the *nix stuff!
+Note that there's also a separate download for ASM programmers now.
+Check http://www.libmng.com for details (download/ports&packages page).
+
+It may be a while for the next release. I'm "off duty" for the next 8 or
+so months...
+
+Gerard
+
+-------------------
+
+bugfixes:
+- B459058 - wrong include for lcms headers
+
+core:
+- changed inclusion of lcms.h header for Linux platforms (suggested by Greg)
+- added get function for last processed BACK chunk
+
+samples:
+- replaced the gtk & sdl viewer apps with updates by Greg Roelofs
+
+contrib:
+
+doc:
+
+makefiles:
+- changed makefile.linux & makefile.unix as suggested by Greg Roelofs
+  (makefile.linux now compiles with lcms by default)
+- added makefile.mingw for mingw32 by Benoit Blanchon (thanks Mate!)
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.2 (Jul 7th 2001)
+--------------------
+
+in short:
+
+Another maintenance release with a few added extra's.
+
+-------------------
+
+bugfixes:
+- B421427 - writes wrong format in bKGD and tRNS
+- B434583 - compiler-warning if MNG_STORE_CHUNKS undefined
+
+core:
+- added optimization option for MNG-video playback
+- added processterm callback
+- added late binding errorcode (not used internally)
+- fixed memory-leak with delta-images (Thanks Michael!)
+- added option to turn off progressive refresh for large images
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.1 (May 2nd 2001)
+--------------------
+
+in short:
+
+Maintenance release.
+Fixed several memory-leaks with the help of Gregg Kelly, added/fixed some CMS
+handling, exported JPEG functions from standard DLL, and some other minor fixes.
+
+The CMS fix now makes libmng automagically work in MNG_FULL_CMS mode as a
+sRGB compliant system. YOU WILL NEED TO CHANGE THIS IF YOU ARE NOT ON AN sRGB
+COMPLIANT SYSTEM AND WANT TO USE CMS!!!!
+(look in libmng.h for the proper function-calls)
+
+-------------------
+
+bugfixes:
+
+core:
+- added MEND processing callback
+- fixed first FRAM_MODE=4 timing problem
+- added handle status-copy function (use with care)
+- exported JPEG functions from standard DLL
+- added BGRA8 canvas with premultiplied alpha (contrib by Gregg Kelly)
+- fixed problem with display_reset/display_resume (Thanks Gregg!)
+- fixed several memory-leaks (Thanks Gregg!)
+- fixed reset_rundata to drop all objects (Thanks again, Gregg!)
+- fixed problem with cms profile being created multiple times when both
+  iCCP & cHRM/gAMA are present (And again... Gregg)
+- moved mng_clear_cms to libmng_cms
+- added "default" sRGB generation (Thanks Marti!)
+
+samples:
+
+contrib:
+
+doc:
+
+makefiles:
+
+autoconf:
+
+-----------------------------------------------------------
+
+1.0.0 (Feb 6th 2001)
+--------------------
+
+in short:
+
+First public release. Finally(!)
+
+This is the 0.9.5 CVS version, which will never be released, because I feel it
+is now ready for a public release. So apart from the version-numbers here and
+there, all other changes are listed under 0.9.5.
+
+This library will work with every MNG/JNG known and available to me. Note that
+there are still parts that need to be coded, and that MNG support is around
+90-95% (JNG at 100%). It is however compliant with the latest and greatest
+MNG 1.0 specification.
+
+I hope to dedicate a bit more time this year to finish up full support and fill
+in the remaining blanks. But this is coming out of my spare time. And extra
+help is always appreciated.
+
+Please enjoy!
+
+Gerard
+
+-----------------------------------------------------------
+
+0.9.5 (no release)
+------------------
+
+in short:
+
+intermediate CVS
+
+-------------------
+
+bugfixes:
+B129681 - fixed compiler warnings SGI/Irix (thanks Dimitri)
+
+core:
+- fixed compiler-warnings Mozilla (thanks Tim)
+- fixed timing-problem with switching framing_modes
+- fixed some small compiler warnings (thanks Nikki)
+
+samples:
+
+contrib:
+- fixed library-paths for MSVC DLL project (thanks Chad)
+
+doc:
+
+makefiles:
+- added makefile for DJGPP (thanks Silvio)
+
+autoconf:
+
+-----------------------------------------------------------
+
+0.9.4 (Jan 19th 2001)
+----------------------
+
+in short:
+
+Now that the MNG spec is at 1.0, this should be the last beta. There's a few
+small changes to make it inline with the spec, and a couple of bug-fixes.
+This is a serious release-candidate for libmng-1.0!!
+Please... test test test test!!
+
+-------------------
+
+bugfixes:
+B123314 - fixed number of TERM related problems
+B123322 - fixed unwanted repetition in mng_readdisplay()
+B123443 - fixed by Ralph
+B124910 - fixed definition for WIN32_LEAN_AND_MEAN (thanks Chad)
+B125750 - fixed by Ralph
+B125756 - fixed mixup of data- & function-pointers (thanks Dimitri)
+B127517 - changed inclusion of the lcms header file for non-windows platforms
+
+core:
+- version numbers
+- fixed possible loop in display_resume() (Thanks Vova!)
+- fixed unwanted repetition in mng_readdisplay()
+- changed inclusion of the lcms header file for non-windows platforms
+- changed IHDR filter_method check for PNGs
+- moved restore of object 0 to libmng_display
+- added restore of object 0 to TERM processing (B123314)
+- fixed TERM delay processing (B123314)
+- fixed TERM end processing when count = 0 (B123314)
+- changed callback convention for MSVC (Thanks Chad)
+- fixed mixup of data- & function-pointers (thanks Dimitri)
+- added support for "nEED MNG-1.0"
+- added errorcode for MAGN methods
+- added errorchecking for MAGN methods
+- removed "old" MAGN methods 3 & 4
+- added "new" MAGN methods 3, 4 & 5
+- removed test filter-methods 1 & 65
+- set default level-set for filtertype=64 to all zeroes
+
+samples:
+
+contrib:
+- added GTK mng-view example by Vova Babin
+- added MSVC MNGview sample by Nikolaus Brennig
+- updated Jason Summer's mngplg to version 0.9.2
+  (that's mngplg-0.9.2 based on libmng-0.9.3 !!!)
+- rearranged contrib directory slightly
+- added MSVC project to build libmng.dll by Chad Austin
+
+doc:
+- added README.dll
+- added README.config
+
+makefiles:
+- added a makefile for MS Visual C++ (Thanks to Atsushi Matsuda)
+
+autoconf:
+- fixed configure.in for lcms (FreeBSD port by Mikhail Teterin)
+- by default configure includes CMS support if lcms is present
+
+-----------------------------------------------------------
+
+0.9.3 (October 29th 2000)
+-------------------------
+
+in short:
+
+Another beta release. The number of changes in the MNG specification have
+resulted in a lot of new code and some changed code. At the same time I saw
+no need to withhold some new functionality as it was pretty clear there was
+going to be another beta-round. If things go well, I'm going to try to release
+libmng 1.0.0 very shortly after this one.
+
+Many thanks to a lot of people for helping out, sending contributions, making
+suggestions and testing this little baby. This would get nowhere without YOU!!!
+
+- fixed bug 111300/117103
+- added workaround for faulty PhotoShop iCCP chunk
+- added MAGN/JDAA chunks
+- added support for new filter_types
+- added PNG/MNG spec version indicators
+- added BCB mngview contribution by Andy Protano
+- added BCB mngdump; a GUI-based MNG dumping utility (Andy Protano)
+- implemented support for nEED "draft nn"
+- implemented app-defined support for bKGD for PNG images
+- removed trace-options from default SO/DLL builds (!!!)
+- raised initial maximum canvas size to 10000x10000 (!!!)
+  (an App that wants to protect from overly large images should call
+   mng_set_maxcanvassize() with appropriate values)
+- fixed other assorted stuff
+
+-------------------
+
+bugfixes:
+B111300 - fixup for improved portability
+B117103 - fixed compilation errors on *nix with lcms (thanks Ralph!)
+
+core:
+- fixed compiler-warnings from Mozilla
+- added check for simplicity-bits in MHDR
+- added workaround for faulty PhotoShop iCCP chunk
+- fixed app-supplied background restore
+- fixed TERM processing delay of 0 msecs
+- fixed write-code for zTXt & iTXt
+- fixed read-code for iTXt
+- added MAGN chunk
+- fixed sRGB precedence for gamma_only corection
+- added support for new filter_types
+- fixed problem with no refresh after TERM
+- fixed DEFI behavior
+- fixed inclusion parameters to make the external libs work together
+- added export of zlib functions from windows dll
+- fixed timing & refresh behavior for single PNG/JNG
+- removed trace-options from default SO/DLL builds (!!!)
+- fixed MAGN rounding errors (thanks Matthias!)
+- fixed small timing problem when FRAM delay = 0
+- fixed simplicity-check in compliance with draft 81/0.98a
+- fixed alpha-blending for all alpha-canvasstyles
+- added support for alpha-depth prediction
+- fixed processing of unknown critical chunks
+- removed test-MaGN
+- added PNG/MNG spec version indicators
+- implemented support for nEED
+- added support for JDAA
+- added functions to retrieve PNG/JNG specific header-info
+- added optional support for bKGD for PNG images
+- raised initial maximum canvas size to 10000x10000
+- added support for delta-JNG
+- added callback to process non-critical unknown chunks
+- fixed support for delta-images during read() / display()
+- added closestream() processing for mng_cleanup()
+- fixed delta-processing behavior
+- added storage for pixel-/alpha-sampledepth for delta's
+- implemented delayed delta-processing
+- fixed putchunk_plte() to set bEmpty parameter (thanks Ben!)
+- added errorcode for delayed delta-processing
+- added get/set for bKGD preference setting
+- added get function for interlace/progressive display
+- fixed bug in empty PLTE handling
+- fixed seperate read() & display() processing
+- fixed tRNS processing for gray-image < 8-bits
+
+samples:
+- added BCB mngview contribution by Andy Protano
+
+contrib:
+- added BCB mngdump; a GUI-based MNG dumping utility (Andy Protano)
+
+doc:
+- updated RPM spec-file by MATSUURA Takanori
+- updated README.contrib
+
+makefiles:
+- fixed some stuff in automake/autoconf/libtool
+- fixed auto* for bug B117103
+
+-----------------------------------------------------------
+
+0.9.2 (August 7th 2000)
+-----------------------
+
+in short:
+
+Third beta release! Last one???
+
+!!IMPORTANT!! All file-names are now prefixed with "libmng_" !!IMPORTANT!!
+
+Many thanks to Albert Chin-A-Young for his contribution of the
+autoconf/automake/libtool stuff and to Ralph Giles for helping me
+put it in the right places.
+
+There's a special README.autoconf so please read it!
+
+- fixed bug 110320/110546/110547/111096
+- added several status retrieval functions
+- fixed other small bugs in display processing
+- fixed number of small problems and documentation typos
+- added autoconf/automake/libtool
+- added latest MNG plugin (0.9.0) by Jason Summers
+
+-------------------
+
+bugfixes:
+B110320 - fixed GCC warning about mix-sized pointer math
+B110546 - fixed for improperly returning UNEXPECTEDEOF
+B110547 - fixed bug in interlace code
+B111096 - fixed large-buffer read-suspension
+
+core:
+- version numbers
+- fixed small bugs in display processing
+- removed Nextbackxxx fields (no longer used)
+- fixed problem with trace-functions improperly wrapped
+- put specific code in add_chunk() inside MNG_SUPPORT_WRITE wrapper
+- fixed documentation typos
+- fixed wrapping of suspension parameters
+- added status_xxxx functions
+- added trace-codes/-strings for status_xxxxx functions
+- changed file-prefixes
+- added function to set simplicity field
+- added trace-code/-string for updatemngsimplicity
+- fixed putchunk_unknown() function
+
+samples:
+
+contrib:
+- added latest MNG plugin (0.9.0) by Jason Summers
+
+doc:
+- version numbers
+- added autoconf readme
+- version numbers in RPM stuff
+
+makefiles:
+- fixed for new file-prefix
+- added autoconf/automake/libtool
+
+-----------------------------------------------------------
+
+0.9.1 (July 26th 2000)
+----------------------
+
+in short:
+
+Second beta release.
+
+Given the enormous amount of bug-reports (not ;-), this will most likely
+be one of the last betas. If things remain upright, the first public release
+(1.0.0) is fairly eminent in the weeks to come...
+
+- added SDL mng player by Ralph Giles to contributions
+- fixed timing and added internal buffering for I/O-suspension scenarios
+- added get routines for internal display-state variables (frame/layer/playtime)
+- changed read-processing for improved I/O-suspension (internal buffering)
+- fixed several problems with create- & write-support
+- added a load of documentation
+- lots of small stuff
+
+-------------------
+
+bugfixes:
+
+core:
+- fixed mandatory BACK color to be opaque
+- changed mng_display_resume to allow to be called after a suspension
+  return with MNG_NEEDMOREDATA
+- changed comments to indicate modified behavior for timer & suspension breaks
+- added variables for go_xxxx processing
+- implemented support for freeze/reset/resume & go_xxxx
+- added trace-codes/-strings for special display processing
+- added variables for improved timing support
+- added support for improved timing
+- added get routines for internal display variables
+- added get/set routines for suspensionmode variable
+- added trace-code/-string for get/set suspensionmode
+- added trace-codes/-strings for get/set display variables
+- added support for improved I/O-suspension
+- changed read-processing for improved I/O-suspension
+- added trace-code/-string for read_databuffer (I/O-suspension)
+- added suspendbuffer constants
+- changed EOF processing behavior
+- fixed TERM delay processing
+- changed pre-draft48 frame_mode=3 to frame_mode=1
+- added callbacks for SAVE/SEEK processing
+- added trace-codes/-strings for SAVE/SEEK callbacks
+- added variable for NEEDSECTIONWAIT breaks
+- added trace-codes/-strings for get/set sectionbreaks
+- added NEEDSECTIONWAIT error-code/-string
+- added macro + routine to set returncode without calling error callback
+- added trace-code/-string for special error routine
+- changed default readbuffer size from 1024 to 4200
+- added variable for freeze & reset processing
+- fixed storage of images during mng_read()
+- fixed support for mng_display() after mng_read()
+- added error cleanup processing
+- fixed support for mng_display_reset()
+- fixed suspension-buffering for 32K+ chunks
+- added function to set frame-/layer-count & playtime
+- added trace-code/-string for updatemngheader
+- added error-code/-string for updatemngheader if not a MNG
+- fixed creation-code
+- fixed writing of signature
+- fixed several chunk-writing routines
+
+samples:
+- fixed the libmng.pas module in line with libmng.h
+
+contrib:
+- added the SDL based mngplay viewer by Ralph Giles
+
+doc:
+- extended the RPM contribution by MATSUURA Takanori
+- added libmng.txt, a full description of the library and its usage
+- added man-pages for mng(5), jng(5) and libmng(3)
+
+makefiles:
+
+-----------------------------------------------------------
+
+0.9.0 (June 30th 2000)
+----------------------
+
+in short:
+
+This is the first beta!!! Yippee!!!
+
+Thanks to all the people who helped to guide me in the right direction.
+You know who you are!
+
+A special thanks to the guys with early implementations, who stood by and
+put up with my whims :-)
+
+changes over 0.5.3:
+
+- updated mngplg to 0.4.1 (the latest & greatest)
+- changed refresh parameters to 'x,y,width,height'
+
+-----------------------------------------------------------
+
+0.5.3 (never released)
+----------------------
+
+in short:
+
+This is a working version only; the next release will be 0.9.0 (first Beta!)
+
+There are a few incompatible changes with previous versions. The userdata
+variable has been changed from mng_uint32 to mng_ptr to accomodate 64-bit
+systems. For the same reason memory allocation size parameters have been
+changed to a mng_size_t type which is a typedef of size_t.
+
+Thanks to Aleks Jakulin for helping to iron out some 64-bit platform issues!
+
+- implemented the update-region parameters of the refresh callback
+- added support for most common delta-image options
+- added an animation-speed modifier
+- added an image-level parameter for the processtext callback
+- updated mngplg to 0.4.0 (supports JNG, full CMS, and other enhancements!)
+- fixed a lot of small things
+- added support for PPLT chunk
+- fixed to support 64-bit platforms
+
+-------------------
+
+bugfixes:
+
+core:
+- added processing of color-info on delta-image
+- fixed handling of empty SAVE chunk
+- fixed display of stored JNG images
+- fixed problem with BASI-IEND as object 0
+- changed the version parameters (obviously)
+- added update-region parms for refresh calback
+- added Needrefresh parameter
+- added initialization of update-region for refresh
+- added initialization of Needrefresh parameter
+- changed progressive-display processing                  
+- added tracecodes for tracing JPEG progression           
+- added tracing of JPEG calls
+- added Deltaimmediate parm for faster delta-processing
+- added extra checks for delta-images                     
+- many changes to support delta-images
+- optimized some store_xxx routines                       
+- fixed some small things (as precaution)                 
+- fixed possible trouble if IEND display-processing got broken up
+- fixed nasty bug with embedded PNG after delta-image    
+- added processing of PLTE & tRNS for delta-images
+- added processing of PLTE/tRNS & color-info for delta-images in the
+  ani_objects chain
+- fixed problem with color-correction for stored images   
+- added get/set for speedtype to facilitate testing
+- added trace-codes & -strings for get/set speedtype
+- added speed-modifier to timing routine       
+- added get-routine of imagelevel for processtext callback
+- added trace-code & -string for get imagelevel
+- added administration of imagelevel parameter            
+- added support for PPLT chunk                         
+- added trace-codes & -strings for PPLT chunk processing
+- fixed problem with incorrect gamma-correction
+- fixed inclusion of IJG read/write code
+- fixed problem with 16-bit GA format
+- fixed problem with cheap transparency for 4-bit gray
+- fixed display_xxxx routines for interlaced images
+- added precaution against faulty iCCP chunks from PS
+- changed userdata variable to mng_ptr
+- added typedef for mng_size_t
+- changed size parameter for memory allocation to mng_size_t
+- fixed compiler-warning for non-initialized iB variable
+- changed definition for 32-bit ints (64-bit platforms)
+- changed definition for mng_handle (64-bit platforms)
+- swapped refresh parameters
+- fixed initialization routine for new mng_handle type
+- added inclusion of stdlib.h for abs()
+- fixed some 64-bit warnings
+- fixed incompatible return-types
+
+samples:
+
+contrib:
+- updated mngplg to 0.3.0 (supports JNG & full color-correction!)
+- updated mngplg to 0.4.0 (Jason is picking up the pace ;-)
+
+doc:
+- added rpm directory with rpm spec-file (contributed by MATSUURA Takanori)
+
+makefiles:
+- changed makefile.linux to reflect versionnr for shared-lib
+- changed makefile.linux to depend on mng_conf.h & mng_types.h
+
+-----------------------------------------------------------
+
+0.5.2 (June 10th 2000)
+----------------------
+
+in short:
+
+This is the third release for developers
+Another milestone since JNG is now fully supported
+The next release will most likely be numbered 0.9.0 as the first Beta!!
+
+Fixed bug 106017 & 106019
+Added many constants regarding chunk-property values
+Implemented full JNG support
+Added all the error- & trace-strings
+Added get/set routines for default ZLIB/IJG parameters
+Added a generic makefile for Unix platforms (contributed by Tim Rowley)
+Added canvasstyle for separate RGB + A canvas (eg. mozilla-style)
+Separated configuration-options into a separate file: "mng_conf.h"
+Fixed stuff for generic Unix compilation (contributed by Tim Rowley)
+Upgraded to lcms1.0.6 (now supports 16-bit endian-peculiarities)
+Added a makefile for Linux ELF & fixed some code-issues to go along with gcc
+Added support for suspended input-buffer processing
+Implemented the display-routines for RGBA/ARGB/BGRA/ABGR canvasstyles
+Implemented the application background-restore functionality
+Fixed & tested the mngtree Unix-sample (runs on Linux-RH6.2 with libmng.so)
+Upgraded mngplg to v0.2.2 (based on the latest code including JNG)
+Fixed a lot of other assorted stuff
+
+-------------------
+
+bugfixes:
+B003(106017) - fixed problem with <mem.h> being proprietary to BCB
+B004(106019) - fixed problem when MNG_SUPPORT_WRITE not defined
+
+core:
+- bumped version-numbers up to 0.5.2 (yeah, really)
+- fixed support for IJGSRC6B
+- cleaned up some code regarding mixed support-options
+- complemented constants for chunk-property values
+- fixed MNG_UINT_pHYg value
+- implemented JNG support
+- fixed problem with DEFI clipping
+- added error telltale strings & support
+- added trace telltale strings & support
+- added support for global color-chunks inside TERM/LOOP
+- added support for global PLTE,tRNS,bKGD inside TERM/LOOP
+- added default IJG compression parameters and such
+- moved init of default zlib parms to "mng_hlapi.c"
+- added init of default IJG parms
+- added support for get/set of zlib/IJG default parms
+- added tracestrings for global animation color-chunks
+- added tracestrings for get/set of default ZLIB/IJG parms
+- added tracestrings for global PLTE,tRNS,bKGD             
+- added framenr/layernr/playtime to object header          
+- added initialization of framenr/layernr/playtime        
+- changed ani_create calls not returning object pointer
+- create ani objects always (not just inside TERM/LOOP)
+- fixed inconsistancy with freeing global iCCP profile    
+- fixed minor bugs 16-bit pixel-handling                    
+- added object promotion routine (PROM handling)           
+- added trace-codes & -strings for image-object promotion
+- added trace-codes & -strings for delta-image processing
+- added error-codes & -strings for delta-image processing              
+- added support for delta-image processing
+- added ani-object routines for delta-image processing
+- added delta-image fields
+- added compression/filter/interlace fields to object-buffer for
+  delta-image processing                
+- added delta-image row-processing routines
+- fixed up punctuation in several files (contributed by Tim Rowley)       
+- removed useless definition in "mng_chunks.h" (contributed by Tim Rowley)
+- fixed pointer confusion in "mng_display.c" (contributed by Tim Rowley)
+- fixed inclusion for memcpy (contributed by Tim Rowley)
+- added mng_int32p (contributed by Tim Rowley)
+- added internal delta-image processing callbacks
+- separated configuration-options into "mng_conf.h"
+- changed to most likely configuration
+- added RGB8_A8 canvasstyle
+- added getalphaline callback for RGB8_A8 canvasstyle
+- fixed some makeup for Linux gcc compile
+- implemented app bkgd restore routines                   
+- implemented RGBA8, ARGB8, BGRA8 & ABGR8 display routines
+- added support for RGB8_A8 canvasstyle
+- added support for suspended input-buffer processing                   
+- added mng_read_resume HLAPI function to support read-suspension
+- fixed timer-handling to run with Mozilla (Tim Rowley)
+- fixed alpha-handling for alpha canvasstyles             
+- fixed some compilation-warnings (contrib Jason Morris)
+
+samples:
+- fixed mngview(delphi) to work with the new core
+- synchronized libmng.pas(delphi) with the new libmng.h header
+- removed the error- & trace-strings from libmng.pas(delphi)
+- fixed mngtree(Unix) to compile on Linux (runs with libmng.so)
+- added makefile.linux for mngtree(Unix) (tested on RedHat6.2)
+
+contrib:
+- updated mngplg to 0.2.2 (based on latest code; supports JNG!)
+
+doc:
+- this file obviously
+- added Tim Rowley as contributing author
+- changed the examples.readme doc
+- updated the design-schematics in line with the current code
+
+makefiles:
+- changed the directory to "makefiles" to avoid name-conflicts
+- added generic Unix makefile (thanks to Tim Rowley)
+- added Linux ELF makefile (tested on RedHat6.2)
+
+-----------------------------------------------------------
+
+0.5.1 May 16th 2000
+-------------------
+
+in short:
+
+This is the second release for developers
+It's a bit of a milestone since all the chunk functionality is in place and
+functioning (read, examine, create & write)
+This version is incompatible with 0.5.0 since some of the callback prototypes
+have changed (should be the last time that happens!)
+There are a few more samples and even a real contribution!
+
+Fixed bug 105795 & 105797
+Fixed a mis-alignment in animation-timing
+Added chunk-access functions
+Finished all chunk-storage routine-bits
+Finished all chunk-write routines
+Changed the callback prototypes to allow error-reporting back to the library
+Fixed some routines to allow for callback error-reporting
+Added version-control functions & constants
+Added two functions to set display- & sRGB-profile from memory
+Moved CRC table to dynamic structure (for improved thread-safety)
+Added SAVE & SEEK save&restore functionality
+Finished the application-based CMS-callbacks
+Fixed a few BCB specifics
+Changed the Win32 DLL and samples to use __stdcall
+Did some more assorted little changes
+Added 2 BCB samples
+Added 1 Unix sample
+Added the MNG plugin by Jason Summers in the contrib section
+Changed some documents to reflect these changes
+
+-------------------
+
+bugfixes:
+B001(105795) - fixed wrong lcms call & memory-leak for gammatables
+B002(105797) - fixed problem with missing sRGB profile
+
+core:
+- changed chunk iteration function
+- added chunk access functions
+- added version control constants & functions
+- changed strict-ANSI stuff
+- added set_outputprofile2 & set_srgbprofile2
+- added empty-chunk put-routines
+- added version_dll & VERSION_DLL (for consistency)
+- added version control explanatory text & samples
+- added iteratechunk callback definition
+- improved definitions for DLL support
+- added 8-bit palette definition
+- added general array definitions
+- added MNG_NULL definition
+- changed most callback prototypes to allow the app
+  to report errors during callback processing
+- added CRC table to main structure (for thread-safety)
+- added iPLTEentries for checking hIST-length
+- changed palette definition to exported palette-type
+- removed frozen indicator
+- added create/write indicators
+- added eMNGma hack (will be removed in 1.0.0 !!!)
+- added TERM animation object pointer (easier reference)
+- added saved-data structure for SAVE/SEEK processing
+- added some errorcodes
+- added application errorcodes (used with callbacks)
+- moved chunk-access errorcodes to severity 5
+- added chunk-access function trace-codes
+- changed trace to macro for callback error-reporting
+- added save_state & restore_state trace-codes
+- put in some extra comments
+- fixed layout for sBIT, PPLT
+- changed write callback definition
+- fixed layout for PPLT again (missed deltatype ?!?)
+- cleaned up left-over teststuff in the BACK chunk routine
+- changed CRC initialization to use dynamic structure
+  (wasn't thread-safe the old way !)
+- filled in many missing sequence&length checks
+- filled in many missing chunk-store snippets
+- added checks for running animations
+- filled remaining write routines
+- fixed read_pplt with regard to deltatype
+- added callback error-reporting support
+- added pre-draft48 support (short MHDR, frame_mode, LOOP)
+- fixed chunk-storage bit in several routines
+- supplemented the SAVE & SEEK display processing
+- added init of iPLTEcount
+- changed calling-convention definition
+- changed status-handling of display-routines
+- added versioning-control routines
+- filled the write routine
+- fixed frame_delay misalignment
+- added sanity check for frozen status
+- changed display_mend to reset state to initial or SAVE
+- added save_state and restore_state for SAVE/SEEK/TERM
+  processing
+- added process_save & process_seek routines
+- changed and filled iterate-chunk function
+- added getchunk functions
+- added putchunk functions
+- added empty-chunk put-routines
+- filled application-based color-management routines
+- added creatememprofile
+- filled the deflatedata routine
+- added cleanup of saved-data (SAVE/SEEK processing)
+- moved the actual write_graphic functionality from mng_hlapi.c
+  to it's appropriate function in the mng_write.c module
+- moved standard header includes into mng_types.h
+  (stdlib/mem for mem-mngmt & math for fp gamma-calc)
+- added getimgdata & putimgdata functions
+
+samples:
+- fixed mngview(delphi) to work with the new core
+- synchronized libmng.pas(delphi) with the new libmng.h header
+- added mngtree(bcb) sample
+- added bogus(bcb) sample
+- added mngtree(unix) sample
+
+contrib:
+- added mngplg 0.1.0 / a MNG plugin for Win32 by Jason Summers
+
+doc:
+- added this changes.readme file
+- changed the samples.readme doc accordingly
+- changed the contrib.readme doc accordingly
+
+-----------------------------------------------------------
+
+0.5.0 May 1st 2000
+------------------
+
+in short:
+
+This is the first developers release.
+It's roughly about 60% done.
diff --git a/src/3rdparty/libmng/LICENSE b/src/3rdparty/libmng/LICENSE
new file mode 100644
index 0000000..2b624c0
--- /dev/null
+++ b/src/3rdparty/libmng/LICENSE
@@ -0,0 +1,57 @@
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * COPYRIGHT NOTICE:                                                      * */
+/* *                                                                        * */
+/* * Copyright (c) 2000-2007 Gerard Juyn (gerard@libmng.com)                     * */
+/* * [You may insert additional notices after this sentence if you modify   * */
+/* *  this source]                                                          * */
+/* *                                                                        * */
+/* * For the purposes of this copyright and license, "Contributing Authors" * */
+/* * is defined as the following set of individuals:                        * */
+/* *                                                                        * */
+/* *    Gerard Juyn                                                         * */
+/* *    Glenn Randers-Pehrson                                               * */
+/* *                                                                        * */
+/* * The MNG Library is supplied "AS IS".  The Contributing Authors         * */
+/* * disclaim all warranties, expressed or implied, including, without      * */
+/* * limitation, the warranties of merchantability and of fitness for any   * */
+/* * purpose.  The Contributing Authors assume no liability for direct,     * */
+/* * indirect, incidental, special, exemplary, or consequential damages,    * */
+/* * which may result from the use of the MNG Library, even if advised of   * */
+/* * the possibility of such damage.                                        * */
+/* *                                                                        * */
+/* * Permission is hereby granted to use, copy, modify, and distribute this * */
+/* * source code, or portions hereof, for any purpose, without fee, subject * */
+/* * to the following restrictions:                                         * */
+/* *                                                                        * */
+/* * 1. The origin of this source code must not be misrepresented;          * */
+/* *    you must not claim that you wrote the original software.            * */
+/* *                                                                        * */
+/* * 2. Altered versions must be plainly marked as such and must not be     * */
+/* *    misrepresented as being the original source.                        * */
+/* *                                                                        * */
+/* * 3. This Copyright notice may not be removed or altered from any source * */
+/* *    or altered source distribution.                                     * */
+/* *                                                                        * */
+/* * The Contributing Authors specifically permit, without fee, and         * */
+/* * encourage the use of this source code as a component to supporting     * */
+/* * the MNG and JNG file format in commercial products.  If you use this   * */
+/* * source code in a product, acknowledgment would be highly appreciated.  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Parts of this software have been adapted from the libpng package.      * */
+/* * Although this library supports all features from the PNG specification * */
+/* * (as MNG descends from it) it does not require the libpng package.      * */
+/* * It does require the zlib library and optionally the IJG jpeg library,  * */
+/* * and/or the "little-cms" library by Marti Maria (depending on the       * */
+/* * inclusion of support for JNG and Full-Color-Management respectively.   * */
+/* *                                                                        * */
+/* * This library's function is primarily to read and display MNG           * */
+/* * animations. It is not meant as a full-featured image-editing           * */
+/* * component! It does however offer creation and editing functionality    * */
+/* * at the chunk level.                                                    * */
+/* * (future modifications may include some more support for creation       * */
+/* *  and or editing)                                                       * */
+/* *                                                                        * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/README b/src/3rdparty/libmng/README
new file mode 100644
index 0000000..a8e67ca
--- /dev/null
+++ b/src/3rdparty/libmng/README
@@ -0,0 +1,36 @@
+libmng 1.0.10
+-------------
+
+Added provisional ANG and anIM support, and made some minor bugfixes.
+
+libmng 1.0.9
+------------
+
+A number of optimizations in the chunk handling and reader/writer code.
+This saves over 20KB on binary footprint!
+
+Also several bugfixes and a couple of patches bring it another step
+closer to perfection.... :-)
+
+See CHANGELOG for details.
+
+
+Y.T.
+
+Gerard
+
+
+For more information please visit:
+
+The official libmng web-site:
+  http://www.libmng.com/
+
+Libmng's community on SourceForge:
+  https://sourceforge.net/project/?group_id=5635
+
+The official MNG homepage:
+  http://www.libpng.org/pub/mng/
+
+The official PNG homepage:
+  http://www.libpng.org/pub/png/
+
diff --git a/src/3rdparty/libmng/README.autoconf b/src/3rdparty/libmng/README.autoconf
new file mode 100644
index 0000000..753f7b4
--- /dev/null
+++ b/src/3rdparty/libmng/README.autoconf
@@ -0,0 +1,213 @@
+**********************************************************************
+**********************************************************************
+
+                ***** this is unmaintained *****
+
+If you happen to find problems with autoconfiguration and building,
+I simply cannot help you. I'm looking for a maintainer that doesn't mind
+spending a few minutes every now and then on the next release to make sure
+things are still in working order.
+
+For the moment all autoconf stuff ahs been moved into unmaintained!!
+
+**********************************************************************
+**********************************************************************
+
+
+
+
+Configuration from CVS
+======================
+
+If you're using source checked out from CVS, rather than a source
+distribution tarball, please be aware that you can use ./autogen.sh in
+place of ./configure below.
+
+Because this is a cross-platform project, the source templates for
+the autoconf scripts are sequestered in the 'makefiles' directory.
+Running './autogen.sh' will copy them into their conventional places at
+the lop level. If you already see the files there, you don't need to
+worry about this step.
+
+Basic Installation
+==================
+
+   These are generic installation instructions.
+
+   The `configure' shell script attempts to guess correct values for
+various system-dependent variables used during compilation.  It uses
+those values to create a `Makefile' in each directory of the package.
+It may also create one or more `.h' files containing system-dependent
+definitions.  Finally, it creates a shell script `config.status' that
+you can run in the future to recreate the current configuration, a file
+`config.cache' that saves the results of its tests to speed up
+reconfiguring, and a file `config.log' containing compiler output
+(useful mainly for debugging `configure').
+
+   If you need to do unusual things to compile the package, please try
+to figure out how `configure' could check whether to do them, and mail
+diffs or instructions to the address given in the `README' so they can
+be considered for the next release.  If at some point `config.cache'
+contains results you don't want to keep, you may remove or edit it.
+
+   The file `configure.in' is used to create `configure' by a program
+called `autoconf'.  You only need `configure.in' if you want to change
+it or regenerate `configure' using a newer version of `autoconf'.
+
+The simplest way to compile this package is:
+
+  1. `cd' to the directory containing the package's source code and type
+     `./configure' to configure the package for your system.  If you're
+     using `csh' on an old version of System V, you might need to type
+     `sh ./configure' instead to prevent `csh' from trying to execute
+     `configure' itself.
+
+     Running `configure' takes awhile.  While running, it prints some
+     messages telling which features it is checking for.
+
+  2. Type `make' to compile the package.
+
+  3. Optionally, type `make check' to run any self-tests that come with
+     the package.
+
+  4. Type `make install' to install the programs and any data files and
+     documentation.
+
+  5. You can remove the program binaries and object files from the
+     source code directory by typing `make clean'.  To also remove the
+     files that `configure' created (so you can compile the package for
+     a different kind of computer), type `make distclean'.  There is
+     also a `make maintainer-clean' target, but that is intended mainly
+     for the package's developers.  If you use it, you may have to get
+     all sorts of other programs in order to regenerate files that came
+     with the distribution.
+
+Compilers and Options
+=====================
+
+   Some systems require unusual options for compilation or linking that
+the `configure' script does not know about.  You can give `configure'
+initial values for variables by setting them in the environment.  Using
+a Bourne-compatible shell, you can do that on the command line like
+this:
+     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
+
+Or on systems that have the `env' program, you can do it like this:
+     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
+
+Compiling For Multiple Architectures
+====================================
+
+   You can compile the package for more than one kind of computer at the
+same time, by placing the object files for each architecture in their
+own directory.  To do this, you must use a version of `make' that
+supports the `VPATH' variable, such as GNU `make'.  `cd' to the
+directory where you want the object files and executables to go and run
+the `configure' script.  `configure' automatically checks for the
+source code in the directory that `configure' is in and in `..'.
+
+   If you have to use a `make' that does not supports the `VPATH'
+variable, you have to compile the package for one architecture at a time
+in the source code directory.  After you have installed the package for
+one architecture, use `make distclean' before reconfiguring for another
+architecture.
+
+Installation Names
+==================
+
+   By default, `make install' will install the package's files in
+`/usr/local/bin', `/usr/local/man', etc.  You can specify an
+installation prefix other than `/usr/local' by giving `configure' the
+option `--prefix=PATH'.
+
+   You can specify separate installation prefixes for
+architecture-specific files and architecture-independent files.  If you
+give `configure' the option `--exec-prefix=PATH', the package will use
+PATH as the prefix for installing programs and libraries.
+Documentation and other data files will still use the regular prefix.
+
+   In addition, if you use an unusual directory layout you can give
+options like `--bindir=PATH' to specify different values for particular
+kinds of files.  Run `configure --help' for a list of the directories
+you can set and what kinds of files go in them.
+
+   If the package supports it, you can cause programs to be installed
+with an extra prefix or suffix on their names by giving `configure' the
+option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
+
+Optional Features
+=================
+
+   Some packages pay attention to `--enable-FEATURE' options to
+`configure', where FEATURE indicates an optional part of the package.
+They may also pay attention to `--with-PACKAGE' options, where PACKAGE
+is something like `gnu-as' or `x' (for the X Window System).  The
+`README' should mention any `--enable-' and `--with-' options that the
+package recognizes.
+
+   For packages that use the X Window System, `configure' can usually
+find the X include and library files automatically, but if it doesn't,
+you can use the `configure' options `--x-includes=DIR' and
+`--x-libraries=DIR' to specify their locations.
+
+Specifying the System Type
+==========================
+
+   There may be some features `configure' can not figure out
+automatically, but needs to determine by the type of host the package
+will run on.  Usually `configure' can figure that out, but if it prints
+a message saying it can not guess the host type, give it the
+`--host=TYPE' option.  TYPE can either be a short name for the system
+type, such as `sun4', or a canonical name with three fields:
+     CPU-COMPANY-SYSTEM
+
+See the file `config.sub' for the possible values of each field.  If
+`config.sub' isn't included in this package, then this package doesn't
+need to know the host type.
+
+   If you are building compiler tools for cross-compiling, you can also
+use the `--target=TYPE' option to select the type of system they will
+produce code for and the `--build=TYPE' option to select the type of
+system on which you are compiling the package.
+
+Sharing Defaults
+================
+
+   If you want to set default values for `configure' scripts to share,
+you can create a site shell script called `config.site' that gives
+default values for variables like `CC', `cache_file', and `prefix'.
+`configure' looks for `PREFIX/share/config.site' if it exists, then
+`PREFIX/etc/config.site' if it exists.  Or, you can set the
+`CONFIG_SITE' environment variable to the location of the site script.
+A warning: not all `configure' scripts look for a site script.
+
+Operation Controls
+==================
+
+   `configure' recognizes the following options to control how it
+operates.
+
+`--cache-file=FILE'
+     Use and save the results of the tests in FILE instead of
+     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
+     debugging `configure'.
+
+`--help'
+     Print a summary of the options to `configure', and exit.
+
+`--quiet'
+`--silent'
+`-q'
+     Do not print messages saying which checks are being made.  To
+     suppress all normal output, redirect it to `/dev/null' (any error
+     messages will still be shown).
+
+`--srcdir=DIR'
+     Look for the package's source code in directory DIR.  Usually
+     `configure' can determine that directory automatically.
+
+`--version'
+     Print the version of Autoconf used to generate the `configure'
+     script, and exit.
+
+`configure' also accepts some other, not widely useful, options.
diff --git a/src/3rdparty/libmng/README.config b/src/3rdparty/libmng/README.config
new file mode 100644
index 0000000..d5cd454
--- /dev/null
+++ b/src/3rdparty/libmng/README.config
@@ -0,0 +1,104 @@
+Configuration options in libmng
+===============================
+
+The library is fairly configurable through the use of a number of defines.
+Please note however that certain defines are for internal use only.
+The following list gives a summary of options that can be used externally to
+define the functionality of the library:
+
+========================================
+
+#define MNG_BUILD_DLL
+
+This is used to indicate that a "standard" DLL should result from compiling
+the library. Please note the remarks in README.dll if you intend to work
+with the library as a DLL. The purpose of this option is to ensure that
+DLL builds have the same set of functions.
+
+#define MNG_BUILD_SO
+
+This is used to indicate that a "standard" shared library (SO) should result
+from a compilation. The purpose of this option is to ensure that all
+shared libraries generated this way will have the same set of functions.
+
+#define MNG_USE_DLL / #define MNG_USE_SO
+
+These should be used when including the library header in the compilation
+of an application to indicate that the compiler/linker must take the
+necessary steps to make the binary executable to use the standard DLL
+or shared library (SO).
+
+#define MNG_SKIP_ZLIB / #define MNG_SKIP_LCMS / #define MNG_SKIP_IJG6B
+
+Use these in conjunction with MNG_USE_DLL / MNG_USE_SO. This is useful if
+you only need the external definitions of the MNG library and not the others,
+which will speed up the compilation process.
+
+#define MNG_SUPPORT_FULL / #define MNG_SUPPORT_LC / #define MNG_SUPPORT_VLC
+
+These can be used to indicate the level of MNG spec compliance required.
+Currently only full MNG compliance is supported.
+
+#define MNG_SUPPORT_IJG6B
+
+This can be used to indicate if JNG support is required. This option will
+include the IJG JPEG-library. Note that MNG_SUPPORT_FULL will automatically
+set this option. Use this only if you need JNG support with MNG-(V)LC.
+
+#define MNG_FULL_CMS / #define MNG_GAMMA_ONLY / #define MNG_NO_CMS /
+#define MNG_APP_CMS
+
+These indicate the color-correction support level of the library.
+If you are on a platform that supports lcms (Little CMS by Marti Maria Saguar)
+then it is highly recommended to define MNG_FULL_CMS.
+If your platform has it's own CMS then select MNG_APP_CMS and be sure to
+include the appropriate callbacks in your app.
+In all other cases it is recommended to define MNG_GAMMA_ONLY.
+
+#define MNG_SUPPORT_READ / #define MNG_SUPPORT_WRITE /
+#define MNG_SUPPORT_DISPLAY
+
+These indicate the high-level support for reading, writing and/or
+displaying files. Note that in order to display a file, you'll need to read
+it first. (yes, really!)
+
+#define MNG_STORE_CHUNKS
+
+This indicates that the library should store chunk-information when reading
+a file. This information can then be processed through the
+MNG_ITERATE_CHUNKS() function. Note that you must specify this option if
+you want to create and write a new file.
+
+#define MNG_ACCESS_CHUNKS
+
+This is used to indicate that the app may need access to internally stored
+chunk information. MNG_STORE_CHUNKS must be defined as well for this option
+to function properly.
+
+#define MNG_INTERNAL_MEMMNGMT
+
+You can use this to have the library handle it's own memory allocation and
+deallocation through the "standard" memory functions. This option is turned
+off by default, which means your app must define the memory callbacks.
+
+#define MNG_ERROR_TELLTALE
+
+Set this on to allow human-readable error-messages to be included in the
+library and the error function and callback.
+
+#define MNG_BIGENDIAN_SUPPORTED
+
+This option should be used to indicate the hardware is based on big endian
+integers.
+
+#define MNG_SUPPORT_TRACE / #define MNG_TRACE_TELLTALE
+
+These two can be used when debugging an app. You'll need to have the trace
+callback setup also. This allows for a rather thorough investigation of the
+libraries function paths.
+
+========================================
+
+Any other optional defines you may encounter are for internal use only.
+please do not specify them externally. In case of doubt, consult the
+support email lists. More info can be found on http://www.libmng.com
diff --git a/src/3rdparty/libmng/README.contrib b/src/3rdparty/libmng/README.contrib
new file mode 100644
index 0000000..9b28753
--- /dev/null
+++ b/src/3rdparty/libmng/README.contrib
@@ -0,0 +1,95 @@
+The contrib directory contains contributions made by fellow
+enthousiasts. (Check respective web-sites for the latest version)
+
+----------------------------------------------------------------------
+
+mngplg - A Netscape plugin for MNG - by Jason Summers
+
+http://pobox.com/~jason1/imaging/mngplg/
+
+The very first contribution, and what a start!
+GIF look out, MNG is on the prowl and ready to swat you like a fly!
+
+----------------------------------------------------------------------
+
+mngplay - An SDL based MNG viewer - by Ralph Giles
+
+http://snow.ashlu.bc.ca/~giles/mng/
+
+Another nice contribution. View MNG files on practically any platform
+with this standalone viewer.
+Source-code only; Requires SDL library and libmng.so
+
+(Modified by Greg Roelofs)
+
+----------------------------------------------------------------------
+
+mngview - A BCB port of the Delphi sample - by Andy Protano
+
+I have added this nice little port to the BCB samples directory.
+It adds a nifty progressbar while reading a file. Excellent work!
+Requires libmng.dll
+(note: this is in the BCB samples directory)
+
+----------------------------------------------------------------------
+
+mngdump - A BCB GUI-based dump utility - by Andy Protano
+
+Andy has sent me this fully functional MNG dump utility, that gives
+detailed information of the contents of any MNG file.
+Requires libmng.dll
+
+----------------------------------------------------------------------
+
+mng-view - A GTK-based MNG viewer - by Vova Babin
+
+Vova has been hacking away with the libmng code and has come up with
+this nice little sample how to write a MNG viewer using GTK.
+Thanks mate!
+Source-code only
+Requires GTK+ (1.2 or higher) and libmng (0.9.2 or higher)
+
+(Modified by Greg Roelofs)
+
+----------------------------------------------------------------------
+
+mngview - Another MNG viewer; this one for MSVC - by Nicholaus Brennig
+
+A welcome contribution from Nicholaus. Author of SlowView. A very nice
+image-handling utility for Windows. A welcome contribution since there
+have been numerous questions about linking libmng with MSVC.
+Well, look no further. Here it is!
+
+----------------------------------------------------------------------
+
+MSVC libmng project - An MSVC project to build libmng.dll
+                    - by Chad Austin
+
+Chad has contributed some project-files that you could use to build
+libmng.dll with MSVC. Please be sure to read the README file included.
+
+----------------------------------------------------------------------
+
+fbmngplay - A simple fbcon based mng player - by Stefan Reinauer
+
+Stefan has contributed this little example, based on Ralph's
+SDL player. It uses the kernel framebuffer device to display mng
+animations through the libmng interface.
+(currently for 16-bit buffers only)
+
+----------------------------------------------------------------------
+
+xmngview - Lesstif/Motif standalone player for MNG files
+         - by Winfried Szukalski
+
+Winfried contributed this MNG player for X-based systems.
+(recently updated)
+
+----------------------------------------------------------------------
+
+makemng - A delta-MNG creation utility for MSVC - by Alex Volkov
+
+Alex sent me this nice utility that will allow you to create highly
+optmized MNGs using the delta-PNG capabilities of MNG.
+
+----------------------------------------------------------------------
diff --git a/src/3rdparty/libmng/README.dll b/src/3rdparty/libmng/README.dll
new file mode 100644
index 0000000..2f779e8
--- /dev/null
+++ b/src/3rdparty/libmng/README.dll
@@ -0,0 +1,41 @@
+Standard Windows DLL
+====================
+
+The DLL provided in the BCB/win32dll directory is meant as the sole candidate
+for distributions, based on libmng.dll, that install the DLL into the public
+Windows system-directory. The outline herein defines the requirements to
+which such a distribution must comply. If you cannot comply with these
+requirements please install the dll in the same directory as your application
+and NOT in the Windows system-directory!!!
+
+
+1) Only the DLL already assembled in the libmng distribution may be used for
+   other distributions!
+
+2) Only stable public releases are eligible for distribution! A public release
+   is one where the y-value of the x.y.z version-code is an even number.
+   Eg. 1.0.0, 1.2.1, 2.4.7, etc.
+
+3) The installation program MUST store the DLL in the Windows system-directory!
+   Eg. C:\WinNT\System32, C:\Windows98\System
+   (Note: InstallShield users can use the <SYSDIR> variable)
+
+3) The installation program MUST flag the file as a shared library!
+
+4) The installation program MUST NOT install the DLL if a newer version
+   already exists in the Windows system-directory! The standard DLL provided
+   contains the Windows-default version-numbering system. PLEASE USE IT!!
+   DO NOT rely on the date or size of the files.
+
+5) An uninstall procedure MAY NOT remove the DLL if other applications are
+   still linked to it! Proper handling as a shared library is imperitive.
+
+6) TEST IT, TEST IT, TEST IT!!! (I just can't stress this enough)
+   If you don't have enough time, let someone else test it BEFORE you
+   distribute!
+
+
+The penalty for violating these rules is inclusion of your name in the list
+of endangered but useless species (just below the GIF entry!), and on my
+blacklist. YOU HAVE BEEN FOREWARNED!
+
diff --git a/src/3rdparty/libmng/README.examples b/src/3rdparty/libmng/README.examples
new file mode 100644
index 0000000..1ba94c1
--- /dev/null
+++ b/src/3rdparty/libmng/README.examples
@@ -0,0 +1,48 @@
+The samples are in platform-specific directories.
+
+!!! contributions are very welcome !!!
+
+
+bcb - Borland C++ Builder (3.0) (found under bcb/xxx)
+-----------------------------------------------------
+
+win32dll - sample project to create a Windows dll. Requires zlib1.2.1,
+           IJG jpgsrc6b and lcms1.0.14. The directories containing these
+           libraries must be at the same level as the libmng directory.
+           So if you're in the directory with this file and the libmng
+           sources, they should be in ..\zlib , ..\jpgsrc6b and ..\lcms
+           respectively.
+
+!!!        To run the other Win32 samples you need to copy the libmng.dll
+           file from here into the sample's directory !!!
+
+mngtree  - sample project to create a little command-line tool that dumps
+           the chunk-structure of a given file onto stdout.
+
+bogus    - a completely bogus example on how to create a perfectly valid
+           (though slightly biased) MNG.
+
+mngview  - port of the Delphi mngview sample. contributed by Andy Protano.
+           see also README.contrib
+
+mngrepair- an example on how to fix invalid MNG files
+           uses the new mng_copy_chunks() function and MNG_SOFTERRORS to
+           'ignore' certain input-errors. This conditional *MUST* only be used
+           for exactly this kind of software; eg. repair utilities.
+
+
+delphi - Borland Delphi (3.0+) (found under contrib/delphi/xxx)
+---------------------------------------------------------------
+
+mngview  - sample project for a simple mng-viewer. The general unit in
+           the delphi directory was translated from libmng.h It can be
+           used in other projects to access libmng.dll created with the
+           win32dll example above.
+
+
+unix - Unix (found under contrib/gcc/xxx)
+-----------------------------------------
+
+mngtree  - basically a copy of the BCB sample. It includes a makefile for
+           Linux and it's been tested on RedHat6.2
+
diff --git a/src/3rdparty/libmng/README.footprint b/src/3rdparty/libmng/README.footprint
new file mode 100644
index 0000000..34dba7f
--- /dev/null
+++ b/src/3rdparty/libmng/README.footprint
@@ -0,0 +1,46 @@
+/*
+   You can use one or more of the following defines to
+   reduce the size of the compiled library.  Define the
+   SKIPCANVAS macros for any canvas configurations that
+   your application doesn't use.  Define the SKIPCHUNK
+   macros for any chunks that your application doesn't
+   process.  Define MNG_OPTIMIZE_FOOTPRINT to choose
+   smaller code size over faster execution and less memory
+   usage.  These macros became available in version 1.0.6.
+*/
+
+/* eliminate unused features from libmng */
+#define MNG_OPTIMIZE_FOOTPRINT
+#define MNG_OPTIMIZE_OBJCLEANUP
+#define MNG_OPTIMIZE_CHUNKINITFREE
+#define MNG_OPTIMIZE_CHUNKASSIGN
+#define MNG_OPTIMIZE_CHUNKREADER
+
+#define MNG_SKIPCANVAS_ABGR8
+#define MNG_SKIPCANVAS_ARGB8
+#define MNG_SKIPCANVAS_BGR8
+#define MNG_SKIPCANVAS_BGRA8
+#define MNG_SKIPCANVAS_BGRA8_PM
+#define MNG_SKIPCANVAS_BGRX8
+#define MNG_SKIPCANVAS_RGBA8
+#define MNG_SKIPCANVAS_BGR565
+#define MNG_SKIPCANVAS_RGB565
+#define MNG_SKIPCANVAS_BGRA565
+#define MNG_SKIPCANVAS_RGBA565
+
+#define MNG_SKIPCHUNK_iCCP
+#define MNG_SKIPCHUNK_tEXt
+#define MNG_SKIPCHUNK_zTXt
+#define MNG_SKIPCHUNK_iTXt
+#define MNG_SKIPCHUNK_bKGD
+#define MNG_SKIPCHUNK_pHYs
+#define MNG_SKIPCHUNK_sBIT
+#define MNG_SKIPCHUNK_sPLT
+#define MNG_SKIPCHUNK_hIST
+#define MNG_SKIPCHUNK_tIME
+#define MNG_SKIPCHUNK_eXPI
+#define MNG_SKIPCHUNK_fPRI
+#define MNG_SKIPCHUNK_nEED
+#define MNG_SKIPCHUNK_pHYg
+
+
diff --git a/src/3rdparty/libmng/README.packaging b/src/3rdparty/libmng/README.packaging
new file mode 100644
index 0000000..da0db3e
--- /dev/null
+++ b/src/3rdparty/libmng/README.packaging
@@ -0,0 +1,24 @@
+Packaging Libmng for distribution
+---------------------------------
+
+These are some notes for those building binaries for distribution.
+
+We're interested to hear about anywhere libmng is helpful, so let us
+know if you're including it with your application or OS. Also, if your
+build is publicly accessible, we'd be happy to link to it from
+the libmng site.
+
+However, We respectfully request that you *not* distribute binaries as a
+shared library (DLL) with any of the major features disabled. While
+there is support for this in terms of #ifdef directives (in
+libmng_conf.h) and autoconf switches they are intended for embedded
+application and testing. The default compilation options support the
+full MNG specification, and we wish to avoid the confusion among
+general users that partial support would engender.
+
+
+Platform specific notes:
+
+We have a basic .spec file for generating rpms. Send us a note if you'd
+like to clean it up.
+
diff --git a/src/3rdparty/libmng/doc/Plan1.png b/src/3rdparty/libmng/doc/Plan1.png
new file mode 100644
index 0000000..ced5517
Binary files /dev/null and b/src/3rdparty/libmng/doc/Plan1.png differ
diff --git a/src/3rdparty/libmng/doc/Plan2.png b/src/3rdparty/libmng/doc/Plan2.png
new file mode 100644
index 0000000..3619ea6
Binary files /dev/null and b/src/3rdparty/libmng/doc/Plan2.png differ
diff --git a/src/3rdparty/libmng/doc/doc.readme b/src/3rdparty/libmng/doc/doc.readme
new file mode 100644
index 0000000..e92e93c
--- /dev/null
+++ b/src/3rdparty/libmng/doc/doc.readme
@@ -0,0 +1,19 @@
+This directory hosts the documentation for libmng.
+
+You will find a lot of useful info on the web-site:
+http://www.libmng.com
+
+Man-pages are in the man sub-directory
+
+RPM specification files are in the RPM sub-directory
+
+Files in this directory:
+
+- libmng.txt
+
+Description of the library proper and its usage
+
+- Plan1.png & Plan2.png
+
+Visual representation of the functional and technical
+design of the library (in PNG format of course!)
diff --git a/src/3rdparty/libmng/doc/libmng.txt b/src/3rdparty/libmng/doc/libmng.txt
new file mode 100644
index 0000000..b9e9bc4
--- /dev/null
+++ b/src/3rdparty/libmng/doc/libmng.txt
@@ -0,0 +1,1107 @@
+libmng - Multiple-image Network Graphics (MNG) Reference Library 1.0.9
+
+DESCRIPTION
+The libmng library supports decoding, displaying, encoding, and various
+other manipulations of the Multiple-image Network Graphics (MNG) format
+image files. It uses the zlib compression library, and optionally the
+JPEG library by the Independant JPEG Group (IJG) and/or
+lcms (little cms), a color-management library by Marti Maria Saguer.
+
+
+I. Introduction
+
+This file describes how to use and modify the MNG reference library
+(known as libmng) for your own use.  There are seven sections to this
+file: introduction, callbacks, housekeeping, reading, displaying,
+writing, and modification and configuration notes for various special
+platforms. We assume that libmng is already installed; see the
+INSTALL.README file for instructions on how to install libmng.
+
+Libmng was written to support and promote the MNG specification.
+
+The latest MNG specification (currently 1.0) is available at
+  http://www.libpng.org/pub/mng/
+
+Other information about MNG can be found at the MNG home page at
+  http://www.libpng.org/pub/mng/
+
+The latest version of libmng can be found at its own homepage at
+  http://www.libmng.com/
+
+In most cases the library will not need to be changed.
+For standardization purposes the library contains both a Windows DLL
+and a makefile for building a shared library (SO). The library is
+written in C, but an interface for Borland Delphi is also available.
+
+Libmng has been designed to handle multiple sessions at one time,
+to be easily modifiable, to be portable to the vast majority of
+machines (ANSI, K&R, 32-, and 64-bit) available, and to be easy
+to use.
+
+Libmng uses zlib for its compression and decompression of MNG files.
+Further information about zlib, and the latest version of zlib, can be
+found at the zlib home page, <http://www.zlib.org/>.
+The zlib compression utility is a general purpose utility that is
+useful for more than MNG/PNG files, and can be used without libmng.
+See the documentation delivered with zlib for more details.
+
+Libmng optionally uses the JPEG library by the Independant JPEG Group
+(IJG). This library is used for the JNG sub-format, which is part of
+the MNG specification, and allows for inclusion of JPEG decoded and
+thus highly compressed (photographic) images.
+Further information about the IJG JPEG library and the latest sources
+can be found at <http://www.ijg.org/>.
+
+Libmng can also optionally use the lcms (little CMS) library by
+Marti Maria Saguer. This library provides an excellent color-management
+system (CMS), which gives libmng the ability to provide full
+color-correction for images with the proper color-information encoded.
+Further information and the latest sources can be found at
+<http://www.littlecms.com/>.
+
+Libmng is thread safe, provided the threads are using different
+handles as returned by the initialization call.
+Each thread should have its own handle and thus its own image.
+Libmng does not protect itself against two threads using the
+same instance of a handle.
+
+The libmng.h header file is the single reference needed for programming
+with libmng:
+
+#include <libmng.h>
+
+
+II. Callbacks
+
+Libmng makes extensive use of callback functions. This is meant to
+keep the library as platform-independant and flexible as possible.
+Actually, the first call you will make to the library, already contains
+three parameters you can use to provide callback entry-points.
+
+Most functions must return a mng_bool (boolean). Returning MNG_FALSE
+indicates the library the callback failed in some way and the library
+will immediately return from whatever it was doing back to the
+application. Returning MNG_TRUE indicates there were no problems and
+processing can continue.
+
+Let's step through each of the possible callbacks. The sections on
+reading, displaying and writing will also explain which callbacks are
+needed when and where.
+
+- mng_ptr mng_memalloc (mng_size_t iLen)
+
+A very basic function which the library uses to allocate a memory-block
+with the given size. A typical implementation would be:
+
+    mng_ptr my_alloc (mng_size_t iLen) {
+      return calloc (1, iSize);
+    }
+
+Note that the library requires you to zero-out the memory-block!!!
+
+- void mng_memfree (mng_ptr    pPtr,
+                    mng_size_t iLen)
+
+Counterpart of the previous function. Typically:
+
+    void my_free (mng_ptr pPtr, mng_size_t iLen) {
+      free (pPtr);
+    }
+
+- mng_bool mng_openstream  (mng_handle hHandle)
+- mng_bool mng_closestream (mng_handle hHandle)
+
+These are called by the library just before it starts to process
+(either read or write) a file and just after the processing stops.
+This is the recommended place to do I/O initialization & finalization.
+Whether you do or not, is up to you. The library does not put any
+meaning into the calls. They are simply provided for your convenience.
+
+- mng_bool mng_readdata (mng_handle  hHandle,
+                         mng_ptr     pBuf,
+                         mng_uint32  iBuflen,
+                         mng_uint32p pRead)
+
+This function is called when the library needs some more input while
+reading an image. The reading process supports two modes:
+Suspension-mode (SMOD) and non-suspension-mode (NSMOD).
+See mng_set_suspensionmode() for a more detailed description.
+
+In NSMOD, the library requires you to return exactly the amount of bytes
+requested (= iBuflen). Any lesser amount indicates the input file
+is exhausted and the library will return a MNG_UNEXPECTEDEOF errorcode.
+
+In SMOD, you may return a smaller amount of bytes than requested.
+This tells the library it should temporarily wait for more input to
+arrive. The lib will return with MNG_NEEDMOREDATA, and will expect a
+call to mng_read_resume() or mng_display_resume() next, as soon as
+more input-data has arrived.
+
+For NSMOD this function could be as simple as:
+
+    mng_bool my_read (mng_handle  hHandle,
+                      mng_ptr     pBuf,
+                      mng_uint32  iBuflen,
+                      mng_uint32p pRead) {
+      *pRead = fread (pBuf, 1, iBuflen, myfile);
+      return MNG_TRUE;
+    }
+
+- mng_bool mng_writedata (mng_handle  hHandle,
+                          mng_ptr     pBuf,
+                          mng_uint32  iBuflen,
+                          mng_uint32p pWritten)
+
+This function is called during the mng_write() function to actually
+output data to the file. There is no suspension-mode during write,
+so the application must return the exact number of bytes the library
+requests to be written.
+
+A typical implementation could be:
+
+    mng_bool my_write (mng_handle  hHandle,
+                       mng_ptr     pBuf, 
+                       mng_uint32  iBuflen,
+                       mng_uint32p pWritten) {
+      *pWritten = fwrite (pBuf, 1, iBuflen, myfile);
+      return MNG_TRUE;
+    }
+
+- mng_bool mng_errorproc (mng_handle  hHandle,
+                          mng_int32   iErrorcode,
+                          mng_int8    iSeverity,
+                          mng_chunkid iChunkname,
+                          mng_uint32  iChunkseq,
+                          mng_int32   iExtra1,
+                          mng_int32   iExtra2,
+                          mng_pchar   zErrortext)
+
+This function is called whenever an error is detected inside the
+library. This may be caused by invalid input, callbacks indicating
+failure, or wrongfully calling functions out of place.
+
+If you do not provide this callback the library will still return
+an errorcode from the called function, and the mng_getlasterror()
+function can be used to retrieve the other parameters.
+
+This function is currently only provided for convenience, but may
+at some point be used to indicate certain errors may be acceptable,
+and processing should continue.
+
+- mng_bool mng_traceproc (mng_handle hHandle,
+                          mng_int32  iFuncnr,
+                          mng_int32  iFuncseq,
+                          mng_pchar  zFuncname)
+
+This function is provided to allow a functional analysis of the
+library. This may be useful if you encounter certain errors and
+cannot determine what the problem is.
+
+Almost all functions inside the library will activate this
+callback with an appropriate function-name at the start and end
+of the function. Please note that large images may generate an
+enormous amount of calls.
+
+- mng_bool mng_processheader (mng_handle hHandle,
+                              mng_uint32 iWidth,
+                              mng_uint32 iHeight)
+
+This function is called once the header information of an input-
+image has been processed. At this point the image dimensions are
+available and also some other properties depending on the type
+of the image. Eg. for a MNG the frame-/layercount, playtime &
+simplicity fields are known.
+
+The primary purpose of this callback is to inform the application
+of the size of the image, and for the application to initialize
+the drawing canvas to be used by the library. This is also a good
+point to set the canvas-style. Eg. mng_set_canvasstyle().
+
+- mng_bool mng_processtext (mng_handle hHandle,
+                            mng_uint8  iType,
+                            mng_pchar  zKeyword,
+                            mng_pchar  zText,
+                            mng_pchar  zLanguage,
+                            mng_pchar  zTranslation)
+
+This callback is activated for each textual chunk in the input-
+image. These are tEXt, zTXt & iTXt. It may be used to retain
+specific comments for presentation to the user.
+
+- mng_bool mng_processsave (mng_handle hHandle)
+- mng_bool mng_processseek (mng_handle hHandle,
+                            mng_pchar  zName)
+
+The purpose of these callbacks is to signal the processing of the
+SAVE & SEEK chunks in a MNG input-file. This may be used in the
+future to specify some special processing. At the moment these
+functions are only provided as a signal.
+
+- mng_ptr mng_getcanvasline (mng_handle hHandle,
+                             mng_uint32 iLinenr)
+- mng_ptr mng_getbkgdline   (mng_handle hHandle,
+                             mng_uint32 iLinenr)
+- mng_ptr mng_getalphaline  (mng_handle hHandle,
+                             mng_uint32 iLinenr)
+
+These callbacks are used to access the drawing canvas, background
+canvas and an optional separate alpha-channel canvas. The latter is
+used only with the MNG_CANVAS_RGB8_A8 canvas-style.
+
+If the getbkgdline() callback is not supplied the library will
+composite full or partially transparent pixels in the image against
+a specified background color. See mng_set_bgcolor() for more details.
+If a chosen canvas-style includes an alpha-channel, this callback
+is very likely not needed.
+
+The application is responsible for returning a pointer to a line of
+pixels, which should be in the exact format as defined by the call
+to mng_set_canvasstyle() and mng_set_bkgdstyle(), without gaps between
+the representation of each pixel.
+
+- mng_bool mng_refresh (mng_handle hHandle,
+                        mng_uint32 iX,
+                        mng_uint32 iY,
+                        mng_uint32 iWidth,
+                        mng_uint32 iHeight)
+
+This callback is called when the library has drawn a complete frame
+onto the drawing canvas, and it is ready to be displayed.
+The application is responsible for transferring the drawing canvas
+from memory onto the actual output device.
+
+- mng_uint32 mng_gettickcount (mng_handle hHandle)
+
+This function should return the number of milliseconds on some internal
+clock. The entire animation timing depends heavily on this function,
+1and the number returned should be as accurate as possible.
+
+- mng_bool mng_settimer (mng_handle hHandle,
+                         mng_uint32 iMsecs)
+
+This callback is activated every time the library requires a "pause".
+Note that the function itself should NOT execute the wait. It should
+simply store the time-field and allow the library to return. Libmng
+will return with the MNG_NEEDTIMERWAIT code, indicating the callback
+was called and it is now time to execute the pause.
+
+After the indicated number of milliseconds have elapsed, the application
+should call mng_display_resume(), to resume the animation as planned.
+
+This method allows for both a real timer or a simple wait command in the
+application. Whichever method you select, both the gettickcount() and
+settimer() callbacks are crucial for proper animation timing.
+
+- mng_bool mng_processgamma  (mng_handle hHandle,
+                              mng_uint32 iGamma)
+- mng_bool mng_processchroma (mng_handle hHandle,
+                              mng_uint32 iWhitepointx,
+                              mng_uint32 iWhitepointy,
+                              mng_uint32 iRedx,
+                              mng_uint32 iRedy,
+                              mng_uint32 iGreenx,
+                              mng_uint32 iGreeny,
+                              mng_uint32 iBluex,
+                              mng_uint32 iBluey)
+- mng_bool mng_processsrgb   (mng_handle hHandle,
+                              mng_uint8  iRenderingintent)
+- mng_bool mng_processiccp   (mng_handle hHandle,
+                              mng_uint32 iProfilesize,
+                              mng_ptr    pProfile)
+- mng_bool mng_processarow   (mng_handle hHandle,
+                              mng_uint32 iRowsamples,
+                              mng_bool   bIsRGBA16,
+                              mng_ptr    pRow)
+
+These callbacks are only required when you selected the MNG_APP_CMS
+directive during compilation of the library. See the configuration
+section for more details.
+
+- mng_bool mng_iteratechunk (mng_handle  hHandle,
+                             mng_handle  hChunk,
+                             mng_chunkid iChunkid,
+                             mng_uint32  iChunkseq)
+
+This callback is only used for the mng_iterate_chunks() function.
+It is called exactly once for each chunk stored.
+
+
+III. Housekeeping
+
+
+> Memory management
+
+The library can use internal memory allocation/deallocation or use
+provided callbacks for its memory management. The choice is made at
+compilation time. See the section on customization for details.
+
+If internal management has been selected, the memory callback functions
+need not be supplied. Even if you do supply them they will not be used.
+The actual code used is similar to the code discussed in the callback
+section:
+
+      pPtr = calloc (1, iSize);
+
+      free (pPtr);
+
+If your compiler does not support these functions, or you wish to monitor
+the library's use of memory for certain reasons, you can choose to
+compile the library with external memory management. In this case the
+memory callback functions MUST be supplied, and should function as if the
+above code was used.
+
+
+> Initialization
+
+The basic initialization of the library is short and swift:
+
+    myhandle = mng_initialize (myuserdata, my_alloc, 
+                               my_free, MNG_NULL);
+    if (myhandle == MNG_NULL)
+      /* process error */;
+
+The first field is an application-only parameter. It is saved in
+libmng's internal structures and available at all times through the
+mng_get_userdata() function. This is especially handy in callback functions
+if your program may be handling multiple files at the same time.
+
+The second and third field supply the library with the memory callback
+1function entry-points. These are described in more detail in the callback
+section and the previous paragraph.
+
+The fourth and last field may be used to supply the library with the
+entry-point of a trace callback function. For regular use you will not
+need this!
+
+The function returns a handle which will be your ticket to MNG-heaven.
+All other functions rely on this handle. It is the single fixed unique
+reference-point between your application and the library.
+
+You should call the initialization function for each image you wish to
+process simultaneously. If you are processing images consecutively, you can
+reset the internal status of the library with the mng_reset() function.
+This function will clear all internal state variables, free any stored
+chunks and/or objects, etc, etc. Your callbacks and other external parameters
+will be retained.
+
+After you successfully received the handle it is time to set the required
+callbacks. The sections on reading, displaying & writing indicate which
+callbacks are required and which are optional.
+To set the callbacks simply do:
+
+    myretcode = mng_setcb_xxxxxx (myhandle, my_xxxxxx);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Naturally you'd replace the x's with the name of the callback.
+
+
+> Cleanup
+
+Once you've gotten hold of that precious mng_handle, you should always,
+and I mean always, call the cleanup function when you're done.
+Just do:
+
+    mng_cleanup (myhandle);
+
+And you're done. There shouldn't be an ounce of memory spilled after
+that call.
+
+Note that if you would like to process multiple files consecutively
+you do not need to do mng_cleanup() / mng_initialize() between each file
+but simply
+
+    myretcode = mng_reset (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+will suffice. Saves some time and effort, that.
+
+
+> Error handling
+
+From the examples in the previous paragraphs you may have noticed a
+meticulous scheme for error handling. And yes, that's exactly what it is.
+Practically each call simply returns an errorcode, indicating success,
+eg. MNG_NOERROR or failure, anything else but MNG_NEEDMOREDATA and
+MNG_NEEDTIMERWAIT. These latter two will be discussed in more detail in
+their respective fields of interest: the reading section and displaying
+section respectively.
+
+It is the application's responsibility to check the returncode after
+each call. You can call mng_getlasterror() to receive the details of
+the last detected error. This even includes a discriptive error-message
+if you enabled that option during compilation of the library.
+
+Note that after receiving an error it is still possible to call the
+library, but it's also very likely that any following call will fail.
+The only functions deemed to work will be mng_reset() and mng_cleanup().
+Yes, if you abort your program after an error, you should still call
+mng_cleanup().
+
+
+IV. Reading
+
+Reading a MNG, JNG or PNG is fairly easy. It depends slightly on your
+ultimate goal how certain specifics are to be handled, but the basics
+are similar in all cases.
+
+For the read functioins to work you must have compiled the library with
+the MNG_READ_SUPPRT directive. The standard DLL and Shared Library
+have this on by default!
+
+
+> Setup
+
+Naturally you must have initialized the library and be the owner of
+a mng_handle. The following callbacks are essential:
+
+    mng_openstream, mng_readdata, mng_closestream
+
+You may optionally define:
+
+    mng_errorproc, mng_traceproc
+    mng_processheader, mng_processtext
+    mng_processsave, mng_processseek
+
+The reading bit will also fail if you are already creating or
+displaying a file. Seems a bit obvious, but I thought I'd mention it,
+just in case.
+
+
+> To suspend or not to suspend
+
+There is one choice you need to make before calling the read function.
+Are you in need of suspension-mode or not?
+
+If you're reading from a disk you most certainly do not need
+suspension-mode. Even the oldest and slowest of disks will be fast
+enough for straight reading.
+
+However, if your input comes from a really slow device, such as a
+dialup-line or the likes, you may opt for suspension-mode. This is done
+by calling
+
+    myretcode = mng_set_suspensionmode (myhandle,
+                                        MNG_TRUE);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Suspension-mode will force the library to use special buffering on the
+input. This allows your application to receive data of arbitrarily length
+and return this in the mng_readdata() callback, without disturbing the
+chunk processing routines of the library.
+
+Suspension-mode does require a little extra care in the main logic of the
+1application. The read function may return with MNG_NEEDMOREDATA when the
+mng_readdata() callback returns less data then it needs to process the
+next chunk. This indicates the application to wait for more data to arrive
+and then resume processing by calling mng_read_resume().
+
+
+> The read HLAPI
+
+The actual reading is just plain simple. Since all I/O is done
+1outside the library through the callbacks, the library can focus on
+its real task. Understanding, checking and labelling the input data!
+
+All you really need to do is this:
+
+    myretcode = mng_read (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Of course, if you're on suspension-mode the code is a little more
+complicated:
+
+    myretcode = mng_read (myhandle);
+
+    while (myretcode == MNG_NEEDMOREDATA) {
+      /* wait for input-data to arrive */
+      myretcode = mng_read_resume (myhandle);
+    } 
+   
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+This is rather crude and more sophisticated programming methods may
+dictate another approach. Whatever method you decide on, it should
+act as if the above code was in its place.
+
+There is also the mng_readdisplay() function, but this is discussed
+in the displaying section. It functions pretty much as the mng_read()
+function, but also immediately starts displaying the image.
+mng_read_resume() should be replaced by mng_display_resume() in that
+case!
+
+
+> What happens inside
+
+What actually happens inside the library depends on the configuration
+options set during the compilation of the library.
+
+Basically the library will first read the 8-byte file header, to determine
+its validity and the type of image it is about to process. Then it will
+repeatedly read a 4-byte chunk-length and then the remainder of the chunk
+until it either reaches EOF (indicated by the mng_readdata() callback) or
+implicitly decides EOF as it processed the logically last chunk of the
+image.
+
+Applications that require strict conformity and do not allow superfluous
+data after the ending chunk, will need to perform this check in their
+mng_closestream() callback.
+
+Each chunk is then checked on CRC, after which it is handed over to the
+appropriate chunk processing routine. These routines will disect the
+chunk, check the validity of its contents, check its position with respect
+to other chunks, etc, etc.
+
+If everything checks out, the chunk is further processed as follows:
+
+If display support has been selected during compilation, certain pre-display
+initialization will take place.
+
+If chunk-storage support has been selected during compilation, the chunks
+data may be stored in a special internal structure and held for future
+reference.
+
+
+> Storing and accessing chunks
+
+One of the compilation options activates support for chunk storage.
+This option may be useful if you want to examine an image. The directive
+is MNG_STORE_CHUNKS. You must also turn on the MNG_ACCESS_CHUNKS
+directive.
+
+The actual storage facility can be turned on or off with the
+mng_set_storechunks() function. If set to MNG_TRUE, chunks will be
+stored as they are read.
+
+At any point you can then call the mng_iterate_chunks() function
+to iterate through the current list of chunks. This function requires
+a callback which is called for each chunk and receives a specific
+chunk-handle. This chunk-handle can be used to call the appropriate
+mng_getchunk_xxxx() function, to access the chunks properties.
+
+A typical implementation may look like this:
+
+    mng_bool my_iteratechunk (mng_handle  hHandle,
+                              mng_handle  hChunk,
+                              mng_chunkid iChunkid,
+                              mng_uint32  iChunkseq) {
+      switch (iChunkid) {
+        case MNG_UINT_MHDR : { /* process MHDR */;
+                               break; }
+        case MNG_UINT_FRAM : { /* process FRAM */;
+                               break; }
+
+            ...etc...
+
+        case MNG_UINT_HUH  : { /* unknown chunk */; 
+                               break; }
+        default : { /* duh; forgot one */; }
+      }
+
+      return MNG_TRUE; /* keep'm coming */
+    }
+
+To get to the actual chunk fields of lets say a SHOW chunk you would do:
+
+    mng_bool isempty;
+    mng_uint16 firstid, lastid;
+    mng_uint8 showmode;
+
+    myretcode mng_getchunk_show (hHandle, hChunk, 
+                                 isempty, firstid,
+                                 lastid, showmode);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+
+V. Displaying
+
+
+> Setup
+
+Assuming you have initialized the library and are the owner of
+a mng_handle. The following callbacks are essential:
+
+    mng_getcanvasline, mng_refresh
+    mng_gettickcount, mng_settimer
+
+If you wish to use an application supplied background you must supply:
+
+    mng_getbkgdline
+
+If you wish to use the MNG_CANVAS_RGB8_A8 canvas style you must supply:
+
+    mng_getalphaline
+
+You may optionally define:
+
+    mng_errorproc, mng_traceproc
+    mng_processheader, mng_processtext
+    mng_processsave, mng_processseek
+
+Note that the mng_processheader() callback is optional but will
+be quite significant for proper operation!
+
+Displaying an image will fail if you are creating a file or already
+displaying one. Yes, you can't display it twice!
+
+
+> A word on canvas styles
+
+The canvas style describes how your drawing canvas is made up.
+You must set this before the library actually starts drawing, so
+the mng_processheader() callback is a pretty good place for it.
+
+Currently only 8-bit RGB canvas styles are supported, either with
+or without an alpha channel.
+
+If you like to do alpha composition yourself you can select one of
+the canvas styles that include an alpha channel. You can even have
+a separate alpha canvas by selecting the MNG_CANVAS_RGB8_A8 style.
+
+All styles require a compact model. Eg. MNG_CANVAS_BGR8 requires
+your canvas lines in bgrbgrbgr... storage, where each letter
+represents an 8-bit value of the corresponding color, and each
+threesome makes up the values of one(1) pixel.
+
+The library processes a line at a time, so the canvas lines do not
+actually need to be consecutive in memory.
+
+
+> Alpha composition and application backgrounds
+
+All Network Graphics can be partially transparent. This requires
+special processing if you need to display an image against some
+background. Note that the MNG header (MHDR chunk) contains a
+simplicity field indicating whether transparency information in
+the file is critical or not. This only applies to embedded images,
+which means the full image-frame of the MNG may still contain fully
+transparent pixels!
+
+Depending on your needs you can supply a single background color,
+a background canvas or tell the library to return the alpha-channel
+and do alpha composition yourself.
+
+This is different from the BACK chunk in a MNG, or the bKGD chunk
+in an (embedded) PNG or JNG. The BACK chunk indicates an optional or
+mandatory background color and/or image. The bKGD chunk only indicates
+an optional background color. These chunks indicate the Authors
+preferences. They may be absent in which case you need to supply
+some sort of background yourself.
+
+> Composing against a background color
+
+This is the easiest method. Call the mng_set_bgcolor() function to
+set the values of the red, green and blue component of your preferred
+background color.
+
+Use one of the canvas styles that do not have an alpha-channel, and
+which matches your output requirements.
+
+> Composing against a background canvas
+
+This is somewhat more complicated. You will need to set the
+mng_getbkgdline() callback. This will be called whenever the library
+needs to compose a partially transparent line.
+
+This canvas must hold the background against which the image should
+be composed. Its size must match exactly with the image dimensions
+and thus the drawing canvas!
+
+Use one of the canvas styles that do not have an alpha-channel, and
+which matches your output requirements. The canvas style of the
+background canvas may even differ from the drawing canvas. The library's
+composing will still function properly.
+
+> Composing within the application
+
+If you have the option in your application to draw a (partially)
+transparent canvas to the output device, this option is preferred.
+
+Select one of the canvas styles that do have an alpha-channel.
+The library will now supply the appropriate alpha information,
+allowing the application to compose the image as it sees fit.
+
+
+> Color information and CMS
+
+Network Graphics may, and usually will, contain color-correction
+information. This information is intended to compensate for the
+difference in recording and display devices used.
+
+This document does not address the specifics of color-management.
+See the PNG specification for a more detailed description.
+
+> Using little cms by Marti Maria Saguer
+
+This is the easiest method, providing you can compile the lcms package.
+Select the MNG_FULL_CMS directive during compilation, and sit back and
+relax. The library will take care of all color-correction for you.
+
+> Using an OS- or application-supplied CMS
+
+If you are so lucky to have access to CMS functionality from within
+your application, you may instruct the library to leave color-correction
+to you.
+
+Select the MNG_APP_CMS directive during compilation of the library.
+You MUST also set the following callbacks:
+
+    mng_processgamma, mng_processchroma,
+    mng_processsrgb, mng_processiccp and
+    mng_processarow
+
+The last callback is called when the library needs you to correct
+an arbitrary line of pixels. The other callbacks are called when
+the corresponding color-information is encountered in the file.
+You must store this information somewhere for use in the
+mng_processarow() callback.
+
+> Using gamma-only correction
+
+This isn't a preferred method, but it's better than no correction
+at all. Gamma-only correction will at least compensate for
+gamma-differences between the original recorder and your output device.
+
+Select the MNG_GAMMA_ONLY directive during compilation
+of the library. Your compiler MUST support fp operations.
+
+> No color correction
+
+Ouch. This is really bad. This is the least preferred method,
+but may be necessary if your system cannot use lcms, doesn't
+have its own CMS, and does not allow fp operations, ruling out
+the gamma-only option.
+
+Select the MNG_NO_CMS directive during compilation.
+Images will definitely not be displayed as seen by the Author!!!
+
+
+> Animations and timing
+
+Animations require some form of timing support. The library relies
+on two callbacks for this purpose. The mng_gettickcount() and
+mng_settimer() callbacks. mng_gettickcount() is used to determine
+the passing of time in milliseconds since the beginning of the
+animation. This is also used to compensate during suspension-mode
+if you are using the mng_readdisplay() function to read & display
+the file simultaneously.
+
+The callback may return an arbitrary number of milliseconds, but
+this number must increase proportionaly between calls. Most modern
+systems will have some tickcount() function which derives its
+input from an internal clock. The value returned from this function
+is more than adequate for libmng.
+
+The mng_settimer() callback is called when the library determines
+a little "pause" is required before rendering another frame of the
+animation. The pause interval is also expressed in milliseconds.
+Your application should store this value and return immediately.
+The library will then make appropriate arrangements to store its
+internal state and returns to your application with the
+MNG_NEEDTIMERWAIT code.
+
+At that point you should suspend processing and wait the given
+interval. Please use your OS features for this. Do not engage some
+sort of loop. That is real bad programming practice. Most modern
+systems will have some timing functions. A simple wait() function
+may suffice, but this may prevent your applications main-task from
+running, and possibly prevent the actual update of your output device.
+
+
+> The mng_refresh() callback
+
+The mng_refresh() callback is called whenever the library has
+"finished" drawing a new frame onto your canvas, and just before it
+will call the mng_settimer() callback.
+
+This allows you to perform some actions necessary to "refresh" the
+canvas onto your output device. Please do NOT suspend processing
+inside this callback. This must be handled after the mng_settimer()
+callback!
+
+
+> Displaying while reading
+
+This method is preferred if you are reading from a slow input device
+(such as a dialup-line) and you wish to start displaying something
+as quickly as possible. This functionality is provided mainly for
+browser-type applications but may be appropriate for other
+applications as well.
+
+The method is usually used in unison with the suspension-mode of
+the read module. A typical implementation would look like this:
+
+    /* initiale library and set required callbacks */
+
+    /* activate suspension-mode */
+    myretcode = mng_set_suspensionmode (myhandle, 
+                                        MNG_TRUE);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+    myretcode = mng_readdisplay (myhandle);
+
+    while ((myretcode == MNG_NEEDMOREDATA) ||
+           (myretcode == MNG_NEEDTIMERWAIT)) {
+      if (myretcode == MNG_NEEDMOREDATA)
+        /* wait for more input-data */;
+      else
+        /* wait for timer interval */;
+
+      myretcode = mng_display_resume (myhandle);
+    }
+
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+More advanced programming methods may require a different approach,
+but the final result should function as in the code above.
+
+
+> Displaying after reading
+
+This method is used to display a file that was previously read.
+It is primarily meant for viewers with direct file access, such as
+1a local harddisk.
+
+Once you have successfully read the file, all you need to do is:
+
+    myretcode = mng_display (myhandle);
+
+    while (myretcode == MNG_NEEDTIMERWAIT) {
+      /* wait for timer interval */;
+      myretcode = mng_display_resume (myhandle);
+    }
+
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Again, more advanced programming methods may require a different
+approach, but the final result should function as in the code above.
+
+
+> Display manipulation
+
+Several HLAPI functions are provided to allow a user to manipulate
+the normal flow of an animation.
+
+- mng_display_freeze (mng_handle hHandle)
+
+This will "freeze" the animation in place.
+
+- mng_display_resume (mng_handle hHandle)
+
+This function can be used to resume a frozen animation, or to force
+the library to advance the animation to the next frame.
+
+- mng_display_reset (mng_handle hHandle)
+
+This function will "reset" the animation into its pristine state.
+Calling mng_display() afterwards will re-display the animation
+from the first frame.
+
+- mng_display_golayer    (mng_handle hHandle,
+                          mng_uint32 iLayer)
+- mng_display_goframe    (mng_handle hHandle,
+                          mng_uint32 iFrame)
+- mng_display_goplaytime (mng_handle hHandle,
+                          mng_uint32 iPlaytime)
+
+These three functions can be used to "jump" to a specific layer, frame
+or timeslot in the animation. You must "freeze" the animation before
+using any of these functions.
+
+All above functions may only be called during a timer interval!
+It is the applications responsibility to cleanup any resources with
+respect to the timer wait.
+
+
+VI. Writing
+
+The main focus of the library lies in its displaying capabilites.
+But it does offer writing support as well.
+You can create and write a file, or you can write a file you
+have previously read, providing the storage of chunks was enabled
+and active.
+
+For this to work you must have compiled the library with the
+MNG_WRITE_SUPPO1RT and MNG_ACCESS_CHUNKS directives. The standard DLL and
+Shared Library have this on by default!
+
+
+> Setup
+
+As always you must have initialized the library and be the owner of
+a mng_handle. The following callbacks are essential:
+
+    mng_openstream, mng_writedata, mng_closestream
+
+You can optionally define:
+
+    mng_errorproc, mng_traceproc
+
+The creation and writing functions will fail if you are in the middle
+of reading, creating or writing a file.
+
+
+> Creating a new file
+
+To start a new file the library must be in its initial state.
+First you need to tell the library your intentions:
+
+    myretcode = mng_create (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+After that you start adding the appropriate chunks:
+
+    myretcode = mng_putchunk_mhdr (myhandle, ...);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+And so on, and so forth. Note that the library will automatically signal
+the logical end of the file by the ending chunk. Also the first chunk
+will indicate the library the filetype (eg. PNG, JNG or MNG) and force
+the proper signature when writing the file.
+
+The code above can be simplified, as you can always get the last errorcode
+by using the mng_getlasterror() function:
+
+    if ( (mng_putchunk_xxxx (myhandle, ...)) or
+         (mng_putchunk_xxxx (myhandle, ...)) or
+             ...etc...                          )
+      /* process error */;
+
+Please note that you must have a pretty good understanding of the chunk
+specification. Unlike the read functions, there are virtually no checks,
+so it is quite possible to write completely wrong files.
+It is a good practice to read back your file into the library to verify
+its integrity.
+
+Once you've got all the chunks added, all you do is:
+
+    myretcode mng_write (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+And presto. You're done. The real work is of course carried out in
+your callbacks. Note that this is a single operation as opposed to
+the read & display functions that may return with MNG_NEEDMOREDATA
+and/or MNG_NEEDTIMERWAIT. The write function just does the job, and
+only returns after it's finished or if it encounters some
+unrecoverable error.
+
+
+> Writing a previously read file
+
+If you have already successfully read a file, you can use the library to
+write it out as a copy or something. You MUST have compiled the library
+with the MNG_STORE_CHUNKS directive, and you must have done
+mng_set_storechunks (myhandle, MNG_TRUE).
+
+This doesn't require the MNG_ACCESS_CHUNKS directive, unless you want
+to fiddle with the chunks as well.
+
+Again all you need to do is:
+
+    myretcode mng_write (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+
+VII. Modifying/Customizing libmng:
+
+to do
+
+> Compilation directives
+
+to do
+
+> Platform dependant modification
+
+to do
+
+
+References :
+
+libmng :
+  http://www.libmng.com/
+
+zlib :
+  http://www.info-zip.org/pub/infozip/zlib/
+
+IJG JPEG library :
+  http://www.ijg.org/
+
+lcms (little CMS) by Marti Maria Saguer :
+  http://www.littlecms.com/
+
+MNG specification:
+  http://www.libpng.org/pub/mng
+
+
+In the case of any inconsistency between the MNG specification
+and this library, the specification takes precedence.
+
+
+The contributing authors would like to thank all those who helped
+with testing, bug fixes, and patience.  This wouldn't have been
+possible without all of you!!!
+
+
+COPYRIGHT NOTICE:
+
+Copyright (c) 2000,2001 Gerard Juyn
+
+For the purposes of this copyright and license, "Contributing Authors"
+is defined as the following set of individuals:
+
+   Gerard Juyn
+
+The MNG Library is supplied "AS IS".  The Contributing Authors
+disclaim all warranties, expressed or implied, including, without
+limitation, the warranties of merchantability and of fitness for any
+purpose.  The Contributing Authors assume no liability for direct,
+indirect, incidental, special, exemplary, or consequential damages,
+which may result from the use of the MNG Library, even if advised of
+the possibility of such damage.
+
+Permission is hereby granted to use, copy, modify, and distribute this
+source code, or portions hereof, for any purpose, without fee, subject
+to the following restrictions:
+
+1. The origin of this source code must not be misrepresented;
+you must not claim that you wrote the original software.
+
+2. Altered versions must be plainly marked as such and must not be
+misrepresented as being the original source.
+
+3. This Copyright notice may not be removed or altered from any source
+or altered source distribution.
+
+The Contributing Authors specifically permit, without fee, and
+encourage the use of this source code as a component to supporting
+the MNG and JNG file format in commercial products.  If you use this
+source code in a product, acknowledgment would be highly appreciated.
+
+
+Remarks :
+
+Parts of this software have been adapted from the libpng library.
+Although this library supports all features from the PNG specification
+(as MNG descends from it) it does not require the libpng library.
+It does require the zlib library and optionally the IJG JPEG library,
+and/or the "little-cms" library by Marti Maria Saguer (depending on the
+inclusion of support for JNG and Full-Color-Management respectively.
+
+This library's function is primarily to read and display MNG
+animations. It is not meant as a full-featured image-editing
+component! It does however offer creation and editing functionality
+at the chunk level. (future modifications may include some more
+support for creation and or editing)
+
diff --git a/src/3rdparty/libmng/doc/man/jng.5 b/src/3rdparty/libmng/doc/man/jng.5
new file mode 100644
index 0000000..0e371ad
--- /dev/null
+++ b/src/3rdparty/libmng/doc/man/jng.5
@@ -0,0 +1,37 @@
+.TH JNG 5 "July 26, 2000"
+.SH NAME
+jng \- JPEG Network Graphics (JNG) sub-format
+.SH DESCRIPTION
+JNG (JPEG Network Graphics) is a sub-format of the MNG (Multiple-image
+Network Graphics) format. As with MNG it extends on the features of the
+popular PNG (Portable Network Graphics) image-format. 
+.br
+
+This sub-format was designed to support a lossy compression-method.
+It is based completely on the JPEG specification. It adds the high-compression
+ratios of JPEG for photographic images.
+
+As a member of the Network Graphics family, JNG was deemed adequate as a
+stand-alone format as it extends the JPEG format with color-correction and
+transparency features.
+
+.SH "SEE ALSO"
+.IR png(5) ", " mng(5) ", " libmng(3)
+.LP
+MNG 1.00, February 9, 2001:
+.IP
+http://www.libpng.org/pub/mng
+
+.SH AUTHORS
+This man page: Gerard Juyn
+.LP
+Multiple-image Network Graphics (MNG) Specification Version 1.00 (Februari 9, 2001):
+Glenn Randers-Pehrson and others (png-list@ccrc.wustl.edu).
+.LP
+
+.SH COPYRIGHT NOTICE
+The MNG-1.00 specification is copyright (c) 1998-2001 Glenn Randers-Pehrson.
+See the specification for conditions of use and distribution.
+.LP
+.\" end of man page
+
diff --git a/src/3rdparty/libmng/doc/man/libmng.3 b/src/3rdparty/libmng/doc/man/libmng.3
new file mode 100644
index 0000000..5321faa
--- /dev/null
+++ b/src/3rdparty/libmng/doc/man/libmng.3
@@ -0,0 +1,1146 @@
+.TH LIBMNG 3 "January 30th, 2005"
+.SH NAME
+libmng \- Multiple-image Network Graphics (MNG) Reference Library 1.0.9
+.SH SYNOPSIS
+\fI\fB
+
+\fB#include <libmng.h>\fP
+
+
+.SH DESCRIPTION
+The
+.I libmng
+library supports decoding, displaying, encoding, and various other
+manipulations of the Multiple-image Network Graphics (MNG) format
+image files. It uses the
+.IR zlib(3)
+compression library, and optionally the JPEG library by the Independant
+JPEG Group (IJG) and/or lcms (little cms), a color-management library
+by Marti Maria Saguer.
+
+
+.SH I. Introduction
+
+This file describes how to use and modify the MNG reference library
+(known as libmng) for your own use.  There are seven sections to this
+file: introduction, callbacks, housekeeping, reading, displaying,
+writing, and modification and configuration notes for various special
+platforms. We assume that libmng is already installed; see the
+INSTALL.README file for instructions on how to install libmng.
+
+Libmng was written to support and promote the MNG specification.
+
+The MNG-1.0 specification is available at
+<http://www.libpng.org/pub/mng/spec/>.
+
+Other information about MNG can be found at the MNG home page,
+<http://www.libpng.org/pub/mng/>.
+The latest version of libmng can be found at its own homepage at
+<http://www.libmng.com/>.
+
+In most cases the library will not need to be changed.
+For standardization purposes the library contains both a Windows DLL
+and a makefile for building a shared library (SO). The library is
+written in C, but an interface for Borland Delphi is also available.
+
+Libmng has been designed to handle multiple sessions at one time,
+to be easily modifiable, to be portable to the vast majority of
+machines (ANSI, K&R, 32-, and 64-bit) available, and to be easy
+to use.
+
+Libmng uses zlib for its compression and decompression of MNG files.
+Further information about zlib, and the latest version of zlib, can be
+found at the zlib home page, <http://www.zlib.org/>.
+The zlib compression utility is a general purpose utility that is
+useful for more than MNG/PNG files, and can be used without libmng.
+See the documentation delivered with zlib for more details.
+
+Libmng optionally uses the JPEG library by the Independant JPEG Group
+(IJG). This library is used for the JNG sub-format, which is part of
+the MNG specification, and allows for inclusion of JPEG decoded and
+thus highly compressed (photographic) images.
+Further information about the IJG JPEG library and the latest sources
+can be found at <http://www.ijg.org/>.
+
+Libmng can also optionally use the lcms (little CMS) library by
+Marti Maria Saguer. This library provides an excellent color-management
+system (CMS), which gives libmng the ability to provide full
+color-correction for images with the proper color-information encoded.
+Further information and the latest sources can be found at
+<http://www.littlecms.com/>.
+
+Libmng is thread safe, provided the threads are using different
+handles as returned by the initialization call.
+Each thread should have its own handle and thus its own image.
+Libmng does not protect itself against two threads using the
+same instance of a handle.
+
+The libmng.h header file is the single reference needed for programming
+with libmng:
+
+#include <libmng.h>
+
+
+.SH II. Callbacks
+
+Libmng makes extensive use of callback functions. This is meant to
+keep the library as platform-independant and flexible as possible.
+Actually, the first call you will make to the library, already contains
+three parameters you can use to provide callback entry-points.
+
+Most functions must return a mng_bool (boolean). Returning MNG_FALSE
+indicates the library the callback failed in some way and the library
+will immediately return from whatever it was doing back to the
+application. Returning MNG_TRUE indicates there were no problems and
+processing can continue.
+
+Let's step through each of the possible callbacks. The sections on
+reading, displaying and writing will also explain which callbacks are
+needed when and where.
+
+\- mng_ptr mng_memalloc (mng_size_t iLen)
+
+A very basic function which the library uses to allocate a memory-block
+with the given size. A typical implementation would be:
+
+    mng_ptr my_alloc (mng_size_t iLen) {
+      return calloc (1, iLen);
+    }
+
+Note that the library requires you to zero-out the memory-block!!!
+
+\- void mng_memfree (mng_ptr    pPtr,
+                    mng_size_t iLen)
+
+Counterpart of the previous function. Typically:
+
+    void my_free (mng_ptr pPtr, mng_size_t iLen) {
+      free (pPtr);
+    }
+
+\- mng_bool mng_openstream  (mng_handle hHandle)
+
+\- mng_bool mng_closestream (mng_handle hHandle)
+
+These are called by the library just before it starts to process
+(either read or write) a file and just after the processing stops.
+This is the recommended place to do I/O initialization & finalization.
+Whether you do or not, is up to you. The library does not put any
+meaning into the calls. They are simply provided for your convenience.
+
+\- mng_bool mng_readdata (mng_handle  hHandle, 
+                         mng_ptr     pBuf, 
+                         mng_uint32  iBuflen, 
+                         mng_uint32p pRead)
+    
+This function is called when the library needs some more input while
+reading an image. The reading process supports two modes:
+Suspension-mode (SMOD) and non-suspension-mode (NSMOD).
+See mng_set_suspensionmode() for a more detailed description.
+
+In NSMOD, the library requires you to return exactly the amount of bytes
+requested (= iBuflen). Any lesser amount indicates the input file
+is exhausted and the library will return a MNG_UNEXPECTEDEOF errorcode.
+
+In SMOD, you may return a smaller amount of bytes than requested.
+This tells the library it should temporarily wait for more input to
+arrive. The lib will return with MNG_NEEDMOREDATA, and will expect a
+call to mng_read_resume() or mng_display_resume() next, as soon as
+more input-data has arrived.
+
+For NSMOD this function could be as simple as:
+
+    mng_bool my_read (mng_handle  hHandle,
+                      mng_ptr     pBuf, 
+                      mng_uint32  iBuflen,
+                      mng_uint32p pRead) {
+      *pRead = fread (pBuf, 1, iBuflen, myfile);
+      return MNG_TRUE;
+    }
+
+\- mng_bool mng_writedata (mng_handle  hHandle,
+                          mng_ptr     pBuf, 
+                          mng_uint32  iBuflen, 
+                          mng_uint32p pWritten)
+
+This function is called during the mng_write() function to actually
+output data to the file. There is no suspension-mode during write,
+so the application must return the exact number of bytes the library
+requests to be written.
+
+A typical implementation could be:
+
+    mng_bool my_write (mng_handle  hHandle,
+                       mng_ptr     pBuf, 
+                       mng_uint32  iBuflen,
+                       mng_uint32p pWritten) {
+      *pWritten = fwrite (pBuf, 1, iBuflen, myfile);
+      return MNG_TRUE;
+    }
+
+\- mng_bool mng_errorproc (mng_handle  hHandle,
+                          mng_int32   iErrorcode,
+                          mng_int8    iSeverity,
+                          mng_chunkid iChunkname,
+                          mng_uint32  iChunkseq,
+                          mng_int32   iExtra1,
+                          mng_int32   iExtra2,
+                          mng_pchar   zErrortext)
+
+This function is called whenever an error is detected inside the
+library. This may be caused by invalid input, callbacks indicating
+failure, or wrongfully calling functions out of place.
+
+If you do not provide this callback the library will still return
+an errorcode from the called function, and the mng_getlasterror()
+function can be used to retrieve the other parameters.
+
+This function is currently only provided for convenience, but may
+at some point be used to indicate certain errors may be acceptable,
+and processing should continue.
+
+\- mng_bool mng_traceproc (mng_handle hHandle,
+                          mng_int32  iFuncnr,
+                          mng_int32  iFuncseq,
+                          mng_pchar  zFuncname)
+
+This function is provided to allow a functional analysis of the
+library. This may be useful if you encounter certain errors and
+cannot determine what the problem is.
+
+Almost all functions inside the library will activate this
+callback with an appropriate function-name at the start and end
+of the function. Please note that large images may generate an
+enormous amount of calls.
+
+\- mng_bool mng_processheader (mng_handle hHandle,
+                              mng_uint32 iWidth,
+                              mng_uint32 iHeight)
+
+This function is called once the header information of an input-
+image has been processed. At this point the image dimensions are
+available and also some other properties depending on the type
+of the image. Eg. for a MNG the frame-/layercount, playtime &
+simplicity fields are known.
+
+The primary purpose of this callback is to inform the application
+of the size of the image, and for the application to initialize
+the drawing canvas to be used by the library. This is also a good
+point to set the canvas-style. Eg. mng_set_canvasstyle().
+
+\- mng_bool mng_processtext (mng_handle hHandle,
+                            mng_uint8  iType,
+                            mng_pchar  zKeyword,
+                            mng_pchar  zText,
+                            mng_pchar  zLanguage,
+                            mng_pchar  zTranslation)
+
+This callback is activated for each textual chunk in the input-
+image. These are tEXt, zTXt & iTXt. It may be used to retain
+specific comments for presentation to the user.
+
+\- mng_bool mng_processsave (mng_handle hHandle)
+
+\- mng_bool mng_processseek (mng_handle hHandle,
+                            mng_pchar  zName)
+
+The purpose of these callbacks is to signal the processing of the
+SAVE & SEEK chunks in a MNG input-file. This may be used in the
+future to specify some special processing. At the moment these
+functions are only provided as a signal.
+
+\- mng_ptr mng_getcanvasline (mng_handle hHandle,
+                             mng_uint32 iLinenr)
+
+\- mng_ptr mng_getbkgdline   (mng_handle hHandle,
+                             mng_uint32 iLinenr)
+
+\- mng_ptr mng_getalphaline  (mng_handle hHandle,
+                             mng_uint32 iLinenr)
+
+These callbacks are used to access the drawing canvas, background
+canvas and an optional separate alpha-channel canvas. The latter is
+used only with the MNG_CANVAS_RGB8_A8 canvas-style.
+
+If the getbkgdline() callback is not supplied the library will
+composite fully or partially transparent pixels in the image against
+a specified background color. See mng_set_bgcolor() for more details.
+If a chosen canvas-style includes an alpha-channel, this callback
+is very likely not needed.
+
+The application is responsible for returning a pointer to a line of
+pixels, which should be in the exact format as defined by the call
+to mng_set_canvasstyle() and mng_set_bkgdstyle(), without gaps between
+the representation of each pixel, unless specified by the canvas-style.
+
+\- mng_bool mng_refresh (mng_handle hHandle,
+                        mng_uint32 iX,
+                        mng_uint32 iY,
+                        mng_uint32 iWidth,
+                        mng_uint32 iHeight)
+
+This callback is called when the library has drawn a complete frame
+onto the drawing canvas, and it is ready to be displayed.
+The application is responsible for transferring the drawing canvas
+from memory onto the actual output device.
+
+\- mng_uint32 mng_gettickcount (mng_handle hHandle)
+
+This function should return the number of milliseconds on some internal
+clock. The entire animation timing depends heavily on this function,
+and the number returned should be as accurate as possible.
+
+\- mng_bool mng_settimer (mng_handle hHandle,
+                         mng_uint32 iMsecs)
+
+This callback is activated every time the library requires a "pause".
+Note that the function itself should NOT execute the wait. It should
+simply store the time-field and allow the library to return. Libmng
+will return with the MNG_NEEDTIMERWAIT code, indicating the callback
+was called and it is now time to execute the pause.
+
+After the indicated number of milliseconds have elapsed, the application
+should call mng_display_resume(), to resume the animation as planned.
+
+This method allows for both a real timer or a simple wait command in the
+application. Whichever method you select, both the gettickcount() and
+settimer() callbacks are crucial for proper animation timing.
+
+\- mng_bool mng_processgamma  (mng_handle hHandle,
+                              mng_uint32 iGamma)
+
+\- mng_bool mng_processchroma (mng_handle hHandle,
+                              mng_uint32 iWhitepointx,
+                              mng_uint32 iWhitepointy,
+                              mng_uint32 iRedx,
+                              mng_uint32 iRedy,
+                              mng_uint32 iGreenx,
+                              mng_uint32 iGreeny,
+                              mng_uint32 iBluex,
+                              mng_uint32 iBluey)
+
+\- mng_bool mng_processsrgb   (mng_handle hHandle,
+                              mng_uint8  iRenderingintent)
+
+\- mng_bool mng_processiccp   (mng_handle hHandle,
+                              mng_uint32 iProfilesize,
+                              mng_ptr    pProfile)
+
+\- mng_bool mng_processarow   (mng_handle hHandle,
+                              mng_uint32 iRowsamples,
+                              mng_bool   bIsRGBA16,
+                              mng_ptr    pRow)
+
+These callbacks are only required when you selected the MNG_APP_CMS
+directive during compilation of the library. See the configuration
+section for more details.
+
+\- mng_bool mng_iteratechunk (mng_handle  hHandle,
+                             mng_handle  hChunk,
+                             mng_chunkid iChunkid,
+                             mng_uint32  iChunkseq)
+
+This callback is only used for the mng_iterate_chunks() function.
+It is called exactly once for each chunk stored.
+
+
+.SH III. Housekeeping
+
+
+.SS Memory management
+
+The library can use internal memory allocation/deallocation or use
+provided callbacks for its memory management. The choice is made at
+compilation time. See the section on customization for details.
+
+If internal management has been selected, the memory callback functions
+need not be supplied. Even if you do supply them they will not be used.
+The actual code used is similar to the code discussed in the callback
+section:
+
+      pPtr = calloc (1, iLen);
+
+      free (pPtr);
+
+If your compiler does not support these functions, or you wish to monitor
+the library's use of memory for certain reasons, you can choose to
+compile the library with external memory management. In this case the
+memory callback functions MUST be supplied, and should function as if the
+above code was used.
+
+
+.SS Initialization
+
+The basic initialization of the library is short and swift:
+
+    myhandle = mng_initialize (myuserdata, my_alloc, 
+                               my_free, MNG_NULL);
+    if (myhandle == MNG_NULL)
+      /* process error */;
+
+The first field is an application-only parameter. It is saved in
+libmng's internal structures and available at all times through the
+mng_get_userdata() function. This is especially handy in callback functions
+if your program may be handling multiple files at the same time.
+
+The second and third field supply the library with the memory callback
+function entry-points. These are described in more detail in the callback
+section and the previous paragraph.
+
+The fourth and last field may be used to supply the library with the
+entry-point of a trace callback function. For regular use you will not
+need this!
+
+The function returns a handle which will be your ticket to MNG-heaven.
+All other functions rely on this handle. It is the single fixed unique
+reference-point between your application and the library.
+
+You should call the initialization function for each image you wish to
+process simultaneously. If you are processing images consecutively, you can
+reset the internal status of the library with the mng_reset() function.
+This function will clear all internal state variables, free any stored
+chunks and/or objects, etc, etc. Your callbacks and other external parameters
+will be retained.
+
+After you successfully received the handle it is time to set the required
+callbacks. The sections on reading, displaying & writing indicate which
+callbacks are required and which are optional.
+To set the callbacks simply do:
+
+    myretcode = mng_setcb_xxxxxx (myhandle, my_xxxxxx);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Naturally you'd replace the x's with the name of the callback.
+
+
+.SS Cleanup
+
+Once you've gotten hold of that precious mng_handle, you should always,
+and I mean always, call the cleanup function when you're done.
+Just do:
+
+    mng_cleanup (myhandle);
+
+And you're done. There shouldn't be an ounce of memory spilled after
+that call.
+
+Note that if you would like to process multiple files consecutively
+you do not need to do mng_cleanup() / mng_initialize() between each file
+but simply
+
+    myretcode = mng_reset (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+will suffice. Saves some time and effort, that.
+
+
+.SS Error handling
+
+From the examples in the previous paragraphs you may have noticed a
+meticulous scheme for error handling. And yes, that's exactly what it is.
+Practically each call simply returns an errorcode, indicating success,
+eg. MNG_NOERROR or failure, anything else but MNG_NEEDMOREDATA and
+MNG_NEEDTIMERWAIT. These latter two will be discussed in more detail in
+their respective fields of interest: the reading section and displaying
+section respectively.
+
+It is the application's responsibility to check the returncode after
+each call. You can call mng_getlasterror() to receive the details of
+the last detected error. This even includes a discriptive error-message
+if you enabled that option during compilation of the library.
+
+Note that after receiving an error it is still possible to call the
+library, but it's also very likely that any following call will fail.
+The only functions deemed to work will be mng_reset() and mng_cleanup().
+Yes, if you abort your program after an error, you should still call
+mng_cleanup().
+
+
+.SH IV. Reading
+
+Reading a MNG, JNG or PNG is fairly easy. It depends slightly on your
+ultimate goal how certain specifics are to be handled, but the basics
+are similar in all cases.
+
+For the read functioins to work you must have compiled the library with
+the MNG_READ_SUPPRT directive. The standard DLL and Shared Library
+have this on by default!
+
+
+.SS Setup
+
+Naturally you must have initialized the library and be the owner of
+a mng_handle. The following callbacks are essential:
+
+    mng_openstream, mng_readdata, mng_closestream
+
+You may optionally define:
+
+    mng_errorproc, mng_traceproc
+    mng_processheader, mng_processtext
+    mng_processsave, mng_processseek
+
+The reading bit will also fail if you are already creating or
+displaying a file. Seems a bit obvious, but I thought I'd mention it,
+just in case.
+
+
+.SS To suspend or not to suspend
+
+There is one choice you need to make before calling the read function.
+Are you in need of suspension-mode or not?
+
+If you're reading from a disk you most certainly do not need
+suspension-mode. Even the oldest and slowest of disks will be fast
+enough for straight reading.
+
+However, if your input comes from a really slow device, such as a
+dialup-line or the likes, you may opt for suspension-mode. This is done
+by calling
+
+    myretcode = mng_set_suspensionmode (myhandle,
+                                        MNG_TRUE);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Suspension-mode will force the library to use special buffering on the
+input. This allows your application to receive data of arbitrarily length
+and return this in the mng_readdata() callback, without disturbing the
+chunk processing routines of the library.
+
+Suspension-mode does require a little extra care in the main logic of the
+application. The read function may return with MNG_NEEDMOREDATA when the
+mng_readdata() callback returns less data then it needs to process the
+next chunk. This indicates the application to wait for more data to arrive
+and then resume processing by calling mng_read_resume().
+
+
+.SS The read HLAPI
+
+The actual reading is just plain simple. Since all I/O is done
+outside the library through the callbacks, the library can focus on
+its real task. Understanding, checking and labelling the input data!
+
+All you really need to do is this:
+
+    myretcode = mng_read (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Of course, if you're on suspension-mode the code is a little more
+complicated:
+
+    myretcode = mng_read (myhandle);
+
+    while (myretcode == MNG_NEEDMOREDATA) {
+      /* wait for input-data to arrive */
+      myretcode = mng_read_resume (myhandle);
+    } 
+   
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+This is rather crude and more sophisticated programming methods may
+dictate another approach. Whatever method you decide on, it should
+act as if the above code was in its place.
+
+There is also the mng_readdisplay() function, but this is discussed
+in the displaying section. It functions pretty much as the mng_read()
+function, but also immediately starts displaying the image.
+mng_read_resume() should be replaced by mng_display_resume() in that
+case!
+
+
+.SS What happens inside
+
+What actually happens inside the library depends on the configuration
+options set during the compilation of the library.
+
+Basically the library will first read the 8-byte file header, to determine
+its validity and the type of image it is about to process. Then it will
+repeatedly read a 4-byte chunk-length and then the remainder of the chunk
+until it either reaches EOF (indicated by the mng_readdata() callback) or
+implicitly decides EOF as it processed the logically last chunk of the
+image.
+
+Applications that require strict conformity and do not allow superfluous
+data after the ending chunk, will need to perform this check in their
+mng_closestream() callback.
+
+Each chunk is then checked on CRC, after which it is handed over to the
+appropriate chunk processing routine. These routines will disect the
+chunk, check the validity of its contents, check its position with respect
+to other chunks, etc, etc.
+
+If everything checks out, the chunk is further processed as follows:
+
+If display support has been selected during compilation, certain pre-display
+initialization will take place.
+
+If chunk-storage support has been selected during compilation, the chunks
+data may be stored in a special internal structure and held for future
+reference.
+
+
+.SS Storing and accessing chunks
+
+One of the compilation options activates support for chunk storage.
+This option may be useful if you want to examine an image. The directive
+is MNG_STORE_CHUNKS. You must also turn on the MNG_ACCESS_CHUNKS
+directive.
+
+The actual storage facility can be turned on or off with the
+mng_set_storechunks() function. If set to MNG_TRUE, chunks will be
+stored as they are read.
+
+At any point you can then call the mng_iterate_chunks() function
+to iterate through the current list of chunks. This function requires
+a callback which is called for each chunk and receives a specific
+chunk-handle. This chunk-handle can be used to call the appropriate
+mng_getchunk_xxxx() function, to access the chunks properties.
+
+A typical implementation may look like this:
+
+    mng_bool my_iteratechunk (mng_handle  hHandle,
+                              mng_handle  hChunk,
+                              mng_chunkid iChunkid,
+                              mng_uint32  iChunkseq) {
+      switch (iChunkid) {
+        case MNG_UINT_MHDR : { /* process MHDR */;
+                               break; }
+        case MNG_UINT_FRAM : { /* process FRAM */;
+                               break; }
+
+            ...etc...
+
+        case MNG_UINT_HUH  : { /* unknown chunk */; 
+                               break; }
+        default : { /* duh; forgot one */; }
+      }
+
+      return MNG_TRUE; /* keep'm coming */
+    }
+
+To get to the actual chunk fields of lets say a SHOW chunk you would do:
+
+    mng_bool isempty;
+    mng_uint16 firstid, lastid;
+    mng_uint8 showmode;
+
+    myretcode mng_getchunk_show (hHandle, hChunk, 
+                                 isempty, firstid,
+                                 lastid, showmode);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+
+.SH V. Displaying
+
+
+.SS Setup
+
+Assuming you have initialized the library and are the owner of
+a mng_handle. The following callbacks are essential:
+
+    mng_getcanvasline, mng_refresh
+    mng_gettickcount, mng_settimer
+
+If you wish to use an application supplied background you must supply:
+
+    mng_getbkgdline
+
+If you wish to use the MNG_CANVAS_RGB8_A8 canvas style you must supply:
+
+    mng_getalphaline
+
+You may optionally define:
+
+    mng_errorproc, mng_traceproc
+    mng_processheader, mng_processtext
+    mng_processsave, mng_processseek
+
+Note that the mng_processheader() callback is optional but will
+be quite significant for proper operation!
+
+Displaying an image will fail if you are creating a file or already
+displaying one. Yes, you can't display it twice!
+
+
+.SS A word on canvas styles
+
+The canvas style describes how your drawing canvas is made up.
+You must set this before the library actually starts drawing, so
+the mng_processheader() callback is a pretty good place for it.
+
+Currently only 8-bit RGB canvas styles are supported, either with
+or without an alpha channel.
+
+If you like to do alpha composition yourself you can select one of
+the canvas styles that include an alpha channel. You can even have
+a separate alpha canvas by selecting the MNG_CANVAS_RGB8_A8 style.
+
+All styles require a compact model. Eg. MNG_CANVAS_BGR8 requires
+your canvas lines in bgrbgrbgr... storage, where each letter
+represents an 8-bit value of the corresponding color, and each
+threesome makes up the values of one(1) pixel.
+
+The library processes a line at a time, so the canvas lines do not
+actually need to be consecutive in memory.
+
+
+.SS Alpha composition and application backgrounds
+
+All Network Graphics can be partially transparent. This requires
+special processing if you need to display an image against some
+background. Note that the MNG header (MHDR chunk) contains a
+simplicity field indicating whether transparency information in
+the file is critical or not. This only applies to embedded images,
+which means the full image-frame of the MNG may still contain fully
+transparent pixels!
+
+Depending on your needs you can supply a single background color,
+a background canvas or tell the library to return the alpha-channel
+and do alpha composition yourself.
+
+This is different from the BACK chunk in a MNG, or the bKGD chunk
+in an (embedded) PNG or JNG. The BACK chunk indicates an optional or
+mandatory background color and/or image. The bKGD chunk only indicates
+an optional background color. These chunks indicate the Authors
+preferences. They may be absent in which case you need to supply
+some sort of background yourself.
+
+.SS Composing against a background color
+
+This is the easiest method. Call the mng_set_bgcolor() function to
+set the values of the red, green and blue component of your preferred
+background color.
+
+Use one of the canvas styles that do not have an alpha-channel, and
+which matches your output requirements.
+
+.SS Composing against a background canvas
+
+This is somewhat more complicated. You will need to set the
+mng_getbkgdline() callback. This will be called whenever the library
+needs to compose a partially transparent line.
+
+This canvas must hold the background against which the image should
+be composed. Its size must match exactly with the image dimensions
+and thus the drawing canvas!
+
+Use one of the canvas styles that do not have an alpha-channel, and
+which matches your output requirements. The canvas style of the
+background canvas may even differ from the drawing canvas. The library's
+composing will still function properly.
+
+.SS Composing within the application
+
+If you have the option in your application to draw a (partially)
+transparent canvas to the output device, this option is preferred.
+
+Select one of the canvas styles that do have an alpha-channel.
+The library will now supply the appropriate alpha information,
+allowing the application to compose the image as it sees fit.
+
+
+.SS Color information and CMS
+
+Network Graphics may, and usually will, contain color-correction
+information. This information is intended to compensate for the
+difference in recording and display devices used.
+
+This document does not address the specifics of color-management.
+See the PNG specification for a more detailed description.
+
+.SS Using little cms by Marti Maria Saguer
+
+This is the easiest method, providing you can compile the lcms package.
+Select the MNG_FULL_CMS directive during compilation, and sit back and
+relax. The library will take care of all color-correction for you.
+
+.SS Using an OS- or application-supplied CMS
+
+If you are so lucky to have access to CMS functionality from within
+your application, you may instruct the library to leave color-correction
+to you.
+
+Select the MNG_APP_CMS directive during compilation of the library.
+You MUST also set the following callbacks:
+
+    mng_processgamma, mng_processchroma,
+    mng_processsrgb, mng_processiccp and
+    mng_processarow
+
+The last callback is called when the library needs you to correct
+an arbitrary line of pixels. The other callbacks are called when
+the corresponding color-information is encountered in the file.
+You must store this information somewhere for use in the
+mng_processarow() callback.
+
+.SS Using gamma-only correction
+
+This isn't a preferred method, but it's better than no correction
+at all. Gamma-only correction will at least compensate for
+gamma-differences between the original recorder and your output device.
+
+Select the MNG_GAMMA_ONLY directive during compilation
+of the library. Your compiler MUST support fp operations.
+
+.SS No color correction
+
+Ouch. This is really bad. This is the least preferred method,
+but may be necessary if your system cannot use lcms, doesn't
+have its own CMS, and does not allow fp operations, ruling out
+the gamma-only option.
+
+Select the MNG_NO_CMS directive during compilation.
+Images will definitely not be displayed as seen by the Author!!!
+
+
+.SS Animations and timing
+
+Animations require some form of timing support. The library relies
+on two callbacks for this purpose. The mng_gettickcount() and
+mng_settimer() callbacks. mng_gettickcount() is used to determine
+the passing of time in milliseconds since the beginning of the
+animation. This is also used to compensate during suspension-mode
+if you are using the mng_readdisplay() function to read & display
+the file simultaneously.
+
+The callback may return an arbitrary number of milliseconds, but
+this number must increase proportionaly between calls. Most modern
+systems will have some tickcount() function which derives its
+input from an internal clock. The value returned from this function
+is more than adequate for libmng.
+
+The mng_settimer() callback is called when the library determines
+a little "pause" is required before rendering another frame of the
+animation. The pause interval is also expressed in milliseconds.
+Your application should store this value and return immediately.
+The library will then make appropriate arrangements to store its
+internal state and returns to your application with the
+MNG_NEEDTIMERWAIT code.
+
+At that point you should suspend processing and wait the given
+interval. Please use your OS features for this. Do not engage some
+sort of loop. That is real bad programming practice. Most modern
+systems will have some timing functions. A simple wait() function
+may suffice, but this may prevent your applications main-task from
+running, and possibly prevent the actual update of your output device.
+
+
+.SS The mng_refresh() callback
+
+The mng_refresh() callback is called whenever the library has
+"finished" drawing a new frame onto your canvas, and just before it
+will call the mng_settimer() callback.
+
+This allows you to perform some actions necessary to "refresh" the
+canvas onto your output device. Please do NOT suspend processing
+inside this callback. This must be handled after the mng_settimer()
+callback!
+
+
+.SS Displaying while reading
+
+This method is preferred if you are reading from a slow input device
+(such as a dialup-line) and you wish to start displaying something
+as quickly as possible. This functionality is provided mainly for
+browser-type applications but may be appropriate for other
+applications as well.
+
+The method is usually used in unison with the suspension-mode of
+the read module. A typical implementation would look like this:
+
+    /* initiale library and set required callbacks */
+
+    /* activate suspension-mode */
+    myretcode = mng_set_suspensionmode (myhandle, 
+                                        MNG_TRUE);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+    myretcode = mng_readdisplay (myhandle);
+
+    while ((myretcode == MNG_NEEDMOREDATA) ||
+           (myretcode == MNG_NEEDTIMERWAIT)) {
+      if (myretcode == MNG_NEEDMOREDATA)
+        /* wait for more input-data */;
+      else
+        /* wait for timer interval */;
+
+      myretcode = mng_display_resume (myhandle);
+    }
+
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+More advanced programming methods may require a different approach,
+but the final result should function as in the code above.
+
+
+.SS Displaying after reading
+
+This method is used to display a file that was previously read.
+It is primarily meant for viewers with direct file access, such as
+1a local harddisk.
+
+Once you have successfully read the file, all you need to do is:
+
+    myretcode = mng_display (myhandle);
+
+    while (myretcode == MNG_NEEDTIMERWAIT) {
+      /* wait for timer interval */;
+      myretcode = mng_display_resume (myhandle);
+    }
+
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+Again, more advanced programming methods may require a different
+approach, but the final result should function as in the code above.
+
+
+.SS Display manipulation
+
+Several HLAPI functions are provided to allow a user to manipulate
+the normal flow of an animation.
+
+\- mng_display_freeze (mng_handle hHandle)
+
+This will "freeze" the animation in place.
+
+\- mng_display_resume (mng_handle hHandle)
+
+This function can be used to resume a frozen animation, or to force
+the library to advance the animation to the next frame.
+
+\- mng_display_reset (mng_handle hHandle)
+
+This function will "reset" the animation into its pristine state.
+Calling mng_display() afterwards will re-display the animation
+from the first frame.
+
+\- mng_display_golayer (mng_handle hHandle,
+                        mng_uint32 iLayer)
+
+\- mng_display_goframe (mng_handle hHandle,
+                        mng_uint32 iFrame)
+
+\- mng_display_gotime (mng_handle hHandle,
+                       mng_uint32 iPlaytime)
+
+These three functions can be used to "jump" to a specific layer, frame
+or timeslot in the animation. You must "freeze" the animation before
+using any of these functions.
+
+All above functions may only be called during a timer interval!
+It is the applications responsibility to cleanup any resources with
+respect to the timer wait.
+
+
+.SH VI. Writing
+
+The main focus of the library lies in its displaying capabilites.
+But it does offer writing support as well.
+You can create and write a file, or you can write a file you
+have previously read, providing the storage of chunks was enabled
+and active.
+
+For this to work you must have compiled the library with the
+MNG_WRITE_SUPPO1RT and MNG_ACCESS_CHUNKS directives. The standard DLL and
+Shared Library have this on by default!
+
+
+.SS Setup
+
+As always you must have initialized the library and be the owner of
+a mng_handle. The following callbacks are essential:
+
+    mng_openstream, mng_writedata, mng_closestream
+
+You can optionally define:
+
+    mng_errorproc, mng_traceproc
+
+The creation and writing functions will fail if you are in the middle
+of reading, creating or writing a file.
+
+
+.SS Creating a new file
+
+To start a new file the library must be in its initial state.
+First you need to tell the library your intentions:
+
+    myretcode = mng_create (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+After that you start adding the appropriate chunks:
+
+    myretcode = mng_put1chunk_mhdr (myhandle, ...);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+And so on, and so forth. Note that the library will automatically signal
+the logical end of the file by the ending chunk. Also the first chunk
+will indicate the library the filetype (eg. PNG, JNG or MNG) and force
+the proper signature when writing the file.
+
+The code above can be simplified, as you can always get the last errorcode
+by using the mng_getlasterror() function:
+
+    if ( (mng_putchunk_xxxx (myhandle, ...)) or
+         (mng_putchunk_xxxx (myhandle, ...)) or
+             ...etc...                          )
+      /* process error */;
+
+Please note that you must have a pretty good understanding of the chunk
+specification. Unlike the read functions, there are virtually no checks,
+so it is quite possible to write completely wrong files.
+It is a good practice to read back your file into the library to verify
+its integrity.
+
+Once you've got all the chunks added, all you do is:
+
+    myretcode mng_write (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+And presto. You're done. The real work is of course carried out in
+your callbacks. Note that this is a single operation as opposed to
+the read & display functions that may return with MNG_NEEDMOREDATA
+and/or MNG_NEEDTIMERWAIT. The write function just does the job, and
+only returns after it's finished or if it encounters some
+unrecoverable error.
+
+
+.SS Writing a previously read file
+
+If you have already successfully read a file, you can use the library to
+write it out as a copy or something. You MUST have compiled the library
+with the MNG_STORE_CHUNKS directive, and you must have done
+mng_set_storechunks (myhandle, MNG_TRUE).
+
+This doesn't require the MNG_ACCESS_CHUNKS directive, unless you want
+to fiddle with the chunks as well.
+
+Again all you need to do is:
+
+    myretcode mng_write (myhandle);
+    if (myretcode != MNG_NOERROR)
+      /* process error */;
+
+
+.SH VII. Modifying/Customizing libmng:
+
+not finished yet
+
+.SS Compilation directives
+
+not finished yet
+
+.SS Platform dependant modification
+
+not finished yet
+
+.SH "SEE ALSO"
+.IR mng(5), jng(5), png(5), libpng(3)
+
+.LP
+libmng :
+.IP
+.br
+http://www.libmng.com
+
+.LP
+zlib :
+.IP
+.br
+http://www.info-zip.org/pub/infozip/zlib/
+
+.LP
+IJG JPEG library :
+.IP
+.br
+http://www.ijg.org
+
+.LP
+lcms (little CMS) by Marti Maria Saguer :
+.IP
+.br
+http://www.littlecms.com/
+
+.LP
+MNG specification:
+.IP
+.br
+http://www.libpng.org/pub/mng
+
+.LP
+In the case of any inconsistency between the MNG specification
+and this library, the specification takes precedence.
+
+
+.SH AUTHORS
+This man page: Gerard Juyn
+<gerard at libmng.com>
+
+The contributing authors would like to thank all those who helped
+with testing, bug fixes, and patience.  This wouldn't have been
+possible without all of you!!!
+
+
+.SH COPYRIGHT NOTICE:
+
+Copyright (c) 2000-2002 Gerard Juyn
+
+For the purposes of this copyright and license, "Contributing Authors"
+is defined as the following set of individuals:
+
+   Gerard Juyn
+
+The MNG Library is supplied "AS IS".  The Contributing Authors
+disclaim all warranties, expressed or implied, including, without
+limitation, the warranties of merchantability and of fitness for any
+purpose.  The Contributing Authors assume no liability for direct,
+indirect, incidental, special, exemplary, or consequential damages,
+which may result from the use of the MNG Library, even if advised of
+the possibility of such damage.
+
+Permission is hereby granted to use, copy, modify, and distribute this
+source code, or portions hereof, for any purpose, without fee, subject
+to the following restrictions:
+
+1. The origin of this source code must not be misrepresented;
+you must not claim that you wrote the original software.
+
+2. Altered versions must be plainly marked as such and must not be
+misrepresented as being the original source.
+
+3. This Copyright notice may not be removed or altered from any source
+or altered source distribution.
+
+The Contributing Authors specifically permit, without fee, and
+encourage the use of this source code as a component to supporting
+the MNG and JNG file format in commercial products.  If you use this
+source code in a product, acknowledgment would be highly appreciated.
+
+.SH Remarks
+
+Parts of this software have been adapted from the libpng library.
+Although this library supports all features from the PNG specification
+(as MNG descends from it) it does not require the libpng library.
+It does require the zlib library and optionally the IJG JPEG library,
+and/or the "little-cms" library by Marti Maria Saguer (depending on the
+inclusion of support for JNG and Full-Color-Management respectively.
+
+This library's function is primarily to read and display MNG
+animations. It is not meant as a full-featured image-editing
+component! It does however offer creation and editing functionality
+at the chunk level. (future modifications may include some more
+support for creation and or editing)
+
+.\" end of man page
diff --git a/src/3rdparty/libmng/doc/man/mng.5 b/src/3rdparty/libmng/doc/man/mng.5
new file mode 100644
index 0000000..e40c249
--- /dev/null
+++ b/src/3rdparty/libmng/doc/man/mng.5
@@ -0,0 +1,42 @@
+.TH MNG 5 "July 25, 2000"
+.SH NAME
+mng \- Multiple-image Network Graphics (MNG) format
+.SH DESCRIPTION
+MNG (Multiple-image Network Graphics) is the animation extension of the
+popular PNG image-format. PNG (Portable Network Graphics) is an
+extensible file format for the lossless, portable, well-compressed
+storage of raster images. 
+.br
+
+MNG has advanced animation features which make it very useful as a full
+replacement for GIF animations. These features allow animations that
+are impossible with GIF or result in much smaller files as GIF.
+
+As MNG builds on the same structure as PNG, it is robust, extensible and
+free of patents. It retains the same clever file integrity checks as in PNG.
+
+MNG also embraces the lossy JPEG image-format in a sub-format named JNG,
+which allows for alpha-transparency and color-correction on highly
+compressed (photographic) images.
+
+.SH "SEE ALSO"
+.IR png(5) ", " jng(5) ", " libmng(3) ", " libpng(3) ", " zlib(3) ", "
+deflate(5) ", " zlib(5) ", " jpeg(5)
+.LP
+MNG 1.00, Februari 9, 2001:
+.IP
+.br
+http://www.libpng.org/pub/mng
+.SH AUTHORS
+This man page: Gerard Juyn
+.LP
+Multiple-image Network Graphics (MNG) Specification Version 1.00 (Februari 9, 2001):
+Glenn Randers-Pehrson and others (png-list@ccrc.wustl.edu).
+.LP
+
+.SH COPYRIGHT NOTICE
+The MNG-1.00 specification is copyright (c) 1998-2001 Glenn Randers-Pehrson.
+See the specification for conditions of use and distribution.
+.LP
+.\" end of man page
+
diff --git a/src/3rdparty/libmng/doc/misc/magic.dif b/src/3rdparty/libmng/doc/misc/magic.dif
new file mode 100644
index 0000000..005ad5a
--- /dev/null
+++ b/src/3rdparty/libmng/doc/misc/magic.dif
@@ -0,0 +1,30 @@
+--- magic.orig	Wed Aug 14 16:48:56 2002
++++ magic	Wed Aug 14 16:50:09 2002
+@@ -2544,6 +2544,27 @@
+ >>28	byte		1		interlaced
+ 1	string		PNG		PNG image data, CORRUPTED
+ 
++#MNG
++# 0x8a M N G 0x0d 0x0a 0x1a 0x0a [4-byte pad] 
++# M H D R [4-byte width][4-byte height][4-byte ticks][4-byte layers]
++# [4-byte frame][4-byte time]
++#
++0		string	\x8aMNG		MNG image data,
++>4		belong	!0x0d0a1a0a	CORRUPTED
++>4		belong	0x0d0a1a0a
++>>16	belong	x			%ld x
++>>20	belong	x			%ld
++
++#JNG
++# 0x8b J N G 0x0d 0x0a 0x1a 0x0a [4-byte pad] 
++# J H D R [4-byte width][4-byte height]
++#
++0		string	\x8bJNG		JNG image data,
++>4		belong	!0x0d0a1a0a	CORRUPTED
++>4		belong	0x0d0a1a0a
++>>16	belong	x			%ld x
++>>20	belong	x			%ld
++
+ # GIF
+ 0	string		GIF8		GIF image data
+ >4	string		7a		\b, version 8%s,
diff --git a/src/3rdparty/libmng/doc/rpm/libmng-1.0.10-rhconf.patch b/src/3rdparty/libmng/doc/rpm/libmng-1.0.10-rhconf.patch
new file mode 100644
index 0000000..a73b79d
--- /dev/null
+++ b/src/3rdparty/libmng/doc/rpm/libmng-1.0.10-rhconf.patch
@@ -0,0 +1,38 @@
+--- libmng/makefiles/makefile.linux.orig	Sat Jul  1 15:10:35 2000
++++ libmng/makefiles/makefile.linux	Sat Jul  1 15:14:52 2000
+@@ -13,19 +13,19 @@
+ OPTIONS = -DMNG_BUILD_SO
+ 
+ # where "make install" puts libmng.a,libmng.so*,libmng.h,libmng_conf.h,libmng_types.h
+-prefix=/usr/local
++prefix=/usr
+ 
+ # Where the zlib library and include files are located
+-ZLIBLIB=../zlib
+-ZLIBINC=../zlib
++ZLIBLIB=/usr/lib
++ZLIBINC=/usr/include
+ 
+ # Where the jpeg library and include files are located
+-JPEGLIB=../jpgsrc
+-JPEGINC=../jpgsrc
++JPEGLIB=/usr/lib
++JPEGINC=/usr/include
+ 
+ # Where the lcms library and include files are located
+-LCMSLIB=../lcms/lib
+-LCMSINC=../lcms/source
++LCMSLIB=/usr/lib
++LCMSINC=/usr/include
+ 
+ ALIGN=
+ # for i386:
+@@ -37,7 +37,7 @@
+ 
+ # for pgcc version 2.95.1, -O3 is buggy; don't use it.
+ 
+-CFLAGS=-I$(ZLIBINC) -I$(JPEGINC) -I$(LCMSINC) -Wall -O3 -funroll-loops \
++CFLAGS=-I$(ZLIBINC) -I$(JPEGINC) -I$(LCMSINC) -Wall $(RPM_OPT_FLAGS) \
+ 	$(OPTIONS) $(ALIGN) # $(WARNMORE) -g
+ LDFLAGS=-L. -Wl,-rpath,. \
+ 	-L$(ZLIBLIB) -Wl,-rpath,$(ZLIBLIB) \
diff --git a/src/3rdparty/libmng/doc/rpm/libmng.spec b/src/3rdparty/libmng/doc/rpm/libmng.spec
new file mode 100644
index 0000000..89908d7
--- /dev/null
+++ b/src/3rdparty/libmng/doc/rpm/libmng.spec
@@ -0,0 +1,116 @@
+Summary: A library of functions for manipulating MNG format files.
+Name: libmng
+Version: 1.0.10
+Release: 2.1
+Copyright: AS IS
+Group: System Environment/Libraries
+Source0: libmng-%{PACKAGE_VERSION}.tar.gz
+Patch: libmng-%{PACKAGE_VERSION}-rhconf.patch
+URL: http://www.libmng.com/
+BuildRoot: /var/tmp/libmng-root
+BuildPrereq: libjpeg-devel, zlib-devel, lcms-devel
+
+%description
+libmng - library for reading, writing, displaying and examing
+Multiple-Image Network Graphics. MNG is the animation extension to the
+popular PNG image-format.
+
+%package devel
+Summary: Development tools for programs to manipulate MNG format files.
+Group: Development/Libraries
+Requires: libmng = %{PACKAGE_VERSION}
+%description devel
+The libmng-devel package contains the header files and static
+libraries necessary for developing programs using the MNG
+(Multiple-Image Network Graphics) library.
+
+If you want to develop programs which will manipulate MNG image format
+files, you should install libmng-devel.  You'll also need to install
+the libmng package.
+
+%changelog
+* Fri Jul 13 2007 Glenn Randers-Pehrson <glennrp at users.sf.net>
+- updated to 1.0.10
+
+* Thu Aug  5 2004 Gerard Juyn <gerard at libmng.com>
+* Sun Jan 30 2005 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.9
+
+* Thu Aug  5 2004 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.8
+
+* Sun Mar 21 2004 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.7
+
+* Sun Oct 19 2003 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.6
+
+* Tue Sep 24 2002 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.5
+
+* Sun Jun 23 2002 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.4
+
+* Mon Sep 18 2001 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.3
+
+* Sat Jul 7 2001 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.2
+
+* Wed May 2 2001 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.1
+
+* Mon Feb 5 2001 Gerard Juyn <gerard at libmng.com>
+- updated to 1.0.0
+
+* Fri Jan 19 2001 Gerard Juyn <gerard at libmng.com>
+- updated to 0.9.4
+
+* Sat Oct 28 2000 Gerard Juyn <gerard at libmng.com>
+- updated to 0.9.3
+
+* Tue Aug 15 2000 MATSUURA Takanori <t-matsuu at protein.osaka-u.ac.jp>
+- based on libmng-0.9.2/doc/rpm/libmng.spec
+- use %%configure and %%makeinstall
+
+* Sat Aug  5 2000 Gerard Juyn <gerard at libmng.com>
+- updated to 0.9.2
+
+* Wed Jul 26 2000 Gerard Juyn <gerard at libmng.com>
+- updated to 0.9.1
+
+* Sat Jul  1 2000 MATSUURA Takanori <t-matsuu at protein.osaka-u.ac.jp>
+- updated to 0.9.0
+
+* Sat Jun 24 2000 MATSUURA Takanori <t-matsuu at protein.osaka-u.ac.jp>
+- 1st release for RPM
+
+%prep
+%setup
+%configure
+
+%build
+make
+
+%install
+rm -rf $RPM_BUILD_ROOT
+%makeinstall
+
+%clean
+rm -rf $RPM_BUILD_ROOT
+
+%post -p /sbin/ldconfig
+
+%postun -p /sbin/ldconfig
+
+%files
+%defattr(-,root,root)
+%doc CHANGES LICENSE README doc
+/usr/lib/libmng.so.*
+
+%files devel
+%defattr(-,root,root)
+/usr/include/*
+/usr/lib/libmng.a
+/usr/lib/libmng.so
+
diff --git a/src/3rdparty/libmng/libmng.h b/src/3rdparty/libmng/libmng.h
new file mode 100644
index 0000000..b3b1ab1
--- /dev/null
+++ b/src/3rdparty/libmng/libmng.h
@@ -0,0 +1,2932 @@
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * COPYRIGHT NOTICE:                                                      * */
+/* *                                                                        * */
+/* * Copyright (c) 2000-2007 Gerard Juyn                                    * */
+/* * [You may insert additional notices after this sentence if you modify   * */
+/* *  this source]                                                          * */
+/* *                                                                        * */
+/* * For the purposes of this copyright and license, "Contributing Authors" * */
+/* * is defined as the following set of individuals:                        * */
+/* *                                                                        * */
+/* *    Gerard Juyn                 - gjuyn :at: users.sourceforge.net      * */
+/* *    Glenn Randers-Pehrson       - glennrp :at: users.sourceforge.net    * */
+/* *    Raphael Assenat             - raph :at: raphnet.net                 * */
+/* *    John Stiles                 -                                       * */
+/* *                                                                        * */
+/* * The MNG Library is supplied "AS IS".  The Contributing Authors         * */
+/* * disclaim all warranties, expressed or implied, including, without      * */
+/* * limitation, the warranties of merchantability and of fitness for any   * */
+/* * purpose.  The Contributing Authors assume no liability for direct,     * */
+/* * indirect, incidental, special, exemplary, or consequential damages,    * */
+/* * which may result from the use of the MNG Library, even if advised of   * */
+/* * the possibility of such damage.                                        * */
+/* *                                                                        * */
+/* * Permission is hereby granted to use, copy, modify, and distribute this * */
+/* * source code, or portions hereof, for any purpose, without fee, subject * */
+/* * to the following restrictions:                                         * */
+/* *                                                                        * */
+/* * 1. The origin of this source code must not be misrepresented;          * */
+/* *    you must not claim that you wrote the original software.            * */
+/* *                                                                        * */
+/* * 2. Altered versions must be plainly marked as such and must not be     * */
+/* *    misrepresented as being the original source.                        * */
+/* *                                                                        * */
+/* * 3. This Copyright notice may not be removed or altered from any source * */
+/* *    or altered source distribution.                                     * */
+/* *                                                                        * */
+/* * The Contributing Authors specifically permit, without fee, and         * */
+/* * encourage the use of this source code as a component to supporting     * */
+/* * the MNG and JNG file format in commercial products.  If you use this   * */
+/* * source code in a product, acknowledgment would be highly appreciated.  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Parts of this software have been adapted from the libpng package.      * */
+/* * Although this library supports all features from the PNG specification * */
+/* * (as MNG descends from it) it does not require the libpng package.      * */
+/* * It does require the zlib library and optionally the IJG jpeg library,  * */
+/* * and/or the "little-cms" library by Marti Maria (depending on the       * */
+/* * inclusion of support for JNG and Full-Color-Management respectively.   * */
+/* *                                                                        * */
+/* * This library's function is primarily to read and display MNG           * */
+/* * animations. It is not meant as a full-featured image-editing           * */
+/* * component! It does however offer creation and editing functionality    * */
+/* * at the chunk level.                                                    * */
+/* * (future modifications may include some more support for creation       * */
+/* *  and or editing)                                                       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Version numbering                                                      * */
+/* *                                                                        * */
+/* * X.Y.Z : X = release (0 = initial build)                                * */
+/* *         Y = major version (uneven = test; even = production)           * */
+/* *         Z = minor version (bugfixes; 2 is older than 10)               * */
+/* *                                                                        * */
+/* * production versions only appear when a test-version is extensively     * */
+/* * tested and found stable or for intermediate bug-fixes (recognized by   * */
+/* * a change in the Z number)                                              * */
+/* *                                                                        * */
+/* * x.1.x      = test version                                              * */
+/* * x.2.x      = production version                                        * */
+/* * x.3.x      = test version                                              * */
+/* * x.4.x      = production version                                        * */
+/* *  etc.                                                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Identifier naming conventions throughout this library                  * */
+/* *                                                                        * */
+/* * iXxxx      = an integer                                                * */
+/* * dXxxx      = a float                                                   * */
+/* * pXxxx      = a pointer                                                 * */
+/* * bXxxx      = a boolean                                                 * */
+/* * eXxxx      = an enumeration                                            * */
+/* * hXxxx      = a handle                                                  * */
+/* * zXxxx      = a zero-terminated string (pchar)                          * */
+/* * fXxxx      = a pointer to a function (callback)                        * */
+/* * aXxxx      = an array                                                  * */
+/* * sXxxx      = a structure                                               * */
+/* *                                                                        * */
+/* * Macros & defines are in all uppercase.                                 * */
+/* * Functions & typedefs in all lowercase.                                 * */
+/* * Exported stuff is prefixed with MNG_ or mng_ respectively.             * */
+/* *                                                                        * */
+/* * (I may have missed a couple; don't hesitate to let me know!)           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng.h                  copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : main application interface                                 * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : The main application interface. An application should not  * */
+/* *             need access to any of the other modules!                   * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - changed chunk iteration function                         * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - added chunk access functions                             * */
+/* *             - added version control constants & functions              * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added set_outputprofile2 & set_srgbprofile2              * */
+/* *             - added empty-chunk put-routines                           * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - added version_dll & VERSION_DLL (for consistency)        * */
+/* *             - added version control explanatory text & samples         * */
+/* *             0.5.1 - 05/15/2000 - G.Juyn                                * */
+/* *             - added getimgdata & putimgdata functions                  * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/16/2000 - G.Juyn                                * */
+/* *             - changed the version parameters (obviously)               * */
+/* *             0.5.2 - 05/18/2000 - G.Juyn                                * */
+/* *             - complimented constants for chunk-property values         * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - fixed MNG_UINT_pHYg value                                * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added support for get/set default zlib/IJG parms         * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - added MNG_BIGENDIAN_SUPPORT (contributed by Tim Rowley)  * */
+/* *             - separated configuration-options into "mng_conf.h"        * */
+/* *             - added RGB8_A8 canvasstyle                                * */
+/* *             - added getalphaline callback for RGB8_A8 canvasstyle      * */
+/* *             0.5.2 - 06/06/2000 - G.Juyn                                * */
+/* *             - moved errorcodes from "mng_error.h"                      * */
+/* *             - added mng_read_resume function to support                * */
+/* *               read-suspension                                          * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - changed the version parameters (obviously)               * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added get/set for speedtype to facilitate testing        * */
+/* *             - added get for imagelevel during processtext callback     * */
+/* *             0.5.3 - 06/24/2000 - G.Juyn                                * */
+/* *             - fixed inclusion of IJG read/write code                   * */
+/* *             0.5.3 - 06/26/2000 - G.Juyn                                * */
+/* *             - changed userdata variable to mng_ptr                     * */
+/* *                                                                        * */
+/* *             0.9.0 - 06/30/2000 - G.Juyn                                * */
+/* *             - changed refresh parameters to 'x,y,width,height'         * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/06/2000 - G.Juyn                                * */
+/* *             - added MNG_NEEDTIMERWAIT errorcode                        * */
+/* *             - changed comments to indicate modified behavior for       * */
+/* *               timer & suspension breaks                                * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - added get routines for internal display variables        * */
+/* *             - added get/set routines for suspensionmode variable       * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added callbacks for SAVE/SEEK processing                 * */
+/* *             - added get/set routines for sectionbreak variable         * */
+/* *             - added NEEDSECTIONWAIT errorcode                          * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - added function to set frame-/layer-count & playtime      * */
+/* *             - added errorcode for updatemngheader if not a MNG         * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - fixed problem with trace-functions improperly wrapped    * */
+/* *             - added status_xxxx functions                              * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *             - added function to set simplicity field                   * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/09/2000 - G.Juyn                                * */
+/* *             - added check for simplicity-bits in MHDR                  * */
+/* *             0.9.3 - 08/12/2000 - G.Juyn                                * */
+/* *             - added workaround for faulty PhotoShop iCCP chunk         * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 10/10/2000 - G.Juyn                                * */
+/* *             - added support for alpha-depth prediction                 * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - fixed processing of unknown critical chunks              * */
+/* *             - removed test-MaGN                                        * */
+/* *             - added PNG/MNG spec version indicators                    * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added functions to retrieve PNG/JNG specific header-info * */
+/* *             - added JDAA chunk                                         * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *             0.9.3 - 10/20/2000 - G.Juyn                                * */
+/* *             - added errocode for delayed delta-processing              * */
+/* *             - added get/set for bKGD preference setting                * */
+/* *             0.9.3 - 10/21/2000 - G.Juyn                                * */
+/* *             - added get function for interlace/progressive display     * */
+/* *                                                                        * */
+/* *             0.9.4 - 01/18/2001 - G.Juyn                                * */
+/* *             - added errorcode for MAGN methods                         * */
+/* *             - removed test filter-methods 1 & 65                       * */
+/* *                                                                        * */
+/* *             1.0.0 - 02/05/2001 - G.Juyn                                * */
+/* *             - version numbers (obviously)                              * */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn (code by G.Kelly)              * */
+/* *             - added BGRA8 canvas with premultiplied alpha              * */
+/* *             1.0.1 - 05/02/2001 - G.Juyn                                * */
+/* *             - added "default" sRGB generation (Thanks Marti!)          * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *             - added processterm callback                               * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - added late binding errorcode (not used internally)       * */
+/* *             - added option to turn off progressive refresh             * */
+/* *                                                                        * */
+/* *             1.0.3 - 08/06/2001 - G.Juyn                                * */
+/* *             - added get function for last processed BACK chunk         * */
+/* *                                                                        * */
+/* *             1.0.5 - 07/04/2002 - G.Juyn                                * */
+/* *             - added errorcode for extreme chunk-sizes                  * */
+/* *             1.0.5 - 08/07/2002 - G.Juyn                                * */
+/* *             - added test-option for PNG filter method 193 (=no filter) * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             - completed delta-image support                            * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - added HLAPI function to copy chunks                      * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             - added 'supports' call to check function availability     * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - fixed LOOP iteration=0 special case                      * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 09/22/2002 - G.Juyn                                * */
+/* *             - added bgrx8 canvas (filler byte)                         * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - added check for TERM placement during create/write       * */
+/* *             - added beta version function & constant                   * */
+/* *             1.0.5 - 11/07/2002 - G.Juyn                                * */
+/* *             - added support to get totals after mng_read()             * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G. Randers-Pehrson                    * */
+/* *             - added support for reducing the footprint of libmng       * */
+/* *               by macros that optionally skip unused chunks, remove     * */
+/* *               16-bit sample support, remove Delta support, and         * */
+/* *               remove JNG support, to accomodate Mozilla/Firebird.      * */
+/* *             1.0.6 - 07/14/2003 - G. Randers-Pehrson                    * */
+/* *             - further optional removal of unused functions             * */
+/* *                                                                        * */
+/* *             1.0.7 - 11/27/2003 - R.A                                   * */
+/* *             - added CANVAS_RGB565 and CANVAS_BGR565                    * */
+/* *             1.0.7 - 12/06/2003 - R.A                                   * */
+/* *             - added CANVAS_RGBA565 and CANVAS_BGRA565                  * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *             1.0.7 - 03/07/2004 - G. Randers-Pehrson                    * */
+/* *             - put gamma, cms-related declarations inside #ifdef        * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/02/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *             1.0.8 - 04/12/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *             1.0.8 - 06/05/2004 - G.R-P                                 * */
+/* *             - define MNG_INCLUDE_ZLIB when MNG_USE_ZLIB_CRC is defined * */
+/* *                                                                        * */
+/* *             1.0.9 - 10/03/2004 - G.Juyn                                * */
+/* *             - added function to retrieve current FRAM delay            * */
+/* *             1.0.9 - 10/14/2004 - G.Juyn                                * */
+/* *             - added bgr565_a8 canvas-style (thanks to J. Elvander)     * */
+/* *             1.0.9 - 10/17/2004 - G.Juyn                                * */
+/* *             - fixed PPLT getchunk/putchunk routines                    * */
+/* *                                                                        * */
+/* *             1.0.10 - 03/07/2006 - (thanks to W. Manthey)               * */
+/* *             - added CANVAS_RGB555 and CANVAS_BGR555                    * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_h_
+#define _libmng_h_
+
+/* ************************************************************************** */
+
+#include "libmng_conf.h"               /* user-specific configuration options */
+
+/* ************************************************************************** */
+
+#define MNG_CHECK_BAD_ICCP             /* let's catch that sucker !!! */
+
+#ifdef MNG_SUPPORT_READ                /* dependencies based on user-configuration */
+#define MNG_INCLUDE_READ_PROCS
+#endif
+
+#ifdef MNG_SUPPORT_WRITE
+#define MNG_INCLUDE_WRITE_PROCS
+#endif
+
+#ifdef MNG_USE_ZLIB_CRC
+#define MNG_INCLUDE_ZLIB
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY
+#define MNG_INCLUDE_FILTERS
+#define MNG_INCLUDE_INTERLACE
+#define MNG_INCLUDE_OBJECTS
+#define MNG_INCLUDE_DISPLAY_PROCS
+#define MNG_INCLUDE_TIMING_PROCS
+#define MNG_INCLUDE_ZLIB
+#endif
+
+#ifdef MNG_STORE_CHUNKS
+#define MNG_INCLUDE_ZLIB
+#endif
+
+#ifdef MNG_SUPPORT_IJG6B
+#define MNG_INCLUDE_JNG
+#define MNG_INCLUDE_IJG6B
+#define MNG_USE_SETJMP
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_ACCESS_CHUNKS)
+#define MNG_INCLUDE_JNG_READ
+#endif
+#if defined(MNG_SUPPORT_WRITE) || defined(MNG_ACCESS_CHUNKS)
+#define MNG_INCLUDE_JNG_WRITE
+#endif
+#endif
+
+#ifdef MNG_FULL_CMS
+#define MNG_INCLUDE_LCMS
+#endif
+
+#ifdef MNG_AUTO_DITHER
+#define MNG_INCLUDE_DITHERING
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+#define MNG_INCLUDE_TRACE_PROCS
+#ifdef MNG_TRACE_TELLTALE
+#define MNG_INCLUDE_TRACE_STRINGS
+#endif
+#endif
+
+#ifdef MNG_ERROR_TELLTALE
+#define MNG_INCLUDE_ERROR_STRINGS
+#endif
+
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_OPTIMIZE_CHUNKACCESS
+#define MNG_OPTIMIZE_CHUNKACCESS
+#endif
+#else
+#ifdef MNG_OPTIMIZE_CHUNKACCESS
+#undef MNG_OPTIMIZE_CHUNKACCESS
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#include "libmng_types.h"              /* platform-specific definitions
+                                          and other assorted stuff */
+
+/* ************************************************************************** */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Versioning control                                                    * */
+/* *                                                                        * */
+/* *  version_so and version_dll will NOT reflect version_major;            * */
+/* *  these will only change for binary incompatible changes (which will    * */
+/* *  hopefully never occur)                                                * */
+/* *  note: they will be set to 1 on the first public release !!!           * */
+/* *                                                                        * */
+/* *  first public release:                                                 * */
+/* *  #define MNG_VERSION_TEXT    "1.0.0"                                   * */
+/* *  #define MNG_VERSION_SO      1       eg. libmng.so.1                   * */
+/* *  #define MNG_VERSION_DLL     1       eg. libmng.dll                    * */
+/* *  #define MNG_VERSION_MAJOR   1                                         * */
+/* *  #define MNG_VERSION_MINOR   0                                         * */
+/* *  #define MNG_VERSION_RELEASE 0                                         * */
+/* *                                                                        * */
+/* *  bug fix & cosmetics :                                                 * */
+/* *  #define MNG_VERSION_TEXT    "1.0.1"                                   * */
+/* *  #define MNG_VERSION_SO      1       eg. libmng.so.1                   * */
+/* *  #define MNG_VERSION_DLL     1       eg. libmng.dll                    * */
+/* *  #define MNG_VERSION_MAJOR   1                                         * */
+/* *  #define MNG_VERSION_MINOR   0                                         * */
+/* *  #define MNG_VERSION_RELEASE 1                                         * */
+/* *                                                                        * */
+/* *  feature change :                                                      * */
+/* *  #define MNG_VERSION_TEXT    "1.2.0"                                   * */
+/* *  #define MNG_VERSION_SO      1       eg. libmng.so.1                   * */
+/* *  #define MNG_VERSION_DLL     1       eg. libmng.dll                    * */
+/* *  #define MNG_VERSION_MAJOR   1                                         * */
+/* *  #define MNG_VERSION_MINOR   2                                         * */
+/* *  #define MNG_VERSION_RELEASE 0                                         * */
+/* *                                                                        * */
+/* *  major rewrite (still binary compatible) :                             * */
+/* *  #define MNG_VERSION_TEXT    "2.0.0"                                   * */
+/* *  #define MNG_VERSION_SO      1       eg. libmng.so.1                   * */
+/* *  #define MNG_VERSION_DLL     1       eg. libmng.dll                    * */
+/* *  #define MNG_VERSION_MAJOR   2                                         * */
+/* *  #define MNG_VERSION_MINOR   0                                         * */
+/* *  #define MNG_VERSION_RELEASE 0                                         * */
+/* *                                                                        * */
+/* *  binary incompatible change:                                           * */
+/* *  #define MNG_VERSION_TEXT    "13.0.0"                                  * */
+/* *  #define MNG_VERSION_SO      2       eg. libmng.so.2                   * */
+/* *  #define MNG_VERSION_DLL     2       eg. libmng2.dll                   * */
+/* *  #define MNG_VERSION_MAJOR   13                                        * */
+/* *  #define MNG_VERSION_MINOR   0                                         * */
+/* *  #define MNG_VERSION_RELEASE 0                                         * */
+/* *                                                                        * */
+/* *  note that version_so & version_dll will always remain equal so it     * */
+/* *  doesn't matter which one is called to do version-checking; they are   * */
+/* *  just provided for their target platform                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_VERSION_TEXT    "1.0.10"
+#define MNG_VERSION_SO      1          /* eg. libmng.so.1  */
+#define MNG_VERSION_DLL     1          /* but: libmng.dll (!) */
+#define MNG_VERSION_MAJOR   1
+#define MNG_VERSION_MINOR   0
+#define MNG_VERSION_RELEASE 10
+#define MNG_VERSION_BETA    MNG_FALSE
+
+MNG_EXT mng_pchar MNG_DECL mng_version_text      (void);
+MNG_EXT mng_uint8 MNG_DECL mng_version_so        (void);
+MNG_EXT mng_uint8 MNG_DECL mng_version_dll       (void);
+MNG_EXT mng_uint8 MNG_DECL mng_version_major     (void);
+MNG_EXT mng_uint8 MNG_DECL mng_version_minor     (void);
+MNG_EXT mng_uint8 MNG_DECL mng_version_release   (void);
+MNG_EXT mng_bool  MNG_DECL mng_version_beta      (void);
+
+/* use the following call to check wether the version of libmng your app
+   is using supports the given function; this is useful in apps that dynamically
+   load the library to make sure a certain function will work; the result will
+   be MNG_TRUE if the given function is implemented in this version of the library;
+   Major/Minor/Version indicate the version the function became available;
+   (if these fields are zero the function is not yet implemented!) */
+#ifdef MNG_SUPPORT_FUNCQUERY
+MNG_EXT mng_bool  MNG_DECL mng_supports_func     (mng_pchar  zFunction,
+                                                  mng_uint8* iMajor,
+                                                  mng_uint8* iMinor,
+                                                  mng_uint8* iRelease);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  MNG/PNG specification level conformance                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_PNG_VERSION     "1.2"
+#define MNG_PNG_VERSION_MAJ 1
+#define MNG_PNG_VERSION_MIN 2
+
+#define MNG_MNG_VERSION     "1.1"
+#define MNG_MNG_VERSION_MAJ 1
+#define MNG_MNG_VERSION_MIN 1
+#define MNG_MNG_DRAFT       99         /* deprecated;
+                                          only used for nEED "MNG DRAFT nn" */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  High-level application functions                                      * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* library initialization function */
+/* must be the first called before anything can be done at all */
+/* initializes internal datastructure(s) */
+MNG_EXT mng_handle  MNG_DECL mng_initialize      (mng_ptr       pUserdata,
+                                                  mng_memalloc  fMemalloc,
+                                                  mng_memfree   fMemfree,
+                                                  mng_traceproc fTraceproc);
+
+/* library reset function */
+/* can be used to re-initialize the library, so another image can be
+   processed. there's absolutely no harm in calling it, even when it's not
+   really necessary */
+MNG_EXT mng_retcode MNG_DECL mng_reset           (mng_handle    hHandle);
+
+/* library cleanup function */
+/* must be the last called to clean up internal datastructure(s) */
+MNG_EXT mng_retcode MNG_DECL mng_cleanup         (mng_handle*   hHandle);
+
+/* high-level read functions */
+/* use mng_read if you simply want to read a Network Graphic */
+/* mng_read_resume is used in I/O-read-suspension scenarios, where the
+   "readdata" callback may return FALSE & length=0 indicating its buffer is
+   depleted or too short to supply the required bytes, and the buffer needs
+   to be refilled; libmng will return the errorcode MNG_NEEDMOREDATA telling
+   the app to refill its read-buffer after which it must call mng_read_resume
+   (or mng_display_resume if it also displaying the image simultaneously) */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_retcode MNG_DECL mng_read            (mng_handle    hHandle);
+MNG_EXT mng_retcode MNG_DECL mng_read_resume     (mng_handle    hHandle);
+#endif
+
+/* high-level "data push" functions */
+/* these functions can be used in situations where data is streaming into the
+   application and needs to be buffered by libmng before it is actually
+   requested by libmng itself. the pushing complements the normal reading
+   mechanism, but applications can decide to always return "0 bytes read" to
+   make libmng go into suspension mode with the returncode MNG_NEEDMOREDATA */
+/* mng_read_pushdata can be used to push blobs of data of arbitrary size;
+   mng_read_pushsig and mng_read_pushchunk can be used if the application
+   has already done some low-level decoding (eg. at the chunk level) */
+/* the data being pushed into libmng with mng_read_pushdata *must* contain
+   the regular 4-byte chunklength, but *must not* contain it with
+   mng_read_pushchunk!!! */
+/* mng_read_pushsig is used to prevent libmng from trying to parse the regular
+   PNG/JNG/MNG signature bytes; the application must have done this itself
+   and *must* indicate the proper type in the function call or things will
+   go amiss!!
+   also you *must* call this first, so pretty much right after mng_initialize
+   and certainly before any call to mng_read or mng_readdisplay !!!! */
+/* IMPORTANT!!! data can only be safely pushed when libmng is in a
+   "wait" state; eg. during MNG_NEEDTIMERWAIT, MNG_NEEDSECTIONWAIT or
+   MNG_NEEDMOREDATA !!! this just means you can't have one thread displaying
+   and another thread pushing data !!! */
+/* if bOwnership = MNG_TRUE, libmng will retain the supplied pointer and
+   *will* expect the buffer to remain available until libmng is finished
+   with it; what happens then depends on whether or not you have set the
+   releasedata() callback; if this is set than the supplied buffer will
+   be returned through this callback and your application can take care of
+   cleaning it up, otherwise libmng will use its internal freeing mechanism
+   (which, depending on compile-options, will be the standard C free() call,
+   or the memfree() callback */
+/* if bOwnership = MNG_FALSE, libmng will just copy the data into its own
+   buffers and dispose of it in the normal way */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_retcode MNG_DECL mng_read_pushdata   (mng_handle    hHandle,
+                                                  mng_ptr       pData,
+                                                  mng_size_t    iLength,
+                                                  mng_bool      bTakeownership);
+MNG_EXT mng_retcode MNG_DECL mng_read_pushsig    (mng_handle    hHandle,
+                                                  mng_imgtype   eSigtype);
+MNG_EXT mng_retcode MNG_DECL mng_read_pushchunk  (mng_handle    hHandle,
+                                                  mng_ptr       pChunk,
+                                                  mng_size_t    iLength,
+                                                  mng_bool      bTakeownership);
+#endif
+
+/* high-level write & create functions */
+/* use this if you want to write a previously read Network Graphic or
+   if you want to create a new graphic and write it */
+/* to write a previously read graphic you must have defined MNG_STORE_CHUNKS */
+/* to create a new graphic you'll also need access to the chunks
+   (eg. #define MNG_ACCESS_CHUNKS !) */
+#ifdef MNG_SUPPORT_WRITE
+MNG_EXT mng_retcode MNG_DECL mng_write           (mng_handle    hHandle);
+MNG_EXT mng_retcode MNG_DECL mng_create          (mng_handle    hHandle);
+#endif
+
+/* high-level display functions */
+/* use these to display a previously read or created graphic or
+   to read & display a graphic simultaneously */
+/* mng_display_resume should be called after a timer-interval
+   expires that was set through the settimer-callback, after a
+   read suspension-break, or, to resume an animation after a call
+   to mng_display_freeze/mng_display_reset */
+/* mng_display_freeze thru mng_display_gotime can be used to influence
+   the display of an image, BUT ONLY if it has been completely read! */
+#ifdef MNG_SUPPORT_DISPLAY
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_retcode MNG_DECL mng_readdisplay     (mng_handle    hHandle);
+#endif
+MNG_EXT mng_retcode MNG_DECL mng_display         (mng_handle    hHandle);
+MNG_EXT mng_retcode MNG_DECL mng_display_resume  (mng_handle    hHandle);
+MNG_EXT mng_retcode MNG_DECL mng_display_freeze  (mng_handle    hHandle);
+MNG_EXT mng_retcode MNG_DECL mng_display_reset   (mng_handle    hHandle);
+#ifndef MNG_NO_DISPLAY_GO_SUPPORTED
+MNG_EXT mng_retcode MNG_DECL mng_display_goframe (mng_handle    hHandle,
+                                                  mng_uint32    iFramenr);
+MNG_EXT mng_retcode MNG_DECL mng_display_golayer (mng_handle    hHandle,
+                                                  mng_uint32    iLayernr);
+MNG_EXT mng_retcode MNG_DECL mng_display_gotime  (mng_handle    hHandle,
+                                                  mng_uint32    iPlaytime);
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* event processing function */
+/* this needs to be called by the app when dynamic MNG is enabled and
+   a specific event occurs in the user-interface */
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_SUPPORT_DYNAMICMNG)
+MNG_EXT mng_retcode MNG_DECL mng_trapevent       (mng_handle    hHandle,
+                                                  mng_uint8     iEventtype,
+                                                  mng_int32     iX,
+                                                  mng_int32     iY);
+#endif
+
+/* error reporting function */
+/* use this if you need more detailed info on the last error */
+/* iExtra1 & iExtra2 may contain errorcodes from zlib, jpeg, etc... */
+/* zErrortext will only be filled if you #define MNG_ERROR_TELLTALE */
+MNG_EXT mng_retcode MNG_DECL mng_getlasterror    (mng_handle    hHandle,
+                                                  mng_int8*     iSeverity,
+                                                  mng_chunkid*  iChunkname,
+                                                  mng_uint32*   iChunkseq,
+                                                  mng_int32*    iExtra1,
+                                                  mng_int32*    iExtra2,
+                                                  mng_pchar*    zErrortext);
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Callback set functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* memory callbacks */
+/* called to allocate and release internal datastructures */
+#ifndef MNG_INTERNAL_MEMMNGMT
+MNG_EXT mng_retcode MNG_DECL mng_setcb_memalloc      (mng_handle        hHandle,
+                                                      mng_memalloc      fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_memfree       (mng_handle        hHandle,
+                                                      mng_memfree       fProc);
+#endif /* MNG_INTERNAL_MEMMNGMT */
+
+/* open- & close-stream callbacks */
+/* called to open & close streams for input or output */
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+MNG_EXT mng_retcode MNG_DECL mng_setcb_openstream    (mng_handle        hHandle,
+                                                      mng_openstream    fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_closestream   (mng_handle        hHandle,
+                                                      mng_closestream   fProc);
+#endif
+#endif
+
+/* read callback */
+/* called to get data from the inputstream */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_retcode MNG_DECL mng_setcb_readdata      (mng_handle        hHandle,
+                                                      mng_readdata      fProc);
+#endif
+
+/* write callback */
+/* called to put data into the outputstream */
+#ifdef MNG_SUPPORT_WRITE
+MNG_EXT mng_retcode MNG_DECL mng_setcb_writedata     (mng_handle        hHandle,
+                                                      mng_writedata     fProc);
+#endif
+
+/* error callback */
+/* called when an error occurs */
+/* the application can determine if the error is recoverable,
+   and may inform the library by setting specific returncodes */
+MNG_EXT mng_retcode MNG_DECL mng_setcb_errorproc     (mng_handle        hHandle,
+                                                      mng_errorproc     fProc);
+
+/* trace callback */
+/* called to show the currently executing function */
+#ifdef MNG_SUPPORT_TRACE
+MNG_EXT mng_retcode MNG_DECL mng_setcb_traceproc     (mng_handle        hHandle,
+                                                      mng_traceproc     fProc);
+#endif
+
+/* callbacks for read processing */
+/* processheader is called when all header information has been gathered
+   from the inputstream */
+/* processtext is called for every tEXt, zTXt and iTXt chunk in the
+   inputstream (iType=0 for tEXt, 1 for zTXt and 2 for iTXt);
+   you can call get_imagelevel to check at what nesting-level the chunk is
+   encountered (eg. tEXt inside an embedded image inside a MNG -> level == 2;
+                in most other case -> level == 1) */
+/* processsave & processseek are called for SAVE/SEEK chunks */
+/* processneed is called for the nEED chunk; you should specify a callback
+   for this as the default behavior will be to abort processing, unless
+   the requirement is one of:
+   - a supported chunk
+   - the text "draft nn" where nn is a numeric value
+   - the text "MNG-1.0" or "MNG-1.1"
+   - the text "CACHEOFF" */
+/* processmend is called at the very end of the animation-stream;
+   note that this may not be the end of the animation though! */
+/* processterm is called when a TERM chunk is encountered; there can be only
+   1 in the stream (or none) */
+/* processunknown is called after reading each non-critical unknown chunk */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processheader (mng_handle        hHandle,
+                                                      mng_processheader fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processtext   (mng_handle        hHandle,
+                                                      mng_processtext   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processsave   (mng_handle        hHandle,
+                                                      mng_processsave   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processseek   (mng_handle        hHandle,
+                                                      mng_processseek   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processneed   (mng_handle        hHandle,
+                                                      mng_processneed   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processmend   (mng_handle        hHandle,
+                                                      mng_processmend   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processterm   (mng_handle        hHandle,
+                                                      mng_processterm   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processunknown(mng_handle        hHandle,
+                                                      mng_processunknown fProc);
+#endif
+
+/* callbacks for display processing */
+/* getcanvasline is called to get an access-pointer to a line on the
+   drawing-canvas */
+/* getbkgdline is called to get an access-pointer to a line from the
+   background-canvas */
+/* refresh is called to inform the GUI to redraw the current canvas onto
+   its output device (eg. in Win32 this would mean sending an
+   invalidate message for the specified region */
+/* NOTE that the update-region is specified as x,y,width,height; eg. the
+   invalidate message for Windows requires left,top,right,bottom parameters
+   where the bottom-right is exclusive of the region!!
+   to get these correctly is as simple as:
+   left   = x;
+   top    = y;
+   right  = x + width;
+   bottom = y + height;
+   if your implementation requires inclusive points, simply subtract 1 from
+   both the right & bottom values calculated above.
+   */
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_retcode MNG_DECL mng_setcb_getcanvasline (mng_handle        hHandle,
+                                                      mng_getcanvasline fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_getbkgdline   (mng_handle        hHandle,
+                                                      mng_getbkgdline   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_getalphaline  (mng_handle        hHandle,
+                                                      mng_getalphaline  fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_refresh       (mng_handle        hHandle,
+                                                      mng_refresh       fProc);
+
+/* timing callbacks */
+/* gettickcount is called to get the system tickcount (milliseconds);
+   this is used to determine the remaining interval between frames */
+/* settimer is called to inform the application that it should set a timer;
+   when the timer is triggered the app must call mng_display_resume */
+MNG_EXT mng_retcode MNG_DECL mng_setcb_gettickcount  (mng_handle        hHandle,
+                                                      mng_gettickcount  fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_settimer      (mng_handle        hHandle,
+                                                      mng_settimer      fProc);
+
+/* color management callbacks */
+/* called to transmit color management information to the application */
+/* these are only used when you #define MNG_APP_CMS */
+#ifdef MNG_APP_CMS
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processgamma  (mng_handle        hHandle,
+                                                      mng_processgamma  fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processchroma (mng_handle        hHandle,
+                                                      mng_processchroma fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processsrgb   (mng_handle        hHandle,
+                                                      mng_processsrgb   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processiccp   (mng_handle        hHandle,
+                                                      mng_processiccp   fProc);
+MNG_EXT mng_retcode MNG_DECL mng_setcb_processarow   (mng_handle        hHandle,
+                                                      mng_processarow   fProc);
+#endif /* MNG_APP_CMS */
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* release push data callback */
+/* used when the app pushes data into libmng (as opposed to libmng pulling it)
+   and relinquishes ownership of the pushed data-buffer, but *does* want to
+   release (free) the buffer itself once libmng has finished processing it */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_retcode MNG_DECL mng_setcb_releasedata   (mng_handle        hHandle,
+                                                      mng_releasedata   fProc);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Callback get functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* see _setcb_ */
+#ifndef MNG_INTERNAL_MEMMNGMT
+MNG_EXT mng_memalloc      MNG_DECL mng_getcb_memalloc      (mng_handle hHandle);
+MNG_EXT mng_memfree       MNG_DECL mng_getcb_memfree       (mng_handle hHandle);
+#endif
+
+/* see _setcb_ */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_releasedata   MNG_DECL mng_getcb_releasedata   (mng_handle hHandle);
+#endif
+
+/* see _setcb_ */
+#if defined(MNG_SUPPORT_READ) || defined(MNG_WRITE_SUPPORT)
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+MNG_EXT mng_openstream    MNG_DECL mng_getcb_openstream    (mng_handle hHandle);
+MNG_EXT mng_closestream   MNG_DECL mng_getcb_closestream   (mng_handle hHandle);
+#endif
+#endif
+
+/* see _setcb_ */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_readdata      MNG_DECL mng_getcb_readdata      (mng_handle hHandle);
+#endif
+
+/* see _setcb_ */
+#ifdef MNG_SUPPORT_WRITE
+MNG_EXT mng_writedata     MNG_DECL mng_getcb_writedata     (mng_handle hHandle);
+#endif
+
+/* see _setcb_ */
+MNG_EXT mng_errorproc     MNG_DECL mng_getcb_errorproc     (mng_handle hHandle);
+
+/* see _setcb_ */
+#ifdef MNG_SUPPORT_TRACE
+MNG_EXT mng_traceproc     MNG_DECL mng_getcb_traceproc     (mng_handle hHandle);
+#endif
+
+/* see _setcb_ */
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_processheader MNG_DECL mng_getcb_processheader (mng_handle hHandle);
+MNG_EXT mng_processtext   MNG_DECL mng_getcb_processtext   (mng_handle hHandle);
+MNG_EXT mng_processsave   MNG_DECL mng_getcb_processsave   (mng_handle hHandle);
+MNG_EXT mng_processseek   MNG_DECL mng_getcb_processseek   (mng_handle hHandle);
+MNG_EXT mng_processneed   MNG_DECL mng_getcb_processneed   (mng_handle hHandle);
+MNG_EXT mng_processunknown MNG_DECL mng_getcb_processunknown (mng_handle hHandle);
+MNG_EXT mng_processterm   MNG_DECL mng_getcb_processterm   (mng_handle hHandle);
+#endif
+
+/* see _setcb_ */
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_getcanvasline MNG_DECL mng_getcb_getcanvasline (mng_handle hHandle);
+MNG_EXT mng_getbkgdline   MNG_DECL mng_getcb_getbkgdline   (mng_handle hHandle);
+MNG_EXT mng_getalphaline  MNG_DECL mng_getcb_getalphaline  (mng_handle hHandle);
+MNG_EXT mng_refresh       MNG_DECL mng_getcb_refresh       (mng_handle hHandle);
+
+/* see _setcb_ */
+MNG_EXT mng_gettickcount  MNG_DECL mng_getcb_gettickcount  (mng_handle hHandle);
+MNG_EXT mng_settimer      MNG_DECL mng_getcb_settimer      (mng_handle hHandle);
+
+/* see _setcb_ */
+#ifdef MNG_APP_CMS
+MNG_EXT mng_processgamma  MNG_DECL mng_getcb_processgamma  (mng_handle hHandle);
+MNG_EXT mng_processchroma MNG_DECL mng_getcb_processchroma (mng_handle hHandle);
+MNG_EXT mng_processsrgb   MNG_DECL mng_getcb_processsrgb   (mng_handle hHandle);
+MNG_EXT mng_processiccp   MNG_DECL mng_getcb_processiccp   (mng_handle hHandle);
+MNG_EXT mng_processarow   MNG_DECL mng_getcb_processarow   (mng_handle hHandle);
+#endif /* MNG_APP_CMS */
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Property set functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* Application data pointer */
+/* provided for application use; not used by the library */
+MNG_EXT mng_retcode MNG_DECL mng_set_userdata        (mng_handle        hHandle,
+                                                      mng_ptr           pUserdata);
+
+/* The style of the drawing- & background-canvas */
+/* only used for displaying images */
+/* both are initially set to 24-bit RGB (eg. 8-bit per channel) */
+MNG_EXT mng_retcode MNG_DECL mng_set_canvasstyle     (mng_handle        hHandle,
+                                                      mng_uint32        iStyle);
+MNG_EXT mng_retcode MNG_DECL mng_set_bkgdstyle       (mng_handle        hHandle,
+                                                      mng_uint32        iStyle);
+
+/* The default background color */
+/* only used if the getbkgdline callback is not defined */
+/* for initially painting the canvas and restoring (part of) the background */
+MNG_EXT mng_retcode MNG_DECL mng_set_bgcolor         (mng_handle        hHandle,
+                                                      mng_uint16        iRed,
+                                                      mng_uint16        iGreen,
+                                                      mng_uint16        iBlue);
+
+/* Indicates preferred use of the bKGD chunk for PNG images */
+MNG_EXT mng_retcode MNG_DECL mng_set_usebkgd         (mng_handle        hHandle,
+                                                      mng_bool          bUseBKGD);
+
+/* Indicates storage of read chunks */
+/* only useful if you #define mng_store_chunks */
+/* can be used to dynamically change storage management */
+MNG_EXT mng_retcode MNG_DECL mng_set_storechunks     (mng_handle        hHandle,
+                                                      mng_bool          bStorechunks);
+
+/* Indicates breaks requested when processing SAVE/SEEK */
+/* set this to let the app handle section breaks; the library will return
+   MNG_NEEDSECTIONWAIT return-codes for each SEEK chunk */
+MNG_EXT mng_retcode MNG_DECL mng_set_sectionbreaks   (mng_handle        hHandle,
+                                                      mng_bool          bSectionbreaks);
+
+/* Indicates storage of playback info (ON by default!) */
+/* can be used to turn off caching of playback info; this is useful to
+   specifically optimize MNG-video playback; note that if caching is turned off
+   LOOP chunks will be flagged as errors! TERM chunks will be ignored and only
+   passed to the processterm() callback if it is defined by the app; also, this
+   feature can only be used with mng_readdisplay(); mng_read(),
+   mng_display_reset() and mng_display_goxxxx() will return an error;
+   once this option is turned off it can't be turned on for the same stream!!! */
+MNG_EXT mng_retcode MNG_DECL mng_set_cacheplayback   (mng_handle        hHandle,
+                                                      mng_bool          bCacheplayback);
+
+/* Indicates automatic progressive refreshes for large images (ON by default!) */
+/* turn this off if you do not want intermittent painting while a large image
+   is being read. useful if the input-stream comes from a fast medium, such
+   as a local harddisk */
+MNG_EXT mng_retcode MNG_DECL mng_set_doprogressive   (mng_handle        hHandle,
+                                                      mng_bool          bDoProgressive);
+
+/* Indicates existence and required checking of the CRC in input streams,
+   and generation in output streams */
+/* !!!! Use this ONLY if you know what you are doing !!!! */
+/* The value is a combination of the following flags:
+   0x0000001 = CRC is present in the input stream
+   0x0000002 = CRC must be generated in the output stream
+   0x0000010 = CRC should be checked for ancillary chunks
+   0x0000020 = a faulty CRC for ancillary chunks generates a warning only
+   0x0000040 = a faulty CRC for ancillary chunks generates an error
+   0x0000100 = CRC should be checked for critical chunks
+   0x0000200 = a faulty CRC for critical chunks generates a warning only
+   0x0000400 = a faulty CRC for critical chunks generates an error
+
+   The default is 0x00000533 = CRC present in input streams; should be checked;
+                               warning for ancillary chunks; error for critical
+                               chunks; generate CRC for output streams
+
+   Note that some combinations are meaningless; eg. if the CRC is not present
+   it won't do any good to turn the checking flags on; if a checking flag
+   is off, it doesn't do any good to ask for generation of warnings or errors.
+   Also libmng will generate either an error or a warning, not both,
+   so if you specify both the default will be to generate an error!
+   The only useful combinations for input are 331, 551, 351, 531, 0, 301, 501
+   and optionally 031 and 051, but only checking ancillary chunks and not
+   critical chunks is generally not a very good idea!!!
+   If you've also writing these values should be combined with 0x02 if
+   CRC's are required in the output stream
+   */
+MNG_EXT mng_retcode MNG_DECL mng_set_crcmode         (mng_handle        hHandle,
+                                                      mng_uint32        iCrcmode);
+
+/* Color-management necessaries */
+/*
+    *************************************************************************
+                 !!!!!!!! THIS NEXT BIT IS IMPORTANT !!!!!!!!!
+    *************************************************************************
+
+    If you have defined MNG_FULL_CMS (and are using lcms), you will have to
+    think hard about the following routines.
+
+    lcms requires 2 profiles to work off the differences in the input-image
+    and the output-device. The ICC profile for the input-image will be
+    embedded within it to reflect its color-characteristics, but the output
+    profile depends on the output-device, which is something only *YOU* know
+    about. sRGB (standard RGB) is common for x86 compatible environments
+    (eg. Windows, Linux and some others)
+
+    If you are compiling for a sRGB compliant system you probably won't have
+    to do anything special. (unless you want to of course)
+
+    If you are compiling for a non-sRGB compliant system
+    (eg. SGI, Mac, Next, others...)
+    you *MUST* define a proper ICC profile for the generic output-device
+    associated with that platform.
+
+    In either event, you may also want to offer an option to your users to
+    set the profile manually, or, if you know how, set it from a
+    system-defined default.
+
+    TO RECAP: for sRGB systems (Windows, Linux) no action required!
+              for non-sRGB systems (SGI, Mac, Next) ACTION REQUIRED!
+
+    Please visit http://www.srgb.com, http://www.color.org and
+    http://www.littlecms.com for more info.
+
+    *************************************************************************
+                 !!!!!!!! THE BIT ABOVE IS IMPORTANT !!!!!!!!!
+    *************************************************************************
+*/
+/* mng_set_srgb tells libmng if it's running on a sRGB compliant system or not
+   the default is already set to MNG_TRUE */
+/* mng_set_outputprofile, mng_set_outputprofile2, mng_set_outputsrgb
+   are used to set the default profile describing the output-device
+   by default it is already initialized with an sRGB profile */
+/* mng_set_srgbprofile, mng_set_srgbprofile2, mng_set_srgbimplicit
+   are used to set the default profile describing a standard sRGB device
+   this is used when the input-image is tagged only as being sRGB, but the
+   output-device is defined as not being sRGB compliant
+   by default it is already initialized with a standard sRGB profile */
+#if defined(MNG_SUPPORT_DISPLAY)
+MNG_EXT mng_retcode MNG_DECL mng_set_srgb            (mng_handle        hHandle,
+                                                      mng_bool          bIssRGB);
+MNG_EXT mng_retcode MNG_DECL mng_set_outputprofile   (mng_handle        hHandle,
+                                                      mng_pchar         zFilename);
+MNG_EXT mng_retcode MNG_DECL mng_set_outputprofile2  (mng_handle        hHandle,
+                                                      mng_uint32        iProfilesize,
+                                                      mng_ptr           pProfile);
+MNG_EXT mng_retcode MNG_DECL mng_set_outputsrgb      (mng_handle        hHandle);
+MNG_EXT mng_retcode MNG_DECL mng_set_srgbprofile     (mng_handle        hHandle,
+                                                      mng_pchar         zFilename);
+MNG_EXT mng_retcode MNG_DECL mng_set_srgbprofile2    (mng_handle        hHandle,
+                                                      mng_uint32        iProfilesize,
+                                                      mng_ptr           pProfile);
+MNG_EXT mng_retcode MNG_DECL mng_set_srgbimplicit    (mng_handle        hHandle);
+#endif
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+/* Gamma settings */
+/* ... blabla (explain gamma processing a little; eg. formula & stuff) ... */
+MNG_EXT mng_retcode MNG_DECL mng_set_viewgamma       (mng_handle        hHandle,
+                                                      mng_float         dGamma);
+MNG_EXT mng_retcode MNG_DECL mng_set_displaygamma    (mng_handle        hHandle,
+                                                      mng_float         dGamma);
+MNG_EXT mng_retcode MNG_DECL mng_set_dfltimggamma    (mng_handle        hHandle,
+                                                      mng_float         dGamma);
+MNG_EXT mng_retcode MNG_DECL mng_set_viewgammaint    (mng_handle        hHandle,
+                                                      mng_uint32        iGamma);
+MNG_EXT mng_retcode MNG_DECL mng_set_displaygammaint (mng_handle        hHandle,
+                                                      mng_uint32        iGamma);
+MNG_EXT mng_retcode MNG_DECL mng_set_dfltimggammaint (mng_handle        hHandle,
+                                                      mng_uint32        iGamma);
+#endif
+
+#ifndef MNG_SKIP_MAXCANVAS
+/* Ultimate clipping size */
+/* used to limit extreme graphics from overloading the system */
+/* if a graphic exceeds these limits a warning is issued, which can
+   be ignored by the app (using the errorproc callback). in that case
+   the library will use these settings to clip the input graphic, and
+   the app's canvas must account for this */
+MNG_EXT mng_retcode MNG_DECL mng_set_maxcanvaswidth  (mng_handle        hHandle,
+                                                      mng_uint32        iMaxwidth);
+MNG_EXT mng_retcode MNG_DECL mng_set_maxcanvasheight (mng_handle        hHandle,
+                                                      mng_uint32        iMaxheight);
+MNG_EXT mng_retcode MNG_DECL mng_set_maxcanvassize   (mng_handle        hHandle,
+                                                      mng_uint32        iMaxwidth,
+                                                      mng_uint32        iMaxheight);
+#endif
+
+/* ZLIB default compression parameters */
+/* these are used when writing out chunks */
+/* they are also used when compressing PNG image-data or JNG alpha-data;
+   in this case you can set them just before calling mng_putimgdata_ihdr */
+/* set to your liking; usually the defaults will suffice though! */
+/* check the documentation for ZLIB for details on these parameters */
+#ifdef MNG_INCLUDE_ZLIB
+MNG_EXT mng_retcode MNG_DECL mng_set_zlib_level      (mng_handle        hHandle,
+                                                      mng_int32         iZlevel);
+MNG_EXT mng_retcode MNG_DECL mng_set_zlib_method     (mng_handle        hHandle,
+                                                      mng_int32         iZmethod);
+MNG_EXT mng_retcode MNG_DECL mng_set_zlib_windowbits (mng_handle        hHandle,
+                                                      mng_int32         iZwindowbits);
+MNG_EXT mng_retcode MNG_DECL mng_set_zlib_memlevel   (mng_handle        hHandle,
+                                                      mng_int32         iZmemlevel);
+MNG_EXT mng_retcode MNG_DECL mng_set_zlib_strategy   (mng_handle        hHandle,
+                                                      mng_int32         iZstrategy);
+
+MNG_EXT mng_retcode MNG_DECL mng_set_zlib_maxidat    (mng_handle        hHandle,
+                                                      mng_uint32        iMaxIDAT);
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* JNG default compression parameters (based on IJG code) */
+/* these are used when compressing JNG image-data; so you can set them
+   just before calling mng_putimgdata_jhdr */
+/* set to your liking; usually the defaults will suffice though! */
+/* check the documentation for IJGSRC6B for details on these parameters */
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_INCLUDE_IJG6B
+MNG_EXT mng_retcode MNG_DECL mng_set_jpeg_dctmethod  (mng_handle        hHandle,
+                                                      mngjpeg_dctmethod eJPEGdctmethod);
+#endif
+MNG_EXT mng_retcode MNG_DECL mng_set_jpeg_quality    (mng_handle        hHandle,
+                                                      mng_int32         iJPEGquality);
+MNG_EXT mng_retcode MNG_DECL mng_set_jpeg_smoothing  (mng_handle        hHandle,
+                                                      mng_int32         iJPEGsmoothing);
+MNG_EXT mng_retcode MNG_DECL mng_set_jpeg_progressive(mng_handle        hHandle,
+                                                      mng_bool          bJPEGprogressive);
+MNG_EXT mng_retcode MNG_DECL mng_set_jpeg_optimized  (mng_handle        hHandle,
+                                                      mng_bool          bJPEGoptimized);
+
+MNG_EXT mng_retcode MNG_DECL mng_set_jpeg_maxjdat    (mng_handle        hHandle,
+                                                      mng_uint32        iMaxJDAT);
+#endif /* MNG_INCLUDE_JNG */
+
+/* Suspension-mode setting */
+/* use this to activate the internal suspension-buffer to improve
+   read-suspension processing */
+/* TODO: write-suspension ??? */   
+#if defined(MNG_SUPPORT_READ)
+MNG_EXT mng_retcode MNG_DECL mng_set_suspensionmode  (mng_handle        hHandle,
+                                                      mng_bool          bSuspensionmode);
+#endif
+
+/* Speed setting */
+/* use this to influence the display-speed of animations */
+#if defined(MNG_SUPPORT_DISPLAY)
+MNG_EXT mng_retcode MNG_DECL mng_set_speed           (mng_handle        hHandle,
+                                                      mng_speedtype     iSpeed);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Property get functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* see _set_ */
+MNG_EXT mng_ptr     MNG_DECL mng_get_userdata        (mng_handle        hHandle);
+
+/* Network Graphic header details */
+/* these get filled once the graphics header is processed,
+   so they are available in the processheader callback; before that
+   they are zeroed out and imagetype is set to it_unknown */
+/* this might be a good point for the app to initialize the drawing-canvas! */
+/* note that some fields are only set for the first(!) header-chunk:
+   MNG/MHDR (imagetype = mng_it_mng) - ticks thru simplicity
+   PNG/IHDR (imagetype = mng_it_png) - bitdepth thru interlace
+   JNG/JHDR (imagetype = mng_it_jng) - bitdepth thru compression &
+                                       interlace thru alphainterlace */
+MNG_EXT mng_imgtype MNG_DECL mng_get_sigtype         (mng_handle        hHandle);
+MNG_EXT mng_imgtype MNG_DECL mng_get_imagetype       (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_imagewidth      (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_imageheight     (mng_handle        hHandle);
+
+MNG_EXT mng_uint32  MNG_DECL mng_get_ticks           (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_framecount      (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_layercount      (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_playtime        (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_simplicity      (mng_handle        hHandle);
+
+MNG_EXT mng_uint8   MNG_DECL mng_get_bitdepth        (mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_colortype       (mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_compression     (mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_filter          (mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_interlace       (mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_alphabitdepth   (mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_alphacompression(mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_alphafilter     (mng_handle        hHandle);
+MNG_EXT mng_uint8   MNG_DECL mng_get_alphainterlace  (mng_handle        hHandle);
+
+/* indicates the predicted alpha-depth required to properly display the image */
+/* gets set once the graphics header is processed and is available in the
+   processheader callback for any type of input-image (PNG, JNG or MNG) */
+/* possible values are 0,1,2,4,8,16
+   0  = no transparency required
+   1  = on/off transparency required (alpha-values are 0 or 2^bit_depth-1)
+   2+ = semi-transparency required (values will be scaled to the bitdepth of the
+                                    canvasstyle supplied by the application) */
+MNG_EXT mng_uint8   MNG_DECL mng_get_alphadepth      (mng_handle        hHandle);
+
+/* defines whether a refresh() callback is called for an interlace pass (PNG)
+   or progressive scan (JNG) */
+/* returns the interlace pass number for PNG or a fabricated pass number for JNG;
+   returns 0 in all other cases */
+/* only useful if the image_type = mng_it_png or mng_it_jng and if the image
+   is actually interlaced (PNG) or progressive (JNG) */
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_uint8   MNG_DECL mng_get_refreshpass     (mng_handle        hHandle);
+#endif
+
+/* see _set_ */
+MNG_EXT mng_uint32  MNG_DECL mng_get_canvasstyle     (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_bkgdstyle       (mng_handle        hHandle);
+
+/* see _set_ */
+MNG_EXT mng_retcode MNG_DECL mng_get_bgcolor         (mng_handle        hHandle,
+                                                      mng_uint16*       iRed,
+                                                      mng_uint16*       iGreen,
+                                                      mng_uint16*       iBlue);
+
+/* see _set_ */
+MNG_EXT mng_bool    MNG_DECL mng_get_usebkgd         (mng_handle        hHandle);
+
+/* see _set_ */
+MNG_EXT mng_bool    MNG_DECL mng_get_storechunks     (mng_handle        hHandle);
+
+/* see _set_ */
+MNG_EXT mng_bool    MNG_DECL mng_get_sectionbreaks   (mng_handle        hHandle);
+
+/* see _set_ */
+MNG_EXT mng_bool    MNG_DECL mng_get_cacheplayback   (mng_handle        hHandle);
+
+/* see _set_ */
+MNG_EXT mng_bool    MNG_DECL mng_get_doprogressive   (mng_handle        hHandle);
+
+/* see _set_ */
+MNG_EXT mng_uint32  MNG_DECL mng_get_crcmode         (mng_handle        hHandle);
+
+/* see _set_ */
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_FULL_CMS)
+MNG_EXT mng_bool    MNG_DECL mng_get_srgb            (mng_handle        hHandle);
+#endif
+
+/* see _set_ */
+MNG_EXT mng_float   MNG_DECL mng_get_viewgamma       (mng_handle        hHandle);
+MNG_EXT mng_float   MNG_DECL mng_get_displaygamma    (mng_handle        hHandle);
+MNG_EXT mng_float   MNG_DECL mng_get_dfltimggamma    (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_viewgammaint    (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_displaygammaint (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_dfltimggammaint (mng_handle        hHandle);
+
+#ifndef MNG_SKIP_MAXCANVAS
+/* see _set_ */
+MNG_EXT mng_uint32  MNG_DECL mng_get_maxcanvaswidth  (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_maxcanvasheight (mng_handle        hHandle);
+#endif
+
+/* see _set_ */
+#ifdef MNG_INCLUDE_ZLIB
+MNG_EXT mng_int32   MNG_DECL mng_get_zlib_level      (mng_handle        hHandle);
+MNG_EXT mng_int32   MNG_DECL mng_get_zlib_method     (mng_handle        hHandle);
+MNG_EXT mng_int32   MNG_DECL mng_get_zlib_windowbits (mng_handle        hHandle);
+MNG_EXT mng_int32   MNG_DECL mng_get_zlib_memlevel   (mng_handle        hHandle);
+MNG_EXT mng_int32   MNG_DECL mng_get_zlib_strategy   (mng_handle        hHandle);
+
+MNG_EXT mng_uint32  MNG_DECL mng_get_zlib_maxidat    (mng_handle        hHandle);
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* see _set_ */
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_INCLUDE_IJG6B
+MNG_EXT mngjpeg_dctmethod
+                    MNG_DECL mng_get_jpeg_dctmethod  (mng_handle        hHandle);
+#endif
+MNG_EXT mng_int32   MNG_DECL mng_get_jpeg_quality    (mng_handle        hHandle);
+MNG_EXT mng_int32   MNG_DECL mng_get_jpeg_smoothing  (mng_handle        hHandle);
+MNG_EXT mng_bool    MNG_DECL mng_get_jpeg_progressive(mng_handle        hHandle);
+MNG_EXT mng_bool    MNG_DECL mng_get_jpeg_optimized  (mng_handle        hHandle);
+
+MNG_EXT mng_uint32  MNG_DECL mng_get_jpeg_maxjdat    (mng_handle        hHandle);
+#endif /* MNG_INCLUDE_JNG */
+
+/* see _set_  */
+#if defined(MNG_SUPPORT_READ)
+MNG_EXT mng_bool    MNG_DECL mng_get_suspensionmode  (mng_handle        hHandle);
+#endif
+
+/* see _set_  */
+#if defined(MNG_SUPPORT_DISPLAY)
+MNG_EXT mng_speedtype
+                    MNG_DECL mng_get_speed           (mng_handle        hHandle);
+#endif
+
+/* Image-level */
+/* this can be used inside the processtext callback to determine the level of
+   text of the image being processed; the value 1 is returned for top-level
+   texts, and the value 2 for a text inside an embedded image inside a MNG */
+MNG_EXT mng_uint32  MNG_DECL mng_get_imagelevel      (mng_handle        hHandle);
+
+/* BACK info */
+/* can be used to retrieve the color & mandatory values for the last processed
+   BACK chunk of a MNG (will fail for other image-types);
+   if no BACK chunk was processed yet, it will return all zeroes */
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_retcode MNG_DECL mng_get_lastbackchunk   (mng_handle        hHandle,
+                                                      mng_uint16*       iRed,
+                                                      mng_uint16*       iGreen,
+                                                      mng_uint16*       iBlue,
+                                                      mng_uint8*        iMandatory);
+#endif
+
+/* SEEK info */
+/* can be used to retrieve the segmentname of the last processed SEEK chunk;
+   if no SEEK chunk was processed or its segmentname was empty, the function
+   will return an empty string; the provided buffer must be at least 80 bytes!! */
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_retcode MNG_DECL mng_get_lastseekname    (mng_handle        hHandle,
+                                                      mng_pchar         zSegmentname);
+#endif
+
+/* FRAM info */
+/* can be used to retrieve the current FRAM delay; this may be useful when
+   retrieving a stream of frames with their corresponding delays by "fake"
+   reading and displaying the file */
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_uint32 MNG_DECL mng_get_currframdelay    (mng_handle        hHandle);
+#endif
+
+/* Display status variables */
+/* these get filled & updated during display processing */
+/* starttime is the tickcount at the start of displaying the animation */
+/* runtime is the actual number of millisecs since the start of the animation */
+/* currentframe, currentlayer & currentplaytime indicate the current
+   frame/layer/playtime(msecs) in the animation (these keep increasing;
+   even after the animation loops back to the TERM chunk) */
+/* totalframes, totallayers & totalplaytime are filled after a complete run
+   of an animation (eg. at MEND); they are also valid after just reading the MNG */
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_uint32  MNG_DECL mng_get_starttime       (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_runtime         (mng_handle        hHandle);
+#ifndef MNG_NO_CURRENT_INFO
+MNG_EXT mng_uint32  MNG_DECL mng_get_currentframe    (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_currentlayer    (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_currentplaytime (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_totalframes     (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_totallayers     (mng_handle        hHandle);
+MNG_EXT mng_uint32  MNG_DECL mng_get_totalplaytime   (mng_handle        hHandle);
+#endif
+#endif
+
+/* Status variables */
+/* these indicate the internal state of the library */
+/* most indicate exactly what you would expect -
+   status_error:        true if the last function call returned an errorcode
+   status_reading:      true if the library is (still) reading an image
+   status_suspendbreak: true if the library has suspended for "I/O"
+   status_creating:     true if the library is in the middle of creating an image
+   status_writing:      true if the library is in the middle of writing an image
+   status_displaying:   true if the library is displaying an image
+   status_running:      true if display processing is active (eg. not frozen or reset)
+   status_timerbreak:   true if the library has suspended for a "timer-break"
+   status_dynamic:      true if the library encountered an evNT chunk in the MNG
+   status_runningevent: true if the library is processing an external event */
+/* eg. mng_readdisplay() will turn the reading, displaying and running status on;
+   when EOF is reached the reading status will be turned off */   
+MNG_EXT mng_bool    MNG_DECL mng_status_error        (mng_handle        hHandle);
+#ifdef MNG_SUPPORT_READ
+MNG_EXT mng_bool    MNG_DECL mng_status_reading      (mng_handle        hHandle);
+MNG_EXT mng_bool    MNG_DECL mng_status_suspendbreak (mng_handle        hHandle);
+#endif
+#ifdef MNG_SUPPORT_WRITE
+MNG_EXT mng_bool    MNG_DECL mng_status_creating     (mng_handle        hHandle);
+MNG_EXT mng_bool    MNG_DECL mng_status_writing      (mng_handle        hHandle);
+#endif
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_EXT mng_bool    MNG_DECL mng_status_displaying   (mng_handle        hHandle);
+MNG_EXT mng_bool    MNG_DECL mng_status_running      (mng_handle        hHandle);
+MNG_EXT mng_bool    MNG_DECL mng_status_timerbreak   (mng_handle        hHandle);
+#endif
+#ifdef MNG_SUPPORT_DYNAMICMNG
+MNG_EXT mng_bool    MNG_DECL mng_status_dynamic      (mng_handle        hHandle);
+MNG_EXT mng_bool    MNG_DECL mng_status_runningevent (mng_handle        hHandle);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Chunk access functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_ACCESS_CHUNKS
+
+/* ************************************************************************** */
+
+/* use this to iterate the stored chunks */
+/* requires MNG_ACCESS_CHUNKS & MNG_STORE_CHUNKS */
+/* starts from the supplied chunk-index-nr; the first chunk has index 0!! */
+MNG_EXT mng_retcode MNG_DECL mng_iterate_chunks      (mng_handle       hHandle,
+                                                      mng_uint32       iChunkseq,
+                                                      mng_iteratechunk fProc);
+
+/* use the next function inside your 'iteratechunk' callback to copy
+   the given chunk to a new mng you are creating */
+/* the 'out' handle should be in 'create' status! */
+#ifdef MNG_SUPPORT_WRITE
+MNG_EXT mng_retcode MNG_DECL mng_copy_chunk          (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_handle       hHandleOut);
+#endif
+
+/* ************************************************************************** */
+
+/* use these to get chunk data from within the callback in iterate_chunks */
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_ihdr       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iWidth,
+                                                      mng_uint32       *iHeight,
+                                                      mng_uint8        *iBitdepth,
+                                                      mng_uint8        *iColortype,
+                                                      mng_uint8        *iCompression,
+                                                      mng_uint8        *iFilter,
+                                                      mng_uint8        *iInterlace);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_plte       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iCount,
+                                                      mng_palette8     *aPalette);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_idat       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iRawlen,
+                                                      mng_ptr          *pRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_trns       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_bool         *bGlobal,
+                                                      mng_uint8        *iType,
+                                                      mng_uint32       *iCount,
+                                                      mng_uint8arr     *aAlphas,
+                                                      mng_uint16       *iGray,
+                                                      mng_uint16       *iRed,
+                                                      mng_uint16       *iGreen,
+                                                      mng_uint16       *iBlue,
+                                                      mng_uint32       *iRawlen,
+                                                      mng_uint8arr     *aRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_gama       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint32       *iGamma);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_chrm       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint32       *iWhitepointx,
+                                                      mng_uint32       *iWhitepointy,
+                                                      mng_uint32       *iRedx,
+                                                      mng_uint32       *iRedy,
+                                                      mng_uint32       *iGreenx,
+                                                      mng_uint32       *iGreeny,
+                                                      mng_uint32       *iBluex,
+                                                      mng_uint32       *iBluey);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_srgb       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint8        *iRenderingintent);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_iccp       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint32       *iNamesize,
+                                                      mng_pchar        *zName,
+                                                      mng_uint8        *iCompression,
+                                                      mng_uint32       *iProfilesize,
+                                                      mng_ptr          *pProfile);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_text       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iKeywordsize,
+                                                      mng_pchar        *zKeyword,
+                                                      mng_uint32       *iTextsize,
+                                                      mng_pchar        *zText);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_ztxt       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iKeywordsize,
+                                                      mng_pchar        *zKeyword,
+                                                      mng_uint8        *iCompression,
+                                                      mng_uint32       *iTextsize,
+                                                      mng_pchar        *zText);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_itxt       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iKeywordsize,
+                                                      mng_pchar        *zKeyword,
+                                                      mng_uint8        *iCompressionflag,
+                                                      mng_uint8        *iCompressionmethod,
+                                                      mng_uint32       *iLanguagesize,
+                                                      mng_pchar        *zLanguage,
+                                                      mng_uint32       *iTranslationsize,
+                                                      mng_pchar        *zTranslation,
+                                                      mng_uint32       *iTextsize,
+                                                      mng_pchar        *zText);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_bkgd       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint8        *iType,
+                                                      mng_uint8        *iIndex,
+                                                      mng_uint16       *iGray,
+                                                      mng_uint16       *iRed,
+                                                      mng_uint16       *iGreen,
+                                                      mng_uint16       *iBlue);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_phys       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint32       *iSizex,
+                                                      mng_uint32       *iSizey,
+                                                      mng_uint8        *iUnit);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_sbit       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint8        *iType,
+                                                      mng_uint8arr4    *aBits);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_splt       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint32       *iNamesize,
+                                                      mng_pchar        *zName,
+                                                      mng_uint8        *iSampledepth,
+                                                      mng_uint32       *iEntrycount,
+                                                      mng_ptr          *pEntries);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_hist       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iEntrycount,
+                                                      mng_uint16arr    *aEntries);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_time       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iYear,
+                                                      mng_uint8        *iMonth,
+                                                      mng_uint8        *iDay,
+                                                      mng_uint8        *iHour,
+                                                      mng_uint8        *iMinute,
+                                                      mng_uint8        *iSecond);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_mhdr       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iWidth,
+                                                      mng_uint32       *iHeight,
+                                                      mng_uint32       *iTicks,
+                                                      mng_uint32       *iLayercount,
+                                                      mng_uint32       *iFramecount,
+                                                      mng_uint32       *iPlaytime,
+                                                      mng_uint32       *iSimplicity);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_loop       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint8        *iLevel,
+                                                      mng_uint32       *iRepeat,
+                                                      mng_uint8        *iTermination,
+                                                      mng_uint32       *iItermin,
+                                                      mng_uint32       *iItermax,
+                                                      mng_uint32       *iCount,
+                                                      mng_uint32p      *pSignals);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_endl       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint8        *iLevel);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_defi       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iObjectid,
+                                                      mng_uint8        *iDonotshow,
+                                                      mng_uint8        *iConcrete,
+                                                      mng_bool         *bHasloca,
+                                                      mng_int32        *iXlocation,
+                                                      mng_int32        *iYlocation,
+                                                      mng_bool         *bHasclip,
+                                                      mng_int32        *iLeftcb,
+                                                      mng_int32        *iRightcb,
+                                                      mng_int32        *iTopcb,
+                                                      mng_int32        *iBottomcb);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_basi       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iWidth,
+                                                      mng_uint32       *iHeight,
+                                                      mng_uint8        *iBitdepth,
+                                                      mng_uint8        *iColortype,
+                                                      mng_uint8        *iCompression,
+                                                      mng_uint8        *iFilter,
+                                                      mng_uint8        *iInterlace,
+                                                      mng_uint16       *iRed,
+                                                      mng_uint16       *iGreen,
+                                                      mng_uint16       *iBlue,
+                                                      mng_uint16       *iAlpha,
+                                                      mng_uint8        *iViewable);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_clon       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iSourceid,
+                                                      mng_uint16       *iCloneid,
+                                                      mng_uint8        *iClonetype,
+                                                      mng_uint8        *iDonotshow,
+                                                      mng_uint8        *iConcrete,
+                                                      mng_bool         *bHasloca,
+                                                      mng_uint8        *iLocationtype,
+                                                      mng_int32        *iLocationx,
+                                                      mng_int32        *iLocationy);
+
+#ifndef MNG_SKIPCHUNK_PAST
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_past       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iDestid,
+                                                      mng_uint8        *iTargettype,
+                                                      mng_int32        *iTargetx,
+                                                      mng_int32        *iTargety,
+                                                      mng_uint32       *iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_past_src   (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint16       *iSourceid,
+                                                      mng_uint8        *iComposition,
+                                                      mng_uint8        *iOrientation,
+                                                      mng_uint8        *iOffsettype,
+                                                      mng_int32        *iOffsetx,
+                                                      mng_int32        *iOffsety,
+                                                      mng_uint8        *iBoundarytype,
+                                                      mng_int32        *iBoundaryl,
+                                                      mng_int32        *iBoundaryr,
+                                                      mng_int32        *iBoundaryt,
+                                                      mng_int32        *iBoundaryb);
+#endif
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_disc       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iCount,
+                                                      mng_uint16p      *pObjectids);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_back       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iRed,
+                                                      mng_uint16       *iGreen,
+                                                      mng_uint16       *iBlue,
+                                                      mng_uint8        *iMandatory,
+                                                      mng_uint16       *iImageid,
+                                                      mng_uint8        *iTile);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_fram       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint8        *iMode,
+                                                      mng_uint32       *iNamesize,
+                                                      mng_pchar        *zName,
+                                                      mng_uint8        *iChangedelay,
+                                                      mng_uint8        *iChangetimeout,
+                                                      mng_uint8        *iChangeclipping,
+                                                      mng_uint8        *iChangesyncid,
+                                                      mng_uint32       *iDelay,
+                                                      mng_uint32       *iTimeout,
+                                                      mng_uint8        *iBoundarytype,
+                                                      mng_int32        *iBoundaryl,
+                                                      mng_int32        *iBoundaryr,
+                                                      mng_int32        *iBoundaryt,
+                                                      mng_int32        *iBoundaryb,
+                                                      mng_uint32       *iCount,
+                                                      mng_uint32p      *pSyncids);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_move       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iFirstid,
+                                                      mng_uint16       *iLastid,
+                                                      mng_uint8        *iMovetype,
+                                                      mng_int32        *iMovex,
+                                                      mng_int32        *iMovey);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_clip       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iFirstid,
+                                                      mng_uint16       *iLastid,
+                                                      mng_uint8        *iCliptype,
+                                                      mng_int32        *iClipl,
+                                                      mng_int32        *iClipr,
+                                                      mng_int32        *iClipt,
+                                                      mng_int32        *iClipb);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_show       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint16       *iFirstid,
+                                                      mng_uint16       *iLastid,
+                                                      mng_uint8        *iMode);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_term       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint8        *iTermaction,
+                                                      mng_uint8        *iIteraction,
+                                                      mng_uint32       *iDelay,
+                                                      mng_uint32       *iItermax);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_save       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint8        *iOffsettype,
+                                                      mng_uint32       *iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_save_entry (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint8        *iEntrytype,
+                                                      mng_uint32arr2   *iOffset,
+                                                      mng_uint32arr2   *iStarttime,
+                                                      mng_uint32       *iLayernr,
+                                                      mng_uint32       *iFramenr,
+                                                      mng_uint32       *iNamesize,
+                                                      mng_pchar        *zName);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_seek       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iNamesize,
+                                                      mng_pchar        *zName);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_expi       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iSnapshotid,
+                                                      mng_uint32       *iNamesize,
+                                                      mng_pchar        *zName);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_fpri       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint8        *iDeltatype,
+                                                      mng_uint8        *iPriority);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_need       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iKeywordssize,
+                                                      mng_pchar        *zKeywords);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_phyg       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_bool         *bEmpty,
+                                                      mng_uint32       *iSizex,
+                                                      mng_uint32       *iSizey,
+                                                      mng_uint8        *iUnit);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_jhdr       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iWidth,
+                                                      mng_uint32       *iHeight,
+                                                      mng_uint8        *iColortype,
+                                                      mng_uint8        *iImagesampledepth,
+                                                      mng_uint8        *iImagecompression,
+                                                      mng_uint8        *iImageinterlace,
+                                                      mng_uint8        *iAlphasampledepth,
+                                                      mng_uint8        *iAlphacompression,
+                                                      mng_uint8        *iAlphafilter,
+                                                      mng_uint8        *iAlphainterlace);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_jdat       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iRawlen,
+                                                      mng_ptr          *pRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_jdaa       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iRawlen,
+                                                      mng_ptr          *pRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_dhdr       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iObjectid,
+                                                      mng_uint8        *iImagetype,
+                                                      mng_uint8        *iDeltatype,
+                                                      mng_uint32       *iBlockwidth,
+                                                      mng_uint32       *iBlockheight,
+                                                      mng_uint32       *iBlockx,
+                                                      mng_uint32       *iBlocky);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_prom       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint8        *iColortype,
+                                                      mng_uint8        *iSampledepth,
+                                                      mng_uint8        *iFilltype);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_pplt       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint8        *iDeltatype,
+                                                      mng_uint32       *iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_pplt_entry (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint16       *iRed,
+                                                      mng_uint16       *iGreen,
+                                                      mng_uint16       *iBlue,
+                                                      mng_uint16       *iAlpha,
+                                                      mng_bool         *bUsed);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_drop       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iCount,
+                                                      mng_chunkidp     *pChunknames);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_dbyk       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_chunkid      *iChunkname,
+                                                      mng_uint8        *iPolarity,
+                                                      mng_uint32       *iKeywordssize,
+                                                      mng_pchar        *zKeywords);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_ordr       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_ordr_entry (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       iEntry,
+                                                      mng_chunkid      *iChunkname,
+                                                      mng_uint8        *iOrdertype);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_magn       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint16       *iFirstid,
+                                                      mng_uint16       *iLastid,
+                                                      mng_uint16       *iMethodX,
+                                                      mng_uint16       *iMX,
+                                                      mng_uint16       *iMY,
+                                                      mng_uint16       *iML,
+                                                      mng_uint16       *iMR,
+                                                      mng_uint16       *iMT,
+                                                      mng_uint16       *iMB,
+                                                      mng_uint16       *iMethodY);
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_mpng       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iFramewidth,
+                                                      mng_uint32       *iFrameheight,
+                                                      mng_uint16       *iNumplays,
+                                                      mng_uint16       *iTickspersec,
+                                                      mng_uint8        *iCompressionmethod,
+                                                      mng_uint32       *iCount);
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_mpng_frame (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint32       *iX,
+                                                      mng_uint32       *iY,
+                                                      mng_uint32       *iWidth,
+                                                      mng_uint32       *iHeight,
+                                                      mng_int32        *iXoffset,
+                                                      mng_int32        *iYoffset,
+                                                      mng_uint16       *iTicks);
+#endif
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_evnt       (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       *iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_evnt_entry (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint8        *iEventtype,
+                                                      mng_uint8        *iMasktype,
+                                                      mng_int32        *iLeft,
+                                                      mng_int32        *iRight,
+                                                      mng_int32        *iTop,
+                                                      mng_int32        *iBottom,
+                                                      mng_uint16       *iObjectid,
+                                                      mng_uint8        *iIndex,
+                                                      mng_uint32       *iSegmentnamesize,
+                                                      mng_pchar        *zSegmentname);
+
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_unknown    (mng_handle       hHandle,
+                                                      mng_handle       hChunk,
+                                                      mng_chunkid      *iChunkname,
+                                                      mng_uint32       *iRawlen,
+                                                      mng_ptr          *pRawdata);
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+/* use these to create new chunks at the end of the chunk-list */
+/* requires at least MNG_ACCESS_CHUNKS (MNG_SUPPORT_WRITE may be nice too) */
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_ihdr       (mng_handle       hHandle,
+                                                      mng_uint32       iWidth,
+                                                      mng_uint32       iHeight,
+                                                      mng_uint8        iBitdepth,
+                                                      mng_uint8        iColortype,
+                                                      mng_uint8        iCompression,
+                                                      mng_uint8        iFilter,
+                                                      mng_uint8        iInterlace);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_plte       (mng_handle       hHandle,
+                                                      mng_uint32       iCount,
+                                                      mng_palette8     aPalette);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_idat       (mng_handle       hHandle,
+                                                      mng_uint32       iRawlen,
+                                                      mng_ptr          pRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_iend       (mng_handle       hHandle);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_trns       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_bool         bGlobal,
+                                                      mng_uint8        iType,
+                                                      mng_uint32       iCount,
+                                                      mng_uint8arr     aAlphas,
+                                                      mng_uint16       iGray,
+                                                      mng_uint16       iRed,
+                                                      mng_uint16       iGreen,
+                                                      mng_uint16       iBlue,
+                                                      mng_uint32       iRawlen,
+                                                      mng_uint8arr     aRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_gama       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint32       iGamma);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_chrm       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint32       iWhitepointx,
+                                                      mng_uint32       iWhitepointy,
+                                                      mng_uint32       iRedx,
+                                                      mng_uint32       iRedy,
+                                                      mng_uint32       iGreenx,
+                                                      mng_uint32       iGreeny,
+                                                      mng_uint32       iBluex,
+                                                      mng_uint32       iBluey);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_srgb       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint8        iRenderingintent);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_iccp       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint32       iNamesize,
+                                                      mng_pchar        zName,
+                                                      mng_uint8        iCompression,
+                                                      mng_uint32       iProfilesize,
+                                                      mng_ptr          pProfile);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_text       (mng_handle       hHandle,
+                                                      mng_uint32       iKeywordsize,
+                                                      mng_pchar        zKeyword,
+                                                      mng_uint32       iTextsize,
+                                                      mng_pchar        zText);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_ztxt       (mng_handle       hHandle,
+                                                      mng_uint32       iKeywordsize,
+                                                      mng_pchar        zKeyword,
+                                                      mng_uint8        iCompression,
+                                                      mng_uint32       iTextsize,
+                                                      mng_pchar        zText);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_itxt       (mng_handle       hHandle,
+                                                      mng_uint32       iKeywordsize,
+                                                      mng_pchar        zKeyword,
+                                                      mng_uint8        iCompressionflag,
+                                                      mng_uint8        iCompressionmethod,
+                                                      mng_uint32       iLanguagesize,
+                                                      mng_pchar        zLanguage,
+                                                      mng_uint32       iTranslationsize,
+                                                      mng_pchar        zTranslation,
+                                                      mng_uint32       iTextsize,
+                                                      mng_pchar        zText);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_bkgd       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint8        iType,
+                                                      mng_uint8        iIndex,
+                                                      mng_uint16       iGray,
+                                                      mng_uint16       iRed,
+                                                      mng_uint16       iGreen,
+                                                      mng_uint16       iBlue);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_phys       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint32       iSizex,
+                                                      mng_uint32       iSizey,
+                                                      mng_uint8        iUnit);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_sbit       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint8        iType,
+                                                      mng_uint8arr4    aBits);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_splt       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint32       iNamesize,
+                                                      mng_pchar        zName,
+                                                      mng_uint8        iSampledepth,
+                                                      mng_uint32       iEntrycount,
+                                                      mng_ptr          pEntries);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_hist       (mng_handle       hHandle,
+                                                      mng_uint32       iEntrycount,
+                                                      mng_uint16arr    aEntries);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_time       (mng_handle       hHandle,
+                                                      mng_uint16       iYear,
+                                                      mng_uint8        iMonth,
+                                                      mng_uint8        iDay,
+                                                      mng_uint8        iHour,
+                                                      mng_uint8        iMinute,
+                                                      mng_uint8        iSecond);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_mhdr       (mng_handle       hHandle,
+                                                      mng_uint32       iWidth,
+                                                      mng_uint32       iHeight,
+                                                      mng_uint32       iTicks,
+                                                      mng_uint32       iLayercount,
+                                                      mng_uint32       iFramecount,
+                                                      mng_uint32       iPlaytime,
+                                                      mng_uint32       iSimplicity);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_mend       (mng_handle       hHandle);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_loop       (mng_handle       hHandle,
+                                                      mng_uint8        iLevel,
+                                                      mng_uint32       iRepeat,
+                                                      mng_uint8        iTermination,
+                                                      mng_uint32       iItermin,
+                                                      mng_uint32       iItermax,
+                                                      mng_uint32       iCount,
+                                                      mng_uint32p      pSignals);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_endl       (mng_handle       hHandle,
+                                                      mng_uint8        iLevel);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_defi       (mng_handle       hHandle,
+                                                      mng_uint16       iObjectid,
+                                                      mng_uint8        iDonotshow,
+                                                      mng_uint8        iConcrete,
+                                                      mng_bool         bHasloca,
+                                                      mng_int32        iXlocation,
+                                                      mng_int32        iYlocation,
+                                                      mng_bool         bHasclip,
+                                                      mng_int32        iLeftcb,
+                                                      mng_int32        iRightcb,
+                                                      mng_int32        iTopcb,
+                                                      mng_int32        iBottomcb);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_basi       (mng_handle       hHandle,
+                                                      mng_uint32       iWidth,
+                                                      mng_uint32       iHeight,
+                                                      mng_uint8        iBitdepth,
+                                                      mng_uint8        iColortype,
+                                                      mng_uint8        iCompression,
+                                                      mng_uint8        iFilter,
+                                                      mng_uint8        iInterlace,
+                                                      mng_uint16       iRed,
+                                                      mng_uint16       iGreen,
+                                                      mng_uint16       iBlue,
+                                                      mng_uint16       iAlpha,
+                                                      mng_uint8        iViewable);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_clon       (mng_handle       hHandle,
+                                                      mng_uint16       iSourceid,
+                                                      mng_uint16       iCloneid,
+                                                      mng_uint8        iClonetype,
+                                                      mng_uint8        iDonotshow,
+                                                      mng_uint8        iConcrete,
+                                                      mng_bool         bHasloca,
+                                                      mng_uint8        iLocationtype,
+                                                      mng_int32        iLocationx,
+                                                      mng_int32        iLocationy);
+
+#ifndef MNG_SKIPCHUNK_PAST
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_past       (mng_handle       hHandle,
+                                                      mng_uint16       iDestid,
+                                                      mng_uint8        iTargettype,
+                                                      mng_int32        iTargetx,
+                                                      mng_int32        iTargety,
+                                                      mng_uint32       iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_past_src   (mng_handle       hHandle,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint16       iSourceid,
+                                                      mng_uint8        iComposition,
+                                                      mng_uint8        iOrientation,
+                                                      mng_uint8        iOffsettype,
+                                                      mng_int32        iOffsetx,
+                                                      mng_int32        iOffsety,
+                                                      mng_uint8        iBoundarytype,
+                                                      mng_int32        iBoundaryl,
+                                                      mng_int32        iBoundaryr,
+                                                      mng_int32        iBoundaryt,
+                                                      mng_int32        iBoundaryb);
+#endif
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_disc       (mng_handle       hHandle,
+                                                      mng_uint32       iCount,
+                                                      mng_uint16p      pObjectids);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_back       (mng_handle       hHandle,
+                                                      mng_uint16       iRed,
+                                                      mng_uint16       iGreen,
+                                                      mng_uint16       iBlue,
+                                                      mng_uint8        iMandatory,
+                                                      mng_uint16       iImageid,
+                                                      mng_uint8        iTile);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_fram       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint8        iMode,
+                                                      mng_uint32       iNamesize,
+                                                      mng_pchar        zName,
+                                                      mng_uint8        iChangedelay,
+                                                      mng_uint8        iChangetimeout,
+                                                      mng_uint8        iChangeclipping,
+                                                      mng_uint8        iChangesyncid,
+                                                      mng_uint32       iDelay,
+                                                      mng_uint32       iTimeout,
+                                                      mng_uint8        iBoundarytype,
+                                                      mng_int32        iBoundaryl,
+                                                      mng_int32        iBoundaryr,
+                                                      mng_int32        iBoundaryt,
+                                                      mng_int32        iBoundaryb,
+                                                      mng_uint32       iCount,
+                                                      mng_uint32p      pSyncids);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_move       (mng_handle       hHandle,
+                                                      mng_uint16       iFirstid,
+                                                      mng_uint16       iLastid,
+                                                      mng_uint8        iMovetype,
+                                                      mng_int32        iMovex,
+                                                      mng_int32        iMovey);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_clip       (mng_handle       hHandle,
+                                                      mng_uint16       iFirstid,
+                                                      mng_uint16       iLastid,
+                                                      mng_uint8        iCliptype,
+                                                      mng_int32        iClipl,
+                                                      mng_int32        iClipr,
+                                                      mng_int32        iClipt,
+                                                      mng_int32        iClipb);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_show       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint16       iFirstid,
+                                                      mng_uint16       iLastid,
+                                                      mng_uint8        iMode);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_term       (mng_handle       hHandle,
+                                                      mng_uint8        iTermaction,
+                                                      mng_uint8        iIteraction,
+                                                      mng_uint32       iDelay,
+                                                      mng_uint32       iItermax);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_save       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint8        iOffsettype,
+                                                      mng_uint32       iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_save_entry (mng_handle       hHandle,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint8        iEntrytype,
+                                                      mng_uint32arr2   iOffset,
+                                                      mng_uint32arr2   iStarttime,
+                                                      mng_uint32       iLayernr,
+                                                      mng_uint32       iFramenr,
+                                                      mng_uint32       iNamesize,
+                                                      mng_pchar        zName);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_seek       (mng_handle       hHandle,
+                                                      mng_uint32       iNamesize,
+                                                      mng_pchar        zName);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_expi       (mng_handle       hHandle,
+                                                      mng_uint16       iSnapshotid,
+                                                      mng_uint32       iNamesize,
+                                                      mng_pchar        zName);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_fpri       (mng_handle       hHandle,
+                                                      mng_uint8        iDeltatype,
+                                                      mng_uint8        iPriority);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_need       (mng_handle       hHandle,
+                                                      mng_uint32       iKeywordssize,
+                                                      mng_pchar        zKeywords);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_phyg       (mng_handle       hHandle,
+                                                      mng_bool         bEmpty,
+                                                      mng_uint32       iSizex,
+                                                      mng_uint32       iSizey,
+                                                      mng_uint8        iUnit);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_jhdr       (mng_handle       hHandle,
+                                                      mng_uint32       iWidth,
+                                                      mng_uint32       iHeight,
+                                                      mng_uint8        iColortype,
+                                                      mng_uint8        iImagesampledepth,
+                                                      mng_uint8        iImagecompression,
+                                                      mng_uint8        iImageinterlace,
+                                                      mng_uint8        iAlphasampledepth,
+                                                      mng_uint8        iAlphacompression,
+                                                      mng_uint8        iAlphafilter,
+                                                      mng_uint8        iAlphainterlace);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_jdat       (mng_handle       hHandle,
+                                                      mng_uint32       iRawlen,
+                                                      mng_ptr          pRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_jdaa       (mng_handle       hHandle,
+                                                      mng_uint32       iRawlen,
+                                                      mng_ptr          pRawdata);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_jsep       (mng_handle       hHandle);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_dhdr       (mng_handle       hHandle,
+                                                      mng_uint16       iObjectid,
+                                                      mng_uint8        iImagetype,
+                                                      mng_uint8        iDeltatype,
+                                                      mng_uint32       iBlockwidth,
+                                                      mng_uint32       iBlockheight,
+                                                      mng_uint32       iBlockx,
+                                                      mng_uint32       iBlocky);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_prom       (mng_handle       hHandle,
+                                                      mng_uint8        iColortype,
+                                                      mng_uint8        iSampledepth,
+                                                      mng_uint8        iFilltype);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_ipng       (mng_handle       hHandle);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_pplt       (mng_handle       hHandle,
+                                                      mng_uint8        iDeltatype,
+                                                      mng_uint32       iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_pplt_entry (mng_handle       hHandle,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint16       iRed,
+                                                      mng_uint16       iGreen,
+                                                      mng_uint16       iBlue,
+                                                      mng_uint16       iAlpha);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_jpng       (mng_handle       hHandle);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_drop       (mng_handle       hHandle,
+                                                      mng_uint32       iCount,
+                                                      mng_chunkidp     pChunknames);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_dbyk       (mng_handle       hHandle,
+                                                      mng_chunkid      iChunkname,
+                                                      mng_uint8        iPolarity,
+                                                      mng_uint32       iKeywordssize,
+                                                      mng_pchar        zKeywords);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_ordr       (mng_handle       hHandle,
+                                                      mng_uint32       iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_ordr_entry (mng_handle       hHandle,
+                                                      mng_uint32       iEntry,
+                                                      mng_chunkid      iChunkname,
+                                                      mng_uint8        iOrdertype);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_magn       (mng_handle       hHandle,
+                                                      mng_uint16       iFirstid,
+                                                      mng_uint16       iLastid,
+                                                      mng_uint16       iMethodX,
+                                                      mng_uint16       iMX,
+                                                      mng_uint16       iMY,
+                                                      mng_uint16       iML,
+                                                      mng_uint16       iMR,
+                                                      mng_uint16       iMT,
+                                                      mng_uint16       iMB,
+                                                      mng_uint16       iMethodY);
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_mpng       (mng_handle       hHandle,
+                                                      mng_uint32       iFramewidth,
+                                                      mng_uint32       iFrameheight,
+                                                      mng_uint16       iNumplays,
+                                                      mng_uint16       iTickspersec,
+                                                      mng_uint8        iCompressionmethod,
+                                                      mng_uint32       iCount);
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_mpng_frame (mng_handle       hHandle,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint32       iX,
+                                                      mng_uint32       iY,
+                                                      mng_uint32       iWidth,
+                                                      mng_uint32       iHeight,
+                                                      mng_int32        iXoffset,
+                                                      mng_int32        iYoffset,
+                                                      mng_uint16       iTicks);
+#endif
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_evnt       (mng_handle       hHandle,
+                                                      mng_uint32       iCount);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_evnt_entry (mng_handle       hHandle,
+                                                      mng_uint32       iEntry,
+                                                      mng_uint8        iEventtype,
+                                                      mng_uint8        iMasktype,
+                                                      mng_int32        iLeft,
+                                                      mng_int32        iRight,
+                                                      mng_int32        iTop,
+                                                      mng_int32        iBottom,
+                                                      mng_uint16       iObjectid,
+                                                      mng_uint8        iIndex,
+                                                      mng_uint32       iSegmentnamesize,
+                                                      mng_pchar        zSegmentname);
+
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_unknown    (mng_handle       hHandle,
+                                                      mng_chunkid      iChunkname,
+                                                      mng_uint32       iRawlen,
+                                                      mng_ptr          pRawdata);
+
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+
+/* use these functions to access the actual image-data in stored chunks,
+   as opposed to the IDAT/JDAT data */
+/* to get accurate pixel-data the canvasstyle should seriously reflect the
+   bitdepth/colortype combination of the preceding IHDR/JHDR/BASI/DHDR;
+   all input can be converted to rgb(a)8 (rgb(a)16 for 16-bit images), but
+   there are only limited conversions back (see below for putimgdata)  */
+
+/* call this function if you want to extract the nth image from the list;
+   the first image is designated seqnr 0! */
+/* this function finds the IHDR/JHDR/BASI/DHDR with the appropriate seqnr,
+   starting from the beginning of the chunk-list; this may tend to get a little
+   slow for animations with a large number of chunks for images near the end */
+/* supplying a seqnr past the last image in the animation will return with
+   an errorcode */   
+MNG_EXT mng_retcode MNG_DECL mng_getimgdata_seq      (mng_handle        hHandle,
+                                                      mng_uint32        iSeqnr,
+                                                      mng_uint32        iCanvasstyle,
+                                                      mng_getcanvasline fGetcanvasline);
+
+/* both the following functions will search forward to find the first IDAT/JDAT,
+   and then traverse back to find the start of the image (IHDR,JHDR,DHDR,BASI);
+   note that this is very fast compared to decoding the IDAT/JDAT, so there's
+   not really a need for optimization; either can be called from the
+   iterate_chunks callback when a IHDR/JHDR is encountered; for BASI/DHDR there
+   may not be real image-data so it's wisest to keep iterating till the IEND,
+   and then call either of these functions if necessary (remember the correct seqnr!) */
+
+/* call this function if you want to extract the image starting at or after the nth
+   position in the chunk-list; this number is returned in the iterate_chunks callback */
+MNG_EXT mng_retcode MNG_DECL mng_getimgdata_chunkseq (mng_handle        hHandle,
+                                                      mng_uint32        iSeqnr,
+                                                      mng_uint32        iCanvasstyle,
+                                                      mng_getcanvasline fGetcanvasline);
+
+/* call this function if you want to extract the image starting at or after the
+   indicated chunk; the handle of a chunk is returned in the iterate_chunks callback */
+MNG_EXT mng_retcode MNG_DECL mng_getimgdata_chunk    (mng_handle        hHandle,
+                                                      mng_handle        hChunk,
+                                                      mng_uint32        iCanvasstyle,
+                                                      mng_getcanvasline fGetcanvasline);
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+/* use the following functions to add image-data to the list of stored chunks */
+/* note that this only adds the IDAT or JDAT chunks and no others; you must call
+   one of these functions after you 'put' the initial chunks of the image and
+   before you 'put' the closing chunks */
+/* the canvasstyle should seriously reflect the bitdepth/colortype combination;
+   eg. bitdepth=16 would expect a 16-bit canvasstyle,
+   colortype=g or ga would expect a gray or gray+alpha style respectively
+   and so on, and so forth ...
+   (nb. the number of conversions will be extremely limited for the moment!) */
+
+MNG_EXT mng_retcode MNG_DECL mng_putimgdata_ihdr     (mng_handle        hHandle,
+                                                      mng_uint32        iWidth,
+                                                      mng_uint32        iHeight,
+                                                      mng_uint8         iColortype,
+                                                      mng_uint8         iBitdepth,
+                                                      mng_uint8         iCompression,
+                                                      mng_uint8         iFilter,
+                                                      mng_uint8         iInterlace,
+                                                      mng_uint32        iCanvasstyle,
+                                                      mng_getcanvasline fGetcanvasline);
+
+MNG_EXT mng_retcode MNG_DECL mng_putimgdata_jhdr     (mng_handle        hHandle,
+                                                      mng_uint32        iWidth,
+                                                      mng_uint32        iHeight,
+                                                      mng_uint8         iColortype,
+                                                      mng_uint8         iBitdepth,
+                                                      mng_uint8         iCompression,
+                                                      mng_uint8         iInterlace,
+                                                      mng_uint8         iAlphaBitdepth,
+                                                      mng_uint8         iAlphaCompression,
+                                                      mng_uint8         iAlphaFilter,
+                                                      mng_uint8         iAlphaInterlace,
+                                                      mng_uint32        iCanvasstyle,
+                                                      mng_getcanvasline fGetcanvasline);
+
+/* ************************************************************************** */
+
+/* use the following functions to set the framecount/layercount/playtime or
+   simplicity of an animation you are creating; this may be useful if these
+   variables are calculated during the creation-process */
+
+MNG_EXT mng_retcode MNG_DECL mng_updatemngheader     (mng_handle        hHandle,
+                                                      mng_uint32        iFramecount,
+                                                      mng_uint32        iLayercount,
+                                                      mng_uint32        iPlaytime);
+
+MNG_EXT mng_retcode MNG_DECL mng_updatemngsimplicity (mng_handle        hHandle,
+                                                      mng_uint32        iSimplicity);
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+#endif /* MNG_ACCESS_CHUNKS */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Error-code structure                                                   * */
+/* *                                                                        * */
+/* * 0b0000 00xx xxxx xxxx - basic errors; severity 9 (environment)         * */
+/* * 0b0000 01xx xxxx xxxx - chunk errors; severity 9 (image induced)       * */
+/* * 0b0000 10xx xxxx xxxx - severity 5 errors (application induced)        * */
+/* * 0b0001 00xx xxxx xxxx - severity 2 warnings (recoverable)              * */
+/* * 0b0010 00xx xxxx xxxx - severity 1 warnings (recoverable)              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_NOERROR          (mng_retcode)0    /* er.. indicates all's well   */
+
+#define MNG_OUTOFMEMORY      (mng_retcode)1    /* oops, buy some megabytes!   */
+#define MNG_INVALIDHANDLE    (mng_retcode)2    /* call mng_initialize first   */
+#define MNG_NOCALLBACK       (mng_retcode)3    /* set the callbacks please    */
+#define MNG_UNEXPECTEDEOF    (mng_retcode)4    /* what'd ya do with the data? */
+#define MNG_ZLIBERROR        (mng_retcode)5    /* zlib burped                 */
+#define MNG_JPEGERROR        (mng_retcode)6    /* jpglib complained           */
+#define MNG_LCMSERROR        (mng_retcode)7    /* little cms stressed out     */
+#define MNG_NOOUTPUTPROFILE  (mng_retcode)8    /* no output-profile defined   */
+#define MNG_NOSRGBPROFILE    (mng_retcode)9    /* no sRGB-profile defined     */
+#define MNG_BUFOVERFLOW      (mng_retcode)10   /* zlib output-buffer overflow */
+#define MNG_FUNCTIONINVALID  (mng_retcode)11   /* ay, totally inappropriate   */
+#define MNG_OUTPUTERROR      (mng_retcode)12   /* disk full ?                 */
+#define MNG_JPEGBUFTOOSMALL  (mng_retcode)13   /* can't handle buffer overflow*/
+#define MNG_NEEDMOREDATA     (mng_retcode)14   /* I'm hungry, give me more    */
+#define MNG_NEEDTIMERWAIT    (mng_retcode)15   /* Sleep a while then wake me  */
+#define MNG_NEEDSECTIONWAIT  (mng_retcode)16   /* just processed a SEEK       */
+#define MNG_LOOPWITHCACHEOFF (mng_retcode)17   /* LOOP when playback info off */
+
+#define MNG_DLLNOTLOADED     (mng_retcode)99   /* late binding failed         */
+
+#define MNG_APPIOERROR       (mng_retcode)901  /* application I/O error       */
+#define MNG_APPTIMERERROR    (mng_retcode)902  /* application timing error    */
+#define MNG_APPCMSERROR      (mng_retcode)903  /* application CMS error       */
+#define MNG_APPMISCERROR     (mng_retcode)904  /* application other error     */
+#define MNG_APPTRACEABORT    (mng_retcode)905  /* application aborts on trace */
+
+#define MNG_INTERNALERROR    (mng_retcode)999  /* internal inconsistancy      */
+
+#define MNG_INVALIDSIG       (mng_retcode)1025 /* invalid graphics file       */
+#define MNG_INVALIDCRC       (mng_retcode)1027 /* crc check failed            */
+#define MNG_INVALIDLENGTH    (mng_retcode)1028 /* chunklength mystifies me    */
+#define MNG_SEQUENCEERROR    (mng_retcode)1029 /* invalid chunk sequence      */
+#define MNG_CHUNKNOTALLOWED  (mng_retcode)1030 /* completely out-of-place     */
+#define MNG_MULTIPLEERROR    (mng_retcode)1031 /* only one occurence allowed  */
+#define MNG_PLTEMISSING      (mng_retcode)1032 /* indexed-color requires PLTE */
+#define MNG_IDATMISSING      (mng_retcode)1033 /* IHDR-block requires IDAT    */
+#define MNG_CANNOTBEEMPTY    (mng_retcode)1034 /* must contain some data      */
+#define MNG_GLOBALLENGTHERR  (mng_retcode)1035 /* global data incorrect       */
+#define MNG_INVALIDBITDEPTH  (mng_retcode)1036 /* bitdepth out-of-range       */
+#define MNG_INVALIDCOLORTYPE (mng_retcode)1037 /* colortype out-of-range      */
+#define MNG_INVALIDCOMPRESS  (mng_retcode)1038 /* compression method invalid  */
+#define MNG_INVALIDFILTER    (mng_retcode)1039 /* filter method invalid       */
+#define MNG_INVALIDINTERLACE (mng_retcode)1040 /* interlace method invalid    */
+#define MNG_NOTENOUGHIDAT    (mng_retcode)1041 /* ran out of compressed data  */
+#define MNG_PLTEINDEXERROR   (mng_retcode)1042 /* palette-index out-of-range  */
+#define MNG_NULLNOTFOUND     (mng_retcode)1043 /* couldn't find null-separator*/
+#define MNG_KEYWORDNULL      (mng_retcode)1044 /* keyword cannot be empty     */
+#define MNG_OBJECTUNKNOWN    (mng_retcode)1045 /* the object can't be found   */
+#define MNG_OBJECTEXISTS     (mng_retcode)1046 /* the object already exists   */
+#define MNG_TOOMUCHIDAT      (mng_retcode)1047 /* got too much compressed data*/
+#define MNG_INVSAMPLEDEPTH   (mng_retcode)1048 /* sampledepth out-of-range    */
+#define MNG_INVOFFSETSIZE    (mng_retcode)1049 /* invalid offset-size         */
+#define MNG_INVENTRYTYPE     (mng_retcode)1050 /* invalid entry-type          */
+#define MNG_ENDWITHNULL      (mng_retcode)1051 /* may not end with NULL       */
+#define MNG_INVIMAGETYPE     (mng_retcode)1052 /* invalid image_type          */
+#define MNG_INVDELTATYPE     (mng_retcode)1053 /* invalid delta_type          */
+#define MNG_INVALIDINDEX     (mng_retcode)1054 /* index-value invalid         */
+#define MNG_TOOMUCHJDAT      (mng_retcode)1055 /* got too much compressed data*/
+#define MNG_JPEGPARMSERR     (mng_retcode)1056 /* JHDR/JPEG parms do not match*/
+#define MNG_INVFILLMETHOD    (mng_retcode)1057 /* invalid fill_method         */
+#define MNG_OBJNOTCONCRETE   (mng_retcode)1058 /* object must be concrete     */
+#define MNG_TARGETNOALPHA    (mng_retcode)1059 /* object has no alpha-channel */
+#define MNG_MNGTOOCOMPLEX    (mng_retcode)1060 /* can't handle complexity     */
+#define MNG_UNKNOWNCRITICAL  (mng_retcode)1061 /* unknown critical chunk found*/
+#define MNG_UNSUPPORTEDNEED  (mng_retcode)1062 /* nEED requirement unsupported*/
+#define MNG_INVALIDDELTA     (mng_retcode)1063 /* Delta operation illegal     */
+#define MNG_INVALIDMETHOD    (mng_retcode)1064 /* invalid MAGN method         */
+#define MNG_IMPROBABLELENGTH (mng_retcode)1065 /* impropable chunk length     */
+#define MNG_INVALIDBLOCK     (mng_retcode)1066 /* invalid delta block         */
+#define MNG_INVALIDEVENT     (mng_retcode)1067 /* invalid event_type          */
+#define MNG_INVALIDMASK      (mng_retcode)1068 /* invalid mask_type           */
+#define MNG_NOMATCHINGLOOP   (mng_retcode)1069 /* ENDL without matching LOOP  */
+#define MNG_SEEKNOTFOUND     (mng_retcode)1070 /* EvNT points to unknown SEEK */
+#define MNG_OBJNOTABSTRACT   (mng_retcode)1071 /* object must be abstract     */
+#define MNG_TERMSEQERROR     (mng_retcode)1072 /* TERM in wrong place         */
+#define MNG_INVALIDFIELDVAL  (mng_retcode)1073 /* invalid fieldvalue (generic)*/
+#define MNG_INVALIDWIDTH     (mng_retcode)1074 /* invalid frame/image width   */
+#define MNG_INVALIDHEIGHT    (mng_retcode)1075 /* invalid frame/image height  */
+
+#define MNG_INVALIDCNVSTYLE  (mng_retcode)2049 /* can't make anything of this */
+#define MNG_WRONGCHUNK       (mng_retcode)2050 /* accessing the wrong chunk   */
+#define MNG_INVALIDENTRYIX   (mng_retcode)2051 /* accessing the wrong entry   */
+#define MNG_NOHEADER         (mng_retcode)2052 /* must have had header first  */
+#define MNG_NOCORRCHUNK      (mng_retcode)2053 /* can't find parent chunk     */
+#define MNG_NOMHDR           (mng_retcode)2054 /* no MNG header available     */
+
+#define MNG_IMAGETOOLARGE    (mng_retcode)4097 /* input-image way too big     */
+#define MNG_NOTANANIMATION   (mng_retcode)4098 /* file not a MNG              */
+#define MNG_FRAMENRTOOHIGH   (mng_retcode)4099 /* frame-nr out-of-range       */
+#define MNG_LAYERNRTOOHIGH   (mng_retcode)4100 /* layer-nr out-of-range       */
+#define MNG_PLAYTIMETOOHIGH  (mng_retcode)4101 /* playtime out-of-range       */
+#define MNG_FNNOTIMPLEMENTED (mng_retcode)4102 /* function not yet available  */
+
+#define MNG_IMAGEFROZEN      (mng_retcode)8193 /* stopped displaying          */
+
+#define MNG_LCMS_NOHANDLE    1                 /* LCMS returned NULL handle   */
+#define MNG_LCMS_NOMEM       2                 /* LCMS returned NULL gammatab */
+#define MNG_LCMS_NOTRANS     3                 /* LCMS returned NULL transform*/
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Canvas styles                                                         * */
+/* *                                                                        * */
+/* *  Note that the intentions are pretty darn good, but that the focus     * */
+/* *  is currently on 8-bit color support                                   * */
+/* *                                                                        * */
+/* *  The RGB8_A8 style is defined for apps that require a separate         * */
+/* *  canvas for the color-planes and the alpha-plane (eg. mozilla)         * */
+/* *  This requires for the app to supply the "getalphaline" callback!!!    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_CANVAS_RGB8      0x00000000L
+#define MNG_CANVAS_RGBA8     0x00001000L
+#define MNG_CANVAS_RGBA8_PM  0x00009000L
+#define MNG_CANVAS_ARGB8     0x00003000L
+#define MNG_CANVAS_ARGB8_PM  0x0000B000L
+#define MNG_CANVAS_RGB8_A8   0x00005000L
+#define MNG_CANVAS_BGR8      0x00000001L
+#define MNG_CANVAS_BGRX8     0x00010001L
+#define MNG_CANVAS_BGRA8     0x00001001L
+#define MNG_CANVAS_BGRA8PM   0x00009001L         /* backward compatibility */
+#define MNG_CANVAS_BGRA8_PM  0x00009001L
+#define MNG_CANVAS_ABGR8     0x00003001L
+#define MNG_CANVAS_ABGR8_PM  0x0000B001L
+#define MNG_CANVAS_RGB16     0x00000100L         /* not supported yet */
+#define MNG_CANVAS_RGBA16    0x00001100L         /* not supported yet */
+#define MNG_CANVAS_ARGB16    0x00003100L         /* not supported yet */
+#define MNG_CANVAS_BGR16     0x00000101L         /* not supported yet */
+#define MNG_CANVAS_BGRA16    0x00001101L         /* not supported yet */
+#define MNG_CANVAS_ABGR16    0x00003101L         /* not supported yet */
+#define MNG_CANVAS_GRAY8     0x00000002L         /* not supported yet */
+#define MNG_CANVAS_GRAY16    0x00000102L         /* not supported yet */
+#define MNG_CANVAS_GRAYA8    0x00001002L         /* not supported yet */
+#define MNG_CANVAS_GRAYA16   0x00001102L         /* not supported yet */
+#define MNG_CANVAS_AGRAY8    0x00003002L         /* not supported yet */
+#define MNG_CANVAS_AGRAY16   0x00003102L         /* not supported yet */
+#define MNG_CANVAS_DX15      0x00000003L         /* not supported yet */
+#define MNG_CANVAS_DX16      0x00000004L         /* not supported yet */
+
+#define MNG_CANVAS_RGB565    0x00000005L
+#define MNG_CANVAS_RGBA565   0x00001005L
+#define MNG_CANVAS_BGR565    0x00000006L
+#define MNG_CANVAS_BGRA565   0x00001006L
+#define MNG_CANVAS_BGR565_A8 0x00004006L
+
+#define MNG_CANVAS_RGB555    0x00000007L
+#define MNG_CANVAS_BGR555    0x00000008L
+
+#define MNG_CANVAS_PIXELTYPE(C)  (C & 0x000000FFL)
+#define MNG_CANVAS_BITDEPTH(C)   (C & 0x00000100L)
+#define MNG_CANVAS_HASALPHA(C)   (C & 0x00001000L)
+#define MNG_CANVAS_ALPHAFIRST(C) (C & 0x00002000L)
+#define MNG_CANVAS_ALPHASEPD(C)  (C & 0x00004000L)
+#define MNG_CANVAS_ALPHAPM(C)    (C & 0x00008000L)
+#define MNG_CANVAS_HASFILLER(C)  (C & 0x00010000L)
+
+#define MNG_CANVAS_RGB(C)        (MNG_CANVAS_PIXELTYPE (C) == 0)
+#define MNG_CANVAS_BGR(C)        (MNG_CANVAS_PIXELTYPE (C) == 1)
+#define MNG_CANVAS_GRAY(C)       (MNG_CANVAS_PIXELTYPE (C) == 2)
+#define MNG_CANVAS_DIRECTX15(C)  (MNG_CANVAS_PIXELTYPE (C) == 3)
+#define MNG_CANVAS_DIRECTX16(C)  (MNG_CANVAS_PIXELTYPE (C) == 4)
+#define MNG_CANVAS_RGB_565(C)    (MNG_CANVAS_PIXELTYPE (C) == 5)
+#define MNG_CANVAS_BGR_565(C)    (MNG_CANVAS_PIXELTYPE (C) == 6)
+#define MNG_CANVAS_8BIT(C)       (!MNG_CANVAS_BITDEPTH (C))
+#define MNG_CANVAS_16BIT(C)      (MNG_CANVAS_BITDEPTH (C))
+#define MNG_CANVAS_PIXELFIRST(C) (!MNG_CANVAS_ALPHAFIRST (C))
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Chunk names (idea adapted from libpng 1.1.0 - png.h)                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_UINT_HUH  0x40404040L
+
+#define MNG_UINT_BACK 0x4241434bL
+#define MNG_UINT_BASI 0x42415349L
+#define MNG_UINT_CLIP 0x434c4950L
+#define MNG_UINT_CLON 0x434c4f4eL
+#define MNG_UINT_DBYK 0x4442594bL
+#define MNG_UINT_DEFI 0x44454649L
+#define MNG_UINT_DHDR 0x44484452L
+#define MNG_UINT_DISC 0x44495343L
+#define MNG_UINT_DROP 0x44524f50L
+#define MNG_UINT_ENDL 0x454e444cL
+#define MNG_UINT_FRAM 0x4652414dL
+#define MNG_UINT_IDAT 0x49444154L
+#define MNG_UINT_IEND 0x49454e44L
+#define MNG_UINT_IHDR 0x49484452L
+#define MNG_UINT_IJNG 0x494a4e47L
+#define MNG_UINT_IPNG 0x49504e47L
+#define MNG_UINT_JDAA 0x4a444141L
+#define MNG_UINT_JDAT 0x4a444154L
+#define MNG_UINT_JHDR 0x4a484452L
+#define MNG_UINT_JSEP 0x4a534550L
+#define MNG_UINT_JdAA 0x4a644141L
+#define MNG_UINT_LOOP 0x4c4f4f50L
+#define MNG_UINT_MAGN 0x4d41474eL
+#define MNG_UINT_MEND 0x4d454e44L
+#define MNG_UINT_MHDR 0x4d484452L
+#define MNG_UINT_MOVE 0x4d4f5645L
+#define MNG_UINT_ORDR 0x4f524452L
+#define MNG_UINT_PAST 0x50415354L
+#define MNG_UINT_PLTE 0x504c5445L
+#define MNG_UINT_PPLT 0x50504c54L
+#define MNG_UINT_PROM 0x50524f4dL
+#define MNG_UINT_SAVE 0x53415645L
+#define MNG_UINT_SEEK 0x5345454bL
+#define MNG_UINT_SHOW 0x53484f57L
+#define MNG_UINT_TERM 0x5445524dL
+#define MNG_UINT_adAT 0x61644154L
+#define MNG_UINT_ahDR 0x61684452L
+#define MNG_UINT_bKGD 0x624b4744L
+#define MNG_UINT_cHRM 0x6348524dL
+#define MNG_UINT_eXPI 0x65585049L
+#define MNG_UINT_evNT 0x65764e54L
+#define MNG_UINT_fPRI 0x66505249L
+#define MNG_UINT_gAMA 0x67414d41L
+#define MNG_UINT_hIST 0x68495354L
+#define MNG_UINT_iCCP 0x69434350L
+#define MNG_UINT_iTXt 0x69545874L
+#define MNG_UINT_mpNG 0x6d704e47L
+#define MNG_UINT_nEED 0x6e454544L
+#define MNG_UINT_oFFs 0x6f464673L
+#define MNG_UINT_pCAL 0x7043414cL
+#define MNG_UINT_pHYg 0x70444167L
+#define MNG_UINT_pHYs 0x70485973L
+#define MNG_UINT_sBIT 0x73424954L
+#define MNG_UINT_sCAL 0x7343414cL
+#define MNG_UINT_sPLT 0x73504c54L
+#define MNG_UINT_sRGB 0x73524742L
+#define MNG_UINT_tEXt 0x74455874L
+#define MNG_UINT_tIME 0x74494d45L
+#define MNG_UINT_tRNS 0x74524e53L
+#define MNG_UINT_zTXt 0x7a545874L
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Chunk property values                                                 * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_BITDEPTH_1                   1       /* IHDR, BASI, JHDR, PROM */
+#define MNG_BITDEPTH_2                   2
+#define MNG_BITDEPTH_4                   4
+#define MNG_BITDEPTH_8                   8       /* sPLT */
+#define MNG_BITDEPTH_16                 16
+
+#define MNG_COLORTYPE_GRAY               0       /* IHDR, BASI, PROM */
+#define MNG_COLORTYPE_RGB                2
+#define MNG_COLORTYPE_INDEXED            3
+#define MNG_COLORTYPE_GRAYA              4
+#define MNG_COLORTYPE_RGBA               6
+
+#define MNG_COMPRESSION_DEFLATE          0       /* IHDR, zTXt, iTXt, iCCP,
+                                                    BASI, JHDR */
+
+#define MNG_FILTER_ADAPTIVE              0       /* IHDR, BASI, JHDR */
+/* #define MNG_FILTER_NO_ADAPTIVE           1
+#define MNG_FILTER_NO_DIFFERING          0
+#define MNG_FILTER_DIFFERING             0x40
+#define MNG_FILTER_MASK                  (MNG_FILTER_NO_ADAPTIVE | MNG_FILTER_DIFFERING) */
+#ifdef FILTER192
+#define MNG_FILTER_DIFFERING             0xC0
+#endif
+#ifdef FILTER193
+#define MNG_FILTER_NOFILTER              0xC1
+#endif
+
+#define MNG_INTERLACE_NONE               0       /* IHDR, BASI, JHDR */
+#define MNG_INTERLACE_ADAM7              1
+
+#define MNG_FILTER_NONE                  0       /* IDAT */
+#define MNG_FILTER_SUB                   1
+#define MNG_FILTER_UP                    2
+#define MNG_FILTER_AVERAGE               3
+#define MNG_FILTER_PAETH                 4
+
+#define MNG_INTENT_PERCEPTUAL            0       /* sRGB */
+#define MNG_INTENT_RELATIVECOLORIMETRIC  1
+#define MNG_INTENT_SATURATION            2
+#define MNG_INTENT_ABSOLUTECOLORIMETRIC  3
+                                                 /* tEXt, zTXt, iTXt */
+#define MNG_TEXT_TITLE                   "Title"
+#define MNG_TEXT_AUTHOR                  "Author"
+#define MNG_TEXT_DESCRIPTION             "Description"
+#define MNG_TEXT_COPYRIGHT               "Copyright"
+#define MNG_TEXT_CREATIONTIME            "Creation Time"
+#define MNG_TEXT_SOFTWARE                "Software"
+#define MNG_TEXT_DISCLAIMER              "Disclaimer"
+#define MNG_TEXT_WARNING                 "Warning"
+#define MNG_TEXT_SOURCE                  "Source"
+#define MNG_TEXT_COMMENT                 "Comment"
+
+#define MNG_FLAG_UNCOMPRESSED            0       /* iTXt */
+#define MNG_FLAG_COMPRESSED              1
+
+#define MNG_UNIT_UNKNOWN                 0       /* pHYs, pHYg */
+#define MNG_UNIT_METER                   1
+                                                 /* MHDR */
+#define MNG_SIMPLICITY_VALID             0x00000001
+#define MNG_SIMPLICITY_SIMPLEFEATURES    0x00000002
+#define MNG_SIMPLICITY_COMPLEXFEATURES   0x00000004
+#define MNG_SIMPLICITY_TRANSPARENCY      0x00000008
+#define MNG_SIMPLICITY_JNG               0x00000010
+#define MNG_SIMPLICITY_DELTAPNG          0x00000020
+
+#define MNG_TERMINATION_DECODER_NC       0       /* LOOP */
+#define MNG_TERMINATION_USER_NC          1
+#define MNG_TERMINATION_EXTERNAL_NC      2
+#define MNG_TERMINATION_DETERMINISTIC_NC 3
+#define MNG_TERMINATION_DECODER_C        4
+#define MNG_TERMINATION_USER_C           5
+#define MNG_TERMINATION_EXTERNAL_C       6
+#define MNG_TERMINATION_DETERMINISTIC_C  7
+
+#define MNG_DONOTSHOW_VISIBLE            0       /* DEFI */
+#define MNG_DONOTSHOW_NOTVISIBLE         1
+
+#define MNG_ABSTRACT                     0       /* DEFI */
+#define MNG_CONCRETE                     1
+
+#define MNG_NOTVIEWABLE                  0       /* BASI */
+#define MNG_VIEWABLE                     1
+
+#define MNG_FULL_CLONE                   0       /* CLON */
+#define MNG_PARTIAL_CLONE                1
+#define MNG_RENUMBER                     2
+
+#define MNG_CONCRETE_ASPARENT            0       /* CLON */
+#define MNG_CONCRETE_MAKEABSTRACT        1
+
+#define MNG_LOCATION_ABSOLUTE            0       /* CLON, MOVE */
+#define MNG_LOCATION_RELATIVE            1
+
+#ifndef MNG_SKIPCHUNK_PAST
+#define MNG_TARGET_ABSOLUTE              0       /* PAST */
+#define MNG_TARGET_RELATIVE_SAMEPAST     1
+#define MNG_TARGET_RELATIVE_PREVPAST     2
+
+#define MNG_COMPOSITE_OVER               0       /* PAST */
+#define MNG_COMPOSITE_REPLACE            1
+#define MNG_COMPOSITE_UNDER              2
+
+#define MNG_ORIENTATION_SAME             0       /* PAST */
+#define MNG_ORIENTATION_180DEG           2
+#define MNG_ORIENTATION_FLIPHORZ         4
+#define MNG_ORIENTATION_FLIPVERT         6
+#define MNG_ORIENTATION_TILED            8
+
+#define MNG_OFFSET_ABSOLUTE              0       /* PAST */
+#define MNG_OFFSET_RELATIVE              1
+#endif
+
+#define MNG_BOUNDARY_ABSOLUTE            0       /* PAST, FRAM */
+#define MNG_BOUNDARY_RELATIVE            1
+
+#define MNG_BACKGROUNDCOLOR_MANDATORY    0x01    /* BACK */
+#define MNG_BACKGROUNDIMAGE_MANDATORY    0x02    /* BACK */
+
+#define MNG_BACKGROUNDIMAGE_NOTILE       0       /* BACK */
+#define MNG_BACKGROUNDIMAGE_TILE         1
+
+#define MNG_FRAMINGMODE_NOCHANGE         0       /* FRAM */
+#define MNG_FRAMINGMODE_1                1
+#define MNG_FRAMINGMODE_2                2
+#define MNG_FRAMINGMODE_3                3
+#define MNG_FRAMINGMODE_4                4
+
+#define MNG_CHANGEDELAY_NO               0       /* FRAM */
+#define MNG_CHANGEDELAY_NEXTSUBFRAME     1
+#define MNG_CHANGEDELAY_DEFAULT          2
+
+#define MNG_CHANGETIMOUT_NO              0       /* FRAM */
+#define MNG_CHANGETIMOUT_DETERMINISTIC_1 1
+#define MNG_CHANGETIMOUT_DETERMINISTIC_2 2
+#define MNG_CHANGETIMOUT_DECODER_1       3
+#define MNG_CHANGETIMOUT_DECODER_2       4
+#define MNG_CHANGETIMOUT_USER_1          5
+#define MNG_CHANGETIMOUT_USER_2          6
+#define MNG_CHANGETIMOUT_EXTERNAL_1      7
+#define MNG_CHANGETIMOUT_EXTERNAL_2      8
+
+#define MNG_CHANGECLIPPING_NO            0       /* FRAM */
+#define MNG_CHANGECLIPPING_NEXTSUBFRAME  1
+#define MNG_CHANGECLIPPING_DEFAULT       2
+
+#define MNG_CHANGESYNCID_NO              0       /* FRAM */
+#define MNG_CHANGESYNCID_NEXTSUBFRAME    1
+#define MNG_CHANGESYNCID_DEFAULT         2
+
+#define MNG_CLIPPING_ABSOLUTE            0       /* CLIP */
+#define MNG_CLIPPING_RELATIVE            1
+
+#define MNG_SHOWMODE_0                   0       /* SHOW */
+#define MNG_SHOWMODE_1                   1
+#define MNG_SHOWMODE_2                   2
+#define MNG_SHOWMODE_3                   3
+#define MNG_SHOWMODE_4                   4
+#define MNG_SHOWMODE_5                   5
+#define MNG_SHOWMODE_6                   6
+#define MNG_SHOWMODE_7                   7
+
+#define MNG_TERMACTION_LASTFRAME         0       /* TERM */
+#define MNG_TERMACTION_CLEAR             1
+#define MNG_TERMACTION_FIRSTFRAME        2
+#define MNG_TERMACTION_REPEAT            3
+
+#define MNG_ITERACTION_LASTFRAME         0       /* TERM */
+#define MNG_ITERACTION_CLEAR             1
+#define MNG_ITERACTION_FIRSTFRAME        2
+
+#define MNG_SAVEOFFSET_4BYTE             4       /* SAVE */
+#define MNG_SAVEOFFSET_8BYTE             8
+
+#define MNG_SAVEENTRY_SEGMENTFULL        0       /* SAVE */
+#define MNG_SAVEENTRY_SEGMENT            1
+#define MNG_SAVEENTRY_SUBFRAME           2
+#define MNG_SAVEENTRY_EXPORTEDIMAGE      3
+
+#define MNG_PRIORITY_ABSOLUTE            0       /* fPRI */
+#define MNG_PRIORITY_RELATIVE            1
+
+#ifdef MNG_INCLUDE_JNG
+#define MNG_COLORTYPE_JPEGGRAY           8       /* JHDR */
+#define MNG_COLORTYPE_JPEGCOLOR         10
+#define MNG_COLORTYPE_JPEGGRAYA         12
+#define MNG_COLORTYPE_JPEGCOLORA        14
+
+#define MNG_BITDEPTH_JPEG8               8       /* JHDR */
+#define MNG_BITDEPTH_JPEG12             12
+#define MNG_BITDEPTH_JPEG8AND12         20
+
+#define MNG_COMPRESSION_BASELINEJPEG     8       /* JHDR */
+
+#define MNG_INTERLACE_SEQUENTIAL         0       /* JHDR */
+#define MNG_INTERLACE_PROGRESSIVE        8
+#endif /* MNG_INCLUDE_JNG */
+
+#define MNG_IMAGETYPE_UNKNOWN            0       /* DHDR */
+#define MNG_IMAGETYPE_PNG                1
+#define MNG_IMAGETYPE_JNG                2
+
+#define MNG_DELTATYPE_REPLACE            0       /* DHDR */
+#define MNG_DELTATYPE_BLOCKPIXELADD      1
+#define MNG_DELTATYPE_BLOCKALPHAADD      2
+#define MNG_DELTATYPE_BLOCKCOLORADD      3
+#define MNG_DELTATYPE_BLOCKPIXELREPLACE  4
+#define MNG_DELTATYPE_BLOCKALPHAREPLACE  5
+#define MNG_DELTATYPE_BLOCKCOLORREPLACE  6
+#define MNG_DELTATYPE_NOCHANGE           7
+
+#define MNG_FILLMETHOD_LEFTBITREPLICATE  0       /* PROM */
+#define MNG_FILLMETHOD_ZEROFILL          1
+
+#define MNG_DELTATYPE_REPLACERGB         0       /* PPLT */
+#define MNG_DELTATYPE_DELTARGB           1
+#define MNG_DELTATYPE_REPLACEALPHA       2
+#define MNG_DELTATYPE_DELTAALPHA         3
+#define MNG_DELTATYPE_REPLACERGBA        4
+#define MNG_DELTATYPE_DELTARGBA          5
+
+#define MNG_POLARITY_ONLY                0       /* DBYK */
+#define MNG_POLARITY_ALLBUT              1
+
+#define MNG_EVENT_NONE                   0       /* evNT */
+#define MNG_EVENT_MOUSEENTER             1
+#define MNG_EVENT_MOUSEMOVE              2
+#define MNG_EVENT_MOUSEEXIT              3
+#define MNG_EVENT_MOUSEDOWN              4
+#define MNG_EVENT_MOUSEUP                5
+
+#define MNG_MASK_NONE                    0       /* evNT */
+#define MNG_MASK_BOX                     1
+#define MNG_MASK_OBJECT                  2
+#define MNG_MASK_OBJECTIX                3
+#define MNG_MASK_BOXOBJECT               4
+#define MNG_MASK_BOXOBJECTIX             5
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Processtext callback types                                            * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_TYPE_TEXT 0
+#define MNG_TYPE_ZTXT 1
+#define MNG_TYPE_ITXT 2
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  CRC processing masks                                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_CRC_INPUT              0x0000000f
+#define MNG_CRC_INPUT_NONE         0x00000000
+#define MNG_CRC_INPUT_PRESENT      0x00000001
+#define MNG_CRC_OUTPUT             0x000000f0
+#define MNG_CRC_OUTPUT_NONE        0x00000000
+#define MNG_CRC_OUTPUT_GENERATE    0x00000020
+#define MNG_CRC_OUTPUT_DUMMY       0x00000040
+#define MNG_CRC_ANCILLARY          0x00000f00
+#define MNG_CRC_ANCILLARY_IGNORE   0x00000000
+#define MNG_CRC_ANCILLARY_DISCARD  0x00000100
+#define MNG_CRC_ANCILLARY_WARNING  0x00000200
+#define MNG_CRC_ANCILLARY_ERROR    0x00000300
+#define MNG_CRC_CRITICAL           0x0000f000
+#define MNG_CRC_CRITICAL_IGNORE    0x00000000
+#define MNG_CRC_CRITICAL_WARNING   0x00002000
+#define MNG_CRC_CRITICAL_ERROR     0x00003000
+#define MNG_CRC_DEFAULT            0x00002121
+
+/* ************************************************************************** */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _libmng_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_callback_xs.c b/src/3rdparty/libmng/libmng_callback_xs.c
new file mode 100644
index 0000000..ff1a22a
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_callback_xs.c
@@ -0,0 +1,1239 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_callback_xs.c      copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : callback get/set interface (implementation)                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the callback get/set functions           * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - fixed calling convention                                 * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - fixed up punctuation (contribution by Tim Rowley)        * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - added getalphaline callback for RGB8_A8 canvasstyle      * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added callbacks for SAVE/SEEK processing                 * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added processterm callback                               * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G. R-P                                * */
+/* *             - added SKIPCHUNK feature                                  * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *             1.0.7 - 03/19/2004 - G.R-P                                 * */
+/* *             - fixed typo (MNG_SKIPCHUNK_SAVE -> MNG_SKIPCHUNK_nEED     * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/10/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/18/2004 - G.R-P.                                * */
+/* *             - added two SKIPCHUNK_TERM conditionals                    * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Callback set functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+mng_retcode MNG_DECL mng_setcb_memalloc (mng_handle   hHandle,
+                                         mng_memalloc fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_MEMALLOC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fMemalloc = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_MEMALLOC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INTERNAL_MEMMNGMT */
+
+/* ************************************************************************** */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+mng_retcode MNG_DECL mng_setcb_memfree (mng_handle  hHandle,
+                                        mng_memfree fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_MEMFREE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fMemfree = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_MEMFREE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INTERNAL_MEMMNGMT */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_setcb_releasedata (mng_handle      hHandle,
+                                            mng_releasedata fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_RELEASEDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fReleasedata = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_RELEASEDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+mng_retcode MNG_DECL mng_setcb_openstream (mng_handle     hHandle,
+                                           mng_openstream fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_OPENSTREAM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fOpenstream = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_OPENSTREAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+mng_retcode MNG_DECL mng_setcb_closestream (mng_handle      hHandle,
+                                            mng_closestream fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_CLOSESTREAM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fClosestream = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_CLOSESTREAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_setcb_readdata (mng_handle   hHandle,
+                                         mng_readdata fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_READDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fReaddata = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_READDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_setcb_writedata (mng_handle    hHandle,
+                                          mng_writedata fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_WRITEDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fWritedata = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_WRITEDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_setcb_errorproc (mng_handle    hHandle,
+                                          mng_errorproc fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_ERRORPROC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fErrorproc = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_ERRORPROC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_TRACE
+mng_retcode MNG_DECL mng_setcb_traceproc (mng_handle    hHandle,
+                                          mng_traceproc fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_TRACEPROC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fTraceproc = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_TRACEPROC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_TRACE */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_setcb_processheader (mng_handle        hHandle,
+                                              mng_processheader fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSHEADER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessheader = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSHEADER, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_tEXt
+mng_retcode MNG_DECL mng_setcb_processtext (mng_handle      hHandle,
+                                            mng_processtext fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSTEXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcesstext = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSTEXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode MNG_DECL mng_setcb_processsave (mng_handle      hHandle,
+                                            mng_processsave fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSSAVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcesssave = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSSAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode MNG_DECL mng_setcb_processseek (mng_handle      hHandle,
+                                            mng_processseek fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSSEEK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessseek = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSSEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_nEED
+mng_retcode MNG_DECL mng_setcb_processneed (mng_handle      hHandle,
+                                            mng_processneed fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSNEED, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessneed = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSNEED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_setcb_processmend (mng_handle      hHandle,
+                                            mng_processmend fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSMEND, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessmend = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSMEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_setcb_processunknown (mng_handle         hHandle,
+                                               mng_processunknown fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSUNKNOWN, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessunknown = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSUNKNOWN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_TERM
+mng_retcode MNG_DECL mng_setcb_processterm (mng_handle      hHandle,
+                                            mng_processterm fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSTERM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessterm = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSTERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_setcb_getcanvasline (mng_handle        hHandle,
+                                              mng_getcanvasline fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETCANVASLINE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fGetcanvasline = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETCANVASLINE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_setcb_getbkgdline (mng_handle      hHandle,
+                                            mng_getbkgdline fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETBKGDLINE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fGetbkgdline = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETBKGDLINE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_setcb_getalphaline (mng_handle       hHandle,
+                                             mng_getalphaline fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETALPHALINE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fGetalphaline = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETALPHALINE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_setcb_refresh (mng_handle  hHandle,
+                                        mng_refresh fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_REFRESH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fRefresh = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_REFRESH, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_setcb_gettickcount (mng_handle       hHandle,
+                                             mng_gettickcount fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETTICKCOUNT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fGettickcount = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_GETTICKCOUNT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_setcb_settimer (mng_handle   hHandle,
+                                         mng_settimer fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_SETTIMER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fSettimer = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_SETTIMER, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+mng_retcode MNG_DECL mng_setcb_processgamma (mng_handle        hHandle,
+                                             mng_processgamma  fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSGAMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessgamma = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSGAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+#ifndef MNG_SKIPCHUNK_cHRM
+mng_retcode MNG_DECL mng_setcb_processchroma (mng_handle        hHandle,
+                                              mng_processchroma fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSCHROMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcesschroma = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSCHROMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+mng_retcode MNG_DECL mng_setcb_processsrgb (mng_handle      hHandle,
+                                            mng_processsrgb fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSSRGB, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcesssrgb = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSSRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_retcode MNG_DECL mng_setcb_processiccp (mng_handle      hHandle,
+                                            mng_processiccp fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSICCP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessiccp = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+mng_retcode MNG_DECL mng_setcb_processarow (mng_handle      hHandle,
+                                            mng_processarow fProc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSAROW, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->fProcessarow = fProc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SETCB_PROCESSAROW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Callback get functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+mng_memalloc MNG_DECL mng_getcb_memalloc (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_MEMALLOC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_MEMALLOC, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fMemalloc;
+}
+#endif /* MNG_INTERNAL_MEMMNGMT */
+
+/* ************************************************************************** */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+mng_memfree MNG_DECL mng_getcb_memfree (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_MEMFREE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_MEMFREE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fMemfree;
+}
+#endif /* MNG_INTERNAL_MEMMNGMT */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_releasedata MNG_DECL mng_getcb_releasedata (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_RELEASEDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_RELEASEDATA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fReleasedata;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_readdata MNG_DECL mng_getcb_readdata (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_READDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_READDATA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fReaddata;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+mng_openstream MNG_DECL mng_getcb_openstream (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_OPENSTREAM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_OPENSTREAM, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fOpenstream;
+}
+#endif
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+mng_closestream MNG_DECL mng_getcb_closestream (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_CLOSESTREAM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_CLOSESTREAM, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fClosestream;
+}
+#endif
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_WRITE
+mng_writedata MNG_DECL mng_getcb_writedata (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_WRITEDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_WRITEDATA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fWritedata;
+}
+#endif /* MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+mng_errorproc MNG_DECL mng_getcb_errorproc (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_ERRORPROC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_ERRORPROC, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fErrorproc;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_TRACE
+mng_traceproc MNG_DECL mng_getcb_traceproc (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_TRACEPROC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_TRACEPROC, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fTraceproc;
+}
+#endif /* MNG_SUPPORT_TRACE */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_processheader MNG_DECL mng_getcb_processheader (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSHEADER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSHEADER, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessheader;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_tEXt
+mng_processtext MNG_DECL mng_getcb_processtext (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSTEXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSTEXT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcesstext;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_processsave MNG_DECL mng_getcb_processsave (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSSAVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSSAVE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcesssave;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_processseek MNG_DECL mng_getcb_processseek (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSSEEK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSSEEK, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessseek;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_nEED
+mng_processneed MNG_DECL mng_getcb_processneed (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSNEED, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSNEED, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessneed;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_processmend MNG_DECL mng_getcb_processmend (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSMEND, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSMEND, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessmend;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_processunknown MNG_DECL mng_getcb_processunknown (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSUNKNOWN, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSUNKNOWN, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessunknown;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+#ifndef MNG_SKIPCHUNK_TERM
+mng_processterm MNG_DECL mng_getcb_processterm (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSTERM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSTERM, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessterm;
+}
+#endif
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_getcanvasline MNG_DECL mng_getcb_getcanvasline (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETCANVASLINE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETCANVASLINE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fGetcanvasline;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_getbkgdline MNG_DECL mng_getcb_getbkgdline (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETBKGDLINE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETBKGDLINE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fGetbkgdline;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_getalphaline MNG_DECL mng_getcb_getalphaline (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETALPHALINE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETALPHALINE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fGetalphaline;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_refresh MNG_DECL mng_getcb_refresh (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_REFRESH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_REFRESH, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fRefresh;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_gettickcount MNG_DECL mng_getcb_gettickcount (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETTICKCOUNT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_GETTICKCOUNT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fGettickcount;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_settimer MNG_DECL mng_getcb_settimer (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_SETTIMER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_SETTIMER, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fSettimer;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+mng_processgamma MNG_DECL mng_getcb_processgamma (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSGAMMA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessgamma;
+}
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+#ifndef MNG_SKIPCHUNK_cHRM
+mng_processchroma MNG_DECL mng_getcb_processchroma (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSCHROMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSCHROMA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcesschroma;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+mng_processsrgb MNG_DECL mng_getcb_processsrgb (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSSRGB, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSSRGB, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcesssrgb;
+}
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_processiccp MNG_DECL mng_getcb_processiccp (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSICCP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSICCP, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessiccp;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_APP_CMS)
+mng_processarow MNG_DECL mng_getcb_processarow (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSAROW, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GETCB_PROCESSAROW, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->fProcessarow;
+}
+#endif /* MNG_SUPPORT_DISPLAY && MNG_APP_CMS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
+
diff --git a/src/3rdparty/libmng/libmng_chunk_descr.c b/src/3rdparty/libmng/libmng_chunk_descr.c
new file mode 100644
index 0000000..e1004a5
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunk_descr.c
@@ -0,0 +1,6090 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunk_descr.c      copyright (c) 2005-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Chunk descriptor functions (implementation)                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the chunk- anf field-descriptor          * */
+/* *             routines                                                   * */
+/* *                                                                        * */
+/* * changes   : 1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKREADER               * */
+/* *             1.0.9 - 12/11/2004 - G.Juyn                                * */
+/* *             - made all constants 'static'                              * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *             1.0.9 - 01/17/2005 - G.Juyn                                * */
+/* *             - fixed problem with global PLTE/tRNS                      * */
+/* *                                                                        * */
+/* *             1.0.10 - 01/17/2005 - G.R-P.                               * */
+/* *             - added typecast to appease the compiler                   * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include <stddef.h>                    /* needed for offsetof() */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_objects.h"
+#include "libmng_chunks.h"
+#include "libmng_chunk_descr.h"
+#include "libmng_object_prc.h"
+#include "libmng_chunk_prc.h"
+#include "libmng_chunk_io.h"
+#include "libmng_display.h"
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+#include "libmng_pixels.h"
+#include "libmng_filter.h"
+#endif
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+#if defined(MNG_INCLUDE_READ_PROCS) || defined(MNG_INCLUDE_WRITE_PROCS)
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* PNG chunks */
+
+MNG_LOCAL mng_field_descriptor mng_fields_ihdr [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_NOHIGHBIT,
+     1, 0, 4, 4,
+     offsetof(mng_ihdr, iWidth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_NOHIGHBIT,
+     1, 0, 4, 4,
+     offsetof(mng_ihdr, iHeight), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 16, 1, 1,
+     offsetof(mng_ihdr, iBitdepth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 6, 1, 1,
+     offsetof(mng_ihdr, iColortype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_ihdr, iCompression), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_ihdr, iFilter), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_ihdr, iInterlace), MNG_NULL, MNG_NULL}
+  };
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_field_descriptor mng_fields_plte [] =
+  {
+    {mng_debunk_plte,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_field_descriptor mng_fields_idat [] =
+  {
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 0, 0,
+     offsetof(mng_idat, pData), MNG_NULL, offsetof(mng_idat, iDatasize)}
+  };
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_field_descriptor mng_fields_trns [] =
+  {
+    {mng_debunk_trns,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_gAMA
+MNG_LOCAL mng_field_descriptor mng_fields_gama [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_gama, iGamma), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+MNG_LOCAL mng_field_descriptor mng_fields_chrm [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iWhitepointx), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iWhitepointy), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iRedx), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iRedy), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iGreeny), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iGreeny), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iBluex), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_chrm, iBluey), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sRGB
+MNG_LOCAL mng_field_descriptor mng_fields_srgb [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 4, 1, 1,
+     offsetof(mng_srgb, iRenderingintent), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+MNG_LOCAL mng_field_descriptor mng_fields_iccp [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_TERMINATOR,
+     0, 0, 1, 79,
+     offsetof(mng_iccp, zName), MNG_NULL, offsetof(mng_iccp, iNamesize)},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_iccp, iCompression), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_DEFLATED,
+     0, 0, 0, 0,
+     offsetof(mng_iccp, pProfile), MNG_NULL, offsetof(mng_iccp, iProfilesize)}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+MNG_LOCAL mng_field_descriptor mng_fields_text [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_TERMINATOR,
+     0, 0, 1, 79,
+     offsetof(mng_text, zKeyword), MNG_NULL, offsetof(mng_text, iKeywordsize)},
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 0, 0,
+     offsetof(mng_text, zText), MNG_NULL, offsetof(mng_text, iTextsize)}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+MNG_LOCAL mng_field_descriptor mng_fields_ztxt [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_TERMINATOR,
+     0, 0, 1, 79,
+     offsetof(mng_ztxt, zKeyword), MNG_NULL, offsetof(mng_ztxt, iKeywordsize)},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_ztxt, iCompression), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_DEFLATED,
+     0, 0, 0, 0,
+     offsetof(mng_ztxt, zText), MNG_NULL, offsetof(mng_ztxt, iTextsize)}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+MNG_LOCAL mng_field_descriptor mng_fields_itxt [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_TERMINATOR,
+     0, 0, 1, 79,
+     offsetof(mng_itxt, zKeyword), MNG_NULL, offsetof(mng_itxt, iKeywordsize)},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_itxt, iCompressionflag), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_itxt, iCompressionmethod), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_TERMINATOR,
+     0, 0, 0, 0,
+     offsetof(mng_itxt, zLanguage), MNG_NULL, offsetof(mng_itxt, iLanguagesize)},
+    {MNG_NULL,
+     MNG_FIELD_TERMINATOR,
+     0, 0, 0, 0,
+     offsetof(mng_itxt, zTranslation), MNG_NULL, offsetof(mng_itxt, iTranslationsize)},
+    {mng_deflate_itxt,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+MNG_LOCAL mng_field_descriptor mng_fields_bkgd [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_PUTIMGTYPE,
+     0, 0, 0, 0,
+     offsetof(mng_bkgd, iType), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE3,
+     0, 0xFF, 1, 1,
+     offsetof(mng_bkgd, iIndex), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE0 | MNG_FIELD_IFIMGTYPE4,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_bkgd, iGray), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE2 | MNG_FIELD_IFIMGTYPE6,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_bkgd, iRed), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE2 | MNG_FIELD_IFIMGTYPE6,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_bkgd, iGreen), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE2 | MNG_FIELD_IFIMGTYPE6,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_bkgd, iBlue), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYs
+MNG_LOCAL mng_field_descriptor mng_fields_phys [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_phys, iSizex), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_phys, iSizey), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_phys, iUnit), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sBIT
+MNG_LOCAL mng_field_descriptor mng_fields_sbit [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_PUTIMGTYPE,
+     0, 0, 0, 0,
+     offsetof(mng_sbit, iType), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPES,
+     0, 0xFF, 1, 1,
+     offsetof(mng_sbit, aBits[0]), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE2 | MNG_FIELD_IFIMGTYPE3 | MNG_FIELD_IFIMGTYPE4 | MNG_FIELD_IFIMGTYPE6,
+     0, 0xFF, 1, 1,
+     offsetof(mng_sbit, aBits[1]), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE2 | MNG_FIELD_IFIMGTYPE3 | MNG_FIELD_IFIMGTYPE6,
+     0, 0xFF, 1, 1,
+     offsetof(mng_sbit, aBits[2]), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_IFIMGTYPE6,
+     0, 0xFF, 1, 1,
+     offsetof(mng_sbit, aBits[3]), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+MNG_LOCAL mng_field_descriptor mng_fields_splt [] =
+  {
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 1, 79,
+     offsetof(mng_splt, zName), MNG_NULL, offsetof(mng_splt, iNamesize)},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     8, 16, 1, 1,
+     offsetof(mng_splt, iSampledepth), MNG_NULL, MNG_NULL},
+    {mng_splt_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+MNG_LOCAL mng_field_descriptor mng_fields_hist [] =
+  {
+    {mng_hist_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tIME
+MNG_LOCAL mng_field_descriptor mng_fields_time [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_time, iYear), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 12, 1, 1,
+     offsetof(mng_time, iMonth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 31, 1, 1,
+     offsetof(mng_time, iDay), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 24, 1, 1,
+     offsetof(mng_time, iHour), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 60, 1, 1,
+     offsetof(mng_time, iMinute), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 60, 1, 1,
+     offsetof(mng_time, iSecond), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* JNG chunks */
+
+#ifdef MNG_INCLUDE_JNG
+MNG_LOCAL mng_field_descriptor mng_fields_jhdr [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_NOHIGHBIT,
+     1, 0, 4, 4,
+     offsetof(mng_jhdr, iWidth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_NOHIGHBIT,
+     1, 0, 4, 4,
+     offsetof(mng_jhdr, iHeight), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     8, 16, 1, 1,
+     offsetof(mng_jhdr, iColortype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     8, 20, 1, 1,
+     offsetof(mng_jhdr, iImagesampledepth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     8, 8, 1, 1,
+     offsetof(mng_jhdr, iImagecompression), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 8, 1, 1,
+     offsetof(mng_jhdr, iImageinterlace), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 16, 1, 1,
+     offsetof(mng_jhdr, iAlphasampledepth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 8, 1, 1,
+     offsetof(mng_jhdr, iAlphacompression), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_jhdr, iAlphafilter), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_jhdr, iAlphainterlace), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#define mng_fields_jdaa mng_fields_idat
+#define mng_fields_jdat mng_fields_idat
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* MNG chunks */
+
+MNG_LOCAL mng_field_descriptor mng_fields_mhdr [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_mhdr, iWidth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_mhdr, iHeight), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_mhdr, iTicks), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_mhdr, iLayercount), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_mhdr, iFramecount), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_mhdr, iPlaytime), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_mhdr, iSimplicity), MNG_NULL, MNG_NULL}
+  };
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+MNG_LOCAL mng_field_descriptor mng_fields_loop [] =
+  {
+    {mng_debunk_loop,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+MNG_LOCAL mng_field_descriptor mng_fields_endl [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFF, 1, 1,
+     offsetof(mng_endl, iLevel), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+MNG_LOCAL mng_field_descriptor mng_fields_defi [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_defi, iObjectid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 0xFF, 1, 1,
+     offsetof(mng_defi, iDonotshow), offsetof(mng_defi, bHasdonotshow), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 0xFF, 1, 1,
+     offsetof(mng_defi, iConcrete), offsetof(mng_defi, bHasconcrete), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_defi, iXlocation), offsetof(mng_defi, bHasloca), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_defi, iYlocation), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP2,
+     0, 0, 4, 4,
+     offsetof(mng_defi, iLeftcb), offsetof(mng_defi, bHasclip), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP2,
+     0, 0, 4, 4,
+     offsetof(mng_defi, iRightcb), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP2,
+     0, 0, 4, 4,
+     offsetof(mng_defi, iTopcb), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP2,
+     0, 0, 4, 4,
+     offsetof(mng_defi, iBottomcb), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BASI
+MNG_LOCAL mng_field_descriptor mng_fields_basi [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_basi, iWidth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_basi, iHeight), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 16, 1, 1,
+     offsetof(mng_basi, iBitdepth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 6, 1, 1,
+     offsetof(mng_basi, iColortype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_basi, iCompression), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_basi, iFilter), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_basi, iInterlace), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_basi, iRed), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_basi, iGreen), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_basi, iBlue), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_basi, iAlpha), offsetof(mng_basi, bHasalpha), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 1, 1, 1,
+     offsetof(mng_basi, iViewable), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLON
+MNG_LOCAL mng_field_descriptor mng_fields_clon [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_clon, iSourceid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_clon, iCloneid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 2, 1, 1,
+     offsetof(mng_clon, iClonetype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 1, 1, 1,
+     offsetof(mng_clon, iDonotshow), offsetof(mng_clon, bHasdonotshow), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 1, 1, 1,
+     offsetof(mng_clon, iConcrete), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 2, 1, 1,
+     offsetof(mng_clon, iLocationtype), offsetof(mng_clon, bHasloca), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_clon, iLocationx), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_clon, iLocationy), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+MNG_LOCAL mng_field_descriptor mng_fields_past [] =
+  {
+    {mng_debunk_past,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+MNG_LOCAL mng_field_descriptor mng_fields_disc [] =
+  {
+    {mng_disc_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BACK
+MNG_LOCAL mng_field_descriptor mng_fields_back [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_back, iRed), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_back, iGreen), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_back, iBlue), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 3, 1, 1,
+     offsetof(mng_back, iMandatory), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_back, iImageid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 1, 1, 1,
+     offsetof(mng_back, iTile), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+MNG_LOCAL mng_field_descriptor mng_fields_fram [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 4, 1, 1,
+     offsetof(mng_fram, iMode), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_TERMINATOR | MNG_FIELD_OPTIONAL,
+     0, 0, 1, 79,
+     offsetof(mng_fram, zName), MNG_NULL, offsetof(mng_fram, iNamesize)},
+    {mng_fram_remainder,
+     MNG_FIELD_OPTIONAL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MOVE
+MNG_LOCAL mng_field_descriptor mng_fields_move [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_move, iFirstid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_move, iLastid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_move, iMovetype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_move, iMovex), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_move, iMovey), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLIP
+MNG_LOCAL mng_field_descriptor mng_fields_clip [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_clip, iFirstid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_clip, iLastid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_clip, iCliptype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_clip, iClipl), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_clip, iClipr), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_clip, iClipt), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_clip, iClipb), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SHOW
+MNG_LOCAL mng_field_descriptor mng_fields_show [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 0xFFFF, 2, 2,
+     offsetof(mng_show, iFirstid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     1, 0xFFFF, 2, 2,
+     offsetof(mng_show, iLastid), offsetof(mng_show, bHaslastid), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL,
+     0, 7, 1, 1,
+     offsetof(mng_show, iMode), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_TERM
+MNG_LOCAL mng_field_descriptor mng_fields_term [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 3, 1, 1,
+     offsetof(mng_term, iTermaction), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 2, 1, 1,
+     offsetof(mng_term, iIteraction), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_term, iDelay), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_term, iItermax), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+MNG_LOCAL mng_field_descriptor mng_fields_save [] =
+  {
+    {mng_save_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+MNG_LOCAL mng_field_descriptor mng_fields_seek [] =
+  {
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 1, 79,
+     offsetof(mng_seek, zName), MNG_NULL, offsetof(mng_seek, iNamesize)}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+MNG_LOCAL mng_field_descriptor mng_fields_expi [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_expi, iSnapshotid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 1, 79,
+     offsetof(mng_expi, zName), MNG_NULL, offsetof(mng_expi, iNamesize)}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_fPRI
+MNG_LOCAL mng_field_descriptor mng_fields_fpri [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_fpri, iDeltatype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFF, 1, 1,
+     offsetof(mng_fpri, iPriority), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+MNG_LOCAL mng_field_descriptor mng_fields_need [] =
+  {
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 1, 0,
+     offsetof(mng_need, zKeywords), MNG_NULL, offsetof(mng_need, iKeywordssize)}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYg
+#define mng_fields_phyg mng_fields_phys
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_field_descriptor mng_fields_dhdr [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_dhdr, iObjectid), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 2, 1, 1,
+     offsetof(mng_dhdr, iImagetype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 7, 1, 1,
+     offsetof(mng_dhdr, iDeltatype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_dhdr, iBlockwidth), offsetof(mng_dhdr, bHasblocksize), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP1,
+     0, 0, 4, 4,
+     offsetof(mng_dhdr, iBlockheight), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP2,
+     0, 0, 4, 4,
+     offsetof(mng_dhdr, iBlockx), offsetof(mng_dhdr, bHasblockloc), MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT | MNG_FIELD_OPTIONAL | MNG_FIELD_GROUP2,
+     0, 0, 4, 4,
+     offsetof(mng_dhdr, iBlocky), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_field_descriptor mng_fields_prom [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 14, 1, 1,
+     offsetof(mng_prom, iColortype), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 16, 1, 1,
+     offsetof(mng_prom, iSampledepth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_prom, iFilltype), MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_field_descriptor mng_fields_pplt [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 5, 1, 1,
+     offsetof(mng_pplt, iDeltatype), MNG_NULL, MNG_NULL},
+    {mng_pplt_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_field_descriptor mng_fields_drop [] =
+  {
+    {mng_drop_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+MNG_LOCAL mng_field_descriptor mng_fields_dbyk [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_dbyk, iChunkname), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_dbyk, iPolarity), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 1, 0,
+     offsetof(mng_dbyk, zKeywords), MNG_NULL, offsetof(mng_dbyk, iKeywordssize)}
+  };
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+MNG_LOCAL mng_field_descriptor mng_fields_ordr [] =
+  {
+    {mng_drop_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+MNG_LOCAL mng_field_descriptor mng_fields_magn [] =
+  {
+    {mng_debunk_magn,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_LOCAL mng_field_descriptor mng_fields_mpng [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 0, 4, 4,
+     offsetof(mng_mpng, iFramewidth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 0, 4, 4,
+     offsetof(mng_mpng, iFrameheight), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0xFFFF, 2, 2,
+     offsetof(mng_mpng, iNumplays), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 0xFFFF, 2, 2,
+     offsetof(mng_mpng, iTickspersec), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 1, 1,
+     offsetof(mng_mpng, iCompressionmethod), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_DEFLATED,
+     0, 0, 1, 0,
+     offsetof(mng_mpng, pFrames), MNG_NULL, offsetof(mng_mpng, iFramessize)}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+MNG_LOCAL mng_field_descriptor mng_fields_ahdr [] =
+  {
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 0, 4, 4,
+     offsetof(mng_ahdr, iNumframes), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_ahdr, iTickspersec), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 0, 4, 4,
+     offsetof(mng_ahdr, iNumplays), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 0, 4, 4,
+     offsetof(mng_ahdr, iTilewidth), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     1, 0, 4, 4,
+     offsetof(mng_ahdr, iTileheight), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_ahdr, iInterlace), MNG_NULL, MNG_NULL},
+    {MNG_NULL,
+     MNG_FIELD_INT,
+     0, 1, 1, 1,
+     offsetof(mng_ahdr, iStillused), MNG_NULL, MNG_NULL}
+  };
+
+MNG_LOCAL mng_field_descriptor mng_fields_adat [] =
+  {
+    {mng_adat_tiles,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+MNG_LOCAL mng_field_descriptor mng_fields_evnt [] =
+  {
+    {mng_evnt_entries,
+     MNG_NULL,
+     0, 0, 0, 0,
+     MNG_NULL, MNG_NULL, MNG_NULL}
+  };
+#endif
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_field_descriptor mng_fields_unknown [] =
+  {
+    {MNG_NULL,
+     MNG_NULL,
+     0, 0, 1, 0,
+     offsetof(mng_unknown_chunk, pData), MNG_NULL, offsetof(mng_unknown_chunk, iDatasize)}
+  };
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* PNG chunks */
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_ihdr =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_ihdr,
+     mng_fields_ihdr, (sizeof(mng_fields_ihdr) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL,
+     MNG_NULL,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOJHDR | MNG_DESCR_NOBASI | MNG_DESCR_NOIDAT | MNG_DESCR_NOPLTE};
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_plte =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_plte, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_plte,
+     mng_fields_plte, (sizeof(mng_fields_plte) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_idat =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_idat, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_idat,
+     mng_fields_idat, (sizeof(mng_fields_idat) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOJSEP};
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_iend =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_iend,
+     MNG_NULL, 0,
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_GenHDR,
+     MNG_NULL};
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_trns =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_trns, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_trns,
+     mng_fields_trns, (sizeof(mng_fields_trns) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+
+#ifndef MNG_SKIPCHUNK_gAMA
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_gama =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_gama, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_gama,
+     mng_fields_gama, (sizeof(mng_fields_gama) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOPLTE | MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_cHRM
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_chrm =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_chrm, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_chrm,
+     mng_fields_chrm, (sizeof(mng_fields_chrm) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOPLTE | MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_sRGB
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_srgb =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_srgb, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_srgb,
+     mng_fields_srgb, (sizeof(mng_fields_srgb) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOPLTE | MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_iCCP
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_iccp =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_iccp, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_iccp,
+     mng_fields_iccp, (sizeof(mng_fields_iccp) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOPLTE | MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_tEXt
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_text =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_text,
+     mng_fields_text, (sizeof(mng_fields_text) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_NULL};
+#endif
+
+#ifndef MNG_SKIPCHUNK_zTXt
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_ztxt =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_ztxt,
+     mng_fields_ztxt, (sizeof(mng_fields_ztxt) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_NULL};
+#endif
+
+#ifndef MNG_SKIPCHUNK_iTXt
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_itxt =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_itxt,
+     mng_fields_itxt, (sizeof(mng_fields_itxt) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_NULL};
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_bkgd =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_bkgd, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_bkgd,
+     mng_fields_bkgd, (sizeof(mng_fields_bkgd) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_pHYs
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_phys =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_phys, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_phys,
+     mng_fields_phys, (sizeof(mng_fields_phys) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_sBIT
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_sbit =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_sbit, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_sbit,
+     mng_fields_sbit, (sizeof(mng_fields_sbit) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_sPLT
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_splt =
+    {mng_it_png, mng_create_none, 0, offsetof(mng_splt, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_splt,
+     mng_fields_splt, (sizeof(mng_fields_splt) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL | MNG_DESCR_EMPTYEMBED | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_hIST
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_hist =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_hist,
+     mng_fields_hist, (sizeof(mng_fields_hist) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_GenHDR | MNG_DESCR_PLTE,
+     MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT | MNG_DESCR_NOJDAA};
+#endif
+
+#ifndef MNG_SKIPCHUNK_tIME
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_time =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_time,
+     mng_fields_time, (sizeof(mng_fields_time) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_GLOBAL,
+     MNG_DESCR_GenHDR,
+     MNG_NULL};
+#endif
+
+/* ************************************************************************** */
+/* JNG chunks */
+
+#ifdef MNG_INCLUDE_JNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_jhdr =
+    {mng_it_jng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_jhdr,
+     mng_fields_jhdr, (sizeof(mng_fields_jhdr) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_NULL,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_jdaa =
+    {mng_it_jng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_jdaa,
+     mng_fields_jdaa, (sizeof(mng_fields_jdaa) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_JngHDR,
+     MNG_DESCR_NOJSEP};
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_jdat =
+    {mng_it_jng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_jdat,
+     mng_fields_jdat, (sizeof(mng_fields_jdat) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_JngHDR,
+     MNG_NULL};
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_jsep =
+    {mng_it_jng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_jsep,
+     MNG_NULL, 0,
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_JngHDR,
+     MNG_DESCR_NOJSEP};
+#endif
+
+/* ************************************************************************** */
+/* MNG chunks */
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_mhdr =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_mhdr,
+     mng_fields_mhdr, (sizeof(mng_fields_mhdr) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_NULL,
+     MNG_DESCR_NOMHDR | MNG_DESCR_NOIHDR | MNG_DESCR_NOJHDR};
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_mend =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_mend,
+     MNG_NULL, 0,
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_MHDR,
+     MNG_NULL};
+
+#ifndef MNG_SKIPCHUNK_LOOP
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_loop =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_loop,
+     mng_fields_loop, (sizeof(mng_fields_loop) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_endl =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_endl,
+     mng_fields_endl, (sizeof(mng_fields_endl) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_DEFI
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_defi =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_defi,
+     mng_fields_defi, (sizeof(mng_fields_defi) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_BASI
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_basi =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_basi,
+     mng_fields_basi, (sizeof(mng_fields_basi) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_CLON
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_clon =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_clon,
+     mng_fields_clon, (sizeof(mng_fields_clon) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_past =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_past,
+     mng_fields_past, (sizeof(mng_fields_past) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_DISC
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_disc =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_disc,
+     mng_fields_disc, (sizeof(mng_fields_disc) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_BACK
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_back =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_back,
+     mng_fields_back, (sizeof(mng_fields_back) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_fram =
+    {mng_it_mng, mng_create_none, 0, offsetof(mng_fram, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_fram,
+     mng_fields_fram, (sizeof(mng_fields_fram) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_MOVE
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_move =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_move,
+     mng_fields_move, (sizeof(mng_fields_move) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_CLIP
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_clip =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_clip,
+     mng_fields_clip, (sizeof(mng_fields_clip) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_SHOW
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_show =
+    {mng_it_mng, mng_create_none, 0, offsetof(mng_show, bEmpty),
+     MNG_NULL, MNG_NULL, mng_special_show,
+     mng_fields_show, (sizeof(mng_fields_show) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_TERM
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_term =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_term,
+     mng_fields_term, (sizeof(mng_fields_term) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR | MNG_DESCR_NOTERM | MNG_DESCR_NOLOOP};
+#endif
+
+#ifndef MNG_SKIPCHUNK_SAVE
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_save =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_save,
+     mng_fields_save, (sizeof(mng_fields_save) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOSAVE | MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_SEEK
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_seek =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_seek,
+     mng_fields_seek, (sizeof(mng_fields_seek) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYGLOBAL,
+     MNG_DESCR_MHDR | MNG_DESCR_SAVE,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_eXPI
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_expi =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_expi,
+     mng_fields_expi, (sizeof(mng_fields_expi) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_fPRI
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_fpri =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_fpri,
+     mng_fields_fpri, (sizeof(mng_fields_fpri) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_nEED
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_need =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_need,
+     mng_fields_need, (sizeof(mng_fields_need) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_pHYg
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_phyg =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_phyg,
+     mng_fields_phyg, (sizeof(mng_fields_phyg) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_dhdr =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_dhdr,
+     mng_fields_dhdr, (sizeof(mng_fields_dhdr) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_prom =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_prom,
+     mng_fields_prom, (sizeof(mng_fields_prom) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR | MNG_DESCR_DHDR,
+     MNG_NULL};
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_ipng =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_ipng,
+     MNG_NULL, 0,
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_MHDR | MNG_DESCR_DHDR,
+     MNG_NULL};
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_pplt =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_pplt,
+     mng_fields_pplt, (sizeof(mng_fields_pplt) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR | MNG_DESCR_DHDR,
+     MNG_NULL};
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_ijng =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_ijng,
+     MNG_NULL, 0,
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_MHDR | MNG_DESCR_DHDR,
+     MNG_NULL};
+#endif
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_drop =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_drop,
+     mng_fields_drop, (sizeof(mng_fields_drop) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR | MNG_DESCR_DHDR,
+     MNG_NULL};
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_dbyk =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_dbyk,
+     mng_fields_dbyk, (sizeof(mng_fields_dbyk) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYEMBED,
+     MNG_DESCR_MHDR | MNG_DESCR_DHDR,
+     MNG_NULL};
+#endif
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_ordr =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_ordr,
+     mng_fields_ordr, (sizeof(mng_fields_ordr) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR | MNG_DESCR_DHDR,
+     MNG_NULL};
+#endif
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_magn =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_magn,
+     mng_fields_magn, (sizeof(mng_fields_magn) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOIHDR | MNG_DESCR_NOBASI | MNG_DESCR_NODHDR | MNG_DESCR_NOJHDR};
+#endif
+
+#ifndef MNG_SKIPCHUNK_evNT
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_evnt =
+    {mng_it_mng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_evnt,
+     mng_fields_evnt, (sizeof(mng_fields_evnt) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_MHDR,
+     MNG_DESCR_NOSAVE};
+#endif
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_mpng =
+    {mng_it_mpng, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_mpng,
+     mng_fields_mpng, (sizeof(mng_fields_mpng) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_NULL,
+     MNG_DESCR_NOMHDR | MNG_DESCR_NOIDAT | MNG_DESCR_NOJDAT};
+#endif
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_ahdr =
+    {mng_it_ang, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_ahdr,
+     mng_fields_ahdr, (sizeof(mng_fields_ahdr) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_IHDR,
+     MNG_DESCR_NOMHDR | MNG_DESCR_NOJHDR | MNG_DESCR_NOIDAT};
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_adat =
+    {mng_it_ang, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_adat,
+     mng_fields_adat, (sizeof(mng_fields_adat) / sizeof(mng_field_descriptor)),
+     MNG_NULL,
+     MNG_DESCR_IHDR,
+     MNG_DESCR_NOMHDR | MNG_DESCR_NOJHDR};
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* the good ol' unknown babe */
+
+MNG_LOCAL mng_chunk_descriptor mng_chunk_descr_unknown =
+    {mng_it_png, mng_create_none, 0, 0,
+     MNG_NULL, MNG_NULL, mng_special_unknown,
+     mng_fields_unknown, (sizeof(mng_fields_unknown) / sizeof(mng_field_descriptor)),
+     MNG_DESCR_EMPTY | MNG_DESCR_EMPTYEMBED,
+     MNG_NULL,
+     MNG_NULL};
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+MNG_LOCAL mng_chunk_header mng_chunk_unknown =
+    {MNG_UINT_HUH, mng_init_general, mng_free_unknown,
+     mng_read_general, mng_write_unknown, mng_assign_unknown,
+     0, 0, sizeof(mng_unknown_chunk), &mng_chunk_descr_unknown};
+
+/* ************************************************************************** */
+
+  /* the table-idea & binary search code was adapted from
+     libpng 1.1.0 (pngread.c) */
+  /* NOTE1: the table must remain sorted by chunkname, otherwise the binary
+     search will break !!! (ps. watch upper-/lower-case chunknames !!) */
+  /* NOTE2: the layout must remain equal to the header part of all the
+     chunk-structures (yes, that means even the pNext and pPrev fields;
+     it's wasting a bit of space, but hey, the code is a lot easier) */
+
+MNG_LOCAL mng_chunk_header mng_chunk_table [] =
+  {
+#ifndef MNG_SKIPCHUNK_BACK
+    {MNG_UINT_BACK, mng_init_general, mng_free_general, mng_read_general, mng_write_back, mng_assign_general, 0, 0, sizeof(mng_back), &mng_chunk_descr_back},
+#endif
+#ifndef MNG_SKIPCHUNK_BASI
+    {MNG_UINT_BASI, mng_init_general, mng_free_general, mng_read_general, mng_write_basi, mng_assign_general, 0, 0, sizeof(mng_basi), &mng_chunk_descr_basi},
+#endif
+#ifndef MNG_SKIPCHUNK_CLIP
+    {MNG_UINT_CLIP, mng_init_general, mng_free_general, mng_read_general, mng_write_clip, mng_assign_general, 0, 0, sizeof(mng_clip), &mng_chunk_descr_clip},
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+    {MNG_UINT_CLON, mng_init_general, mng_free_general, mng_read_general, mng_write_clon, mng_assign_general, 0, 0, sizeof(mng_clon), &mng_chunk_descr_clon},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+    {MNG_UINT_DBYK, mng_init_general, mng_free_dbyk,    mng_read_general, mng_write_dbyk, mng_assign_dbyk,    0, 0, sizeof(mng_dbyk), &mng_chunk_descr_dbyk},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_DEFI
+    {MNG_UINT_DEFI, mng_init_general, mng_free_general, mng_read_general, mng_write_defi, mng_assign_general, 0, 0, sizeof(mng_defi), &mng_chunk_descr_defi},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_UINT_DHDR, mng_init_general, mng_free_general, mng_read_general, mng_write_dhdr, mng_assign_general, 0, 0, sizeof(mng_dhdr), &mng_chunk_descr_dhdr},
+#endif
+#ifndef MNG_SKIPCHUNK_DISC
+    {MNG_UINT_DISC, mng_init_general, mng_free_disc,    mng_read_general, mng_write_disc, mng_assign_disc,    0, 0, sizeof(mng_disc), &mng_chunk_descr_disc},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DROP
+    {MNG_UINT_DROP, mng_init_general, mng_free_drop,    mng_read_general, mng_write_drop, mng_assign_drop,    0, 0, sizeof(mng_drop), &mng_chunk_descr_drop},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+    {MNG_UINT_ENDL, mng_init_general, mng_free_general, mng_read_general, mng_write_endl, mng_assign_general, 0, 0, sizeof(mng_endl), &mng_chunk_descr_endl},
+#endif
+#ifndef MNG_SKIPCHUNK_FRAM
+    {MNG_UINT_FRAM, mng_init_general, mng_free_fram,    mng_read_general, mng_write_fram, mng_assign_fram,    0, 0, sizeof(mng_fram), &mng_chunk_descr_fram},
+#endif
+    {MNG_UINT_IDAT, mng_init_general, mng_free_idat,    mng_read_general, mng_write_idat, mng_assign_idat,    0, 0, sizeof(mng_idat), &mng_chunk_descr_idat},  /* 12-th element! */
+    {MNG_UINT_IEND, mng_init_general, mng_free_general, mng_read_general, mng_write_iend, mng_assign_general, 0, 0, sizeof(mng_iend), &mng_chunk_descr_iend},
+    {MNG_UINT_IHDR, mng_init_general, mng_free_general, mng_read_general, mng_write_ihdr, mng_assign_general, 0, 0, sizeof(mng_ihdr), &mng_chunk_descr_ihdr},
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+    {MNG_UINT_IJNG, mng_init_general, mng_free_general, mng_read_general, mng_write_ijng, mng_assign_general, 0, 0, sizeof(mng_ijng), &mng_chunk_descr_ijng},
+#endif
+    {MNG_UINT_IPNG, mng_init_general, mng_free_general, mng_read_general, mng_write_ipng, mng_assign_general, 0, 0, sizeof(mng_ipng), &mng_chunk_descr_ipng},
+#endif
+#ifdef MNG_INCLUDE_JNG
+    {MNG_UINT_JDAA, mng_init_general, mng_free_jdaa,    mng_read_general, mng_write_jdaa, mng_assign_jdaa,    0, 0, sizeof(mng_jdaa), &mng_chunk_descr_jdaa},
+    {MNG_UINT_JDAT, mng_init_general, mng_free_jdat,    mng_read_general, mng_write_jdat, mng_assign_jdat,    0, 0, sizeof(mng_jdat), &mng_chunk_descr_jdat},
+    {MNG_UINT_JHDR, mng_init_general, mng_free_general, mng_read_general, mng_write_jhdr, mng_assign_general, 0, 0, sizeof(mng_jhdr), &mng_chunk_descr_jhdr},
+    {MNG_UINT_JSEP, mng_init_general, mng_free_general, mng_read_general, mng_write_jsep, mng_assign_general, 0, 0, sizeof(mng_jsep), &mng_chunk_descr_jsep},
+    {MNG_UINT_JdAA, mng_init_general, mng_free_jdaa,    mng_read_general, mng_write_jdaa, mng_assign_jdaa,    0, 0, sizeof(mng_jdaa), &mng_chunk_descr_jdaa},
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+    {MNG_UINT_LOOP, mng_init_general, mng_free_loop,    mng_read_general, mng_write_loop, mng_assign_loop,    0, 0, sizeof(mng_loop), &mng_chunk_descr_loop},
+#endif
+#ifndef MNG_SKIPCHUNK_MAGN
+    {MNG_UINT_MAGN, mng_init_general, mng_free_general, mng_read_general, mng_write_magn, mng_assign_general, 0, 0, sizeof(mng_magn), &mng_chunk_descr_magn},
+#endif
+    {MNG_UINT_MEND, mng_init_general, mng_free_general, mng_read_general, mng_write_mend, mng_assign_general, 0, 0, sizeof(mng_mend), &mng_chunk_descr_mend},
+    {MNG_UINT_MHDR, mng_init_general, mng_free_general, mng_read_general, mng_write_mhdr, mng_assign_general, 0, 0, sizeof(mng_mhdr), &mng_chunk_descr_mhdr},
+#ifndef MNG_SKIPCHUNK_MOVE
+    {MNG_UINT_MOVE, mng_init_general, mng_free_general, mng_read_general, mng_write_move, mng_assign_general, 0, 0, sizeof(mng_move), &mng_chunk_descr_move},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+    {MNG_UINT_ORDR, mng_init_general, mng_free_ordr,    mng_read_general, mng_write_ordr, mng_assign_ordr,    0, 0, sizeof(mng_ordr), &mng_chunk_descr_ordr},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_UINT_PAST, mng_init_general, mng_free_past,    mng_read_general, mng_write_past, mng_assign_past,    0, 0, sizeof(mng_past), &mng_chunk_descr_past},
+#endif
+    {MNG_UINT_PLTE, mng_init_general, mng_free_general, mng_read_general, mng_write_plte, mng_assign_general, 0, 0, sizeof(mng_plte), &mng_chunk_descr_plte},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_UINT_PPLT, mng_init_general, mng_free_general, mng_read_general, mng_write_pplt, mng_assign_general, 0, 0, sizeof(mng_pplt), &mng_chunk_descr_pplt},
+    {MNG_UINT_PROM, mng_init_general, mng_free_general, mng_read_general, mng_write_prom, mng_assign_general, 0, 0, sizeof(mng_prom), &mng_chunk_descr_prom},
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+    {MNG_UINT_SAVE, mng_init_general, mng_free_save,    mng_read_general, mng_write_save, mng_assign_save,    0, 0, sizeof(mng_save), &mng_chunk_descr_save},
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+    {MNG_UINT_SEEK, mng_init_general, mng_free_seek,    mng_read_general, mng_write_seek, mng_assign_seek,    0, 0, sizeof(mng_seek), &mng_chunk_descr_seek},
+#endif
+#ifndef MNG_SKIPCHUNK_SHOW
+    {MNG_UINT_SHOW, mng_init_general, mng_free_general, mng_read_general, mng_write_show, mng_assign_general, 0, 0, sizeof(mng_show), &mng_chunk_descr_show},
+#endif
+#ifndef MNG_SKIPCHUNK_TERM
+    {MNG_UINT_TERM, mng_init_general, mng_free_general, mng_read_general, mng_write_term, mng_assign_general, 0, 0, sizeof(mng_term), &mng_chunk_descr_term},
+#endif
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+    {MNG_UINT_adAT, mng_init_general, mng_free_adat,    mng_read_general, mng_write_adat, mng_assign_adat,    0, 0, sizeof(mng_adat), &mng_chunk_descr_adat},
+    {MNG_UINT_ahDR, mng_init_general, mng_free_general, mng_read_general, mng_write_ahdr, mng_assign_ahdr,    0, 0, sizeof(mng_ahdr), &mng_chunk_descr_ahdr},
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+    {MNG_UINT_bKGD, mng_init_general, mng_free_general, mng_read_general, mng_write_bkgd, mng_assign_general, 0, 0, sizeof(mng_bkgd), &mng_chunk_descr_bkgd},
+#endif
+#ifndef MNG_SKIPCHUNK_cHRM
+    {MNG_UINT_cHRM, mng_init_general, mng_free_general, mng_read_general, mng_write_chrm, mng_assign_general, 0, 0, sizeof(mng_chrm), &mng_chunk_descr_chrm},
+#endif
+#ifndef MNG_SKIPCHUNK_eXPI
+    {MNG_UINT_eXPI, mng_init_general, mng_free_expi,    mng_read_general, mng_write_expi, mng_assign_expi,    0, 0, sizeof(mng_expi), &mng_chunk_descr_expi},
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_UINT_evNT, mng_init_general, mng_free_evnt,    mng_read_general, mng_write_evnt, mng_assign_evnt,    0, 0, sizeof(mng_evnt), &mng_chunk_descr_evnt},
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+    {MNG_UINT_fPRI, mng_init_general, mng_free_general, mng_read_general, mng_write_fpri, mng_assign_general, 0, 0, sizeof(mng_fpri), &mng_chunk_descr_fpri},
+#endif
+#ifndef MNG_SKIPCHUNK_gAMA
+    {MNG_UINT_gAMA, mng_init_general, mng_free_general, mng_read_general, mng_write_gama, mng_assign_general, 0, 0, sizeof(mng_gama), &mng_chunk_descr_gama},
+#endif
+#ifndef MNG_SKIPCHUNK_hIST
+    {MNG_UINT_hIST, mng_init_general, mng_free_general, mng_read_general, mng_write_hist, mng_assign_general, 0, 0, sizeof(mng_hist), &mng_chunk_descr_hist},
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+    {MNG_UINT_iCCP, mng_init_general, mng_free_iccp,    mng_read_general, mng_write_iccp, mng_assign_iccp,    0, 0, sizeof(mng_iccp), &mng_chunk_descr_iccp},
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+    {MNG_UINT_iTXt, mng_init_general, mng_free_itxt,    mng_read_general, mng_write_itxt, mng_assign_itxt,    0, 0, sizeof(mng_itxt), &mng_chunk_descr_itxt},
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_UINT_mpNG, mng_init_general, mng_free_mpng,    mng_read_general, mng_write_mpng, mng_assign_mpng,    0, 0, sizeof(mng_mpng), &mng_chunk_descr_mpng},
+#endif
+#ifndef MNG_SKIPCHUNK_nEED
+    {MNG_UINT_nEED, mng_init_general, mng_free_need,    mng_read_general, mng_write_need, mng_assign_need,    0, 0, sizeof(mng_need), &mng_chunk_descr_need},
+#endif
+/* TODO:     {MNG_UINT_oFFs, 0, 0, 0, 0, 0, 0},  */
+/* TODO:     {MNG_UINT_pCAL, 0, 0, 0, 0, 0, 0},  */
+#ifndef MNG_SKIPCHUNK_pHYg
+    {MNG_UINT_pHYg, mng_init_general, mng_free_general, mng_read_general, mng_write_phyg, mng_assign_general, 0, 0, sizeof(mng_phyg), &mng_chunk_descr_phyg},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+    {MNG_UINT_pHYs, mng_init_general, mng_free_general, mng_read_general, mng_write_phys, mng_assign_general, 0, 0, sizeof(mng_phys), &mng_chunk_descr_phys},
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+    {MNG_UINT_sBIT, mng_init_general, mng_free_general, mng_read_general, mng_write_sbit, mng_assign_general, 0, 0, sizeof(mng_sbit), &mng_chunk_descr_sbit},
+#endif
+/* TODO:     {MNG_UINT_sCAL, 0, 0, 0, 0, 0, 0},  */
+#ifndef MNG_SKIPCHUNK_sPLT
+    {MNG_UINT_sPLT, mng_init_general, mng_free_splt,    mng_read_general, mng_write_splt, mng_assign_splt,    0, 0, sizeof(mng_splt), &mng_chunk_descr_splt},
+#endif
+    {MNG_UINT_sRGB, mng_init_general, mng_free_general, mng_read_general, mng_write_srgb, mng_assign_general, 0, 0, sizeof(mng_srgb), &mng_chunk_descr_srgb},
+#ifndef MNG_SKIPCHUNK_tEXt
+    {MNG_UINT_tEXt, mng_init_general, mng_free_text,    mng_read_general, mng_write_text, mng_assign_text,    0, 0, sizeof(mng_text), &mng_chunk_descr_text},
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+    {MNG_UINT_tIME, mng_init_general, mng_free_general, mng_read_general, mng_write_time, mng_assign_general, 0, 0, sizeof(mng_time), &mng_chunk_descr_time},
+#endif
+    {MNG_UINT_tRNS, mng_init_general, mng_free_general, mng_read_general, mng_write_trns, mng_assign_general, 0, 0, sizeof(mng_trns), &mng_chunk_descr_trns},
+#ifndef MNG_SKIPCHUNK_zTXt
+    {MNG_UINT_zTXt, mng_init_general, mng_free_ztxt,    mng_read_general, mng_write_ztxt, mng_assign_ztxt,    0, 0, sizeof(mng_ztxt), &mng_chunk_descr_ztxt},
+#endif
+  };
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+void mng_get_chunkheader (mng_chunkid       iChunkname,
+                          mng_chunk_headerp pResult)
+{
+                                       /* binary search variables */
+  mng_int32         iTop, iLower, iUpper, iMiddle;
+  mng_chunk_headerp pEntry;            /* pointer to found entry */
+                                       /* determine max index of table */
+  iTop = (sizeof (mng_chunk_table) / sizeof (mng_chunk_table [0])) - 1;
+
+  /* binary search; with 54 chunks, worst-case is 7 comparisons */
+  iLower  = 0;
+#ifndef MNG_NO_DELTA_PNG
+  iMiddle = 11;                        /* start with the IDAT entry */
+#else
+  iMiddle = 8;
+#endif
+  iUpper  = iTop;
+  pEntry  = 0;                         /* no goods yet! */
+
+  do                                   /* the binary search itself */
+    {
+      if (mng_chunk_table [iMiddle].iChunkname < iChunkname)
+        iLower = iMiddle + 1;
+      else if (mng_chunk_table [iMiddle].iChunkname > iChunkname)
+        iUpper = iMiddle - 1;
+      else
+      {
+        pEntry = &mng_chunk_table [iMiddle];
+        break;
+      }
+      iMiddle = (iLower + iUpper) >> 1;
+    }
+  while (iLower <= iUpper);
+
+  if (!pEntry)                         /* unknown chunk ? */
+    pEntry = &mng_chunk_unknown;       /* make it so! */
+
+  MNG_COPY (pResult, pEntry, sizeof(mng_chunk_header));
+
+  return;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* PNG chunks */
+
+MNG_C_SPECIALFUNC (mng_special_ihdr)
+{
+  pData->bHasIHDR      = MNG_TRUE;     /* indicate IHDR is present */
+                                       /* and store interesting fields */
+  if ((!pData->bHasDHDR) || (pData->iDeltatype == MNG_DELTATYPE_NOCHANGE))
+  {
+    pData->iDatawidth  = ((mng_ihdrp)pChunk)->iWidth;
+    pData->iDataheight = ((mng_ihdrp)pChunk)->iHeight;
+  }
+
+  pData->iBitdepth     = ((mng_ihdrp)pChunk)->iBitdepth;
+  pData->iColortype    = ((mng_ihdrp)pChunk)->iColortype;
+  pData->iCompression  = ((mng_ihdrp)pChunk)->iCompression;
+  pData->iFilter       = ((mng_ihdrp)pChunk)->iFilter;
+  pData->iInterlace    = ((mng_ihdrp)pChunk)->iInterlace;
+
+#if defined(MNG_NO_1_2_4BIT_SUPPORT) || defined(MNG_NO_16BIT_SUPPORT)
+  pData->iPNGmult = 1;
+  pData->iPNGdepth = pData->iBitdepth;
+#endif
+
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+  if (pData->iBitdepth < 8)
+      pData->iBitdepth = 8;
+#endif
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (pData->iBitdepth > 8)
+    {
+      pData->iBitdepth = 8;
+      pData->iPNGmult = 2;
+    }
+#endif
+
+  if ((pData->iBitdepth !=  8)      /* parameter validity checks */
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+      && (pData->iBitdepth !=  1) &&
+      (pData->iBitdepth !=  2) &&
+      (pData->iBitdepth !=  4)
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+      && (pData->iBitdepth != 16)   
+#endif
+      )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if ((pData->iColortype != MNG_COLORTYPE_GRAY   ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGB    ) &&
+      (pData->iColortype != MNG_COLORTYPE_INDEXED) &&
+      (pData->iColortype != MNG_COLORTYPE_GRAYA  ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGBA   )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  if ((pData->iColortype == MNG_COLORTYPE_INDEXED) && (pData->iBitdepth > 8))
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (((pData->iColortype == MNG_COLORTYPE_RGB    ) ||
+       (pData->iColortype == MNG_COLORTYPE_GRAYA  ) ||
+       (pData->iColortype == MNG_COLORTYPE_RGBA   )    ) &&
+      (pData->iBitdepth < 8                            )    )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (pData->iCompression != MNG_COMPRESSION_DEFLATE)
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+#if defined(FILTER192) || defined(FILTER193)
+  if ((pData->iFilter != MNG_FILTER_ADAPTIVE ) &&
+#if defined(FILTER192) && defined(FILTER193)
+      (pData->iFilter != MNG_FILTER_DIFFERING) &&
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#else
+#ifdef FILTER192
+      (pData->iFilter != MNG_FILTER_DIFFERING)    )
+#else
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#endif
+#endif
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#else
+  if (pData->iFilter)
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#endif
+
+  if ((pData->iInterlace != MNG_INTERLACE_NONE ) &&
+      (pData->iInterlace != MNG_INTERLACE_ADAM7)    )
+    MNG_ERROR (pData, MNG_INVALIDINTERLACE);
+
+#ifdef MNG_SUPPORT_DISPLAY 
+#ifndef MNG_NO_DELTA_PNG
+  if (pData->bHasDHDR)                 /* check the colortype for delta-images ! */
+  {
+    mng_imagedatap pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+
+    if (pData->iColortype != pBuf->iColortype)
+    {
+      if ( ( (pData->iColortype != MNG_COLORTYPE_INDEXED) ||
+             (pBuf->iColortype  == MNG_COLORTYPE_GRAY   )    ) &&
+           ( (pData->iColortype != MNG_COLORTYPE_GRAY   ) ||
+             (pBuf->iColortype  == MNG_COLORTYPE_INDEXED)    )    )
+        MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+    }
+  }
+#endif
+#endif
+
+  if (!pData->bHasheader)              /* first chunk ? */
+  {
+    pData->bHasheader = MNG_TRUE;      /* we've got a header */
+    pData->eImagetype = mng_it_png;    /* then this must be a PNG */
+    pData->iWidth     = pData->iDatawidth;
+    pData->iHeight    = pData->iDataheight;
+                                       /* predict alpha-depth ! */
+    if ((pData->iColortype == MNG_COLORTYPE_GRAYA  ) ||
+        (pData->iColortype == MNG_COLORTYPE_RGBA   )    )
+      pData->iAlphadepth = pData->iBitdepth;
+    else
+    if (pData->iColortype == MNG_COLORTYPE_INDEXED)
+      pData->iAlphadepth = 8;          /* worst case scenario */
+    else
+      pData->iAlphadepth = 1;  /* Possible tRNS cheap binary transparency */
+                                       /* fits on maximum canvas ? */
+    if ((pData->iWidth > pData->iMaxwidth) || (pData->iHeight > pData->iMaxheight))
+      MNG_WARNING (pData, MNG_IMAGETOOLARGE);
+
+#if !defined(MNG_INCLUDE_MPNG_PROPOSAL) || !defined(MNG_SUPPORT_DISPLAY)
+    if (pData->fProcessheader)         /* inform the app ? */
+      if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+        MNG_ERROR (pData, MNG_APPMISCERROR);
+#endif
+  }
+
+  if (!pData->bHasDHDR)
+    pData->iImagelevel++;              /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_process_display_ihdr (pData);
+#else
+  return MNG_NOERROR;                 
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+
+/* ************************************************************************** */
+
+MNG_F_SPECIALFUNC (mng_debunk_plte)
+{
+  mng_pltep  pPLTE    = (mng_pltep)pChunk;
+  mng_uint32 iRawlen  = *piRawlen;
+  mng_uint8p pRawdata = *ppRawdata;
+                                       /* length must be multiple of 3 */
+  if (((iRawlen % 3) != 0) || (iRawlen > 768))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                                       /* this is the exact length */
+  pPLTE->iEntrycount = iRawlen / 3;
+
+  MNG_COPY (pPLTE->aEntries, pRawdata, iRawlen);
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_plte)
+{                                      /* multiple PLTE only inside BASI */
+  if ((pData->bHasPLTE) && (!pData->bHasBASI))
+    MNG_ERROR (pData, MNG_MULTIPLEERROR);
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {                                    /* only allowed for indexed-color or
+                                          rgb(a)-color! */
+    if ((pData->iColortype != MNG_COLORTYPE_RGB    ) &&
+        (pData->iColortype != MNG_COLORTYPE_INDEXED) &&
+        (pData->iColortype != MNG_COLORTYPE_RGBA   )   )
+      MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+                                       /* empty only allowed if global present */
+    if ((((mng_pltep)pChunk)->bEmpty) && (!pData->bHasglobalPLTE))
+      MNG_ERROR (pData, MNG_CANNOTBEEMPTY);
+  }
+  else
+  {
+    if (((mng_pltep)pChunk)->bEmpty)   /* cannot be empty as global! */
+      MNG_ERROR (pData, MNG_CANNOTBEEMPTY);
+  }
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+    pData->bHasPLTE = MNG_TRUE;        /* got it! */
+  else
+    pData->bHasglobalPLTE = MNG_TRUE;
+
+  pData->iPLTEcount = ((mng_pltep)pChunk)->iEntrycount;
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    mng_imagep     pImage;
+    mng_imagedatap pBuf;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* processing delta-image ? */
+    {                                  /* store in object 0 !!! */
+      pImage           = (mng_imagep)pData->pObjzero;
+      pBuf             = pImage->pImgbuf;
+      pBuf->bHasPLTE   = MNG_TRUE;     /* it's definitely got a PLTE now */
+      pBuf->iPLTEcount = ((mng_pltep)pChunk)->iEntrycount;
+      MNG_COPY (pBuf->aPLTEentries, ((mng_pltep)pChunk)->aEntries,
+                sizeof (pBuf->aPLTEentries));
+    }
+    else
+#endif
+    {                                  /* get the current object */
+      pImage = (mng_imagep)pData->pCurrentobj;
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+
+      pBuf = pImage->pImgbuf;          /* address the object buffer */
+      pBuf->bHasPLTE = MNG_TRUE;       /* and tell it it's got a PLTE now */
+
+      if (((mng_pltep)pChunk)->bEmpty) /* if empty, inherit from global */
+      {
+        pBuf->iPLTEcount = pData->iGlobalPLTEcount;
+        MNG_COPY (pBuf->aPLTEentries, pData->aGlobalPLTEentries,
+                  sizeof (pBuf->aPLTEentries));
+
+        if (pData->bHasglobalTRNS)     /* also copy global tRNS ? */
+        {
+          mng_uint32 iRawlen2  = pData->iGlobalTRNSrawlen;
+          mng_uint8p pRawdata2 = (mng_uint8p)(pData->aGlobalTRNSrawdata);
+                                       /* indicate tRNS available */
+          pBuf->bHasTRNS = MNG_TRUE;
+                                       /* global length oke ? */
+          if ((iRawlen2 == 0) || (iRawlen2 > pBuf->iPLTEcount))
+            MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+                                       /* copy it */
+          pBuf->iTRNScount = iRawlen2;
+          MNG_COPY (pBuf->aTRNSentries, pRawdata2, iRawlen2);
+        }
+      }
+      else
+      {                                /* store fields for future reference */
+        pBuf->iPLTEcount = ((mng_pltep)pChunk)->iEntrycount;
+        MNG_COPY (pBuf->aPLTEentries, ((mng_pltep)pChunk)->aEntries,
+                  sizeof (pBuf->aPLTEentries));
+      }
+    }
+  }
+  else                                 /* store as global */
+  {
+    pData->iGlobalPLTEcount = ((mng_pltep)pChunk)->iEntrycount;
+    MNG_COPY (pData->aGlobalPLTEentries, ((mng_pltep)pChunk)->aEntries,
+              sizeof (pData->aGlobalPLTEentries));
+                                       /* create an animation object */
+    return mng_create_ani_plte (pData);
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_idat)
+{
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasJHDR) &&
+      (pData->iJHDRalphacompression != MNG_COMPRESSION_DEFLATE))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+#endif
+                                       /* not allowed for deltatype NO_CHANGE */
+#ifndef MNG_NO_DELTA_PNG
+  if ((pData->bHasDHDR) && ((pData->iDeltatype == MNG_DELTATYPE_NOCHANGE)))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+#endif
+                                       /* can only be empty in BASI-block! */
+  if ((((mng_idatp)pChunk)->bEmpty) && (!pData->bHasBASI))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                                       /* indexed-color requires PLTE */
+  if ((pData->bHasIHDR) && (pData->iColortype == 3) && (!pData->bHasPLTE))
+    MNG_ERROR (pData, MNG_PLTEMISSING);
+
+  pData->bHasIDAT = MNG_TRUE;          /* got some IDAT now, don't we */
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_iend)
+{                                      /* IHDR-block requires IDAT */
+  if ((pData->bHasIHDR) && (!pData->bHasIDAT))
+    MNG_ERROR (pData, MNG_IDATMISSING);
+
+  pData->iImagelevel--;                /* one level up */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create an animation object */
+    mng_retcode iRetcode = mng_create_ani_image (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* display processing */
+    iRetcode = mng_process_display_iend (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (!pData->bTimerset)               /* reset only if not broken !!! */
+  {
+#endif
+                                       /* IEND signals the end for most ... */
+    pData->bHasIHDR         = MNG_FALSE;
+    pData->bHasBASI         = MNG_FALSE;
+    pData->bHasDHDR         = MNG_FALSE;
+#ifdef MNG_INCLUDE_JNG
+    pData->bHasJHDR         = MNG_FALSE;
+    pData->bHasJSEP         = MNG_FALSE;
+    pData->bHasJDAA         = MNG_FALSE;
+    pData->bHasJDAT         = MNG_FALSE;
+#endif
+    pData->bHasPLTE         = MNG_FALSE;
+    pData->bHasTRNS         = MNG_FALSE;
+    pData->bHasGAMA         = MNG_FALSE;
+    pData->bHasCHRM         = MNG_FALSE;
+    pData->bHasSRGB         = MNG_FALSE;
+    pData->bHasICCP         = MNG_FALSE;
+    pData->bHasBKGD         = MNG_FALSE;
+    pData->bHasIDAT         = MNG_FALSE;
+#ifdef MNG_SUPPORT_DISPLAY
+  }
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+MNG_F_SPECIALFUNC (mng_debunk_trns)
+{
+  mng_trnsp  pTRNS    = (mng_trnsp)pChunk;
+  mng_uint32 iRawlen  = *piRawlen;
+  mng_uint8p pRawdata = *ppRawdata;
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {                                  /* not global! */
+    pTRNS->bGlobal = MNG_FALSE;
+    pTRNS->iType   = pData->iColortype;
+
+    if (iRawlen != 0)
+    {
+      switch (pData->iColortype)     /* store fields */
+      {
+        case 0: {                    /* gray */
+                  if (iRawlen != 2)
+                    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                  pTRNS->iGray  = mng_get_uint16 (pRawdata);
+                  break;
+                }
+        case 2: {                    /* rgb */
+                  if (iRawlen != 6)
+                    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                  pTRNS->iRed   = mng_get_uint16 (pRawdata);
+                  pTRNS->iGreen = mng_get_uint16 (pRawdata+2);
+                  pTRNS->iBlue  = mng_get_uint16 (pRawdata+4);
+                  break;
+                }
+        case 3: {                    /* indexed */
+                  if (iRawlen > 256)
+                    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                  pTRNS->iCount = iRawlen;
+                  MNG_COPY (pTRNS->aEntries, pRawdata, iRawlen);
+                  break;
+                }
+      }
+    }
+  }
+  else                               /* it's global! */
+  {
+    if (iRawlen == 0)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+    pTRNS->bGlobal = MNG_TRUE;
+    pTRNS->iType   = 0;
+    pTRNS->iRawlen = iRawlen;
+    MNG_COPY (pTRNS->aRawdata, pRawdata, iRawlen);
+
+    pData->iGlobalTRNSrawlen = iRawlen;
+    MNG_COPY (pData->aGlobalTRNSrawdata, pRawdata, iRawlen);
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_trns)
+{                                      /* multiple tRNS only inside BASI */
+  if ((pData->bHasTRNS) && (!pData->bHasBASI))
+    MNG_ERROR (pData, MNG_MULTIPLEERROR);
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {                                    /* not allowed with full alpha-channel */
+    if ((pData->iColortype == 4) || (pData->iColortype == 6))
+      MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+
+    if (!((mng_trnsp)pChunk)->bEmpty)  /* filled ? */
+    {                                
+#ifdef MNG_SUPPORT_DISPLAY
+      if (pData->iColortype == 3)
+      {
+        mng_imagep     pImage = (mng_imagep)pData->pCurrentobj;
+        mng_imagedatap pBuf;
+
+        if (!pImage)                   /* no object then check obj 0 */
+          pImage = (mng_imagep)pData->pObjzero;
+
+        pBuf = pImage->pImgbuf;        /* address object buffer */
+
+        if (((mng_trnsp)pChunk)->iCount > pBuf->iPLTEcount)
+          MNG_ERROR (pData, MNG_INVALIDLENGTH);
+      }
+#endif
+    }
+    else                               /* if empty there must be global stuff! */
+    {
+      if (!pData->bHasglobalTRNS)
+        MNG_ERROR (pData, MNG_CANNOTBEEMPTY);
+    }
+  }
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+    pData->bHasTRNS = MNG_TRUE;        /* indicate tRNS available */
+  else
+    pData->bHasglobalTRNS = MNG_TRUE;
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    mng_imagep     pImage;
+    mng_imagedatap pBuf;
+    mng_uint8p     pRawdata2;
+    mng_uint32     iRawlen2;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* processing delta-image ? */
+    {                                  /* store in object 0 !!! */
+#if defined(MNG_NO_1_2_4BIT_SUPPORT)
+      mng_uint8 multiplier[]={0,255,85,0,17,0,0,0,1,0,0,0,0,0,0,0,1};
+#endif
+      pImage = (mng_imagep)pData->pObjzero;
+      pBuf   = pImage->pImgbuf;        /* address object buffer */
+      pBuf->bHasTRNS   = MNG_TRUE;     /* tell it it's got a tRNS now */
+      pBuf->iTRNSgray  = 0;
+      pBuf->iTRNSred   = 0;
+      pBuf->iTRNSgreen = 0;
+      pBuf->iTRNSblue  = 0;
+      pBuf->iTRNScount = 0;
+
+      switch (pData->iColortype)       /* store fields for future reference */
+      {
+        case 0: {                      /* gray */
+                  pBuf->iTRNSgray  = ((mng_trnsp)pChunk)->iGray;
+#if defined(MNG_NO_1_2_4BIT_SUPPORT)
+                  pBuf->iTRNSgray *= multiplier[pData->iPNGdepth];
+#endif
+#if defined(MNG_NO_16BIT_SUPPORT)
+                  if (pData->iPNGmult == 2)
+                     pBuf->iTRNSgray >>= 8;
+#endif
+                  break;
+                }
+        case 2: {                      /* rgb */
+                  pBuf->iTRNSred   = ((mng_trnsp)pChunk)->iRed;
+                  pBuf->iTRNSgreen = ((mng_trnsp)pChunk)->iGreen;
+                  pBuf->iTRNSblue  = ((mng_trnsp)pChunk)->iBlue;
+#if defined(MNG_NO_16BIT_SUPPORT)
+                  if (pData->iPNGmult == 2)
+                  {
+                     pBuf->iTRNSred   >>= 8;
+                     pBuf->iTRNSgreen >>= 8;
+                     pBuf->iTRNSblue  >>= 8;
+                  }
+#endif
+                  break;
+                }
+        case 3: {                      /* indexed */
+                  pBuf->iTRNScount = ((mng_trnsp)pChunk)->iCount;
+                  MNG_COPY (pBuf->aTRNSentries,
+                            ((mng_trnsp)pChunk)->aEntries,
+                            ((mng_trnsp)pChunk)->iCount);
+                  break;
+                }
+      }
+    }
+    else
+#endif
+    {                                  /* address current object */
+      pImage = (mng_imagep)pData->pCurrentobj;
+
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+
+      pBuf = pImage->pImgbuf;          /* address object buffer */
+      pBuf->bHasTRNS   = MNG_TRUE;     /* and tell it it's got a tRNS now */
+      pBuf->iTRNSgray  = 0;
+      pBuf->iTRNSred   = 0;
+      pBuf->iTRNSgreen = 0;
+      pBuf->iTRNSblue  = 0;
+      pBuf->iTRNScount = 0;
+
+      if (((mng_trnsp)pChunk)->bEmpty) /* if empty, inherit from global */
+      {
+        iRawlen2  = pData->iGlobalTRNSrawlen;
+        pRawdata2 = (mng_ptr)(pData->aGlobalTRNSrawdata);
+                                       /* global length oke ? */
+        if ((pData->iColortype == 0) && (iRawlen2 != 2))
+          MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+
+        if ((pData->iColortype == 2) && (iRawlen2 != 6))
+          MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+
+        if ((pData->iColortype == 3) && ((iRawlen2 == 0) || (iRawlen2 > pBuf->iPLTEcount)))
+          MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+
+        switch (pData->iColortype)     /* store fields for future reference */
+        {
+          case 0: {                    /* gray */
+                    pBuf->iTRNSgray = mng_get_uint16 (pRawdata2);
+#if defined(MNG_NO_16BIT_SUPPORT)
+                    if (pData->iPNGmult == 2)
+                       pBuf->iTRNSgray >>= 8;
+#endif
+                    break;
+                  }
+          case 2: {                    /* rgb */
+                    pBuf->iTRNSred   = mng_get_uint16 (pRawdata2);
+                    pBuf->iTRNSgreen = mng_get_uint16 (pRawdata2+2);
+                    pBuf->iTRNSblue  = mng_get_uint16 (pRawdata2+4);
+#if defined(MNG_NO_16BIT_SUPPORT)
+                    if (pData->iPNGmult == 2)
+                    {
+                       pBuf->iTRNSred   >>= 8;
+                       pBuf->iTRNSgreen >>= 8;
+                       pBuf->iTRNSblue  >>= 8;
+                    }
+#endif
+                    break;
+                  }
+          case 3: {                    /* indexed */
+                    pBuf->iTRNScount = iRawlen2;
+                    MNG_COPY (pBuf->aTRNSentries, pRawdata2, iRawlen2);
+                    break;
+                  }
+        }
+      }
+      else
+      {
+        switch (pData->iColortype)     /* store fields for future reference */
+        {
+          case 0: {                    /* gray */
+                    pBuf->iTRNSgray = ((mng_trnsp)pChunk)->iGray;
+#if defined(MNG_NO_16BIT_SUPPORT)
+                    if (pData->iPNGmult == 2)
+                       pBuf->iTRNSgray >>= 8;
+#endif
+                    break;
+                  }
+          case 2: {                    /* rgb */
+                    pBuf->iTRNSred   = ((mng_trnsp)pChunk)->iRed;
+                    pBuf->iTRNSgreen = ((mng_trnsp)pChunk)->iGreen;
+                    pBuf->iTRNSblue  = ((mng_trnsp)pChunk)->iBlue;
+#if defined(MNG_NO_16BIT_SUPPORT)
+                    if (pData->iPNGmult == 2)
+                    {
+                       pBuf->iTRNSred   >>= 8;
+                       pBuf->iTRNSgreen >>= 8;
+                       pBuf->iTRNSblue  >>= 8;
+                    }
+#endif
+                    break;
+                  }
+          case 3: {                    /* indexed */
+                    pBuf->iTRNScount = ((mng_trnsp)pChunk)->iCount;
+                    MNG_COPY (pBuf->aTRNSentries,
+                              ((mng_trnsp)pChunk)->aEntries,
+                              ((mng_trnsp)pChunk)->iCount);
+                    break;
+                  }
+        }
+      }
+    }
+  }
+  else
+  {                                    /* create an animation object */
+    return mng_create_ani_trns (pData);
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_gama)
+{
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasGAMA = MNG_TRUE;        /* indicate we've got it */
+  else
+    pData->bHasglobalGAMA = (mng_bool)!((mng_gamap)pChunk)->bEmpty;
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {
+    mng_imagep pImage;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* update delta image ? */
+      pImage = (mng_imagep)pData->pObjzero;
+    else
+#endif
+    {
+      pImage = (mng_imagep)pData->pCurrentobj;
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+    }
+                                       /* store for color-processing routines */
+    pImage->pImgbuf->iGamma   = ((mng_gamap)pChunk)->iGamma;
+    pImage->pImgbuf->bHasGAMA = MNG_TRUE;
+  }
+  else
+  {                                    /* store as global */
+    if (!((mng_gamap)pChunk)->bEmpty)
+      pData->iGlobalGamma = ((mng_gamap)pChunk)->iGamma;
+                                       /* create an animation object */
+    return mng_create_ani_gama (pData, pChunk);
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+MNG_C_SPECIALFUNC (mng_special_chrm)
+{
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasCHRM = MNG_TRUE;        /* indicate we've got it */
+  else
+    pData->bHasglobalCHRM = (mng_bool)!((mng_chrmp)pChunk)->bEmpty;
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+#ifdef MNG_INCLUDE_JNG
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    {
+      mng_imagep     pImage;
+      mng_imagedatap pBuf;
+
+#ifndef MNG_NO_DELTA_PNG
+      if (pData->bHasDHDR)             /* update delta image ? */
+        pImage = (mng_imagep)pData->pObjzero;
+      else
+#endif
+      {
+        pImage = (mng_imagep)pData->pCurrentobj;
+        if (!pImage)                   /* no object then dump it in obj 0 */
+          pImage = (mng_imagep)pData->pObjzero;
+      }
+
+      pBuf = pImage->pImgbuf;          /* address object buffer */
+      pBuf->bHasCHRM = MNG_TRUE;       /* and tell it it's got a CHRM now */
+                                       /* store for color-processing routines */
+      pBuf->iWhitepointx   = ((mng_chrmp)pChunk)->iWhitepointx;
+      pBuf->iWhitepointy   = ((mng_chrmp)pChunk)->iWhitepointy;
+      pBuf->iPrimaryredx   = ((mng_chrmp)pChunk)->iRedx;
+      pBuf->iPrimaryredy   = ((mng_chrmp)pChunk)->iRedy;
+      pBuf->iPrimarygreenx = ((mng_chrmp)pChunk)->iGreenx;
+      pBuf->iPrimarygreeny = ((mng_chrmp)pChunk)->iGreeny;
+      pBuf->iPrimarybluex  = ((mng_chrmp)pChunk)->iBluex;
+      pBuf->iPrimarybluey  = ((mng_chrmp)pChunk)->iBluey;
+    }
+    else
+    {                                  /* store as global */
+      if (!((mng_chrmp)pChunk)->bEmpty)
+      {
+        pData->iGlobalWhitepointx   = ((mng_chrmp)pChunk)->iWhitepointx;
+        pData->iGlobalWhitepointy   = ((mng_chrmp)pChunk)->iWhitepointy;
+        pData->iGlobalPrimaryredx   = ((mng_chrmp)pChunk)->iRedx;
+        pData->iGlobalPrimaryredy   = ((mng_chrmp)pChunk)->iRedy;
+        pData->iGlobalPrimarygreenx = ((mng_chrmp)pChunk)->iGreenx;
+        pData->iGlobalPrimarygreeny = ((mng_chrmp)pChunk)->iGreeny;
+        pData->iGlobalPrimarybluex  = ((mng_chrmp)pChunk)->iBluex;
+        pData->iGlobalPrimarybluey  = ((mng_chrmp)pChunk)->iBluey;
+      }
+                                       /* create an animation object */
+      return mng_create_ani_chrm (pData, pChunk);
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_srgb)
+{
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasSRGB = MNG_TRUE;        /* indicate we've got it */
+  else
+    pData->bHasglobalSRGB = (mng_bool)!((mng_srgbp)pChunk)->bEmpty;
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {
+    mng_imagep pImage;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* update delta image ? */
+      pImage = (mng_imagep)pData->pObjzero;
+    else
+#endif
+    {
+      pImage = (mng_imagep)pData->pCurrentobj;
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+    }
+                                       /* store for color-processing routines */
+    pImage->pImgbuf->iRenderingintent = ((mng_srgbp)pChunk)->iRenderingintent;
+    pImage->pImgbuf->bHasSRGB         = MNG_TRUE;
+  }
+  else
+  {                                    /* store as global */
+    if (!((mng_srgbp)pChunk)->bEmpty)
+      pData->iGlobalRendintent = ((mng_srgbp)pChunk)->iRenderingintent;
+                                       /* create an animation object */
+    return mng_create_ani_srgb (pData, pChunk);
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+MNG_C_SPECIALFUNC (mng_special_iccp)
+{
+  mng_retcode       iRetcode;
+  mng_chunk_headerp pDummy;
+
+#ifdef MNG_CHECK_BAD_ICCP              /* Check for bad iCCP chunk */
+  if (!strncmp (((mng_iccpp)pChunk)->zName, "Photoshop ICC profile", 21))
+  {
+    if (((mng_iccpp)pChunk)->iProfilesize == 2615) /* is it the sRGB profile ? */
+    {
+      mng_chunk_header chunk_srgb;
+      mng_get_chunkheader (MNG_UINT_sRGB, &chunk_srgb);
+                                       /* pretend it's an sRGB chunk then ! */
+      iRetcode = mng_read_general (pData, &chunk_srgb, 1, (mng_ptr)"0", &pDummy);
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+
+      pDummy->fCleanup (pData, pDummy);  
+    }
+  }
+  else
+  {
+#endif /* MNG_CHECK_BAD_ICCP */
+
+#ifdef MNG_INCLUDE_JNG
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+      pData->bHasICCP = MNG_TRUE;      /* indicate we've got it */
+    else
+      pData->bHasglobalICCP = (mng_bool)!((mng_iccpp)pChunk)->bEmpty;
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifdef MNG_INCLUDE_JNG
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    {
+      mng_imagep pImage;
+
+#ifndef MNG_NO_DELTA_PNG
+      if (pData->bHasDHDR)             /* update delta image ? */
+      {                                /* store in object 0 ! */
+        pImage = (mng_imagep)pData->pObjzero;
+
+        if (pImage->pImgbuf->pProfile) /* profile existed ? */
+          MNG_FREEX (pData, pImage->pImgbuf->pProfile, pImage->pImgbuf->iProfilesize);
+                                       /* allocate a buffer & copy it */
+        MNG_ALLOC (pData, pImage->pImgbuf->pProfile, ((mng_iccpp)pChunk)->iProfilesize);
+        MNG_COPY  (pImage->pImgbuf->pProfile, ((mng_iccpp)pChunk)->pProfile, ((mng_iccpp)pChunk)->iProfilesize);
+                                       /* store its length as well */
+        pImage->pImgbuf->iProfilesize = ((mng_iccpp)pChunk)->iProfilesize;
+        pImage->pImgbuf->bHasICCP     = MNG_TRUE;
+      }
+      else
+#endif
+      {
+        pImage = (mng_imagep)pData->pCurrentobj;
+
+        if (!pImage)                   /* no object then dump it in obj 0 */
+          pImage = (mng_imagep)pData->pObjzero;
+
+        if (pImage->pImgbuf->pProfile) /* profile existed ? */
+          MNG_FREEX (pData, pImage->pImgbuf->pProfile, pImage->pImgbuf->iProfilesize);
+                                       /* allocate a buffer & copy it */
+        MNG_ALLOC (pData, pImage->pImgbuf->pProfile, ((mng_iccpp)pChunk)->iProfilesize);
+        MNG_COPY  (pImage->pImgbuf->pProfile, ((mng_iccpp)pChunk)->pProfile, ((mng_iccpp)pChunk)->iProfilesize);
+                                       /* store its length as well */
+        pImage->pImgbuf->iProfilesize = ((mng_iccpp)pChunk)->iProfilesize;
+        pImage->pImgbuf->bHasICCP     = MNG_TRUE;
+      }
+    }
+    else
+    {                                  /* store as global */
+      if (pData->pGlobalProfile)     /* did we have a global profile ? */
+        MNG_FREEX (pData, pData->pGlobalProfile, pData->iGlobalProfilesize);
+
+      if (((mng_iccpp)pChunk)->bEmpty) /* empty chunk ? */
+      {
+        pData->iGlobalProfilesize = 0; /* reset to null */
+        pData->pGlobalProfile     = MNG_NULL;
+      }
+      else
+      {                                /* allocate a global buffer & copy it */
+        MNG_ALLOC (pData, pData->pGlobalProfile, ((mng_iccpp)pChunk)->iProfilesize);
+        MNG_COPY  (pData->pGlobalProfile, ((mng_iccpp)pChunk)->pProfile, ((mng_iccpp)pChunk)->iProfilesize);
+                                       /* store its length as well */
+        pData->iGlobalProfilesize = ((mng_iccpp)pChunk)->iProfilesize;
+      }
+                                       /* create an animation object */
+      return mng_create_ani_iccp (pData, pChunk);
+    }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_CHECK_BAD_ICCP
+  }
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+MNG_C_SPECIALFUNC (mng_special_text)
+{
+  if (pData->fProcesstext)             /* inform the application ? */
+  {
+    mng_bool bOke = pData->fProcesstext ((mng_handle)pData, MNG_TYPE_TEXT,
+                                         ((mng_textp)pChunk)->zKeyword,
+                                         ((mng_textp)pChunk)->zText, 0, 0);
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+MNG_C_SPECIALFUNC (mng_special_ztxt)
+{
+  if (pData->fProcesstext)             /* inform the application ? */
+  {
+    mng_bool bOke = pData->fProcesstext ((mng_handle)pData, MNG_TYPE_ZTXT,
+                                         ((mng_ztxtp)pChunk)->zKeyword,
+                                         ((mng_ztxtp)pChunk)->zText, 0, 0);
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+MNG_F_SPECIALFUNC (mng_deflate_itxt)
+{
+  mng_itxtp  pITXT    = (mng_itxtp)pChunk;
+  mng_uint32 iBufsize = 0;
+  mng_uint8p pBuf     = 0;
+  mng_uint32 iTextlen = 0;
+
+  if (pITXT->iCompressionflag)         /* decompress the text ? */
+  {
+    mng_retcode iRetcode = mng_inflate_buffer (pData, *ppRawdata, *piRawlen,
+                                               &pBuf, &iBufsize, &iTextlen);
+
+    if (iRetcode)                      /* on error bail out */
+    {                                  /* don't forget to drop the temp buffer */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+
+    MNG_ALLOC (pData, pITXT->zText, iTextlen+1);
+    MNG_COPY (pITXT->zText, pBuf, iTextlen);
+
+    pITXT->iTextsize = iTextlen;
+
+    MNG_FREEX (pData, pBuf, iBufsize);
+
+  } else {
+
+    MNG_ALLOC (pData, pITXT->zText, (*piRawlen)+1);
+    MNG_COPY (pITXT->zText, *ppRawdata, *piRawlen);
+
+    pITXT->iTextsize = *piRawlen;
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+MNG_C_SPECIALFUNC (mng_special_itxt)
+{
+  if (pData->fProcesstext)             /* inform the application ? */
+  {
+    mng_bool bOke = pData->fProcesstext ((mng_handle)pData, MNG_TYPE_ITXT,
+                                         ((mng_itxtp)pChunk)->zKeyword,
+                                         ((mng_itxtp)pChunk)->zText,
+                                         ((mng_itxtp)pChunk)->zLanguage,
+                                         ((mng_itxtp)pChunk)->zTranslation);
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+MNG_C_SPECIALFUNC (mng_special_bkgd)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_imagep     pImage = (mng_imagep)pData->pCurrentobj;
+  mng_imagedatap pBuf;
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasBKGD = MNG_TRUE;        /* indicate bKGD available */
+  else
+    pData->bHasglobalBKGD = (mng_bool)!(((mng_bkgdp)pChunk)->bEmpty);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (!pImage)                         /* if no object dump it in obj 0 */
+    pImage = (mng_imagep)pData->pObjzero;
+  pBuf = pImage->pImgbuf;              /* address object buffer */
+
+#ifdef MNG_INCLUDE_JNG
+  if (pData->bHasJHDR)
+  {
+    pBuf->bHasBKGD = MNG_TRUE;         /* tell the object it's got bKGD now */
+
+    switch (pData->iJHDRcolortype)     /* store fields for future reference */
+    {
+      case  8 : ;                      /* gray */
+      case 12 : {                      /* graya */
+                  pBuf->iBKGDgray  = ((mng_bkgdp)pChunk)->iGray;
+                  break;
+                }
+      case 10 : ;                      /* rgb */
+      case 14 : {                      /* rgba */
+                  pBuf->iBKGDred   = ((mng_bkgdp)pChunk)->iRed;
+                  pBuf->iBKGDgreen = ((mng_bkgdp)pChunk)->iGreen;
+                  pBuf->iBKGDblue  = ((mng_bkgdp)pChunk)->iBlue;
+                  break;
+                }
+    }
+  }
+  else
+#endif /* MNG_INCLUDE_JNG */
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    pBuf->bHasBKGD = MNG_TRUE;         /* tell the object it's got bKGD now */
+
+    switch (pData->iColortype)         /* store fields for future reference */
+    {
+      case 0 : ;                        /* gray */
+      case 4 : {                        /* graya */
+                 pBuf->iBKGDgray  = ((mng_bkgdp)pChunk)->iGray;
+                 break;
+               }
+      case 2 : ;                        /* rgb */
+      case 6 : {                        /* rgba */
+                 pBuf->iBKGDred   = ((mng_bkgdp)pChunk)->iRed;
+                 pBuf->iBKGDgreen = ((mng_bkgdp)pChunk)->iGreen;
+                 pBuf->iBKGDblue  = ((mng_bkgdp)pChunk)->iBlue;
+                 break;
+               }
+      case 3 : {                        /* indexed */
+                 pBuf->iBKGDindex = ((mng_bkgdp)pChunk)->iIndex;
+                 break;
+               }
+    }
+  }
+  else                                 /* store as global */
+  {
+    if (!(((mng_bkgdp)pChunk)->bEmpty))
+    {
+      pData->iGlobalBKGDred   = ((mng_bkgdp)pChunk)->iRed;
+      pData->iGlobalBKGDgreen = ((mng_bkgdp)pChunk)->iGreen;
+      pData->iGlobalBKGDblue  = ((mng_bkgdp)pChunk)->iBlue;
+    }
+                                       /* create an animation object */
+    return mng_create_ani_bkgd (pData);
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYs
+MNG_C_SPECIALFUNC (mng_special_phys)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sBIT
+MNG_C_SPECIALFUNC (mng_special_sbit)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+MNG_F_SPECIALFUNC (mng_splt_entries)
+{
+  mng_spltp  pSPLT    = (mng_spltp)pChunk;
+  mng_uint32 iRawlen  = *piRawlen;
+  mng_uint8p pRawdata = *ppRawdata;
+
+  if ((pSPLT->iSampledepth != MNG_BITDEPTH_8 ) &&
+      (pSPLT->iSampledepth != MNG_BITDEPTH_16)   )
+    MNG_ERROR (pData, MNG_INVSAMPLEDEPTH);
+                                       /* check remaining length */
+  if ( ((pSPLT->iSampledepth == MNG_BITDEPTH_8 ) && (iRawlen %  6 != 0)) ||
+       ((pSPLT->iSampledepth == MNG_BITDEPTH_16) && (iRawlen % 10 != 0))    )
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  if (pSPLT->iSampledepth == MNG_BITDEPTH_8)
+    pSPLT->iEntrycount = iRawlen / 6;
+  else
+    pSPLT->iEntrycount = iRawlen / 10;
+
+  if (iRawlen)
+  {
+    MNG_ALLOC (pData, pSPLT->pEntries, iRawlen);
+    MNG_COPY (pSPLT->pEntries, pRawdata, iRawlen);
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+MNG_C_SPECIALFUNC (mng_special_splt)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+MNG_F_SPECIALFUNC (mng_hist_entries)
+{
+  mng_histp  pHIST    = (mng_histp)pChunk;
+  mng_uint32 iRawlen  = *piRawlen;
+  mng_uint8p pRawdata = *ppRawdata;
+  mng_uint32 iX;
+
+  if ( ((iRawlen & 0x01) != 0) || ((iRawlen >> 1) != pData->iPLTEcount) )
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pHIST->iEntrycount = iRawlen >> 1;
+
+  for (iX = 0; iX < pHIST->iEntrycount; iX++)
+  {
+    pHIST->aEntries[iX] = mng_get_uint16 (pRawdata);
+    pRawdata += 2;
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+MNG_C_SPECIALFUNC (mng_special_hist)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tIME
+MNG_C_SPECIALFUNC (mng_special_time)
+{
+/*  if (pData->fProcesstime) */            /* inform the application ? */
+/*  {
+
+    pData->fProcesstime ((mng_handle)pData, );
+  } */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* JNG chunks */
+
+#ifdef MNG_INCLUDE_JNG
+MNG_C_SPECIALFUNC (mng_special_jhdr)
+{
+  if ((pData->eSigtype == mng_it_jng) && (pData->iChunkseq > 1))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* inside a JHDR-IEND block now */
+  pData->bHasJHDR              = MNG_TRUE;
+                                       /* and store interesting fields */
+  pData->iDatawidth            = ((mng_jhdrp)pChunk)->iWidth;
+  pData->iDataheight           = ((mng_jhdrp)pChunk)->iHeight;
+  pData->iJHDRcolortype        = ((mng_jhdrp)pChunk)->iColortype;
+  pData->iJHDRimgbitdepth      = ((mng_jhdrp)pChunk)->iImagesampledepth;
+  pData->iJHDRimgcompression   = ((mng_jhdrp)pChunk)->iImagecompression;
+  pData->iJHDRimginterlace     = ((mng_jhdrp)pChunk)->iImageinterlace;
+  pData->iJHDRalphabitdepth    = ((mng_jhdrp)pChunk)->iAlphasampledepth;
+  pData->iJHDRalphacompression = ((mng_jhdrp)pChunk)->iAlphacompression;
+  pData->iJHDRalphafilter      = ((mng_jhdrp)pChunk)->iAlphafilter;
+  pData->iJHDRalphainterlace   = ((mng_jhdrp)pChunk)->iAlphainterlace;
+
+#if defined(MNG_NO_1_2_4BIT_SUPPORT) || defined(MNG_NO_16BIT_SUPPORT)
+  pData->iPNGmult = 1;
+  pData->iPNGdepth = pData->iJHDRalphabitdepth;
+#endif
+
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+  if (pData->iJHDRalphabitdepth < 8)
+    pData->iJHDRalphabitdepth = 8;
+#endif
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (pData->iJHDRalphabitdepth > 8)
+  {
+    pData->iPNGmult = 2;
+    pData->iJHDRalphabitdepth = 8;
+  }
+#endif
+                                       /* parameter validity checks */
+  if ((pData->iJHDRcolortype != MNG_COLORTYPE_JPEGGRAY  ) &&
+      (pData->iJHDRcolortype != MNG_COLORTYPE_JPEGCOLOR ) &&
+      (pData->iJHDRcolortype != MNG_COLORTYPE_JPEGGRAYA ) &&
+      (pData->iJHDRcolortype != MNG_COLORTYPE_JPEGCOLORA)    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  if ((pData->iJHDRimgbitdepth != MNG_BITDEPTH_JPEG8     ) &&
+      (pData->iJHDRimgbitdepth != MNG_BITDEPTH_JPEG12    ) &&
+      (pData->iJHDRimgbitdepth != MNG_BITDEPTH_JPEG8AND12)    )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA ) ||
+      (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )
+  {
+    if ((pData->iJHDRalphabitdepth != MNG_BITDEPTH_8 )
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        && (pData->iJHDRalphabitdepth != MNG_BITDEPTH_1 ) &&
+        (pData->iJHDRalphabitdepth != MNG_BITDEPTH_2 ) &&
+        (pData->iJHDRalphabitdepth != MNG_BITDEPTH_4 )
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+        && (pData->iJHDRalphabitdepth != MNG_BITDEPTH_16)
+#endif
+        )
+      MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+    if ((pData->iJHDRalphacompression != MNG_COMPRESSION_DEFLATE     ) &&
+        (pData->iJHDRalphacompression != MNG_COMPRESSION_BASELINEJPEG)    )
+      MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+    if ((pData->iJHDRalphacompression == MNG_COMPRESSION_BASELINEJPEG) &&
+        (pData->iJHDRalphabitdepth    !=  MNG_BITDEPTH_8             )    )
+      MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+#if defined(FILTER192) || defined(FILTER193)
+    if ((pData->iJHDRalphafilter != MNG_FILTER_ADAPTIVE ) &&
+#if defined(FILTER192) && defined(FILTER193)
+        (pData->iJHDRalphafilter != MNG_FILTER_DIFFERING) &&
+        (pData->iJHDRalphafilter != MNG_FILTER_NOFILTER )    )
+#else
+#ifdef FILTER192
+        (pData->iJHDRalphafilter != MNG_FILTER_DIFFERING)    )
+#else
+        (pData->iJHDRalphafilter != MNG_FILTER_NOFILTER )    )
+#endif
+#endif
+      MNG_ERROR (pData, MNG_INVALIDFILTER);
+#else
+    if (pData->iJHDRalphafilter)
+      MNG_ERROR (pData, MNG_INVALIDFILTER);
+#endif
+
+  }
+  else
+  {
+    if (pData->iJHDRalphabitdepth)
+      MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+    if (pData->iJHDRalphacompression)
+      MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+    if (pData->iJHDRalphafilter)
+      MNG_ERROR (pData, MNG_INVALIDFILTER);
+    if (pData->iJHDRalphainterlace)
+      MNG_ERROR (pData, MNG_INVALIDINTERLACE);
+  }
+
+  if (!pData->bHasheader)              /* first chunk ? */
+  {
+    pData->bHasheader = MNG_TRUE;      /* we've got a header */
+    pData->eImagetype = mng_it_jng;    /* then this must be a JNG */
+    pData->iWidth     = ((mng_jhdrp)pChunk)->iWidth;
+    pData->iHeight    = ((mng_jhdrp)pChunk)->iHeight;
+                                       /* predict alpha-depth ! */
+    if ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA ) ||
+        (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )
+      pData->iAlphadepth = pData->iJHDRalphabitdepth;
+    else
+      pData->iAlphadepth = 0;
+                                       /* fits on maximum canvas ? */
+    if ((pData->iWidth > pData->iMaxwidth) || (pData->iHeight > pData->iMaxheight))
+      MNG_WARNING (pData, MNG_IMAGETOOLARGE);
+
+    if (pData->fProcessheader)         /* inform the app ? */
+      if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+        MNG_ERROR (pData, MNG_APPMISCERROR);
+
+  }
+
+  pData->iColortype = 0;               /* fake grayscale for other routines */
+  pData->iImagelevel++;                /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode = mng_process_display_jhdr (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (((mng_jhdrp)pChunk)->iAlphasampledepth > 8)
+    ((mng_jhdrp)pChunk)->iAlphasampledepth = 8;
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+MNG_C_SPECIALFUNC (mng_special_jdaa)
+{
+  if (pData->iJHDRalphacompression != MNG_COMPRESSION_BASELINEJPEG)
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  pData->bHasJDAA = MNG_TRUE;          /* got some JDAA now, don't we */
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+MNG_C_SPECIALFUNC (mng_special_jdat)
+{
+  pData->bHasJDAT = MNG_TRUE;          /* got some JDAT now, don't we */
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+MNG_C_SPECIALFUNC (mng_special_jsep)
+{
+  pData->bHasJSEP = MNG_TRUE;          /* indicate we've had the 8-/12-bit separator */
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+/* MNG chunks */
+
+MNG_C_SPECIALFUNC (mng_special_mhdr)
+{
+  if (pData->bHasheader)               /* can only be the first chunk! */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  pData->bHasMHDR     = MNG_TRUE;      /* oh boy, a real MNG */
+  pData->bHasheader   = MNG_TRUE;      /* we've got a header */
+  pData->eImagetype   = mng_it_mng;    /* fill header fields */
+  pData->iWidth       = ((mng_mhdrp)pChunk)->iWidth;
+  pData->iHeight      = ((mng_mhdrp)pChunk)->iHeight;
+  pData->iTicks       = ((mng_mhdrp)pChunk)->iTicks;
+  pData->iLayercount  = ((mng_mhdrp)pChunk)->iLayercount;
+  pData->iFramecount  = ((mng_mhdrp)pChunk)->iFramecount;
+  pData->iPlaytime    = ((mng_mhdrp)pChunk)->iPlaytime;
+  pData->iSimplicity  = ((mng_mhdrp)pChunk)->iSimplicity;
+#ifndef MNG_NO_OLD_VERSIONS
+  pData->bPreDraft48  = MNG_FALSE;
+#endif
+                                       /* predict alpha-depth */
+  if ((pData->iSimplicity & 0x00000001) == 0)
+#ifndef MNG_NO_16BIT_SUPPORT
+    pData->iAlphadepth = 16;           /* no indicators = assume the worst */
+#else
+    pData->iAlphadepth = 8;            /* anything else = assume the worst */
+#endif
+  else
+  if ((pData->iSimplicity & 0x00000008) == 0)
+    pData->iAlphadepth = 0;            /* no transparency at all */
+  else
+  if ((pData->iSimplicity & 0x00000140) == 0x00000040)
+    pData->iAlphadepth = 1;            /* no semi-transparency guaranteed */
+  else
+#ifndef MNG_NO_16BIT_SUPPORT
+    pData->iAlphadepth = 16;           /* anything else = assume the worst */
+#else
+    pData->iAlphadepth = 8;            /* anything else = assume the worst */
+#endif
+
+#ifdef MNG_INCLUDE_JNG                 /* can we handle the complexity ? */
+  if (pData->iSimplicity & 0x0000FC00)
+#else
+  if (pData->iSimplicity & 0x0000FC10)
+#endif
+    MNG_ERROR (pData, MNG_MNGTOOCOMPLEX);
+                                       /* fits on maximum canvas ? */
+  if ((pData->iWidth > pData->iMaxwidth) || (pData->iHeight > pData->iMaxheight))
+    MNG_WARNING (pData, MNG_IMAGETOOLARGE);
+
+  if (pData->fProcessheader)           /* inform the app ? */
+    if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+
+  pData->iImagelevel++;                /* one level deeper */
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_mend)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* do something */
+    mng_retcode iRetcode = mng_process_display_mend (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    if (!pData->iTotalframes)          /* save totals */
+      pData->iTotalframes   = pData->iFrameseq;
+    if (!pData->iTotallayers)
+      pData->iTotallayers   = pData->iLayerseq;
+    if (!pData->iTotalplaytime)
+      pData->iTotalplaytime = pData->iFrametime;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  pData->bHasMHDR = MNG_FALSE;         /* end of the line, bro! */
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+MNG_F_SPECIALFUNC (mng_debunk_loop)
+{
+  mng_loopp  pLOOP    = (mng_loopp)pChunk;
+  mng_uint32 iRawlen  = *piRawlen;
+  mng_uint8p pRawdata = *ppRawdata;
+
+  if (iRawlen >= 5)                    /* length checks */
+  {
+    if (iRawlen >= 6)
+    {
+      if ((iRawlen - 6) % 4 != 0)
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+    }
+  }
+  else
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  if (iRawlen >= 5)                  /* store the fields */
+  {
+    pLOOP->iLevel  = *pRawdata;
+
+#ifndef MNG_NO_OLD_VERSIONS
+    if (pData->bPreDraft48)
+    {
+      pLOOP->iTermination = *(pRawdata+1);
+      pLOOP->iRepeat = mng_get_uint32 (pRawdata+2);
+    }
+    else
+#endif
+    {
+      pLOOP->iRepeat = mng_get_uint32 (pRawdata+1);
+    }
+
+    if (iRawlen >= 6)
+    {
+#ifndef MNG_NO_OLD_VERSIONS
+      if (!pData->bPreDraft48)
+#endif
+        pLOOP->iTermination = *(pRawdata+5);
+
+      if (iRawlen >= 10)
+      {
+        pLOOP->iItermin = mng_get_uint32 (pRawdata+6);
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+        if (iRawlen >= 14)
+        {
+          pLOOP->iItermax = mng_get_uint32 (pRawdata+10);
+          pLOOP->iCount   = (iRawlen - 14) / 4;
+
+          if (pLOOP->iCount)
+          {
+            MNG_ALLOC (pData, pLOOP->pSignals, pLOOP->iCount << 2);
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+            {
+              mng_uint32  iX;
+              mng_uint8p  pIn  = pRawdata + 14;
+              mng_uint32p pOut = (mng_uint32p)pLOOP->pSignals;
+
+              for (iX = 0; iX < pLOOP->iCount; iX++)
+              {
+                *pOut++ = mng_get_uint32 (pIn);
+                pIn += 4;
+              }
+            }
+#else
+            MNG_COPY (pLOOP->pSignals, pRawdata + 14, pLOOP->iCount << 2);
+#endif /* !MNG_BIGENDIAN_SUPPORTED */
+          }
+        }
+#endif
+      }
+    }
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+MNG_C_SPECIALFUNC (mng_special_loop)
+{
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_LOOPWITHCACHEOFF);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+
+    pData->bHasLOOP = MNG_TRUE;        /* indicate we're inside a loop */
+                                       /* create the LOOP ani-object */
+    iRetcode = mng_create_ani_loop (pData, pChunk);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* skip till matching ENDL if iteration=0 */
+    if ((!pData->bSkipping) && (((mng_loopp)pChunk)->iRepeat == 0))
+      pData->bSkipping = MNG_TRUE;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+MNG_C_SPECIALFUNC (mng_special_endl)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  if (pData->bHasLOOP)                 /* are we really processing a loop ? */
+  {
+    mng_uint8 iLevel = ((mng_endlp)pChunk)->iLevel;
+                                       /* create an ENDL animation object */
+    return mng_create_ani_endl (pData, iLevel);
+  }
+  else
+    MNG_ERROR (pData, MNG_NOMATCHINGLOOP);
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+MNG_C_SPECIALFUNC (mng_special_defi)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_retcode iRetcode;
+
+  pData->iDEFIobjectid     = ((mng_defip)pChunk)->iObjectid;
+  pData->bDEFIhasdonotshow = ((mng_defip)pChunk)->bHasdonotshow;
+  pData->iDEFIdonotshow    = ((mng_defip)pChunk)->iDonotshow;
+  pData->bDEFIhasconcrete  = ((mng_defip)pChunk)->bHasconcrete;
+  pData->iDEFIconcrete     = ((mng_defip)pChunk)->iConcrete;
+  pData->bDEFIhasloca      = ((mng_defip)pChunk)->bHasloca;
+  pData->iDEFIlocax        = ((mng_defip)pChunk)->iXlocation;
+  pData->iDEFIlocay        = ((mng_defip)pChunk)->iYlocation;
+  pData->bDEFIhasclip      = ((mng_defip)pChunk)->bHasclip;
+  pData->iDEFIclipl        = ((mng_defip)pChunk)->iLeftcb;
+  pData->iDEFIclipr        = ((mng_defip)pChunk)->iRightcb;
+  pData->iDEFIclipt        = ((mng_defip)pChunk)->iTopcb;
+  pData->iDEFIclipb        = ((mng_defip)pChunk)->iBottomcb;
+                                       /* create an animation object */
+  iRetcode = mng_create_ani_defi (pData);
+  if (!iRetcode)                       /* do display processing */
+    iRetcode = mng_process_display_defi (pData);
+  return iRetcode;
+#else
+  return MNG_NOERROR;                  /* done */
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BASI
+MNG_C_SPECIALFUNC (mng_special_basi)
+{
+  pData->bHasBASI     = MNG_TRUE;      /* inside a BASI-IEND block now */
+                                       /* store interesting fields */
+  pData->iDatawidth   = ((mng_basip)pChunk)->iWidth;
+  pData->iDataheight  = ((mng_basip)pChunk)->iHeight;
+  pData->iBitdepth    = ((mng_basip)pChunk)->iBitdepth;   
+  pData->iColortype   = ((mng_basip)pChunk)->iColortype;
+  pData->iCompression = ((mng_basip)pChunk)->iCompression;
+  pData->iFilter      = ((mng_basip)pChunk)->iFilter;
+  pData->iInterlace   = ((mng_basip)pChunk)->iInterlace;
+
+#if defined(MNG_NO_1_2_4BIT_SUPPORT) || defined(MNG_NO_16BIT_SUPPORT)
+  pData->iPNGmult = 1;
+  pData->iPNGdepth = pData->iBitdepth;
+#endif
+
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+  if (pData->iBitdepth < 8)
+    pData->iBitdepth = 8;
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (pData->iBitdepth > 8)
+    {
+      pData->iBitdepth = 8;
+      pData->iPNGmult = 2;
+    }
+#endif
+
+  if ((pData->iBitdepth !=  8)      /* parameter validity checks */
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+      && (pData->iBitdepth !=  1) &&
+      (pData->iBitdepth !=  2) &&
+      (pData->iBitdepth !=  4)
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+      && (pData->iBitdepth != 16)
+#endif
+      )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if ((pData->iColortype != MNG_COLORTYPE_GRAY   ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGB    ) &&
+      (pData->iColortype != MNG_COLORTYPE_INDEXED) &&
+      (pData->iColortype != MNG_COLORTYPE_GRAYA  ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGBA   )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  if ((pData->iColortype == MNG_COLORTYPE_INDEXED) && (pData->iBitdepth > 8))
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (((pData->iColortype == MNG_COLORTYPE_RGB    ) ||
+       (pData->iColortype == MNG_COLORTYPE_GRAYA  ) ||
+       (pData->iColortype == MNG_COLORTYPE_RGBA   )    ) &&
+      (pData->iBitdepth < 8                            )    )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+#if defined(FILTER192) || defined(FILTER193)
+  if ((pData->iFilter != MNG_FILTER_ADAPTIVE ) &&
+#if defined(FILTER192) && defined(FILTER193)
+      (pData->iFilter != MNG_FILTER_DIFFERING) &&
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#else
+#ifdef FILTER192
+      (pData->iFilter != MNG_FILTER_DIFFERING)    )
+#else
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#endif
+#endif
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#else
+  if (pData->iFilter)
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#endif
+
+  pData->iImagelevel++;                /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create an animation object */
+    mng_retcode iRetcode = mng_create_ani_basi (pData, pChunk);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (((mng_basip)pChunk)->iBitdepth > 8)
+    ((mng_basip)pChunk)->iBitdepth = 8;
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLON
+MNG_C_SPECIALFUNC (mng_special_clon)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_clon (pData, pChunk);
+#else
+  return MNG_NOERROR;                  /* done */
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+MNG_F_SPECIALFUNC (mng_debunk_past)
+{
+  mng_pastp        pPAST    = (mng_pastp)pChunk;
+  mng_uint32       iRawlen  = *piRawlen;
+  mng_uint8p       pRawdata = *ppRawdata;
+  mng_uint32       iSize;
+  mng_uint32       iX;
+  mng_past_sourcep pSource;
+                                       /* check the length */
+  if ((iRawlen < 41) || (((iRawlen - 11) % 30) != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pPAST->iDestid     = mng_get_uint16 (pRawdata);
+  pPAST->iTargettype = *(pRawdata+2);
+  pPAST->iTargetx    = mng_get_int32  (pRawdata+3);
+  pPAST->iTargety    = mng_get_int32  (pRawdata+7);
+  pPAST->iCount      = ((iRawlen - 11) / 30); /* how many entries again? */
+  iSize              = pPAST->iCount * sizeof (mng_past_source);
+
+  pRawdata += 11;
+                                       /* get a buffer for all the source blocks */
+  MNG_ALLOC (pData, pPAST->pSources, iSize);
+
+  pSource = (mng_past_sourcep)(pPAST->pSources);
+
+  for (iX = pPAST->iCount; iX > 0; iX--)
+  {                                    /* now copy the source blocks */
+    pSource->iSourceid     = mng_get_uint16 (pRawdata);
+    pSource->iComposition  = *(pRawdata+2);
+    pSource->iOrientation  = *(pRawdata+3);
+    pSource->iOffsettype   = *(pRawdata+4);
+    pSource->iOffsetx      = mng_get_int32 (pRawdata+5);
+    pSource->iOffsety      = mng_get_int32 (pRawdata+9);
+    pSource->iBoundarytype = *(pRawdata+13);
+    pSource->iBoundaryl    = mng_get_int32 (pRawdata+14);
+    pSource->iBoundaryr    = mng_get_int32 (pRawdata+18);
+    pSource->iBoundaryt    = mng_get_int32 (pRawdata+22);
+    pSource->iBoundaryb    = mng_get_int32 (pRawdata+26);
+
+    pSource++;
+    pRawdata += 30;
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+MNG_C_SPECIALFUNC (mng_special_past)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_past (pData, pChunk);
+#else
+  return MNG_NOERROR;
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+MNG_F_SPECIALFUNC (mng_disc_entries)
+{
+  mng_discp   pDISC    = (mng_discp)pChunk;
+  mng_uint32  iRawlen  = *piRawlen;
+  mng_uint8p  pRawdata = *ppRawdata;
+
+  if ((iRawlen % 2) != 0)              /* check the length */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pDISC->iCount = (iRawlen / sizeof (mng_uint16));
+
+  if (pDISC->iCount)
+  {
+    MNG_ALLOC (pData, pDISC->pObjectids, iRawlen);
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+    {
+      mng_uint32  iX;
+      mng_uint8p  pIn  = pRawdata;
+      mng_uint16p pOut = pDISC->pObjectids;
+
+      for (iX = pDISC->iCount; iX > 0; iX--)
+      {
+        *pOut++ = mng_get_uint16 (pIn);
+        pIn += 2;
+      }
+    }
+#else
+    MNG_COPY (pDISC->pObjectids, pRawdata, iRawlen);
+#endif /* !MNG_BIGENDIAN_SUPPORTED */
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+MNG_C_SPECIALFUNC (mng_special_disc)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_disc (pData, pChunk);
+#else
+  return MNG_NOERROR;                  
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BACK
+MNG_C_SPECIALFUNC (mng_special_back)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+                                       /* retrieve the fields */
+  pData->bHasBACK       = MNG_TRUE;
+  pData->iBACKred       = ((mng_backp)pChunk)->iRed;
+  pData->iBACKgreen     = ((mng_backp)pChunk)->iGreen;
+  pData->iBACKblue      = ((mng_backp)pChunk)->iBlue;
+  pData->iBACKmandatory = ((mng_backp)pChunk)->iMandatory;
+  pData->iBACKimageid   = ((mng_backp)pChunk)->iImageid;
+  pData->iBACKtile      = ((mng_backp)pChunk)->iTile;
+
+  return mng_create_ani_back (pData);
+#else
+  return MNG_NOERROR;
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+MNG_F_SPECIALFUNC (mng_fram_remainder)
+{
+  mng_framp  pFRAM     = (mng_framp)pChunk;
+  mng_uint32 iRawlen   = *piRawlen;
+  mng_uint8p pRawdata  = *ppRawdata;
+  mng_uint32 iRequired = 0;
+
+  if (iRawlen < 4)                     /* must have at least 4 bytes */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  iRequired = 4;                       /* calculate and check required remaining length */
+
+  pFRAM->iChangedelay    = *pRawdata;
+  pFRAM->iChangetimeout  = *(pRawdata+1);
+  pFRAM->iChangeclipping = *(pRawdata+2);
+  pFRAM->iChangesyncid   = *(pRawdata+3);
+
+  if (pFRAM->iChangedelay   ) { iRequired +=  4; }
+  if (pFRAM->iChangetimeout ) { iRequired +=  4; }
+  if (pFRAM->iChangeclipping) { iRequired += 17; }
+
+  if (pFRAM->iChangesyncid)
+  {
+    if ((iRawlen - iRequired) % 4 != 0)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+  {
+    if (iRawlen != iRequired)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+
+  pRawdata += 4;
+
+  if (pFRAM->iChangedelay)              /* delay changed ? */
+  {
+    pFRAM->iDelay = mng_get_uint32 (pRawdata);
+    pRawdata += 4;
+  }
+
+  if (pFRAM->iChangetimeout)            /* timeout changed ? */
+  {
+    pFRAM->iTimeout = mng_get_uint32 (pRawdata);
+    pRawdata += 4;
+  }
+
+  if (pFRAM->iChangeclipping)           /* clipping changed ? */
+  {
+    pFRAM->iBoundarytype = *pRawdata;
+    pFRAM->iBoundaryl    = mng_get_int32 (pRawdata+1);
+    pFRAM->iBoundaryr    = mng_get_int32 (pRawdata+5);
+    pFRAM->iBoundaryt    = mng_get_int32 (pRawdata+9);
+    pFRAM->iBoundaryb    = mng_get_int32 (pRawdata+13);
+    pRawdata += 17;
+  }
+
+  if (pFRAM->iChangesyncid)
+  {
+    pFRAM->iCount    = (iRawlen - iRequired) / 4;
+
+    if (pFRAM->iCount)
+    {
+      MNG_ALLOC (pData, pFRAM->pSyncids, pFRAM->iCount * 4);
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+      {
+        mng_uint32 iX;
+        mng_uint32p pOut = pFRAM->pSyncids;
+
+        for (iX = pFRAM->iCount; iX > 0; iX--)
+        {
+          *pOut++ = mng_get_uint32 (pRawdata);
+          pRawdata += 4;
+        }
+      }
+#else
+      MNG_COPY (pFRAM->pSyncids, pRawdata, pFRAM->iCount * 4);
+#endif /* !MNG_BIGENDIAN_SUPPORTED */
+    }
+  }
+
+#ifndef MNG_NO_OLD_VERSIONS
+  if (pData->bPreDraft48)              /* old style input-stream ? */
+  {
+    switch (pFRAM->iMode)              /* fix the framing mode then */
+    {
+      case  0: { break; }
+      case  1: { pFRAM->iMode = 3; break; }
+      case  2: { pFRAM->iMode = 4; break; }
+      case  3: { pFRAM->iMode = 1; break; }
+      case  4: { pFRAM->iMode = 1; break; }
+      case  5: { pFRAM->iMode = 2; break; }
+      default: { pFRAM->iMode = 1; break; }
+    }
+  }
+#endif
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+MNG_C_SPECIALFUNC (mng_special_fram)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_fram (pData, pChunk);
+#else
+  return MNG_NOERROR;
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MOVE
+MNG_C_SPECIALFUNC (mng_special_move)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_move (pData, pChunk);
+#else
+  return MNG_NOERROR;
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLIP
+MNG_C_SPECIALFUNC (mng_special_clip)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_clip (pData, pChunk);
+#else
+  return MNG_NOERROR;                  
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SHOW
+MNG_C_SPECIALFUNC (mng_special_show)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_retcode iRetcode;
+
+  if (!((mng_showp)pChunk)->bEmpty)    /* any data ? */
+  {
+    if (!((mng_showp)pChunk)->bHaslastid)
+      ((mng_showp)pChunk)->iLastid = ((mng_showp)pChunk)->iFirstid;
+
+    pData->iSHOWfromid = ((mng_showp)pChunk)->iFirstid;
+    pData->iSHOWtoid   = ((mng_showp)pChunk)->iLastid;
+    pData->iSHOWmode   = ((mng_showp)pChunk)->iMode;
+  }
+  else                                 /* use defaults then */
+  {
+    pData->iSHOWfromid = 1;
+    pData->iSHOWtoid   = 65535;
+    pData->iSHOWmode   = 2;
+  }
+                                       /* create a SHOW animation object */
+  iRetcode = mng_create_ani_show (pData);
+  if (!iRetcode)                       /* go and do it! */
+    iRetcode = mng_process_display_show (pData);
+
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_TERM
+MNG_C_SPECIALFUNC (mng_special_term)
+{
+                                       /* should be behind MHDR or SAVE !! */
+  if ((!pData->bHasSAVE) && (pData->iChunkseq > 2))
+  {
+    pData->bMisplacedTERM = MNG_TRUE;  /* indicate we found a misplaced TERM */
+                                       /* and send a warning signal!!! */
+    MNG_WARNING (pData, MNG_SEQUENCEERROR);
+  }
+
+  pData->bHasTERM = MNG_TRUE;
+
+  if (pData->fProcessterm)             /* inform the app ? */
+    if (!pData->fProcessterm (((mng_handle)pData),
+                              ((mng_termp)pChunk)->iTermaction,
+                              ((mng_termp)pChunk)->iIteraction,
+                              ((mng_termp)pChunk)->iDelay,
+                              ((mng_termp)pChunk)->iItermax))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create the TERM ani-object */
+    mng_retcode iRetcode = mng_create_ani_term (pData, pChunk);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* save for future reference */
+    pData->pTermaniobj = pData->pLastaniobj;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+MNG_F_SPECIALFUNC (mng_save_entries)
+{
+  mng_savep       pSAVE     = (mng_savep)pChunk;
+  mng_uint32      iRawlen   = *piRawlen;
+  mng_uint8p      pRawdata  = *ppRawdata;
+  mng_save_entryp pEntry    = MNG_NULL;
+  mng_uint32      iCount    = 0;
+  mng_uint8       iOtype    = *pRawdata;
+  mng_uint8       iEtype;
+  mng_uint8p      pTemp;
+  mng_uint8p      pNull;
+  mng_uint32      iLen;
+  mng_uint32      iOffset[2];
+  mng_uint32      iStarttime[2];
+  mng_uint32      iFramenr;
+  mng_uint32      iLayernr;
+  mng_uint32      iX;
+  mng_uint32      iNamesize;
+
+  if ((iOtype != 4) && (iOtype != 8))
+    MNG_ERROR (pData, MNG_INVOFFSETSIZE);
+
+  pSAVE->iOffsettype = iOtype;
+
+  for (iX = 0; iX < 2; iX++)       /* do this twice to get the count first ! */
+  {
+    pTemp = pRawdata + 1;
+    iLen  = iRawlen  - 1;
+
+    if (iX)                        /* second run ? */
+    {
+      MNG_ALLOC (pData, pEntry, (iCount * sizeof (mng_save_entry)));
+
+      pSAVE->iCount   = iCount;
+      pSAVE->pEntries = pEntry;
+    }
+
+    while (iLen)                   /* anything left ? */
+    {
+      iEtype = *pTemp;             /* entrytype */
+
+      if ((iEtype != 0) && (iEtype != 1) && (iEtype != 2) && (iEtype != 3))
+        MNG_ERROR (pData, MNG_INVENTRYTYPE);
+
+      pTemp++;
+
+      if (iEtype > 1)
+      {
+        iOffset    [0] = 0;
+        iOffset    [1] = 0;
+        iStarttime [0] = 0;
+        iStarttime [1] = 0;
+        iLayernr       = 0;
+        iFramenr       = 0;
+      }
+      else
+      {
+        if (iOtype == 4)
+        {
+          iOffset [0] = 0;
+          iOffset [1] = mng_get_uint32 (pTemp);
+
+          pTemp += 4;
+        }
+        else
+        {
+          iOffset [0] = mng_get_uint32 (pTemp);
+          iOffset [1] = mng_get_uint32 (pTemp+4);
+
+          pTemp += 8;
+        }
+
+        if (iEtype > 0)
+        {
+          iStarttime [0] = 0;
+          iStarttime [1] = 0;
+          iLayernr       = 0;
+          iFramenr       = 0;
+        }
+        else
+        {
+          if (iOtype == 4)
+          {
+            iStarttime [0] = 0;
+            iStarttime [1] = mng_get_uint32 (pTemp+0);
+            iLayernr       = mng_get_uint32 (pTemp+4);
+            iFramenr       = mng_get_uint32 (pTemp+8);
+
+            pTemp += 12;
+          }
+          else
+          {
+            iStarttime [0] = mng_get_uint32 (pTemp+0);
+            iStarttime [1] = mng_get_uint32 (pTemp+4);
+            iLayernr       = mng_get_uint32 (pTemp+8);
+            iFramenr       = mng_get_uint32 (pTemp+12);
+
+            pTemp += 16;
+          }
+        }
+      }
+
+      pNull = pTemp;               /* get the name length */
+      while (*pNull)
+        pNull++;
+
+      if ((pNull - pRawdata) > (mng_int32)iRawlen)
+      {
+        iNamesize = iLen;          /* no null found; so end of SAVE */
+        iLen      = 0;
+      }
+      else
+      {
+        iNamesize = pNull - pTemp; /* should be another entry */
+        iLen     -= iNamesize;
+
+        if (!iLen)                 /* must not end with a null ! */
+          MNG_ERROR (pData, MNG_ENDWITHNULL);
+      }
+
+      if (!pEntry)
+      {
+        iCount++;
+      }
+      else
+      {
+        pEntry->iEntrytype     = iEtype;
+        pEntry->iOffset    [0] = iOffset    [0];
+        pEntry->iOffset    [1] = iOffset    [1];
+        pEntry->iStarttime [0] = iStarttime [0];
+        pEntry->iStarttime [1] = iStarttime [1];
+        pEntry->iLayernr       = iLayernr;
+        pEntry->iFramenr       = iFramenr;
+        pEntry->iNamesize      = iNamesize;
+
+        if (iNamesize)
+        {
+          MNG_ALLOC (pData, pEntry->zName, iNamesize+1);
+          MNG_COPY (pEntry->zName, pTemp, iNamesize);
+        }
+
+        pEntry++;
+      }
+
+      pTemp += iNamesize;
+    }
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+MNG_C_SPECIALFUNC (mng_special_save)
+{
+  pData->bHasSAVE = MNG_TRUE;
+
+  if (pData->fProcesssave)             /* inform the application ? */
+  {
+    mng_bool bOke = pData->fProcesssave ((mng_handle)pData);
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+
+    /* TODO: something with the parameters */
+
+                                       /* create a SAVE animation object */
+    iRetcode = mng_create_ani_save (pData);
+    if (!iRetcode)                     /* process it */
+      iRetcode = mng_process_display_save (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+MNG_C_SPECIALFUNC (mng_special_seek)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_DISPLAY
+                                       /* create a SEEK animation object */
+  iRetcode = mng_create_ani_seek (pData, pChunk);
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  if (pData->fProcessseek)             /* inform the app ? */
+    if (!pData->fProcessseek ((mng_handle)pData, ((mng_seekp)pChunk)->zName))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_process_display_seek (pData);
+#else
+  return MNG_NOERROR;                  
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+MNG_C_SPECIALFUNC (mng_special_expi)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_fPRI
+MNG_C_SPECIALFUNC (mng_special_fpri)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+MNG_LOCAL mng_bool CheckKeyword (mng_datap  pData,
+                                 mng_uint8p pKeyword)
+{
+  mng_chunkid handled_chunks [] =
+  {
+    MNG_UINT_BACK,                     /* keep it sorted !!!! */
+    MNG_UINT_BASI,
+    MNG_UINT_CLIP,
+    MNG_UINT_CLON,
+#ifndef MNG_NO_DELTA_PNG
+/* TODO:    MNG_UINT_DBYK,  */
+#endif
+    MNG_UINT_DEFI,
+#ifndef MNG_NO_DELTA_PNG
+    MNG_UINT_DHDR,
+#endif
+    MNG_UINT_DISC,
+#ifndef MNG_NO_DELTA_PNG
+/* TODO:    MNG_UINT_DROP,  */
+#endif
+    MNG_UINT_ENDL,
+    MNG_UINT_FRAM,
+    MNG_UINT_IDAT,
+    MNG_UINT_IEND,
+    MNG_UINT_IHDR,
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+    MNG_UINT_IJNG,
+#endif    
+    MNG_UINT_IPNG,
+#endif
+#ifdef MNG_INCLUDE_JNG
+    MNG_UINT_JDAA,
+    MNG_UINT_JDAT,
+    MNG_UINT_JHDR,
+/* TODO:    MNG_UINT_JSEP,  */
+    MNG_UINT_JdAA,
+#endif
+    MNG_UINT_LOOP,
+    MNG_UINT_MAGN,
+    MNG_UINT_MEND,
+    MNG_UINT_MHDR,
+    MNG_UINT_MOVE,
+/* TODO:    MNG_UINT_ORDR,  */
+    MNG_UINT_PAST,
+    MNG_UINT_PLTE,
+#ifndef MNG_NO_DELTA_PNG
+    MNG_UINT_PPLT,
+    MNG_UINT_PROM,
+#endif
+    MNG_UINT_SAVE,
+    MNG_UINT_SEEK,
+    MNG_UINT_SHOW,
+    MNG_UINT_TERM,
+    MNG_UINT_bKGD,
+    MNG_UINT_cHRM,
+/* TODO:    MNG_UINT_eXPI,  */
+    MNG_UINT_evNT,
+/* TODO:    MNG_UINT_fPRI,  */
+    MNG_UINT_gAMA,
+/* TODO:    MNG_UINT_hIST,  */
+    MNG_UINT_iCCP,
+    MNG_UINT_iTXt,
+    MNG_UINT_nEED,
+/* TODO:    MNG_UINT_oFFs,  */
+/* TODO:    MNG_UINT_pCAL,  */
+/* TODO:    MNG_UINT_pHYg,  */
+/* TODO:    MNG_UINT_pHYs,  */
+/* TODO:    MNG_UINT_sBIT,  */
+/* TODO:    MNG_UINT_sCAL,  */
+/* TODO:    MNG_UINT_sPLT,  */
+    MNG_UINT_sRGB,
+    MNG_UINT_tEXt,
+    MNG_UINT_tIME,
+    MNG_UINT_tRNS,
+    MNG_UINT_zTXt,
+  };
+
+  mng_bool bOke = MNG_FALSE;
+
+  if (pData->fProcessneed)             /* does the app handle it ? */
+    bOke = pData->fProcessneed ((mng_handle)pData, (mng_pchar)pKeyword);
+
+  if (!bOke)
+  {                                    /* find the keyword length */
+    mng_uint8p pNull = pKeyword;
+    while (*pNull)
+      pNull++;
+
+    if ((pNull - pKeyword) == 4)       /* test a chunk ? */
+    {                                  /* get the chunk-id */
+      mng_chunkid iChunkid = (*pKeyword     << 24) + (*(pKeyword+1) << 16) +
+                             (*(pKeyword+2) <<  8) + (*(pKeyword+3)      );
+                                       /* binary search variables */
+      mng_int32   iTop, iLower, iUpper, iMiddle;
+                                       /* determine max index of table */
+      iTop = (sizeof (handled_chunks) / sizeof (handled_chunks [0])) - 1;
+
+      /* binary search; with 52 chunks, worst-case is 7 comparisons */
+      iLower  = 0;
+      iMiddle = iTop >> 1;
+      iUpper  = iTop;
+
+      do                                   /* the binary search itself */
+        {
+          if (handled_chunks [iMiddle] < iChunkid)
+            iLower = iMiddle + 1;
+          else if (handled_chunks [iMiddle] > iChunkid)
+            iUpper = iMiddle - 1;
+          else
+          {
+            bOke = MNG_TRUE;
+            break;
+          }
+
+          iMiddle = (iLower + iUpper) >> 1;
+        }
+      while (iLower <= iUpper);
+    }
+                                       /* test draft ? */
+    if ((!bOke) && ((pNull - pKeyword) == 8) &&
+        (*pKeyword     == 'd') && (*(pKeyword+1) == 'r') &&
+        (*(pKeyword+2) == 'a') && (*(pKeyword+3) == 'f') &&
+        (*(pKeyword+4) == 't') && (*(pKeyword+5) == ' '))
+    {
+      mng_uint32 iDraft;
+
+      iDraft = (*(pKeyword+6) - '0') * 10 + (*(pKeyword+7) - '0');
+      bOke   = (mng_bool)(iDraft <= MNG_MNG_DRAFT);
+    }
+                                       /* test MNG 1.0/1.1 ? */
+    if ((!bOke) && ((pNull - pKeyword) == 7) &&
+        (*pKeyword     == 'M') && (*(pKeyword+1) == 'N') &&
+        (*(pKeyword+2) == 'G') && (*(pKeyword+3) == '-') &&
+        (*(pKeyword+4) == '1') && (*(pKeyword+5) == '.') &&
+        ((*(pKeyword+6) == '0') || (*(pKeyword+6) == '1')))
+      bOke   = MNG_TRUE;
+                                       /* test CACHEOFF ? */
+    if ((!bOke) && ((pNull - pKeyword) == 8) &&
+        (*pKeyword     == 'C') && (*(pKeyword+1) == 'A') &&
+        (*(pKeyword+2) == 'C') && (*(pKeyword+3) == 'H') &&
+        (*(pKeyword+4) == 'E') && (*(pKeyword+5) == 'O') &&
+        (*(pKeyword+6) == 'F') && (*(pKeyword+7) == 'F'))
+    {
+      if (!pData->pFirstaniobj)        /* only if caching hasn't started yet ! */
+      {
+        bOke                  = MNG_TRUE;
+        pData->bCacheplayback = MNG_FALSE;
+        pData->bStorechunks   = MNG_FALSE;
+      }
+    }
+  }
+
+  return bOke;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+MNG_C_SPECIALFUNC (mng_special_need)
+{
+                                       /* let's check it */
+  mng_bool   bOke = MNG_TRUE;
+  mng_uint8p pNull, pTemp, pMax;
+
+  pTemp = (mng_uint8p)((mng_needp)pChunk)->zKeywords;
+  pMax  = (mng_uint8p)(pTemp + ((mng_needp)pChunk)->iKeywordssize);
+  pNull = pTemp;
+  while (*pNull)
+    pNull++;
+
+  while ((bOke) && (pNull < pMax))
+  {
+    bOke  = CheckKeyword (pData, pTemp);
+    pTemp = pNull + 1;
+    pNull = pTemp;
+    while (*pNull)
+      pNull++;
+  }
+
+  if (bOke)
+    bOke = CheckKeyword (pData, pTemp);
+
+  if (!bOke)
+    MNG_ERROR (pData, MNG_UNSUPPORTEDNEED);
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYg
+MNG_C_SPECIALFUNC (mng_special_phyg)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_C_SPECIALFUNC (mng_special_dhdr)
+{
+  if ((((mng_dhdrp)pChunk)->iDeltatype == MNG_DELTATYPE_REPLACE) && (((mng_dhdrp)pChunk)->bHasblockloc))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  if ((((mng_dhdrp)pChunk)->iDeltatype == MNG_DELTATYPE_NOCHANGE) && (((mng_dhdrp)pChunk)->bHasblocksize))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasDHDR   = MNG_TRUE;        /* inside a DHDR-IEND block now */
+  pData->iDeltatype = ((mng_dhdrp)pChunk)->iDeltatype;
+
+  pData->iImagelevel++;                /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_dhdr (pData, pChunk);
+#else
+  return MNG_NOERROR;                  
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_C_SPECIALFUNC (mng_special_prom)
+{
+  if ((((mng_promp)pChunk)->iColortype != MNG_COLORTYPE_GRAY   ) &&
+      (((mng_promp)pChunk)->iColortype != MNG_COLORTYPE_RGB    ) &&
+      (((mng_promp)pChunk)->iColortype != MNG_COLORTYPE_INDEXED) &&
+      (((mng_promp)pChunk)->iColortype != MNG_COLORTYPE_GRAYA  ) &&
+      (((mng_promp)pChunk)->iColortype != MNG_COLORTYPE_RGBA   )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (((mng_promp)pChunk)->iSampledepth == MNG_BITDEPTH_16 )
+      ((mng_promp)pChunk)->iSampledepth = MNG_BITDEPTH_8;
+#endif
+
+  if ((((mng_promp)pChunk)->iSampledepth != MNG_BITDEPTH_1 ) &&
+      (((mng_promp)pChunk)->iSampledepth != MNG_BITDEPTH_2 ) &&
+      (((mng_promp)pChunk)->iSampledepth != MNG_BITDEPTH_4 ) &&
+      (((mng_promp)pChunk)->iSampledepth != MNG_BITDEPTH_8 )
+#ifndef MNG_NO_16BIT_SUPPORT
+      && (((mng_promp)pChunk)->iSampledepth != MNG_BITDEPTH_16)
+#endif
+    )
+    MNG_ERROR (pData, MNG_INVSAMPLEDEPTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode = mng_create_ani_prom (pData, pChunk);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_C_SPECIALFUNC (mng_special_ipng)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_retcode iRetcode = mng_create_ani_ipng (pData);
+  if (!iRetcode)                       /* process it */
+    iRetcode = mng_process_display_ipng (pData);
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_F_SPECIALFUNC (mng_pplt_entries)
+{
+  mng_ppltp     pPPLT      = (mng_ppltp)pChunk;
+  mng_uint32    iRawlen    = *piRawlen;
+  mng_uint8p    pRawdata   = *ppRawdata;
+  mng_uint8     iDeltatype = pPPLT->iDeltatype;
+  mng_uint32    iMax       = 0;
+  mng_int32     iX, iY, iM;
+  mng_rgbpaltab aIndexentries;
+  mng_uint8arr  aAlphaentries;
+  mng_uint8arr  aUsedentries;
+                                       /* must be indexed color ! */
+  if (pData->iColortype != MNG_COLORTYPE_INDEXED)
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  for (iY = 255; iY >= 0; iY--)        /* reset arrays */
+  {
+    aIndexentries [iY].iRed   = 0;
+    aIndexentries [iY].iGreen = 0;
+    aIndexentries [iY].iBlue  = 0;
+    aAlphaentries [iY]        = 255;
+    aUsedentries  [iY]        = 0;
+  }
+
+  while (iRawlen)                      /* as long as there are entries left ... */
+  {
+    mng_uint32 iDiff;
+
+    if (iRawlen < 2)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    iX = (mng_int32)(*pRawdata);      /* get start and end index */
+    iM = (mng_int32)(*(pRawdata+1));
+
+    if (iM < iX)
+      MNG_ERROR (pData, MNG_INVALIDINDEX);
+
+    if (iM >= (mng_int32) iMax)       /* determine highest used index */
+      iMax = iM + 1;
+
+    pRawdata += 2;
+    iRawlen  -= 2;
+    iDiff = (iM - iX + 1);
+    if ((iDeltatype == MNG_DELTATYPE_REPLACERGB  ) ||
+        (iDeltatype == MNG_DELTATYPE_DELTARGB    )    )
+      iDiff = iDiff * 3;
+    else
+    if ((iDeltatype == MNG_DELTATYPE_REPLACERGBA) ||
+        (iDeltatype == MNG_DELTATYPE_DELTARGBA  )    )
+      iDiff = iDiff * 4;
+
+    if (iRawlen < iDiff)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((iDeltatype == MNG_DELTATYPE_REPLACERGB  ) ||
+        (iDeltatype == MNG_DELTATYPE_DELTARGB    )    )
+    {
+      for (iY = iX; iY <= iM; iY++)
+      {
+        aIndexentries [iY].iRed   = *pRawdata;
+        aIndexentries [iY].iGreen = *(pRawdata+1);
+        aIndexentries [iY].iBlue  = *(pRawdata+2);
+        aUsedentries  [iY]        = 1;
+
+        pRawdata += 3;
+        iRawlen  -= 3;
+      }
+    }
+    else
+    if ((iDeltatype == MNG_DELTATYPE_REPLACEALPHA) ||
+        (iDeltatype == MNG_DELTATYPE_DELTAALPHA  )    )
+    {
+      for (iY = iX; iY <= iM; iY++)
+      {
+        aAlphaentries [iY]        = *pRawdata;
+        aUsedentries  [iY]        = 1;
+
+        pRawdata++;
+        iRawlen--;
+      }
+    }
+    else
+    {
+      for (iY = iX; iY <= iM; iY++)
+      {
+        aIndexentries [iY].iRed   = *pRawdata;
+        aIndexentries [iY].iGreen = *(pRawdata+1);
+        aIndexentries [iY].iBlue  = *(pRawdata+2);
+        aAlphaentries [iY]        = *(pRawdata+3);
+        aUsedentries  [iY]        = 1;
+
+        pRawdata += 4;
+        iRawlen  -= 4;
+      }
+    }
+  }
+
+  switch (pData->iBitdepth)            /* check maximum allowed entries for bitdepth */
+  {
+    case MNG_BITDEPTH_1 : {
+                            if (iMax > 2)
+                              MNG_ERROR (pData, MNG_INVALIDINDEX);
+                            break;
+                          }
+    case MNG_BITDEPTH_2 : {
+                            if (iMax > 4)
+                              MNG_ERROR (pData, MNG_INVALIDINDEX);
+                            break;
+                          }
+    case MNG_BITDEPTH_4 : {
+                            if (iMax > 16)
+                              MNG_ERROR (pData, MNG_INVALIDINDEX);
+                            break;
+                          }
+  }
+
+  pPPLT->iCount = iMax;
+
+  for (iY = 255; iY >= 0; iY--)        
+  {
+    pPPLT->aEntries [iY].iRed   = aIndexentries [iY].iRed;
+    pPPLT->aEntries [iY].iGreen = aIndexentries [iY].iGreen;
+    pPPLT->aEntries [iY].iBlue  = aIndexentries [iY].iBlue;
+    pPPLT->aEntries [iY].iAlpha = aAlphaentries [iY];
+    pPPLT->aEntries [iY].bUsed  = (mng_bool)(aUsedentries [iY]);
+  }
+
+  {                                    /* create animation object */
+    mng_retcode iRetcode = mng_create_ani_pplt (pData, iDeltatype, iMax,
+                                                aIndexentries, aAlphaentries,
+                                                aUsedentries);
+    if (iRetcode)
+      return iRetcode;
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_C_SPECIALFUNC (mng_special_pplt)
+{
+  return MNG_NOERROR;                 
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+MNG_C_SPECIALFUNC (mng_special_ijng)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_retcode iRetcode = mng_create_ani_ijng (pData);
+  if (!iRetcode)                       /* process it */
+    iRetcode = mng_process_display_ijng (pData);
+  return iRetcode;
+#else
+  return MNG_NOERROR;                  /* done */
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_F_SPECIALFUNC (mng_drop_entries)
+{
+  mng_dropp   pDROP    = (mng_dropp)pChunk;
+  mng_uint32  iRawlen  = *piRawlen;
+  mng_uint8p  pRawdata = *ppRawdata;
+  mng_uint32  iX;
+  mng_uint32p pEntry;
+                                       /* check length */
+  if ((iRawlen < 4) || ((iRawlen % 4) != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  MNG_ALLOC (pData, pEntry, iRawlen);
+  pDROP->iCount      = iRawlen / 4;
+  pDROP->pChunknames = (mng_ptr)pEntry;
+
+  for (iX = pDROP->iCount; iX > 0; iX--)
+  {
+    *pEntry++ = mng_get_uint32 (pRawdata);
+    pRawdata += 4;
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+MNG_C_SPECIALFUNC (mng_special_drop)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+MNG_C_SPECIALFUNC (mng_special_dbyk)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+MNG_F_SPECIALFUNC (mng_ordr_entries)
+{
+  mng_ordrp       pORDR    = (mng_ordrp)pChunk;
+  mng_uint32      iRawlen  = *piRawlen;
+  mng_uint8p      pRawdata = *ppRawdata;
+  mng_uint32      iX;
+  mng_ordr_entryp pEntry;
+                                       /* check length */
+  if ((iRawlen < 5) || ((iRawlen % 5) != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  MNG_ALLOC (pData, pEntry, iRawlen);
+  pORDR->iCount   = iRawlen / 5;
+  pORDR->pEntries = (mng_ptr)pEntry;
+
+  for (iX = pORDR->iCount; iX > 0; iX--)
+  {
+    pEntry->iChunkname = mng_get_uint32 (pRawdata);
+    pEntry->iOrdertype = *(pRawdata+4);
+    pEntry++;
+    pRawdata += 5;
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+MNG_C_SPECIALFUNC (mng_special_ordr)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+MNG_F_SPECIALFUNC (mng_debunk_magn)
+{
+  mng_magnp  pMAGN    = (mng_magnp)pChunk;
+  mng_uint32 iRawlen  = *piRawlen;
+  mng_uint8p pRawdata = *ppRawdata;
+  mng_bool   bFaulty;
+                                       /* check length */
+  if (iRawlen > 20)
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  /* following is an ugly hack to allow faulty layout caused by previous
+     versions of libmng and MNGeye, which wrote MAGN with a 16-bit
+     MethodX/MethodY (as opposed to the proper 8-bit as defined in the spec!) */
+
+  if ((iRawlen ==  6) || (iRawlen ==  8) || (iRawlen == 10) || (iRawlen == 12) ||
+      (iRawlen == 14) || (iRawlen == 16) || (iRawlen == 20))
+    bFaulty = MNG_TRUE;                /* these lengths are all wrong */
+  else                                 /* length 18 can be right or wrong !!! */
+  if ((iRawlen ==  18) && (mng_get_uint16 (pRawdata+4) <= 5) &&
+      (mng_get_uint16 (pRawdata+6)  < 256) &&
+      (mng_get_uint16 (pRawdata+8)  < 256) &&
+      (mng_get_uint16 (pRawdata+10) < 256) &&
+      (mng_get_uint16 (pRawdata+12) < 256) &&
+      (mng_get_uint16 (pRawdata+14) < 256) &&
+      (mng_get_uint16 (pRawdata+16) < 256))
+    bFaulty = MNG_TRUE;                /* this is very likely the wrong layout */
+  else
+    bFaulty = MNG_FALSE;               /* all other cases are handled as right */
+
+  if (bFaulty)                         /* wrong layout ? */
+  {
+    if (iRawlen > 0)                   /* get the fields */
+      pMAGN->iFirstid = mng_get_uint16 (pRawdata);
+    else
+      pMAGN->iFirstid = 0;
+
+    if (iRawlen > 2)
+      pMAGN->iLastid  = mng_get_uint16 (pRawdata+2);
+    else
+      pMAGN->iLastid  = pMAGN->iFirstid;
+
+    if (iRawlen > 4)
+      pMAGN->iMethodX = (mng_uint8)(mng_get_uint16 (pRawdata+4));
+    else
+      pMAGN->iMethodX = 0;
+
+    if (iRawlen > 6)
+      pMAGN->iMX      = mng_get_uint16 (pRawdata+6);
+    else
+      pMAGN->iMX      = 1;
+
+    if (iRawlen > 8)
+      pMAGN->iMY      = mng_get_uint16 (pRawdata+8);
+    else
+      pMAGN->iMY      = pMAGN->iMX;
+
+    if (iRawlen > 10)
+      pMAGN->iML      = mng_get_uint16 (pRawdata+10);
+    else
+      pMAGN->iML      = pMAGN->iMX;
+
+    if (iRawlen > 12)
+      pMAGN->iMR      = mng_get_uint16 (pRawdata+12);
+    else
+      pMAGN->iMR      = pMAGN->iMX;
+
+    if (iRawlen > 14)
+      pMAGN->iMT      = mng_get_uint16 (pRawdata+14);
+    else
+      pMAGN->iMT      = pMAGN->iMY;
+
+    if (iRawlen > 16)
+      pMAGN->iMB      = mng_get_uint16 (pRawdata+16);
+    else
+      pMAGN->iMB      = pMAGN->iMY;
+
+    if (iRawlen > 18)
+      pMAGN->iMethodY = (mng_uint8)(mng_get_uint16 (pRawdata+18));
+    else
+      pMAGN->iMethodY = pMAGN->iMethodX;
+  }
+  else                                 /* proper layout !!!! */
+  {
+    if (iRawlen > 0)                   /* get the fields */
+      pMAGN->iFirstid = mng_get_uint16 (pRawdata);
+    else
+      pMAGN->iFirstid = 0;
+
+    if (iRawlen > 2)
+      pMAGN->iLastid  = mng_get_uint16 (pRawdata+2);
+    else
+      pMAGN->iLastid  = pMAGN->iFirstid;
+
+    if (iRawlen > 4)
+      pMAGN->iMethodX = *(pRawdata+4);
+    else
+      pMAGN->iMethodX = 0;
+
+    if (iRawlen > 5)
+      pMAGN->iMX      = mng_get_uint16 (pRawdata+5);
+    else
+      pMAGN->iMX      = 1;
+
+    if (iRawlen > 7)
+      pMAGN->iMY      = mng_get_uint16 (pRawdata+7);
+    else
+      pMAGN->iMY      = pMAGN->iMX;
+
+    if (iRawlen > 9)
+      pMAGN->iML      = mng_get_uint16 (pRawdata+9);
+    else
+      pMAGN->iML      = pMAGN->iMX;
+
+    if (iRawlen > 11)
+      pMAGN->iMR      = mng_get_uint16 (pRawdata+11);
+    else
+      pMAGN->iMR      = pMAGN->iMX;
+
+    if (iRawlen > 13)
+      pMAGN->iMT      = mng_get_uint16 (pRawdata+13);
+    else
+      pMAGN->iMT      = pMAGN->iMY;
+
+    if (iRawlen > 15)
+      pMAGN->iMB      = mng_get_uint16 (pRawdata+15);
+    else
+      pMAGN->iMB      = pMAGN->iMY;
+
+    if (iRawlen > 17)
+      pMAGN->iMethodY = *(pRawdata+17);
+    else
+      pMAGN->iMethodY = pMAGN->iMethodX;
+  }
+                                       /* check field validity */
+  if ((pMAGN->iMethodX > 5) || (pMAGN->iMethodY > 5))
+    MNG_ERROR (pData, MNG_INVALIDMETHOD);
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+MNG_C_SPECIALFUNC (mng_special_magn)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ani_magn (pData, pChunk);
+#else
+  return MNG_NOERROR;                  
+#endif /* MNG_SUPPORT_DISPLAY */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+MNG_F_SPECIALFUNC (mng_evnt_entries)
+{
+  mng_evntp       pEVNT = (mng_evntp)pChunk;
+  mng_uint32      iRawlen;
+  mng_uint8p      pRawdata;
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_SUPPORT_DYNAMICMNG)
+  mng_retcode     iRetcode;
+#endif
+  mng_uint8p      pNull;
+  mng_uint8       iEventtype;
+  mng_uint8       iMasktype;
+  mng_int32       iLeft;
+  mng_int32       iRight;
+  mng_int32       iTop;
+  mng_int32       iBottom;
+  mng_uint16      iObjectid;
+  mng_uint8       iIndex;
+  mng_uint32      iNamesize;
+  mng_uint32      iCount = 0;
+  mng_evnt_entryp pEntry = MNG_NULL;
+  mng_uint32      iX;
+
+  for (iX = 0; iX < 2; iX++)
+  {
+    iRawlen  = *piRawlen;
+    pRawdata = *ppRawdata;
+
+    if (iX)                            /* second run ? */
+    {
+      MNG_ALLOC (pData, pEntry, (iCount * sizeof (mng_evnt_entry)));
+      pEVNT->iCount   = iCount;
+      pEVNT->pEntries = pEntry;
+    }
+
+    while (iRawlen)                    /* anything left ? */
+    {
+      if (iRawlen < 2)                 /* must have at least 2 bytes ! */
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+      iEventtype = *pRawdata;          /* eventtype */
+      if (iEventtype > 5)
+        MNG_ERROR (pData, MNG_INVALIDEVENT);
+
+      pRawdata++;
+
+      iMasktype  = *pRawdata;          /* masktype */
+      if (iMasktype > 5)
+        MNG_ERROR (pData, MNG_INVALIDMASK);
+
+      pRawdata++;
+      iRawlen -= 2;
+
+      iLeft     = 0;
+      iRight    = 0;
+      iTop      = 0;
+      iBottom   = 0;
+      iObjectid = 0;
+      iIndex    = 0;
+
+      switch (iMasktype)
+      {
+        case 1 :
+          {
+            if (iRawlen > 16)
+            {
+              iLeft     = mng_get_int32 (pRawdata);
+              iRight    = mng_get_int32 (pRawdata+4);
+              iTop      = mng_get_int32 (pRawdata+8);
+              iBottom   = mng_get_int32 (pRawdata+12);
+              pRawdata += 16;
+              iRawlen -= 16;
+            }
+            else
+              MNG_ERROR (pData, MNG_INVALIDLENGTH);
+            break;
+          }
+        case 2 :
+          {
+            if (iRawlen > 2)
+            {
+              iObjectid = mng_get_uint16 (pRawdata);
+              pRawdata += 2;
+              iRawlen -= 2;
+            }
+            else
+              MNG_ERROR (pData, MNG_INVALIDLENGTH);
+            break;
+          }
+        case 3 :
+          {
+            if (iRawlen > 3)
+            {
+              iObjectid = mng_get_uint16 (pRawdata);
+              iIndex    = *(pRawdata+2);
+              pRawdata += 3;
+              iRawlen -= 3;
+            }
+            else
+              MNG_ERROR (pData, MNG_INVALIDLENGTH);
+            break;
+          }
+        case 4 :
+          {
+            if (iRawlen > 18)
+            {
+              iLeft     = mng_get_int32 (pRawdata);
+              iRight    = mng_get_int32 (pRawdata+4);
+              iTop      = mng_get_int32 (pRawdata+8);
+              iBottom   = mng_get_int32 (pRawdata+12);
+              iObjectid = mng_get_uint16 (pRawdata+16);
+              pRawdata += 18;
+              iRawlen -= 18;
+            }
+            else
+              MNG_ERROR (pData, MNG_INVALIDLENGTH);
+            break;
+          }
+        case 5 :
+          {
+            if (iRawlen > 19)
+            {
+              iLeft     = mng_get_int32 (pRawdata);
+              iRight    = mng_get_int32 (pRawdata+4);
+              iTop      = mng_get_int32 (pRawdata+8);
+              iBottom   = mng_get_int32 (pRawdata+12);
+              iObjectid = mng_get_uint16 (pRawdata+16);
+              iIndex    = *(pRawdata+18);
+              pRawdata += 19;
+              iRawlen -= 19;
+            }
+            else
+              MNG_ERROR (pData, MNG_INVALIDLENGTH);
+            break;
+          }
+      }
+
+      pNull = pRawdata;                /* get the name length */
+      while (*pNull)
+        pNull++;
+
+      if ((pNull - pRawdata) > (mng_int32)iRawlen)
+      {
+        iNamesize = iRawlen;           /* no null found; so end of evNT */
+        iRawlen   = 0;
+      }
+      else
+      {
+        iNamesize = pNull - pRawdata;  /* should be another entry */
+        iRawlen   = iRawlen - iNamesize - 1;
+
+        if (!iRawlen)                  /* must not end with a null ! */
+          MNG_ERROR (pData, MNG_ENDWITHNULL);
+      }
+
+      if (!iX)
+      {
+        iCount++;
+      }
+      else
+      {
+        pEntry->iEventtype       = iEventtype;
+        pEntry->iMasktype        = iMasktype;
+        pEntry->iLeft            = iLeft;
+        pEntry->iRight           = iRight;
+        pEntry->iTop             = iTop;
+        pEntry->iBottom          = iBottom;
+        pEntry->iObjectid        = iObjectid;
+        pEntry->iIndex           = iIndex;
+        pEntry->iSegmentnamesize = iNamesize;
+
+        if (iNamesize)
+        {
+          MNG_ALLOC (pData, pEntry->zSegmentname, iNamesize+1);
+          MNG_COPY (pEntry->zSegmentname, pRawdata, iNamesize);
+        }
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_SUPPORT_DYNAMICMNG)
+        iRetcode = mng_create_event (pData, (mng_ptr)pEntry);
+        if (iRetcode)                    /* on error bail out */
+          return iRetcode;
+#endif
+
+        pEntry++;
+      }
+
+      pRawdata = pRawdata + iNamesize + 1;
+    }
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+MNG_C_SPECIALFUNC (mng_special_evnt)
+{
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_C_SPECIALFUNC (mng_special_mpng)
+{
+  if ((pData->eImagetype != mng_it_png) && (pData->eImagetype != mng_it_jng))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+    
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_mpng_obj (pData, pChunk);
+#else
+  return MNG_NOERROR;
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+MNG_C_SPECIALFUNC (mng_special_ahdr)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  return mng_create_ang_obj (pData, pChunk);
+#else
+  return MNG_NOERROR;
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+MNG_F_SPECIALFUNC (mng_adat_tiles)
+{
+  if ((pData->eImagetype != mng_it_ang) || (!pData->pANG))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+
+  {
+    mng_adatp      pADAT = (mng_adatp)pChunk;
+    mng_ang_objp   pANG  = (mng_ang_objp)pData->pANG;
+    mng_uint32     iRawlen  = *piRawlen;
+    mng_uint8p     pRawdata = *ppRawdata;
+    mng_retcode    iRetcode;
+    mng_uint8p     pBuf;
+    mng_uint32     iBufsize;
+    mng_uint32     iRealsize;
+    mng_uint8p     pTemp;
+    mng_uint8p     pTemp2;
+    mng_int32      iX;
+    mng_int32      iSize;
+
+#ifdef MNG_SUPPORT_DISPLAY
+    mng_imagep     pImage;
+    mng_int32      iTemplen;
+    mng_uint8p     pSwap;
+
+    mng_processobject pProcess;
+
+    mng_uint32     iSavedatawidth;
+    mng_uint32     iSavedataheight;
+
+    mng_fptr       fSaveinitrowproc;
+    mng_fptr       fSavestorerow;
+    mng_fptr       fSaveprocessrow;
+    mng_fptr       fSavedifferrow;
+    mng_imagep     fSavestoreobj;
+    mng_imagedatap fSavestorebuf;
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+    png_imgtype    eSavepngimgtype;
+#endif
+
+    mng_uint8      iSaveinterlace;
+    mng_int8       iSavepass;
+    mng_int32      iSaverow;
+    mng_int32      iSaverowinc;
+    mng_int32      iSavecol;
+    mng_int32      iSavecolinc;
+    mng_int32      iSaverowsamples;
+    mng_int32      iSavesamplemul;
+    mng_int32      iSavesampleofs;
+    mng_int32      iSavesamplediv;
+    mng_int32      iSaverowsize;
+    mng_int32      iSaverowmax;
+    mng_int32      iSavefilterofs;
+    mng_int32      iSavepixelofs;
+    mng_uint32     iSavelevel0;
+    mng_uint32     iSavelevel1;
+    mng_uint32     iSavelevel2;
+    mng_uint32     iSavelevel3;
+    mng_uint8p     pSaveworkrow;
+    mng_uint8p     pSaveprevrow;
+    mng_uint8p     pSaverGBArow;
+    mng_bool       bSaveisRGBA16;
+    mng_bool       bSaveisOpaque;
+    mng_int32      iSavefilterbpp;
+
+    mng_int32      iSavedestl;
+    mng_int32      iSavedestt;
+    mng_int32      iSavedestr;
+    mng_int32      iSavedestb;
+    mng_int32      iSavesourcel;
+    mng_int32      iSavesourcet;
+    mng_int32      iSavesourcer;
+    mng_int32      iSavesourceb;
+#endif /* MNG_SUPPORT_DISPLAY */
+
+    iRetcode = mng_inflate_buffer (pData, pRawdata, iRawlen,
+                                   &pBuf, &iBufsize, &iRealsize);
+    if (iRetcode)                      /* on error bail out */
+    {                                  /* don't forget to drop the temp buffer */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+                                       /* get buffer for tile info in ADAT chunk */
+    pADAT->iTilessize = pANG->iNumframes * sizeof(mng_adat_tile);
+    MNG_ALLOCX (pData, pADAT->pTiles, pADAT->iTilessize);
+    if (!pADAT->pTiles)
+    {
+      pADAT->iTilessize = 0;
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+
+    pTemp  = pBuf;
+    pTemp2 = (mng_uint8p)pADAT->pTiles;
+
+    if (!pANG->iStillused)
+      iSize = 12;
+    else
+      iSize = 13;
+
+    for (iX = 0; iX < pANG->iNumframes; iX++)
+    {
+      MNG_COPY (pTemp2, pTemp, iSize);
+      pTemp  += iSize;
+      pTemp2 += sizeof(mng_adat_tile);
+    }
+
+#ifdef MNG_SUPPORT_DISPLAY
+                                       /* get buffer for tile info in ANG object */
+    pANG->iTilessize = pADAT->iTilessize;
+    MNG_ALLOCX (pData, pANG->pTiles, pANG->iTilessize);
+    if (!pANG->pTiles)
+    {
+      pANG->iTilessize = 0;
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+                                       /* copy it from the ADAT object */
+    MNG_COPY (pANG->pTiles, pADAT->pTiles, pANG->iTilessize);
+
+                                       /* save IDAT work-parms */
+    fSaveinitrowproc    = pData->fInitrowproc;
+    fSavestorerow       = pData->fDisplayrow;
+    fSaveprocessrow     = pData->fProcessrow;
+    fSavedifferrow      = pData->fDifferrow;
+    fSavestoreobj       = pData->pStoreobj;
+    fSavestorebuf       = pData->pStorebuf;
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+    eSavepngimgtype     = pData->ePng_imgtype;
+#endif
+
+    iSavedatawidth      = pData->iDatawidth;
+    iSavedataheight     = pData->iDataheight;
+    iSaveinterlace      = pData->iInterlace;
+    iSavepass           = pData->iPass;
+    iSaverow            = pData->iRow;
+    iSaverowinc         = pData->iRowinc;
+    iSavecol            = pData->iCol;
+    iSavecolinc         = pData->iColinc;
+    iSaverowsamples     = pData->iRowsamples;
+    iSavesamplemul      = pData->iSamplemul;
+    iSavesampleofs      = pData->iSampleofs;
+    iSavesamplediv      = pData->iSamplediv;
+    iSaverowsize        = pData->iRowsize;
+    iSaverowmax         = pData->iRowmax;
+    iSavefilterofs      = pData->iFilterofs;
+    iSavepixelofs       = pData->iPixelofs;
+    iSavelevel0         = pData->iLevel0;
+    iSavelevel1         = pData->iLevel1;
+    iSavelevel2         = pData->iLevel2;
+    iSavelevel3         = pData->iLevel3;
+    pSaveworkrow        = pData->pWorkrow;
+    pSaveprevrow        = pData->pPrevrow;
+    pSaverGBArow        = pData->pRGBArow;
+    bSaveisRGBA16       = pData->bIsRGBA16;
+    bSaveisOpaque       = pData->bIsOpaque;
+    iSavefilterbpp      = pData->iFilterbpp;
+    iSavedestl          = pData->iDestl;
+    iSavedestt          = pData->iDestt;
+    iSavedestr          = pData->iDestr;
+    iSavedestb          = pData->iDestb;
+    iSavesourcel        = pData->iSourcel;
+    iSavesourcet        = pData->iSourcet;
+    iSavesourcer        = pData->iSourcer;
+    iSavesourceb        = pData->iSourceb;
+
+    pData->iDatawidth   = pANG->iTilewidth;
+    pData->iDataheight  = pANG->iTileheight;
+
+    pData->iDestl       = 0;
+    pData->iDestt       = 0;
+    pData->iDestr       = pANG->iTilewidth;
+    pData->iDestb       = pANG->iTileheight;
+    pData->iSourcel     = 0;
+    pData->iSourcet     = 0;
+    pData->iSourcer     = pANG->iTilewidth;
+    pData->iSourceb     = pANG->iTileheight;
+
+    pData->fInitrowproc = MNG_NULL;
+    pData->fStorerow    = MNG_NULL;
+    pData->fProcessrow  = MNG_NULL;
+    pData->fDifferrow   = MNG_NULL;
+
+    /* clone image object to store the pixel-data from object 0 */
+    iRetcode = mng_clone_imageobject (pData, 1, MNG_FALSE, MNG_FALSE, MNG_FALSE,
+                                      MNG_FALSE, 0, 0, 0, pData->pObjzero, &pImage);
+    if (iRetcode)                      /* on error, drop temp buffer and bail */
+    {
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+
+    /* make sure we got the right dimensions and interlacing */
+    iRetcode = mng_reset_object_details (pData, pImage, pANG->iTilewidth, pANG->iTileheight,
+                                         pImage->pImgbuf->iBitdepth, pImage->pImgbuf->iColortype,
+                                         pImage->pImgbuf->iCompression, pImage->pImgbuf->iFilter,
+                                         pANG->iInterlace, MNG_FALSE);
+    if (iRetcode)                      /* on error, drop temp buffer and bail */
+    {
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+
+    pData->pStoreobj    = pImage;
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+    pData->fInitrowproc = (mng_fptr)mng_init_rowproc;
+    pData->ePng_imgtype = mng_png_imgtype(pData->iColortype,pData->iBitdepth);
+#else
+    switch (pData->iColortype)         /* determine row initialization routine */
+    {
+      case 0 : {                       /* gray */
+                 switch (pData->iBitdepth)
+                 {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                   case  1 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g1_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g1_i;
+
+                               break;
+                             }
+                   case  2 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g2_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g2_i;
+
+                               break;
+                             }
+                   case  4 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g4_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g4_i;
+                               break;
+                             }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g8_i;
+
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g16_i;
+
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+      case 2 : {                       /* rgb */
+                 switch (pData->iBitdepth)
+                 {
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb8_i;
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb16_i;
+
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+      case 3 : {                       /* indexed */
+                 switch (pData->iBitdepth)
+                 {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                   case  1 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx1_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx1_i;
+
+                               break;
+                             }
+                   case  2 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx2_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx2_i;
+
+                               break;
+                             }
+                   case  4 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx4_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx4_i;
+
+                               break;
+                             }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx8_i;
+
+                               break;
+                             }
+                 }
+
+                 break;
+               }
+      case 4 : {                       /* gray+alpha */
+                 switch (pData->iBitdepth)
+                 {
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga8_i;
+
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga16_i;
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+      case 6 : {                       /* rgb+alpha */
+                 switch (pData->iBitdepth)
+                 {
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba8_i;
+
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba16_i;
+
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+    }
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+
+    pData->iFilterofs = 0;             /* determine filter characteristics */
+    pData->iLevel0    = 0;             /* default levels */
+    pData->iLevel1    = 0;    
+    pData->iLevel2    = 0;
+    pData->iLevel3    = 0;
+
+#ifdef FILTER192                       /* leveling & differing ? */
+    if (pData->iFilter == MNG_FILTER_DIFFERING)
+    {
+      switch (pData->iColortype)
+      {
+        case 0 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 1;
+                   else
+                     pData->iFilterofs = 2;
+
+                   break;
+                 }
+        case 2 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 3;
+                   else
+                     pData->iFilterofs = 6;
+
+                   break;
+                 }
+        case 3 : {
+                   pData->iFilterofs = 1;
+                   break;
+                 }
+        case 4 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 2;
+                   else
+                     pData->iFilterofs = 4;
+
+                   break;
+                 }
+        case 6 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 4;
+                   else
+                     pData->iFilterofs = 8;
+
+                   break;
+                 }
+      }
+    }
+#endif
+
+#ifdef FILTER193                       /* no adaptive filtering ? */
+    if (pData->iFilter == MNG_FILTER_NOFILTER)
+      pData->iPixelofs = pData->iFilterofs;
+    else
+#endif
+      pData->iPixelofs = pData->iFilterofs + 1;
+
+    if (pData->fInitrowproc)           /* need to initialize row processing? */
+    {
+      iRetcode = ((mng_initrowproc)pData->fInitrowproc) (pData);
+      if (iRetcode)
+      {
+         MNG_FREEX (pData, pBuf, iBufsize);
+         return iRetcode;
+      }
+    }
+                                       /* calculate remainder of buffer */
+    pTemp    = pBuf + (mng_int32)(pANG->iNumframes * iSize);
+    iTemplen = iRealsize - (mng_int32)(pANG->iNumframes * iSize);
+
+    do
+    {
+      if (iTemplen > pData->iRowmax)   /* get a pixel-row from the temp buffer */
+      {
+        MNG_COPY (pData->pWorkrow, pTemp, pData->iRowmax);
+      }
+      else
+      {
+        MNG_COPY (pData->pWorkrow, pTemp, iTemplen);
+      }
+
+      {                                /* image not completed yet ? */
+        if (pData->iRow < (mng_int32)pData->iDataheight)
+        {
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+          if (pData->iPNGdepth == 1)
+          {
+            /* Inflate Workrow to 8-bit */
+            mng_int32  iX;
+            mng_uint8p pSrc = pData->pWorkrow+1;
+            mng_uint8p pDest = pSrc + pData->iRowsize - (pData->iRowsize+7)/8;
+
+            for (iX = ((pData->iRowsize+7)/8) ; iX > 0 ; iX--)
+              *pDest++ = *pSrc++;
+
+            pDest = pData->pWorkrow+1;
+            pSrc = pDest + pData->iRowsize - (pData->iRowsize+7)/8;
+            for (iX = pData->iRowsize; ;)
+            {
+              *pDest++ = (((*pSrc)>>7)&1);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>6)&1);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>5)&1);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>4)&1);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>3)&1);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>2)&1);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>1)&1);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)   )&1);
+              if (iX-- <= 0)
+                break;
+              pSrc++;
+            }
+          }
+          else if (pData->iPNGdepth == 2)
+          {
+            /* Inflate Workrow to 8-bit */
+            mng_int32  iX;
+            mng_uint8p pSrc = pData->pWorkrow+1;
+            mng_uint8p pDest = pSrc + pData->iRowsize - (2*pData->iRowsize+7)/8;
+
+            for (iX = ((2*pData->iRowsize+7)/8) ; iX > 0 ; iX--)
+               *pDest++ = *pSrc++;
+
+            pDest = pData->pWorkrow+1;
+            pSrc = pDest + pData->iRowsize - (2*pData->iRowsize+7)/8;
+            for (iX = pData->iRowsize; ;)
+            {
+              *pDest++ = (((*pSrc)>>6)&3);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>4)&3);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)>>2)&3);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)   )&3);
+              if (iX-- <= 0)
+                break;
+              pSrc++;
+            }
+          }
+          else if (pData->iPNGdepth == 4)
+          {
+            /* Inflate Workrow to 8-bit */
+            mng_int32  iX;
+            mng_uint8p pSrc = pData->pWorkrow+1;
+            mng_uint8p pDest = pSrc + pData->iRowsize - (4*pData->iRowsize+7)/8;
+
+            for (iX = ((4*pData->iRowsize+7)/8) ; iX > 0 ; iX--)
+               *pDest++ = *pSrc++;
+
+            pDest = pData->pWorkrow+1;
+            pSrc = pDest + pData->iRowsize - (4*pData->iRowsize+7)/8;
+            for (iX = pData->iRowsize; ;)
+            {
+              *pDest++ = (((*pSrc)>>4)&0x0f);
+              if (iX-- <= 0)
+                break;
+              *pDest++ = (((*pSrc)   )&0x0f);
+              if (iX-- <= 0)
+                break;
+              pSrc++;
+            }
+          }
+          if (pData->iPNGdepth < 8 && pData->iColortype == 0)
+          {
+            /* Expand samples to 8-bit by LBR */
+            mng_int32  iX;
+            mng_uint8p pSrc = pData->pWorkrow+1;
+            mng_uint8 multiplier[]={0,255,85,0,17,0,0,0,1};
+
+            for (iX = pData->iRowsize; iX > 0; iX--)
+                *pSrc++ *= multiplier[pData->iPNGdepth];
+          }
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+          if (pData->iPNGdepth > 8)
+          {
+            /* Reduce Workrow to 8-bit */
+            mng_int32  iX;
+            mng_uint8p pSrc = pData->pWorkrow+1;
+            mng_uint8p pDest = pSrc;
+
+            for (iX = pData->iRowsize; iX > 0; iX--)
+            {
+              *pDest = *pSrc;
+              pDest++;
+              pSrc+=2;
+            }
+          }
+#endif
+
+#ifdef FILTER192                       /* has leveling info ? */
+          if (pData->iFilterofs == MNG_FILTER_DIFFERING)
+            iRetcode = init_rowdiffering (pData);
+          else
+#endif
+            iRetcode = MNG_NOERROR;
+                                       /* filter the row if necessary */
+          if ((!iRetcode) && (pData->iFilterofs < pData->iPixelofs  ) &&
+                             (*(pData->pWorkrow + pData->iFilterofs))    )
+            iRetcode = mng_filter_a_row (pData);
+
+                                       /* additional leveling/differing ? */
+          if ((!iRetcode) && (pData->fDifferrow))
+          {
+            iRetcode = ((mng_differrow)pData->fDifferrow) (pData);
+
+            pSwap           = pData->pWorkrow;
+            pData->pWorkrow = pData->pPrevrow;
+            pData->pPrevrow = pSwap;   /* make sure we're processing the right data */
+          }
+
+          if (!iRetcode)
+          {
+            {                          /* process this row */
+              if ((!iRetcode) && (pData->fProcessrow))
+                iRetcode = ((mng_processrow)pData->fProcessrow) (pData);
+                                       /* store in object ? */
+              if ((!iRetcode) && (pData->fStorerow))
+                iRetcode = ((mng_storerow)pData->fStorerow)     (pData);
+            }
+          }
+
+          if (iRetcode)                   /* on error bail out */
+          {
+            MNG_FREEX (pData, pBuf, iBufsize);
+            MNG_ERROR (pData, iRetcode);
+          }
+
+          if (!pData->fDifferrow)      /* swap row-pointers */
+          {
+            pSwap           = pData->pWorkrow;
+            pData->pWorkrow = pData->pPrevrow;
+            pData->pPrevrow = pSwap;   /* so prev points to the processed row! */
+          }
+                                       /* adjust variables for next row */
+          iRetcode = mng_next_row (pData);
+
+          if (iRetcode)                   /* on error bail out */
+          {
+            MNG_FREEX (pData, pBuf, iBufsize);
+            MNG_ERROR (pData, iRetcode);
+          }
+        }
+      }
+
+      pTemp    += pData->iRowmax;
+      iTemplen -= pData->iRowmax;
+    }                                  /* until some error or EOI
+                                          or all pixels received */
+    while ( (iTemplen > 0)  &&
+            ( (pData->iRow < (mng_int32)pData->iDataheight) ||
+              ( (pData->iPass >= 0) && (pData->iPass < 7) )    )    );
+
+    mng_cleanup_rowproc (pData);       /* cleanup row processing buffers !! */
+
+                                       /* restore saved work-parms */
+    pData->iDatawidth   = iSavedatawidth;
+    pData->iDataheight  = iSavedataheight;
+
+    pData->fInitrowproc = fSaveinitrowproc;
+    pData->fDisplayrow  = fSavestorerow;
+    pData->fProcessrow  = fSaveprocessrow;
+    pData->fDifferrow   = fSavedifferrow;
+    pData->pStoreobj    = fSavestoreobj;
+    pData->pStorebuf    = fSavestorebuf;
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+    pData->ePng_imgtype = eSavepngimgtype;
+#endif
+
+    pData->iInterlace   = iSaveinterlace;
+    pData->iPass        = iSavepass;
+    pData->iRow         = iSaverow;
+    pData->iRowinc      = iSaverowinc;
+    pData->iCol         = iSavecol;
+    pData->iColinc      = iSavecolinc;
+    pData->iRowsamples  = iSaverowsamples;
+    pData->iSamplemul   = iSavesamplemul;
+    pData->iSampleofs   = iSavesampleofs;
+    pData->iSamplediv   = iSavesamplediv;
+    pData->iRowsize     = iSaverowsize;
+    pData->iRowmax      = iSaverowmax;
+    pData->iFilterofs   = iSavefilterofs;
+    pData->iPixelofs    = iSavepixelofs;
+    pData->iLevel0      = iSavelevel0;
+    pData->iLevel1      = iSavelevel1;
+    pData->iLevel2      = iSavelevel2;
+    pData->iLevel3      = iSavelevel3;
+    pData->pWorkrow     = pSaveworkrow;
+    pData->pPrevrow     = pSaveprevrow;
+    pData->pRGBArow     = pSaverGBArow;
+    pData->bIsRGBA16    = bSaveisRGBA16;
+    pData->bIsOpaque    = bSaveisOpaque;
+    pData->iFilterbpp   = iSavefilterbpp;
+    pData->iDestl       = iSavedestl;
+    pData->iDestt       = iSavedestt;
+    pData->iDestr       = iSavedestr;
+    pData->iDestb       = iSavedestb;
+    pData->iSourcel     = iSavesourcel;
+    pData->iSourcet     = iSavesourcet;
+    pData->iSourcer     = iSavesourcer;
+    pData->iSourceb     = iSavesourceb;
+
+                                       /* create the animation directives ! */
+    pProcess = (mng_processobject)pANG->sHeader.fProcess;
+    iRetcode = pProcess (pData, (mng_objectp)pData->pANG);
+    if (iRetcode)
+      return iRetcode;
+
+#endif /* MNG_SUPPORT_DISPLAY */
+
+    MNG_FREE (pData, pBuf, iBufsize);  /* always free the temp buffer ! */
+  }
+
+  *piRawlen = 0;
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+MNG_C_SPECIALFUNC (mng_special_adat)
+{
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+MNG_C_SPECIALFUNC (mng_special_unknown)
+{
+                                       /* critical chunk ? */
+  if ((((mng_uint32)pData->iChunkname & 0x20000000) == 0)
+#ifdef MNG_SKIPCHUNK_SAVE
+    && (pData->iChunkname != MNG_UINT_SAVE)
+#endif
+#ifdef MNG_SKIPCHUNK_SEEK
+    && (pData->iChunkname != MNG_UINT_SEEK)
+#endif
+#ifdef MNG_SKIPCHUNK_DBYK
+    && (pData->iChunkname != MNG_UINT_DBYK)
+#endif
+#ifdef MNG_SKIPCHUNK_ORDR
+    && (pData->iChunkname != MNG_UINT_ORDR)
+#endif
+      )
+    MNG_ERROR (pData, MNG_UNKNOWNCRITICAL);
+
+  if (pData->fProcessunknown)          /* let the app handle it ? */
+  {
+    mng_bool bOke = pData->fProcessunknown ((mng_handle)pData, pData->iChunkname,
+                                            ((mng_unknown_chunkp)pChunk)->iDatasize,
+                                            ((mng_unknown_chunkp)pChunk)->pData);
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_READ_PROCS || MNG_INCLUDE_WRITE_PROCS */
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
+
+
+
diff --git a/src/3rdparty/libmng/libmng_chunk_descr.h b/src/3rdparty/libmng/libmng_chunk_descr.h
new file mode 100644
index 0000000..3781ab0
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunk_descr.h
@@ -0,0 +1,146 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunk_descr.h      copyright (c) 2007 G.Juyn        * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Chunk descriptor functions (implementation)                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : definition of the chunk- anf field-descriptor routines     * */
+/* *                                                                        * */
+/* * changes   : 1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKREADER               * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_chunk_descr_h_
+#define _libmng_chunk_descr_h_
+
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+#if defined(MNG_INCLUDE_READ_PROCS) || defined(MNG_INCLUDE_WRITE_PROCS)
+
+/* ************************************************************************** */
+
+void mng_get_chunkheader (mng_chunkid       iChunkname,
+                          mng_chunk_headerp pResult);
+
+/* ************************************************************************** */
+
+#define MNG_F_SPECIALFUNC(n) mng_retcode n (mng_datap   pData,    \
+                                            mng_chunkp  pChunk,   \
+                                            mng_uint32* piRawlen, \
+                                            mng_uint8p* ppRawdata)
+
+MNG_F_SPECIALFUNC (mng_debunk_plte) ;
+MNG_F_SPECIALFUNC (mng_debunk_trns) ;
+MNG_F_SPECIALFUNC (mng_deflate_itxt) ;
+MNG_F_SPECIALFUNC (mng_splt_entries) ;
+MNG_F_SPECIALFUNC (mng_hist_entries) ;
+
+MNG_F_SPECIALFUNC (mng_debunk_loop) ;
+MNG_F_SPECIALFUNC (mng_debunk_past) ;
+MNG_F_SPECIALFUNC (mng_disc_entries) ;
+MNG_F_SPECIALFUNC (mng_fram_remainder) ;
+MNG_F_SPECIALFUNC (mng_save_entries) ;
+MNG_F_SPECIALFUNC (mng_pplt_entries) ;
+MNG_F_SPECIALFUNC (mng_drop_entries) ;
+MNG_F_SPECIALFUNC (mng_ordr_entries) ;
+MNG_F_SPECIALFUNC (mng_debunk_magn) ;
+MNG_F_SPECIALFUNC (mng_evnt_entries) ;
+MNG_F_SPECIALFUNC (mng_adat_tiles) ;
+
+/* ************************************************************************** */
+
+#define MNG_C_SPECIALFUNC(n) mng_retcode n (mng_datap  pData,   \
+                                            mng_chunkp pChunk)
+
+MNG_C_SPECIALFUNC (mng_special_ihdr) ;
+MNG_C_SPECIALFUNC (mng_special_plte) ;
+MNG_C_SPECIALFUNC (mng_special_idat) ;
+MNG_C_SPECIALFUNC (mng_special_iend) ;
+MNG_C_SPECIALFUNC (mng_special_trns) ;
+MNG_C_SPECIALFUNC (mng_special_gama) ;
+MNG_C_SPECIALFUNC (mng_special_chrm) ;
+MNG_C_SPECIALFUNC (mng_special_srgb) ;
+MNG_C_SPECIALFUNC (mng_special_iccp) ;
+MNG_C_SPECIALFUNC (mng_special_text) ;
+MNG_C_SPECIALFUNC (mng_special_ztxt) ;
+MNG_C_SPECIALFUNC (mng_special_itxt) ;
+MNG_C_SPECIALFUNC (mng_special_bkgd) ;
+MNG_C_SPECIALFUNC (mng_special_phys) ;
+MNG_C_SPECIALFUNC (mng_special_sbit) ;
+MNG_C_SPECIALFUNC (mng_special_splt) ;
+MNG_C_SPECIALFUNC (mng_special_hist) ;
+MNG_C_SPECIALFUNC (mng_special_time) ;
+
+MNG_C_SPECIALFUNC (mng_special_jhdr) ;
+MNG_C_SPECIALFUNC (mng_special_jdaa) ;
+MNG_C_SPECIALFUNC (mng_special_jdat) ;
+MNG_C_SPECIALFUNC (mng_special_jsep) ;
+
+MNG_C_SPECIALFUNC (mng_special_mhdr) ;
+MNG_C_SPECIALFUNC (mng_special_mend) ;
+MNG_C_SPECIALFUNC (mng_special_loop) ;
+MNG_C_SPECIALFUNC (mng_special_endl) ;
+MNG_C_SPECIALFUNC (mng_special_defi) ;
+MNG_C_SPECIALFUNC (mng_special_basi) ;
+MNG_C_SPECIALFUNC (mng_special_clon) ;
+MNG_C_SPECIALFUNC (mng_special_past) ;
+MNG_C_SPECIALFUNC (mng_special_disc) ;
+MNG_C_SPECIALFUNC (mng_special_back) ;
+MNG_C_SPECIALFUNC (mng_special_fram) ;
+MNG_C_SPECIALFUNC (mng_special_move) ;
+MNG_C_SPECIALFUNC (mng_special_clip) ;
+MNG_C_SPECIALFUNC (mng_special_show) ;
+MNG_C_SPECIALFUNC (mng_special_term) ;
+MNG_C_SPECIALFUNC (mng_special_save) ;
+MNG_C_SPECIALFUNC (mng_special_seek) ;
+MNG_C_SPECIALFUNC (mng_special_expi) ;
+MNG_C_SPECIALFUNC (mng_special_fpri) ;
+MNG_C_SPECIALFUNC (mng_special_need) ;
+MNG_C_SPECIALFUNC (mng_special_phyg) ;
+
+MNG_C_SPECIALFUNC (mng_special_dhdr) ;
+MNG_C_SPECIALFUNC (mng_special_prom) ;
+MNG_C_SPECIALFUNC (mng_special_ipng) ;
+MNG_C_SPECIALFUNC (mng_special_pplt) ;
+MNG_C_SPECIALFUNC (mng_special_ijng) ;
+MNG_C_SPECIALFUNC (mng_special_drop) ;
+MNG_C_SPECIALFUNC (mng_special_dbyk) ;
+MNG_C_SPECIALFUNC (mng_special_ordr) ;
+
+MNG_C_SPECIALFUNC (mng_special_magn) ;
+MNG_C_SPECIALFUNC (mng_special_evnt) ;
+MNG_C_SPECIALFUNC (mng_special_mpng) ;
+MNG_C_SPECIALFUNC (mng_special_ahdr) ;
+MNG_C_SPECIALFUNC (mng_special_adat) ;
+MNG_C_SPECIALFUNC (mng_special_unknown) ;
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_READ_PROCS) || MNG_INCLUDE_WRITE_PROCS */
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+/* ************************************************************************** */
+
+#endif /* _libmng_chunk_descr_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_chunk_io.c b/src/3rdparty/libmng/libmng_chunk_io.c
new file mode 100644
index 0000000..eb18099
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunk_io.c
@@ -0,0 +1,10740 @@
+/** ************************************************************************* */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunk_io.c         copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Chunk I/O routines (implementation)                        * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of chunk input/output routines              * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/01/2000 - G.Juyn                                * */
+/* *             - cleaned up left-over teststuff in the BACK chunk routine * */
+/* *             0.5.1 - 05/04/2000 - G.Juyn                                * */
+/* *             - changed CRC initialization to use dynamic structure      * */
+/* *               (wasn't thread-safe the old way !)                       * */
+/* *             0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - filled in many missing sequence&length checks            * */
+/* *             - filled in many missing chunk-store snippets              * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - added checks for running animations                      * */
+/* *             - filled some write routines                               * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/10/2000 - G.Juyn                                * */
+/* *             - filled some more write routines                          * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - filled remaining write routines                          * */
+/* *             - fixed read_pplt with regard to deltatype                 * */
+/* *             - added callback error-reporting support                   * */
+/* *             - added pre-draft48 support (short MHDR, frame_mode, LOOP) * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *             - fixed chunk-storage bit in several routines              * */
+/* *             0.5.1 - 05/13/2000 - G.Juyn                                * */
+/* *             - added eMNGma hack (will be removed in 1.0.0 !!!)         * */
+/* *             - added TERM animation object pointer (easier reference)   * */
+/* *             - supplemented the SAVE & SEEK display processing          * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/18/2000 - G.Juyn                                * */
+/* *             - B004 - fixed problem with MNG_SUPPORT_WRITE not defined  * */
+/* *               also for MNG_SUPPORT_WRITE without MNG_INCLUDE_JNG       * */
+/* *             0.5.2 - 05/19/2000 - G.Juyn                                * */
+/* *             - cleaned up some code regarding mixed support             * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - implemented JNG support                                  * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added support for global color-chunks in animation       * */
+/* *             - added support for global PLTE,tRNS,bKGD in animation     * */
+/* *             - added support for SAVE & SEEK in animation               * */
+/* *             0.5.2 - 05/29/2000 - G.Juyn                                * */
+/* *             - changed ani_create calls not returning object pointer    * */
+/* *             - create ani objects always (not just inside TERM/LOOP)    * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added support for delta-image processing                 * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - fixed up punctuation (contributed by Tim Rowley)         * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - changed SWAP_ENDIAN to BIGENDIAN_SUPPORTED               * */
+/* *             0.5.2 - 06/03/2000 - G.Juyn                                * */
+/* *             - fixed makeup for Linux gcc compile                       * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/12/2000 - G.Juyn                                * */
+/* *             - added processing of color-info on delta-image            * */
+/* *             0.5.3 - 06/13/2000 - G.Juyn                                * */
+/* *             - fixed handling of empty SAVE chunk                       * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - changed to support delta-images                          * */
+/* *             - added extra checks for delta-images                      * */
+/* *             0.5.3 - 06/20/2000 - G.Juyn                                * */
+/* *             - fixed possible trouble if IEND display-process got       * */
+/* *               broken up                                                * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added processing of PLTE & tRNS for delta-images         * */
+/* *             - added administration of imagelevel parameter             * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - implemented support for PPLT chunk                       * */
+/* *             0.5.3 - 06/26/2000 - G.Juyn                                * */
+/* *             - added precaution against faulty iCCP chunks from PS      * */
+/* *             0.5.3 - 06/29/2000 - G.Juyn                                * */
+/* *             - fixed some 64-bit warnings                               * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/14/2000 - G.Juyn                                * */
+/* *             - changed pre-draft48 frame_mode=3 to frame_mode=1         * */
+/* *             0.9.1 - 07/16/2000 - G.Juyn                                * */
+/* *             - fixed storage of images during mng_read()                * */
+/* *             - fixed support for mng_display() after mng_read()         * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - fixed several chunk-writing routines                     * */
+/* *             0.9.1 - 07/24/2000 - G.Juyn                                * */
+/* *             - fixed reading of still-images                            * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/07/2000 - G.Juyn                                * */
+/* *             - B111300 - fixup for improved portability                 * */
+/* *             0.9.3 - 08/08/2000 - G.Juyn                                * */
+/* *             - fixed compiler-warnings from Mozilla                     * */
+/* *             0.9.3 - 08/09/2000 - G.Juyn                                * */
+/* *             - added check for simplicity-bits in MHDR                  * */
+/* *             0.9.3 - 08/12/2000 - G.Juyn                                * */
+/* *             - fixed check for simplicity-bits in MHDR (JNG)            * */
+/* *             0.9.3 - 08/12/2000 - G.Juyn                                * */
+/* *             - added workaround for faulty PhotoShop iCCP chunk         * */
+/* *             0.9.3 - 08/22/2000 - G.Juyn                                * */
+/* *             - fixed write-code for zTXt & iTXt                         * */
+/* *             - fixed read-code for iTXt                                 * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 09/10/2000 - G.Juyn                                * */
+/* *             - fixed DEFI behavior                                      * */
+/* *             0.9.3 - 10/02/2000 - G.Juyn                                * */
+/* *             - fixed simplicity-check in compliance with draft 81/0.98a * */
+/* *             0.9.3 - 10/10/2000 - G.Juyn                                * */
+/* *             - added support for alpha-depth prediction                 * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for JDAA                                   * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - fixed support for MAGN                                   * */
+/* *             - implemented nEED "xxxx" (where "xxxx" is a chunkid)      * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *             - fixed support for bKGD                                   * */
+/* *             0.9.3 - 10/23/2000 - G.Juyn                                * */
+/* *             - fixed bug in empty PLTE handling                         * */
+/* *                                                                        * */
+/* *             0.9.4 - 11/20/2000 - G.Juyn                                * */
+/* *             - changed IHDR filter_method check for PNGs                * */
+/* *             0.9.4 -  1/18/2001 - G.Juyn                                * */
+/* *             - added errorchecking for MAGN methods                     * */
+/* *             - removed test filter-methods 1 & 65                       * */
+/* *                                                                        * */
+/* *             0.9.5 -  1/25/2001 - G.Juyn                                * */
+/* *             - fixed some small compiler warnings (thanks Nikki)        * */
+/* *                                                                        * */
+/* *             1.0.2 - 05/05/2000 - G.Juyn                                * */
+/* *             - B421427 - writes wrong format in bKGD and tRNS           * */
+/* *             1.0.2 - 06/20/2000 - G.Juyn                                * */
+/* *             - B434583 - compiler-warning if MNG_STORE_CHUNKS undefined * */
+/* *                                                                        * */
+/* *             1.0.5 - 07/08/2002 - G.Juyn                                * */
+/* *             - B578572 - removed eMNGma hack (thanks Dimitri!)          * */
+/* *             1.0.5 - 08/07/2002 - G.Juyn                                * */
+/* *             - added test-option for PNG filter method 193 (=no filter) * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/07/2002 - G.Juyn                                * */
+/* *             - fixed reading of FRAM with just frame_mode and name      * */
+/* *             1.0.5 - 09/13/2002 - G.Juyn                                * */
+/* *             - fixed read/write of MAGN chunk                           * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - fixed LOOP iteration=0 special case                      * */
+/* *             1.0.5 - 09/19/2002 - G.Juyn                                * */
+/* *             - misplaced TERM is now treated as warning                 * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 10/03/2002 - G.Juyn                                * */
+/* *             - fixed chunk-storage for evNT chunk                       * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - fixed DISC support                                       * */
+/* *             - added another fix for misplaced TERM chunk               * */
+/* *             1.0.5 - 10/17/2002 - G.Juyn                                * */
+/* *             - fixed initializtion of pIds in dISC read routine         * */
+/* *             1.0.5 - 11/06/2002 - G.Juyn                                * */
+/* *             - added support for nEED "MNG 1.1"                         * */
+/* *             - added support for nEED "CACHEOFF"                        * */
+/* *                                                                        * */
+/* *             1.0.6 - 05/25/2003 - G.R-P                                 * */
+/* *             - added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             1.0.6 - 06/02/2003 - G.R-P                                 * */
+/* *             - removed some redundant checks for iRawlen==0             * */
+/* *             1.0.6 - 06/22/2003 - G.R-P                                 * */
+/* *             - added MNG_NO_16BIT_SUPPORT, MNG_NO_DELTA_PNG reductions  * */
+/* *             - optionally use zlib's crc32 function instead of          * */
+/* *               local mng_update_crc                                     * */
+/* *             1.0.6 - 07/14/2003 - G.R-P                                 * */
+/* *             - added MNG_NO_LOOP_SIGNALS_SUPPORTED conditional          * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *             1.0.6 - 08/17/2003 - G.R-P                                 * */
+/* *             - added conditionals around non-VLC chunk support          * */
+/* *                                                                        * */
+/* *             1.0.7 - 10/29/2003 - G.R-P                                 * */
+/* *             - revised JDAA and JDAT readers to avoid compiler bug      * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *             1.0.7 - 01/27/2004 - J.S                                   * */
+/* *             - fixed inclusion of IJNG chunk for non-JNG use            * */
+/* *             1.0.7 - 02/26/2004 - G.Juyn                                * */
+/* *             - fixed bug in chunk-storage of SHOW chunk (from == to)    * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/02/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *             1.0.8 - 07/07/2004 - G.R-P                                 * */
+/* *             - change worst-case iAlphadepth to 1 for standalone PNGs   * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/28/2004 - G.R-P                                 * */
+/* *             - improved handling of cheap transparency when 16-bit      * */
+/* *               support is disabled                                      * */
+/* *             1.0.9 - 10/04/2004 - G.Juyn                                * */
+/* *             - fixed bug in writing sBIT for indexed color              * */
+/* *             1.0.9 - 10/10/2004 - G.R-P.                                * */
+/* *             - added MNG_NO_1_2_4BIT_SUPPORT                            * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKINITFREE             * */
+/* *             1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKASSIGN               * */
+/* *             1.0.9 - 12/07/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKREADER               * */
+/* *             1.0.9 - 12/11/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_DISPLAYCALLS              * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *             1.0.9 - 01/17/2005 - G.Juyn                                * */
+/* *             - fixed problem with global PLTE/tRNS                      * */
+/* *                                                                        * */
+/* *             1.0.10 - 02/07/2005 - G.Juyn                               * */
+/* *             - fixed display routines called twice for FULL_MNG         * */
+/* *               support in mozlibmngconf.h                               * */
+/* *             1.0.10 - 12/04/2005 - G.R-P.                               * */
+/* *             - #ifdef out use of mng_inflate_buffer when it is not      * */
+/* *               available.                                               * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *             1.0.10 - 05/02/2007 - G.Juyn                               * */
+/* *             - fixed inflate_buffer for extreme compression ratios      * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_objects.h"
+#include "libmng_object_prc.h"
+#include "libmng_chunks.h"
+#ifdef MNG_CHECK_BAD_ICCP
+#include "libmng_chunk_prc.h"
+#endif
+#include "libmng_memory.h"
+#include "libmng_display.h"
+#include "libmng_zlib.h"
+#include "libmng_pixels.h"
+#include "libmng_chunk_io.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * CRC - Cyclic Redundancy Check                                          * */
+/* *                                                                        * */
+/* * The code below is taken directly from the sample provided with the     * */
+/* * PNG specification.                                                     * */
+/* * (it is only adapted to the library's internal data-definitions)        * */
+/* *                                                                        * */
+/* ************************************************************************** */
+/* Make the table for a fast CRC. */
+#ifndef MNG_USE_ZLIB_CRC
+MNG_LOCAL void make_crc_table (mng_datap pData)
+{
+  mng_uint32 iC;
+  mng_int32  iN, iK;
+
+  for (iN = 0; iN < 256; iN++)
+  {
+    iC = (mng_uint32) iN;
+
+    for (iK = 0; iK < 8; iK++)
+    {
+      if (iC & 1)
+        iC = 0xedb88320U ^ (iC >> 1);
+      else
+        iC = iC >> 1;
+    }
+
+    pData->aCRCtable [iN] = iC;
+  }
+
+  pData->bCRCcomputed = MNG_TRUE;
+}
+#endif
+
+/* Update a running CRC with the bytes buf[0..len-1]--the CRC
+   should be initialized to all 1's, and the transmitted value
+   is the 1's complement of the final running CRC (see the
+   crc() routine below). */
+
+MNG_LOCAL mng_uint32 update_crc (mng_datap  pData,
+                                 mng_uint32 iCrc,
+                                 mng_uint8p pBuf,
+                                 mng_int32  iLen)
+{
+#ifdef MNG_USE_ZLIB_CRC
+  return crc32 (iCrc, pBuf, iLen);
+#else
+  mng_uint32 iC = iCrc;
+  mng_int32 iN;
+
+  if (!pData->bCRCcomputed)
+    make_crc_table (pData);
+
+  for (iN = 0; iN < iLen; iN++)
+    iC = pData->aCRCtable [(iC ^ pBuf [iN]) & 0xff] ^ (iC >> 8);
+
+  return iC;
+#endif
+}
+
+/* Return the CRC of the bytes buf[0..len-1]. */
+mng_uint32 mng_crc (mng_datap  pData,
+                    mng_uint8p pBuf,
+                    mng_int32  iLen)
+{
+#ifdef MNG_USE_ZLIB_CRC
+  return update_crc (pData, 0, pBuf, iLen);
+#else
+  return update_crc (pData, 0xffffffffU, pBuf, iLen) ^ 0xffffffffU;
+#endif
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Routines for swapping byte-order from and to graphic files             * */
+/* * (This code is adapted from the libpng package)                         * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+
+/* ************************************************************************** */
+
+mng_uint32 mng_get_uint32 (mng_uint8p pBuf)
+{
+   mng_uint32 i = ((mng_uint32)(*pBuf)       << 24) +
+                  ((mng_uint32)(*(pBuf + 1)) << 16) +
+                  ((mng_uint32)(*(pBuf + 2)) <<  8) +
+                   (mng_uint32)(*(pBuf + 3));
+   return (i);
+}
+
+/* ************************************************************************** */
+
+mng_int32 mng_get_int32 (mng_uint8p pBuf)
+{
+   mng_int32 i = ((mng_int32)(*pBuf)       << 24) +
+                 ((mng_int32)(*(pBuf + 1)) << 16) +
+                 ((mng_int32)(*(pBuf + 2)) <<  8) +
+                  (mng_int32)(*(pBuf + 3));
+   return (i);
+}
+
+/* ************************************************************************** */
+
+mng_uint16 mng_get_uint16 (mng_uint8p pBuf)
+{
+   mng_uint16 i = (mng_uint16)(((mng_uint16)(*pBuf) << 8) +
+                                (mng_uint16)(*(pBuf + 1)));
+   return (i);
+}
+
+/* ************************************************************************** */
+
+void mng_put_uint32 (mng_uint8p pBuf,
+                     mng_uint32 i)
+{
+   *pBuf     = (mng_uint8)((i >> 24) & 0xff);
+   *(pBuf+1) = (mng_uint8)((i >> 16) & 0xff);
+   *(pBuf+2) = (mng_uint8)((i >> 8) & 0xff);
+   *(pBuf+3) = (mng_uint8)(i & 0xff);
+}
+
+/* ************************************************************************** */
+
+void mng_put_int32 (mng_uint8p pBuf,
+                    mng_int32  i)
+{
+   *pBuf     = (mng_uint8)((i >> 24) & 0xff);
+   *(pBuf+1) = (mng_uint8)((i >> 16) & 0xff);
+   *(pBuf+2) = (mng_uint8)((i >> 8) & 0xff);
+   *(pBuf+3) = (mng_uint8)(i & 0xff);
+}
+
+/* ************************************************************************** */
+
+void mng_put_uint16 (mng_uint8p pBuf,
+                     mng_uint16 i)
+{
+   *pBuf     = (mng_uint8)((i >> 8) & 0xff);
+   *(pBuf+1) = (mng_uint8)(i & 0xff);
+}
+
+/* ************************************************************************** */
+
+#endif /* !MNG_BIGENDIAN_SUPPORTED */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Helper routines to simplify chunk-data extraction                      * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_READ_PROCS
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+MNG_LOCAL mng_uint8p find_null (mng_uint8p pIn)
+{
+  mng_uint8p pOut = pIn;
+  while (*pOut)                        /* the read_graphic routine has made sure there's */
+    pOut++;                            /* always at least 1 zero-byte in the buffer */
+  return pOut;
+}
+#endif
+
+/* ************************************************************************** */
+
+#if !defined(MNG_SKIPCHUNK_iCCP) || !defined(MNG_SKIPCHUNK_zTXt) || \
+    !defined(MNG_SKIPCHUNK_iTXt) || defined(MNG_INCLUDE_MPNG_PROPOSAL) || \
+    defined(MNG_INCLUDE_ANG_PROPOSAL)
+mng_retcode mng_inflate_buffer (mng_datap  pData,
+                                mng_uint8p pInbuf,
+                                mng_uint32 iInsize,
+                                mng_uint8p *pOutbuf,
+                                mng_uint32 *iOutsize,
+                                mng_uint32 *iRealsize)
+{
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INFLATE_BUFFER, MNG_LC_START);
+#endif
+
+  if (iInsize)                         /* anything to do ? */
+  {
+    *iOutsize = iInsize * 3;           /* estimate uncompressed size */
+                                       /* and allocate a temporary buffer */
+    MNG_ALLOC (pData, *pOutbuf, *iOutsize);
+
+    do
+    {
+      mngzlib_inflateinit (pData);     /* initialize zlib */
+                                       /* let zlib know where to store the output */
+      pData->sZlib.next_out  = *pOutbuf;
+                                       /* "size - 1" so we've got space for the
+                                          zero-termination of a possible string */
+      pData->sZlib.avail_out = *iOutsize - 1;
+                                       /* ok; let's inflate... */
+      iRetcode = mngzlib_inflatedata (pData, iInsize, pInbuf);
+                                       /* determine actual output size */
+      *iRealsize = (mng_uint32)pData->sZlib.total_out;
+
+      mngzlib_inflatefree (pData);     /* zlib's done */
+
+      if (iRetcode == MNG_BUFOVERFLOW) /* not enough space ? */
+      {                                /* then get some more */
+        MNG_FREEX (pData, *pOutbuf, *iOutsize);
+        *iOutsize = *iOutsize + *iOutsize;
+        MNG_ALLOC (pData, *pOutbuf, *iOutsize);
+      }
+    }                                  /* repeat if we didn't have enough space */
+    while ((iRetcode == MNG_BUFOVERFLOW) &&
+           (*iOutsize < 200 * iInsize));
+
+    if (!iRetcode)                     /* if oke ? */
+      *((*pOutbuf) + *iRealsize) = 0;  /* then put terminator zero */
+
+  }
+  else
+  {
+    *pOutbuf   = 0;                    /* nothing to do; then there's no output */
+    *iOutsize  = 0;
+    *iRealsize = 0;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INFLATE_BUFFER, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_READ_PROCS */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Helper routines to simplify chunk writing                              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+#ifdef MNG_INCLUDE_WRITE_PROCS
+/* ************************************************************************** */
+
+#if !defined(MNG_SKIPCHUNK_iCCP) || !defined(MNG_SKIPCHUNK_zTXt) || !defined(MNG_SKIPCHUNK_iTXt)
+MNG_LOCAL mng_retcode deflate_buffer (mng_datap  pData,
+                                      mng_uint8p pInbuf,
+                                      mng_uint32 iInsize,
+                                      mng_uint8p *pOutbuf,
+                                      mng_uint32 *iOutsize,
+                                      mng_uint32 *iRealsize)
+{
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DEFLATE_BUFFER, MNG_LC_START);
+#endif
+
+  if (iInsize)                         /* anything to do ? */
+  {
+    *iOutsize = (iInsize * 5) >> 2;    /* estimate compressed size */
+                                       /* and allocate a temporary buffer */
+    MNG_ALLOC (pData, *pOutbuf, *iOutsize);
+
+    do
+    {
+      mngzlib_deflateinit (pData);     /* initialize zlib */
+                                       /* let zlib know where to store the output */
+      pData->sZlib.next_out  = *pOutbuf;
+      pData->sZlib.avail_out = *iOutsize;
+                                       /* ok; let's deflate... */
+      iRetcode = mngzlib_deflatedata (pData, iInsize, pInbuf);
+                                       /* determine actual output size */
+      *iRealsize = pData->sZlib.total_out;
+
+      mngzlib_deflatefree (pData);     /* zlib's done */
+
+      if (iRetcode == MNG_BUFOVERFLOW) /* not enough space ? */
+      {                                /* then get some more */
+        MNG_FREEX (pData, *pOutbuf, *iOutsize);
+        *iOutsize = *iOutsize + (iInsize >> 1);
+        MNG_ALLOC (pData, *pOutbuf, *iOutsize);
+      }
+    }                                  /* repeat if we didn't have enough space */
+    while (iRetcode == MNG_BUFOVERFLOW);
+  }
+  else
+  {
+    *pOutbuf   = 0;                    /* nothing to do; then there's no output */
+    *iOutsize  = 0;
+    *iRealsize = 0;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DEFLATE_BUFFER, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode write_raw_chunk (mng_datap   pData,
+                                       mng_chunkid iChunkname,
+                                       mng_uint32  iRawlen,
+                                       mng_uint8p  pRawdata)
+{
+  mng_uint32 iCrc;
+  mng_uint32 iWritten;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_RAW_CHUNK, MNG_LC_START);
+#endif
+                                       /* temporary buffer ? */
+  if ((pRawdata != 0) && (pRawdata != pData->pWritebuf+8))
+  {                                    /* store length & chunktype in default buffer */
+    mng_put_uint32 (pData->pWritebuf,   iRawlen);
+    mng_put_uint32 (pData->pWritebuf+4, (mng_uint32)iChunkname);
+
+    if (pData->iCrcmode & MNG_CRC_OUTPUT)
+    {
+      if ((pData->iCrcmode & MNG_CRC_OUTPUT) == MNG_CRC_OUTPUT_GENERATE)
+      {                                /* calculate the crc */
+        iCrc = update_crc (pData, 0xffffffffL, pData->pWritebuf+4, 4);
+        iCrc = update_crc (pData, iCrc, pRawdata, iRawlen) ^ 0xffffffffL;
+      } else {
+        iCrc = 0;                      /* dummy crc */
+      }                                /* store in default buffer */
+      mng_put_uint32 (pData->pWritebuf+8, iCrc);
+    }
+                                       /* write the length & chunktype */
+    if (!pData->fWritedata ((mng_handle)pData, pData->pWritebuf, 8, &iWritten))
+      MNG_ERROR (pData, MNG_APPIOERROR);
+
+    if (iWritten != 8)                 /* disk full ? */
+      MNG_ERROR (pData, MNG_OUTPUTERROR);
+                                       /* write the temporary buffer */
+    if (!pData->fWritedata ((mng_handle)pData, pRawdata, iRawlen, &iWritten))
+      MNG_ERROR (pData, MNG_APPIOERROR);
+
+    if (iWritten != iRawlen)           /* disk full ? */
+      MNG_ERROR (pData, MNG_OUTPUTERROR);
+
+    if (pData->iCrcmode & MNG_CRC_OUTPUT)
+    {                                  /* write the crc */
+      if (!pData->fWritedata ((mng_handle)pData, pData->pWritebuf+8, 4, &iWritten))
+        MNG_ERROR (pData, MNG_APPIOERROR);
+
+      if (iWritten != 4)               /* disk full ? */
+        MNG_ERROR (pData, MNG_OUTPUTERROR);
+    }
+  }
+  else
+  {                                    /* prefix with length & chunktype */
+    mng_put_uint32 (pData->pWritebuf,   iRawlen);
+    mng_put_uint32 (pData->pWritebuf+4, (mng_uint32)iChunkname);
+
+    if (pData->iCrcmode & MNG_CRC_OUTPUT)
+    {
+      if ((pData->iCrcmode & MNG_CRC_OUTPUT) == MNG_CRC_OUTPUT_GENERATE)
+                                       /* calculate the crc */
+        iCrc = mng_crc (pData, pData->pWritebuf+4, iRawlen + 4);
+      else
+        iCrc = 0;                      /* dummy crc */
+                                       /* add it to the buffer */
+      mng_put_uint32 (pData->pWritebuf + iRawlen + 8, iCrc);
+                                       /* write it in a single pass */
+      if (!pData->fWritedata ((mng_handle)pData, pData->pWritebuf, iRawlen + 12, &iWritten))
+        MNG_ERROR (pData, MNG_APPIOERROR);
+
+      if (iWritten != iRawlen + 12)    /* disk full ? */
+        MNG_ERROR (pData, MNG_OUTPUTERROR);
+    } else {
+      if (!pData->fWritedata ((mng_handle)pData, pData->pWritebuf, iRawlen + 8, &iWritten))
+        MNG_ERROR (pData, MNG_APPIOERROR);
+
+      if (iWritten != iRawlen + 8)     /* disk full ? */
+        MNG_ERROR (pData, MNG_OUTPUTERROR);
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_RAW_CHUNK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* B004 */
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+/* B004 */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * chunk read functions                                                   * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_READ_PROCS
+
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode create_chunk_storage (mng_datap       pData,
+                                            mng_chunkp      pHeader,
+                                            mng_uint32      iRawlen,
+                                            mng_uint8p      pRawdata,
+                                            mng_field_descp pField,
+                                            mng_uint16      iFields,
+                                            mng_chunkp*     ppChunk,
+                                            mng_bool        bWorkcopy)
+{
+  mng_field_descp pTempfield  = pField;
+  mng_uint16      iFieldcount = iFields;
+  mng_uint8p      pTempdata   = pRawdata;
+  mng_uint32      iTemplen    = iRawlen;
+  mng_uint16      iLastgroup  = 0;
+  mng_uint8p      pChunkdata;
+  mng_uint32      iDatalen;
+  mng_uint8       iColortype;
+  mng_bool        bProcess;
+                                       /* initialize storage */
+  mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  if (((mng_chunk_headerp)(*ppChunk))->iChunkname == MNG_UINT_HUH)
+    ((mng_chunk_headerp)(*ppChunk))->iChunkname = pData->iChunkname;
+
+  if ((!bWorkcopy) ||
+      ((((mng_chunk_headerp)pHeader)->iChunkname != MNG_UINT_IDAT) &&
+       (((mng_chunk_headerp)pHeader)->iChunkname != MNG_UINT_JDAT) &&
+       (((mng_chunk_headerp)pHeader)->iChunkname != MNG_UINT_JDAA)   ))
+  {
+    pChunkdata = (mng_uint8p)(*ppChunk);
+
+#ifdef MNG_INCLUDE_JNG                 /* determine current colortype */
+    if (pData->bHasJHDR)
+      iColortype = (mng_uint8)(pData->iJHDRcolortype - 8);
+    else
+#endif /* MNG_INCLUDE_JNG */
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+      iColortype = pData->iColortype;
+    else
+      iColortype = 6;
+
+    if (iTemplen)                      /* not empty ? */
+    {                                  /* then go fill the fields */
+      while ((iFieldcount) && (iTemplen))
+      {
+        if (pTempfield->iOffsetchunk)
+        {
+          if (pTempfield->iFlags & MNG_FIELD_PUTIMGTYPE)
+          {
+            *(pChunkdata+pTempfield->iOffsetchunk) = iColortype;
+            bProcess = MNG_FALSE;
+          }
+          else
+          if (pTempfield->iFlags & MNG_FIELD_IFIMGTYPES)
+            bProcess = (mng_bool)(((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE0) && (iColortype == 0)) ||
+                                  ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE2) && (iColortype == 2)) ||
+                                  ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE3) && (iColortype == 3)) ||
+                                  ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE4) && (iColortype == 4)) ||
+                                  ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE6) && (iColortype == 6))   );
+          else
+            bProcess = MNG_TRUE;
+
+          if (bProcess)
+          {
+            iLastgroup = (mng_uint16)(pTempfield->iFlags & MNG_FIELD_GROUPMASK);
+                                      /* numeric field ? */
+            if (pTempfield->iFlags & MNG_FIELD_INT)
+            {
+              if (iTemplen < pTempfield->iLengthmax)
+                MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+              switch (pTempfield->iLengthmax)
+              {
+                case 1 : { mng_uint8 iNum = *pTempdata;
+                           if (((mng_uint16)iNum < pTempfield->iMinvalue) ||
+                               ((mng_uint16)iNum > pTempfield->iMaxvalue)    )
+                             MNG_ERROR (pData, MNG_INVALIDFIELDVAL);
+                           *(pChunkdata+pTempfield->iOffsetchunk) = iNum;
+                           break; }
+                case 2 : { mng_uint16 iNum = mng_get_uint16 (pTempdata);
+                           if ((iNum < pTempfield->iMinvalue) || (iNum > pTempfield->iMaxvalue))
+                             MNG_ERROR (pData, MNG_INVALIDFIELDVAL);
+                           *((mng_uint16p)(pChunkdata+pTempfield->iOffsetchunk)) = iNum;
+                           break; }
+                case 4 : { mng_uint32 iNum = mng_get_uint32 (pTempdata);
+                           if ((iNum < pTempfield->iMinvalue) ||
+                               ((pTempfield->iFlags & MNG_FIELD_NOHIGHBIT) && (iNum & 0x80000000)) )
+                             MNG_ERROR (pData, MNG_INVALIDFIELDVAL);
+                           *((mng_uint32p)(pChunkdata+pTempfield->iOffsetchunk)) = iNum;
+                           break; }
+              }
+
+              pTempdata += pTempfield->iLengthmax;
+              iTemplen  -= pTempfield->iLengthmax;
+
+            } else {                   /* not numeric so it's a bunch of bytes */
+
+              if (!pTempfield->iOffsetchunklen)    /* big fat NONO */
+                MNG_ERROR (pData, MNG_INTERNALERROR);
+                                       /* with terminating 0 ? */
+              if (pTempfield->iFlags & MNG_FIELD_TERMINATOR)
+              {
+                mng_uint8p pWork = pTempdata;
+                while (*pWork)         /* find the zero */
+                  pWork++;
+                iDatalen = (mng_uint32)(pWork - pTempdata);
+              } else {                 /* no terminator, so everything that's left ! */
+                iDatalen = iTemplen;
+              }
+
+              if ((pTempfield->iLengthmax) && (iDatalen > pTempfield->iLengthmax))
+                MNG_ERROR (pData, MNG_INVALIDLENGTH);
+#if !defined(MNG_SKIPCHUNK_iCCP) || !defined(MNG_SKIPCHUNK_zTXt) || \
+    !defined(MNG_SKIPCHUNK_iTXt) || defined(MNG_INCLUDE_MPNG_PROPOSAL) || \
+    defined(MNG_INCLUDE_ANG_PROPOSAL)
+                                       /* needs decompression ? */
+              if (pTempfield->iFlags & MNG_FIELD_DEFLATED)
+              {
+                mng_uint8p pBuf = 0;
+                mng_uint32 iBufsize = 0;
+                mng_uint32 iRealsize;
+                mng_ptr    pWork;
+
+                iRetcode = mng_inflate_buffer (pData, pTempdata, iDatalen,
+                                               &pBuf, &iBufsize, &iRealsize);
+
+#ifdef MNG_CHECK_BAD_ICCP              /* Check for bad iCCP chunk */
+                if ((iRetcode) && (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_iCCP))
+                {
+                  *((mng_ptr *)(pChunkdata+pTempfield->iOffsetchunk))      = MNG_NULL;
+                  *((mng_uint32p)(pChunkdata+pTempfield->iOffsetchunklen)) = iDatalen;
+                }
+                else
+#endif
+                {
+                  if (iRetcode)
+                    return iRetcode;
+
+#if defined(MNG_INCLUDE_MPNG_PROPOSAL) || defined(MNG_INCLUDE_ANG_PROPOSAL)
+                  if ( (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_mpNG) ||
+                       (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_adAT)    )
+                  {
+                    MNG_ALLOC (pData, pWork, iRealsize);
+                  }
+                  else
+                  {
+#endif
+                                       /* don't forget to generate null terminator */
+                    MNG_ALLOC (pData, pWork, iRealsize+1);
+#if defined(MNG_INCLUDE_MPNG_PROPOSAL) || defined(MNG_INCLUDE_ANG_PROPOSAL)
+                  }
+#endif
+                  MNG_COPY (pWork, pBuf, iRealsize);
+
+                  *((mng_ptr *)(pChunkdata+pTempfield->iOffsetchunk))      = pWork;
+                  *((mng_uint32p)(pChunkdata+pTempfield->iOffsetchunklen)) = iRealsize;
+                }
+
+                if (pBuf)              /* free the temporary buffer */
+                  MNG_FREEX (pData, pBuf, iBufsize);
+
+              } else
+#endif
+                     {                 /* no decompression, so just copy */
+
+                mng_ptr pWork;
+                                       /* don't forget to generate null terminator */
+                MNG_ALLOC (pData, pWork, iDatalen+1);
+                MNG_COPY (pWork, pTempdata, iDatalen);
+
+                *((mng_ptr *)(pChunkdata+pTempfield->iOffsetchunk))      = pWork;
+                *((mng_uint32p)(pChunkdata+pTempfield->iOffsetchunklen)) = iDatalen;
+              }
+
+              if (pTempfield->iFlags & MNG_FIELD_TERMINATOR)
+                iDatalen++;            /* skip the terminating zero as well !!! */
+
+              iTemplen  -= iDatalen;
+              pTempdata += iDatalen;
+            }
+                                       /* need to set an indicator ? */
+            if (pTempfield->iOffsetchunkind)
+              *((mng_uint8p)(pChunkdata+pTempfield->iOffsetchunkind)) = MNG_TRUE;
+          }
+        }
+
+        if (pTempfield->pSpecialfunc)  /* special function required ? */
+        {
+          iRetcode = pTempfield->pSpecialfunc(pData, *ppChunk, &iTemplen, &pTempdata);
+          if (iRetcode)                /* on error bail out */
+            return iRetcode;
+        }
+
+        pTempfield++;                  /* Neeeeeeexxxtt */
+        iFieldcount--;
+      }
+
+      if (iTemplen)                    /* extra data ??? */
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+      while (iFieldcount)              /* not enough data ??? */
+      {
+        if (pTempfield->iFlags & MNG_FIELD_IFIMGTYPES)
+          bProcess = (mng_bool)(((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE0) && (iColortype == 0)) ||
+                                ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE2) && (iColortype == 2)) ||
+                                ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE3) && (iColortype == 3)) ||
+                                ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE4) && (iColortype == 4)) ||
+                                ((pTempfield->iFlags & MNG_FIELD_IFIMGTYPE6) && (iColortype == 6))   );
+        else
+          bProcess = MNG_TRUE;
+
+        if (bProcess)
+        {
+          if (!(pTempfield->iFlags & MNG_FIELD_OPTIONAL))
+            MNG_ERROR (pData, MNG_INVALIDLENGTH);
+          if ((pTempfield->iFlags & MNG_FIELD_GROUPMASK) &&
+              ((mng_uint16)(pTempfield->iFlags & MNG_FIELD_GROUPMASK) == iLastgroup))
+            MNG_ERROR (pData, MNG_INVALIDLENGTH);
+        }
+
+        pTempfield++;
+        iFieldcount--;
+      }
+    }
+  }
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+READ_CHUNK (mng_read_general)
+{
+  mng_retcode     iRetcode = MNG_NOERROR;
+  mng_chunk_descp pDescr   = ((mng_chunk_headerp)pHeader)->pChunkdescr;
+  mng_field_descp pField;
+  mng_uint16      iFields;
+
+  if (!pDescr)                         /* this is a bad booboo !!! */
+    MNG_ERROR (pData, MNG_INTERNALERROR);
+
+  pField  = pDescr->pFielddesc;
+  iFields = pDescr->iFielddesc;
+                                       /* check chunk against signature */
+  if ((pDescr->eImgtype == mng_it_mng) && (pData->eSigtype != mng_it_mng))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+
+  if ((pDescr->eImgtype == mng_it_jng) && (pData->eSigtype == mng_it_png))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+                                       /* empties allowed ? */
+  if ((iRawlen == 0) && (!(pDescr->iAllowed & MNG_DESCR_EMPTY)))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  if ((pData->eImagetype != mng_it_mng) || (!(pDescr->iAllowed & MNG_DESCR_GLOBAL)))
+  {                                    /* *a* header required ? */
+    if ((pDescr->iMusthaves & MNG_DESCR_GenHDR) &&
+#ifdef MNG_INCLUDE_JNG
+        (!pData->bHasIHDR) && (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+        (!pData->bHasIHDR) && (!pData->bHasBASI) && (!pData->bHasDHDR))
+#endif
+      MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+    if ((pDescr->iMusthaves & MNG_DESCR_JngHDR) &&
+        (!pData->bHasDHDR) && (!pData->bHasJHDR))
+      MNG_ERROR (pData, MNG_SEQUENCEERROR);
+#endif
+  }
+                                       /* specific chunk pre-requisite ? */
+  if (((pDescr->iMusthaves & MNG_DESCR_IHDR) && (!pData->bHasIHDR)) ||
+#ifdef MNG_INCLUDE_JNG
+      ((pDescr->iMusthaves & MNG_DESCR_JHDR) && (!pData->bHasJHDR)) ||
+#endif
+      ((pDescr->iMusthaves & MNG_DESCR_DHDR) && (!pData->bHasDHDR)) ||
+      ((pDescr->iMusthaves & MNG_DESCR_LOOP) && (!pData->bHasLOOP)) ||
+      ((pDescr->iMusthaves & MNG_DESCR_PLTE) && (!pData->bHasPLTE)) ||
+      ((pDescr->iMusthaves & MNG_DESCR_MHDR) && (!pData->bHasMHDR)) ||
+      ((pDescr->iMusthaves & MNG_DESCR_SAVE) && (!pData->bHasSAVE))   )
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* specific chunk undesired ? */
+  if (((pDescr->iMustNOThaves & MNG_DESCR_NOIHDR) && (pData->bHasIHDR)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOBASI) && (pData->bHasBASI)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NODHDR) && (pData->bHasDHDR)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOIDAT) && (pData->bHasIDAT)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOPLTE) && (pData->bHasPLTE)) ||
+#ifdef MNG_INCLUDE_JNG
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOJHDR) && (pData->bHasJHDR)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOJDAT) && (pData->bHasJDAT)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOJDAA) && (pData->bHasJDAA)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOJSEP) && (pData->bHasJSEP)) ||
+#endif
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOMHDR) && (pData->bHasMHDR)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOLOOP) && (pData->bHasLOOP)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOTERM) && (pData->bHasTERM)) ||
+      ((pDescr->iMustNOThaves & MNG_DESCR_NOSAVE) && (pData->bHasSAVE))   )
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (pData->eSigtype == mng_it_mng)   /* check global and embedded empty chunks */
+  {
+#ifdef MNG_INCLUDE_JNG
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    {
+      if ((iRawlen == 0) && (!(pDescr->iAllowed & MNG_DESCR_EMPTYEMBED)))
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+    } else {
+      if ((iRawlen == 0) && (!(pDescr->iAllowed & MNG_DESCR_EMPTYGLOBAL)))
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+    }
+  }
+
+  if (pDescr->pSpecialfunc)            /* need special processing ? */
+  {
+    iRetcode = create_chunk_storage (pData, pHeader, iRawlen, pRawdata,
+                                     pField, iFields, ppChunk, MNG_TRUE);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* empty indicator ? */
+    if ((!iRawlen) && (pDescr->iOffsetempty))
+      *(((mng_uint8p)*ppChunk)+pDescr->iOffsetempty) = MNG_TRUE;
+
+    iRetcode = pDescr->pSpecialfunc(pData, *ppChunk);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    if ((((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_IDAT) ||
+        (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_JDAT) ||
+        (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_JDAA)    )
+    {
+      iRetcode = ((mng_chunk_headerp)*ppChunk)->fCleanup (pData, *ppChunk);
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+      *ppChunk = MNG_NULL;
+    } else {
+#ifdef MNG_STORE_CHUNKS
+      if (!pData->bStorechunks)
+#endif
+      {
+        iRetcode = ((mng_chunk_headerp)*ppChunk)->fCleanup (pData, *ppChunk);
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+        *ppChunk = MNG_NULL;
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (iRawlen)
+  {
+#ifdef MNG_OPTIMIZE_DISPLAYCALLS
+    pData->iRawlen  = iRawlen;
+    pData->pRawdata = pRawdata;
+#endif
+
+                                       /* display processing */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    if (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_IDAT)
+      iRetcode = mng_process_display_idat (pData, iRawlen, pRawdata);
+#ifdef MNG_INCLUDE_JNG
+    else
+    if (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_JDAT)
+      iRetcode = mng_process_display_jdat (pData, iRawlen, pRawdata);
+    else
+    if (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_JDAA)
+      iRetcode = mng_process_display_jdaa (pData, iRawlen, pRawdata);
+#endif
+#else
+    if (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_IDAT)
+      iRetcode = mng_process_display_idat (pData);
+#ifdef MNG_INCLUDE_JNG
+    else
+    if (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_JDAT)
+      iRetcode = mng_process_display_jdat (pData);
+    else
+    if (((mng_chunk_headerp)pHeader)->iChunkname == MNG_UINT_JDAA)
+      iRetcode = mng_process_display_jdaa (pData);
+#endif
+#endif
+
+    if (iRetcode)
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if ((pData->bStorechunks) && (!(*ppChunk)))
+  {
+    iRetcode = create_chunk_storage (pData, pHeader, iRawlen, pRawdata,
+                                     pField, iFields, ppChunk, MNG_FALSE);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* empty indicator ? */
+    if ((!iRawlen) && (pDescr->iOffsetempty))
+      *(((mng_uint8p)*ppChunk)+pDescr->iOffsetempty) = MNG_TRUE;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_ihdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IHDR, MNG_LC_START);
+#endif
+
+  if (iRawlen != 13)                   /* length oke ? */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                                       /* only allowed inside PNG or MNG */
+  if ((pData->eSigtype != mng_it_png) && (pData->eSigtype != mng_it_mng))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+                                       /* sequence checks */
+  if ((pData->eSigtype == mng_it_png) && (pData->iChunkseq > 1))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasIDAT) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasIDAT))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  pData->bHasIHDR      = MNG_TRUE;     /* indicate IHDR is present */
+                                       /* and store interesting fields */
+  if ((!pData->bHasDHDR) || (pData->iDeltatype == MNG_DELTATYPE_NOCHANGE))
+  {
+    pData->iDatawidth  = mng_get_uint32 (pRawdata);
+    pData->iDataheight = mng_get_uint32 (pRawdata+4);
+  }
+
+  pData->iBitdepth     = *(pRawdata+8);
+  pData->iColortype    = *(pRawdata+9);
+  pData->iCompression  = *(pRawdata+10);
+  pData->iFilter       = *(pRawdata+11);
+  pData->iInterlace    = *(pRawdata+12);
+
+#if defined(MNG_NO_1_2_4BIT_SUPPORT) || defined(MNG_NO_16BIT_SUPPORT)
+  pData->iPNGmult = 1;
+  pData->iPNGdepth = pData->iBitdepth;
+#endif
+
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+  if (pData->iBitdepth < 8)
+      pData->iBitdepth = 8;
+#endif
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (pData->iBitdepth > 8)
+    {
+      pData->iBitdepth = 8;
+      pData->iPNGmult = 2;
+    }
+#endif
+
+  if ((pData->iBitdepth !=  8)      /* parameter validity checks */
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+      && (pData->iBitdepth !=  1) &&
+      (pData->iBitdepth !=  2) &&
+      (pData->iBitdepth !=  4)
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+      && (pData->iBitdepth != 16)   
+#endif
+      )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if ((pData->iColortype != MNG_COLORTYPE_GRAY   ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGB    ) &&
+      (pData->iColortype != MNG_COLORTYPE_INDEXED) &&
+      (pData->iColortype != MNG_COLORTYPE_GRAYA  ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGBA   )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  if ((pData->iColortype == MNG_COLORTYPE_INDEXED) && (pData->iBitdepth > 8))
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (((pData->iColortype == MNG_COLORTYPE_RGB    ) ||
+       (pData->iColortype == MNG_COLORTYPE_GRAYA  ) ||
+       (pData->iColortype == MNG_COLORTYPE_RGBA   )    ) &&
+      (pData->iBitdepth < 8                            )    )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (pData->iCompression != MNG_COMPRESSION_DEFLATE)
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+#if defined(FILTER192) || defined(FILTER193)
+  if ((pData->iFilter != MNG_FILTER_ADAPTIVE ) &&
+#if defined(FILTER192) && defined(FILTER193)
+      (pData->iFilter != MNG_FILTER_DIFFERING) &&
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#else
+#ifdef FILTER192
+      (pData->iFilter != MNG_FILTER_DIFFERING)    )
+#else
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#endif
+#endif
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#else
+  if (pData->iFilter)
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#endif
+
+  if ((pData->iInterlace != MNG_INTERLACE_NONE ) &&
+      (pData->iInterlace != MNG_INTERLACE_ADAM7)    )
+    MNG_ERROR (pData, MNG_INVALIDINTERLACE);
+
+#ifdef MNG_SUPPORT_DISPLAY 
+#ifndef MNG_NO_DELTA_PNG
+  if (pData->bHasDHDR)                 /* check the colortype for delta-images ! */
+  {
+    mng_imagedatap pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+
+    if (pData->iColortype != pBuf->iColortype)
+    {
+      if ( ( (pData->iColortype != MNG_COLORTYPE_INDEXED) ||
+             (pBuf->iColortype  == MNG_COLORTYPE_GRAY   )    ) &&
+           ( (pData->iColortype != MNG_COLORTYPE_GRAY   ) ||
+             (pBuf->iColortype  == MNG_COLORTYPE_INDEXED)    )    )
+        MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+    }
+  }
+#endif
+#endif
+
+  if (!pData->bHasheader)              /* first chunk ? */
+  {
+    pData->bHasheader = MNG_TRUE;      /* we've got a header */
+    pData->eImagetype = mng_it_png;    /* then this must be a PNG */
+    pData->iWidth     = pData->iDatawidth;
+    pData->iHeight    = pData->iDataheight;
+                                       /* predict alpha-depth ! */
+    if ((pData->iColortype == MNG_COLORTYPE_GRAYA  ) ||
+        (pData->iColortype == MNG_COLORTYPE_RGBA   )    )
+      pData->iAlphadepth = pData->iBitdepth;
+    else
+    if (pData->iColortype == MNG_COLORTYPE_INDEXED)
+      pData->iAlphadepth = 8;          /* worst case scenario */
+    else
+      pData->iAlphadepth = 1;  /* Possible tRNS cheap binary transparency */
+                                       /* fits on maximum canvas ? */
+    if ((pData->iWidth > pData->iMaxwidth) || (pData->iHeight > pData->iMaxheight))
+      MNG_WARNING (pData, MNG_IMAGETOOLARGE);
+
+#if !defined(MNG_INCLUDE_MPNG_PROPOSAL) || !defined(MNG_SUPPORT_DISPLAY)
+    if (pData->fProcessheader)         /* inform the app ? */
+      if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+        MNG_ERROR (pData, MNG_APPMISCERROR);
+#endif        
+  }
+
+  if (!pData->bHasDHDR)
+    pData->iImagelevel++;              /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode = mng_process_display_ihdr (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* fill the fields */
+    ((mng_ihdrp)*ppChunk)->iWidth       = mng_get_uint32 (pRawdata);
+    ((mng_ihdrp)*ppChunk)->iHeight      = mng_get_uint32 (pRawdata+4);
+    ((mng_ihdrp)*ppChunk)->iBitdepth    = pData->iBitdepth;
+    ((mng_ihdrp)*ppChunk)->iColortype   = pData->iColortype;
+    ((mng_ihdrp)*ppChunk)->iCompression = pData->iCompression;
+    ((mng_ihdrp)*ppChunk)->iFilter      = pData->iFilter;
+    ((mng_ihdrp)*ppChunk)->iInterlace   = pData->iInterlace;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_plte)
+{
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  mng_uint32  iX;
+  mng_uint8p  pRawdata2;
+#endif
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_uint32  iRawlen2;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PLTE, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasJHDR))
+#else
+  if (pData->bHasIDAT)
+#endif  
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* multiple PLTE only inside BASI */
+  if ((pData->bHasPLTE) && (!pData->bHasBASI))
+    MNG_ERROR (pData, MNG_MULTIPLEERROR);
+                                       /* length must be multiple of 3 */
+  if (((iRawlen % 3) != 0) || (iRawlen > 768))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {                                    /* only allowed for indexed-color or
+                                          rgb(a)-color! */
+    if ((pData->iColortype != 2) && (pData->iColortype != 3) && (pData->iColortype != 6))
+      MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+                                       /* empty only allowed if global present */
+    if ((iRawlen == 0) && (!pData->bHasglobalPLTE))
+        MNG_ERROR (pData, MNG_CANNOTBEEMPTY);
+  }
+  else
+  {
+    if (iRawlen == 0)                  /* cannot be empty as global! */
+      MNG_ERROR (pData, MNG_CANNOTBEEMPTY);
+  }
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+    pData->bHasPLTE = MNG_TRUE;        /* got it! */
+  else
+    pData->bHasglobalPLTE = MNG_TRUE;
+
+  pData->iPLTEcount = iRawlen / 3;  
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    mng_imagep     pImage;
+    mng_imagedatap pBuf;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* processing delta-image ? */
+    {                                  /* store in object 0 !!! */
+      pImage           = (mng_imagep)pData->pObjzero;
+      pBuf             = pImage->pImgbuf;
+      pBuf->bHasPLTE   = MNG_TRUE;     /* it's definitely got a PLTE now */
+      pBuf->iPLTEcount = iRawlen / 3;  /* this is the exact length */
+      pRawdata2        = pRawdata;     /* copy the entries */
+
+      for (iX = 0; iX < iRawlen / 3; iX++)
+      {
+        pBuf->aPLTEentries[iX].iRed   = *pRawdata2;
+        pBuf->aPLTEentries[iX].iGreen = *(pRawdata2+1);
+        pBuf->aPLTEentries[iX].iBlue  = *(pRawdata2+2);
+
+        pRawdata2 += 3;
+      }
+    }
+    else
+#endif
+    {                                  /* get the current object */
+      pImage = (mng_imagep)pData->pCurrentobj;
+
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+
+      pBuf = pImage->pImgbuf;          /* address the object buffer */
+      pBuf->bHasPLTE = MNG_TRUE;       /* and tell it it's got a PLTE now */
+
+      if (!iRawlen)                    /* if empty, inherit from global */
+      {
+        pBuf->iPLTEcount = pData->iGlobalPLTEcount;
+        MNG_COPY (pBuf->aPLTEentries, pData->aGlobalPLTEentries,
+                  sizeof (pBuf->aPLTEentries));
+
+        if (pData->bHasglobalTRNS)     /* also copy global tRNS ? */
+        {                              /* indicate tRNS available */
+          pBuf->bHasTRNS = MNG_TRUE;
+
+          iRawlen2  = pData->iGlobalTRNSrawlen;
+          pRawdata2 = (mng_uint8p)(pData->aGlobalTRNSrawdata);
+                                       /* global length oke ? */
+          if ((iRawlen2 == 0) || (iRawlen2 > pBuf->iPLTEcount))
+            MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+                                       /* copy it */
+          pBuf->iTRNScount = iRawlen2;
+          MNG_COPY (pBuf->aTRNSentries, pRawdata2, iRawlen2);
+        }
+      }
+      else
+      {                                /* store fields for future reference */
+        pBuf->iPLTEcount = iRawlen / 3;
+        pRawdata2        = pRawdata;
+
+        for (iX = 0; iX < pBuf->iPLTEcount; iX++)
+        {
+          pBuf->aPLTEentries[iX].iRed   = *pRawdata2;
+          pBuf->aPLTEentries[iX].iGreen = *(pRawdata2+1);
+          pBuf->aPLTEentries[iX].iBlue  = *(pRawdata2+2);
+
+          pRawdata2 += 3;
+        }
+      }
+    }
+  }
+  else                                 /* store as global */
+  {
+    pData->iGlobalPLTEcount = iRawlen / 3;
+    pRawdata2               = pRawdata;
+
+    for (iX = 0; iX < pData->iGlobalPLTEcount; iX++)
+    {
+      pData->aGlobalPLTEentries[iX].iRed   = *pRawdata2;
+      pData->aGlobalPLTEentries[iX].iGreen = *(pRawdata2+1);
+      pData->aGlobalPLTEentries[iX].iBlue  = *(pRawdata2+2);
+
+      pRawdata2 += 3;
+    }
+
+    {                                  /* create an animation object */
+      mng_retcode iRetcode = mng_create_ani_plte (pData, pData->iGlobalPLTEcount,
+                                                  pData->aGlobalPLTEentries);
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_pltep)*ppChunk)->bEmpty      = (mng_bool)(iRawlen == 0);
+    ((mng_pltep)*ppChunk)->iEntrycount = iRawlen / 3;
+    pRawdata2                          = pRawdata;
+
+    for (iX = 0; iX < ((mng_pltep)*ppChunk)->iEntrycount; iX++)
+    {
+      ((mng_pltep)*ppChunk)->aEntries[iX].iRed   = *pRawdata2;
+      ((mng_pltep)*ppChunk)->aEntries[iX].iGreen = *(pRawdata2+1);
+      ((mng_pltep)*ppChunk)->aEntries[iX].iBlue  = *(pRawdata2+2);
+
+      pRawdata2 += 3;
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_idat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IDAT, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_JNG                 /* sequence checks */
+  if ((!pData->bHasIHDR) && (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasIHDR) && (!pData->bHasBASI) && (!pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasJHDR) &&
+      (pData->iJHDRalphacompression != MNG_COMPRESSION_DEFLATE))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (pData->bHasJSEP)
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+#endif
+                                       /* not allowed for deltatype NO_CHANGE */
+#ifndef MNG_NO_DELTA_PNG
+  if ((pData->bHasDHDR) && ((pData->iDeltatype == MNG_DELTATYPE_NOCHANGE)))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+#endif
+                                       /* can only be empty in BASI-block! */
+  if ((iRawlen == 0) && (!pData->bHasBASI))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                                       /* indexed-color requires PLTE */
+  if ((pData->bHasIHDR) && (pData->iColortype == 3) && (!pData->bHasPLTE))
+    MNG_ERROR (pData, MNG_PLTEMISSING);
+
+  pData->bHasIDAT = MNG_TRUE;          /* got some IDAT now, don't we */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (iRawlen)
+  {                                    /* display processing */
+    mng_retcode iRetcode = mng_process_display_idat (pData, iRawlen, pRawdata);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_idatp)*ppChunk)->bEmpty    = (mng_bool)(iRawlen == 0);
+    ((mng_idatp)*ppChunk)->iDatasize = iRawlen;
+
+    if (iRawlen != 0)                  /* is there any data ? */
+    {
+      MNG_ALLOC (pData, ((mng_idatp)*ppChunk)->pData, iRawlen);
+      MNG_COPY  (((mng_idatp)*ppChunk)->pData, pRawdata, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_iend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IEND, MNG_LC_START);
+#endif
+
+  if (iRawlen > 0)                     /* must not contain data! */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_INCLUDE_JNG                 /* sequence checks */
+  if ((!pData->bHasIHDR) && (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasIHDR) && (!pData->bHasBASI) && (!pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* IHDR-block requires IDAT */
+  if ((pData->bHasIHDR) && (!pData->bHasIDAT))
+    MNG_ERROR (pData, MNG_IDATMISSING);
+
+  pData->iImagelevel--;                /* one level up */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create an animation object */
+    mng_retcode iRetcode = mng_create_ani_image (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* display processing */
+    iRetcode = mng_process_display_iend (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (!pData->bTimerset)               /* reset only if not broken !!! */
+  {
+#endif
+                                       /* IEND signals the end for most ... */
+    pData->bHasIHDR         = MNG_FALSE;
+    pData->bHasBASI         = MNG_FALSE;
+    pData->bHasDHDR         = MNG_FALSE;
+#ifdef MNG_INCLUDE_JNG
+    pData->bHasJHDR         = MNG_FALSE;
+    pData->bHasJSEP         = MNG_FALSE;
+    pData->bHasJDAA         = MNG_FALSE;
+    pData->bHasJDAT         = MNG_FALSE;
+#endif
+    pData->bHasPLTE         = MNG_FALSE;
+    pData->bHasTRNS         = MNG_FALSE;
+    pData->bHasGAMA         = MNG_FALSE;
+    pData->bHasCHRM         = MNG_FALSE;
+    pData->bHasSRGB         = MNG_FALSE;
+    pData->bHasICCP         = MNG_FALSE;
+    pData->bHasBKGD         = MNG_FALSE;
+    pData->bHasIDAT         = MNG_FALSE;
+#ifdef MNG_SUPPORT_DISPLAY
+  }
+#endif
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_trns)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TRNS, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasJHDR))
+#else
+  if (pData->bHasIDAT)
+#endif  
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* multiple tRNS only inside BASI */
+  if ((pData->bHasTRNS) && (!pData->bHasBASI))
+    MNG_ERROR (pData, MNG_MULTIPLEERROR);
+
+  if (iRawlen > 256)                   /* it just can't be bigger than that! */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {                                    /* not allowed with full alpha-channel */
+    if ((pData->iColortype == 4) || (pData->iColortype == 6))
+      MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+
+    if (iRawlen != 0)                  /* filled ? */
+    {                                  /* length checks */
+      if ((pData->iColortype == 0) && (iRawlen != 2))
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+      if ((pData->iColortype == 2) && (iRawlen != 6))
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+      if (pData->iColortype == 3)
+      {
+        mng_imagep     pImage = (mng_imagep)pData->pCurrentobj;
+        mng_imagedatap pBuf;
+
+        if (!pImage)                   /* no object then check obj 0 */
+          pImage = (mng_imagep)pData->pObjzero;
+
+        pBuf = pImage->pImgbuf;        /* address object buffer */
+
+        if (iRawlen > pBuf->iPLTEcount)
+          MNG_ERROR (pData, MNG_INVALIDLENGTH);
+      }
+#endif
+    }
+    else                               /* if empty there must be global stuff! */
+    {
+      if (!pData->bHasglobalTRNS)
+        MNG_ERROR (pData, MNG_CANNOTBEEMPTY);
+    }
+  }
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+    pData->bHasTRNS = MNG_TRUE;        /* indicate tRNS available */
+  else
+    pData->bHasglobalTRNS = MNG_TRUE;
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    mng_imagep     pImage;
+    mng_imagedatap pBuf;
+    mng_uint8p     pRawdata2;
+    mng_uint32     iRawlen2;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* processing delta-image ? */
+    {                                  /* store in object 0 !!! */
+      pImage = (mng_imagep)pData->pObjzero;
+      pBuf   = pImage->pImgbuf;        /* address object buffer */
+
+      switch (pData->iColortype)       /* store fields for future reference */
+      {
+        case 0: {                      /* gray */
+#if defined(MNG_NO_1_2_4BIT_SUPPORT)
+                  mng_uint8 multiplier[]={0,255,85,0,17,0,0,0,1,
+                                          0,0,0,0,0,0,0,1};
+#endif
+                  pBuf->iTRNSgray  = mng_get_uint16 (pRawdata);
+                  pBuf->iTRNSred   = 0;
+                  pBuf->iTRNSgreen = 0;
+                  pBuf->iTRNSblue  = 0;
+                  pBuf->iTRNScount = 0;
+#if defined(MNG_NO_1_2_4BIT_SUPPORT)
+                  pBuf->iTRNSgray *= multiplier[pData->iPNGdepth];
+#endif
+#if defined(MNG_NO_16BIT_SUPPORT)
+                  if (pData->iPNGmult == 2)
+                     pBuf->iTRNSgray >>= 8;
+#endif
+                  break;
+                }
+        case 2: {                      /* rgb */
+                  pBuf->iTRNSgray  = 0;
+                  pBuf->iTRNSred   = mng_get_uint16 (pRawdata);
+                  pBuf->iTRNSgreen = mng_get_uint16 (pRawdata+2);
+                  pBuf->iTRNSblue  = mng_get_uint16 (pRawdata+4);
+                  pBuf->iTRNScount = 0;
+#if defined(MNG_NO_16BIT_SUPPORT)
+                  if (pData->iPNGmult == 2)
+                  {
+                     pBuf->iTRNSred   >>= 8;
+                     pBuf->iTRNSgreen >>= 8;
+                     pBuf->iTRNSblue  >>= 8;
+                  }
+#endif
+                  break;
+                }
+        case 3: {                      /* indexed */
+                  pBuf->iTRNSgray  = 0;
+                  pBuf->iTRNSred   = 0;
+                  pBuf->iTRNSgreen = 0;
+                  pBuf->iTRNSblue  = 0;
+                  pBuf->iTRNScount = iRawlen;
+                  MNG_COPY (pBuf->aTRNSentries, pRawdata, iRawlen);
+                  break;
+                }
+      }
+
+      pBuf->bHasTRNS = MNG_TRUE;       /* tell it it's got a tRNS now */
+    }
+    else
+#endif
+    {                                  /* address current object */
+      pImage = (mng_imagep)pData->pCurrentobj;
+
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+
+      pBuf = pImage->pImgbuf;          /* address object buffer */
+      pBuf->bHasTRNS = MNG_TRUE;       /* and tell it it's got a tRNS now */
+
+      if (iRawlen == 0)                /* if empty, inherit from global */
+      {
+        iRawlen2  = pData->iGlobalTRNSrawlen;
+        pRawdata2 = (mng_ptr)(pData->aGlobalTRNSrawdata);
+                                         /* global length oke ? */
+        if ((pData->iColortype == 0) && (iRawlen2 != 2))
+          MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+
+        if ((pData->iColortype == 2) && (iRawlen2 != 6))
+          MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+
+        if ((pData->iColortype == 3) && ((iRawlen2 == 0) || (iRawlen2 > pBuf->iPLTEcount)))
+          MNG_ERROR (pData, MNG_GLOBALLENGTHERR);
+      }
+      else
+      {
+        iRawlen2  = iRawlen;
+        pRawdata2 = pRawdata;
+      }
+
+      switch (pData->iColortype)        /* store fields for future reference */
+      {
+        case 0: {                      /* gray */
+                  pBuf->iTRNSgray  = mng_get_uint16 (pRawdata2);
+                  pBuf->iTRNSred   = 0;
+                  pBuf->iTRNSgreen = 0;
+                  pBuf->iTRNSblue  = 0;
+                  pBuf->iTRNScount = 0;
+#if defined(MNG_NO_16BIT_SUPPORT)
+                  if (pData->iPNGmult == 2)
+                     pBuf->iTRNSgray >>= 8;
+#endif
+                  break;
+                }
+        case 2: {                      /* rgb */
+                  pBuf->iTRNSgray  = 0;
+                  pBuf->iTRNSred   = mng_get_uint16 (pRawdata2);
+                  pBuf->iTRNSgreen = mng_get_uint16 (pRawdata2+2);
+                  pBuf->iTRNSblue  = mng_get_uint16 (pRawdata2+4);
+                  pBuf->iTRNScount = 0;
+#if defined(MNG_NO_16BIT_SUPPORT)
+                  if (pData->iPNGmult == 2)
+                  {
+                     pBuf->iTRNSred   >>= 8;
+                     pBuf->iTRNSgreen >>= 8;
+                     pBuf->iTRNSblue  >>= 8;
+                  }
+#endif
+                  break;
+                }
+        case 3: {                      /* indexed */
+                  pBuf->iTRNSgray  = 0;
+                  pBuf->iTRNSred   = 0;
+                  pBuf->iTRNSgreen = 0;
+                  pBuf->iTRNSblue  = 0;
+                  pBuf->iTRNScount = iRawlen2;
+                  MNG_COPY (pBuf->aTRNSentries, pRawdata2, iRawlen2);
+                  break;
+                }
+      }
+    }  
+  }
+  else                                 /* store as global */
+  {
+    pData->iGlobalTRNSrawlen = iRawlen;
+    MNG_COPY (pData->aGlobalTRNSrawdata, pRawdata, iRawlen);
+
+    {                                  /* create an animation object */
+      mng_retcode iRetcode = mng_create_ani_trns (pData, pData->iGlobalTRNSrawlen,
+                                                  pData->aGlobalTRNSrawdata);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+    {                                  /* not global! */
+      ((mng_trnsp)*ppChunk)->bGlobal  = MNG_FALSE;
+      ((mng_trnsp)*ppChunk)->iType    = pData->iColortype;
+
+      if (iRawlen == 0)                /* if empty, indicate so */
+        ((mng_trnsp)*ppChunk)->bEmpty = MNG_TRUE;
+      else
+      {
+        ((mng_trnsp)*ppChunk)->bEmpty = MNG_FALSE;
+
+        switch (pData->iColortype)     /* store fields */
+        {
+          case 0: {                    /* gray */
+                    ((mng_trnsp)*ppChunk)->iGray  = mng_get_uint16 (pRawdata);
+                    break;
+                  }
+          case 2: {                    /* rgb */
+                    ((mng_trnsp)*ppChunk)->iRed   = mng_get_uint16 (pRawdata);
+                    ((mng_trnsp)*ppChunk)->iGreen = mng_get_uint16 (pRawdata+2);
+                    ((mng_trnsp)*ppChunk)->iBlue  = mng_get_uint16 (pRawdata+4);
+                    break;
+                  }
+          case 3: {                    /* indexed */
+                    ((mng_trnsp)*ppChunk)->iCount = iRawlen;
+                    MNG_COPY (((mng_trnsp)*ppChunk)->aEntries, pRawdata, iRawlen);
+                    break;
+                  }
+        }
+      }
+    }
+    else                               /* it's global! */
+    {
+      ((mng_trnsp)*ppChunk)->bEmpty  = (mng_bool)(iRawlen == 0);
+      ((mng_trnsp)*ppChunk)->bGlobal = MNG_TRUE;
+      ((mng_trnsp)*ppChunk)->iType   = 0;
+      ((mng_trnsp)*ppChunk)->iRawlen = iRawlen;
+
+      MNG_COPY (((mng_trnsp)*ppChunk)->aRawdata, pRawdata, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_gama)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_GAMA, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasPLTE) || (pData->bHasJDAT) || (pData->bHasJDAA))
+#else
+  if ((pData->bHasIDAT) || (pData->bHasPLTE))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {                                    /* length must be exactly 4 */
+    if (iRawlen != 4)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+  {                                    /* length must be empty or exactly 4 */
+    if ((iRawlen != 0) && (iRawlen != 4))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasGAMA = MNG_TRUE;        /* indicate we've got it */
+  else
+    pData->bHasglobalGAMA = (mng_bool)(iRawlen != 0);
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {
+    mng_imagep pImage;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* update delta image ? */
+    {                                  /* store in object 0 ! */
+      pImage = (mng_imagep)pData->pObjzero;
+                                       /* store for color-processing routines */
+      pImage->pImgbuf->iGamma   = mng_get_uint32 (pRawdata);
+      pImage->pImgbuf->bHasGAMA = MNG_TRUE;
+    }
+    else
+#endif
+    {
+      pImage = (mng_imagep)pData->pCurrentobj;
+
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+                                       /* store for color-processing routines */
+      pImage->pImgbuf->iGamma   = mng_get_uint32 (pRawdata);
+      pImage->pImgbuf->bHasGAMA = MNG_TRUE;
+    }
+  }
+  else
+  {                                    /* store as global */
+    if (iRawlen != 0)
+      pData->iGlobalGamma = mng_get_uint32 (pRawdata);
+
+    {                                  /* create an animation object */
+      mng_retcode iRetcode = mng_create_ani_gama (pData, (mng_bool)(iRawlen == 0),
+                                                  pData->iGlobalGamma);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_gamap)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+      ((mng_gamap)*ppChunk)->iGamma = mng_get_uint32 (pRawdata);
+
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_cHRM
+READ_CHUNK (mng_read_chrm)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CHRM, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasPLTE) || (pData->bHasJDAT) || (pData->bHasJDAA))
+#else
+  if ((pData->bHasIDAT) || (pData->bHasPLTE))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {                                    /* length must be exactly 32 */
+    if (iRawlen != 32)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+  {                                    /* length must be empty or exactly 32 */
+    if ((iRawlen != 0) && (iRawlen != 32))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasCHRM = MNG_TRUE;        /* indicate we've got it */
+  else
+    pData->bHasglobalCHRM = (mng_bool)(iRawlen != 0);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_uint32 iWhitepointx,   iWhitepointy;
+    mng_uint32 iPrimaryredx,   iPrimaryredy;
+    mng_uint32 iPrimarygreenx, iPrimarygreeny;
+    mng_uint32 iPrimarybluex,  iPrimarybluey;
+
+    iWhitepointx   = mng_get_uint32 (pRawdata);
+    iWhitepointy   = mng_get_uint32 (pRawdata+4);
+    iPrimaryredx   = mng_get_uint32 (pRawdata+8);
+    iPrimaryredy   = mng_get_uint32 (pRawdata+12);
+    iPrimarygreenx = mng_get_uint32 (pRawdata+16);
+    iPrimarygreeny = mng_get_uint32 (pRawdata+20);
+    iPrimarybluex  = mng_get_uint32 (pRawdata+24);
+    iPrimarybluey  = mng_get_uint32 (pRawdata+28);
+
+#ifdef MNG_INCLUDE_JNG
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    {
+      mng_imagep     pImage;
+      mng_imagedatap pBuf;
+
+#ifndef MNG_NO_DELTA_PNG
+      if (pData->bHasDHDR)             /* update delta image ? */
+      {                                /* store it in object 0 ! */
+        pImage = (mng_imagep)pData->pObjzero;
+
+        pBuf = pImage->pImgbuf;        /* address object buffer */
+        pBuf->bHasCHRM = MNG_TRUE;     /* and tell it it's got a CHRM now */
+                                       /* store for color-processing routines */
+        pBuf->iWhitepointx   = iWhitepointx;
+        pBuf->iWhitepointy   = iWhitepointy;
+        pBuf->iPrimaryredx   = iPrimaryredx;
+        pBuf->iPrimaryredy   = iPrimaryredy;
+        pBuf->iPrimarygreenx = iPrimarygreenx;
+        pBuf->iPrimarygreeny = iPrimarygreeny;
+        pBuf->iPrimarybluex  = iPrimarybluex;
+        pBuf->iPrimarybluey  = iPrimarybluey;
+      }
+      else
+#endif
+      {
+        pImage = (mng_imagep)pData->pCurrentobj;
+
+        if (!pImage)                   /* no object then dump it in obj 0 */
+          pImage = (mng_imagep)pData->pObjzero;
+
+        pBuf = pImage->pImgbuf;        /* address object buffer */
+        pBuf->bHasCHRM = MNG_TRUE;     /* and tell it it's got a CHRM now */
+                                       /* store for color-processing routines */
+        pBuf->iWhitepointx   = iWhitepointx;
+        pBuf->iWhitepointy   = iWhitepointy;
+        pBuf->iPrimaryredx   = iPrimaryredx;
+        pBuf->iPrimaryredy   = iPrimaryredy;
+        pBuf->iPrimarygreenx = iPrimarygreenx;
+        pBuf->iPrimarygreeny = iPrimarygreeny;
+        pBuf->iPrimarybluex  = iPrimarybluex;
+        pBuf->iPrimarybluey  = iPrimarybluey;
+      }
+    }
+    else
+    {                                  /* store as global */
+      if (iRawlen != 0)
+      {
+        pData->iGlobalWhitepointx   = iWhitepointx;
+        pData->iGlobalWhitepointy   = iWhitepointy;
+        pData->iGlobalPrimaryredx   = iPrimaryredx;
+        pData->iGlobalPrimaryredy   = iPrimaryredy;
+        pData->iGlobalPrimarygreenx = iPrimarygreenx;
+        pData->iGlobalPrimarygreeny = iPrimarygreeny;
+        pData->iGlobalPrimarybluex  = iPrimarybluex;
+        pData->iGlobalPrimarybluey  = iPrimarybluey;
+      }
+
+      {                                /* create an animation object */
+        mng_retcode iRetcode = mng_create_ani_chrm (pData, (mng_bool)(iRawlen == 0),
+                                                    iWhitepointx,   iWhitepointy,
+                                                    iPrimaryredx,   iPrimaryredy,
+                                                    iPrimarygreenx, iPrimarygreeny,
+                                                    iPrimarybluex,  iPrimarybluey);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_chrmp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+    {
+      ((mng_chrmp)*ppChunk)->iWhitepointx = mng_get_uint32 (pRawdata);
+      ((mng_chrmp)*ppChunk)->iWhitepointy = mng_get_uint32 (pRawdata+4);
+      ((mng_chrmp)*ppChunk)->iRedx        = mng_get_uint32 (pRawdata+8);
+      ((mng_chrmp)*ppChunk)->iRedy        = mng_get_uint32 (pRawdata+12);
+      ((mng_chrmp)*ppChunk)->iGreenx      = mng_get_uint32 (pRawdata+16);
+      ((mng_chrmp)*ppChunk)->iGreeny      = mng_get_uint32 (pRawdata+20);
+      ((mng_chrmp)*ppChunk)->iBluex       = mng_get_uint32 (pRawdata+24);
+      ((mng_chrmp)*ppChunk)->iBluey       = mng_get_uint32 (pRawdata+28);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_srgb)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SRGB, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasPLTE) || (pData->bHasJDAT) || (pData->bHasJDAA))
+#else
+  if ((pData->bHasIDAT) || (pData->bHasPLTE))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {                                    /* length must be exactly 1 */
+    if (iRawlen != 1)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+  {                                    /* length must be empty or exactly 1 */
+    if ((iRawlen != 0) && (iRawlen != 1))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasSRGB = MNG_TRUE;        /* indicate we've got it */
+  else
+    pData->bHasglobalSRGB = (mng_bool)(iRawlen != 0);
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {
+    mng_imagep pImage;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* update delta image ? */
+    {                                  /* store in object 0 ! */
+      pImage = (mng_imagep)pData->pObjzero;
+                                       /* store for color-processing routines */
+      pImage->pImgbuf->iRenderingintent = *pRawdata;
+      pImage->pImgbuf->bHasSRGB         = MNG_TRUE;
+    }
+    else
+#endif
+    {
+      pImage = (mng_imagep)pData->pCurrentobj;
+
+      if (!pImage)                     /* no object then dump it in obj 0 */
+        pImage = (mng_imagep)pData->pObjzero;
+                                       /* store for color-processing routines */
+      pImage->pImgbuf->iRenderingintent = *pRawdata;
+      pImage->pImgbuf->bHasSRGB         = MNG_TRUE;
+    }
+  }
+  else
+  {                                    /* store as global */
+    if (iRawlen != 0)
+      pData->iGlobalRendintent = *pRawdata;
+
+    {                                  /* create an animation object */
+      mng_retcode iRetcode = mng_create_ani_srgb (pData, (mng_bool)(iRawlen == 0),
+                                                  pData->iGlobalRendintent);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_srgbp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+      ((mng_srgbp)*ppChunk)->iRenderingintent = *pRawdata;
+
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_iCCP
+READ_CHUNK (mng_read_iccp)
+{
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint32  iCompressedsize;
+  mng_uint32  iProfilesize;
+  mng_uint32  iBufsize = 0;
+  mng_uint8p  pBuf = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ICCP, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasPLTE) || (pData->bHasJDAT) || (pData->bHasJDAA))
+#else
+  if ((pData->bHasIDAT) || (pData->bHasPLTE))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+  {                                    /* length must be at least 2 */
+    if (iRawlen < 2)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+  {                                    /* length must be empty or at least 2 */
+    if ((iRawlen != 0) && (iRawlen < 2))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+
+  pTemp = find_null (pRawdata);        /* find null-separator */
+                                       /* not found inside input-data ? */
+  if ((pTemp - pRawdata) > (mng_int32)iRawlen)
+    MNG_ERROR (pData, MNG_NULLNOTFOUND);
+                                       /* determine size of compressed profile */
+  iCompressedsize = (mng_uint32)(iRawlen - (pTemp - pRawdata) - 2);
+                                       /* decompress the profile */
+  iRetcode = mng_inflate_buffer (pData, pTemp+2, iCompressedsize,
+                                 &pBuf, &iBufsize, &iProfilesize);
+
+#ifdef MNG_CHECK_BAD_ICCP              /* Check for bad iCCP chunk */
+  if ((iRetcode) && (!strncmp ((char *)pRawdata, "Photoshop ICC profile", 21)))
+  {
+    if (iRawlen == 2615)               /* is it the sRGB profile ? */
+    {
+      mng_chunk_header chunk_srgb =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+        {MNG_UINT_sRGB, mng_init_general, mng_free_general, mng_read_srgb, mng_write_srgb, mng_assign_general, 0, 0, sizeof(mng_srgb)};
+#else
+        {MNG_UINT_sRGB, mng_init_srgb, mng_free_srgb, mng_read_srgb, mng_write_srgb, mng_assign_srgb, 0, 0};
+#endif
+                                       /* pretend it's an sRGB chunk then ! */
+      iRetcode = mng_read_srgb (pData, &chunk_srgb, 1, (mng_ptr)"0", ppChunk);
+
+      if (iRetcode)                    /* on error bail out */
+      {                                /* don't forget to drop the temp buffer */
+        MNG_FREEX (pData, pBuf, iBufsize);
+        return iRetcode;
+      }
+    }
+  }
+  else
+  {
+#endif /* MNG_CHECK_BAD_ICCP */
+
+    if (iRetcode)                      /* on error bail out */
+    {                                  /* don't forget to drop the temp buffer */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+
+#ifdef MNG_INCLUDE_JNG
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+      pData->bHasICCP = MNG_TRUE;      /* indicate we've got it */
+    else
+      pData->bHasglobalICCP = (mng_bool)(iRawlen != 0);
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifdef MNG_INCLUDE_JNG
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+    if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    {
+      mng_imagep pImage;
+
+#ifndef MNG_NO_DELTA_PNG
+      if (pData->bHasDHDR)             /* update delta image ? */
+      {                                /* store in object 0 ! */
+        pImage = (mng_imagep)pData->pObjzero;
+
+        if (pImage->pImgbuf->pProfile) /* profile existed ? */
+          MNG_FREEX (pData, pImage->pImgbuf->pProfile, pImage->pImgbuf->iProfilesize);
+                                       /* allocate a buffer & copy it */
+        MNG_ALLOC (pData, pImage->pImgbuf->pProfile, iProfilesize);
+        MNG_COPY  (pImage->pImgbuf->pProfile, pBuf, iProfilesize);
+                                       /* store its length as well */
+        pImage->pImgbuf->iProfilesize = iProfilesize;
+        pImage->pImgbuf->bHasICCP     = MNG_TRUE;
+      }
+      else
+#endif
+      {
+        pImage = (mng_imagep)pData->pCurrentobj;
+
+        if (!pImage)                   /* no object then dump it in obj 0 */
+          pImage = (mng_imagep)pData->pObjzero;
+
+        if (pImage->pImgbuf->pProfile) /* profile existed ? */
+          MNG_FREEX (pData, pImage->pImgbuf->pProfile, pImage->pImgbuf->iProfilesize);
+                                       /* allocate a buffer & copy it */
+        MNG_ALLOC (pData, pImage->pImgbuf->pProfile, iProfilesize);
+        MNG_COPY  (pImage->pImgbuf->pProfile, pBuf, iProfilesize);
+                                       /* store its length as well */
+        pImage->pImgbuf->iProfilesize = iProfilesize;
+        pImage->pImgbuf->bHasICCP     = MNG_TRUE;
+      }
+    }
+    else
+    {                                  /* store as global */
+      if (iRawlen == 0)                /* empty chunk ? */
+      {
+        if (pData->pGlobalProfile)     /* did we have a global profile ? */
+          MNG_FREEX (pData, pData->pGlobalProfile, pData->iGlobalProfilesize);
+
+        pData->iGlobalProfilesize = 0; /* reset to null */
+        pData->pGlobalProfile     = MNG_NULL;
+      }
+      else
+      {                                /* allocate a global buffer & copy it */
+        MNG_ALLOC (pData, pData->pGlobalProfile, iProfilesize);
+        MNG_COPY  (pData->pGlobalProfile, pBuf, iProfilesize);
+                                       /* store its length as well */
+        pData->iGlobalProfilesize = iProfilesize;
+      }
+
+                                       /* create an animation object */
+      iRetcode = mng_create_ani_iccp (pData, (mng_bool)(iRawlen == 0),
+                                      pData->iGlobalProfilesize,
+                                      pData->pGlobalProfile);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+    if (pData->bStorechunks)
+    {                                  /* initialize storage */
+      iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+      if (iRetcode)                    /* on error bail out */
+      {                                /* don't forget to drop the temp buffer */
+        MNG_FREEX (pData, pBuf, iBufsize);
+        return iRetcode;
+      }
+                                       /* store the fields */
+      ((mng_iccpp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+      if (iRawlen)                     /* not empty ? */
+      {
+        if (!pBuf)                     /* hasn't been unpuzzled it yet ? */
+        {                              /* find null-separator */
+          pTemp = find_null (pRawdata);
+                                       /* not found inside input-data ? */
+          if ((pTemp - pRawdata) > (mng_int32)iRawlen)
+            MNG_ERROR (pData, MNG_NULLNOTFOUND);
+                                       /* determine size of compressed profile */
+          iCompressedsize = iRawlen - (pTemp - pRawdata) - 2;
+                                       /* decompress the profile */
+          iRetcode = mng_inflate_buffer (pData, pTemp+2, iCompressedsize,
+                                         &pBuf, &iBufsize, &iProfilesize);
+
+          if (iRetcode)                /* on error bail out */
+          {                            /* don't forget to drop the temp buffer */
+            MNG_FREEX (pData, pBuf, iBufsize);
+            return iRetcode;
+          }
+        }
+
+        ((mng_iccpp)*ppChunk)->iNamesize = (mng_uint32)(pTemp - pRawdata);
+
+        if (((mng_iccpp)*ppChunk)->iNamesize)
+        {
+          MNG_ALLOC (pData, ((mng_iccpp)*ppChunk)->zName,
+                            ((mng_iccpp)*ppChunk)->iNamesize + 1);
+          MNG_COPY  (((mng_iccpp)*ppChunk)->zName, pRawdata,
+                     ((mng_iccpp)*ppChunk)->iNamesize);
+        }
+
+        ((mng_iccpp)*ppChunk)->iCompression = *(pTemp+1);
+        ((mng_iccpp)*ppChunk)->iProfilesize = iProfilesize;
+
+        MNG_ALLOC (pData, ((mng_iccpp)*ppChunk)->pProfile, iProfilesize);
+        MNG_COPY  (((mng_iccpp)*ppChunk)->pProfile, pBuf, iProfilesize);
+      }
+    }
+#endif /* MNG_STORE_CHUNKS */
+
+    if (pBuf)                          /* free the temporary buffer */
+      MNG_FREEX (pData, pBuf, iBufsize);
+
+#ifdef MNG_CHECK_BAD_ICCP
+  }
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_tEXt
+READ_CHUNK (mng_read_text)
+{
+  mng_uint32 iKeywordlen, iTextlen;
+  mng_pchar  zKeyword, zText;
+  mng_uint8p pTemp;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TEXT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 2)                     /* length must be at least 2 */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pTemp = find_null (pRawdata);        /* find the null separator */
+                                       /* not found inside input-data ? */
+  if ((pTemp - pRawdata) > (mng_int32)iRawlen)
+    MNG_ERROR (pData, MNG_NULLNOTFOUND);
+
+  if (pTemp == pRawdata)               /* there must be at least 1 char for keyword */
+    MNG_ERROR (pData, MNG_KEYWORDNULL);
+
+  iKeywordlen = (mng_uint32)(pTemp - pRawdata);
+  iTextlen    = iRawlen - iKeywordlen - 1;
+
+  if (pData->fProcesstext)             /* inform the application ? */
+  {
+    mng_bool bOke;
+
+    MNG_ALLOC (pData, zKeyword, iKeywordlen + 1);
+    MNG_COPY  (zKeyword, pRawdata, iKeywordlen);
+
+    MNG_ALLOCX (pData, zText, iTextlen + 1);
+
+    if (!zText)                        /* on error bail out */
+    {
+      MNG_FREEX (pData, zKeyword, iKeywordlen + 1);
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+
+    if (iTextlen)
+      MNG_COPY (zText, pTemp+1, iTextlen);
+
+    bOke = pData->fProcesstext ((mng_handle)pData, MNG_TYPE_TEXT, zKeyword, zText, 0, 0);
+
+    MNG_FREEX (pData, zText, iTextlen + 1);
+    MNG_FREEX (pData, zKeyword, iKeywordlen + 1);
+
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+
+  }
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_textp)*ppChunk)->iKeywordsize = iKeywordlen;
+    ((mng_textp)*ppChunk)->iTextsize    = iTextlen;
+
+    if (iKeywordlen)
+    {
+      MNG_ALLOC (pData, ((mng_textp)*ppChunk)->zKeyword, iKeywordlen+1);
+      MNG_COPY  (((mng_textp)*ppChunk)->zKeyword, pRawdata, iKeywordlen);
+    }
+
+    if (iTextlen)
+    {
+      MNG_ALLOC (pData, ((mng_textp)*ppChunk)->zText, iTextlen+1);
+      MNG_COPY  (((mng_textp)*ppChunk)->zText, pTemp+1, iTextlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TEXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_zTXt
+READ_CHUNK (mng_read_ztxt)
+{
+  mng_retcode iRetcode;
+  mng_uint32  iKeywordlen, iTextlen;
+  mng_pchar   zKeyword;
+  mng_uint8p  pTemp;
+  mng_uint32  iCompressedsize;
+  mng_uint32  iBufsize;
+  mng_uint8p  pBuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ZTXT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 3)                     /* length must be at least 3 */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pTemp = find_null (pRawdata);        /* find the null separator */
+                                       /* not found inside input-data ? */
+  if ((pTemp - pRawdata) > (mng_int32)iRawlen)
+    MNG_ERROR (pData, MNG_NULLNOTFOUND);
+
+  if (pTemp == pRawdata)               /* there must be at least 1 char for keyword */
+    MNG_ERROR (pData, MNG_KEYWORDNULL);
+
+  if (*(pTemp+1) != 0)                 /* only deflate compression-method allowed */
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+  iKeywordlen     = (mng_uint32)(pTemp - pRawdata);
+  iCompressedsize = (mng_uint32)(iRawlen - iKeywordlen - 2);
+
+  zKeyword        = 0;                 /* there's no keyword buffer yet */
+  pBuf            = 0;                 /* or a temporary buffer ! */
+
+  if (pData->fProcesstext)             /* inform the application ? */
+  {                                    /* decompress the text */
+    iRetcode = mng_inflate_buffer (pData, pTemp+2, iCompressedsize,
+                                   &pBuf, &iBufsize, &iTextlen);
+
+    if (iRetcode)                      /* on error bail out */
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+
+    MNG_ALLOCX (pData, zKeyword, iKeywordlen+1);
+
+    if (!zKeyword)                     /* on error bail out */
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+
+    MNG_COPY (zKeyword, pRawdata, iKeywordlen);
+
+    if (!pData->fProcesstext ((mng_handle)pData, MNG_TYPE_ZTXT, zKeyword, (mng_pchar)pBuf, 0, 0))
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_FREEX (pData, zKeyword, iKeywordlen+1);
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+    }
+  }
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_FREEX (pData, zKeyword, iKeywordlen+1);
+      return iRetcode;
+    }
+                                       /* store the fields */
+    ((mng_ztxtp)*ppChunk)->iKeywordsize = iKeywordlen;
+    ((mng_ztxtp)*ppChunk)->iCompression = *(pTemp+1);
+
+    if ((!pBuf) && (iCompressedsize))  /* did we not get a text-buffer yet ? */
+    {                                  /* decompress the text */
+      iRetcode = mng_inflate_buffer (pData, pTemp+2, iCompressedsize,
+                                     &pBuf, &iBufsize, &iTextlen);
+
+      if (iRetcode)                    /* on error bail out */
+      {                                /* don't forget to drop the temp buffers */
+        MNG_FREEX (pData, pBuf, iBufsize);
+        MNG_FREEX (pData, zKeyword, iKeywordlen+1);
+        return iRetcode;
+      }
+    }
+
+    MNG_ALLOCX (pData, ((mng_ztxtp)*ppChunk)->zKeyword, iKeywordlen + 1);
+                                       /* on error bail out */
+    if (!((mng_ztxtp)*ppChunk)->zKeyword)
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_FREEX (pData, zKeyword, iKeywordlen+1);
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+
+    MNG_COPY (((mng_ztxtp)*ppChunk)->zKeyword, pRawdata, iKeywordlen);
+
+    ((mng_ztxtp)*ppChunk)->iTextsize = iTextlen;
+
+    if (iCompressedsize)
+    {
+      MNG_ALLOCX (pData, ((mng_ztxtp)*ppChunk)->zText, iTextlen + 1);
+                                       /* on error bail out */
+      if (!((mng_ztxtp)*ppChunk)->zText)
+      {                                /* don't forget to drop the temp buffers */
+        MNG_FREEX (pData, pBuf, iBufsize);
+        MNG_FREEX (pData, zKeyword, iKeywordlen+1);
+        MNG_ERROR (pData, MNG_OUTOFMEMORY);
+      }
+
+      MNG_COPY (((mng_ztxtp)*ppChunk)->zText, pBuf, iTextlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+  MNG_FREEX (pData, pBuf, iBufsize);   /* free the temporary buffers */
+  MNG_FREEX (pData, zKeyword, iKeywordlen+1);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ZTXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_iTXt
+READ_CHUNK (mng_read_itxt)
+{
+  mng_retcode iRetcode;
+  mng_uint32  iKeywordlen, iTextlen, iLanguagelen, iTranslationlen;
+  mng_pchar   zKeyword, zLanguage, zTranslation;
+  mng_uint8p  pNull1, pNull2, pNull3;
+  mng_uint32  iCompressedsize;
+  mng_uint8   iCompressionflag;
+  mng_uint32  iBufsize;
+  mng_uint8p  pBuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ITXT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 6)                     /* length must be at least 6 */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pNull1 = find_null (pRawdata);       /* find the null separators */
+  pNull2 = find_null (pNull1+3);
+  pNull3 = find_null (pNull2+1);
+                                       /* not found inside input-data ? */
+  if (((pNull1 - pRawdata) > (mng_int32)iRawlen) ||
+      ((pNull2 - pRawdata) > (mng_int32)iRawlen) ||
+      ((pNull3 - pRawdata) > (mng_int32)iRawlen)    )
+    MNG_ERROR (pData, MNG_NULLNOTFOUND);
+
+  if (pNull1 == pRawdata)              /* there must be at least 1 char for keyword */
+    MNG_ERROR (pData, MNG_KEYWORDNULL);
+                                       /* compression or not ? */
+  if ((*(pNull1+1) != 0) && (*(pNull1+1) != 1))
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+  if (*(pNull1+2) != 0)                /* only deflate compression-method allowed */
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+  iKeywordlen      = (mng_uint32)(pNull1 - pRawdata);
+  iLanguagelen     = (mng_uint32)(pNull2 - pNull1 - 3);
+  iTranslationlen  = (mng_uint32)(pNull3 - pNull2 - 1);
+  iCompressedsize  = (mng_uint32)(iRawlen - iKeywordlen - iLanguagelen - iTranslationlen - 5);
+  iCompressionflag = *(pNull1+1);
+
+  zKeyword     = 0;                    /* no buffers acquired yet */
+  zLanguage    = 0;
+  zTranslation = 0;
+  pBuf         = 0;
+  iTextlen     = 0;
+
+  if (pData->fProcesstext)             /* inform the application ? */
+  {
+    if (iCompressionflag)              /* decompress the text ? */
+    {
+      iRetcode = mng_inflate_buffer (pData, pNull3+1, iCompressedsize,
+                                     &pBuf, &iBufsize, &iTextlen);
+
+      if (iRetcode)                    /* on error bail out */
+      {                                /* don't forget to drop the temp buffer */
+        MNG_FREEX (pData, pBuf, iBufsize);
+        return iRetcode;
+      }
+    }
+    else
+    {
+      iTextlen = iCompressedsize;
+      iBufsize = iTextlen+1;           /* plus 1 for terminator byte!!! */
+
+      MNG_ALLOC (pData, pBuf, iBufsize);
+      MNG_COPY  (pBuf, pNull3+1, iTextlen);
+    }
+
+    MNG_ALLOCX (pData, zKeyword,     iKeywordlen     + 1);
+    MNG_ALLOCX (pData, zLanguage,    iLanguagelen    + 1);
+    MNG_ALLOCX (pData, zTranslation, iTranslationlen + 1);
+                                       /* on error bail out */
+    if ((!zKeyword) || (!zLanguage) || (!zTranslation))
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, zTranslation, iTranslationlen + 1);
+      MNG_FREEX (pData, zLanguage,    iLanguagelen    + 1);
+      MNG_FREEX (pData, zKeyword,     iKeywordlen     + 1);
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+
+    MNG_COPY (zKeyword,     pRawdata, iKeywordlen);
+    MNG_COPY (zLanguage,    pNull1+3, iLanguagelen);
+    MNG_COPY (zTranslation, pNull2+1, iTranslationlen);
+
+    if (!pData->fProcesstext ((mng_handle)pData, MNG_TYPE_ITXT, zKeyword, (mng_pchar)pBuf,
+                                                                zLanguage, zTranslation))
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, zTranslation, iTranslationlen + 1);
+      MNG_FREEX (pData, zLanguage,    iLanguagelen    + 1);
+      MNG_FREEX (pData, zKeyword,     iKeywordlen     + 1);
+      MNG_FREEX (pData, pBuf,         iBufsize);
+
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+    }
+  }
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, zTranslation, iTranslationlen + 1);
+      MNG_FREEX (pData, zLanguage,    iLanguagelen    + 1);
+      MNG_FREEX (pData, zKeyword,     iKeywordlen     + 1);
+      MNG_FREEX (pData, pBuf,         iBufsize);
+      return iRetcode;
+    }
+                                       /* store the fields */
+    ((mng_itxtp)*ppChunk)->iKeywordsize       = iKeywordlen;
+    ((mng_itxtp)*ppChunk)->iLanguagesize      = iLanguagelen;
+    ((mng_itxtp)*ppChunk)->iTranslationsize   = iTranslationlen;
+    ((mng_itxtp)*ppChunk)->iCompressionflag   = *(pNull1+1);
+    ((mng_itxtp)*ppChunk)->iCompressionmethod = *(pNull1+2);
+
+    if ((!pBuf) && (iCompressedsize))  /* did we not get a text-buffer yet ? */
+    {
+      if (iCompressionflag)            /* decompress the text ? */
+      {
+        iRetcode = mng_inflate_buffer (pData, pNull3+1, iCompressedsize,
+                                       &pBuf, &iBufsize, &iTextlen);
+
+        if (iRetcode)                  /* on error bail out */
+        {                              /* don't forget to drop the temp buffers */
+          MNG_FREEX (pData, zTranslation, iTranslationlen + 1);
+          MNG_FREEX (pData, zLanguage,    iLanguagelen    + 1);
+          MNG_FREEX (pData, zKeyword,     iKeywordlen     + 1);
+          MNG_FREEX (pData, pBuf,         iBufsize);
+          return iRetcode;
+        }
+      }
+      else
+      {
+        iTextlen = iCompressedsize;
+        iBufsize = iTextlen+1;         /* plus 1 for terminator byte!!! */
+
+        MNG_ALLOC (pData, pBuf, iBufsize);
+        MNG_COPY  (pBuf, pNull3+1, iTextlen);
+      }
+    }
+
+    MNG_ALLOCX (pData, ((mng_itxtp)*ppChunk)->zKeyword,     iKeywordlen     + 1);
+    MNG_ALLOCX (pData, ((mng_itxtp)*ppChunk)->zLanguage,    iLanguagelen    + 1);
+    MNG_ALLOCX (pData, ((mng_itxtp)*ppChunk)->zTranslation, iTranslationlen + 1);
+                                       /* on error bail out */
+    if ((!((mng_itxtp)*ppChunk)->zKeyword    ) ||
+        (!((mng_itxtp)*ppChunk)->zLanguage   ) ||
+        (!((mng_itxtp)*ppChunk)->zTranslation)    )
+    {                                  /* don't forget to drop the temp buffers */
+      MNG_FREEX (pData, zTranslation, iTranslationlen + 1);
+      MNG_FREEX (pData, zLanguage,    iLanguagelen    + 1);
+      MNG_FREEX (pData, zKeyword,     iKeywordlen     + 1);
+      MNG_FREEX (pData, pBuf,         iBufsize);
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+
+    MNG_COPY (((mng_itxtp)*ppChunk)->zKeyword,     pRawdata, iKeywordlen);
+    MNG_COPY (((mng_itxtp)*ppChunk)->zLanguage,    pNull1+3, iLanguagelen);
+    MNG_COPY (((mng_itxtp)*ppChunk)->zTranslation, pNull2+1, iTranslationlen);
+
+    ((mng_itxtp)*ppChunk)->iTextsize = iTextlen;
+
+    if (iTextlen)
+    {
+      MNG_ALLOCX (pData, ((mng_itxtp)*ppChunk)->zText, iTextlen + 1);
+
+      if (!((mng_itxtp)*ppChunk)->zText)
+      {                                /* don't forget to drop the temp buffers */
+        MNG_FREEX (pData, zTranslation, iTranslationlen + 1);
+        MNG_FREEX (pData, zLanguage,    iLanguagelen    + 1);
+        MNG_FREEX (pData, zKeyword,     iKeywordlen     + 1);
+        MNG_FREEX (pData, pBuf,         iBufsize);
+        MNG_ERROR (pData, MNG_OUTOFMEMORY);
+      }
+
+      MNG_COPY  (((mng_itxtp)*ppChunk)->zText, pBuf, iTextlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+                                       /* free the temporary buffers */
+  MNG_FREEX (pData, zTranslation, iTranslationlen + 1);
+  MNG_FREEX (pData, zLanguage,    iLanguagelen    + 1);
+  MNG_FREEX (pData, zKeyword,     iKeywordlen     + 1);
+  MNG_FREEX (pData, pBuf,         iBufsize);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ITXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_bKGD
+READ_CHUNK (mng_read_bkgd)
+{
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_imagep     pImage = (mng_imagep)pData->pCurrentobj;
+  mng_imagedatap pBuf;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_BKGD, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasJDAT) || (pData->bHasJDAA))
+#else
+  if (pData->bHasIDAT)
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen > 6)                     /* it just can't be bigger than that! */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_INCLUDE_JNG                 /* length checks */
+  if (pData->bHasJHDR)
+  {
+    if (((pData->iJHDRcolortype == 8) || (pData->iJHDRcolortype == 12)) && (iRawlen != 2))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if (((pData->iJHDRcolortype == 10) || (pData->iJHDRcolortype == 14)) && (iRawlen != 6))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+#endif /* MNG_INCLUDE_JNG */
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    if (((pData->iColortype == 0) || (pData->iColortype == 4)) && (iRawlen != 2))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if (((pData->iColortype == 2) || (pData->iColortype == 6)) && (iRawlen != 6))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iColortype == 3) && (iRawlen != 1))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+  {
+    if (iRawlen != 6)                  /* global is always 16-bit RGB ! */
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    pData->bHasBKGD = MNG_TRUE;        /* indicate bKGD available */
+  else
+    pData->bHasglobalBKGD = (mng_bool)(iRawlen != 0);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (!pImage)                         /* if no object dump it in obj 0 */
+    pImage = (mng_imagep)pData->pObjzero;
+
+  pBuf = pImage->pImgbuf;              /* address object buffer */
+
+#ifdef MNG_INCLUDE_JNG
+  if (pData->bHasJHDR)
+  {
+    pBuf->bHasBKGD = MNG_TRUE;         /* tell the object it's got bKGD now */
+
+    switch (pData->iJHDRcolortype)     /* store fields for future reference */
+    {
+      case  8 : ;                      /* gray */
+      case 12 : {                      /* graya */
+                  pBuf->iBKGDgray  = mng_get_uint16 (pRawdata);
+                  break;
+                }
+      case 10 : ;                      /* rgb */
+      case 14 : {                      /* rgba */
+                  pBuf->iBKGDred   = mng_get_uint16 (pRawdata);
+                  pBuf->iBKGDgreen = mng_get_uint16 (pRawdata+2);
+                  pBuf->iBKGDblue  = mng_get_uint16 (pRawdata+4);
+                  break;
+                }
+    }
+  }
+  else
+#endif /* MNG_INCLUDE_JNG */
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    pBuf->bHasBKGD = MNG_TRUE;         /* tell the object it's got bKGD now */
+
+    switch (pData->iColortype)         /* store fields for future reference */
+    {
+      case 0 : ;                        /* gray */
+      case 4 : {                        /* graya */
+                 pBuf->iBKGDgray  = mng_get_uint16 (pRawdata);
+                 break;
+               }
+      case 2 : ;                        /* rgb */
+      case 6 : {                        /* rgba */
+                 pBuf->iBKGDred   = mng_get_uint16 (pRawdata);
+                 pBuf->iBKGDgreen = mng_get_uint16 (pRawdata+2);
+                 pBuf->iBKGDblue  = mng_get_uint16 (pRawdata+4);
+                 break;
+               }
+      case 3 : {                        /* indexed */
+                 pBuf->iBKGDindex = *pRawdata;
+                 break;
+               }
+    }
+  }
+  else                                 /* store as global */
+  {
+    if (iRawlen)
+    {
+      pData->iGlobalBKGDred   = mng_get_uint16 (pRawdata);
+      pData->iGlobalBKGDgreen = mng_get_uint16 (pRawdata+2);
+      pData->iGlobalBKGDblue  = mng_get_uint16 (pRawdata+4);
+    }
+
+    {                                  /* create an animation object */
+      mng_retcode iRetcode = mng_create_ani_bkgd (pData, pData->iGlobalBKGDred,
+                                                  pData->iGlobalBKGDgreen,
+                                                  pData->iGlobalBKGDblue);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_bkgdp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+    ((mng_bkgdp)*ppChunk)->iType  = pData->iColortype;
+
+    if (iRawlen)
+    {
+      switch (iRawlen)                 /* guess from length */
+      {
+        case 1 : {                     /* indexed */
+                   ((mng_bkgdp)*ppChunk)->iType  = 3;
+                   ((mng_bkgdp)*ppChunk)->iIndex = *pRawdata;
+                   break;
+                 }
+        case 2 : {                     /* gray */
+                   ((mng_bkgdp)*ppChunk)->iType  = 0;
+                   ((mng_bkgdp)*ppChunk)->iGray  = mng_get_uint16 (pRawdata);
+                   break;
+                 }
+        case 6 : {                     /* rgb */
+                   ((mng_bkgdp)*ppChunk)->iType  = 2;
+                   ((mng_bkgdp)*ppChunk)->iRed   = mng_get_uint16 (pRawdata);
+                   ((mng_bkgdp)*ppChunk)->iGreen = mng_get_uint16 (pRawdata+2);
+                   ((mng_bkgdp)*ppChunk)->iBlue  = mng_get_uint16 (pRawdata+4);
+                   break;
+                 }
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_pHYs
+READ_CHUNK (mng_read_phys)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PHYS, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIDAT) || (pData->bHasJDAT) || (pData->bHasJDAA))
+#else
+  if (pData->bHasIDAT)
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* it's 9 bytes or empty; no more, no less! */
+  if ((iRawlen != 9) && (iRawlen != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_physp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+    {
+      ((mng_physp)*ppChunk)->iSizex = mng_get_uint32 (pRawdata);
+      ((mng_physp)*ppChunk)->iSizey = mng_get_uint32 (pRawdata+4);
+      ((mng_physp)*ppChunk)->iUnit  = *(pRawdata+8);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PHYS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_sBIT
+READ_CHUNK (mng_read_sbit)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SBIT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasPLTE) || (pData->bHasIDAT) || (pData->bHasJDAT) || (pData->bHasJDAA))
+#else
+  if ((pData->bHasPLTE) || (pData->bHasIDAT))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen > 4)                     /* it just can't be bigger than that! */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_INCLUDE_JNG                 /* length checks */
+  if (pData->bHasJHDR)
+  {
+    if ((pData->iJHDRcolortype ==  8) && (iRawlen != 1))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iJHDRcolortype == 10) && (iRawlen != 3))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iJHDRcolortype == 12) && (iRawlen != 2))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iJHDRcolortype == 14) && (iRawlen != 4))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+#endif /* MNG_INCLUDE_JNG */
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+  {
+    if ((pData->iColortype == 0) && (iRawlen != 1))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iColortype == 2) && (iRawlen != 3))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iColortype == 3) && (iRawlen != 3))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iColortype == 4) && (iRawlen != 2))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((pData->iColortype == 6) && (iRawlen != 4))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+  else
+  {                                    /* global = empty or RGBA */
+    if ((iRawlen != 0) && (iRawlen != 4))
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_sbitp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+    {
+#ifdef MNG_INCLUDE_JNG
+      if (pData->bHasJHDR)
+        ((mng_sbitp)*ppChunk)->iType = pData->iJHDRcolortype;
+      else
+#endif
+      if (pData->bHasIHDR)
+        ((mng_sbitp)*ppChunk)->iType = pData->iColortype;
+      else                             /* global ! */
+        ((mng_sbitp)*ppChunk)->iType = 6;
+
+      if (iRawlen > 0)
+        ((mng_sbitp)*ppChunk)->aBits [0] = *pRawdata;
+      if (iRawlen > 1)
+        ((mng_sbitp)*ppChunk)->aBits [1] = *(pRawdata+1);
+      if (iRawlen > 2)
+        ((mng_sbitp)*ppChunk)->aBits [2] = *(pRawdata+2);
+      if (iRawlen > 3)
+        ((mng_sbitp)*ppChunk)->aBits [3] = *(pRawdata+3);
+
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SBIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_sPLT
+READ_CHUNK (mng_read_splt)
+{
+  mng_uint8p pTemp;
+  mng_uint32 iNamelen;
+  mng_uint8  iSampledepth;
+  mng_uint32 iRemain;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SPLT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (pData->bHasIDAT)
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen)
+  {
+    pTemp = find_null (pRawdata);      /* find null-separator */
+                                       /* not found inside input-data ? */
+    if ((pTemp - pRawdata) > (mng_int32)iRawlen)
+      MNG_ERROR (pData, MNG_NULLNOTFOUND);
+
+    iNamelen     = (mng_uint32)(pTemp - pRawdata);
+    iSampledepth = *(pTemp+1);
+    iRemain      = (iRawlen - 2 - iNamelen);
+
+    if ((iSampledepth != 1) && (iSampledepth != 2))
+      MNG_ERROR (pData, MNG_INVSAMPLEDEPTH);
+                                       /* check remaining length */
+    if ( ((iSampledepth == 1) && (iRemain %  6 != 0)) ||
+         ((iSampledepth == 2) && (iRemain % 10 != 0))    )
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  }
+  else
+  {
+    pTemp        = MNG_NULL;
+    iNamelen     = 0;
+    iSampledepth = 0;
+    iRemain      = 0;
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_spltp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+    {
+      ((mng_spltp)*ppChunk)->iNamesize    = iNamelen;
+      ((mng_spltp)*ppChunk)->iSampledepth = iSampledepth;
+
+      if (iSampledepth == 1)
+        ((mng_spltp)*ppChunk)->iEntrycount = iRemain / 6;
+      else
+        ((mng_spltp)*ppChunk)->iEntrycount = iRemain / 10;
+
+      if (iNamelen)
+      {
+        MNG_ALLOC (pData, ((mng_spltp)*ppChunk)->zName, iNamelen+1);
+        MNG_COPY (((mng_spltp)*ppChunk)->zName, pRawdata, iNamelen);
+      }
+
+      if (iRemain)
+      {
+        MNG_ALLOC (pData, ((mng_spltp)*ppChunk)->pEntries, iRemain);
+        MNG_COPY (((mng_spltp)*ppChunk)->pEntries, pTemp+2, iRemain);
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_hIST
+READ_CHUNK (mng_read_hist)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_HIST, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasIHDR) && (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if ((!pData->bHasPLTE) || (pData->bHasIDAT))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* length oke ? */
+  if ( ((iRawlen & 0x01) != 0) || ((iRawlen >> 1) != pData->iPLTEcount) )
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {
+    mng_uint32 iX;
+                                       /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_histp)*ppChunk)->iEntrycount = iRawlen >> 1;
+
+    for (iX = 0; iX < (iRawlen >> 1); iX++)
+    {
+      ((mng_histp)*ppChunk)->aEntries [iX] = mng_get_uint16 (pRawdata);
+      pRawdata += 2;
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_HIST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_tIME
+READ_CHUNK (mng_read_time)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TIME, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 7)                    /* length must be exactly 7 */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+/*  if (pData->fProcesstime) */            /* inform the application ? */
+/*  {
+
+    pData->fProcesstime ((mng_handle)pData, );
+  } */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_timep)*ppChunk)->iYear   = mng_get_uint16 (pRawdata);
+    ((mng_timep)*ppChunk)->iMonth  = *(pRawdata+2);
+    ((mng_timep)*ppChunk)->iDay    = *(pRawdata+3);
+    ((mng_timep)*ppChunk)->iHour   = *(pRawdata+4);
+    ((mng_timep)*ppChunk)->iMinute = *(pRawdata+5);
+    ((mng_timep)*ppChunk)->iSecond = *(pRawdata+6);
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TIME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_mhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MHDR, MNG_LC_START);
+#endif
+
+  if (pData->eSigtype != mng_it_mng)   /* sequence checks */
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+
+  if (pData->bHasheader)               /* can only be the first chunk! */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* correct length ? */
+#ifndef MNG_NO_OLD_VERSIONS
+  if ((iRawlen != 28) && (iRawlen != 12))
+#else
+  if ((iRawlen != 28))
+#endif
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasMHDR       = MNG_TRUE;    /* oh boy, a real MNG */
+  pData->bHasheader     = MNG_TRUE;    /* we've got a header */
+  pData->eImagetype     = mng_it_mng;  /* fill header fields */
+  pData->iWidth         = mng_get_uint32 (pRawdata);
+  pData->iHeight        = mng_get_uint32 (pRawdata+4);
+  pData->iTicks         = mng_get_uint32 (pRawdata+8);
+
+#ifndef MNG_NO_OLD_VERSIONS
+  if (iRawlen == 28)                   /* proper MHDR ? */
+  {
+#endif
+    pData->iLayercount  = mng_get_uint32 (pRawdata+12);
+    pData->iFramecount  = mng_get_uint32 (pRawdata+16);
+    pData->iPlaytime    = mng_get_uint32 (pRawdata+20);
+    pData->iSimplicity  = mng_get_uint32 (pRawdata+24);
+
+#ifndef MNG_NO_OLD_VERSIONS
+    pData->bPreDraft48  = MNG_FALSE;
+  }
+  else                                 /* probably pre-draft48 then */
+  {
+    pData->iLayercount  = 0;
+    pData->iFramecount  = 0;
+    pData->iPlaytime    = 0;
+    pData->iSimplicity  = 0;
+
+    pData->bPreDraft48  = MNG_TRUE;
+  }
+#endif
+                                       /* predict alpha-depth */
+  if ((pData->iSimplicity & 0x00000001) == 0)
+#ifndef MNG_NO_16BIT_SUPPORT
+    pData->iAlphadepth = 16;           /* no indicators = assume the worst */
+#else
+    pData->iAlphadepth = 8;            /* anything else = assume the worst */
+#endif
+  else
+  if ((pData->iSimplicity & 0x00000008) == 0)
+    pData->iAlphadepth = 0;            /* no transparency at all */
+  else
+  if ((pData->iSimplicity & 0x00000140) == 0x00000040)
+    pData->iAlphadepth = 1;            /* no semi-transparency guaranteed */
+  else
+#ifndef MNG_NO_16BIT_SUPPORT
+    pData->iAlphadepth = 16;           /* anything else = assume the worst */
+#else
+    pData->iAlphadepth = 8;            /* anything else = assume the worst */
+#endif
+
+#ifdef MNG_INCLUDE_JNG                 /* can we handle the complexity ? */
+  if (pData->iSimplicity & 0x0000FC00)
+#else
+  if (pData->iSimplicity & 0x0000FC10)
+#endif
+    MNG_ERROR (pData, MNG_MNGTOOCOMPLEX);
+                                       /* fits on maximum canvas ? */
+  if ((pData->iWidth > pData->iMaxwidth) || (pData->iHeight > pData->iMaxheight))
+    MNG_WARNING (pData, MNG_IMAGETOOLARGE);
+
+  if (pData->fProcessheader)           /* inform the app ? */
+    if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+
+  pData->iImagelevel++;                /* one level deeper */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_mhdrp)*ppChunk)->iWidth      = pData->iWidth;
+    ((mng_mhdrp)*ppChunk)->iHeight     = pData->iHeight;
+    ((mng_mhdrp)*ppChunk)->iTicks      = pData->iTicks;
+    ((mng_mhdrp)*ppChunk)->iLayercount = pData->iLayercount;
+    ((mng_mhdrp)*ppChunk)->iFramecount = pData->iFramecount;
+    ((mng_mhdrp)*ppChunk)->iPlaytime   = pData->iPlaytime;
+    ((mng_mhdrp)*ppChunk)->iSimplicity = pData->iSimplicity;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_mend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MEND, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen > 0)                     /* must not contain data! */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* do something */
+    mng_retcode iRetcode = mng_process_display_mend (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    if (!pData->iTotalframes)          /* save totals */
+      pData->iTotalframes   = pData->iFrameseq;
+    if (!pData->iTotallayers)
+      pData->iTotallayers   = pData->iLayerseq;
+    if (!pData->iTotalplaytime)
+      pData->iTotalplaytime = pData->iFrametime;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  pData->bHasMHDR = MNG_FALSE;         /* end of the line, bro! */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_LOOP
+READ_CHUNK (mng_read_loop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_LOOP, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_LOOPWITHCACHEOFF);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen >= 5)                    /* length checks */
+  {
+    if (iRawlen >= 6)
+    {
+      if ((iRawlen - 6) % 4 != 0)
+        MNG_ERROR (pData, MNG_INVALIDLENGTH);
+    }
+  }
+  else
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_uint8   iLevel;
+    mng_uint32  iRepeat;
+    mng_uint8   iTermination = 0;
+    mng_uint32  iItermin     = 1;
+    mng_uint32  iItermax     = 0x7fffffffL;
+    mng_retcode iRetcode;
+
+    pData->bHasLOOP = MNG_TRUE;        /* indicate we're inside a loop */
+
+    iLevel = *pRawdata;                /* determine the fields for processing */
+
+#ifndef MNG_NO_OLD_VERSIONS
+    if (pData->bPreDraft48)
+    {
+      iTermination = *(pRawdata+1);
+
+      iRepeat = mng_get_uint32 (pRawdata+2);
+    }
+    else
+#endif
+      iRepeat = mng_get_uint32 (pRawdata+1);
+
+    if (iRawlen >= 6)
+    {
+#ifndef MNG_NO_OLD_VERSIONS
+      if (!pData->bPreDraft48)
+#endif
+        iTermination = *(pRawdata+5);
+
+      if (iRawlen >= 10)
+      {
+        iItermin = mng_get_uint32 (pRawdata+6);
+
+        if (iRawlen >= 14)
+        {
+          iItermax = mng_get_uint32 (pRawdata+10);
+
+          /* TODO: process signals */
+
+        }
+      }
+    }
+                                       /* create the LOOP ani-object */
+    iRetcode = mng_create_ani_loop (pData, iLevel, iRepeat, iTermination,
+                                           iItermin, iItermax, 0, 0);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* skip till matching ENDL if iteration=0 */
+    if ((!pData->bSkipping) && (iRepeat == 0))
+      pData->bSkipping = MNG_TRUE;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    if (iRawlen >= 5)                  /* store the fields */
+    {
+      ((mng_loopp)*ppChunk)->iLevel  = *pRawdata;
+
+#ifndef MNG_NO_OLD_VERSIONS
+      if (pData->bPreDraft48)
+      {
+        ((mng_loopp)*ppChunk)->iTermination = *(pRawdata+1);
+        ((mng_loopp)*ppChunk)->iRepeat = mng_get_uint32 (pRawdata+2);
+      }
+      else
+#endif
+      {
+        ((mng_loopp)*ppChunk)->iRepeat = mng_get_uint32 (pRawdata+1);
+      }
+
+      if (iRawlen >= 6)
+      {
+#ifndef MNG_NO_OLD_VERSIONS
+        if (!pData->bPreDraft48)
+#endif
+          ((mng_loopp)*ppChunk)->iTermination = *(pRawdata+5);
+
+        if (iRawlen >= 10)
+        {
+          ((mng_loopp)*ppChunk)->iItermin = mng_get_uint32 (pRawdata+6);
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+          if (iRawlen >= 14)
+          {
+            ((mng_loopp)*ppChunk)->iItermax = mng_get_uint32 (pRawdata+10);
+            ((mng_loopp)*ppChunk)->iCount   = (iRawlen - 14) / 4;
+
+            if (((mng_loopp)*ppChunk)->iCount)
+            {
+              MNG_ALLOC (pData, ((mng_loopp)*ppChunk)->pSignals,
+                                ((mng_loopp)*ppChunk)->iCount << 2);
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+              {
+                mng_uint32  iX;
+                mng_uint8p  pIn  = pRawdata + 14;
+                mng_uint32p pOut = (mng_uint32p)((mng_loopp)*ppChunk)->pSignals;
+
+                for (iX = 0; iX < ((mng_loopp)*ppChunk)->iCount; iX++)
+                {
+                  *pOut++ = mng_get_uint32 (pIn);
+                  pIn += 4;
+                }
+              }
+#else
+              MNG_COPY (((mng_loopp)*ppChunk)->pSignals, pRawdata + 14,
+                        ((mng_loopp)*ppChunk)->iCount << 2);
+#endif /* !MNG_BIGENDIAN_SUPPORTED */
+            }
+          }
+#endif
+        }
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_LOOP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_LOOP
+READ_CHUNK (mng_read_endl)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ENDL, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 1)                    /* length must be exactly 1 */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    if (pData->bHasLOOP)               /* are we really processing a loop ? */
+    {
+      mng_uint8 iLevel = *pRawdata;    /* get the nest level */
+                                       /* create an ENDL animation object */
+      mng_retcode iRetcode = mng_create_ani_endl (pData, iLevel);
+                                 
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+
+/*      {
+        mng_ani_endlp pENDL = (mng_ani_endlp)pData->pLastaniobj;
+
+        iRetcode = pENDL->sHeader.fProcess (pData, pENDL);
+
+        if (iRetcode)
+          return iRetcode;
+      } */
+    }
+    else
+      MNG_ERROR (pData, MNG_NOMATCHINGLOOP);
+      
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_endlp)*ppChunk)->iLevel = *pRawdata;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_DEFI
+READ_CHUNK (mng_read_defi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DEFI, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check the length */
+  if ((iRawlen != 2) && (iRawlen != 3) && (iRawlen != 4) &&
+      (iRawlen != 12) && (iRawlen != 28))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+
+    pData->iDEFIobjectid       = mng_get_uint16 (pRawdata);
+
+    if (iRawlen > 2)
+    {
+      pData->bDEFIhasdonotshow = MNG_TRUE;
+      pData->iDEFIdonotshow    = *(pRawdata+2);
+    }
+    else
+    {
+      pData->bDEFIhasdonotshow = MNG_FALSE;
+      pData->iDEFIdonotshow    = 0;
+    }
+
+    if (iRawlen > 3)
+    {
+      pData->bDEFIhasconcrete  = MNG_TRUE;
+      pData->iDEFIconcrete     = *(pRawdata+3);
+    }
+    else
+    {
+      pData->bDEFIhasconcrete  = MNG_FALSE;
+      pData->iDEFIconcrete     = 0;
+    }
+
+    if (iRawlen > 4)
+    {
+      pData->bDEFIhasloca      = MNG_TRUE;
+      pData->iDEFIlocax        = mng_get_int32 (pRawdata+4);
+      pData->iDEFIlocay        = mng_get_int32 (pRawdata+8);
+    }
+    else
+    {
+      pData->bDEFIhasloca      = MNG_FALSE;
+      pData->iDEFIlocax        = 0;
+      pData->iDEFIlocay        = 0;
+    }
+
+    if (iRawlen > 12)
+    {
+      pData->bDEFIhasclip      = MNG_TRUE;
+      pData->iDEFIclipl        = mng_get_int32 (pRawdata+12);
+      pData->iDEFIclipr        = mng_get_int32 (pRawdata+16);
+      pData->iDEFIclipt        = mng_get_int32 (pRawdata+20);
+      pData->iDEFIclipb        = mng_get_int32 (pRawdata+24);
+    }
+    else
+    {
+      pData->bDEFIhasclip      = MNG_FALSE;
+      pData->iDEFIclipl        = 0;
+      pData->iDEFIclipr        = 0;
+      pData->iDEFIclipt        = 0;
+      pData->iDEFIclipb        = 0;
+    }
+                                       /* create an animation object */
+    iRetcode = mng_create_ani_defi (pData);
+                   
+    if (!iRetcode)                     /* do display processing */
+      iRetcode = mng_process_display_defi (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_defip)*ppChunk)->iObjectid       = mng_get_uint16 (pRawdata);
+
+    if (iRawlen > 2)
+    {
+      ((mng_defip)*ppChunk)->bHasdonotshow = MNG_TRUE;
+      ((mng_defip)*ppChunk)->iDonotshow    = *(pRawdata+2);
+    }
+    else
+      ((mng_defip)*ppChunk)->bHasdonotshow = MNG_FALSE;
+
+    if (iRawlen > 3)
+    {
+      ((mng_defip)*ppChunk)->bHasconcrete  = MNG_TRUE;
+      ((mng_defip)*ppChunk)->iConcrete     = *(pRawdata+3);
+    }
+    else
+      ((mng_defip)*ppChunk)->bHasconcrete  = MNG_FALSE;
+
+    if (iRawlen > 4)
+    {
+      ((mng_defip)*ppChunk)->bHasloca      = MNG_TRUE;
+      ((mng_defip)*ppChunk)->iXlocation    = mng_get_int32 (pRawdata+4);
+      ((mng_defip)*ppChunk)->iYlocation    = mng_get_int32 (pRawdata+8);
+    }
+    else
+      ((mng_defip)*ppChunk)->bHasloca      = MNG_FALSE;
+
+    if (iRawlen > 12)
+    {
+      ((mng_defip)*ppChunk)->bHasclip      = MNG_TRUE;
+      ((mng_defip)*ppChunk)->iLeftcb       = mng_get_int32 (pRawdata+12);
+      ((mng_defip)*ppChunk)->iRightcb      = mng_get_int32 (pRawdata+16);
+      ((mng_defip)*ppChunk)->iTopcb        = mng_get_int32 (pRawdata+20);
+      ((mng_defip)*ppChunk)->iBottomcb     = mng_get_int32 (pRawdata+24);
+    }
+    else
+      ((mng_defip)*ppChunk)->bHasclip      = MNG_FALSE;
+
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_BASI
+READ_CHUNK (mng_read_basi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_BASI, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check the length */
+  if ((iRawlen != 13) && (iRawlen != 19) && (iRawlen != 21) && (iRawlen != 22))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasBASI     = MNG_TRUE;      /* inside a BASI-IEND block now */
+                                       /* store interesting fields */
+  pData->iDatawidth   = mng_get_uint32 (pRawdata);
+  pData->iDataheight  = mng_get_uint32 (pRawdata+4);
+  pData->iBitdepth    = *(pRawdata+8);
+  pData->iColortype   = *(pRawdata+9);
+  pData->iCompression = *(pRawdata+10);
+  pData->iFilter      = *(pRawdata+11);
+  pData->iInterlace   = *(pRawdata+12);
+
+
+#if defined(MNG_NO_1_2_4BIT_SUPPORT) || defined(MNG_NO_16BIT_SUPPORT)
+  pData->iPNGmult = 1;
+  pData->iPNGdepth = pData->iBitdepth;
+#endif
+
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+  if (pData->iBitdepth < 8)
+    pData->iBitdepth = 8;
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (pData->iBitdepth > 8)
+    {
+      pData->iBitdepth = 8;
+      pData->iPNGmult = 2;
+    }
+#endif
+
+  if ((pData->iBitdepth !=  8)      /* parameter validity checks */
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+      && (pData->iBitdepth !=  1) &&
+      (pData->iBitdepth !=  2) &&
+      (pData->iBitdepth !=  4)
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+      && (pData->iBitdepth != 16)
+#endif
+      )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if ((pData->iColortype != MNG_COLORTYPE_GRAY   ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGB    ) &&
+      (pData->iColortype != MNG_COLORTYPE_INDEXED) &&
+      (pData->iColortype != MNG_COLORTYPE_GRAYA  ) &&
+      (pData->iColortype != MNG_COLORTYPE_RGBA   )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  if ((pData->iColortype == MNG_COLORTYPE_INDEXED) && (pData->iBitdepth > 8))
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (((pData->iColortype == MNG_COLORTYPE_RGB    ) ||
+       (pData->iColortype == MNG_COLORTYPE_GRAYA  ) ||
+       (pData->iColortype == MNG_COLORTYPE_RGBA   )    ) &&
+      (pData->iBitdepth < 8                            )    )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (pData->iCompression != MNG_COMPRESSION_DEFLATE)
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+#if defined(FILTER192) || defined(FILTER193)
+  if ((pData->iFilter != MNG_FILTER_ADAPTIVE ) &&
+#if defined(FILTER192) && defined(FILTER193)
+      (pData->iFilter != MNG_FILTER_DIFFERING) &&
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#else
+#ifdef FILTER192
+      (pData->iFilter != MNG_FILTER_DIFFERING)    )
+#else
+      (pData->iFilter != MNG_FILTER_NOFILTER )    )
+#endif
+#endif
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#else
+  if (pData->iFilter)
+    MNG_ERROR (pData, MNG_INVALIDFILTER);
+#endif
+
+  if ((pData->iInterlace != MNG_INTERLACE_NONE ) &&
+      (pData->iInterlace != MNG_INTERLACE_ADAM7)    )
+    MNG_ERROR (pData, MNG_INVALIDINTERLACE);
+
+  pData->iImagelevel++;                /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_uint16  iRed      = 0;
+    mng_uint16  iGreen    = 0;
+    mng_uint16  iBlue     = 0;
+    mng_bool    bHasalpha = MNG_FALSE;
+    mng_uint16  iAlpha    = 0xFFFF;
+    mng_uint8   iViewable = 0;
+    mng_retcode iRetcode;
+
+    if (iRawlen > 13)                  /* get remaining fields, if any */
+    {
+      iRed      = mng_get_uint16 (pRawdata+13);
+      iGreen    = mng_get_uint16 (pRawdata+15);
+      iBlue     = mng_get_uint16 (pRawdata+17);
+    }
+
+    if (iRawlen > 19)
+    {
+      bHasalpha = MNG_TRUE;
+      iAlpha    = mng_get_uint16 (pRawdata+19);
+    }
+
+    if (iRawlen > 21)
+      iViewable = *(pRawdata+21);
+                                       /* create an animation object */
+    iRetcode = mng_create_ani_basi (pData, iRed, iGreen, iBlue,
+                                    bHasalpha, iAlpha, iViewable);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_basi (pData, iRed, iGreen, iBlue,
+                                           bHasalpha, iAlpha, iViewable); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_basip)*ppChunk)->iWidth       = mng_get_uint32 (pRawdata);
+    ((mng_basip)*ppChunk)->iHeight      = mng_get_uint32 (pRawdata+4);
+#ifdef MNG_NO_16BIT_SUPPORT
+    if (*(pRawdata+8) > 8)
+      ((mng_basip)*ppChunk)->iBitdepth    = 8;
+    else
+#endif
+      ((mng_basip)*ppChunk)->iBitdepth    = *(pRawdata+8);
+    ((mng_basip)*ppChunk)->iColortype   = *(pRawdata+9);
+    ((mng_basip)*ppChunk)->iCompression = *(pRawdata+10);
+    ((mng_basip)*ppChunk)->iFilter      = *(pRawdata+11);
+    ((mng_basip)*ppChunk)->iInterlace   = *(pRawdata+12);
+
+    if (iRawlen > 13)
+    {
+      ((mng_basip)*ppChunk)->iRed       = mng_get_uint16 (pRawdata+13);
+      ((mng_basip)*ppChunk)->iGreen     = mng_get_uint16 (pRawdata+15);
+      ((mng_basip)*ppChunk)->iBlue      = mng_get_uint16 (pRawdata+17);
+    }
+
+    if (iRawlen > 19)
+      ((mng_basip)*ppChunk)->iAlpha     = mng_get_uint16 (pRawdata+19);
+
+    if (iRawlen > 21)
+      ((mng_basip)*ppChunk)->iViewable  = *(pRawdata+21);
+
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_CLON
+READ_CHUNK (mng_read_clon)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CLON, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check the length */
+  if ((iRawlen != 4) && (iRawlen != 5) && (iRawlen != 6) &&
+      (iRawlen != 7) && (iRawlen != 16))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_uint16  iSourceid, iCloneid;
+    mng_uint8   iClonetype    = 0;
+    mng_bool    bHasdonotshow = MNG_FALSE;
+    mng_uint8   iDonotshow    = 0;
+    mng_uint8   iConcrete     = 0;
+    mng_bool    bHasloca      = MNG_FALSE;
+    mng_uint8   iLocationtype = 0;
+    mng_int32   iLocationx    = 0;
+    mng_int32   iLocationy    = 0;
+    mng_retcode iRetcode;
+
+    iSourceid       = mng_get_uint16 (pRawdata);
+    iCloneid        = mng_get_uint16 (pRawdata+2);
+
+    if (iRawlen > 4)
+      iClonetype    = *(pRawdata+4);
+
+    if (iRawlen > 5)
+    {
+      bHasdonotshow = MNG_TRUE;
+      iDonotshow    = *(pRawdata+5);
+    }
+
+    if (iRawlen > 6)
+      iConcrete     = *(pRawdata+6);
+
+    if (iRawlen > 7)
+    {
+      bHasloca      = MNG_TRUE;
+      iLocationtype = *(pRawdata+7);
+      iLocationx    = mng_get_int32 (pRawdata+8);
+      iLocationy    = mng_get_int32 (pRawdata+12);
+    }
+
+    iRetcode = mng_create_ani_clon (pData, iSourceid, iCloneid, iClonetype,
+                                    bHasdonotshow, iDonotshow, iConcrete,
+                                    bHasloca, iLocationtype, iLocationx, iLocationy);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_clon (pData, iSourceid, iCloneid, iClonetype,
+                                           bHasdonotshow, iDonotshow, iConcrete,
+                                           bHasloca, iLocationtype, iLocationx,
+                                           iLocationy); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_clonp)*ppChunk)->iSourceid       = mng_get_uint16 (pRawdata);
+    ((mng_clonp)*ppChunk)->iCloneid        = mng_get_uint16 (pRawdata+2);
+
+    if (iRawlen > 4)
+      ((mng_clonp)*ppChunk)->iClonetype    = *(pRawdata+4);
+
+    if (iRawlen > 5)
+      ((mng_clonp)*ppChunk)->iDonotshow    = *(pRawdata+5);
+
+    if (iRawlen > 6)
+      ((mng_clonp)*ppChunk)->iConcrete     = *(pRawdata+6);
+
+    if (iRawlen > 7)
+    {
+      ((mng_clonp)*ppChunk)->bHasloca      = MNG_TRUE;
+      ((mng_clonp)*ppChunk)->iLocationtype = *(pRawdata+7);
+      ((mng_clonp)*ppChunk)->iLocationx    = mng_get_int32 (pRawdata+8);
+      ((mng_clonp)*ppChunk)->iLocationy    = mng_get_int32 (pRawdata+12);
+    }
+    else
+    {
+      ((mng_clonp)*ppChunk)->bHasloca      = MNG_FALSE;
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_PAST
+READ_CHUNK (mng_read_past)
+{
+#if defined(MNG_STORE_CHUNKS) || defined(MNG_SUPPORT_DISPLAY)
+  mng_retcode      iRetcode;
+  mng_uint16       iTargetid;
+  mng_uint8        iTargettype;
+  mng_int32        iTargetx;
+  mng_int32        iTargety;
+  mng_uint32       iCount;
+  mng_uint32       iSize;
+  mng_ptr          pSources;
+  mng_uint32       iX;
+  mng_past_sourcep pSource;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PAST, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+                                       /* check the length */
+  if ((iRawlen < 41) || (((iRawlen - 11) % 30) != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#if defined(MNG_STORE_CHUNKS) || defined(MNG_SUPPORT_DISPLAY)
+  iTargetid   = mng_get_uint16 (pRawdata);
+  iTargettype = *(pRawdata+2);
+  iTargetx    = mng_get_int32  (pRawdata+3);
+  iTargety    = mng_get_int32  (pRawdata+7);
+  iCount      = ((iRawlen - 11) / 30); /* how many entries again? */
+  iSize       = iCount * sizeof (mng_past_source);
+
+  pRawdata += 11;
+                                       /* get a buffer for all the source blocks */
+  MNG_ALLOC (pData, pSources, iSize);
+
+  pSource = (mng_past_sourcep)pSources;
+
+  for (iX = 0; iX < iCount; iX++)      /* now copy the source blocks */
+  {
+    pSource->iSourceid     = mng_get_uint16 (pRawdata);
+    pSource->iComposition  = *(pRawdata+2);
+    pSource->iOrientation  = *(pRawdata+3);
+    pSource->iOffsettype   = *(pRawdata+4);
+    pSource->iOffsetx      = mng_get_int32 (pRawdata+5);
+    pSource->iOffsety      = mng_get_int32 (pRawdata+9);
+    pSource->iBoundarytype = *(pRawdata+13);
+    pSource->iBoundaryl    = mng_get_int32 (pRawdata+14);
+    pSource->iBoundaryr    = mng_get_int32 (pRawdata+18);
+    pSource->iBoundaryt    = mng_get_int32 (pRawdata+22);
+    pSource->iBoundaryb    = mng_get_int32 (pRawdata+26);
+
+    pSource++;
+    pRawdata += 30;
+  }
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create playback object */
+    iRetcode = mng_create_ani_past (pData, iTargetid, iTargettype, iTargetx,
+                                    iTargety, iCount, pSources);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_past (pData, iTargetid, iTargettype, iTargetx,
+                                           iTargety, iCount, pSources); */
+
+    if (iRetcode)                      /* on error bail out */
+    {
+      MNG_FREEX (pData, pSources, iSize);
+      return iRetcode;
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+    {
+      MNG_FREEX (pData, pSources, iSize);
+      return iRetcode;
+    }
+                                       /* store the fields */
+    ((mng_pastp)*ppChunk)->iDestid     = iTargetid;
+    ((mng_pastp)*ppChunk)->iTargettype = iTargettype;
+    ((mng_pastp)*ppChunk)->iTargetx    = iTargetx;
+    ((mng_pastp)*ppChunk)->iTargety    = iTargety;
+    ((mng_pastp)*ppChunk)->iCount      = iCount;
+                                       /* get a buffer & copy the source blocks */
+    MNG_ALLOC (pData, ((mng_pastp)*ppChunk)->pSources, iSize);
+    MNG_COPY (((mng_pastp)*ppChunk)->pSources, pSources, iSize);
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#if defined(MNG_STORE_CHUNKS) || defined(MNG_SUPPORT_DISPLAY)
+                                       /* free the source block buffer */
+  MNG_FREEX (pData, pSources, iSize);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PAST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_DISC
+READ_CHUNK (mng_read_disc)
+{
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  mng_uint32  iCount;
+  mng_uint16p pIds = MNG_NULL;
+  mng_retcode iRetcode;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DISC, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if ((iRawlen % 2) != 0)              /* check the length */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  iCount = (iRawlen / sizeof (mng_uint16));
+
+  if (iCount)
+  {
+    MNG_ALLOC (pData, pIds, iRawlen);
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+    {
+      mng_uint32  iX;
+      mng_uint8p  pIn  = pRawdata;
+      mng_uint16p pOut = pIds;
+
+      for (iX = 0; iX < iCount; iX++)
+      {
+        *pOut++ = mng_get_uint16 (pIn);
+        pIn += 2;
+      }
+    }
+#else
+    MNG_COPY (pIds, pRawdata, iRawlen);
+#endif /* !MNG_BIGENDIAN_SUPPORTED */
+  }
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create playback object */
+    iRetcode = mng_create_ani_disc (pData, iCount, pIds);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_disc (pData, iCount, pIds); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_discp)*ppChunk)->iCount = iCount;
+
+    if (iRawlen)
+    {
+      MNG_ALLOC (pData, ((mng_discp)*ppChunk)->pObjectids, iRawlen);
+      MNG_COPY (((mng_discp)*ppChunk)->pObjectids, pIds, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  if (iRawlen)
+    MNG_FREEX (pData, pIds, iRawlen);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DISC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_BACK
+READ_CHUNK (mng_read_back)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_BACK, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check the length */
+  if ((iRawlen != 6) && (iRawlen != 7) && (iRawlen != 9) && (iRawlen != 10))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+                                       /* retrieve the fields */
+    pData->bHasBACK         = MNG_TRUE;
+    pData->iBACKred         = mng_get_uint16 (pRawdata);
+    pData->iBACKgreen       = mng_get_uint16 (pRawdata+2);
+    pData->iBACKblue        = mng_get_uint16 (pRawdata+4);
+
+    if (iRawlen > 6)
+      pData->iBACKmandatory = *(pRawdata+6);
+    else
+      pData->iBACKmandatory = 0;
+
+    if (iRawlen > 7)
+      pData->iBACKimageid   = mng_get_uint16 (pRawdata+7);
+    else
+      pData->iBACKimageid   = 0;
+
+    if (iRawlen > 9)
+      pData->iBACKtile      = *(pRawdata+9);
+    else
+      pData->iBACKtile      = 0;
+
+    iRetcode = mng_create_ani_back (pData, pData->iBACKred, pData->iBACKgreen,
+                                    pData->iBACKblue, pData->iBACKmandatory,
+                                    pData->iBACKimageid, pData->iBACKtile);
+
+    if (iRetcode)                    /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_backp)*ppChunk)->iRed         = mng_get_uint16 (pRawdata);
+    ((mng_backp)*ppChunk)->iGreen       = mng_get_uint16 (pRawdata+2);
+    ((mng_backp)*ppChunk)->iBlue        = mng_get_uint16 (pRawdata+4);
+
+    if (iRawlen > 6)
+      ((mng_backp)*ppChunk)->iMandatory = *(pRawdata+6);
+
+    if (iRawlen > 7)
+      ((mng_backp)*ppChunk)->iImageid   = mng_get_uint16 (pRawdata+7);
+
+    if (iRawlen > 9)
+      ((mng_backp)*ppChunk)->iTile      = *(pRawdata+9);
+
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_FRAM
+READ_CHUNK (mng_read_fram)
+{
+  mng_uint8p pTemp;
+#ifdef MNG_STORE_CHUNKS
+  mng_uint32 iNamelen;
+#endif
+  mng_uint32 iRemain;
+  mng_uint32 iRequired = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_FRAM, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen <= 1)                    /* only framing-mode ? */
+  {
+#ifdef MNG_STORE_CHUNKS
+    iNamelen = 0;                      /* indicate so */
+#endif
+    iRemain  = 0;
+    pTemp    = MNG_NULL;
+  }
+  else
+  {
+    pTemp = find_null (pRawdata+1);    /* find null-separator */
+                                       /* not found inside input-data ? */
+    if ((pTemp - pRawdata) > (mng_int32)iRawlen)
+      pTemp  = pRawdata + iRawlen;     /* than remainder is name */
+
+#ifdef MNG_STORE_CHUNKS
+    iNamelen = (mng_uint32)((pTemp - pRawdata) - 1);
+#endif
+    iRemain  = (mng_uint32)(iRawlen - (pTemp - pRawdata));
+
+    if (iRemain)                       /* if there is remaining data it's less 1 byte */
+      iRemain--;
+
+    if ((iRemain) && (iRemain < 4))    /* remains must be empty or at least 4 bytes */
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if (iRemain)
+    {
+      iRequired = 4;                   /* calculate and check required remaining length */
+
+      if (*(pTemp+1)) { iRequired += 4; }
+      if (*(pTemp+2)) { iRequired += 4; }
+      if (*(pTemp+3)) { iRequired += 17; }
+
+      if (*(pTemp+4))
+      {
+        if ((iRemain - iRequired) % 4 != 0)
+          MNG_ERROR (pData, MNG_INVALIDLENGTH);
+      }
+      else
+      {
+        if (iRemain != iRequired)
+          MNG_ERROR (pData, MNG_INVALIDLENGTH);
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_uint8p  pWork           = pTemp;
+    mng_uint8   iFramemode      = 0;
+    mng_uint8   iChangedelay    = 0;
+    mng_uint32  iDelay          = 0;
+    mng_uint8   iChangetimeout  = 0;
+    mng_uint32  iTimeout        = 0;
+    mng_uint8   iChangeclipping = 0;
+    mng_uint8   iCliptype       = 0;
+    mng_int32   iClipl          = 0;
+    mng_int32   iClipr          = 0;
+    mng_int32   iClipt          = 0;
+    mng_int32   iClipb          = 0;
+    mng_retcode iRetcode;
+
+    if (iRawlen)                       /* any data specified ? */
+    {
+      if (*(pRawdata))                 /* save the new framing mode ? */
+      {
+        iFramemode = *(pRawdata);
+
+#ifndef MNG_NO_OLD_VERSIONS
+        if (pData->bPreDraft48)        /* old style input-stream ? */
+        {
+          switch (iFramemode)
+          {
+            case  0: { break; }
+            case  1: { iFramemode = 3; break; }
+            case  2: { iFramemode = 4; break; }
+            case  3: { iFramemode = 1; break; }
+            case  4: { iFramemode = 1; break; }
+            case  5: { iFramemode = 2; break; }
+            default: { iFramemode = 1; break; }
+          }
+        }
+#endif
+      }
+
+      if (iRemain)
+      {
+        iChangedelay    = *(pWork+1);
+        iChangetimeout  = *(pWork+2);
+        iChangeclipping = *(pWork+3);
+        pWork += 5;
+
+        if (iChangedelay)              /* delay changed ? */
+        {
+          iDelay = mng_get_uint32 (pWork);
+          pWork += 4;
+        }
+
+        if (iChangetimeout)            /* timeout changed ? */
+        {
+          iTimeout = mng_get_uint32 (pWork);
+          pWork += 4;
+        }
+
+        if (iChangeclipping)           /* clipping changed ? */
+        {
+          iCliptype = *pWork;
+          iClipl    = mng_get_int32 (pWork+1);
+          iClipr    = mng_get_int32 (pWork+5);
+          iClipt    = mng_get_int32 (pWork+9);
+          iClipb    = mng_get_int32 (pWork+13);
+        }
+      }
+    }
+
+    iRetcode = mng_create_ani_fram (pData, iFramemode, iChangedelay, iDelay,
+                                    iChangetimeout, iTimeout,
+                                    iChangeclipping, iCliptype,
+                                    iClipl, iClipr, iClipt, iClipb);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_fram (pData, iFramemode, iChangedelay, iDelay,
+                                           iChangetimeout, iTimeout,
+                                           iChangeclipping, iCliptype,
+                                           iClipl, iClipr, iClipt, iClipb); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_framp)*ppChunk)->bEmpty              = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+    {
+      mng_uint8 iFramemode = *(pRawdata);
+
+#ifndef MNG_NO_OLD_VERSIONS
+      if (pData->bPreDraft48)          /* old style input-stream ? */
+      {
+        switch (iFramemode)
+        {
+          case  1: { iFramemode = 3; break; }
+          case  2: { iFramemode = 4; break; }
+          case  3: { iFramemode = 5; break; }    /* TODO: provision for mode=5 ??? */
+          case  4: { iFramemode = 1; break; }
+          case  5: { iFramemode = 2; break; }
+          default: { iFramemode = 1; break; }
+        }
+      }
+#endif
+
+      ((mng_framp)*ppChunk)->iMode             = iFramemode;
+      ((mng_framp)*ppChunk)->iNamesize         = iNamelen;
+
+      if (iNamelen)
+      {
+        MNG_ALLOC (pData, ((mng_framp)*ppChunk)->zName, iNamelen+1);
+        MNG_COPY (((mng_framp)*ppChunk)->zName, pRawdata+1, iNamelen);
+      }
+
+      if (iRemain)
+      {
+        ((mng_framp)*ppChunk)->iChangedelay    = *(pTemp+1);
+        ((mng_framp)*ppChunk)->iChangetimeout  = *(pTemp+2);
+        ((mng_framp)*ppChunk)->iChangeclipping = *(pTemp+3);
+        ((mng_framp)*ppChunk)->iChangesyncid   = *(pTemp+4);
+
+        pTemp += 5;
+
+        if (((mng_framp)*ppChunk)->iChangedelay)
+        {
+          ((mng_framp)*ppChunk)->iDelay        = mng_get_uint32 (pTemp);
+          pTemp += 4;
+        }
+
+        if (((mng_framp)*ppChunk)->iChangetimeout)
+        {
+          ((mng_framp)*ppChunk)->iTimeout      = mng_get_uint32 (pTemp);
+          pTemp += 4;
+        }
+
+        if (((mng_framp)*ppChunk)->iChangeclipping)
+        {
+          ((mng_framp)*ppChunk)->iBoundarytype = *pTemp;
+          ((mng_framp)*ppChunk)->iBoundaryl    = mng_get_int32 (pTemp+1);
+          ((mng_framp)*ppChunk)->iBoundaryr    = mng_get_int32 (pTemp+5);
+          ((mng_framp)*ppChunk)->iBoundaryt    = mng_get_int32 (pTemp+9);
+          ((mng_framp)*ppChunk)->iBoundaryb    = mng_get_int32 (pTemp+13);
+          pTemp += 17;
+        }
+
+        if (((mng_framp)*ppChunk)->iChangesyncid)
+        {
+          ((mng_framp)*ppChunk)->iCount        = (iRemain - iRequired) / 4;
+
+          if (((mng_framp)*ppChunk)->iCount)
+          {
+            MNG_ALLOC (pData, ((mng_framp)*ppChunk)->pSyncids,
+                              ((mng_framp)*ppChunk)->iCount * 4);
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+            {
+              mng_uint32 iX;
+              mng_uint32p pOut = ((mng_framp)*ppChunk)->pSyncids;
+
+              for (iX = 0; iX < ((mng_framp)*ppChunk)->iCount; iX++)
+              {
+                *pOut++ = mng_get_uint32 (pTemp);
+                pTemp += 4;
+              }
+            }
+#else
+            MNG_COPY (((mng_framp)*ppChunk)->pSyncids, pTemp,
+                      ((mng_framp)*ppChunk)->iCount * 4);
+#endif /* !MNG_BIGENDIAN_SUPPORTED */
+          }
+        }
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_FRAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_MOVE
+READ_CHUNK (mng_read_move)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MOVE, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 13)                   /* check the length */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+                                       /* create a MOVE animation object */
+    iRetcode = mng_create_ani_move (pData, mng_get_uint16 (pRawdata),
+                                           mng_get_uint16 (pRawdata+2),
+                                           *(pRawdata+4),
+                                           mng_get_int32 (pRawdata+5),
+                                           mng_get_int32 (pRawdata+9));
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_move (pData,
+                                           mng_get_uint16 (pRawdata),
+                                           mng_get_uint16 (pRawdata+2),
+                                           *(pRawdata+4),
+                                           mng_get_int32 (pRawdata+5),
+                                           mng_get_int32 (pRawdata+9)); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_movep)*ppChunk)->iFirstid  = mng_get_uint16 (pRawdata);
+    ((mng_movep)*ppChunk)->iLastid   = mng_get_uint16 (pRawdata+2);
+    ((mng_movep)*ppChunk)->iMovetype = *(pRawdata+4);
+    ((mng_movep)*ppChunk)->iMovex    = mng_get_int32 (pRawdata+5);
+    ((mng_movep)*ppChunk)->iMovey    = mng_get_int32 (pRawdata+9);
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_CLIP
+READ_CHUNK (mng_read_clip)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CLIP, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 21)                   /* check the length */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+                                       /* create a CLIP animation object */
+    iRetcode = mng_create_ani_clip (pData, mng_get_uint16 (pRawdata),
+                                           mng_get_uint16 (pRawdata+2),
+                                           *(pRawdata+4),
+                                           mng_get_int32 (pRawdata+5),
+                                           mng_get_int32 (pRawdata+9),
+                                           mng_get_int32 (pRawdata+13),
+                                           mng_get_int32 (pRawdata+17));
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_clip (pData,
+                                           mng_get_uint16 (pRawdata),
+                                           mng_get_uint16 (pRawdata+2),
+                                           *(pRawdata+4),
+                                           mng_get_int32 (pRawdata+5),
+                                           mng_get_int32 (pRawdata+9),
+                                           mng_get_int32 (pRawdata+13),
+                                           mng_get_int32 (pRawdata+17)); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_clipp)*ppChunk)->iFirstid  = mng_get_uint16 (pRawdata);
+    ((mng_clipp)*ppChunk)->iLastid   = mng_get_uint16 (pRawdata+2);
+    ((mng_clipp)*ppChunk)->iCliptype = *(pRawdata+4);
+    ((mng_clipp)*ppChunk)->iClipl    = mng_get_int32 (pRawdata+5);
+    ((mng_clipp)*ppChunk)->iClipr    = mng_get_int32 (pRawdata+9);
+    ((mng_clipp)*ppChunk)->iClipt    = mng_get_int32 (pRawdata+13);
+    ((mng_clipp)*ppChunk)->iClipb    = mng_get_int32 (pRawdata+17);
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_SHOW
+READ_CHUNK (mng_read_show)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SHOW, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check the length */
+  if ((iRawlen != 0) && (iRawlen != 2) && (iRawlen != 4) && (iRawlen != 5))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+
+    if (iRawlen)                       /* determine parameters if any */
+    {
+      pData->iSHOWfromid = mng_get_uint16 (pRawdata);
+
+      if (iRawlen > 2)
+        pData->iSHOWtoid = mng_get_uint16 (pRawdata+2);
+      else
+        pData->iSHOWtoid = pData->iSHOWfromid;
+
+      if (iRawlen > 4)
+        pData->iSHOWmode = *(pRawdata+4);
+      else
+        pData->iSHOWmode = 0;
+    }
+    else                               /* use defaults then */
+    {
+      pData->iSHOWmode   = 2;
+      pData->iSHOWfromid = 1;
+      pData->iSHOWtoid   = 65535;
+    }
+                                       /* create a SHOW animation object */
+    iRetcode = mng_create_ani_show (pData, pData->iSHOWfromid,
+                                    pData->iSHOWtoid, pData->iSHOWmode);
+
+    if (!iRetcode)
+      iRetcode = mng_process_display_show (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_showp)*ppChunk)->bEmpty      = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+    {
+      ((mng_showp)*ppChunk)->iFirstid  = mng_get_uint16 (pRawdata);
+
+      if (iRawlen > 2)
+        ((mng_showp)*ppChunk)->iLastid = mng_get_uint16 (pRawdata+2);
+      else
+        ((mng_showp)*ppChunk)->iLastid = ((mng_showp)*ppChunk)->iFirstid;
+
+      if (iRawlen > 4)
+        ((mng_showp)*ppChunk)->iMode   = *(pRawdata+4);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_TERM
+READ_CHUNK (mng_read_term)
+{
+  mng_uint8   iTermaction;
+  mng_uint8   iIteraction = 0;
+  mng_uint32  iDelay      = 0;
+  mng_uint32  iItermax    = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TERM, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+                                       /* should be behind MHDR or SAVE !! */
+  if ((!pData->bHasSAVE) && (pData->iChunkseq > 2))
+  {
+    pData->bMisplacedTERM = MNG_TRUE;  /* indicate we found a misplaced TERM */
+                                       /* and send a warning signal!!! */
+    MNG_WARNING (pData, MNG_SEQUENCEERROR);
+  }
+
+  if (pData->bHasLOOP)                 /* no way, jose! */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (pData->bHasTERM)                 /* only 1 allowed! */
+    MNG_ERROR (pData, MNG_MULTIPLEERROR);
+                                       /* check the length */
+  if ((iRawlen != 1) && (iRawlen != 10))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasTERM = MNG_TRUE;
+
+  iTermaction = *pRawdata;             /* get the fields */
+
+  if (iRawlen > 1)
+  {
+    iIteraction = *(pRawdata+1);
+    iDelay      = mng_get_uint32 (pRawdata+2);
+    iItermax    = mng_get_uint32 (pRawdata+6);
+  }
+
+  if (pData->fProcessterm)             /* inform the app ? */
+    if (!pData->fProcessterm (((mng_handle)pData), iTermaction, iIteraction,
+                                                   iDelay, iItermax))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create the TERM ani-object */
+    mng_retcode iRetcode = mng_create_ani_term (pData, iTermaction, iIteraction,
+                                                iDelay, iItermax);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* save for future reference */
+    pData->pTermaniobj = pData->pLastaniobj;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_termp)*ppChunk)->iTermaction = iTermaction;
+    ((mng_termp)*ppChunk)->iIteraction = iIteraction;
+    ((mng_termp)*ppChunk)->iDelay      = iDelay;
+    ((mng_termp)*ppChunk)->iItermax    = iItermax;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_SAVE
+READ_CHUNK (mng_read_save)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SAVE, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (pData->bHasSAVE))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  pData->bHasSAVE = MNG_TRUE;
+
+  if (pData->fProcesssave)             /* inform the application ? */
+  {
+    mng_bool bOke = pData->fProcesssave ((mng_handle)pData);
+
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+
+
+    /* TODO: something with the parameters */
+
+
+                                       /* create a SAVE animation object */
+    iRetcode = mng_create_ani_save (pData);
+
+    if (!iRetcode)
+      iRetcode = mng_process_display_save (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+      
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_savep)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)                       /* not empty ? */
+    {
+      mng_uint8       iOtype = *pRawdata;
+      mng_uint8       iEtype;
+      mng_uint32      iCount = 0;
+      mng_uint8p      pTemp;
+      mng_uint8p      pNull;
+      mng_uint32      iLen;
+      mng_uint32      iOffset[2];
+      mng_uint32      iStarttime[2];
+      mng_uint32      iFramenr;
+      mng_uint32      iLayernr;
+      mng_uint32      iX;
+      mng_save_entryp pEntry = MNG_NULL;
+      mng_uint32      iNamesize;
+
+      if ((iOtype != 4) && (iOtype != 8))
+        MNG_ERROR (pData, MNG_INVOFFSETSIZE);
+
+      ((mng_savep)*ppChunk)->iOffsettype = iOtype;
+
+      for (iX = 0; iX < 2; iX++)       /* do this twice to get the count first ! */
+      {
+        pTemp = pRawdata + 1;
+        iLen  = iRawlen  - 1;
+
+        if (iX)                        /* second run ? */
+        {
+          MNG_ALLOC (pData, pEntry, (iCount * sizeof (mng_save_entry)));
+
+          ((mng_savep)*ppChunk)->iCount   = iCount;
+          ((mng_savep)*ppChunk)->pEntries = pEntry;
+        }
+
+        while (iLen)                   /* anything left ? */
+        {
+          iEtype = *pTemp;             /* entrytype */
+
+          if ((iEtype != 0) && (iEtype != 1) && (iEtype != 2) && (iEtype != 3))
+            MNG_ERROR (pData, MNG_INVENTRYTYPE);
+
+          pTemp++;
+
+          if (iEtype > 1)
+          {
+            iOffset    [0] = 0;
+            iOffset    [1] = 0;
+            iStarttime [0] = 0;
+            iStarttime [1] = 0;
+            iLayernr       = 0;
+            iFramenr       = 0;
+          }
+          else
+          {
+            if (iOtype == 4)
+            {
+              iOffset [0] = 0;
+              iOffset [1] = mng_get_uint32 (pTemp);
+
+              pTemp += 4;
+            }
+            else
+            {
+              iOffset [0] = mng_get_uint32 (pTemp);
+              iOffset [1] = mng_get_uint32 (pTemp+4);
+
+              pTemp += 8;
+            }
+
+            if (iEtype > 0)
+            {
+              iStarttime [0] = 0;
+              iStarttime [1] = 0;
+              iLayernr       = 0;
+              iFramenr       = 0;
+            }
+            else
+            {
+              if (iOtype == 4)
+              {
+                iStarttime [0] = 0;
+                iStarttime [1] = mng_get_uint32 (pTemp+0);
+                iLayernr       = mng_get_uint32 (pTemp+4);
+                iFramenr       = mng_get_uint32 (pTemp+8);
+
+                pTemp += 12;
+              }
+              else
+              {
+                iStarttime [0] = mng_get_uint32 (pTemp+0);
+                iStarttime [1] = mng_get_uint32 (pTemp+4);
+                iLayernr       = mng_get_uint32 (pTemp+8);
+                iFramenr       = mng_get_uint32 (pTemp+12);
+
+                pTemp += 16;
+              }
+            }
+          }
+
+          pNull = find_null (pTemp);   /* get the name length */
+
+          if ((pNull - pRawdata) > (mng_int32)iRawlen)
+          {
+            iNamesize = iLen;          /* no null found; so end of SAVE */
+            iLen      = 0;
+          }
+          else
+          {
+            iNamesize = pNull - pTemp; /* should be another entry */
+            iLen     -= iNamesize;
+
+            if (!iLen)                 /* must not end with a null ! */
+              MNG_ERROR (pData, MNG_ENDWITHNULL);
+          }
+
+          if (!pEntry)
+          {
+            iCount++;
+          }
+          else
+          {
+            pEntry->iEntrytype     = iEtype;
+            pEntry->iOffset    [0] = iOffset    [0];
+            pEntry->iOffset    [1] = iOffset    [1];
+            pEntry->iStarttime [0] = iStarttime [0];
+            pEntry->iStarttime [1] = iStarttime [1];
+            pEntry->iLayernr       = iLayernr;
+            pEntry->iFramenr       = iFramenr;
+            pEntry->iNamesize      = iNamesize;
+
+            if (iNamesize)
+            {
+              MNG_ALLOC (pData, pEntry->zName, iNamesize+1);
+              MNG_COPY (pEntry->zName, pTemp, iNamesize);
+            }
+
+            pEntry++;
+          }
+
+          pTemp += iNamesize;
+        }
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_SEEK
+READ_CHUNK (mng_read_seek)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SEEK, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (!pData->bHasSAVE))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_SUPPORT_DISPLAY
+                                       /* create a SEEK animation object */
+  iRetcode = mng_create_ani_seek (pData, iRawlen, (mng_pchar)pRawdata);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+    
+#endif /* MNG_SUPPORT_DISPLAY */
+
+  if (pData->fProcessseek)             /* inform the app ? */
+  {
+    mng_bool  bOke;
+    mng_pchar zName;
+
+    MNG_ALLOC (pData, zName, iRawlen + 1);
+
+    if (iRawlen)
+      MNG_COPY (zName, pRawdata, iRawlen);
+
+    bOke = pData->fProcessseek ((mng_handle)pData, zName);
+
+    MNG_FREEX (pData, zName, iRawlen + 1);
+
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+                                       /* do display processing of the SEEK */
+  iRetcode = mng_process_display_seek (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_seekp)*ppChunk)->iNamesize = iRawlen;
+
+    if (iRawlen)
+    {
+      MNG_ALLOC (pData, ((mng_seekp)*ppChunk)->zName, iRawlen+1);
+      MNG_COPY (((mng_seekp)*ppChunk)->zName, pRawdata, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_eXPI
+READ_CHUNK (mng_read_expi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_EXPI, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 3)                     /* check the length */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_expip)*ppChunk)->iSnapshotid = mng_get_uint16 (pRawdata);
+    ((mng_expip)*ppChunk)->iNamesize   = iRawlen - 2;
+
+    if (((mng_expip)*ppChunk)->iNamesize)
+    {
+      MNG_ALLOC (pData, ((mng_expip)*ppChunk)->zName,
+                        ((mng_expip)*ppChunk)->iNamesize + 1);
+      MNG_COPY (((mng_expip)*ppChunk)->zName, pRawdata+2,
+                ((mng_expip)*ppChunk)->iNamesize);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_EXPI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_fPRI
+READ_CHUNK (mng_read_fpri)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_FPRI, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 2)                    /* must be two bytes long */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_fprip)*ppChunk)->iDeltatype = *pRawdata;
+    ((mng_fprip)*ppChunk)->iPriority  = *(pRawdata+1);
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_FPRI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_nEED
+MNG_LOCAL mng_bool CheckKeyword (mng_datap  pData,
+                                 mng_uint8p pKeyword)
+{
+  mng_chunkid handled_chunks [] =
+  {
+    MNG_UINT_BACK,                     /* keep it sorted !!!! */
+    MNG_UINT_BASI,
+    MNG_UINT_CLIP,
+    MNG_UINT_CLON,
+#ifndef MNG_NO_DELTA_PNG
+/* TODO:    MNG_UINT_DBYK,  */
+#endif
+    MNG_UINT_DEFI,
+#ifndef MNG_NO_DELTA_PNG
+    MNG_UINT_DHDR,
+#endif
+    MNG_UINT_DISC,
+#ifndef MNG_NO_DELTA_PNG
+/* TODO:    MNG_UINT_DROP,  */
+#endif
+    MNG_UINT_ENDL,
+    MNG_UINT_FRAM,
+    MNG_UINT_IDAT,
+    MNG_UINT_IEND,
+    MNG_UINT_IHDR,
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+    MNG_UINT_IJNG,
+#endif    
+    MNG_UINT_IPNG,
+#endif
+#ifdef MNG_INCLUDE_JNG
+    MNG_UINT_JDAA,
+    MNG_UINT_JDAT,
+    MNG_UINT_JHDR,
+/* TODO:    MNG_UINT_JSEP,  */
+    MNG_UINT_JdAA,
+#endif
+    MNG_UINT_LOOP,
+    MNG_UINT_MAGN,
+    MNG_UINT_MEND,
+    MNG_UINT_MHDR,
+    MNG_UINT_MOVE,
+/* TODO:    MNG_UINT_ORDR,  */
+    MNG_UINT_PAST,
+    MNG_UINT_PLTE,
+#ifndef MNG_NO_DELTA_PNG
+    MNG_UINT_PPLT,
+    MNG_UINT_PROM,
+#endif
+    MNG_UINT_SAVE,
+    MNG_UINT_SEEK,
+    MNG_UINT_SHOW,
+    MNG_UINT_TERM,
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+    MNG_UINT_adAT,
+    MNG_UINT_ahDR,
+#endif
+    MNG_UINT_bKGD,
+    MNG_UINT_cHRM,
+/* TODO:    MNG_UINT_eXPI,  */
+    MNG_UINT_evNT,
+/* TODO:    MNG_UINT_fPRI,  */
+    MNG_UINT_gAMA,
+/* TODO:    MNG_UINT_hIST,  */
+    MNG_UINT_iCCP,
+    MNG_UINT_iTXt,
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    MNG_UINT_mpNG,
+#endif
+    MNG_UINT_nEED,
+/* TODO:    MNG_UINT_oFFs,  */
+/* TODO:    MNG_UINT_pCAL,  */
+/* TODO:    MNG_UINT_pHYg,  */
+/* TODO:    MNG_UINT_pHYs,  */
+/* TODO:    MNG_UINT_sBIT,  */
+/* TODO:    MNG_UINT_sCAL,  */
+/* TODO:    MNG_UINT_sPLT,  */
+    MNG_UINT_sRGB,
+    MNG_UINT_tEXt,
+    MNG_UINT_tIME,
+    MNG_UINT_tRNS,
+    MNG_UINT_zTXt,
+  };
+
+  mng_bool bOke = MNG_FALSE;
+
+  if (pData->fProcessneed)             /* does the app handle it ? */
+    bOke = pData->fProcessneed ((mng_handle)pData, (mng_pchar)pKeyword);
+
+  if (!bOke)
+  {                                    /* find the keyword length */
+    mng_uint8p pNull = find_null (pKeyword);
+
+    if (pNull - pKeyword == 4)         /* test a chunk ? */
+    {                                  /* get the chunk-id */
+      mng_chunkid iChunkid = (*pKeyword     << 24) + (*(pKeyword+1) << 16) +
+                             (*(pKeyword+2) <<  8) + (*(pKeyword+3)      );
+                                       /* binary search variables */
+      mng_int32   iTop, iLower, iUpper, iMiddle;
+                                       /* determine max index of table */
+      iTop = (sizeof (handled_chunks) / sizeof (handled_chunks [0])) - 1;
+
+      /* binary search; with 52 chunks, worst-case is 7 comparisons */
+      iLower  = 0;
+      iMiddle = iTop >> 1;
+      iUpper  = iTop;
+
+      do                                   /* the binary search itself */
+        {
+          if (handled_chunks [iMiddle] < iChunkid)
+            iLower = iMiddle + 1;
+          else if (handled_chunks [iMiddle] > iChunkid)
+            iUpper = iMiddle - 1;
+          else
+          {
+            bOke = MNG_TRUE;
+            break;
+          }
+
+          iMiddle = (iLower + iUpper) >> 1;
+        }
+      while (iLower <= iUpper);
+    }
+                                       /* test draft ? */
+    if ((!bOke) && (pNull - pKeyword == 8) &&
+        (*pKeyword     == 'd') && (*(pKeyword+1) == 'r') &&
+        (*(pKeyword+2) == 'a') && (*(pKeyword+3) == 'f') &&
+        (*(pKeyword+4) == 't') && (*(pKeyword+5) == ' '))
+    {
+      mng_uint32 iDraft;
+
+      iDraft = (*(pKeyword+6) - '0') * 10 + (*(pKeyword+7) - '0');
+      bOke   = (mng_bool)(iDraft <= MNG_MNG_DRAFT);
+    }
+                                       /* test MNG 1.0/1.1 ? */
+    if ((!bOke) && (pNull - pKeyword == 7) &&
+        (*pKeyword     == 'M') && (*(pKeyword+1) == 'N') &&
+        (*(pKeyword+2) == 'G') && (*(pKeyword+3) == '-') &&
+        (*(pKeyword+4) == '1') && (*(pKeyword+5) == '.') &&
+        ((*(pKeyword+6) == '0') || (*(pKeyword+6) == '1')))
+      bOke   = MNG_TRUE;
+                                       /* test CACHEOFF ? */
+    if ((!bOke) && (pNull - pKeyword == 8) &&
+        (*pKeyword     == 'C') && (*(pKeyword+1) == 'A') &&
+        (*(pKeyword+2) == 'C') && (*(pKeyword+3) == 'H') &&
+        (*(pKeyword+4) == 'E') && (*(pKeyword+5) == 'O') &&
+        (*(pKeyword+6) == 'F') && (*(pKeyword+7) == 'F'))
+    {
+      if (!pData->pFirstaniobj)        /* only if caching hasn't started yet ! */
+      {
+        bOke                  = MNG_TRUE;
+        pData->bCacheplayback = MNG_FALSE;
+        pData->bStorechunks   = MNG_FALSE;
+      }
+    }
+  }
+
+  return bOke;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_nEED
+READ_CHUNK (mng_read_need)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_NEED, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 1)                     /* check the length */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  {                                    /* let's check it */
+    mng_bool   bOke = MNG_TRUE;
+    mng_pchar  zKeywords;
+    mng_uint8p pNull, pTemp;
+
+    MNG_ALLOC (pData, zKeywords, iRawlen + 1);
+
+    if (iRawlen)
+      MNG_COPY (zKeywords, pRawdata, iRawlen);
+
+    pTemp = (mng_uint8p)zKeywords;
+    pNull = find_null (pTemp);
+
+    while ((bOke) && (pNull < (mng_uint8p)zKeywords + iRawlen))
+    {
+      bOke  = CheckKeyword (pData, pTemp);
+      pTemp = pNull + 1;
+      pNull = find_null (pTemp);
+    }
+
+    if (bOke)
+      bOke = CheckKeyword (pData, pTemp);
+
+    MNG_FREEX (pData, zKeywords, iRawlen + 1);
+
+    if (!bOke)
+      MNG_ERROR (pData, MNG_UNSUPPORTEDNEED);
+  }
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_needp)*ppChunk)->iKeywordssize = iRawlen;
+
+    if (iRawlen)
+    {
+      MNG_ALLOC (pData, ((mng_needp)*ppChunk)->zKeywords, iRawlen+1);
+      MNG_COPY (((mng_needp)*ppChunk)->zKeywords, pRawdata, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_NEED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_pHYg
+READ_CHUNK (mng_read_phyg)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PHYG, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* it's 9 bytes or empty; no more, no less! */
+  if ((iRawlen != 9) && (iRawlen != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_phygp)*ppChunk)->bEmpty = (mng_bool)(iRawlen == 0);
+
+    if (iRawlen)
+    {
+      ((mng_phygp)*ppChunk)->iSizex = mng_get_uint32 (pRawdata);
+      ((mng_phygp)*ppChunk)->iSizey = mng_get_uint32 (pRawdata+4);
+      ((mng_phygp)*ppChunk)->iUnit  = *(pRawdata+8);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PHYG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_INCLUDE_JNG
+READ_CHUNK (mng_read_jhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JHDR, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((pData->eSigtype != mng_it_jng) && (pData->eSigtype != mng_it_mng))
+    MNG_ERROR (pData, MNG_CHUNKNOTALLOWED);
+
+  if ((pData->eSigtype == mng_it_jng) && (pData->iChunkseq > 1))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 16)                   /* length oke ? */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                                       /* inside a JHDR-IEND block now */
+  pData->bHasJHDR              = MNG_TRUE;
+                                       /* and store interesting fields */
+  pData->iDatawidth            = mng_get_uint32 (pRawdata);
+  pData->iDataheight           = mng_get_uint32 (pRawdata+4);
+  pData->iJHDRcolortype        = *(pRawdata+8);
+  pData->iJHDRimgbitdepth      = *(pRawdata+9);
+  pData->iJHDRimgcompression   = *(pRawdata+10);
+  pData->iJHDRimginterlace     = *(pRawdata+11);
+  pData->iJHDRalphabitdepth    = *(pRawdata+12);
+  pData->iJHDRalphacompression = *(pRawdata+13);
+  pData->iJHDRalphafilter      = *(pRawdata+14);
+  pData->iJHDRalphainterlace   = *(pRawdata+15);
+
+
+#if defined(MNG_NO_1_2_4BIT_SUPPORT) || defined(MNG_NO_16BIT_SUPPORT)
+  pData->iPNGmult = 1;
+  pData->iPNGdepth = pData->iJHDRalphabitdepth;
+#endif
+
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+  if (pData->iJHDRalphabitdepth < 8)
+    pData->iJHDRalphabitdepth = 8;
+#endif
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (pData->iJHDRalphabitdepth > 8)
+  {
+    pData->iPNGmult = 2;
+    pData->iJHDRalphabitdepth = 8;
+  }
+#endif
+                                       /* parameter validity checks */
+  if ((pData->iJHDRcolortype != MNG_COLORTYPE_JPEGGRAY  ) &&
+      (pData->iJHDRcolortype != MNG_COLORTYPE_JPEGCOLOR ) &&
+      (pData->iJHDRcolortype != MNG_COLORTYPE_JPEGGRAYA ) &&
+      (pData->iJHDRcolortype != MNG_COLORTYPE_JPEGCOLORA)    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  if ((pData->iJHDRimgbitdepth != MNG_BITDEPTH_JPEG8     ) &&
+      (pData->iJHDRimgbitdepth != MNG_BITDEPTH_JPEG12    ) &&
+      (pData->iJHDRimgbitdepth != MNG_BITDEPTH_JPEG8AND12)    )
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if (pData->iJHDRimgcompression != MNG_COMPRESSION_BASELINEJPEG)
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+  if ((pData->iJHDRimginterlace != MNG_INTERLACE_SEQUENTIAL ) &&
+      (pData->iJHDRimginterlace != MNG_INTERLACE_PROGRESSIVE)    )
+    MNG_ERROR (pData, MNG_INVALIDINTERLACE);
+
+  if ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA ) ||
+      (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )
+  {
+    if ((pData->iJHDRalphabitdepth != MNG_BITDEPTH_8 )
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        && (pData->iJHDRalphabitdepth != MNG_BITDEPTH_1 ) &&
+        (pData->iJHDRalphabitdepth != MNG_BITDEPTH_2 ) &&
+        (pData->iJHDRalphabitdepth != MNG_BITDEPTH_4 )
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+        && (pData->iJHDRalphabitdepth != MNG_BITDEPTH_16)
+#endif
+        )
+      MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+    if ((pData->iJHDRalphacompression != MNG_COMPRESSION_DEFLATE     ) &&
+        (pData->iJHDRalphacompression != MNG_COMPRESSION_BASELINEJPEG)    )
+      MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+    if ((pData->iJHDRalphacompression == MNG_COMPRESSION_BASELINEJPEG) &&
+        (pData->iJHDRalphabitdepth    !=  MNG_BITDEPTH_8             )    )
+      MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+#if defined(FILTER192) || defined(FILTER193)
+    if ((pData->iJHDRalphafilter != MNG_FILTER_ADAPTIVE ) &&
+#if defined(FILTER192) && defined(FILTER193)
+        (pData->iJHDRalphafilter != MNG_FILTER_DIFFERING) &&
+        (pData->iJHDRalphafilter != MNG_FILTER_NOFILTER )    )
+#else
+#ifdef FILTER192
+        (pData->iJHDRalphafilter != MNG_FILTER_DIFFERING)    )
+#else
+        (pData->iJHDRalphafilter != MNG_FILTER_NOFILTER )    )
+#endif
+#endif
+      MNG_ERROR (pData, MNG_INVALIDFILTER);
+#else
+    if (pData->iJHDRalphafilter)
+      MNG_ERROR (pData, MNG_INVALIDFILTER);
+#endif
+
+    if ((pData->iJHDRalphainterlace != MNG_INTERLACE_NONE ) &&
+        (pData->iJHDRalphainterlace != MNG_INTERLACE_ADAM7)    )
+      MNG_ERROR (pData, MNG_INVALIDINTERLACE);
+
+  }
+  else
+  {
+    if (pData->iJHDRalphabitdepth)
+      MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+    if (pData->iJHDRalphacompression)
+      MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+    if (pData->iJHDRalphafilter)
+      MNG_ERROR (pData, MNG_INVALIDFILTER);
+
+    if (pData->iJHDRalphainterlace)
+      MNG_ERROR (pData, MNG_INVALIDINTERLACE);
+
+  }
+
+  if (!pData->bHasheader)              /* first chunk ? */
+  {
+    pData->bHasheader = MNG_TRUE;      /* we've got a header */
+    pData->eImagetype = mng_it_jng;    /* then this must be a JNG */
+    pData->iWidth     = mng_get_uint32 (pRawdata);
+    pData->iHeight    = mng_get_uint32 (pRawdata+4);
+                                       /* predict alpha-depth ! */
+  if ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA ) ||
+      (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )
+      pData->iAlphadepth = pData->iJHDRalphabitdepth;
+    else
+      pData->iAlphadepth = 0;
+                                       /* fits on maximum canvas ? */
+    if ((pData->iWidth > pData->iMaxwidth) || (pData->iHeight > pData->iMaxheight))
+      MNG_WARNING (pData, MNG_IMAGETOOLARGE);
+
+    if (pData->fProcessheader)         /* inform the app ? */
+      if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+
+  }
+
+  pData->iColortype = 0;               /* fake grayscale for other routines */
+  pData->iImagelevel++;                /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode = mng_process_display_jhdr (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_jhdrp)*ppChunk)->iWidth            = mng_get_uint32 (pRawdata);
+    ((mng_jhdrp)*ppChunk)->iHeight           = mng_get_uint32 (pRawdata+4);
+    ((mng_jhdrp)*ppChunk)->iColortype        = *(pRawdata+8);
+    ((mng_jhdrp)*ppChunk)->iImagesampledepth = *(pRawdata+9);
+    ((mng_jhdrp)*ppChunk)->iImagecompression = *(pRawdata+10);
+    ((mng_jhdrp)*ppChunk)->iImageinterlace   = *(pRawdata+11);
+    ((mng_jhdrp)*ppChunk)->iAlphasampledepth = *(pRawdata+12);
+#ifdef MNG_NO_16BIT_SUPPORT
+    if (*(pRawdata+12) > 8)
+        ((mng_jhdrp)*ppChunk)->iAlphasampledepth = 8;
+#endif
+    ((mng_jhdrp)*ppChunk)->iAlphacompression = *(pRawdata+13);
+    ((mng_jhdrp)*ppChunk)->iAlphafilter      = *(pRawdata+14);
+    ((mng_jhdrp)*ppChunk)->iAlphainterlace   = *(pRawdata+15);
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#else
+#define read_jhdr 0
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_INCLUDE_JNG
+READ_CHUNK (mng_read_jdaa)
+{
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  volatile mng_retcode iRetcode;
+
+  iRetcode=MNG_NOERROR;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JDAA, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasJHDR) && (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (pData->bHasJSEP)
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+    
+  if (pData->iJHDRalphacompression != MNG_COMPRESSION_BASELINEJPEG)
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen == 0)                    /* can never be empty */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasJDAA = MNG_TRUE;          /* got some JDAA now, don't we */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  iRetcode = mng_process_display_jdaa (pData, iRawlen, pRawdata);
+
+  if (iRetcode)                      /* on error bail out */
+    return iRetcode;
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_jdaap)*ppChunk)->bEmpty    = (mng_bool)(iRawlen == 0);
+    ((mng_jdaap)*ppChunk)->iDatasize = iRawlen;
+
+    if (iRawlen != 0)                  /* is there any data ? */
+    {
+      MNG_ALLOC (pData, ((mng_jdaap)*ppChunk)->pData, iRawlen);
+      MNG_COPY  (((mng_jdaap)*ppChunk)->pData, pRawdata, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JDAA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#else
+#define read_jdaa 0
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_INCLUDE_JNG
+READ_CHUNK (mng_read_jdat)
+{
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  volatile mng_retcode iRetcode;
+
+  iRetcode=MNG_NOERROR;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JDAT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasJHDR) && (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen == 0)                    /* can never be empty */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasJDAT = MNG_TRUE;          /* got some JDAT now, don't we */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  iRetcode = mng_process_display_jdat (pData, iRawlen, pRawdata);
+
+  if (iRetcode)                      /* on error bail out */
+    return iRetcode;
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_jdatp)*ppChunk)->bEmpty    = (mng_bool)(iRawlen == 0);
+    ((mng_jdatp)*ppChunk)->iDatasize = iRawlen;
+
+    if (iRawlen != 0)                  /* is there any data ? */
+    {
+      MNG_ALLOC (pData, ((mng_jdatp)*ppChunk)->pData, iRawlen);
+      MNG_COPY  (((mng_jdatp)*ppChunk)->pData, pRawdata, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#else
+#define read_jdat 0
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_INCLUDE_JNG
+READ_CHUNK (mng_read_jsep)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JSEP, MNG_LC_START);
+#endif
+
+  if (!pData->bHasJHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 0)                    /* must be empty ! */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasJSEP = MNG_TRUE;          /* indicate we've had the 8-/12-bit separator */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_JSEP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#else
+#define read_jsep 0
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+READ_CHUNK (mng_read_dhdr)
+{
+  mng_uint8 iImagetype, iDeltatype;
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DHDR, MNG_LC_START);
+#endif
+
+  if (!pData->bHasMHDR)                /* sequence checks */
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((pData->bHasIHDR) || (pData->bHasBASI) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check for valid length */
+  if ((iRawlen != 4) && (iRawlen != 12) && (iRawlen != 20))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  iImagetype = *(pRawdata+2);          /* check fields for validity */
+  iDeltatype = *(pRawdata+3);
+
+  if (iImagetype > MNG_IMAGETYPE_JNG)
+    MNG_ERROR (pData, MNG_INVIMAGETYPE);
+
+  if (iDeltatype > MNG_DELTATYPE_NOCHANGE)
+    MNG_ERROR (pData, MNG_INVDELTATYPE);
+
+  if ((iDeltatype == MNG_DELTATYPE_REPLACE) && (iRawlen > 12))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  if ((iDeltatype == MNG_DELTATYPE_NOCHANGE) && (iRawlen > 4))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  pData->bHasDHDR   = MNG_TRUE;        /* inside a DHDR-IEND block now */
+  pData->iDeltatype = iDeltatype;
+
+  pData->iImagelevel++;                /* one level deeper */
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_uint16  iObjectid    = mng_get_uint16 (pRawdata);
+    mng_uint32  iBlockwidth  = 0;
+    mng_uint32  iBlockheight = 0;
+    mng_uint32  iBlockx      = 0;
+    mng_uint32  iBlocky      = 0;
+    mng_retcode iRetcode;
+
+    if (iRawlen > 4)
+    {
+      iBlockwidth  = mng_get_uint32 (pRawdata+4);
+      iBlockheight = mng_get_uint32 (pRawdata+8);
+    }
+
+    if (iRawlen > 12)
+    {
+      iBlockx      = mng_get_uint32 (pRawdata+12);
+      iBlocky      = mng_get_uint32 (pRawdata+16);
+    }
+
+    iRetcode = mng_create_ani_dhdr (pData, iObjectid, iImagetype, iDeltatype,
+                                    iBlockwidth, iBlockheight, iBlockx, iBlocky);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_dhdr (pData, iObjectid, iImagetype, iDeltatype,
+                                           iBlockwidth, iBlockheight, iBlockx, iBlocky); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_dhdrp)*ppChunk)->iObjectid      = mng_get_uint16 (pRawdata);
+    ((mng_dhdrp)*ppChunk)->iImagetype     = iImagetype;
+    ((mng_dhdrp)*ppChunk)->iDeltatype     = iDeltatype;
+
+    if (iRawlen > 4)
+    {
+      ((mng_dhdrp)*ppChunk)->iBlockwidth  = mng_get_uint32 (pRawdata+4);
+      ((mng_dhdrp)*ppChunk)->iBlockheight = mng_get_uint32 (pRawdata+8);
+    }
+
+    if (iRawlen > 12)
+    {
+      ((mng_dhdrp)*ppChunk)->iBlockx      = mng_get_uint32 (pRawdata+12);
+      ((mng_dhdrp)*ppChunk)->iBlocky      = mng_get_uint32 (pRawdata+16);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+READ_CHUNK (mng_read_prom)
+{
+  mng_uint8 iColortype;
+  mng_uint8 iSampledepth;
+  mng_uint8 iFilltype;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PROM, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 3)                    /* gotta be exactly 3 bytes */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  iColortype   = *pRawdata;            /* check fields for validity */
+  iSampledepth = *(pRawdata+1);
+  iFilltype    = *(pRawdata+2);
+
+  if ((iColortype != MNG_COLORTYPE_GRAY   ) &&
+      (iColortype != MNG_COLORTYPE_RGB    ) &&
+      (iColortype != MNG_COLORTYPE_INDEXED) &&
+      (iColortype != MNG_COLORTYPE_GRAYA  ) &&
+      (iColortype != MNG_COLORTYPE_RGBA   )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (iSampledepth == MNG_BITDEPTH_16 )
+      iSampledepth = MNG_BITDEPTH_8;
+#endif
+
+  if ((iSampledepth != MNG_BITDEPTH_1 ) &&
+      (iSampledepth != MNG_BITDEPTH_2 ) &&
+      (iSampledepth != MNG_BITDEPTH_4 ) &&
+      (iSampledepth != MNG_BITDEPTH_8 )
+#ifndef MNG_NO_16BIT_SUPPORT
+      && (iSampledepth != MNG_BITDEPTH_16)
+#endif
+    )
+    MNG_ERROR (pData, MNG_INVSAMPLEDEPTH);
+
+  if ((iFilltype != MNG_FILLMETHOD_LEFTBITREPLICATE) &&
+      (iFilltype != MNG_FILLMETHOD_ZEROFILL        )    )
+    MNG_ERROR (pData, MNG_INVFILLMETHOD);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode = mng_create_ani_prom (pData, iSampledepth,
+                                                iColortype, iFilltype);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_prom (pData, iSampledepth,
+                                           iColortype, iFilltype); */
+                                           
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_promp)*ppChunk)->iColortype   = iColortype;
+    ((mng_promp)*ppChunk)->iSampledepth = iSampledepth;
+    ((mng_promp)*ppChunk)->iFilltype    = iFilltype;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+READ_CHUNK (mng_read_ipng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IPNG, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 0)                    /* gotta be empty */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode = mng_create_ani_ipng (pData);
+
+    if (!iRetcode)
+      iRetcode = mng_process_display_ipng (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+READ_CHUNK (mng_read_pplt)
+{
+  mng_uint8     iDeltatype;
+  mng_uint8p    pTemp;
+  mng_uint32    iLen;
+  mng_uint8     iX, iM;
+  mng_uint32    iY;
+  mng_uint32    iMax;
+  mng_rgbpaltab aIndexentries;
+  mng_uint8arr  aAlphaentries;
+  mng_uint8arr  aUsedentries;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PPLT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) && (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 1)                     /* must have at least 1 byte */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  iDeltatype = *pRawdata;
+                                       /* valid ? */
+  if (iDeltatype > MNG_DELTATYPE_DELTARGBA)
+    MNG_ERROR (pData, MNG_INVDELTATYPE);
+                                       /* must be indexed color ! */
+  if (pData->iColortype != MNG_COLORTYPE_INDEXED)
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  pTemp = pRawdata + 1;
+  iLen  = iRawlen - 1;
+  iMax  = 0;
+
+  for (iY = 0; iY < 256; iY++)         /* reset arrays */
+  {
+    aIndexentries [iY].iRed   = 0;
+    aIndexentries [iY].iGreen = 0;
+    aIndexentries [iY].iBlue  = 0;
+    aAlphaentries [iY]        = 255;
+    aUsedentries  [iY]        = 0;
+  }
+
+  while (iLen)                         /* as long as there are entries left ... */
+  {
+    mng_uint32 iDiff;
+
+    if (iLen < 2)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    iX = *pTemp;                       /* get start and end index */
+    iM = *(pTemp+1);
+
+    if (iM < iX)
+      MNG_ERROR (pData, MNG_INVALIDINDEX);
+
+    if ((mng_uint32)iM >= iMax)        /* determine highest used index */
+      iMax = (mng_uint32)iM + 1;
+
+    pTemp += 2;
+    iLen  -= 2;
+    iDiff = (iM - iX + 1);
+    if ((iDeltatype == MNG_DELTATYPE_REPLACERGB  ) ||
+        (iDeltatype == MNG_DELTATYPE_DELTARGB    )    )
+      iDiff = iDiff * 3;
+    else
+    if ((iDeltatype == MNG_DELTATYPE_REPLACERGBA) ||
+        (iDeltatype == MNG_DELTATYPE_DELTARGBA  )    )
+      iDiff = iDiff * 4;
+
+    if (iLen < iDiff)
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+    if ((iDeltatype == MNG_DELTATYPE_REPLACERGB  ) ||
+        (iDeltatype == MNG_DELTATYPE_DELTARGB    )    )
+    {
+      for (iY = (mng_uint32)iX; iY <= (mng_uint32)iM; iY++)
+      {
+        aIndexentries [iY].iRed   = *pTemp;
+        aIndexentries [iY].iGreen = *(pTemp+1);
+        aIndexentries [iY].iBlue  = *(pTemp+2);
+        aUsedentries  [iY]        = 1;
+
+        pTemp += 3;
+        iLen  -= 3;
+      }
+    }
+    else
+    if ((iDeltatype == MNG_DELTATYPE_REPLACEALPHA) ||
+        (iDeltatype == MNG_DELTATYPE_DELTAALPHA  )    )
+    {
+      for (iY = (mng_uint32)iX; iY <= (mng_uint32)iM; iY++)
+      {
+        aAlphaentries [iY]        = *pTemp;
+        aUsedentries  [iY]        = 1;
+
+        pTemp++;
+        iLen--;
+      }
+    }
+    else
+    {
+      for (iY = (mng_uint32)iX; iY <= (mng_uint32)iM; iY++)
+      {
+        aIndexentries [iY].iRed   = *pTemp;
+        aIndexentries [iY].iGreen = *(pTemp+1);
+        aIndexentries [iY].iBlue  = *(pTemp+2);
+        aAlphaentries [iY]        = *(pTemp+3);
+        aUsedentries  [iY]        = 1;
+
+        pTemp += 4;
+        iLen  -= 4;
+      }
+    }
+  }
+
+  switch (pData->iBitdepth)            /* check maximum allowed entries for bitdepth */
+  {
+    case MNG_BITDEPTH_1 : {
+                            if (iMax > 2)
+                              MNG_ERROR (pData, MNG_INVALIDINDEX);
+                            break;
+                          }
+    case MNG_BITDEPTH_2 : {
+                            if (iMax > 4)
+                              MNG_ERROR (pData, MNG_INVALIDINDEX);
+                            break;
+                          }
+    case MNG_BITDEPTH_4 : {
+                            if (iMax > 16)
+                              MNG_ERROR (pData, MNG_INVALIDINDEX);
+                            break;
+                          }
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {                                    /* create animation object */
+    mng_retcode iRetcode = mng_create_ani_pplt (pData, iDeltatype, iMax,
+                                                aIndexentries, aAlphaentries,
+                                                aUsedentries);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_pplt (pData, iDeltatype, iMax, aIndexentries,
+                                           aAlphaentries, aUsedentries); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_ppltp)*ppChunk)->iDeltatype = iDeltatype;
+    ((mng_ppltp)*ppChunk)->iCount     = iMax;
+
+    for (iY = 0; iY < 256; iY++)
+    {
+      ((mng_ppltp)*ppChunk)->aEntries [iY].iRed   = aIndexentries [iY].iRed;
+      ((mng_ppltp)*ppChunk)->aEntries [iY].iGreen = aIndexentries [iY].iGreen;
+      ((mng_ppltp)*ppChunk)->aEntries [iY].iBlue  = aIndexentries [iY].iBlue;
+      ((mng_ppltp)*ppChunk)->aEntries [iY].iAlpha = aAlphaentries [iY];
+      ((mng_ppltp)*ppChunk)->aEntries [iY].bUsed  = (mng_bool)(aUsedentries [iY]);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+READ_CHUNK (mng_read_ijng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IJNG, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen != 0)                    /* gotta be empty */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode = mng_create_ani_ijng (pData);
+
+    if (!iRetcode)
+      iRetcode = mng_process_display_ijng (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+READ_CHUNK (mng_read_drop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DROP, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check length */
+  if ((iRawlen < 4) || ((iRawlen % 4) != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_dropp)*ppChunk)->iCount = iRawlen / 4;
+
+    if (iRawlen)
+    {
+      mng_uint32      iX;
+      mng_uint8p      pTemp = pRawdata;
+      mng_uint32p     pEntry;
+
+      MNG_ALLOC (pData, pEntry, iRawlen);
+
+      ((mng_dropp)*ppChunk)->pChunknames = (mng_ptr)pEntry;
+
+      for (iX = 0; iX < iRawlen / 4; iX++)
+      {
+        *pEntry = mng_get_uint32 (pTemp);
+
+        pTemp  += 4;
+        pEntry++;
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DROP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+READ_CHUNK (mng_read_dbyk)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DBYK, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 6)                     /* must be at least 6 long */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_dbykp)*ppChunk)->iChunkname    = mng_get_uint32 (pRawdata);
+    ((mng_dbykp)*ppChunk)->iPolarity     = *(pRawdata+4);
+    ((mng_dbykp)*ppChunk)->iKeywordssize = iRawlen - 5;
+
+    if (iRawlen > 5)
+    {
+      MNG_ALLOC (pData, ((mng_dbykp)*ppChunk)->zKeywords, iRawlen-4);
+      MNG_COPY (((mng_dbykp)*ppChunk)->zKeywords, pRawdata+5, iRawlen-5);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DBYK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+READ_CHUNK (mng_read_ordr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ORDR, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (!pData->bHasDHDR))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check length */
+  if ((iRawlen < 5) || ((iRawlen % 5) != 0))
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+
+
+    /* TODO: something !!! */
+
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_ordrp)*ppChunk)->iCount = iRawlen / 5;
+
+    if (iRawlen)
+    {
+      mng_uint32      iX;
+      mng_ordr_entryp pEntry;
+      mng_uint8p      pTemp = pRawdata;
+      
+      MNG_ALLOC (pData, pEntry, iRawlen);
+
+      ((mng_ordrp)*ppChunk)->pEntries = pEntry;
+
+      for (iX = 0; iX < iRawlen / 5; iX++)
+      {
+        pEntry->iChunkname = mng_get_uint32 (pTemp);
+        pEntry->iOrdertype = *(pTemp+4);
+
+        pTemp += 5;
+        pEntry++;
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_ORDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_MAGN
+READ_CHUNK (mng_read_magn)
+{
+  mng_uint16 iFirstid, iLastid;
+  mng_uint8  iMethodX, iMethodY;
+  mng_uint16 iMX, iMY, iML, iMR, iMT, iMB;
+  mng_bool   bFaulty;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MAGN, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_SUPPORT_JNG
+  if ((!pData->bHasMHDR) || (pData->bHasIHDR) || (pData->bHasDHDR) || (pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) || (pData->bHasIHDR) || (pData->bHasDHDR))
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* check length */
+  if (iRawlen > 20)
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  /* following is an ugly hack to allow faulty layout caused by previous
+     versions of libmng and MNGeye, which wrote MAGN with a 16-bit
+     MethodX/MethodY (as opposed to the proper 8-bit as defined in the spec!) */
+
+  if ((iRawlen ==  6) || (iRawlen ==  8) || (iRawlen == 10) || (iRawlen == 12) ||
+      (iRawlen == 14) || (iRawlen == 16) || (iRawlen == 20))
+    bFaulty = MNG_TRUE;                /* these lengths are all wrong */
+  else                                 /* length 18 can be right or wrong !!! */
+  if ((iRawlen ==  18) && (mng_get_uint16 (pRawdata+4) <= 5) &&
+      (mng_get_uint16 (pRawdata+6)  < 256) &&
+      (mng_get_uint16 (pRawdata+8)  < 256) &&
+      (mng_get_uint16 (pRawdata+10) < 256) &&
+      (mng_get_uint16 (pRawdata+12) < 256) &&
+      (mng_get_uint16 (pRawdata+14) < 256) &&
+      (mng_get_uint16 (pRawdata+16) < 256))
+    bFaulty = MNG_TRUE;                /* this is very likely the wrong layout */
+  else
+    bFaulty = MNG_FALSE;               /* all other cases are handled as right */
+
+  if (bFaulty)                         /* wrong layout ? */
+  {
+    if (iRawlen > 0)                   /* get the fields */
+      iFirstid = mng_get_uint16 (pRawdata);
+    else
+      iFirstid = 0;
+
+    if (iRawlen > 2)
+      iLastid  = mng_get_uint16 (pRawdata+2);
+    else
+      iLastid  = iFirstid;
+
+    if (iRawlen > 4)
+      iMethodX = (mng_uint8)(mng_get_uint16 (pRawdata+4));
+    else
+      iMethodX = 0;
+
+    if (iRawlen > 6)
+      iMX      = mng_get_uint16 (pRawdata+6);
+    else
+      iMX      = 1;
+
+    if (iRawlen > 8)
+      iMY      = mng_get_uint16 (pRawdata+8);
+    else
+      iMY      = iMX;
+
+    if (iRawlen > 10)
+      iML      = mng_get_uint16 (pRawdata+10);
+    else
+      iML      = iMX;
+
+    if (iRawlen > 12)
+      iMR      = mng_get_uint16 (pRawdata+12);
+    else
+      iMR      = iMX;
+
+    if (iRawlen > 14)
+      iMT      = mng_get_uint16 (pRawdata+14);
+    else
+      iMT      = iMY;
+
+    if (iRawlen > 16)
+      iMB      = mng_get_uint16 (pRawdata+16);
+    else
+      iMB      = iMY;
+
+    if (iRawlen > 18)
+      iMethodY = (mng_uint8)(mng_get_uint16 (pRawdata+18));
+    else
+      iMethodY = iMethodX;
+  }
+  else                                 /* proper layout !!!! */
+  {
+    if (iRawlen > 0)                   /* get the fields */
+      iFirstid = mng_get_uint16 (pRawdata);
+    else
+      iFirstid = 0;
+
+    if (iRawlen > 2)
+      iLastid  = mng_get_uint16 (pRawdata+2);
+    else
+      iLastid  = iFirstid;
+
+    if (iRawlen > 4)
+      iMethodX = *(pRawdata+4);
+    else
+      iMethodX = 0;
+
+    if (iRawlen > 5)
+      iMX      = mng_get_uint16 (pRawdata+5);
+    else
+      iMX      = 1;
+
+    if (iRawlen > 7)
+      iMY      = mng_get_uint16 (pRawdata+7);
+    else
+      iMY      = iMX;
+
+    if (iRawlen > 9)
+      iML      = mng_get_uint16 (pRawdata+9);
+    else
+      iML      = iMX;
+
+    if (iRawlen > 11)
+      iMR      = mng_get_uint16 (pRawdata+11);
+    else
+      iMR      = iMX;
+
+    if (iRawlen > 13)
+      iMT      = mng_get_uint16 (pRawdata+13);
+    else
+      iMT      = iMY;
+
+    if (iRawlen > 15)
+      iMB      = mng_get_uint16 (pRawdata+15);
+    else
+      iMB      = iMY;
+
+    if (iRawlen > 17)
+      iMethodY = *(pRawdata+17);
+    else
+      iMethodY = iMethodX;
+  }
+                                       /* check field validity */
+  if ((iMethodX > 5) || (iMethodY > 5))
+    MNG_ERROR (pData, MNG_INVALIDMETHOD);
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    mng_retcode iRetcode;
+
+    iRetcode = mng_create_ani_magn (pData, iFirstid, iLastid, iMethodX,
+                                    iMX, iMY, iML, iMR, iMT, iMB, iMethodY);
+
+/*    if (!iRetcode)
+      iRetcode = mng_process_display_magn (pData, iFirstid, iLastid, iMethodX,
+                                           iMX, iMY, iML, iMR, iMT, iMB, iMethodY); */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_magnp)*ppChunk)->iFirstid = iFirstid;
+    ((mng_magnp)*ppChunk)->iLastid  = iLastid;
+    ((mng_magnp)*ppChunk)->iMethodX = iMethodX;
+    ((mng_magnp)*ppChunk)->iMX      = iMX;
+    ((mng_magnp)*ppChunk)->iMY      = iMY;
+    ((mng_magnp)*ppChunk)->iML      = iML;
+    ((mng_magnp)*ppChunk)->iMR      = iMR;
+    ((mng_magnp)*ppChunk)->iMT      = iMT;
+    ((mng_magnp)*ppChunk)->iMB      = iMB;
+    ((mng_magnp)*ppChunk)->iMethodY = iMethodY;
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+READ_CHUNK (mng_read_mpng)
+{
+  mng_uint32  iFramewidth;
+  mng_uint32  iFrameheight;
+  mng_uint16  iTickspersec;
+  mng_uint32  iFramessize;
+  mng_uint32  iCompressedsize;
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  mng_retcode iRetcode;
+  mng_uint16  iNumplays;
+  mng_uint32  iBufsize;
+  mng_uint8p  pBuf = 0;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MPNG, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if (!pData->bHasIHDR)
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 41)                    /* length must be at least 41 */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+  iFramewidth     = mng_get_int32 (pRawdata);
+  if (iFramewidth == 0)                /* frame_width must not be zero */
+    MNG_ERROR (pData, MNG_INVALIDWIDTH);
+
+  iFrameheight    = mng_get_int32 (pRawdata+4);
+  if (iFrameheight == 0)               /* frame_height must not be zero */
+    MNG_ERROR (pData, MNG_INVALIDHEIGHT);
+
+  iTickspersec    = mng_get_uint16 (pRawdata+10);
+  if (iTickspersec == 0)               /* delay_den must not be zero */
+    MNG_ERROR (pData, MNG_INVALIDFIELDVAL);
+
+  if (*(pRawdata+12) != 0)             /* only deflate compression-method allowed */
+    MNG_ERROR (pData, MNG_INVALIDCOMPRESS);
+
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  iNumplays       = mng_get_uint16 (pRawdata+8);
+  iCompressedsize = (mng_uint32)(iRawlen - 13);
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY
+  {
+    iRetcode = mng_inflate_buffer (pData, pRawdata+13, iCompressedsize,
+                                   &pBuf, &iBufsize, &iFramessize);
+    if (iRetcode)                    /* on error bail out */
+    {
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+
+    if (iFramessize % 26)
+    {
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+    }
+
+    iRetcode = mng_create_mpng_obj (pData, iFramewidth, iFrameheight, iNumplays,
+                                    iTickspersec, iFramessize, pBuf);
+    if (iRetcode)                      /* on error bail out */
+    {
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the fields */
+    ((mng_mpngp)*ppChunk)->iFramewidth        = iFramewidth;
+    ((mng_mpngp)*ppChunk)->iFrameheight       = iFrameheight;
+    ((mng_mpngp)*ppChunk)->iNumplays          = iNumplays;
+    ((mng_mpngp)*ppChunk)->iTickspersec       = iTickspersec;
+    ((mng_mpngp)*ppChunk)->iCompressionmethod = *(pRawdata+14);
+
+#ifndef MNG_SUPPORT_DISPLAY
+    iRetcode = mng_inflate_buffer (pData, pRawdata+13, iCompressedsize,
+                                   &pBuf, &iBufsize, &iFramessize);
+    if (iRetcode)                    /* on error bail out */
+    {
+      MNG_FREEX (pData, pBuf, iBufsize);
+      return iRetcode;
+    }
+
+    if (iFramessize % 26)
+    {
+      MNG_FREEX (pData, pBuf, iBufsize);
+      MNG_ERROR (pData, MNG_INVALIDLENGTH);
+    }
+#endif
+
+    if (iFramessize)
+    {
+      MNG_ALLOCX (pData, ((mng_mpngp)*ppChunk)->pFrames, iFramessize);
+      if (((mng_mpngp)*ppChunk)->pFrames == 0)
+      {
+        MNG_FREEX (pData, pBuf, iBufsize);
+        MNG_ERROR (pData, MNG_OUTOFMEMORY);
+      }
+
+      ((mng_mpngp)*ppChunk)->iFramessize = iFramessize;
+      MNG_COPY (((mng_mpngp)*ppChunk)->pFrames, pBuf, iFramessize);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#if defined(MNG_SUPPORT_DISPLAY) || defined(MNG_STORE_CHUNKS)
+  MNG_FREEX (pData, pBuf, iBufsize);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_MPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifndef MNG_SKIPCHUNK_evNT
+READ_CHUNK (mng_read_evnt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_EVNT, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+  if ((!pData->bHasMHDR) || (pData->bHasSAVE))
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+
+  if (iRawlen < 2)                     /* must have at least 1 entry ! */
+    MNG_ERROR (pData, MNG_INVALIDLENGTH);
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_SUPPORT_DYNAMICMNG)
+  {
+    if (iRawlen)                       /* not empty ? */
+    {
+      mng_retcode iRetcode;
+      mng_uint8p  pTemp;
+      mng_uint8p  pNull;
+      mng_uint32  iLen;
+      mng_uint8   iEventtype;
+      mng_uint8   iMasktype;
+      mng_int32   iLeft;
+      mng_int32   iRight;
+      mng_int32   iTop;
+      mng_int32   iBottom;
+      mng_uint16  iObjectid;
+      mng_uint8   iIndex;
+      mng_uint32  iNamesize;
+
+      pTemp = pRawdata;
+      iLen  = iRawlen;
+
+      while (iLen)                   /* anything left ? */
+      {
+        iEventtype = *pTemp;         /* eventtype */
+        if (iEventtype > 5)
+          MNG_ERROR (pData, MNG_INVALIDEVENT);
+
+        pTemp++;
+
+        iMasktype  = *pTemp;         /* masktype */
+        if (iMasktype > 5)
+          MNG_ERROR (pData, MNG_INVALIDMASK);
+
+        pTemp++;
+        iLen -= 2;
+
+        iLeft     = 0;
+        iRight    = 0;
+        iTop      = 0;
+        iBottom   = 0;
+        iObjectid = 0;
+        iIndex    = 0;
+
+        switch (iMasktype)
+        {
+          case 1 :
+            {
+              if (iLen > 16)
+              {
+                iLeft     = mng_get_int32 (pTemp);
+                iRight    = mng_get_int32 (pTemp+4);
+                iTop      = mng_get_int32 (pTemp+8);
+                iBottom   = mng_get_int32 (pTemp+12);
+                pTemp += 16;
+                iLen -= 16;
+              }
+              else
+                MNG_ERROR (pData, MNG_INVALIDLENGTH);
+              break;
+            }
+          case 2 :
+            {
+              if (iLen > 2)
+              {
+                iObjectid = mng_get_uint16 (pTemp);
+                pTemp += 2;
+                iLen -= 2;
+              }
+              else
+                MNG_ERROR (pData, MNG_INVALIDLENGTH);
+              break;
+            }
+          case 3 :
+            {
+              if (iLen > 3)
+              {
+                iObjectid = mng_get_uint16 (pTemp);
+                iIndex    = *(pTemp+2);
+                pTemp += 3;
+                iLen -= 3;
+              }
+              else
+                MNG_ERROR (pData, MNG_INVALIDLENGTH);
+              break;
+            }
+          case 4 :
+            {
+              if (iLen > 18)
+              {
+                iLeft     = mng_get_int32 (pTemp);
+                iRight    = mng_get_int32 (pTemp+4);
+                iTop      = mng_get_int32 (pTemp+8);
+                iBottom   = mng_get_int32 (pTemp+12);
+                iObjectid = mng_get_uint16 (pTemp+16);
+                pTemp += 18;
+                iLen -= 18;
+              }
+              else
+                MNG_ERROR (pData, MNG_INVALIDLENGTH);
+              break;
+            }
+          case 5 :
+            {
+              if (iLen > 19)
+              {
+                iLeft     = mng_get_int32 (pTemp);
+                iRight    = mng_get_int32 (pTemp+4);
+                iTop      = mng_get_int32 (pTemp+8);
+                iBottom   = mng_get_int32 (pTemp+12);
+                iObjectid = mng_get_uint16 (pTemp+16);
+                iIndex    = *(pTemp+18);
+                pTemp += 19;
+                iLen -= 19;
+              }
+              else
+                MNG_ERROR (pData, MNG_INVALIDLENGTH);
+              break;
+            }
+        }
+
+        pNull = find_null (pTemp);   /* get the name length */
+
+        if ((pNull - pTemp) > (mng_int32)iLen)
+        {
+          iNamesize = iLen;          /* no null found; so end of evNT */
+          iLen      = 0;
+        }
+        else
+        {
+          iNamesize = pNull - pTemp; /* should be another entry */
+          iLen      = iLen - iNamesize - 1;
+
+          if (!iLen)                 /* must not end with a null ! */
+            MNG_ERROR (pData, MNG_ENDWITHNULL);
+        }
+
+        iRetcode = mng_create_event (pData, iEventtype, iMasktype, iLeft, iRight,
+                                            iTop, iBottom, iObjectid, iIndex,
+                                            iNamesize, (mng_pchar)pTemp);
+
+        if (iRetcode)                 /* on error bail out */
+          return iRetcode;
+
+        pTemp = pTemp + iNamesize + 1;
+      }
+    }
+  }
+#endif /* MNG_SUPPORT_DISPLAY && MNG_SUPPORT_DYNAMICMNG */
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    if (iRawlen)                       /* not empty ? */
+    {
+      mng_uint32      iX;
+      mng_uint32      iCount = 0;
+      mng_uint8p      pTemp;
+      mng_uint8p      pNull;
+      mng_uint32      iLen;
+      mng_uint8       iEventtype;
+      mng_uint8       iMasktype;
+      mng_int32       iLeft;
+      mng_int32       iRight;
+      mng_int32       iTop;
+      mng_int32       iBottom;
+      mng_uint16      iObjectid;
+      mng_uint8       iIndex;
+      mng_uint32      iNamesize;
+      mng_evnt_entryp pEntry = MNG_NULL;
+
+      for (iX = 0; iX < 2; iX++)       /* do this twice to get the count first ! */
+      {
+        pTemp = pRawdata;
+        iLen  = iRawlen;
+
+        if (iX)                        /* second run ? */
+        {
+          MNG_ALLOC (pData, pEntry, (iCount * sizeof (mng_evnt_entry)));
+
+          ((mng_evntp)*ppChunk)->iCount   = iCount;
+          ((mng_evntp)*ppChunk)->pEntries = pEntry;
+        }
+
+        while (iLen)                   /* anything left ? */
+        {
+          iEventtype = *pTemp;         /* eventtype */
+          if (iEventtype > 5)
+            MNG_ERROR (pData, MNG_INVALIDEVENT);
+
+          pTemp++;
+
+          iMasktype  = *pTemp;         /* masktype */
+          if (iMasktype > 5)
+            MNG_ERROR (pData, MNG_INVALIDMASK);
+
+          pTemp++;
+          iLen -= 2;
+
+          iLeft     = 0;
+          iRight    = 0;
+          iTop      = 0;
+          iBottom   = 0;
+          iObjectid = 0;
+          iIndex    = 0;
+
+          switch (iMasktype)
+          {
+            case 1 :
+              {
+                if (iLen > 16)
+                {
+                  iLeft     = mng_get_int32 (pTemp);
+                  iRight    = mng_get_int32 (pTemp+4);
+                  iTop      = mng_get_int32 (pTemp+8);
+                  iBottom   = mng_get_int32 (pTemp+12);
+                  pTemp += 16;
+                  iLen -= 16;
+                }
+                else
+                  MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                break;
+              }
+            case 2 :
+              {
+                if (iLen > 2)
+                {
+                  iObjectid = mng_get_uint16 (pTemp);
+                  pTemp += 2;
+                  iLen -= 2;
+                }
+                else
+                  MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                break;
+              }
+            case 3 :
+              {
+                if (iLen > 3)
+                {
+                  iObjectid = mng_get_uint16 (pTemp);
+                  iIndex    = *(pTemp+2);
+                  pTemp += 3;
+                  iLen -= 3;
+                }
+                else
+                  MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                break;
+              }
+            case 4 :
+              {
+                if (iLen > 18)
+                {
+                  iLeft     = mng_get_int32 (pTemp);
+                  iRight    = mng_get_int32 (pTemp+4);
+                  iTop      = mng_get_int32 (pTemp+8);
+                  iBottom   = mng_get_int32 (pTemp+12);
+                  iObjectid = mng_get_uint16 (pTemp+16);
+                  pTemp += 18;
+                  iLen -= 18;
+                }
+                else
+                  MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                break;
+              }
+            case 5 :
+              {
+                if (iLen > 19)
+                {
+                  iLeft     = mng_get_int32 (pTemp);
+                  iRight    = mng_get_int32 (pTemp+4);
+                  iTop      = mng_get_int32 (pTemp+8);
+                  iBottom   = mng_get_int32 (pTemp+12);
+                  iObjectid = mng_get_uint16 (pTemp+16);
+                  iIndex    = *(pTemp+18);
+                  pTemp += 19;
+                  iLen -= 19;
+                }
+                else
+                  MNG_ERROR (pData, MNG_INVALIDLENGTH);
+                break;
+              }
+          }
+
+          pNull = find_null (pTemp);   /* get the name length */
+
+          if ((pNull - pTemp) > (mng_int32)iLen)
+          {
+            iNamesize = iLen;          /* no null found; so end of evNT */
+            iLen      = 0;
+          }
+          else
+          {
+            iNamesize = pNull - pTemp; /* should be another entry */
+            iLen      = iLen - iNamesize - 1;
+
+            if (!iLen)                 /* must not end with a null ! */
+              MNG_ERROR (pData, MNG_ENDWITHNULL);
+          }
+
+          if (!iX)
+          {
+            iCount++;
+          }
+          else
+          {
+            pEntry->iEventtype       = iEventtype;
+            pEntry->iMasktype        = iMasktype;
+            pEntry->iLeft            = iLeft;
+            pEntry->iRight           = iRight;
+            pEntry->iTop             = iTop;
+            pEntry->iBottom          = iBottom;
+            pEntry->iObjectid        = iObjectid;
+            pEntry->iIndex           = iIndex;
+            pEntry->iSegmentnamesize = iNamesize;
+
+            if (iNamesize)
+            {
+              MNG_ALLOC (pData, pEntry->zSegmentname, iNamesize+1);
+              MNG_COPY (pEntry->zSegmentname, pTemp, iNamesize);
+            }
+
+            pEntry++;
+          }
+
+          pTemp = pTemp + iNamesize + 1;
+        }
+      }
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_EVNT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_unknown)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_UNKNOWN, MNG_LC_START);
+#endif
+                                       /* sequence checks */
+#ifdef MNG_INCLUDE_JNG
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) &&
+      (!pData->bHasBASI) && (!pData->bHasDHDR)    )
+#endif
+    MNG_ERROR (pData, MNG_SEQUENCEERROR);
+                                       /* critical chunk ? */
+  if ((((mng_uint32)pData->iChunkname & 0x20000000) == 0)
+#ifdef MNG_SKIPCHUNK_SAVE
+    && (pData->iChunkname != MNG_UINT_SAVE)
+#endif
+#ifdef MNG_SKIPCHUNK_SEEK
+    && (pData->iChunkname != MNG_UINT_SEEK)
+#endif
+#ifdef MNG_SKIPCHUNK_DBYK
+    && (pData->iChunkname != MNG_UINT_DBYK)
+#endif
+#ifdef MNG_SKIPCHUNK_ORDR
+    && (pData->iChunkname != MNG_UINT_ORDR)
+#endif
+      )
+    MNG_ERROR (pData, MNG_UNKNOWNCRITICAL);
+
+  if (pData->fProcessunknown)          /* let the app handle it ? */
+  {
+    mng_bool bOke = pData->fProcessunknown ((mng_handle)pData, pData->iChunkname,
+                                            iRawlen, (mng_ptr)pRawdata);
+
+    if (!bOke)
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+#ifdef MNG_STORE_CHUNKS
+  if (pData->bStorechunks)
+  {                                    /* initialize storage */
+    mng_retcode iRetcode = ((mng_chunk_headerp)pHeader)->fCreate (pData, pHeader, ppChunk);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* store the length */
+    ((mng_chunk_headerp)*ppChunk)->iChunkname = pData->iChunkname;
+    ((mng_unknown_chunkp)*ppChunk)->iDatasize = iRawlen;
+
+    if (iRawlen == 0)                  /* any data at all ? */
+      ((mng_unknown_chunkp)*ppChunk)->pData = 0;
+    else
+    {                                  /* then store it */
+      MNG_ALLOC (pData, ((mng_unknown_chunkp)*ppChunk)->pData, iRawlen);
+      MNG_COPY (((mng_unknown_chunkp)*ppChunk)->pData, pRawdata, iRawlen);
+    }
+  }
+#endif /* MNG_STORE_CHUNKS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_UNKNOWN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+#endif
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_READ_PROCS */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * chunk write functions                                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_ihdr)
+{
+  mng_ihdrp   pIHDR;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IHDR, MNG_LC_START);
+#endif
+
+  pIHDR    = (mng_ihdrp)pChunk;        /* address the proper chunk */
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 13;
+                                       /* fill the output buffer */
+  mng_put_uint32 (pRawdata,   pIHDR->iWidth);
+  mng_put_uint32 (pRawdata+4, pIHDR->iHeight);
+
+  *(pRawdata+8)  = pIHDR->iBitdepth;
+  *(pRawdata+9)  = pIHDR->iColortype;
+  *(pRawdata+10) = pIHDR->iCompression;
+  *(pRawdata+11) = pIHDR->iFilter;
+  *(pRawdata+12) = pIHDR->iInterlace;
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pIHDR->sHeader.iChunkname, iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IHDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_plte)
+{
+  mng_pltep   pPLTE;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PLTE, MNG_LC_START);
+#endif
+
+  pPLTE    = (mng_pltep)pChunk;        /* address the proper chunk */
+
+  if (pPLTE->bEmpty)                   /* write empty chunk ? */
+    iRetcode = write_raw_chunk (pData, pPLTE->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = pPLTE->iEntrycount * 3;
+                                       /* fill the output buffer */
+    pTemp = pRawdata;
+
+    for (iX = 0; iX < pPLTE->iEntrycount; iX++)
+    {
+      *pTemp     = pPLTE->aEntries [iX].iRed;
+      *(pTemp+1) = pPLTE->aEntries [iX].iGreen;
+      *(pTemp+2) = pPLTE->aEntries [iX].iBlue;
+
+      pTemp += 3;
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pPLTE->sHeader.iChunkname, iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PLTE, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_idat)
+{
+  mng_idatp   pIDAT;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IDAT, MNG_LC_START);
+#endif
+
+  pIDAT = (mng_idatp)pChunk;           /* address the proper chunk */
+
+  if (pIDAT->bEmpty)                   /* and write it */
+    iRetcode = write_raw_chunk (pData, pIDAT->sHeader.iChunkname, 0, 0);
+  else
+    iRetcode = write_raw_chunk (pData, pIDAT->sHeader.iChunkname,
+                                pIDAT->iDatasize, pIDAT->pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IDAT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_iend)
+{
+  mng_iendp   pIEND;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IEND, MNG_LC_START);
+#endif
+
+  pIEND = (mng_iendp)pChunk;           /* address the proper chunk */
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pIEND->sHeader.iChunkname, 0, 0);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IEND, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_trns)
+{
+  mng_trnsp   pTRNS;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TRNS, MNG_LC_START);
+#endif
+
+  pTRNS = (mng_trnsp)pChunk;           /* address the proper chunk */
+
+  if (pTRNS->bEmpty)                   /* write empty chunk ? */
+    iRetcode = write_raw_chunk (pData, pTRNS->sHeader.iChunkname, 0, 0);
+  else
+  if (pTRNS->bGlobal)                  /* write global chunk ? */
+    iRetcode = write_raw_chunk (pData, pTRNS->sHeader.iChunkname,
+                                pTRNS->iRawlen, (mng_uint8p)pTRNS->aRawdata);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer */
+    iRawlen  = 0;                      /* and default size */
+
+    switch (pTRNS->iType)
+    {
+      case 0: {
+                iRawlen   = 2;         /* fill the size & output buffer */
+                mng_put_uint16 (pRawdata, pTRNS->iGray);
+
+                break;
+              }
+      case 2: {
+                iRawlen       = 6;     /* fill the size & output buffer */
+                mng_put_uint16 (pRawdata,   pTRNS->iRed);
+                mng_put_uint16 (pRawdata+2, pTRNS->iGreen);
+                mng_put_uint16 (pRawdata+4, pTRNS->iBlue);
+
+                break;
+              }
+      case 3: {                        /* init output buffer size */
+                iRawlen = pTRNS->iCount;
+
+                pTemp   = pRawdata;    /* fill the output buffer */
+
+                for (iX = 0; iX < pTRNS->iCount; iX++)
+                {
+                  *pTemp = pTRNS->aEntries[iX];
+                  pTemp++;
+                }
+
+                break;
+              }
+    }
+                                       /* write the chunk */
+    iRetcode = write_raw_chunk (pData, pTRNS->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TRNS, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_gama)
+{
+  mng_gamap   pGAMA;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_GAMA, MNG_LC_START);
+#endif
+
+  pGAMA = (mng_gamap)pChunk;           /* address the proper chunk */
+
+  if (pGAMA->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pGAMA->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 4;
+                                       /* fill the buffer */
+    mng_put_uint32 (pRawdata, pGAMA->iGamma);
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pGAMA->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_GAMA, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+WRITE_CHUNK (mng_write_chrm)
+{
+  mng_chrmp   pCHRM;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_CHRM, MNG_LC_START);
+#endif
+
+  pCHRM = (mng_chrmp)pChunk;           /* address the proper chunk */
+
+  if (pCHRM->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pCHRM->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 32;
+                                       /* fill the buffer */
+    mng_put_uint32 (pRawdata,    pCHRM->iWhitepointx);
+    mng_put_uint32 (pRawdata+4,  pCHRM->iWhitepointy);
+    mng_put_uint32 (pRawdata+8,  pCHRM->iRedx);
+    mng_put_uint32 (pRawdata+12, pCHRM->iRedy);
+    mng_put_uint32 (pRawdata+16, pCHRM->iGreenx);
+    mng_put_uint32 (pRawdata+20, pCHRM->iGreeny);
+    mng_put_uint32 (pRawdata+24, pCHRM->iBluex);
+    mng_put_uint32 (pRawdata+28, pCHRM->iBluey);
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pCHRM->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_CHRM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_srgb)
+{
+  mng_srgbp   pSRGB;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SRGB, MNG_LC_START);
+#endif
+
+  pSRGB = (mng_srgbp)pChunk;           /* address the proper chunk */
+
+  if (pSRGB->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pSRGB->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 1;
+                                       /* fill the buffer */
+    *pRawdata = pSRGB->iRenderingintent;
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pSRGB->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SRGB, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+WRITE_CHUNK (mng_write_iccp)
+{
+  mng_iccpp   pICCP;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint8p  pBuf = 0;
+  mng_uint32  iBuflen;
+  mng_uint32  iReallen;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ICCP, MNG_LC_START);
+#endif
+
+  pICCP = (mng_iccpp)pChunk;           /* address the proper chunk */
+
+  if (pICCP->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pICCP->sHeader.iChunkname, 0, 0);
+  else
+  {                                    /* compress the profile */
+    iRetcode = deflate_buffer (pData, pICCP->pProfile, pICCP->iProfilesize,
+                               &pBuf, &iBuflen, &iReallen);
+
+    if (!iRetcode)                     /* still oke ? */
+    {
+      pRawdata = pData->pWritebuf+8;   /* init output buffer & size */
+      iRawlen  = pICCP->iNamesize + 2 + iReallen;
+                                       /* requires large buffer ? */
+      if (iRawlen > pData->iWritebufsize)
+        MNG_ALLOC (pData, pRawdata, iRawlen);
+
+      pTemp = pRawdata;                /* fill the buffer */
+
+      if (pICCP->iNamesize)
+      {
+        MNG_COPY (pTemp, pICCP->zName, pICCP->iNamesize);
+        pTemp += pICCP->iNamesize;
+      }
+
+      *pTemp     = 0;
+      *(pTemp+1) = pICCP->iCompression;
+      pTemp += 2;
+
+      if (iReallen)
+        MNG_COPY (pTemp, pBuf, iReallen);
+                                       /* and write it */
+      iRetcode = write_raw_chunk (pData, pICCP->sHeader.iChunkname,
+                                  iRawlen, pRawdata);
+                                       /* drop the temp buffer ? */
+      if (iRawlen > pData->iWritebufsize)
+        MNG_FREEX (pData, pRawdata, iRawlen);
+
+    }
+
+    MNG_FREEX (pData, pBuf, iBuflen);  /* always drop the extra buffer */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ICCP, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+WRITE_CHUNK (mng_write_text)
+{
+  mng_textp   pTEXT;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TEXT, MNG_LC_START);
+#endif
+
+  pTEXT = (mng_textp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = pTEXT->iKeywordsize + 1 + pTEXT->iTextsize;
+                                       /* requires large buffer ? */
+  if (iRawlen > pData->iWritebufsize)
+    MNG_ALLOC (pData, pRawdata, iRawlen);
+
+  pTemp = pRawdata;                    /* fill the buffer */
+
+  if (pTEXT->iKeywordsize)
+  {
+    MNG_COPY (pTemp, pTEXT->zKeyword, pTEXT->iKeywordsize);
+    pTemp += pTEXT->iKeywordsize;
+  }
+
+  *pTemp = 0;
+  pTemp += 1;
+
+  if (pTEXT->iTextsize)
+    MNG_COPY (pTemp, pTEXT->zText, pTEXT->iTextsize);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pTEXT->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+  if (iRawlen > pData->iWritebufsize)  /* drop the temp buffer ? */
+    MNG_FREEX (pData, pRawdata, iRawlen);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TEXT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+WRITE_CHUNK (mng_write_ztxt)
+{
+  mng_ztxtp   pZTXT;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint8p  pBuf = 0;
+  mng_uint32  iBuflen;
+  mng_uint32  iReallen;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ZTXT, MNG_LC_START);
+#endif
+
+  pZTXT = (mng_ztxtp)pChunk;           /* address the proper chunk */
+                                       /* compress the text */
+  iRetcode = deflate_buffer (pData, (mng_uint8p)pZTXT->zText, pZTXT->iTextsize,
+                             &pBuf, &iBuflen, &iReallen);
+
+  if (!iRetcode)                       /* all ok ? */
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = pZTXT->iKeywordsize + 2 + iReallen;
+                                       /* requires large buffer ? */
+    if (iRawlen > pData->iWritebufsize)
+      MNG_ALLOC (pData, pRawdata, iRawlen);
+
+    pTemp = pRawdata;                  /* fill the buffer */
+
+    if (pZTXT->iKeywordsize)
+    {
+      MNG_COPY (pTemp, pZTXT->zKeyword, pZTXT->iKeywordsize);
+      pTemp += pZTXT->iKeywordsize;
+    }
+
+    *pTemp = 0;                        /* terminator zero */
+    pTemp++;
+    *pTemp = 0;                        /* compression type */
+    pTemp++;
+
+    if (iReallen)
+      MNG_COPY (pTemp, pBuf, iReallen);
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pZTXT->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+                                       /* drop the temp buffer ? */
+    if (iRawlen > pData->iWritebufsize)
+      MNG_FREEX (pData, pRawdata, iRawlen);
+
+  }
+
+  MNG_FREEX (pData, pBuf, iBuflen);    /* always drop the compression buffer */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ZTXT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+WRITE_CHUNK (mng_write_itxt)
+{
+  mng_itxtp   pITXT;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint8p  pBuf = 0;
+  mng_uint32  iBuflen;
+  mng_uint32  iReallen;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ITXT, MNG_LC_START);
+#endif
+
+  pITXT = (mng_itxtp)pChunk;           /* address the proper chunk */
+
+  if (pITXT->iCompressionflag)         /* compress the text */
+    iRetcode = deflate_buffer (pData, (mng_uint8p)pITXT->zText, pITXT->iTextsize,
+                               &pBuf, &iBuflen, &iReallen);
+  else
+    iRetcode = MNG_NOERROR;
+
+  if (!iRetcode)                       /* all ok ? */
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = pITXT->iKeywordsize + pITXT->iLanguagesize +
+               pITXT->iTranslationsize + 5;
+
+    if (pITXT->iCompressionflag)
+      iRawlen = iRawlen + iReallen;
+    else
+      iRawlen = iRawlen + pITXT->iTextsize;
+                                       /* requires large buffer ? */
+    if (iRawlen > pData->iWritebufsize)
+      MNG_ALLOC (pData, pRawdata, iRawlen);
+
+    pTemp = pRawdata;                  /* fill the buffer */
+
+    if (pITXT->iKeywordsize)
+    {
+      MNG_COPY (pTemp, pITXT->zKeyword, pITXT->iKeywordsize);
+      pTemp += pITXT->iKeywordsize;
+    }
+
+    *pTemp = 0;
+    pTemp++;
+    *pTemp = pITXT->iCompressionflag;
+    pTemp++;
+    *pTemp = pITXT->iCompressionmethod;
+    pTemp++;
+
+    if (pITXT->iLanguagesize)
+    {
+      MNG_COPY (pTemp, pITXT->zLanguage, pITXT->iLanguagesize);
+      pTemp += pITXT->iLanguagesize;
+    }
+
+    *pTemp = 0;
+    pTemp++;
+
+    if (pITXT->iTranslationsize)
+    {
+      MNG_COPY (pTemp, pITXT->zTranslation, pITXT->iTranslationsize);
+      pTemp += pITXT->iTranslationsize;
+    }
+
+    *pTemp = 0;
+    pTemp++;
+
+    if (pITXT->iCompressionflag)
+    {
+      if (iReallen)
+        MNG_COPY (pTemp, pBuf, iReallen);
+    }
+    else
+    {
+      if (pITXT->iTextsize)
+        MNG_COPY (pTemp, pITXT->zText, pITXT->iTextsize);
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pITXT->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+                                       /* drop the temp buffer ? */
+    if (iRawlen > pData->iWritebufsize)
+      MNG_FREEX (pData, pRawdata, iRawlen);
+
+  }
+
+  MNG_FREEX (pData, pBuf, iBuflen);    /* always drop the compression buffer */
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ITXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+WRITE_CHUNK (mng_write_bkgd)
+{
+  mng_bkgdp   pBKGD;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_BKGD, MNG_LC_START);
+#endif
+
+  pBKGD = (mng_bkgdp)pChunk;           /* address the proper chunk */
+
+  if (pBKGD->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pBKGD->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 0;                      /* and default size */
+
+    switch (pBKGD->iType)
+    {
+      case 0: {                        /* gray */
+                iRawlen = 2;           /* fill the size & output buffer */
+                mng_put_uint16 (pRawdata, pBKGD->iGray);
+
+                break;
+              }
+      case 2: {                        /* rgb */
+                iRawlen = 6;           /* fill the size & output buffer */
+                mng_put_uint16 (pRawdata,   pBKGD->iRed);
+                mng_put_uint16 (pRawdata+2, pBKGD->iGreen);
+                mng_put_uint16 (pRawdata+4, pBKGD->iBlue);
+
+                break;
+              }
+      case 3: {                        /* indexed */
+                iRawlen   = 1;         /* fill the size & output buffer */
+                *pRawdata = pBKGD->iIndex;
+
+                break;
+              }
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pBKGD->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_BKGD, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYs
+WRITE_CHUNK (mng_write_phys)
+{
+  mng_physp   pPHYS;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PHYS, MNG_LC_START);
+#endif
+
+  pPHYS = (mng_physp)pChunk;           /* address the proper chunk */
+
+  if (pPHYS->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pPHYS->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 9;
+                                       /* fill the output buffer */
+    mng_put_uint32 (pRawdata,   pPHYS->iSizex);
+    mng_put_uint32 (pRawdata+4, pPHYS->iSizey);
+
+    *(pRawdata+8) = pPHYS->iUnit;
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pPHYS->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PHYS, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sBIT
+WRITE_CHUNK (mng_write_sbit)
+{
+  mng_sbitp   pSBIT;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SBIT, MNG_LC_START);
+#endif
+
+  pSBIT = (mng_sbitp)pChunk;           /* address the proper chunk */
+
+  if (pSBIT->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pSBIT->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 0;                      /* and default size */
+
+    switch (pSBIT->iType)
+    {
+      case  0: {                       /* gray */
+                 iRawlen       = 1;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+
+                 break;
+               }
+      case  2: {                       /* rgb */
+                 iRawlen       = 3;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+                 *(pRawdata+1) = pSBIT->aBits[1];
+                 *(pRawdata+2) = pSBIT->aBits[2];
+
+                 break;
+               }
+      case  3: {                       /* indexed */
+                 iRawlen       = 3;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+                 *pRawdata     = pSBIT->aBits[1];
+                 *pRawdata     = pSBIT->aBits[2];
+
+                 break;
+               }
+      case  4: {                       /* gray + alpha */
+                 iRawlen       = 2;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+                 *(pRawdata+1) = pSBIT->aBits[1];
+
+                 break;
+               }
+      case  6: {                       /* rgb + alpha */
+                 iRawlen       = 4;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+                 *(pRawdata+1) = pSBIT->aBits[1];
+                 *(pRawdata+2) = pSBIT->aBits[2];
+                 *(pRawdata+3) = pSBIT->aBits[3];
+
+                 break;
+               }
+      case 10: {                       /* jpeg gray */
+                 iRawlen       = 1;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+
+                 break;
+               }
+      case 12: {                       /* jpeg rgb */
+                 iRawlen       = 3;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+                 *(pRawdata+1) = pSBIT->aBits[1];
+                 *(pRawdata+2) = pSBIT->aBits[2];
+
+                 break;
+               }
+      case 14: {                       /* jpeg gray + alpha */
+                 iRawlen       = 2;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+                 *(pRawdata+1) = pSBIT->aBits[1];
+
+                 break;
+               }
+      case 16: {                       /* jpeg rgb + alpha */
+                 iRawlen       = 4;    /* fill the size & output buffer */
+                 *pRawdata     = pSBIT->aBits[0];
+                 *(pRawdata+1) = pSBIT->aBits[1];
+                 *(pRawdata+2) = pSBIT->aBits[2];
+                 *(pRawdata+3) = pSBIT->aBits[3];
+
+                 break;
+               }
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pSBIT->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SBIT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+WRITE_CHUNK (mng_write_splt)
+{
+  mng_spltp   pSPLT;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint32  iEntrieslen;
+  mng_uint8p  pTemp;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SPLT, MNG_LC_START);
+#endif
+
+  pSPLT = (mng_spltp)pChunk;           /* address the proper chunk */
+
+  pRawdata    = pData->pWritebuf+8;    /* init output buffer & size */
+  iEntrieslen = ((pSPLT->iSampledepth >> 3) * 4 + 2) * pSPLT->iEntrycount;
+  iRawlen     = pSPLT->iNamesize + 2 + iEntrieslen;
+                                       /* requires large buffer ? */
+  if (iRawlen > pData->iWritebufsize)
+    MNG_ALLOC (pData, pRawdata, iRawlen);
+
+  pTemp = pRawdata;                    /* fill the buffer */
+
+  if (pSPLT->iNamesize)
+  {
+    MNG_COPY (pTemp, pSPLT->zName, pSPLT->iNamesize);
+    pTemp += pSPLT->iNamesize;
+  }
+
+  *pTemp     = 0;
+  *(pTemp+1) = pSPLT->iSampledepth;
+  pTemp += 2;
+
+  if (pSPLT->iEntrycount)
+    MNG_COPY (pTemp, pSPLT->pEntries, iEntrieslen);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pSPLT->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+  if (iRawlen > pData->iWritebufsize)  /* drop the temp buffer ? */
+    MNG_FREEX (pData, pRawdata, iRawlen);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SPLT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+WRITE_CHUNK (mng_write_hist)
+{
+  mng_histp   pHIST;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_HIST, MNG_LC_START);
+#endif
+
+  pHIST = (mng_histp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = pHIST->iEntrycount << 1;
+
+  pTemp    = pRawdata;                 /* fill the output buffer */
+
+  for (iX = 0; iX < pHIST->iEntrycount; iX++)
+  {
+    mng_put_uint16 (pTemp, pHIST->aEntries [iX]);
+    pTemp += 2;
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pHIST->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_HIST, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tIME
+WRITE_CHUNK (mng_write_time)
+{
+  mng_timep   pTIME;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TIME, MNG_LC_START);
+#endif
+
+  pTIME = (mng_timep)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 7;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata, pTIME->iYear);
+
+  *(pRawdata+2) = pTIME->iMonth;
+  *(pRawdata+3) = pTIME->iDay;
+  *(pRawdata+4) = pTIME->iHour;
+  *(pRawdata+5) = pTIME->iMinute;
+  *(pRawdata+6) = pTIME->iSecond;
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pTIME->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TIME, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_mhdr)
+{
+  mng_mhdrp   pMHDR;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MHDR, MNG_LC_START);
+#endif
+
+  pMHDR = (mng_mhdrp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 28;
+                                       /* fill the output buffer */
+  mng_put_uint32 (pRawdata,    pMHDR->iWidth);
+  mng_put_uint32 (pRawdata+4,  pMHDR->iHeight);
+  mng_put_uint32 (pRawdata+8,  pMHDR->iTicks);
+  mng_put_uint32 (pRawdata+12, pMHDR->iLayercount);
+  mng_put_uint32 (pRawdata+16, pMHDR->iFramecount);
+  mng_put_uint32 (pRawdata+20, pMHDR->iPlaytime);
+  mng_put_uint32 (pRawdata+24, pMHDR->iSimplicity);
+
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pMHDR->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MHDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_mend)
+{
+  mng_mendp   pMEND;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MEND, MNG_LC_START);
+#endif
+
+  pMEND = (mng_mendp)pChunk;           /* address the proper chunk */
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pMEND->sHeader.iChunkname, 0, 0);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MEND, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_loop)
+{
+  mng_loopp   pLOOP;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+  mng_uint8p  pTemp1;
+  mng_uint32p pTemp2;
+  mng_uint32  iX;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_LOOP, MNG_LC_START);
+#endif
+
+  pLOOP = (mng_loopp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 5;
+                                       /* fill the output buffer */
+  *pRawdata = pLOOP->iLevel;
+  mng_put_uint32 (pRawdata+1,  pLOOP->iRepeat);
+
+  if (pLOOP->iTermination)
+  {
+    iRawlen++;
+    *(pRawdata+5) = pLOOP->iTermination;
+
+    if ((pLOOP->iCount) ||
+        (pLOOP->iItermin != 1) || (pLOOP->iItermax != 0x7FFFFFFFL))
+    {
+      iRawlen += 8;
+
+      mng_put_uint32 (pRawdata+6,  pLOOP->iItermin);
+      mng_put_uint32 (pRawdata+10, pLOOP->iItermax);
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+      if (pLOOP->iCount)
+      {
+        iRawlen += pLOOP->iCount * 4;
+
+        pTemp1 = pRawdata+14;
+        pTemp2 = pLOOP->pSignals;
+
+        for (iX = 0; iX < pLOOP->iCount; iX++)
+        {
+          mng_put_uint32 (pTemp1, *pTemp2);
+
+          pTemp1 += 4;
+          pTemp2++;
+        }
+      }
+#endif
+    }
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pLOOP->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_LOOP, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_endl)
+{
+  mng_endlp   pENDL;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ENDL, MNG_LC_START);
+#endif
+
+  pENDL     = (mng_endlp)pChunk;       /* address the proper chunk */
+
+  pRawdata  = pData->pWritebuf+8;      /* init output buffer & size */
+  iRawlen   = 1;
+
+  *pRawdata = pENDL->iLevel;           /* fill the output buffer */
+                                       /* and write it */
+  iRetcode  = write_raw_chunk (pData, pENDL->sHeader.iChunkname,
+                               iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ENDL, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_defi)
+{
+  mng_defip   pDEFI;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DEFI, MNG_LC_START);
+#endif
+
+  pDEFI = (mng_defip)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 2;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata, pDEFI->iObjectid);
+
+  if ((pDEFI->iDonotshow) || (pDEFI->iConcrete) || (pDEFI->bHasloca) || (pDEFI->bHasclip))
+  {
+    iRawlen++;
+    *(pRawdata+2) = pDEFI->iDonotshow;
+
+    if ((pDEFI->iConcrete) || (pDEFI->bHasloca) || (pDEFI->bHasclip))
+    {
+      iRawlen++;
+      *(pRawdata+3) = pDEFI->iConcrete;
+
+      if ((pDEFI->bHasloca) || (pDEFI->bHasclip))
+      {
+        iRawlen += 8;
+
+        mng_put_uint32 (pRawdata+4, pDEFI->iXlocation);
+        mng_put_uint32 (pRawdata+8, pDEFI->iYlocation);
+
+        if (pDEFI->bHasclip)
+        {
+          iRawlen += 16;
+
+          mng_put_uint32 (pRawdata+12, pDEFI->iLeftcb);
+          mng_put_uint32 (pRawdata+16, pDEFI->iRightcb);
+          mng_put_uint32 (pRawdata+20, pDEFI->iTopcb);
+          mng_put_uint32 (pRawdata+24, pDEFI->iBottomcb);
+        }
+      }
+    }
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pDEFI->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DEFI, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_basi)
+{
+  mng_basip   pBASI;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_bool    bOpaque;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_BASI, MNG_LC_START);
+#endif
+
+  pBASI = (mng_basip)pChunk;           /* address the proper chunk */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+  if (pBASI->iBitdepth <= 8)           /* determine opacity alpha-field */
+#endif
+    bOpaque = (mng_bool)(pBASI->iAlpha == 0xFF);
+#ifndef MNG_NO_16BIT_SUPPORT
+  else
+    bOpaque = (mng_bool)(pBASI->iAlpha == 0xFFFF);
+#endif
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 13;
+                                       /* fill the output buffer */
+  mng_put_uint32 (pRawdata,   pBASI->iWidth);
+  mng_put_uint32 (pRawdata+4, pBASI->iHeight);
+
+  *(pRawdata+8)  = pBASI->iBitdepth;
+  *(pRawdata+9)  = pBASI->iColortype;
+  *(pRawdata+10) = pBASI->iCompression;
+  *(pRawdata+11) = pBASI->iFilter;
+  *(pRawdata+12) = pBASI->iInterlace;
+
+  if ((pBASI->iRed) || (pBASI->iGreen) || (pBASI->iBlue) ||
+      (!bOpaque) || (pBASI->iViewable))
+  {
+    iRawlen += 6;
+    mng_put_uint16 (pRawdata+13, pBASI->iRed);
+    mng_put_uint16 (pRawdata+15, pBASI->iGreen);
+    mng_put_uint16 (pRawdata+17, pBASI->iBlue);
+
+    if ((!bOpaque) || (pBASI->iViewable))
+    {
+      iRawlen += 2;
+      mng_put_uint16 (pRawdata+19, pBASI->iAlpha);
+
+      if (pBASI->iViewable)
+      {
+        iRawlen++;
+        *(pRawdata+21) = pBASI->iViewable;
+      }
+    }
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pBASI->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_BASI, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_clon)
+{
+  mng_clonp   pCLON;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_CLON, MNG_LC_START);
+#endif
+
+  pCLON = (mng_clonp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 4;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata,   pCLON->iSourceid);
+  mng_put_uint16 (pRawdata+2, pCLON->iCloneid);
+
+  if ((pCLON->iClonetype) || (pCLON->iDonotshow) || (pCLON->iConcrete) || (pCLON->bHasloca))
+  {
+    iRawlen++;
+    *(pRawdata+4) = pCLON->iClonetype;
+
+    if ((pCLON->iDonotshow) || (pCLON->iConcrete) || (pCLON->bHasloca))
+    {
+      iRawlen++;
+      *(pRawdata+5) = pCLON->iDonotshow;
+
+      if ((pCLON->iConcrete) || (pCLON->bHasloca))
+      {
+        iRawlen++;
+        *(pRawdata+6) = pCLON->iConcrete;
+
+        if (pCLON->bHasloca)
+        {
+          iRawlen += 9;
+          *(pRawdata+7) = pCLON->iLocationtype;
+          mng_put_int32 (pRawdata+8,  pCLON->iLocationx);
+          mng_put_int32 (pRawdata+12, pCLON->iLocationy);
+        }
+      }
+    }
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pCLON->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_CLON, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+WRITE_CHUNK (mng_write_past)
+{
+  mng_pastp        pPAST;
+  mng_uint8p       pRawdata;
+  mng_uint32       iRawlen;
+  mng_retcode      iRetcode;
+  mng_past_sourcep pSource;
+  mng_uint32       iX;
+  mng_uint8p       pTemp;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PAST, MNG_LC_START);
+#endif
+
+  pPAST = (mng_pastp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 11 + (30 * pPAST->iCount);
+                                       /* requires large buffer ? */
+  if (iRawlen > pData->iWritebufsize)
+    MNG_ALLOC (pData, pRawdata, iRawlen);
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata,   pPAST->iDestid);
+
+  *(pRawdata+2) = pPAST->iTargettype;
+
+  mng_put_int32  (pRawdata+3, pPAST->iTargetx);
+  mng_put_int32  (pRawdata+7, pPAST->iTargety);
+
+  pTemp   = pRawdata+11;
+  pSource = pPAST->pSources;
+
+  for (iX = 0; iX < pPAST->iCount; iX++)
+  {
+    mng_put_uint16 (pTemp,    pSource->iSourceid);
+
+    *(pTemp+2)  = pSource->iComposition;
+    *(pTemp+3)  = pSource->iOrientation;
+    *(pTemp+4)  = pSource->iOffsettype;
+
+    mng_put_int32  (pTemp+5,  pSource->iOffsetx);
+    mng_put_int32  (pTemp+9,  pSource->iOffsety);
+
+    *(pTemp+13) = pSource->iBoundarytype;
+
+    mng_put_int32  (pTemp+14, pSource->iBoundaryl);
+    mng_put_int32  (pTemp+18, pSource->iBoundaryr);
+    mng_put_int32  (pTemp+22, pSource->iBoundaryt);
+    mng_put_int32  (pTemp+26, pSource->iBoundaryb);
+
+    pSource++;
+    pTemp += 30;
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pPAST->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+                                       /* free temporary buffer ? */
+  if (iRawlen > pData->iWritebufsize)
+    MNG_FREEX (pData, pRawdata, iRawlen);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PAST, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_disc)
+{
+  mng_discp        pDISC;
+  mng_uint8p       pRawdata;
+  mng_uint32       iRawlen;
+  mng_retcode      iRetcode;
+  mng_uint32       iX;
+  mng_uint8p       pTemp1;
+  mng_uint16p      pTemp2;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DISC, MNG_LC_START);
+#endif
+
+  pDISC    = (mng_discp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = pDISC->iCount << 1;
+
+  pTemp1   = pRawdata;                 /* fill the output buffer */
+  pTemp2   = pDISC->pObjectids;
+
+  for (iX = 0; iX < pDISC->iCount; iX++)
+  {
+    mng_put_uint16 (pTemp1, *pTemp2);
+
+    pTemp2++;
+    pTemp1 += 2;
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pDISC->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DISC, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_back)
+{
+  mng_backp   pBACK;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_BACK, MNG_LC_START);
+#endif
+
+  pBACK = (mng_backp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 6;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata,   pBACK->iRed);
+  mng_put_uint16 (pRawdata+2, pBACK->iGreen);
+  mng_put_uint16 (pRawdata+4, pBACK->iBlue);
+
+  if ((pBACK->iMandatory) || (pBACK->iImageid) || (pBACK->iTile))
+  {
+    iRawlen++;
+    *(pRawdata+6) = pBACK->iMandatory;
+
+    if ((pBACK->iImageid) || (pBACK->iTile))
+    {
+      iRawlen += 2;
+      mng_put_uint16 (pRawdata+7, pBACK->iImageid);
+
+      if (pBACK->iTile)
+      {
+        iRawlen++;
+        *(pRawdata+9) = pBACK->iTile;
+      }
+    }
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pBACK->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_BACK, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_fram)
+{
+  mng_framp   pFRAM;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pTemp;
+  mng_uint32p pTemp2;
+  mng_uint32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_FRAM, MNG_LC_START);
+#endif
+
+  pFRAM = (mng_framp)pChunk;           /* address the proper chunk */
+
+  if (pFRAM->bEmpty)                   /* empty ? */
+    iRetcode = write_raw_chunk (pData, pFRAM->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 1;
+                                       /* fill the output buffer */
+    *pRawdata = pFRAM->iMode;
+
+    if ((pFRAM->iNamesize      ) ||
+        (pFRAM->iChangedelay   ) || (pFRAM->iChangetimeout) ||
+        (pFRAM->iChangeclipping) || (pFRAM->iChangesyncid )    )
+    {
+      if (pFRAM->iNamesize)
+        MNG_COPY (pRawdata+1, pFRAM->zName, pFRAM->iNamesize);
+
+      iRawlen += pFRAM->iNamesize;
+      pTemp = pRawdata + pFRAM->iNamesize + 1;
+
+      if ((pFRAM->iChangedelay   ) || (pFRAM->iChangetimeout) ||
+          (pFRAM->iChangeclipping) || (pFRAM->iChangesyncid )    )
+      {
+        *pTemp     = 0;
+        *(pTemp+1) = pFRAM->iChangedelay;
+        *(pTemp+2) = pFRAM->iChangetimeout;
+        *(pTemp+3) = pFRAM->iChangeclipping;
+        *(pTemp+4) = pFRAM->iChangesyncid;
+
+        iRawlen += 5;
+        pTemp   += 5;
+
+        if (pFRAM->iChangedelay)
+        {
+          mng_put_uint32 (pTemp, pFRAM->iDelay);
+          iRawlen += 4;
+          pTemp   += 4;
+        }
+
+        if (pFRAM->iChangetimeout)
+        {
+          mng_put_uint32 (pTemp, pFRAM->iTimeout);
+          iRawlen += 4;
+          pTemp   += 4;
+        }
+
+        if (pFRAM->iChangeclipping)
+        {
+          *pTemp = pFRAM->iBoundarytype;
+
+          mng_put_uint32 (pTemp+1,  pFRAM->iBoundaryl);
+          mng_put_uint32 (pTemp+5,  pFRAM->iBoundaryr);
+          mng_put_uint32 (pTemp+9,  pFRAM->iBoundaryt);
+          mng_put_uint32 (pTemp+13, pFRAM->iBoundaryb);
+
+          iRawlen += 17;
+          pTemp   += 17;
+        }
+
+        if (pFRAM->iChangesyncid)
+        {
+          iRawlen += pFRAM->iCount * 4;
+          pTemp2 = pFRAM->pSyncids;
+
+          for (iX = 0; iX < pFRAM->iCount; iX++)
+          {
+            mng_put_uint32 (pTemp, *pTemp2);
+
+            pTemp2++;
+            pTemp += 4;
+          }  
+        }
+      }
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pFRAM->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_FRAM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_move)
+{
+  mng_movep   pMOVE;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MOVE, MNG_LC_START);
+#endif
+
+  pMOVE = (mng_movep)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 13;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata,   pMOVE->iFirstid);
+  mng_put_uint16 (pRawdata+2, pMOVE->iLastid);
+
+  *(pRawdata+4) = pMOVE->iMovetype;
+
+  mng_put_int32  (pRawdata+5, pMOVE->iMovex);
+  mng_put_int32  (pRawdata+9, pMOVE->iMovey);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pMOVE->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MOVE, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_clip)
+{
+  mng_clipp   pCLIP;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_CLIP, MNG_LC_START);
+#endif
+
+  pCLIP = (mng_clipp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 21;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata,    pCLIP->iFirstid);
+  mng_put_uint16 (pRawdata+2,  pCLIP->iLastid);
+
+  *(pRawdata+4) = pCLIP->iCliptype;
+
+  mng_put_int32  (pRawdata+5,  pCLIP->iClipl);
+  mng_put_int32  (pRawdata+9,  pCLIP->iClipr);
+  mng_put_int32  (pRawdata+13, pCLIP->iClipt);
+  mng_put_int32  (pRawdata+17, pCLIP->iClipb);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pCLIP->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_CLIP, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_show)
+{
+  mng_showp   pSHOW;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SHOW, MNG_LC_START);
+#endif
+
+  pSHOW = (mng_showp)pChunk;           /* address the proper chunk */
+
+  if (pSHOW->bEmpty)                   /* empty ? */
+    iRetcode = write_raw_chunk (pData, pSHOW->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 2;
+                                       /* fill the output buffer */
+    mng_put_uint16 (pRawdata, pSHOW->iFirstid);
+
+    if ((pSHOW->iLastid != pSHOW->iFirstid) || (pSHOW->iMode))
+    {
+      iRawlen += 2;
+      mng_put_uint16 (pRawdata+2, pSHOW->iLastid);
+
+      if (pSHOW->iMode)
+      {
+        iRawlen++;
+        *(pRawdata+4) = pSHOW->iMode;
+      }
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pSHOW->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SHOW, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_term)
+{
+  mng_termp   pTERM;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TERM, MNG_LC_START);
+#endif
+
+  pTERM     = (mng_termp)pChunk;       /* address the proper chunk */
+
+  pRawdata  = pData->pWritebuf+8;      /* init output buffer & size */
+  iRawlen   = 1;
+
+  *pRawdata = pTERM->iTermaction;      /* fill the output buffer */
+
+  if (pTERM->iTermaction == 3)
+  {
+    iRawlen       = 10;
+    *(pRawdata+1) = pTERM->iIteraction;
+
+    mng_put_uint32 (pRawdata+2, pTERM->iDelay);
+    mng_put_uint32 (pRawdata+6, pTERM->iItermax);
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pTERM->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_TERM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+WRITE_CHUNK (mng_write_save)
+{
+  mng_savep       pSAVE;
+  mng_uint8p      pRawdata;
+  mng_uint32      iRawlen;
+  mng_retcode     iRetcode;
+  mng_save_entryp pEntry;
+  mng_uint32      iEntrysize;
+  mng_uint8p      pTemp;
+  mng_uint32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SAVE, MNG_LC_START);
+#endif
+
+  pSAVE = (mng_savep)pChunk;           /* address the proper chunk */
+
+  if (pSAVE->bEmpty)                   /* empty ? */
+    iRetcode = write_raw_chunk (pData, pSAVE->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata  = pData->pWritebuf+8;    /* init output buffer & size */
+    iRawlen   = 1;
+
+    *pRawdata = pSAVE->iOffsettype;    /* fill the output buffer */
+
+    if (pSAVE->iOffsettype == 16)
+      iEntrysize = 25;
+    else
+      iEntrysize = 17;
+
+    pTemp  = pRawdata+1;
+    pEntry = pSAVE->pEntries;
+
+    for (iX = 0; iX < pSAVE->iCount; iX++)
+    {
+      if (iX)                          /* put separator null-byte, except the first */
+      {
+        *pTemp = 0;
+        pTemp++;
+        iRawlen++;
+      }
+
+      iRawlen += iEntrysize + pEntry->iNamesize;
+      *pTemp = pEntry->iEntrytype;
+
+      if (pSAVE->iOffsettype == 16)
+      {
+        mng_put_uint32 (pTemp+1,  pEntry->iOffset[0]);
+        mng_put_uint32 (pTemp+5,  pEntry->iOffset[1]);
+        mng_put_uint32 (pTemp+9,  pEntry->iStarttime[0]);
+        mng_put_uint32 (pTemp+13, pEntry->iStarttime[1]);
+        mng_put_uint32 (pTemp+17, pEntry->iLayernr);
+        mng_put_uint32 (pTemp+21, pEntry->iFramenr);
+
+        pTemp += 25;
+      }
+      else
+      {
+        mng_put_uint32 (pTemp+1,  pEntry->iOffset[1]);
+        mng_put_uint32 (pTemp+5,  pEntry->iStarttime[1]);
+        mng_put_uint32 (pTemp+9,  pEntry->iLayernr);
+        mng_put_uint32 (pTemp+13, pEntry->iFramenr);
+
+        pTemp += 17;
+      }
+
+      if (pEntry->iNamesize)
+      {
+        MNG_COPY (pTemp, pEntry->zName, pEntry->iNamesize);
+        pTemp += pEntry->iNamesize;
+      }
+
+      pEntry++;  
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pSAVE->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SAVE, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+WRITE_CHUNK (mng_write_seek)
+{
+  mng_seekp   pSEEK;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SEEK, MNG_LC_START);
+#endif
+
+  pSEEK    = (mng_seekp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = pSEEK->iNamesize;
+
+  if (iRawlen)                         /* fill the output buffer */
+    MNG_COPY (pRawdata, pSEEK->zName, iRawlen);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pSEEK->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_SEEK, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+WRITE_CHUNK (mng_write_expi)
+{
+  mng_expip   pEXPI;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_EXPI, MNG_LC_START);
+#endif
+
+  pEXPI    = (mng_expip)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 2 + pEXPI->iNamesize;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata, pEXPI->iSnapshotid);
+
+  if (pEXPI->iNamesize)
+    MNG_COPY (pRawdata+2, pEXPI->zName, pEXPI->iNamesize);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pEXPI->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_EXPI, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_fPRI
+WRITE_CHUNK (mng_write_fpri)
+{
+  mng_fprip   pFPRI;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_FPRI, MNG_LC_START);
+#endif
+
+  pFPRI         = (mng_fprip)pChunk;   /* address the proper chunk */
+
+  pRawdata      = pData->pWritebuf+8;  /* init output buffer & size */
+  iRawlen       = 2;
+
+  *pRawdata     = pFPRI->iDeltatype;   /* fill the output buffer */
+  *(pRawdata+1) = pFPRI->iPriority;
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pFPRI->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_FPRI, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+WRITE_CHUNK (mng_write_need)
+{
+  mng_needp   pNEED;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_NEED, MNG_LC_START);
+#endif
+
+  pNEED    = (mng_needp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = pNEED->iKeywordssize;
+                                       /* fill the output buffer */
+  if (pNEED->iKeywordssize)
+    MNG_COPY (pRawdata, pNEED->zKeywords, pNEED->iKeywordssize);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pNEED->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_NEED, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYg
+WRITE_CHUNK (mng_write_phyg)
+{
+  mng_phygp   pPHYG;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PHYG, MNG_LC_START);
+#endif
+
+  pPHYG = (mng_phygp)pChunk;           /* address the proper chunk */
+
+  if (pPHYG->bEmpty)                   /* write empty ? */
+    iRetcode = write_raw_chunk (pData, pPHYG->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 9;
+                                       /* fill the output buffer */
+    mng_put_uint32 (pRawdata,   pPHYG->iSizex);
+    mng_put_uint32 (pRawdata+4, pPHYG->iSizey);
+
+    *(pRawdata+8) = pPHYG->iUnit;
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pPHYG->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PHYG, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+/* B004 */
+#ifdef MNG_INCLUDE_JNG
+/* B004 */
+WRITE_CHUNK (mng_write_jhdr)
+{
+  mng_jhdrp   pJHDR;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JHDR, MNG_LC_START);
+#endif
+
+  pJHDR    = (mng_jhdrp)pChunk;        /* address the proper chunk */
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 16;
+                                       /* fill the output buffer */
+  mng_put_uint32 (pRawdata,   pJHDR->iWidth);
+  mng_put_uint32 (pRawdata+4, pJHDR->iHeight);
+
+  *(pRawdata+8)  = pJHDR->iColortype;
+  *(pRawdata+9)  = pJHDR->iImagesampledepth;
+  *(pRawdata+10) = pJHDR->iImagecompression;
+  *(pRawdata+11) = pJHDR->iImageinterlace;
+  *(pRawdata+12) = pJHDR->iAlphasampledepth;
+  *(pRawdata+13) = pJHDR->iAlphacompression;
+  *(pRawdata+14) = pJHDR->iAlphafilter;
+  *(pRawdata+15) = pJHDR->iAlphainterlace;
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pJHDR->sHeader.iChunkname, iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JHDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#else
+#define write_jhdr 0
+/* B004 */
+#endif /* MNG_INCLUDE_JNG */
+/* B004 */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+WRITE_CHUNK (mng_write_jdaa)
+{
+  mng_jdatp   pJDAA;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JDAA, MNG_LC_START);
+#endif
+
+  pJDAA = (mng_jdaap)pChunk;           /* address the proper chunk */
+
+  if (pJDAA->bEmpty)                   /* and write it */
+    iRetcode = write_raw_chunk (pData, pJDAA->sHeader.iChunkname, 0, 0);
+  else
+    iRetcode = write_raw_chunk (pData, pJDAA->sHeader.iChunkname,
+                                pJDAA->iDatasize, pJDAA->pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JDAA, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#else
+#define write_jdaa 0
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+/* B004 */
+#ifdef MNG_INCLUDE_JNG
+/* B004 */
+WRITE_CHUNK (mng_write_jdat)
+{
+  mng_jdatp   pJDAT;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JDAT, MNG_LC_START);
+#endif
+
+  pJDAT = (mng_jdatp)pChunk;           /* address the proper chunk */
+
+  if (pJDAT->bEmpty)                   /* and write it */
+    iRetcode = write_raw_chunk (pData, pJDAT->sHeader.iChunkname, 0, 0);
+  else
+    iRetcode = write_raw_chunk (pData, pJDAT->sHeader.iChunkname,
+                                pJDAT->iDatasize, pJDAT->pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JDAT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#else
+#define write_jdat 0
+/* B004 */
+#endif /* MNG_INCLUDE_JNG */
+/* B004 */
+
+/* ************************************************************************** */
+
+/* B004 */
+#ifdef MNG_INCLUDE_JNG
+/* B004 */
+WRITE_CHUNK (mng_write_jsep)
+{
+  mng_jsepp   pJSEP;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JSEP, MNG_LC_START);
+#endif
+
+  pJSEP = (mng_jsepp)pChunk;           /* address the proper chunk */
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pJSEP->sHeader.iChunkname, 0, 0);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_JSEP, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#else
+#define write_jsep 0
+/* B004 */
+#endif /* MNG_INCLUDE_JNG */
+/* B004 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+WRITE_CHUNK (mng_write_dhdr)
+{
+  mng_dhdrp   pDHDR;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DHDR, MNG_LC_START);
+#endif
+
+  pDHDR    = (mng_dhdrp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 4;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata, pDHDR->iObjectid);
+
+  *(pRawdata+2) = pDHDR->iImagetype;
+  *(pRawdata+3) = pDHDR->iDeltatype;
+
+  if (pDHDR->iDeltatype != 7)
+  {
+    iRawlen += 8;
+    mng_put_uint32 (pRawdata+4, pDHDR->iBlockwidth);
+    mng_put_uint32 (pRawdata+8, pDHDR->iBlockheight);
+
+    if (pDHDR->iDeltatype != 0)
+    {
+      iRawlen += 8;
+      mng_put_uint32 (pRawdata+12, pDHDR->iBlockx);
+      mng_put_uint32 (pRawdata+16, pDHDR->iBlocky);
+    }
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pDHDR->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DHDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+WRITE_CHUNK (mng_write_prom)
+{
+  mng_promp   pPROM;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PROM, MNG_LC_START);
+#endif
+
+  pPROM    = (mng_promp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 3;
+
+  *pRawdata     = pPROM->iColortype;   /* fill the output buffer */
+  *(pRawdata+1) = pPROM->iSampledepth;
+  *(pRawdata+2) = pPROM->iFilltype;
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pPROM->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PROM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+WRITE_CHUNK (mng_write_ipng)
+{
+  mng_ipngp   pIPNG;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IPNG, MNG_LC_START);
+#endif
+
+  pIPNG = (mng_ipngp)pChunk;           /* address the proper chunk */
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pIPNG->sHeader.iChunkname, 0, 0);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IPNG, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+WRITE_CHUNK (mng_write_pplt)
+{
+  mng_ppltp       pPPLT;
+  mng_uint8p      pRawdata;
+  mng_uint32      iRawlen;
+  mng_retcode     iRetcode;
+  mng_pplt_entryp pEntry;
+  mng_uint8p      pTemp;
+  mng_uint32      iX;
+  mng_bool        bHasgroup;
+  mng_uint8p      pLastid = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PPLT, MNG_LC_START);
+#endif
+
+  pPPLT = (mng_ppltp)pChunk;           /* address the proper chunk */
+
+  pRawdata  = pData->pWritebuf+8;      /* init output buffer & size */
+  iRawlen   = 1;
+
+  *pRawdata = pPPLT->iDeltatype;       /* fill the output buffer */
+
+  pTemp     = pRawdata+1;
+  bHasgroup = MNG_FALSE;
+
+  for (iX = 0; iX < pPPLT->iCount; iX++)
+  {
+    pEntry = &pPPLT->aEntries[iX];
+    
+    if (pEntry->bUsed)                 /* valid entry ? */
+    {
+      if (!bHasgroup)                  /* start a new group ? */
+      {
+        bHasgroup  = MNG_TRUE;
+        pLastid    = pTemp+1;
+
+        *pTemp     = (mng_uint8)iX;
+        *(pTemp+1) = 0;
+
+        pTemp += 2;
+        iRawlen += 2;
+      }
+
+      switch (pPPLT->iDeltatype)       /* add group-entry depending on type */
+      {
+        case 0: ;
+        case 1: {
+                  *pTemp     = pEntry->iRed;
+                  *(pTemp+1) = pEntry->iGreen;
+                  *(pTemp+2) = pEntry->iBlue;
+
+                  pTemp += 3;
+                  iRawlen += 3;
+
+                  break;
+                }
+
+        case 2: ;
+        case 3: {
+                  *pTemp     = pEntry->iAlpha;
+
+                  pTemp++;
+                  iRawlen++;
+
+                  break;
+                }
+
+        case 4: ;
+        case 5: {
+                  *pTemp     = pEntry->iRed;
+                  *(pTemp+1) = pEntry->iGreen;
+                  *(pTemp+2) = pEntry->iBlue;
+                  *(pTemp+3) = pEntry->iAlpha;
+
+                  pTemp += 4;
+                  iRawlen += 4;
+
+                  break;
+                }
+
+      }
+    }
+    else
+    {
+      if (bHasgroup)                   /* finish off a group ? */
+        *pLastid = (mng_uint8)(iX-1);
+
+      bHasgroup = MNG_FALSE;
+    }
+  }
+
+  if (bHasgroup)                       /* last group unfinished ? */
+    *pLastid = (mng_uint8)(pPPLT->iCount-1);
+                                       /* write the output buffer */
+  iRetcode = write_raw_chunk (pData, pPPLT->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_PPLT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+WRITE_CHUNK (mng_write_ijng)
+{
+  mng_ijngp   pIJNG;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IJNG, MNG_LC_START);
+#endif
+
+  pIJNG = (mng_ijngp)pChunk;           /* address the proper chunk */
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pIJNG->sHeader.iChunkname, 0, 0);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_IJNG, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+WRITE_CHUNK (mng_write_drop)
+{
+  mng_dropp        pDROP;
+  mng_uint8p       pRawdata;
+  mng_uint32       iRawlen;
+  mng_retcode      iRetcode;
+  mng_uint32       iX;
+  mng_uint8p       pTemp1;
+  mng_chunkidp     pTemp2;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DROP, MNG_LC_START);
+#endif
+
+  pDROP    = (mng_dropp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = pDROP->iCount << 2;
+
+  pTemp1   = pRawdata;                 /* fill the output buffer */
+  pTemp2   = pDROP->pChunknames;
+
+  for (iX = 0; iX < pDROP->iCount; iX++)
+  {
+    mng_put_uint32 (pTemp1, (mng_uint32)*pTemp2);
+
+    pTemp2++;
+    pTemp1 += 4;
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pDROP->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DROP, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+WRITE_CHUNK (mng_write_dbyk)
+{
+  mng_dbykp   pDBYK;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DBYK, MNG_LC_START);
+#endif
+
+  pDBYK = (mng_dbykp)pChunk;           /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 5 + pDBYK->iKeywordssize;
+                                       /* fill the output buffer */
+  mng_put_uint32 (pRawdata, pDBYK->iChunkname);
+  *(pRawdata+4) = pDBYK->iPolarity;
+
+  if (pDBYK->iKeywordssize)
+    MNG_COPY (pRawdata+5, pDBYK->zKeywords, pDBYK->iKeywordssize);
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pDBYK->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_DBYK, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+WRITE_CHUNK (mng_write_ordr)
+{
+  mng_ordrp       pORDR;
+  mng_uint8p      pRawdata;
+  mng_uint32      iRawlen;
+  mng_retcode     iRetcode;
+  mng_uint8p      pTemp;
+  mng_ordr_entryp pEntry;
+  mng_uint32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ORDR, MNG_LC_START);
+#endif
+
+  pORDR    = (mng_ordrp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = pORDR->iCount * 5;
+
+  pTemp    = pRawdata;                 /* fill the output buffer */
+  pEntry   = pORDR->pEntries;
+
+  for (iX = 0; iX < pORDR->iCount; iX++)
+  {
+    mng_put_uint32 (pTemp, pEntry->iChunkname);
+    *(pTemp+4) = pEntry->iOrdertype;
+    pTemp += 5;
+    pEntry++;
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pORDR->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_ORDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_magn)
+{
+  mng_magnp   pMAGN;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MAGN, MNG_LC_START);
+#endif
+
+  pMAGN    = (mng_magnp)pChunk;        /* address the proper chunk */
+
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 18;
+                                       /* fill the output buffer */
+  mng_put_uint16 (pRawdata,    pMAGN->iFirstid);
+  mng_put_uint16 (pRawdata+2,  pMAGN->iLastid);
+  *(pRawdata+4) = pMAGN->iMethodX;
+  mng_put_uint16 (pRawdata+5,  pMAGN->iMX);
+  mng_put_uint16 (pRawdata+7,  pMAGN->iMY);
+  mng_put_uint16 (pRawdata+9,  pMAGN->iML);
+  mng_put_uint16 (pRawdata+11, pMAGN->iMR);
+  mng_put_uint16 (pRawdata+13, pMAGN->iMT);
+  mng_put_uint16 (pRawdata+15, pMAGN->iMB);
+  *(pRawdata+17) = pMAGN->iMethodY;
+                                       /* optimize length */
+  if (pMAGN->iMethodY == pMAGN->iMethodX)
+  {
+    iRawlen--;
+
+    if (pMAGN->iMB == pMAGN->iMY)
+    {
+      iRawlen -= 2;
+
+      if (pMAGN->iMT == pMAGN->iMY)
+      {
+        iRawlen -= 2;
+
+        if (pMAGN->iMR == pMAGN->iMX)
+        {
+          iRawlen -= 2;
+
+          if (pMAGN->iML == pMAGN->iMX)
+          {
+            iRawlen -= 2;
+
+            if (pMAGN->iMY == pMAGN->iMX)
+            {
+              iRawlen -= 2;
+
+              if (pMAGN->iMX == 1)
+              {
+                iRawlen -= 2;
+
+                if (pMAGN->iMethodX == 0)
+                {
+                  iRawlen--;
+
+                  if (pMAGN->iLastid == pMAGN->iFirstid)
+                  {
+                    iRawlen -= 2;
+
+                    if (pMAGN->iFirstid == 0)
+                      iRawlen = 0;
+
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pMAGN->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MAGN, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+WRITE_CHUNK (mng_write_mpng)
+{
+  mng_mpngp   pMPNG;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+  mng_uint8p  pBuf = 0;
+  mng_uint32  iBuflen;
+  mng_uint32  iReallen;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MPNG, MNG_LC_START);
+#endif
+
+  pMPNG = (mng_mpngp)pChunk;           /* address the proper chunk */
+                                       /* compress the frame structures */
+  iRetcode = deflate_buffer (pData, (mng_uint8p)pMPNG->pFrames, pMPNG->iFramessize,
+                             &pBuf, &iBuflen, &iReallen);
+
+  if (!iRetcode)                       /* all ok ? */
+  {
+    pRawdata = pData->pWritebuf+8;     /* init output buffer & size */
+    iRawlen  = 15 + iReallen;
+                                       /* requires large buffer ? */
+    if (iRawlen > pData->iWritebufsize)
+      MNG_ALLOC (pData, pRawdata, iRawlen);
+                                       /* fill the buffer */
+    mng_put_uint32 (pRawdata,    pMPNG->iFramewidth);
+    mng_put_uint32 (pRawdata+4,  pMPNG->iFrameheight);
+    mng_put_uint16 (pRawdata+8,  pMPNG->iNumplays);
+    mng_put_uint16 (pRawdata+10, pMPNG->iTickspersec);
+    *(pRawdata+12) = pMPNG->iCompressionmethod;
+
+    if (iReallen)
+      MNG_COPY (pRawdata+13, pBuf, iReallen);
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pMPNG->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+                                       /* drop the temp buffer ? */
+    if (iRawlen > pData->iWritebufsize)
+      MNG_FREEX (pData, pRawdata, iRawlen);
+  }
+
+  MNG_FREEX (pData, pBuf, iBuflen);    /* always drop the compression buffer */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_MPNG, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+WRITE_CHUNK (mng_write_ahdr)
+{
+  mng_ahdrp   pAHDR;
+  mng_uint8p  pRawdata;
+  mng_uint32  iRawlen;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_AHDR, MNG_LC_START);
+#endif
+
+  pAHDR    = (mng_ahdrp)pChunk;        /* address the proper chunk */
+  pRawdata = pData->pWritebuf+8;       /* init output buffer & size */
+  iRawlen  = 22;
+                                       /* fill the buffer */
+  mng_put_uint32 (pRawdata,    pAHDR->iNumframes);
+  mng_put_uint32 (pRawdata+4,  pAHDR->iTickspersec);
+  mng_put_uint32 (pRawdata+8,  pAHDR->iNumplays);
+  mng_put_uint32 (pRawdata+12, pAHDR->iTilewidth);
+  mng_put_uint32 (pRawdata+16, pAHDR->iTileheight);
+  *(pRawdata+20) = pAHDR->iInterlace;
+  *(pRawdata+21) = pAHDR->iStillused;
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pAHDR->sHeader.iChunkname,
+                              iRawlen, pRawdata);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_AHDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+WRITE_CHUNK (mng_write_adat)
+{
+
+  /* TODO: something */
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+WRITE_CHUNK (mng_write_evnt)
+{
+  mng_evntp       pEVNT;
+  mng_uint8p      pRawdata;
+  mng_uint32      iRawlen;
+  mng_retcode     iRetcode;
+  mng_evnt_entryp pEntry;
+  mng_uint8p      pTemp;
+  mng_uint32      iX;
+  mng_uint32      iNamesize;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_EVNT, MNG_LC_START);
+#endif
+
+  pEVNT = (mng_evntp)pChunk;           /* address the proper chunk */
+
+  if (!pEVNT->iCount)                  /* empty ? */
+    iRetcode = write_raw_chunk (pData, pEVNT->sHeader.iChunkname, 0, 0);
+  else
+  {
+    pRawdata  = pData->pWritebuf+8;    /* init output buffer & size */
+    iRawlen   = 0;
+    pTemp     = pRawdata;
+    pEntry    = pEVNT->pEntries;
+
+    for (iX = 0; iX < pEVNT->iCount; iX++)
+    {
+      if (iX)                          /* put separator null-byte, except the first */
+      {
+        *pTemp = 0;
+        pTemp++;
+        iRawlen++;
+      }
+
+      *pTemp     = pEntry->iEventtype;
+      *(pTemp+1) = pEntry->iMasktype;
+      pTemp   += 2;
+      iRawlen += 2;
+
+      switch (pEntry->iMasktype)
+      {
+        case 1 :
+          {
+            mng_put_int32 (pTemp, pEntry->iLeft);
+            mng_put_int32 (pTemp+4, pEntry->iRight);
+            mng_put_int32 (pTemp+8, pEntry->iTop);
+            mng_put_int32 (pTemp+12, pEntry->iBottom);
+            pTemp   += 16;
+            iRawlen += 16;
+            break;
+          }
+        case 2 :
+          {
+            mng_put_uint16 (pTemp, pEntry->iObjectid);
+            pTemp   += 2;
+            iRawlen += 2;
+            break;
+          }
+        case 3 :
+          {
+            mng_put_uint16 (pTemp, pEntry->iObjectid);
+            *(pTemp+2) = pEntry->iIndex;
+            pTemp   += 3;
+            iRawlen += 3;
+            break;
+          }
+        case 4 :
+          {
+            mng_put_int32 (pTemp, pEntry->iLeft);
+            mng_put_int32 (pTemp+4, pEntry->iRight);
+            mng_put_int32 (pTemp+8, pEntry->iTop);
+            mng_put_int32 (pTemp+12, pEntry->iBottom);
+            mng_put_uint16 (pTemp+16, pEntry->iObjectid);
+            pTemp   += 18;
+            iRawlen += 18;
+            break;
+          }
+        case 5 :
+          {
+            mng_put_int32 (pTemp, pEntry->iLeft);
+            mng_put_int32 (pTemp+4, pEntry->iRight);
+            mng_put_int32 (pTemp+8, pEntry->iTop);
+            mng_put_int32 (pTemp+12, pEntry->iBottom);
+            mng_put_uint16 (pTemp+16, pEntry->iObjectid);
+            *(pTemp+18) = pEntry->iIndex;
+            pTemp   += 19;
+            iRawlen += 19;
+            break;
+          }
+      }
+
+      iNamesize = pEntry->iSegmentnamesize;
+
+      if (iNamesize)
+      {
+        MNG_COPY (pTemp, pEntry->zSegmentname, iNamesize);
+        pTemp   += iNamesize;
+        iRawlen += iNamesize;
+      }
+
+      pEntry++;  
+    }
+                                       /* and write it */
+    iRetcode = write_raw_chunk (pData, pEVNT->sHeader.iChunkname,
+                                iRawlen, pRawdata);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_EVNT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+WRITE_CHUNK (mng_write_unknown)
+{
+  mng_unknown_chunkp pUnknown;
+  mng_retcode        iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_UNKNOWN, MNG_LC_START);
+#endif
+                                       /* address the proper chunk */
+  pUnknown = (mng_unknown_chunkp)pChunk;
+                                       /* and write it */
+  iRetcode = write_raw_chunk (pData, pUnknown->sHeader.iChunkname,
+                              pUnknown->iDatasize, pUnknown->pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_UNKNOWN, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_chunk_io.h b/src/3rdparty/libmng/libmng_chunk_io.h
new file mode 100644
index 0000000..f8505ba
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunk_io.h
@@ -0,0 +1,415 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunk_io.h         copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.109                                                      * */
+/* *                                                                        * */
+/* * purpose   : Chunk I/O routines (definition)                            * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the chunk input/output routines              * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/04/2000 - G.Juyn                                * */
+/* *             - changed CRC initialization to use dynamic structure      * */
+/* *               (wasn't thread-safe the old way !)                       * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed write routines definition                        * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for JDAA                                   * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added SKIP_CHUNK and NO_DELTA_PNG support                * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - fixed SKIPCHUNK_itXT and SKIPCHUNK_ztXT typos            * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/07/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKREADER               * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_chunk_io_h_
+#define _libmng_chunk_io_h_
+
+/* ************************************************************************** */
+
+mng_uint32 mng_crc (mng_datap  pData,
+                    mng_uint8p buf,
+                    mng_int32  len);
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_READ_PROCS
+
+/* ************************************************************************** */
+
+mng_retcode mng_inflate_buffer (mng_datap  pData,
+                                mng_uint8p pInbuf,
+                                mng_uint32 iInsize,
+                                mng_uint8p *pOutbuf,
+                                mng_uint32 *iOutsize,
+                                mng_uint32 *iRealsize);
+
+/* ************************************************************************** */
+
+#define READ_CHUNK(n) mng_retcode n (mng_datap   pData,    \
+                                     mng_chunkp  pHeader,  \
+                                     mng_uint32  iRawlen,  \
+                                     mng_uint8p  pRawdata, \
+                                     mng_chunkp* ppChunk)
+
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+READ_CHUNK (mng_read_general) ;
+#endif
+
+READ_CHUNK (mng_read_ihdr) ;
+READ_CHUNK (mng_read_plte) ;
+READ_CHUNK (mng_read_idat) ;
+READ_CHUNK (mng_read_iend) ;
+READ_CHUNK (mng_read_trns) ;
+READ_CHUNK (mng_read_gama) ;
+READ_CHUNK (mng_read_chrm) ;
+READ_CHUNK (mng_read_srgb) ;
+#ifndef MNG_SKIPCHUNK_iCCP
+READ_CHUNK (mng_read_iccp) ;
+#endif
+#ifndef MNG_SKIPCHUNK_tEXt
+READ_CHUNK (mng_read_text) ;
+#endif
+#ifndef MNG_SKIPCHUNK_zTXt
+READ_CHUNK (mng_read_ztxt) ;
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+READ_CHUNK (mng_read_itxt) ;
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+READ_CHUNK (mng_read_bkgd) ;
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+READ_CHUNK (mng_read_phys) ;
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+READ_CHUNK (mng_read_sbit) ;
+#endif
+#ifndef MNG_SKIPCHUNK_sPLT
+READ_CHUNK (mng_read_splt) ;
+#endif
+#ifndef MNG_SKIPCHUNK_hIST
+READ_CHUNK (mng_read_hist) ;
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+READ_CHUNK (mng_read_time) ;
+#endif
+READ_CHUNK (mng_read_mhdr) ;
+READ_CHUNK (mng_read_mend) ;
+READ_CHUNK (mng_read_loop) ;
+READ_CHUNK (mng_read_endl) ;
+READ_CHUNK (mng_read_defi) ;
+READ_CHUNK (mng_read_basi) ;
+READ_CHUNK (mng_read_clon) ;
+#ifndef MNG_SKIPCHUNK_PAST
+READ_CHUNK (mng_read_past) ;
+#endif
+READ_CHUNK (mng_read_disc) ;
+READ_CHUNK (mng_read_back) ;
+READ_CHUNK (mng_read_fram) ;
+READ_CHUNK (mng_read_move) ;
+READ_CHUNK (mng_read_clip) ;
+READ_CHUNK (mng_read_show) ;
+READ_CHUNK (mng_read_term) ;
+READ_CHUNK (mng_read_save) ;
+READ_CHUNK (mng_read_seek) ;
+#ifndef MNG_SKIPCHUNK_eXPI
+READ_CHUNK (mng_read_expi) ;
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+READ_CHUNK (mng_read_fpri) ;
+#endif
+#ifndef MNG_SKIPCHUNK_pHYg
+READ_CHUNK (mng_read_phyg) ;
+#endif
+#ifdef MNG_INCLUDE_JNG
+READ_CHUNK (mng_read_jhdr) ;
+READ_CHUNK (mng_read_jdaa) ;
+READ_CHUNK (mng_read_jdat) ;
+READ_CHUNK (mng_read_jsep) ;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+READ_CHUNK (mng_read_dhdr) ;
+READ_CHUNK (mng_read_prom) ;
+READ_CHUNK (mng_read_ipng) ;
+READ_CHUNK (mng_read_pplt) ;
+#ifdef MNG_INCLUDE_JNG
+READ_CHUNK (mng_read_ijng) ;
+#endif
+READ_CHUNK (mng_read_drop) ;
+READ_CHUNK (mng_read_dbyk) ;
+READ_CHUNK (mng_read_ordr) ;
+#endif
+READ_CHUNK (mng_read_magn) ;
+#ifndef MNG_SKIPCHUNK_nEED
+READ_CHUNK (mng_read_need) ;
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+READ_CHUNK (mng_read_mpng) ;
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+READ_CHUNK (mng_read_evnt) ;
+#endif
+READ_CHUNK (mng_read_unknown) ;
+
+/* ************************************************************************** */
+
+#else /* MNG_INCLUDE_READ_PROCS */
+#define mng_read_ihdr 0
+#define mng_read_plte 0
+#define mng_read_idat 0
+#define mng_read_iend 0
+#define mng_read_trns 0
+#define mng_read_gama 0
+#define mng_read_chrm 0
+#define mng_read_srgb 0
+#define mng_read_iccp 0
+#define mng_read_text 0
+#define mng_read_ztxt 0
+#define mng_read_itxt 0
+#define mng_read_bkgd 0
+#define mng_read_phys 0
+#define mng_read_sbit 0
+#define mng_read_splt 0
+#define mng_read_hist 0
+#define mng_read_time 0
+#define mng_read_mhdr 0
+#define mng_read_mend 0
+#define mng_read_loop 0
+#define mng_read_endl 0
+#define mng_read_defi 0
+#define mng_read_basi 0
+#define mng_read_clon 0
+#ifndef MNG_SKIPCHUNK_PAST
+#define mng_read_past 0
+#endif
+#define mng_read_disc 0
+#define mng_read_back 0
+#define mng_read_fram 0
+#define mng_read_move 0
+#define mng_read_clip 0
+#define mng_read_show 0
+#define mng_read_term 0
+#define mng_read_save 0
+#define mng_read_seek 0
+#define mng_read_expi 0
+#define mng_read_fpri 0
+#define mng_read_phyg 0
+#ifdef MNG_INCLUDE_JNG
+#define mng_read_jhdr 0
+#define mng_read_jdaa 0
+#define mng_read_jdat 0
+#define mng_read_jsep 0
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#define mng_read_dhdr 0
+#define mng_read_prom 0
+#define mng_read_ipng 0
+#define mng_read_pplt 0
+#ifdef MNG_INCLUDE_JNG
+#define mng_read_ijng 0
+#endif
+#define mng_read_drop 0
+#define mng_read_dbyk 0
+#define mng_read_ordr 0
+#endif
+#define mng_read_magn 0
+#define mng_read_need 0
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+#define mng_read_mpng 0
+#endif
+#define mng_read_evnt 0
+#define mng_read_unknown 0
+#endif /* MNG_INCLUDE_READ_PROCS */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+#define WRITE_CHUNK(n) mng_retcode n (mng_datap  pData,   \
+                                      mng_chunkp pChunk)
+
+WRITE_CHUNK (mng_write_ihdr) ;
+WRITE_CHUNK (mng_write_plte) ;
+WRITE_CHUNK (mng_write_idat) ;
+WRITE_CHUNK (mng_write_iend) ;
+WRITE_CHUNK (mng_write_trns) ;
+WRITE_CHUNK (mng_write_gama) ;
+WRITE_CHUNK (mng_write_chrm) ;
+WRITE_CHUNK (mng_write_srgb) ;
+WRITE_CHUNK (mng_write_iccp) ;
+WRITE_CHUNK (mng_write_text) ;
+WRITE_CHUNK (mng_write_ztxt) ;
+WRITE_CHUNK (mng_write_itxt) ;
+WRITE_CHUNK (mng_write_bkgd) ;
+WRITE_CHUNK (mng_write_phys) ;
+WRITE_CHUNK (mng_write_sbit) ;
+WRITE_CHUNK (mng_write_splt) ;
+WRITE_CHUNK (mng_write_hist) ;
+WRITE_CHUNK (mng_write_time) ;
+WRITE_CHUNK (mng_write_mhdr) ;
+WRITE_CHUNK (mng_write_mend) ;
+WRITE_CHUNK (mng_write_loop) ;
+WRITE_CHUNK (mng_write_endl) ;
+WRITE_CHUNK (mng_write_defi) ;
+WRITE_CHUNK (mng_write_basi) ;
+WRITE_CHUNK (mng_write_clon) ;
+#ifndef MNG_SKIPCHUNK_PAST
+WRITE_CHUNK (mng_write_past) ;
+#endif
+WRITE_CHUNK (mng_write_disc) ;
+WRITE_CHUNK (mng_write_back) ;
+WRITE_CHUNK (mng_write_fram) ;
+WRITE_CHUNK (mng_write_move) ;
+WRITE_CHUNK (mng_write_clip) ;
+WRITE_CHUNK (mng_write_show) ;
+WRITE_CHUNK (mng_write_term) ;
+WRITE_CHUNK (mng_write_save) ;
+WRITE_CHUNK (mng_write_seek) ;
+WRITE_CHUNK (mng_write_expi) ;
+WRITE_CHUNK (mng_write_fpri) ;
+WRITE_CHUNK (mng_write_phyg) ;
+#ifdef MNG_INCLUDE_JNG
+WRITE_CHUNK (mng_write_jhdr) ;
+WRITE_CHUNK (mng_write_jdaa) ;
+WRITE_CHUNK (mng_write_jdat) ;
+WRITE_CHUNK (mng_write_jsep) ;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+WRITE_CHUNK (mng_write_dhdr) ;
+WRITE_CHUNK (mng_write_prom) ;
+WRITE_CHUNK (mng_write_ipng) ;
+WRITE_CHUNK (mng_write_pplt) ;
+#ifdef MNG_INCLUDE_JNG
+WRITE_CHUNK (mng_write_ijng) ;
+#endif
+WRITE_CHUNK (mng_write_drop) ;
+WRITE_CHUNK (mng_write_dbyk) ;
+WRITE_CHUNK (mng_write_ordr) ;
+#endif
+WRITE_CHUNK (mng_write_magn) ;
+WRITE_CHUNK (mng_write_need) ;
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+WRITE_CHUNK (mng_write_mpng) ;
+#endif
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+WRITE_CHUNK (mng_write_ahdr) ;
+WRITE_CHUNK (mng_write_adat) ;
+#endif
+WRITE_CHUNK (mng_write_evnt) ;
+WRITE_CHUNK (mng_write_unknown) ;
+
+/* ************************************************************************** */
+
+#else /* MNG_INCLUDE_WRITE_PROCS */
+#define mng_write_ihdr 0
+#define mng_write_plte 0
+#define mng_write_idat 0
+#define mng_write_iend 0
+#define mng_write_trns 0
+#define mng_write_gama 0
+#define mng_write_chrm 0
+#define mng_write_srgb 0
+#define mng_write_iccp 0
+#define mng_write_text 0
+#define mng_write_ztxt 0
+#define mng_write_itxt 0
+#define mng_write_bkgd 0
+#define mng_write_phys 0
+#define mng_write_sbit 0
+#define mng_write_splt 0
+#define mng_write_hist 0
+#define mng_write_time 0
+#define mng_write_mhdr 0
+#define mng_write_mend 0
+#define mng_write_loop 0
+#define mng_write_endl 0
+#define mng_write_defi 0
+#define mng_write_basi 0
+#define mng_write_clon 0
+#ifndef MNG_SKIPCHUNK_PAST
+#define mng_write_past 0
+#endif
+#define mng_write_disc 0
+#define mng_write_back 0
+#define mng_write_fram 0
+#define mng_write_move 0
+#define mng_write_clip 0
+#define mng_write_show 0
+#define mng_write_term 0
+#define mng_write_save 0
+#define mng_write_seek 0
+#define mng_write_expi 0
+#define mng_write_fpri 0
+#define mng_write_phyg 0
+#ifdef MNG_INCLUDE_JNG
+#define mng_write_jhdr 0
+#define mng_write_jdaa 0
+#define mng_write_jdat 0
+#define mng_write_jsep 0
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#define mng_write_dhdr 0
+#define mng_write_prom 0
+#define mng_write_ipng 0
+#define mng_write_pplt 0
+#ifdef MNG_INCLUDE_JNG
+#define mng_write_ijng 0
+#endif
+#define mng_write_drop 0
+#define mng_write_dbyk 0
+#define mng_write_ordr 0
+#endif
+#define mng_write_magn 0
+#define mng_write_need 0
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+#define mng_write_mpng 0
+#endif
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+#define mng_write_adat 0
+#define mng_write_ahdr 0
+#endif
+#define mng_write_evnt 0
+#define mng_write_unknown 0
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+
+#endif /* _libmng_chunk_io_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_chunk_prc.c b/src/3rdparty/libmng/libmng_chunk_prc.c
new file mode 100644
index 0000000..e633e7e
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunk_prc.c
@@ -0,0 +1,4452 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunk_prc.c        copyright (c) 2000-2005 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Chunk initialization & cleanup (implementation)            * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the chunk initialization & cleanup       * */
+/* *             routines                                                   * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - fixed creation-code                                      * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - put add_chunk() inside MNG_INCLUDE_WRITE_PROCS wrapper   * */
+/* *             0.9.2 - 08/01/2000 - G.Juyn                                * */
+/* *             - wrapper for add_chunk() changed                          * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for JDAA                                   * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             - added HLAPI function to copy chunks                      * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 10/04/2002 - G.Juyn                                * */
+/* *             - fixed chunk-storage for evNT chunk                       * */
+/* *             1.0.5 - 10/17/2002 - G.Juyn                                * */
+/* *             - fixed issue in freeing evNT chunk                        * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             - added MNG_NO_DELTA_PNG reduction feature                 * */
+/* *             1.0.6 - 07/14/2003 - G.R-P                                 * */
+/* *             - added MNG_NO_LOOP_SIGNALS_SUPPORTED conditional          * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *             1.0.6 - 08/17/2003 - G.R-P                                 * */
+/* *             - added conditionals around non-VLC chunk support          * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - fixed SKIPCHUNK_eXPI -> fPRI typo                        * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/25/2004 - G.Juyn                                * */
+/* *             - replaced MNG_TWEAK_LARGE_FILES with permanent solution   * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKINITFREE             * */
+/* *             1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKASSIGN               * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* *             1.0.10 - 07/30/2005 - G.Juyn                               * */
+/* *             - fixed problem with CLON object during readdisplay()      * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_chunks.h"
+#include "libmng_chunk_prc.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * General chunk routines                                                 * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+void mng_add_chunk (mng_datap  pData,
+                    mng_chunkp pChunk)
+{
+  if (!pData->pFirstchunk)             /* list is still empty ? */
+  {
+    pData->pFirstchunk      = pChunk;  /* then this becomes the first */
+    
+#ifdef MNG_SUPPORT_WRITE
+    if (!pData->iFirstchunkadded)
+    {
+      pData->iFirstchunkadded = ((mng_chunk_headerp)pChunk)->iChunkname;
+#endif
+
+      if (((mng_chunk_headerp)pChunk)->iChunkname == MNG_UINT_IHDR)
+        pData->eImagetype     = mng_it_png;
+      else
+#ifdef MNG_INCLUDE_JNG
+      if (((mng_chunk_headerp)pChunk)->iChunkname == MNG_UINT_JHDR)
+        pData->eImagetype     = mng_it_jng;
+      else
+#endif
+        pData->eImagetype     = mng_it_mng;
+
+      pData->eSigtype         = pData->eImagetype;
+#ifdef MNG_SUPPORT_WRITE
+    }
+#endif
+  }
+  else
+  {                                    /* else we make appropriate links */
+    ((mng_chunk_headerp)pChunk)->pPrev = pData->pLastchunk;
+    ((mng_chunk_headerp)pData->pLastchunk)->pNext = pChunk;
+  }
+
+  pData->pLastchunk = pChunk;          /* and it's always the last */
+
+  return;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Chunk specific initialization routines                                 * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+INIT_CHUNK_HDR (mng_init_general)
+{
+  MNG_ALLOC (pData, *ppChunk, ((mng_chunk_headerp)pHeader)->iChunksize);
+  MNG_COPY (*ppChunk, pHeader, sizeof (mng_chunk_header));
+  return MNG_NOERROR;
+}
+
+#else /* MNG_OPTIMIZE_CHUNKINITFREE */
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_ihdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IHDR, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_ihdr));
+  ((mng_ihdrp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_plte)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PLTE, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_plte));
+  ((mng_pltep)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_idat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDAT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_idat));
+  ((mng_idatp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_iend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IEND, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_iend));
+  ((mng_iendp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_trns)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TRNS, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_trns));
+  ((mng_trnsp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_gAMA
+INIT_CHUNK_HDR (mng_init_gama)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GAMA, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_gama));
+  ((mng_gamap)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+INIT_CHUNK_HDR (mng_init_chrm)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_CHRM, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_chrm));
+  ((mng_chrmp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sRGB
+INIT_CHUNK_HDR (mng_init_srgb)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SRGB, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_srgb));
+  ((mng_srgbp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+INIT_CHUNK_HDR (mng_init_iccp)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ICCP, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_iccp));
+  ((mng_iccpp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+INIT_CHUNK_HDR (mng_init_text)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TEXT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_text));
+  ((mng_textp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TEXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+INIT_CHUNK_HDR (mng_init_ztxt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ZTXT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_ztxt));
+  ((mng_ztxtp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ZTXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+INIT_CHUNK_HDR (mng_init_itxt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ITXT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_itxt));
+  ((mng_itxtp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ITXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+INIT_CHUNK_HDR (mng_init_bkgd)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_BKGD, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_bkgd));
+  ((mng_bkgdp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYs
+INIT_CHUNK_HDR (mng_init_phys)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PHYS, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_phys));
+  ((mng_physp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PHYS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sBIT
+INIT_CHUNK_HDR (mng_init_sbit)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SBIT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_sbit));
+  ((mng_sbitp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SBIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+INIT_CHUNK_HDR (mng_init_splt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SPLT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_splt));
+  ((mng_spltp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+INIT_CHUNK_HDR (mng_init_hist)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_HIST, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_hist));
+  ((mng_histp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_HIST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tIME
+INIT_CHUNK_HDR (mng_init_time)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TIME, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_time));
+  ((mng_timep)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TIME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_mhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MHDR, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_mhdr));
+  ((mng_mhdrp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_mend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MEND, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_mend));
+  ((mng_mendp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+INIT_CHUNK_HDR (mng_init_loop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_LOOP, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_loop));
+  ((mng_loopp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_LOOP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_endl)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ENDL, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_endl));
+  ((mng_endlp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+INIT_CHUNK_HDR (mng_init_defi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DEFI, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_defi));
+  ((mng_defip)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BASI
+INIT_CHUNK_HDR (mng_init_basi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_BASI, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_basi));
+  ((mng_basip)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLON
+INIT_CHUNK_HDR (mng_init_clon)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_CLON, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_clon));
+  ((mng_clonp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+INIT_CHUNK_HDR (mng_init_past)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PAST, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_past));
+  ((mng_pastp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PAST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+INIT_CHUNK_HDR (mng_init_disc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DISC, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_disc));
+  ((mng_discp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DISC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BACK
+INIT_CHUNK_HDR (mng_init_back)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_BACK, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_back));
+  ((mng_backp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+INIT_CHUNK_HDR (mng_init_fram)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_FRAM, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_fram));
+  ((mng_framp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_FRAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MOVE
+INIT_CHUNK_HDR (mng_init_move)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MOVE, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_move));
+  ((mng_movep)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLIP
+INIT_CHUNK_HDR (mng_init_clip)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_CLIP, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_clip));
+  ((mng_clipp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SHOW
+INIT_CHUNK_HDR (mng_init_show)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SHOW, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_show));
+  ((mng_showp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_TERM
+INIT_CHUNK_HDR (mng_init_term)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TERM, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_term));
+  ((mng_termp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+INIT_CHUNK_HDR (mng_init_save)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SAVE, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_save));
+  ((mng_savep)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+INIT_CHUNK_HDR (mng_init_seek)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SEEK, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_seek));
+  ((mng_seekp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+INIT_CHUNK_HDR (mng_init_expi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_EXPI, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_expi));
+  ((mng_expip)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_EXPI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_fPRI
+INIT_CHUNK_HDR (mng_init_fpri)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_FPRI, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_fpri));
+  ((mng_fprip)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_FPRI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+INIT_CHUNK_HDR (mng_init_need)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_NEED, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_need));
+  ((mng_needp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_NEED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYg
+INIT_CHUNK_HDR (mng_init_phyg)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PHYG, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_phyg));
+  ((mng_phygp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PHYG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+INIT_CHUNK_HDR (mng_init_jhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JHDR, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_jhdr));
+  ((mng_jhdrp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+INIT_CHUNK_HDR (mng_init_jdaa)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JDAA, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_jdaa));
+  ((mng_jdaap)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JDAA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+INIT_CHUNK_HDR (mng_init_jdat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JDAT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_jdat));
+  ((mng_jdatp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+INIT_CHUNK_HDR (mng_init_jsep)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JSEP, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_jsep));
+  ((mng_jsepp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JSEP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+INIT_CHUNK_HDR (mng_init_dhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DHDR, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_dhdr));
+  ((mng_dhdrp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+INIT_CHUNK_HDR (mng_init_prom)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PROM, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_prom));
+  ((mng_promp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+INIT_CHUNK_HDR (mng_init_ipng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IPNG, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_ipng));
+  ((mng_ipngp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+INIT_CHUNK_HDR (mng_init_pplt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PPLT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_pplt));
+  ((mng_ppltp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+INIT_CHUNK_HDR (mng_init_ijng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IJNG, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_ijng));
+  ((mng_ijngp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+INIT_CHUNK_HDR (mng_init_drop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DROP, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_drop));
+  ((mng_dropp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DROP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+INIT_CHUNK_HDR (mng_init_dbyk)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DBYK, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_dbyk));
+  ((mng_dbykp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_DBYK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+INIT_CHUNK_HDR (mng_init_ordr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ORDR, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_ordr));
+  ((mng_ordrp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ORDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+INIT_CHUNK_HDR (mng_init_magn)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MAGN, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_magn));
+  ((mng_magnp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+INIT_CHUNK_HDR (mng_init_evnt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_EVNT, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_evnt));
+  ((mng_evntp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_EVNT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+INIT_CHUNK_HDR (mng_init_unknown)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_UNKNOWN, MNG_LC_START);
+#endif
+
+  MNG_ALLOC (pData, *ppChunk, sizeof (mng_unknown_chunk));
+  ((mng_unknown_chunkp)*ppChunk)->sHeader = *((mng_chunk_headerp)pHeader);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_UNKNOWN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_OPTIMIZE_CHUNKINITFREE */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Chunk specific cleanup routines                                        * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_general)
+{
+  MNG_FREEX (pData, pHeader, ((mng_chunk_headerp)pHeader)->iChunksize);
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_ihdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IHDR, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_ihdr));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_plte)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PLTE, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_plte));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+FREE_CHUNK_HDR (mng_free_idat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IDAT, MNG_LC_START);
+#endif
+
+  if (((mng_idatp)pHeader)->iDatasize)
+    MNG_FREEX (pData, ((mng_idatp)pHeader)->pData,
+                      ((mng_idatp)pHeader)->iDatasize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_idat));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IDAT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_iend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IEND, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_iend));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_trns)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TRNS, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_trns));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_gAMA
+FREE_CHUNK_HDR (mng_free_gama)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_GAMA, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_gama));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_cHRM
+FREE_CHUNK_HDR (mng_free_chrm)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_CHRM, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_chrm));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_sRGB
+FREE_CHUNK_HDR (mng_free_srgb)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SRGB, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_srgb));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+FREE_CHUNK_HDR (mng_free_iccp)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ICCP, MNG_LC_START);
+#endif
+
+  if (((mng_iccpp)pHeader)->iNamesize)
+    MNG_FREEX (pData, ((mng_iccpp)pHeader)->zName,
+                      ((mng_iccpp)pHeader)->iNamesize + 1);
+
+  if (((mng_iccpp)pHeader)->iProfilesize)
+    MNG_FREEX (pData, ((mng_iccpp)pHeader)->pProfile,
+                      ((mng_iccpp)pHeader)->iProfilesize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_iccp));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ICCP, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+FREE_CHUNK_HDR (mng_free_text)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TEXT, MNG_LC_START);
+#endif
+
+  if (((mng_textp)pHeader)->iKeywordsize)
+    MNG_FREEX (pData, ((mng_textp)pHeader)->zKeyword,
+                      ((mng_textp)pHeader)->iKeywordsize + 1);
+
+  if (((mng_textp)pHeader)->iTextsize)
+    MNG_FREEX (pData, ((mng_textp)pHeader)->zText,
+                      ((mng_textp)pHeader)->iTextsize + 1);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_text));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TEXT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+FREE_CHUNK_HDR (mng_free_ztxt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ZTXT, MNG_LC_START);
+#endif
+
+  if (((mng_ztxtp)pHeader)->iKeywordsize)
+    MNG_FREEX (pData, ((mng_ztxtp)pHeader)->zKeyword,
+                      ((mng_ztxtp)pHeader)->iKeywordsize + 1);
+
+  if (((mng_ztxtp)pHeader)->iTextsize)
+    MNG_FREEX (pData, ((mng_ztxtp)pHeader)->zText,
+                      ((mng_ztxtp)pHeader)->iTextsize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_ztxt));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ZTXT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+#ifndef MNG_SKIPCHUNK_iTXt
+FREE_CHUNK_HDR (mng_free_itxt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ITXT, MNG_LC_START);
+#endif
+
+  if (((mng_itxtp)pHeader)->iKeywordsize)
+    MNG_FREEX (pData, ((mng_itxtp)pHeader)->zKeyword,
+                      ((mng_itxtp)pHeader)->iKeywordsize + 1);
+
+  if (((mng_itxtp)pHeader)->iLanguagesize)
+    MNG_FREEX (pData, ((mng_itxtp)pHeader)->zLanguage,
+                      ((mng_itxtp)pHeader)->iLanguagesize + 1);
+
+  if (((mng_itxtp)pHeader)->iTranslationsize)
+    MNG_FREEX (pData, ((mng_itxtp)pHeader)->zTranslation,
+                      ((mng_itxtp)pHeader)->iTranslationsize + 1);
+
+  if (((mng_itxtp)pHeader)->iTextsize)
+    MNG_FREEX (pData, ((mng_itxtp)pHeader)->zText,
+                      ((mng_itxtp)pHeader)->iTextsize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_itxt));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ITXT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+FREE_CHUNK_HDR (mng_free_mpng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MPNG, MNG_LC_START);
+#endif
+
+  if (((mng_mpngp)pHeader)->iFramessize)
+    MNG_FREEX (pData, ((mng_mpngp)pHeader)->pFrames,
+                      ((mng_mpngp)pHeader)->iFramessize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_mpng));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MPNG, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+FREE_CHUNK_HDR (mng_free_adat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ADAT, MNG_LC_START);
+#endif
+
+  if (((mng_adatp)pHeader)->iTilessize)
+    MNG_FREEX (pData, ((mng_adatp)pHeader)->pTiles, ((mng_adatp)pHeader)->iTilessize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_adat));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ADAT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_bKGD
+FREE_CHUNK_HDR (mng_free_bkgd)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_BKGD, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_bkgd));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_pHYs
+FREE_CHUNK_HDR (mng_free_phys)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PHYS, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_phys));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PHYS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_sBIT
+FREE_CHUNK_HDR (mng_free_sbit)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SBIT, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_sbit));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SBIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+FREE_CHUNK_HDR (mng_free_splt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SPLT, MNG_LC_START);
+#endif
+
+  if (((mng_spltp)pHeader)->iNamesize)
+    MNG_FREEX (pData, ((mng_spltp)pHeader)->zName,
+                      ((mng_spltp)pHeader)->iNamesize + 1);
+
+  if (((mng_spltp)pHeader)->iEntrycount)
+    MNG_FREEX (pData, ((mng_spltp)pHeader)->pEntries,
+                      ((mng_spltp)pHeader)->iEntrycount *
+                      (((mng_spltp)pHeader)->iSampledepth * 3 + sizeof (mng_uint16)) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_splt));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SPLT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_hIST
+FREE_CHUNK_HDR (mng_free_hist)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_HIST, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_hist));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_HIST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_tIME
+FREE_CHUNK_HDR (mng_free_time)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TIME, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_time));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TIME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_mhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MHDR, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_mhdr));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_mend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MEND, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_mend));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+FREE_CHUNK_HDR (mng_free_loop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_LOOP, MNG_LC_START);
+#endif
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+  if (((mng_loopp)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_loopp)pHeader)->pSignals,
+                      ((mng_loopp)pHeader)->iCount * sizeof (mng_uint32) );
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_loop));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_LOOP, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_endl)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ENDL, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_endl));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_DEFI
+FREE_CHUNK_HDR (mng_free_defi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DEFI, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_defi));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_BASI
+FREE_CHUNK_HDR (mng_free_basi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_BASI, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_basi));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_CLON
+FREE_CHUNK_HDR (mng_free_clon)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_CLON, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_clon));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+FREE_CHUNK_HDR (mng_free_past)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PAST, MNG_LC_START);
+#endif
+
+  if (((mng_pastp)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_pastp)pHeader)->pSources,
+                      ((mng_pastp)pHeader)->iCount * sizeof (mng_past_source) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_past));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PAST, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+FREE_CHUNK_HDR (mng_free_disc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DISC, MNG_LC_START);
+#endif
+
+  if (((mng_discp)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_discp)pHeader)->pObjectids,
+                      ((mng_discp)pHeader)->iCount * sizeof (mng_uint16) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_disc));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DISC, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_BACK
+FREE_CHUNK_HDR (mng_free_back)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_BACK, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_back));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+FREE_CHUNK_HDR (mng_free_fram)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_FRAM, MNG_LC_START);
+#endif
+
+  if (((mng_framp)pHeader)->iNamesize)
+    MNG_FREEX (pData, ((mng_framp)pHeader)->zName,
+                      ((mng_framp)pHeader)->iNamesize + 1);
+
+  if (((mng_framp)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_framp)pHeader)->pSyncids,
+                      ((mng_framp)pHeader)->iCount * sizeof (mng_uint32) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_fram));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_FRAM, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_MOVE
+FREE_CHUNK_HDR (mng_free_move)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MOVE, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_move));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_CLIP
+FREE_CHUNK_HDR (mng_free_clip)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_CLIP, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_clip));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_SHOW
+FREE_CHUNK_HDR (mng_free_show)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SHOW, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_show));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_TERM
+FREE_CHUNK_HDR (mng_free_term)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TERM, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_term));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+FREE_CHUNK_HDR (mng_free_save)
+{
+  mng_save_entryp pEntry = ((mng_savep)pHeader)->pEntries;
+  mng_uint32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SAVE, MNG_LC_START);
+#endif
+
+  for (iX = 0; iX < ((mng_savep)pHeader)->iCount; iX++)
+  {
+    if (pEntry->iNamesize)
+      MNG_FREEX (pData, pEntry->zName, pEntry->iNamesize);
+
+    pEntry = pEntry + sizeof (mng_save_entry);
+  }
+
+  if (((mng_savep)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_savep)pHeader)->pEntries,
+                      ((mng_savep)pHeader)->iCount * sizeof (mng_save_entry) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_save));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SAVE, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+FREE_CHUNK_HDR (mng_free_seek)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SEEK, MNG_LC_START);
+#endif
+
+  if (((mng_seekp)pHeader)->iNamesize)
+    MNG_FREEX (pData, ((mng_seekp)pHeader)->zName,
+                      ((mng_seekp)pHeader)->iNamesize + 1);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_seek));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_SEEK, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+FREE_CHUNK_HDR (mng_free_expi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_EXPI, MNG_LC_START);
+#endif
+
+  if (((mng_expip)pHeader)->iNamesize)
+    MNG_FREEX (pData, ((mng_expip)pHeader)->zName,
+                      ((mng_expip)pHeader)->iNamesize + 1);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_expi));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_EXPI, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_fPRI
+FREE_CHUNK_HDR (mng_free_fpri)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_FPRI, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_fpri));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_FPRI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+FREE_CHUNK_HDR (mng_free_need)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_NEED, MNG_LC_START);
+#endif
+
+  if (((mng_needp)pHeader)->iKeywordssize)
+    MNG_FREEX (pData, ((mng_needp)pHeader)->zKeywords,
+                      ((mng_needp)pHeader)->iKeywordssize + 1);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_need));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_NEED, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_pHYg
+FREE_CHUNK_HDR (mng_free_phyg)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PHYG, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_phyg));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PHYG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_jhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JHDR, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_jhdr));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_jdaa)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JDAA, MNG_LC_START);
+#endif
+
+  if (((mng_jdaap)pHeader)->iDatasize)
+    MNG_FREEX (pData, ((mng_jdaap)pHeader)->pData,
+                      ((mng_jdaap)pHeader)->iDatasize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_jdaa));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JDAA, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_jdat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JDAT, MNG_LC_START);
+#endif
+
+  if (((mng_jdatp)pHeader)->iDatasize)
+    MNG_FREEX (pData, ((mng_jdatp)pHeader)->pData,
+                      ((mng_jdatp)pHeader)->iDatasize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_jdat));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JDAT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_jsep)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JSEP, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_jsep));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_JSEP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_NO_DELTA_PNG
+FREE_CHUNK_HDR (mng_free_dhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DHDR, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_dhdr));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_NO_DELTA_PNG
+FREE_CHUNK_HDR (mng_free_prom)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PROM, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_prom));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_NO_DELTA_PNG
+FREE_CHUNK_HDR (mng_free_ipng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IPNG, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_ipng));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_NO_DELTA_PNG
+FREE_CHUNK_HDR (mng_free_pplt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PPLT, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_pplt));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_ijng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IJNG, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_ijng));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+FREE_CHUNK_HDR (mng_free_drop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DROP, MNG_LC_START);
+#endif
+
+  if (((mng_dropp)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_dropp)pHeader)->pChunknames,
+                      ((mng_dropp)pHeader)->iCount * sizeof (mng_chunkid) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_drop));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DROP, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+FREE_CHUNK_HDR (mng_free_dbyk)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DBYK, MNG_LC_START);
+#endif
+
+  if (((mng_dbykp)pHeader)->iKeywordssize)
+    MNG_FREEX (pData, ((mng_dbykp)pHeader)->zKeywords,
+                      ((mng_dbykp)pHeader)->iKeywordssize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_dbyk));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_DBYK, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+FREE_CHUNK_HDR (mng_free_ordr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ORDR, MNG_LC_START);
+#endif
+
+  if (((mng_ordrp)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_ordrp)pHeader)->pEntries,
+                      ((mng_ordrp)pHeader)->iCount * sizeof (mng_ordr_entry) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_ordr));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ORDR, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+#ifndef MNG_SKIPCHUNK_MAGN
+FREE_CHUNK_HDR (mng_free_magn)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MAGN, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pHeader, sizeof (mng_magn));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+FREE_CHUNK_HDR (mng_free_evnt)
+{
+  mng_evnt_entryp pEntry = ((mng_evntp)pHeader)->pEntries;
+  mng_uint32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_EVNT, MNG_LC_START);
+#endif
+
+  for (iX = 0; iX < ((mng_evntp)pHeader)->iCount; iX++)
+  {
+    if (pEntry->iSegmentnamesize)
+      MNG_FREEX (pData, pEntry->zSegmentname, pEntry->iSegmentnamesize+1);
+
+    pEntry++;
+  }
+
+  if (((mng_evntp)pHeader)->iCount)
+    MNG_FREEX (pData, ((mng_evntp)pHeader)->pEntries,
+                      ((mng_evntp)pHeader)->iCount * sizeof (mng_evnt_entry) );
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_evnt));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_EVNT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+FREE_CHUNK_HDR (mng_free_unknown)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_UNKNOWN, MNG_LC_START);
+#endif
+
+  if (((mng_unknown_chunkp)pHeader)->iDatasize)
+    MNG_FREEX (pData, ((mng_unknown_chunkp)pHeader)->pData,
+                      ((mng_unknown_chunkp)pHeader)->iDatasize);
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  MNG_FREEX (pData, pHeader, sizeof (mng_unknown_chunk));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_UNKNOWN, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKINITFREE
+  return MNG_NOERROR;
+#else
+  return mng_free_general(pData, pHeader);
+#endif
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Chunk specific copy routines                                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_general)
+{
+  mng_ptr    pSrc = (mng_uint8p)pChunkfrom + sizeof (mng_chunk_header);
+  mng_ptr    pDst = (mng_uint8p)pChunkto   + sizeof (mng_chunk_header);
+  mng_size_t iLen = ((mng_chunk_headerp)pChunkfrom)->iChunksize - sizeof (mng_chunk_header);
+
+  MNG_COPY (pDst, pSrc, iLen);
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_ihdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IHDR, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_IHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_ihdrp)pChunkto)->iWidth       = ((mng_ihdrp)pChunkfrom)->iWidth;
+  ((mng_ihdrp)pChunkto)->iHeight      = ((mng_ihdrp)pChunkfrom)->iHeight;
+  ((mng_ihdrp)pChunkto)->iBitdepth    = ((mng_ihdrp)pChunkfrom)->iBitdepth;
+  ((mng_ihdrp)pChunkto)->iColortype   = ((mng_ihdrp)pChunkfrom)->iColortype;
+  ((mng_ihdrp)pChunkto)->iCompression = ((mng_ihdrp)pChunkfrom)->iCompression;
+  ((mng_ihdrp)pChunkto)->iFilter      = ((mng_ihdrp)pChunkfrom)->iFilter;
+  ((mng_ihdrp)pChunkto)->iInterlace   = ((mng_ihdrp)pChunkfrom)->iInterlace;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_plte)
+{
+  mng_uint32 iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PLTE, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_PLTE)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_pltep)pChunkto)->bEmpty      = ((mng_pltep)pChunkfrom)->bEmpty;
+  ((mng_pltep)pChunkto)->iEntrycount = ((mng_pltep)pChunkfrom)->iEntrycount;
+
+  for (iX = 0; iX < ((mng_pltep)pChunkto)->iEntrycount; iX++)
+    ((mng_pltep)pChunkto)->aEntries [iX] = ((mng_pltep)pChunkfrom)->aEntries [iX];
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+ASSIGN_CHUNK_HDR (mng_assign_idat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IDAT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_IDAT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_idatp)pChunkto)->bEmpty    = ((mng_idatp)pChunkfrom)->bEmpty;
+  ((mng_idatp)pChunkto)->iDatasize = ((mng_idatp)pChunkfrom)->iDatasize;
+
+  if (((mng_idatp)pChunkto)->iDatasize)
+  {
+    MNG_ALLOC (pData, ((mng_idatp)pChunkto)->pData, ((mng_idatp)pChunkto)->iDatasize);
+    MNG_COPY  (((mng_idatp)pChunkto)->pData, ((mng_idatp)pChunkfrom)->pData,
+               ((mng_idatp)pChunkto)->iDatasize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_iend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IEND, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_IEND)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_trns)
+{
+  mng_uint32 iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TRNS, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_tRNS)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_trnsp)pChunkto)->bEmpty  = ((mng_trnsp)pChunkfrom)->bEmpty;
+  ((mng_trnsp)pChunkto)->bGlobal = ((mng_trnsp)pChunkfrom)->bGlobal;
+  ((mng_trnsp)pChunkto)->iType   = ((mng_trnsp)pChunkfrom)->iType;
+  ((mng_trnsp)pChunkto)->iCount  = ((mng_trnsp)pChunkfrom)->iCount;
+  ((mng_trnsp)pChunkto)->iGray   = ((mng_trnsp)pChunkfrom)->iGray;
+  ((mng_trnsp)pChunkto)->iRed    = ((mng_trnsp)pChunkfrom)->iRed;
+  ((mng_trnsp)pChunkto)->iGreen  = ((mng_trnsp)pChunkfrom)->iGreen;
+  ((mng_trnsp)pChunkto)->iBlue   = ((mng_trnsp)pChunkfrom)->iBlue;
+  ((mng_trnsp)pChunkto)->iRawlen = ((mng_trnsp)pChunkfrom)->iRawlen;
+
+  for (iX = 0; iX < ((mng_trnsp)pChunkto)->iCount; iX++)
+    ((mng_trnsp)pChunkto)->aEntries [iX] = ((mng_trnsp)pChunkfrom)->aEntries [iX];
+
+  for (iX = 0; iX < ((mng_trnsp)pChunkto)->iRawlen; iX++)
+    ((mng_trnsp)pChunkto)->aRawdata [iX] = ((mng_trnsp)pChunkfrom)->aRawdata [iX];
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_gAMA
+ASSIGN_CHUNK_HDR (mng_assign_gama)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_GAMA, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_gAMA)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_gamap)pChunkto)->bEmpty = ((mng_gamap)pChunkfrom)->bEmpty;
+  ((mng_gamap)pChunkto)->iGamma = ((mng_gamap)pChunkfrom)->iGamma;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_cHRM
+ASSIGN_CHUNK_HDR (mng_assign_chrm)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_CHRM, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_cHRM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_chrmp)pChunkto)->bEmpty       = ((mng_chrmp)pChunkfrom)->bEmpty;
+  ((mng_chrmp)pChunkto)->iWhitepointx = ((mng_chrmp)pChunkfrom)->iWhitepointx;
+  ((mng_chrmp)pChunkto)->iWhitepointy = ((mng_chrmp)pChunkfrom)->iWhitepointy;
+  ((mng_chrmp)pChunkto)->iRedx        = ((mng_chrmp)pChunkfrom)->iRedx;
+  ((mng_chrmp)pChunkto)->iRedy        = ((mng_chrmp)pChunkfrom)->iRedy;
+  ((mng_chrmp)pChunkto)->iGreenx      = ((mng_chrmp)pChunkfrom)->iGreenx;
+  ((mng_chrmp)pChunkto)->iGreeny      = ((mng_chrmp)pChunkfrom)->iGreeny;
+  ((mng_chrmp)pChunkto)->iBluex       = ((mng_chrmp)pChunkfrom)->iBluex;
+  ((mng_chrmp)pChunkto)->iBluey       = ((mng_chrmp)pChunkfrom)->iBluey;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_sRGB
+ASSIGN_CHUNK_HDR (mng_assign_srgb)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SRGB, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_sRGB)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_srgbp)pChunkto)->iRenderingintent = ((mng_srgbp)pChunkfrom)->iRenderingintent;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+ASSIGN_CHUNK_HDR (mng_assign_iccp)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ICCP, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_iCCP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_iccpp)pChunkto)->bEmpty       = ((mng_iccpp)pChunkfrom)->bEmpty;
+  ((mng_iccpp)pChunkto)->iNamesize    = ((mng_iccpp)pChunkfrom)->iNamesize;
+  ((mng_iccpp)pChunkto)->iCompression = ((mng_iccpp)pChunkfrom)->iCompression;
+  ((mng_iccpp)pChunkto)->iProfilesize = ((mng_iccpp)pChunkfrom)->iProfilesize;
+
+  if (((mng_iccpp)pChunkto)->iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_iccpp)pChunkto)->zName, ((mng_iccpp)pChunkto)->iNamesize);
+    MNG_COPY  (((mng_iccpp)pChunkto)->zName, ((mng_iccpp)pChunkfrom)->zName,
+               ((mng_iccpp)pChunkto)->iNamesize);
+  }
+
+  if (((mng_iccpp)pChunkto)->iProfilesize)
+  {
+    MNG_ALLOC (pData, ((mng_iccpp)pChunkto)->pProfile, ((mng_iccpp)pChunkto)->iProfilesize);
+    MNG_COPY  (((mng_iccpp)pChunkto)->pProfile, ((mng_iccpp)pChunkfrom)->pProfile,
+               ((mng_iccpp)pChunkto)->iProfilesize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+ASSIGN_CHUNK_HDR (mng_assign_text)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TEXT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_tEXt)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_textp)pChunkto)->iKeywordsize = ((mng_textp)pChunkfrom)->iKeywordsize;
+  ((mng_textp)pChunkto)->iTextsize    = ((mng_textp)pChunkfrom)->iTextsize;
+
+  if (((mng_textp)pChunkto)->iKeywordsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunkto)->zKeyword, ((mng_textp)pChunkto)->iKeywordsize);
+    MNG_COPY  (((mng_itxtp)pChunkto)->zKeyword, ((mng_textp)pChunkfrom)->zKeyword,
+               ((mng_itxtp)pChunkto)->iKeywordsize);
+  }
+
+  if (((mng_textp)pChunkto)->iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_textp)pChunkto)->zText, ((mng_textp)pChunkto)->iTextsize);
+    MNG_COPY  (((mng_textp)pChunkto)->zText, ((mng_textp)pChunkfrom)->zText,
+               ((mng_textp)pChunkto)->iTextsize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TEXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+ASSIGN_CHUNK_HDR (mng_assign_ztxt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ZTXT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_zTXt)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_ztxtp)pChunkto)->iKeywordsize = ((mng_ztxtp)pChunkfrom)->iKeywordsize;
+  ((mng_ztxtp)pChunkto)->iCompression = ((mng_ztxtp)pChunkfrom)->iCompression;
+  ((mng_ztxtp)pChunkto)->iTextsize    = ((mng_ztxtp)pChunkfrom)->iTextsize;
+
+  if (((mng_ztxtp)pChunkto)->iKeywordsize)
+  {
+    MNG_ALLOC (pData, ((mng_ztxtp)pChunkto)->zKeyword, ((mng_ztxtp)pChunkto)->iKeywordsize);
+    MNG_COPY  (((mng_ztxtp)pChunkto)->zKeyword, ((mng_ztxtp)pChunkfrom)->zKeyword,
+               ((mng_ztxtp)pChunkto)->iKeywordsize);
+  }
+
+  if (((mng_ztxtp)pChunkto)->iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_ztxtp)pChunkto)->zText, ((mng_ztxtp)pChunkto)->iTextsize);
+    MNG_COPY  (((mng_ztxtp)pChunkto)->zText, ((mng_ztxtp)pChunkfrom)->zText,
+               ((mng_ztxtp)pChunkto)->iTextsize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ZTXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+ASSIGN_CHUNK_HDR (mng_assign_itxt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ITXT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_iTXt)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_itxtp)pChunkto)->iKeywordsize       = ((mng_itxtp)pChunkfrom)->iKeywordsize;
+  ((mng_itxtp)pChunkto)->iCompressionflag   = ((mng_itxtp)pChunkfrom)->iCompressionflag;
+  ((mng_itxtp)pChunkto)->iCompressionmethod = ((mng_itxtp)pChunkfrom)->iCompressionmethod;
+  ((mng_itxtp)pChunkto)->iLanguagesize      = ((mng_itxtp)pChunkfrom)->iLanguagesize;
+  ((mng_itxtp)pChunkto)->iTranslationsize   = ((mng_itxtp)pChunkfrom)->iTranslationsize;
+  ((mng_itxtp)pChunkto)->iTextsize          = ((mng_itxtp)pChunkfrom)->iTextsize;
+
+  if (((mng_itxtp)pChunkto)->iKeywordsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunkto)->zKeyword, ((mng_itxtp)pChunkto)->iKeywordsize);
+    MNG_COPY  (((mng_itxtp)pChunkto)->zKeyword, ((mng_itxtp)pChunkfrom)->zKeyword,
+               ((mng_itxtp)pChunkto)->iKeywordsize);
+  }
+
+  if (((mng_itxtp)pChunkto)->iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunkto)->zLanguage, ((mng_itxtp)pChunkto)->iLanguagesize);
+    MNG_COPY  (((mng_itxtp)pChunkto)->zLanguage, ((mng_itxtp)pChunkfrom)->zLanguage,
+               ((mng_itxtp)pChunkto)->iLanguagesize);
+  }
+
+  if (((mng_itxtp)pChunkto)->iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunkto)->zTranslation, ((mng_itxtp)pChunkto)->iTranslationsize);
+    MNG_COPY  (((mng_itxtp)pChunkto)->zTranslation, ((mng_itxtp)pChunkfrom)->zTranslation,
+               ((mng_itxtp)pChunkto)->iTranslationsize);
+  }
+
+  if (((mng_itxtp)pChunkto)->iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunkto)->zText, ((mng_itxtp)pChunkto)->iTextsize);
+    MNG_COPY  (((mng_itxtp)pChunkto)->zText, ((mng_itxtp)pChunkfrom)->zText,
+               ((mng_itxtp)pChunkto)->iTextsize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ITXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_bKGD
+ASSIGN_CHUNK_HDR (mng_assign_bkgd)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_BKGD, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_bKGD)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_bkgdp)pChunkto)->bEmpty = ((mng_bkgdp)pChunkfrom)->bEmpty;
+  ((mng_bkgdp)pChunkto)->iType  = ((mng_bkgdp)pChunkfrom)->iType;
+  ((mng_bkgdp)pChunkto)->iIndex = ((mng_bkgdp)pChunkfrom)->iIndex;
+  ((mng_bkgdp)pChunkto)->iGray  = ((mng_bkgdp)pChunkfrom)->iGray;
+  ((mng_bkgdp)pChunkto)->iRed   = ((mng_bkgdp)pChunkfrom)->iRed;
+  ((mng_bkgdp)pChunkto)->iGreen = ((mng_bkgdp)pChunkfrom)->iGreen;
+  ((mng_bkgdp)pChunkto)->iBlue  = ((mng_bkgdp)pChunkfrom)->iBlue;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_pHYs
+ASSIGN_CHUNK_HDR (mng_assign_phys)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PHYS, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_pHYs)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_physp)pChunkto)->bEmpty = ((mng_physp)pChunkfrom)->bEmpty;
+  ((mng_physp)pChunkto)->iSizex = ((mng_physp)pChunkfrom)->iSizex;
+  ((mng_physp)pChunkto)->iSizey = ((mng_physp)pChunkfrom)->iSizey;
+  ((mng_physp)pChunkto)->iUnit  = ((mng_physp)pChunkfrom)->iUnit;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PHYS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_sBIT
+ASSIGN_CHUNK_HDR (mng_assign_sbit)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SBIT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_sBIT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_sbitp)pChunkto)->bEmpty    = ((mng_sbitp)pChunkfrom)->bEmpty;
+  ((mng_sbitp)pChunkto)->iType     = ((mng_sbitp)pChunkfrom)->iType;
+  ((mng_sbitp)pChunkto)->aBits [0] = ((mng_sbitp)pChunkfrom)->aBits [0];
+  ((mng_sbitp)pChunkto)->aBits [1] = ((mng_sbitp)pChunkfrom)->aBits [1];
+  ((mng_sbitp)pChunkto)->aBits [2] = ((mng_sbitp)pChunkfrom)->aBits [2];
+  ((mng_sbitp)pChunkto)->aBits [3] = ((mng_sbitp)pChunkfrom)->aBits [3];
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SBIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+ASSIGN_CHUNK_HDR (mng_assign_splt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SPLT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_sPLT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_spltp)pChunkto)->bEmpty       = ((mng_spltp)pChunkfrom)->bEmpty;
+  ((mng_spltp)pChunkto)->iNamesize    = ((mng_spltp)pChunkfrom)->iNamesize;
+  ((mng_spltp)pChunkto)->iSampledepth = ((mng_spltp)pChunkfrom)->iSampledepth;
+  ((mng_spltp)pChunkto)->iEntrycount  = ((mng_spltp)pChunkfrom)->iEntrycount;
+  ((mng_spltp)pChunkto)->pEntries     = ((mng_spltp)pChunkfrom)->pEntries;
+
+  if (((mng_spltp)pChunkto)->iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_spltp)pChunkto)->zName, ((mng_spltp)pChunkto)->iNamesize);
+    MNG_COPY  (((mng_spltp)pChunkto)->zName, ((mng_spltp)pChunkfrom)->zName,
+               ((mng_spltp)pChunkto)->iNamesize);
+  }
+
+  if (((mng_spltp)pChunkto)->iEntrycount)
+  {
+    mng_uint32 iLen = ((mng_spltp)pChunkto)->iEntrycount *
+                      (((mng_spltp)pChunkto)->iSampledepth * 3 + sizeof (mng_uint16));
+
+    MNG_ALLOC (pData, ((mng_spltp)pChunkto)->pEntries, iLen);
+    MNG_COPY  (((mng_spltp)pChunkto)->pEntries, ((mng_spltp)pChunkfrom)->pEntries, iLen);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_hIST
+ASSIGN_CHUNK_HDR (mng_assign_hist)
+{
+  mng_uint32 iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_HIST, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_hIST)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_histp)pChunkto)->iEntrycount = ((mng_histp)pChunkfrom)->iEntrycount;
+
+  for (iX = 0; iX < ((mng_histp)pChunkto)->iEntrycount; iX++)
+    ((mng_histp)pChunkto)->aEntries [iX] = ((mng_histp)pChunkfrom)->aEntries [iX];
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_HIST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_tIME
+ASSIGN_CHUNK_HDR (mng_assign_time)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TIME, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_tIME)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_timep)pChunkto)->iYear   = ((mng_timep)pChunkfrom)->iYear;
+  ((mng_timep)pChunkto)->iMonth  = ((mng_timep)pChunkfrom)->iMonth;
+  ((mng_timep)pChunkto)->iDay    = ((mng_timep)pChunkfrom)->iDay;
+  ((mng_timep)pChunkto)->iHour   = ((mng_timep)pChunkfrom)->iHour;
+  ((mng_timep)pChunkto)->iMinute = ((mng_timep)pChunkfrom)->iMinute;
+  ((mng_timep)pChunkto)->iSecond = ((mng_timep)pChunkfrom)->iSecond;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TIME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_mhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MHDR, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_mhdrp)pChunkto)->iWidth      = ((mng_mhdrp)pChunkfrom)->iWidth;
+  ((mng_mhdrp)pChunkto)->iHeight     = ((mng_mhdrp)pChunkfrom)->iHeight;
+  ((mng_mhdrp)pChunkto)->iTicks      = ((mng_mhdrp)pChunkfrom)->iTicks;
+  ((mng_mhdrp)pChunkto)->iLayercount = ((mng_mhdrp)pChunkfrom)->iLayercount;
+  ((mng_mhdrp)pChunkto)->iFramecount = ((mng_mhdrp)pChunkfrom)->iFramecount;
+  ((mng_mhdrp)pChunkto)->iPlaytime   = ((mng_mhdrp)pChunkfrom)->iPlaytime;
+  ((mng_mhdrp)pChunkto)->iSimplicity = ((mng_mhdrp)pChunkfrom)->iSimplicity;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_mend)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MEND, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_MEND)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+ASSIGN_CHUNK_HDR (mng_assign_loop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_LOOP, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_LOOP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_loopp)pChunkto)->iLevel       = ((mng_loopp)pChunkfrom)->iLevel;
+  ((mng_loopp)pChunkto)->iRepeat      = ((mng_loopp)pChunkfrom)->iRepeat;
+  ((mng_loopp)pChunkto)->iTermination = ((mng_loopp)pChunkfrom)->iTermination;
+  ((mng_loopp)pChunkto)->iItermin     = ((mng_loopp)pChunkfrom)->iItermin;
+  ((mng_loopp)pChunkto)->iItermax     = ((mng_loopp)pChunkfrom)->iItermax;
+  ((mng_loopp)pChunkto)->iCount       = ((mng_loopp)pChunkfrom)->iCount;
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+  if (((mng_loopp)pChunkto)->iCount)
+  {
+    mng_uint32 iLen = ((mng_loopp)pChunkto)->iCount * sizeof (mng_uint32);
+    MNG_ALLOC (pData, ((mng_loopp)pChunkto)->pSignals, iLen);
+    MNG_COPY  (((mng_loopp)pChunkto)->pSignals, ((mng_loopp)pChunkfrom)->pSignals, iLen);
+  }
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_LOOP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_endl)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ENDL, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_ENDL)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_endlp)pChunkto)->iLevel = ((mng_endlp)pChunkfrom)->iLevel;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_DEFI
+ASSIGN_CHUNK_HDR (mng_assign_defi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DEFI, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_DEFI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_defip)pChunkto)->iObjectid     = ((mng_defip)pChunkfrom)->iObjectid;
+  ((mng_defip)pChunkto)->bHasdonotshow = ((mng_defip)pChunkfrom)->bHasdonotshow;
+  ((mng_defip)pChunkto)->iDonotshow    = ((mng_defip)pChunkfrom)->iDonotshow;
+  ((mng_defip)pChunkto)->bHasconcrete  = ((mng_defip)pChunkfrom)->bHasconcrete;
+  ((mng_defip)pChunkto)->iConcrete     = ((mng_defip)pChunkfrom)->iConcrete;
+  ((mng_defip)pChunkto)->bHasloca      = ((mng_defip)pChunkfrom)->bHasloca;
+  ((mng_defip)pChunkto)->iXlocation    = ((mng_defip)pChunkfrom)->iXlocation;
+  ((mng_defip)pChunkto)->iYlocation    = ((mng_defip)pChunkfrom)->iYlocation;
+  ((mng_defip)pChunkto)->bHasclip      = ((mng_defip)pChunkfrom)->bHasclip;
+  ((mng_defip)pChunkto)->iLeftcb       = ((mng_defip)pChunkfrom)->iLeftcb;
+  ((mng_defip)pChunkto)->iRightcb      = ((mng_defip)pChunkfrom)->iRightcb;
+  ((mng_defip)pChunkto)->iTopcb        = ((mng_defip)pChunkfrom)->iTopcb;
+  ((mng_defip)pChunkto)->iBottomcb     = ((mng_defip)pChunkfrom)->iBottomcb;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_BASI
+ASSIGN_CHUNK_HDR (mng_assign_basi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_BASI, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_BASI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_basip)pChunkto)->iWidth       = ((mng_basip)pChunkfrom)->iWidth;
+  ((mng_basip)pChunkto)->iHeight      = ((mng_basip)pChunkfrom)->iHeight;
+  ((mng_basip)pChunkto)->iBitdepth    = ((mng_basip)pChunkfrom)->iBitdepth;
+  ((mng_basip)pChunkto)->iColortype   = ((mng_basip)pChunkfrom)->iColortype;
+  ((mng_basip)pChunkto)->iCompression = ((mng_basip)pChunkfrom)->iCompression;
+  ((mng_basip)pChunkto)->iFilter      = ((mng_basip)pChunkfrom)->iFilter;
+  ((mng_basip)pChunkto)->iInterlace   = ((mng_basip)pChunkfrom)->iInterlace;
+  ((mng_basip)pChunkto)->iRed         = ((mng_basip)pChunkfrom)->iRed;
+  ((mng_basip)pChunkto)->iGreen       = ((mng_basip)pChunkfrom)->iGreen;
+  ((mng_basip)pChunkto)->iBlue        = ((mng_basip)pChunkfrom)->iBlue;
+  ((mng_basip)pChunkto)->iAlpha       = ((mng_basip)pChunkfrom)->iAlpha;
+  ((mng_basip)pChunkto)->iViewable    = ((mng_basip)pChunkfrom)->iViewable;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_CLON
+ASSIGN_CHUNK_HDR (mng_assign_clon)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_CLON, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_CLON)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_clonp)pChunkto)->iSourceid     = ((mng_clonp)pChunkfrom)->iSourceid;
+  ((mng_clonp)pChunkto)->iCloneid      = ((mng_clonp)pChunkfrom)->iCloneid;
+  ((mng_clonp)pChunkto)->iClonetype    = ((mng_clonp)pChunkfrom)->iClonetype;
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+  ((mng_clonp)pChunkto)->bHasdonotshow = ((mng_clonp)pChunkfrom)->bHasdonotshow;
+#endif
+  ((mng_clonp)pChunkto)->iDonotshow    = ((mng_clonp)pChunkfrom)->iDonotshow;
+  ((mng_clonp)pChunkto)->iConcrete     = ((mng_clonp)pChunkfrom)->iConcrete;
+  ((mng_clonp)pChunkto)->bHasloca      = ((mng_clonp)pChunkfrom)->bHasloca;
+  ((mng_clonp)pChunkto)->iLocationtype = ((mng_clonp)pChunkfrom)->iLocationtype;
+  ((mng_clonp)pChunkto)->iLocationx    = ((mng_clonp)pChunkfrom)->iLocationx;
+  ((mng_clonp)pChunkto)->iLocationy    = ((mng_clonp)pChunkfrom)->iLocationy;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+ASSIGN_CHUNK_HDR (mng_assign_past)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PAST, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_PAST)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_pastp)pChunkto)->iDestid     = ((mng_pastp)pChunkfrom)->iDestid;
+  ((mng_pastp)pChunkto)->iTargettype = ((mng_pastp)pChunkfrom)->iTargettype;
+  ((mng_pastp)pChunkto)->iTargetx    = ((mng_pastp)pChunkfrom)->iTargetx;
+  ((mng_pastp)pChunkto)->iTargety    = ((mng_pastp)pChunkfrom)->iTargety;
+  ((mng_pastp)pChunkto)->iCount      = ((mng_pastp)pChunkfrom)->iCount;
+
+  if (((mng_pastp)pChunkto)->iCount)
+  {
+    mng_uint32 iLen = ((mng_pastp)pChunkto)->iCount * sizeof (mng_past_source);
+
+    MNG_ALLOC (pData, ((mng_pastp)pChunkto)->pSources, iLen);
+    MNG_COPY  (((mng_pastp)pChunkto)->pSources, ((mng_pastp)pChunkfrom)->pSources, iLen);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PAST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+ASSIGN_CHUNK_HDR (mng_assign_disc)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DISC, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_DISC)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_discp)pChunkto)->iCount = ((mng_discp)pChunkfrom)->iCount;
+
+  if (((mng_discp)pChunkto)->iCount)
+  {
+    mng_uint32 iLen = ((mng_discp)pChunkto)->iCount * sizeof (mng_uint16);
+
+    MNG_ALLOC (pData, ((mng_discp)pChunkto)->pObjectids, iLen);
+    MNG_COPY  (((mng_discp)pChunkto)->pObjectids, ((mng_discp)pChunkfrom)->pObjectids, iLen);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DISC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_BACK
+ASSIGN_CHUNK_HDR (mng_assign_back)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_BACK, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_BACK)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_backp)pChunkto)->iRed       = ((mng_backp)pChunkfrom)->iRed;
+  ((mng_backp)pChunkto)->iGreen     = ((mng_backp)pChunkfrom)->iGreen;
+  ((mng_backp)pChunkto)->iBlue      = ((mng_backp)pChunkfrom)->iBlue;
+  ((mng_backp)pChunkto)->iMandatory = ((mng_backp)pChunkfrom)->iMandatory;
+  ((mng_backp)pChunkto)->iImageid   = ((mng_backp)pChunkfrom)->iImageid;
+  ((mng_backp)pChunkto)->iTile      = ((mng_backp)pChunkfrom)->iTile;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+ASSIGN_CHUNK_HDR (mng_assign_fram)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_FRAM, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_FRAM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_framp)pChunkto)->bEmpty          = ((mng_framp)pChunkfrom)->bEmpty;
+  ((mng_framp)pChunkto)->iMode           = ((mng_framp)pChunkfrom)->iMode;
+  ((mng_framp)pChunkto)->iNamesize       = ((mng_framp)pChunkfrom)->iNamesize;
+  ((mng_framp)pChunkto)->iChangedelay    = ((mng_framp)pChunkfrom)->iChangedelay;
+  ((mng_framp)pChunkto)->iChangetimeout  = ((mng_framp)pChunkfrom)->iChangetimeout;
+  ((mng_framp)pChunkto)->iChangeclipping = ((mng_framp)pChunkfrom)->iChangeclipping;
+  ((mng_framp)pChunkto)->iChangesyncid   = ((mng_framp)pChunkfrom)->iChangesyncid;
+  ((mng_framp)pChunkto)->iDelay          = ((mng_framp)pChunkfrom)->iDelay;
+  ((mng_framp)pChunkto)->iTimeout        = ((mng_framp)pChunkfrom)->iTimeout;
+  ((mng_framp)pChunkto)->iBoundarytype   = ((mng_framp)pChunkfrom)->iBoundarytype;
+  ((mng_framp)pChunkto)->iBoundaryl      = ((mng_framp)pChunkfrom)->iBoundaryl;
+  ((mng_framp)pChunkto)->iBoundaryr      = ((mng_framp)pChunkfrom)->iBoundaryr;
+  ((mng_framp)pChunkto)->iBoundaryt      = ((mng_framp)pChunkfrom)->iBoundaryt;
+  ((mng_framp)pChunkto)->iBoundaryb      = ((mng_framp)pChunkfrom)->iBoundaryb;
+  ((mng_framp)pChunkto)->iCount          = ((mng_framp)pChunkfrom)->iCount;
+
+  if (((mng_framp)pChunkto)->iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_framp)pChunkto)->zName, ((mng_framp)pChunkto)->iNamesize);
+    MNG_COPY  (((mng_framp)pChunkto)->zName, ((mng_framp)pChunkfrom)->zName,
+               ((mng_framp)pChunkto)->iNamesize);
+  }
+
+  if (((mng_framp)pChunkto)->iCount)
+  {
+    mng_uint32 iLen = ((mng_framp)pChunkto)->iCount * sizeof (mng_uint32);
+
+    MNG_ALLOC (pData, ((mng_framp)pChunkto)->pSyncids, iLen);
+    MNG_COPY  (((mng_framp)pChunkto)->pSyncids, ((mng_framp)pChunkfrom)->pSyncids, iLen);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_FRAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_MOVE
+ASSIGN_CHUNK_HDR (mng_assign_move)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MOVE, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_MOVE)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_movep)pChunkto)->iFirstid  = ((mng_movep)pChunkfrom)->iFirstid;
+  ((mng_movep)pChunkto)->iLastid   = ((mng_movep)pChunkfrom)->iLastid;
+  ((mng_movep)pChunkto)->iMovetype = ((mng_movep)pChunkfrom)->iMovetype;
+  ((mng_movep)pChunkto)->iMovex    = ((mng_movep)pChunkfrom)->iMovex;
+  ((mng_movep)pChunkto)->iMovey    = ((mng_movep)pChunkfrom)->iMovey;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_CLIP
+ASSIGN_CHUNK_HDR (mng_assign_clip)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_CLIP, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_CLIP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_clipp)pChunkto)->iFirstid  = ((mng_clipp)pChunkfrom)->iFirstid;
+  ((mng_clipp)pChunkto)->iLastid   = ((mng_clipp)pChunkfrom)->iLastid;
+  ((mng_clipp)pChunkto)->iCliptype = ((mng_clipp)pChunkfrom)->iCliptype;
+  ((mng_clipp)pChunkto)->iClipl    = ((mng_clipp)pChunkfrom)->iClipl;
+  ((mng_clipp)pChunkto)->iClipr    = ((mng_clipp)pChunkfrom)->iClipr;
+  ((mng_clipp)pChunkto)->iClipt    = ((mng_clipp)pChunkfrom)->iClipt;
+  ((mng_clipp)pChunkto)->iClipb    = ((mng_clipp)pChunkfrom)->iClipb;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_SHOW
+ASSIGN_CHUNK_HDR (mng_assign_show)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SHOW, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_SHOW)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_showp)pChunkto)->bEmpty   = ((mng_showp)pChunkfrom)->bEmpty;
+  ((mng_showp)pChunkto)->iFirstid = ((mng_showp)pChunkfrom)->iFirstid;
+  ((mng_showp)pChunkto)->iLastid  = ((mng_showp)pChunkfrom)->iLastid;
+  ((mng_showp)pChunkto)->iMode    = ((mng_showp)pChunkfrom)->iMode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_TERM
+ASSIGN_CHUNK_HDR (mng_assign_term)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TERM, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_TERM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_termp)pChunkto)->iTermaction = ((mng_termp)pChunkfrom)->iTermaction;
+  ((mng_termp)pChunkto)->iIteraction = ((mng_termp)pChunkfrom)->iIteraction;
+  ((mng_termp)pChunkto)->iDelay      = ((mng_termp)pChunkfrom)->iDelay;
+  ((mng_termp)pChunkto)->iItermax    = ((mng_termp)pChunkfrom)->iItermax;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+ASSIGN_CHUNK_HDR (mng_assign_save)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SAVE, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_SAVE)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_savep)pChunkto)->bEmpty      = ((mng_savep)pChunkfrom)->bEmpty;
+  ((mng_savep)pChunkto)->iOffsettype = ((mng_savep)pChunkfrom)->iOffsettype;
+  ((mng_savep)pChunkto)->iCount      = ((mng_savep)pChunkfrom)->iCount;
+
+  if (((mng_savep)pChunkto)->iCount)
+  {
+    mng_uint32      iX;
+    mng_save_entryp pEntry;
+    mng_uint32      iLen = ((mng_savep)pChunkto)->iCount * sizeof (mng_save_entry);
+
+    MNG_ALLOC (pData, ((mng_savep)pChunkto)->pEntries, iLen);
+    MNG_COPY  (((mng_savep)pChunkto)->pEntries, ((mng_savep)pChunkfrom)->pEntries, iLen);
+
+    pEntry = ((mng_savep)pChunkto)->pEntries;
+
+    for (iX = 0; iX < ((mng_savep)pChunkto)->iCount; iX++)
+    {
+      if (pEntry->iNamesize)
+      {
+        mng_pchar pTemp = pEntry->zName;
+
+        MNG_ALLOC (pData, pEntry->zName, pEntry->iNamesize);
+        MNG_COPY  (pEntry->zName, pTemp, pEntry->iNamesize);
+      }
+      else
+      {
+        pEntry->zName = MNG_NULL;
+      }
+
+      pEntry++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+ASSIGN_CHUNK_HDR (mng_assign_seek)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SEEK, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_SEEK)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_seekp)pChunkto)->iNamesize = ((mng_seekp)pChunkfrom)->iNamesize;
+
+  if (((mng_seekp)pChunkto)->iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_seekp)pChunkto)->zName, ((mng_seekp)pChunkto)->iNamesize);
+    MNG_COPY  (((mng_seekp)pChunkto)->zName, ((mng_seekp)pChunkfrom)->zName,
+               ((mng_seekp)pChunkto)->iNamesize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+ASSIGN_CHUNK_HDR (mng_assign_expi)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_EXPI, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_eXPI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_expip)pChunkto)->iSnapshotid = ((mng_expip)pChunkfrom)->iSnapshotid;
+  ((mng_expip)pChunkto)->iNamesize   = ((mng_expip)pChunkfrom)->iNamesize;
+
+  if (((mng_expip)pChunkto)->iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_expip)pChunkto)->zName, ((mng_expip)pChunkto)->iNamesize);
+    MNG_COPY  (((mng_expip)pChunkto)->zName, ((mng_expip)pChunkfrom)->zName,
+               ((mng_expip)pChunkto)->iNamesize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_EXPI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_fPRI
+ASSIGN_CHUNK_HDR (mng_assign_fpri)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_FPRI, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_fPRI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_fprip)pChunkto)->iDeltatype = ((mng_fprip)pChunkfrom)->iDeltatype;
+  ((mng_fprip)pChunkto)->iPriority  = ((mng_fprip)pChunkfrom)->iPriority;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_FPRI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+ASSIGN_CHUNK_HDR (mng_assign_need)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_NEED, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_nEED)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_needp)pChunkto)->iKeywordssize = ((mng_needp)pChunkfrom)->iKeywordssize;
+
+  if (((mng_needp)pChunkto)->iKeywordssize)
+  {
+    MNG_ALLOC (pData, ((mng_needp)pChunkto)->zKeywords, ((mng_needp)pChunkto)->iKeywordssize);
+    MNG_COPY  (((mng_needp)pChunkto)->zKeywords, ((mng_needp)pChunkfrom)->zKeywords,
+               ((mng_needp)pChunkto)->iKeywordssize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_NEED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_pHYg
+ASSIGN_CHUNK_HDR (mng_assign_phyg)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PHYG, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_pHYg)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_phygp)pChunkto)->bEmpty = ((mng_phygp)pChunkfrom)->bEmpty;
+  ((mng_phygp)pChunkto)->iSizex = ((mng_phygp)pChunkfrom)->iSizex;
+  ((mng_phygp)pChunkto)->iSizey = ((mng_phygp)pChunkfrom)->iSizey;
+  ((mng_phygp)pChunkto)->iUnit  = ((mng_phygp)pChunkfrom)->iUnit;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PHYG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_jhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JHDR, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_JHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_jhdrp)pChunkto)->iWidth            = ((mng_jhdrp)pChunkfrom)->iWidth;
+  ((mng_jhdrp)pChunkto)->iHeight           = ((mng_jhdrp)pChunkfrom)->iHeight;
+  ((mng_jhdrp)pChunkto)->iColortype        = ((mng_jhdrp)pChunkfrom)->iColortype;
+  ((mng_jhdrp)pChunkto)->iImagesampledepth = ((mng_jhdrp)pChunkfrom)->iImagesampledepth;
+  ((mng_jhdrp)pChunkto)->iImagecompression = ((mng_jhdrp)pChunkfrom)->iImagecompression;
+  ((mng_jhdrp)pChunkto)->iImageinterlace   = ((mng_jhdrp)pChunkfrom)->iImageinterlace;
+  ((mng_jhdrp)pChunkto)->iAlphasampledepth = ((mng_jhdrp)pChunkfrom)->iAlphasampledepth;
+  ((mng_jhdrp)pChunkto)->iAlphacompression = ((mng_jhdrp)pChunkfrom)->iAlphacompression;
+  ((mng_jhdrp)pChunkto)->iAlphafilter      = ((mng_jhdrp)pChunkfrom)->iAlphafilter;
+  ((mng_jhdrp)pChunkto)->iAlphainterlace   = ((mng_jhdrp)pChunkfrom)->iAlphainterlace;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_jdaa)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JDAA, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_JDAA)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_jdaap)pChunkto)->bEmpty    = ((mng_jdaap)pChunkfrom)->bEmpty;
+  ((mng_jdaap)pChunkto)->iDatasize = ((mng_jdaap)pChunkfrom)->iDatasize;
+
+  if (((mng_jdaap)pChunkto)->iDatasize)
+  {
+    MNG_ALLOC (pData, ((mng_jdaap)pChunkto)->pData, ((mng_jdaap)pChunkto)->iDatasize);
+    MNG_COPY  (((mng_jdaap)pChunkto)->pData, ((mng_jdaap)pChunkfrom)->pData,
+               ((mng_jdaap)pChunkto)->iDatasize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JDAA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_jdat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JDAT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_JDAT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_jdatp)pChunkto)->bEmpty    = ((mng_jdatp)pChunkfrom)->bEmpty;
+  ((mng_jdatp)pChunkto)->iDatasize = ((mng_jdatp)pChunkfrom)->iDatasize;
+
+  if (((mng_jdatp)pChunkto)->iDatasize)
+  {
+    MNG_ALLOC (pData, ((mng_jdatp)pChunkto)->pData, ((mng_jdatp)pChunkto)->iDatasize);
+    MNG_COPY  (((mng_jdatp)pChunkto)->pData, ((mng_jdatp)pChunkfrom)->pData,
+               ((mng_jdatp)pChunkto)->iDatasize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_jsep)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JSEP, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_JSEP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_JSEP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_NO_DELTA_PNG
+ASSIGN_CHUNK_HDR (mng_assign_dhdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DHDR, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_DHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_dhdrp)pChunkto)->iObjectid    = ((mng_dhdrp)pChunkfrom)->iObjectid;
+  ((mng_dhdrp)pChunkto)->iImagetype   = ((mng_dhdrp)pChunkfrom)->iImagetype;
+  ((mng_dhdrp)pChunkto)->iDeltatype   = ((mng_dhdrp)pChunkfrom)->iDeltatype;
+  ((mng_dhdrp)pChunkto)->iBlockwidth  = ((mng_dhdrp)pChunkfrom)->iBlockwidth;
+  ((mng_dhdrp)pChunkto)->iBlockheight = ((mng_dhdrp)pChunkfrom)->iBlockheight;
+  ((mng_dhdrp)pChunkto)->iBlockx      = ((mng_dhdrp)pChunkfrom)->iBlockx;
+  ((mng_dhdrp)pChunkto)->iBlocky      = ((mng_dhdrp)pChunkfrom)->iBlocky;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_NO_DELTA_PNG
+ASSIGN_CHUNK_HDR (mng_assign_prom)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PROM, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_PROM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_promp)pChunkto)->iColortype   = ((mng_promp)pChunkfrom)->iColortype;
+  ((mng_promp)pChunkto)->iSampledepth = ((mng_promp)pChunkfrom)->iSampledepth;
+  ((mng_promp)pChunkto)->iFilltype    = ((mng_promp)pChunkfrom)->iFilltype;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_NO_DELTA_PNG
+ASSIGN_CHUNK_HDR (mng_assign_ipng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IPNG, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_IPNG)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_NO_DELTA_PNG
+ASSIGN_CHUNK_HDR (mng_assign_pplt)
+{
+  mng_uint32 iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PPLT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_PPLT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_ppltp)pChunkto)->iDeltatype = ((mng_ppltp)pChunkfrom)->iDeltatype;
+  ((mng_ppltp)pChunkto)->iCount     = ((mng_ppltp)pChunkfrom)->iCount;
+
+  for (iX = 0; iX < ((mng_ppltp)pChunkto)->iCount; iX++)
+    ((mng_ppltp)pChunkto)->aEntries [iX] = ((mng_ppltp)pChunkfrom)->aEntries [iX];
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_ijng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IJNG, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_IJNG)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+ASSIGN_CHUNK_HDR (mng_assign_drop)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DROP, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_DROP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_dropp)pChunkto)->iCount = ((mng_dropp)pChunkfrom)->iCount;
+
+  if (((mng_dropp)pChunkto)->iCount)
+  {
+    mng_uint32 iLen = ((mng_dropp)pChunkto)->iCount * sizeof (mng_uint32);
+
+    MNG_ALLOC (pData, ((mng_dropp)pChunkto)->pChunknames, iLen);
+    MNG_COPY  (((mng_dropp)pChunkto)->pChunknames, ((mng_dropp)pChunkfrom)->pChunknames, iLen);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DROP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+ASSIGN_CHUNK_HDR (mng_assign_dbyk)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DBYK, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_DBYK)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_dbykp)pChunkto)->iChunkname    = ((mng_dbykp)pChunkfrom)->iChunkname;
+  ((mng_dbykp)pChunkto)->iPolarity     = ((mng_dbykp)pChunkfrom)->iPolarity;
+  ((mng_dbykp)pChunkto)->iKeywordssize = ((mng_dbykp)pChunkfrom)->iKeywordssize;
+
+  if (((mng_dbykp)pChunkto)->iKeywordssize)
+  {
+    MNG_ALLOC (pData, ((mng_dbykp)pChunkto)->zKeywords, ((mng_dbykp)pChunkto)->iKeywordssize);
+    MNG_COPY  (((mng_dbykp)pChunkto)->zKeywords, ((mng_dbykp)pChunkfrom)->zKeywords,
+               ((mng_dbykp)pChunkto)->iKeywordssize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_DBYK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+ASSIGN_CHUNK_HDR (mng_assign_ordr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ORDR, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_ORDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_ordrp)pChunkto)->iCount = ((mng_ordrp)pChunkfrom)->iCount;
+
+  if (((mng_ordrp)pChunkto)->iCount)
+  {
+    mng_uint32 iLen = ((mng_ordrp)pChunkto)->iCount * sizeof (mng_ordr_entry);
+
+    MNG_ALLOC (pData, ((mng_ordrp)pChunkto)->pEntries, iLen);
+    MNG_COPY  (((mng_ordrp)pChunkto)->pEntries, ((mng_ordrp)pChunkfrom)->pEntries, iLen);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ORDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKASSIGN
+#ifndef MNG_SKIPCHUNK_MAGN
+ASSIGN_CHUNK_HDR (mng_assign_magn)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MAGN, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_MAGN)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_magnp)pChunkto)->iFirstid = ((mng_magnp)pChunkfrom)->iFirstid;
+  ((mng_magnp)pChunkto)->iLastid  = ((mng_magnp)pChunkfrom)->iLastid;
+  ((mng_magnp)pChunkto)->iMethodX = ((mng_magnp)pChunkfrom)->iMethodX;
+  ((mng_magnp)pChunkto)->iMX      = ((mng_magnp)pChunkfrom)->iMX;
+  ((mng_magnp)pChunkto)->iMY      = ((mng_magnp)pChunkfrom)->iMY;
+  ((mng_magnp)pChunkto)->iML      = ((mng_magnp)pChunkfrom)->iML;
+  ((mng_magnp)pChunkto)->iMR      = ((mng_magnp)pChunkfrom)->iMR;
+  ((mng_magnp)pChunkto)->iMT      = ((mng_magnp)pChunkfrom)->iMT;
+  ((mng_magnp)pChunkto)->iMB      = ((mng_magnp)pChunkfrom)->iMB;
+  ((mng_magnp)pChunkto)->iMethodY = ((mng_magnp)pChunkfrom)->iMethodY;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+ASSIGN_CHUNK_HDR (mng_assign_mpng)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MPNG, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_mpNG)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_mpngp)pChunkto)->iFramewidth        = ((mng_mpngp)pChunkfrom)->iFramewidth;
+  ((mng_mpngp)pChunkto)->iFrameheight       = ((mng_mpngp)pChunkfrom)->iFrameheight;
+  ((mng_mpngp)pChunkto)->iNumplays          = ((mng_mpngp)pChunkfrom)->iNumplays;
+  ((mng_mpngp)pChunkto)->iTickspersec       = ((mng_mpngp)pChunkfrom)->iTickspersec;
+  ((mng_mpngp)pChunkto)->iCompressionmethod = ((mng_mpngp)pChunkfrom)->iCompressionmethod;
+  ((mng_mpngp)pChunkto)->iFramessize        = ((mng_mpngp)pChunkfrom)->iFramessize;
+
+  if (((mng_mpngp)pChunkto)->iFramessize)
+  {
+    MNG_ALLOC (pData, ((mng_mpngp)pChunkto)->pFrames, ((mng_mpngp)pChunkto)->iFramessize);
+    MNG_COPY  (((mng_mpngp)pChunkto)->pFrames, ((mng_mpngp)pChunkfrom)->pFrames,
+               ((mng_mpngp)pChunkto)->iFramessize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_MPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+ASSIGN_CHUNK_HDR (mng_assign_ahdr)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_AHDR, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_ahDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_ahdrp)pChunkto)->iNumframes   = ((mng_ahdrp)pChunkfrom)->iNumframes;
+  ((mng_ahdrp)pChunkto)->iTickspersec = ((mng_ahdrp)pChunkfrom)->iTickspersec;
+  ((mng_ahdrp)pChunkto)->iNumplays    = ((mng_ahdrp)pChunkfrom)->iNumplays;
+  ((mng_ahdrp)pChunkto)->iTilewidth   = ((mng_ahdrp)pChunkfrom)->iTilewidth;
+  ((mng_ahdrp)pChunkto)->iTileheight  = ((mng_ahdrp)pChunkfrom)->iTileheight;
+  ((mng_ahdrp)pChunkto)->iInterlace   = ((mng_ahdrp)pChunkfrom)->iInterlace;
+  ((mng_ahdrp)pChunkto)->iStillused   = ((mng_ahdrp)pChunkfrom)->iStillused;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_AHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+ASSIGN_CHUNK_HDR (mng_assign_adat)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ADAT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_adAT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_adatp)pChunkto)->iTilessize = ((mng_adatp)pChunkfrom)->iTilessize;
+
+  if (((mng_adatp)pChunkto)->iTilessize)
+  {
+    MNG_ALLOC (pData, ((mng_adatp)pChunkto)->pTiles, ((mng_adatp)pChunkto)->iTilessize);
+    MNG_COPY  (((mng_adatp)pChunkto)->pTiles, ((mng_adatp)pChunkfrom)->pTiles,
+               ((mng_adatp)pChunkto)->iTilessize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_ADAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+ASSIGN_CHUNK_HDR (mng_assign_evnt)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_EVNT, MNG_LC_START);
+#endif
+
+  if (((mng_chunk_headerp)pChunkfrom)->iChunkname != MNG_UINT_evNT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK); /* ouch */
+
+  ((mng_evntp)pChunkto)->iCount = ((mng_evntp)pChunkfrom)->iCount;
+
+  if (((mng_evntp)pChunkto)->iCount)
+  {
+    mng_uint32      iX;
+    mng_evnt_entryp pEntry;
+    mng_uint32      iLen = ((mng_evntp)pChunkto)->iCount * sizeof (mng_evnt_entry);
+
+    MNG_ALLOC (pData, ((mng_evntp)pChunkto)->pEntries, iLen);
+    MNG_COPY  (((mng_evntp)pChunkto)->pEntries, ((mng_evntp)pChunkfrom)->pEntries, iLen);
+
+    pEntry = ((mng_evntp)pChunkto)->pEntries;
+
+    for (iX = 0; iX < ((mng_evntp)pChunkto)->iCount; iX++)
+    {
+      if (pEntry->iSegmentnamesize)
+      {
+        mng_pchar pTemp = pEntry->zSegmentname;
+
+        MNG_ALLOC (pData, pEntry->zSegmentname, pEntry->iSegmentnamesize+1);
+        MNG_COPY  (pEntry->zSegmentname, pTemp, pEntry->iSegmentnamesize);
+      }
+      else
+      {
+        pEntry->zSegmentname = MNG_NULL;
+      }
+
+      pEntry++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_EVNT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+ASSIGN_CHUNK_HDR (mng_assign_unknown)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_UNKNOWN, MNG_LC_START);
+#endif
+
+  ((mng_unknown_chunkp)pChunkto)->iDatasize = ((mng_unknown_chunkp)pChunkfrom)->iDatasize;
+
+  if (((mng_unknown_chunkp)pChunkto)->iDatasize)
+  {
+    MNG_ALLOC (pData, ((mng_unknown_chunkp)pChunkto)->pData, ((mng_unknown_chunkp)pChunkto)->iDatasize);
+    MNG_COPY  (((mng_unknown_chunkp)pChunkto)->pData, ((mng_unknown_chunkp)pChunkfrom)->pData,
+               ((mng_unknown_chunkp)pChunkto)->iDatasize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ASSIGN_UNKNOWN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_chunk_prc.h b/src/3rdparty/libmng/libmng_chunk_prc.h
new file mode 100644
index 0000000..0cf0f3c
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunk_prc.h
@@ -0,0 +1,381 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunk_prc.h        copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Chunk initialization & cleanup (definition)                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : definition of the chunk initialization & cleanup routines  * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for JDAA                                   * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added NO_DELTA_PNG support                               * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKINITFREE             * */
+/* *             1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKASSIGN               * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_chunk_prc_h_
+#define _libmng_chunk_prc_h_
+
+/* ************************************************************************** */
+
+void mng_add_chunk (mng_datap  pData,
+                    mng_chunkp pChunk);
+
+/* ************************************************************************** */
+
+#define INIT_CHUNK_HDR(n) mng_retcode n (mng_datap   pData,    \
+                                         mng_chunkp  pHeader,  \
+                                         mng_chunkp* ppChunk)
+
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+INIT_CHUNK_HDR (mng_init_general) ;
+#else
+INIT_CHUNK_HDR (mng_init_ihdr) ;
+INIT_CHUNK_HDR (mng_init_plte) ;
+INIT_CHUNK_HDR (mng_init_idat) ;
+INIT_CHUNK_HDR (mng_init_iend) ;
+INIT_CHUNK_HDR (mng_init_trns) ;
+INIT_CHUNK_HDR (mng_init_gama) ;
+INIT_CHUNK_HDR (mng_init_chrm) ;
+INIT_CHUNK_HDR (mng_init_srgb) ;
+INIT_CHUNK_HDR (mng_init_iccp) ;
+INIT_CHUNK_HDR (mng_init_text) ;
+INIT_CHUNK_HDR (mng_init_ztxt) ;
+INIT_CHUNK_HDR (mng_init_itxt) ;
+INIT_CHUNK_HDR (mng_init_bkgd) ;
+INIT_CHUNK_HDR (mng_init_phys) ;
+INIT_CHUNK_HDR (mng_init_sbit) ;
+INIT_CHUNK_HDR (mng_init_splt) ;
+INIT_CHUNK_HDR (mng_init_hist) ;
+INIT_CHUNK_HDR (mng_init_time) ;
+INIT_CHUNK_HDR (mng_init_mhdr) ;
+INIT_CHUNK_HDR (mng_init_mend) ;
+INIT_CHUNK_HDR (mng_init_loop) ;
+INIT_CHUNK_HDR (mng_init_endl) ;
+INIT_CHUNK_HDR (mng_init_defi) ;
+INIT_CHUNK_HDR (mng_init_basi) ;
+INIT_CHUNK_HDR (mng_init_clon) ;
+#ifndef MNG_SKIPCHUNK_PAST
+INIT_CHUNK_HDR (mng_init_past) ;
+#endif
+INIT_CHUNK_HDR (mng_init_disc) ;
+INIT_CHUNK_HDR (mng_init_back) ;
+INIT_CHUNK_HDR (mng_init_fram) ;
+INIT_CHUNK_HDR (mng_init_move) ;
+INIT_CHUNK_HDR (mng_init_clip) ;
+INIT_CHUNK_HDR (mng_init_show) ;
+INIT_CHUNK_HDR (mng_init_term) ;
+INIT_CHUNK_HDR (mng_init_save) ;
+INIT_CHUNK_HDR (mng_init_seek) ;
+INIT_CHUNK_HDR (mng_init_expi) ;
+INIT_CHUNK_HDR (mng_init_fpri) ;
+INIT_CHUNK_HDR (mng_init_need) ;
+INIT_CHUNK_HDR (mng_init_phyg) ;
+#ifdef MNG_INCLUDE_JNG
+INIT_CHUNK_HDR (mng_init_jhdr) ;
+INIT_CHUNK_HDR (mng_init_jdaa) ;
+INIT_CHUNK_HDR (mng_init_jdat) ;
+INIT_CHUNK_HDR (mng_init_jsep) ;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+INIT_CHUNK_HDR (mng_init_dhdr) ;
+INIT_CHUNK_HDR (mng_init_prom) ;
+INIT_CHUNK_HDR (mng_init_ipng) ;
+INIT_CHUNK_HDR (mng_init_pplt) ;
+#ifdef MNG_INCLUDE_JNG
+INIT_CHUNK_HDR (mng_init_ijng) ;
+#endif
+INIT_CHUNK_HDR (mng_init_drop) ;
+INIT_CHUNK_HDR (mng_init_dbyk) ;
+INIT_CHUNK_HDR (mng_init_ordr) ;
+#endif
+INIT_CHUNK_HDR (mng_init_magn) ;
+INIT_CHUNK_HDR (mng_init_evnt) ;
+INIT_CHUNK_HDR (mng_init_unknown) ;
+#endif /* MNG_OPTIMIZE_CHUNKINITFREE */
+
+/* ************************************************************************** */
+
+#define FREE_CHUNK_HDR(n) mng_retcode n (mng_datap   pData,    \
+                                         mng_chunkp  pHeader)
+
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+FREE_CHUNK_HDR (mng_free_general) ;
+#else /* MNG_OPTIMIZE_CHUNKINITFREE */
+FREE_CHUNK_HDR (mng_free_ihdr) ;
+FREE_CHUNK_HDR (mng_free_plte) ;
+FREE_CHUNK_HDR (mng_free_iend) ;
+FREE_CHUNK_HDR (mng_free_trns) ;
+FREE_CHUNK_HDR (mng_free_gama) ;
+FREE_CHUNK_HDR (mng_free_chrm) ;
+FREE_CHUNK_HDR (mng_free_srgb) ;
+FREE_CHUNK_HDR (mng_free_bkgd) ;
+FREE_CHUNK_HDR (mng_free_phys) ;
+FREE_CHUNK_HDR (mng_free_sbit) ;
+FREE_CHUNK_HDR (mng_free_hist) ;
+FREE_CHUNK_HDR (mng_free_time) ;
+FREE_CHUNK_HDR (mng_free_mhdr) ;
+FREE_CHUNK_HDR (mng_free_mend) ;
+FREE_CHUNK_HDR (mng_free_endl) ;
+FREE_CHUNK_HDR (mng_free_defi) ;
+FREE_CHUNK_HDR (mng_free_basi) ;
+FREE_CHUNK_HDR (mng_free_clon) ;
+FREE_CHUNK_HDR (mng_free_back) ;
+FREE_CHUNK_HDR (mng_free_move) ;
+FREE_CHUNK_HDR (mng_free_clip) ;
+FREE_CHUNK_HDR (mng_free_show) ;
+FREE_CHUNK_HDR (mng_free_term) ;
+FREE_CHUNK_HDR (mng_free_fpri) ;
+FREE_CHUNK_HDR (mng_free_phyg) ;
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_jhdr) ;
+FREE_CHUNK_HDR (mng_free_jsep) ;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+FREE_CHUNK_HDR (mng_free_dhdr) ;
+FREE_CHUNK_HDR (mng_free_prom) ;
+FREE_CHUNK_HDR (mng_free_ipng) ;
+FREE_CHUNK_HDR (mng_free_pplt) ;
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_ijng) ;
+#endif
+#endif
+FREE_CHUNK_HDR (mng_free_magn) ;
+#endif /* MNG_OPTIMIZE_CHUNKINITFREE */
+
+FREE_CHUNK_HDR (mng_free_idat) ;
+FREE_CHUNK_HDR (mng_free_iccp) ;
+FREE_CHUNK_HDR (mng_free_text) ;
+FREE_CHUNK_HDR (mng_free_ztxt) ;
+FREE_CHUNK_HDR (mng_free_itxt) ;
+FREE_CHUNK_HDR (mng_free_splt) ;
+FREE_CHUNK_HDR (mng_free_loop) ;
+#ifndef MNG_SKIPCHUNK_PAST
+FREE_CHUNK_HDR (mng_free_past) ;
+#endif
+FREE_CHUNK_HDR (mng_free_disc) ;
+FREE_CHUNK_HDR (mng_free_fram) ;
+FREE_CHUNK_HDR (mng_free_save) ;
+FREE_CHUNK_HDR (mng_free_seek) ;
+FREE_CHUNK_HDR (mng_free_expi) ;
+FREE_CHUNK_HDR (mng_free_need) ;
+#ifdef MNG_INCLUDE_JNG
+FREE_CHUNK_HDR (mng_free_jdaa) ;
+FREE_CHUNK_HDR (mng_free_jdat) ;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+FREE_CHUNK_HDR (mng_free_drop) ;
+FREE_CHUNK_HDR (mng_free_dbyk) ;
+FREE_CHUNK_HDR (mng_free_ordr) ;
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+FREE_CHUNK_HDR (mng_free_mpng) ;
+#endif
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+FREE_CHUNK_HDR (mng_free_adat) ;
+#endif
+FREE_CHUNK_HDR (mng_free_evnt) ;
+FREE_CHUNK_HDR (mng_free_unknown) ;
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+#define ASSIGN_CHUNK_HDR(n) mng_retcode n (mng_datap   pData,    \
+                                           mng_chunkp  pChunkto, \
+                                           mng_chunkp  pChunkfrom)
+
+#ifdef MNG_OPTIMIZE_CHUNKASSIGN
+ASSIGN_CHUNK_HDR (mng_assign_general) ;
+#else /* MNG_OPTIMIZE_CHUNKASSIGN */
+ASSIGN_CHUNK_HDR (mng_assign_ihdr) ;
+ASSIGN_CHUNK_HDR (mng_assign_plte) ;
+ASSIGN_CHUNK_HDR (mng_assign_iend) ;
+ASSIGN_CHUNK_HDR (mng_assign_trns) ;
+ASSIGN_CHUNK_HDR (mng_assign_gama) ;
+ASSIGN_CHUNK_HDR (mng_assign_chrm) ;
+ASSIGN_CHUNK_HDR (mng_assign_srgb) ;
+ASSIGN_CHUNK_HDR (mng_assign_bkgd) ;
+ASSIGN_CHUNK_HDR (mng_assign_phys) ;
+ASSIGN_CHUNK_HDR (mng_assign_sbit) ;
+ASSIGN_CHUNK_HDR (mng_assign_hist) ;
+ASSIGN_CHUNK_HDR (mng_assign_time) ;
+ASSIGN_CHUNK_HDR (mng_assign_mhdr) ;
+ASSIGN_CHUNK_HDR (mng_assign_mend) ;
+ASSIGN_CHUNK_HDR (mng_assign_endl) ;
+ASSIGN_CHUNK_HDR (mng_assign_defi) ;
+ASSIGN_CHUNK_HDR (mng_assign_basi) ;
+ASSIGN_CHUNK_HDR (mng_assign_clon) ;
+ASSIGN_CHUNK_HDR (mng_assign_back) ;
+ASSIGN_CHUNK_HDR (mng_assign_move) ;
+ASSIGN_CHUNK_HDR (mng_assign_clip) ;
+ASSIGN_CHUNK_HDR (mng_assign_show) ;
+ASSIGN_CHUNK_HDR (mng_assign_term) ;
+ASSIGN_CHUNK_HDR (mng_assign_fpri) ;
+ASSIGN_CHUNK_HDR (mng_assign_phyg) ;
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_jhdr) ;
+ASSIGN_CHUNK_HDR (mng_assign_jsep) ;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+ASSIGN_CHUNK_HDR (mng_assign_dhdr) ;
+ASSIGN_CHUNK_HDR (mng_assign_prom) ;
+ASSIGN_CHUNK_HDR (mng_assign_ipng) ;
+ASSIGN_CHUNK_HDR (mng_assign_pplt) ;
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_ijng) ;
+#endif
+#endif
+ASSIGN_CHUNK_HDR (mng_assign_magn) ;
+#endif /* MNG_OPTIMIZE_CHUNKASSIGN */
+
+ASSIGN_CHUNK_HDR (mng_assign_idat) ;
+ASSIGN_CHUNK_HDR (mng_assign_iccp) ;
+ASSIGN_CHUNK_HDR (mng_assign_text) ;
+ASSIGN_CHUNK_HDR (mng_assign_ztxt) ;
+ASSIGN_CHUNK_HDR (mng_assign_itxt) ;
+ASSIGN_CHUNK_HDR (mng_assign_splt) ;
+ASSIGN_CHUNK_HDR (mng_assign_loop) ;
+#ifndef MNG_SKIPCHUNK_PAST
+ASSIGN_CHUNK_HDR (mng_assign_past) ;
+#endif
+ASSIGN_CHUNK_HDR (mng_assign_disc) ;
+ASSIGN_CHUNK_HDR (mng_assign_fram) ;
+ASSIGN_CHUNK_HDR (mng_assign_save) ;
+ASSIGN_CHUNK_HDR (mng_assign_seek) ;
+ASSIGN_CHUNK_HDR (mng_assign_need) ;
+ASSIGN_CHUNK_HDR (mng_assign_expi) ;
+#ifdef MNG_INCLUDE_JNG
+ASSIGN_CHUNK_HDR (mng_assign_jdaa) ;
+ASSIGN_CHUNK_HDR (mng_assign_jdat) ;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+ASSIGN_CHUNK_HDR (mng_assign_drop) ;
+ASSIGN_CHUNK_HDR (mng_assign_dbyk) ;
+ASSIGN_CHUNK_HDR (mng_assign_ordr) ;
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+ASSIGN_CHUNK_HDR (mng_assign_mpng) ;
+#endif
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+ASSIGN_CHUNK_HDR (mng_assign_ahdr) ;
+ASSIGN_CHUNK_HDR (mng_assign_adat) ;
+#endif
+ASSIGN_CHUNK_HDR (mng_assign_evnt) ;
+ASSIGN_CHUNK_HDR (mng_assign_unknown) ;
+
+/* ************************************************************************** */
+
+#else /* MNG_INCLUDE_WRITE_PROCS */
+#define mng_assign_general 0
+#define mng_assign_ihdr 0
+#define mng_assign_plte 0
+#define mng_assign_idat 0
+#define mng_assign_iend 0
+#define mng_assign_trns 0
+#define mng_assign_gama 0
+#define mng_assign_chrm 0
+#define mng_assign_srgb 0
+#define mng_assign_iccp 0
+#define mng_assign_text 0
+#define mng_assign_ztxt 0
+#define mng_assign_itxt 0
+#define mng_assign_bkgd 0
+#define mng_assign_phys 0
+#define mng_assign_sbit 0
+#define mng_assign_splt 0
+#define mng_assign_hist 0
+#define mng_assign_time 0
+#define mng_assign_mhdr 0
+#define mng_assign_mend 0
+#define mng_assign_loop 0
+#define mng_assign_endl 0
+#define mng_assign_defi 0
+#define mng_assign_basi 0
+#define mng_assign_clon 0
+#ifndef MNG_SKIPCHUNK_PAST
+#define mng_assign_past 0
+#endif
+#define mng_assign_disc 0
+#define mng_assign_back 0
+#define mng_assign_fram 0
+#define mng_assign_move 0
+#define mng_assign_clip 0
+#define mng_assign_show 0
+#define mng_assign_term 0
+#define mng_assign_save 0
+#define mng_assign_seek 0
+#define mng_assign_expi 0
+#define mng_assign_fpri 0
+#define mng_assign_phyg 0
+#ifdef MNG_INCLUDE_JNG
+#define mng_assign_jhdr 0
+#define mng_assign_jdaa 0
+#define mng_assign_jdat 0
+#define mng_assign_jsep 0
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#define mng_assign_dhdr 0
+#define mng_assign_prom 0
+#define mng_assign_ipng 0
+#define mng_assign_pplt 0
+#ifdef MNG_INCLUDE_JNG
+#define mng_assign_ijng 0
+#endif
+#define mng_assign_drop 0
+#define mng_assign_dbyk 0
+#define mng_assign_ordr 0
+#endif
+#define mng_assign_magn 0
+#define mng_assign_need 0
+#define mng_assign_mpng 0
+#define mng_assign_ahdr 0
+#define mng_assign_adat 0
+#define mng_assign_evnt 0
+#define mng_assign_unknown 0
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+
+#endif /* _libmng_chunk_prc_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_chunk_xs.c b/src/3rdparty/libmng/libmng_chunk_xs.c
new file mode 100644
index 0000000..1311409
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunk_xs.c
@@ -0,0 +1,7016 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunk_xs.c         copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : chunk access functions (implementation)                    * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the chunk access functions               * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - changed and filled iterate-chunk function                * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - fixed calling convention                                 * */
+/* *             - added getchunk functions                                 * */
+/* *             - added putchunk functions                                 * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added empty-chunk put-routines                           * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *             0.5.1 - 05/15/2000 - G.Juyn                                * */
+/* *             - added getimgdata & putimgdata functions                  * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/19/2000 - G.Juyn                                * */
+/* *             - B004 - fixed problem with MNG_SUPPORT_WRITE not defined  * */
+/* *               also for MNG_SUPPORT_WRITE without MNG_INCLUDE_JNG       * */
+/* *             - Cleaned up some code regarding mixed support             * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - fixed creation-code                                      * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *             - added function to set simplicity field                   * */
+/* *             - fixed putchunk_unknown() function                        * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/07/2000 - G.Juyn                                * */
+/* *             - B111300 - fixup for improved portability                 * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 10/20/2000 - G.Juyn                                * */
+/* *             - fixed putchunk_plte() to set bEmpty parameter            * */
+/* *                                                                        * */
+/* *             0.9.5 - 01/25/2001 - G.Juyn                                * */
+/* *             - fixed some small compiler warnings (thanks Nikki)        * */
+/* *                                                                        * */
+/* *             1.0.5 - 09/07/2002 - G.Juyn                                * */
+/* *             - B578940 - unimplemented functions return errorcode       * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             - added HLAPI function to copy chunks                      * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - added check for TERM placement during create/write       * */
+/* *             1.0.5 - 11/28/2002 - G.Juyn                                * */
+/* *             - fixed definition of iMethodX/Y for MAGN chunk            * */
+/* *                                                                        * */
+/* *             1.0.6 - 05/25/2003 - G.R-P                                 * */
+/* *             - added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added MNG_NO_DELTA_PNG reduction and more SKIPCHUNK      * */
+/* *               optimizations                                            * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *             1.0.6 - 08/17/2003 - G.R-P                                 * */
+/* *             - added conditionals around non-VLC chunk support          * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/01/2004 - G.Juyn                                * */
+/* *             - added missing get-/put-chunk-jdaa                        * */
+/* *             1.0.8 - 08/02/2004 - G.Juyn                                * */
+/* *             - added conditional to allow easier writing of large MNG's * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/17/2004 - G.R-P                                 * */
+/* *             - added two more conditionals                              * */
+/* *             1.0.9 - 09/25/2004 - G.Juyn                                * */
+/* *             - replaced MNG_TWEAK_LARGE_FILES with permanent solution   * */
+/* *             1.0.9 - 17/14/2004 - G.Juyn                                * */
+/* *             - fixed PPLT getchunk/putchunk routines                    * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKINITFREE             * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_chunks.h"
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+#include "libmng_chunk_descr.h"
+#endif
+#include "libmng_chunk_prc.h"
+#include "libmng_chunk_io.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_ACCESS_CHUNKS
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_iterate_chunks (mng_handle       hHandle,
+                                         mng_uint32       iChunkseq,
+                                         mng_iteratechunk fProc)
+{
+  mng_uint32  iSeq;
+  mng_chunkid iChunkname;
+  mng_datap   pData;
+  mng_chunkp  pChunk;
+  mng_bool    bCont;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_ITERATE_CHUNKS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  iSeq   = 0;
+  bCont  = MNG_TRUE;
+  pChunk = pData->pFirstchunk;         /* get the first chunk */
+                                       /* as long as there are some more */
+  while ((pChunk) && (bCont))          /* and the app didn't signal a stop */
+  {
+    if (iSeq >= iChunkseq)             /* reached the first target ? */
+    {                                  /* then call this and next ones back in... */
+      iChunkname = ((mng_chunk_headerp)pChunk)->iChunkname;
+      bCont      = fProc (hHandle, (mng_handle)pChunk, iChunkname, iSeq);
+    }
+
+    iSeq++;                            /* next one */
+    pChunk = ((mng_chunk_headerp)pChunk)->pNext;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_ITERATE_CHUNKS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_copy_chunk (mng_handle hHandle,
+                                     mng_handle hChunk,
+                                     mng_handle hHandleOut)
+{
+  mng_datap   pDataOut;
+  mng_chunkp  pChunk;
+  mng_chunkp  pChunkOut;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_COPY_CHUNK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handles */
+  MNG_VALIDHANDLE (hHandleOut)
+
+  pDataOut = (mng_datap)hHandleOut;    /* make outhandle addressable */
+  pChunk   = (mng_chunkp)hChunk;       /* address the chunk */
+
+  if (!pDataOut->bCreating)            /* aren't we creating a new file ? */
+    MNG_ERROR (pDataOut, MNG_FUNCTIONINVALID)
+                                       /* create a new chunk */
+  iRetcode = ((mng_createchunk)((mng_chunk_headerp)pChunk)->fCreate)
+                        (pDataOut, ((mng_chunk_headerp)pChunk), &pChunkOut);
+  if (!iRetcode)                       /* assign the chunk-specific data */
+    iRetcode = ((mng_assignchunk)((mng_chunk_headerp)pChunk)->fAssign)
+                          (pDataOut, pChunkOut, pChunk);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode; 
+
+  mng_add_chunk (pDataOut, pChunkOut); /* and put it in the output-stream */
+
+                                       /* could it be the end of the chain ? */
+  if (((mng_chunk_headerp)pChunkOut)->iChunkname == MNG_UINT_IEND)
+  {
+#ifdef MNG_INCLUDE_JNG
+    if ((pDataOut->iFirstchunkadded == MNG_UINT_IHDR) ||
+        (pDataOut->iFirstchunkadded == MNG_UINT_JHDR)    )
+#else
+    if (pDataOut->iFirstchunkadded == MNG_UINT_IHDR)
+#endif
+      pDataOut->bCreating = MNG_FALSE; /* right; this should be the last chunk !!! */
+  }
+
+  if (((mng_chunk_headerp)pChunkOut)->iChunkname == MNG_UINT_MEND)
+    pDataOut->bCreating = MNG_FALSE;   /* definitely this should be the last !!! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_COPY_CHUNK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_ihdr (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iWidth,
+                                        mng_uint32 *iHeight,
+                                        mng_uint8  *iBitdepth,
+                                        mng_uint8  *iColortype,
+                                        mng_uint8  *iCompression,
+                                        mng_uint8  *iFilter,
+                                        mng_uint8  *iInterlace)
+{
+  mng_datap pData;
+  mng_ihdrp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_IHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_ihdrp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_IHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iWidth       = pChunk->iWidth;      /* fill the fields */
+  *iHeight      = pChunk->iHeight;
+  *iBitdepth    = pChunk->iBitdepth;
+  *iColortype   = pChunk->iColortype;
+  *iCompression = pChunk->iCompression;
+  *iFilter      = pChunk->iFilter;
+  *iInterlace   = pChunk->iInterlace;
+
+                                       /* fill the chunk */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_plte (mng_handle   hHandle,
+                                        mng_handle   hChunk,
+                                        mng_uint32   *iCount,
+                                        mng_palette8 *aPalette)
+{
+  mng_datap pData;
+  mng_pltep pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PLTE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_pltep)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_PLTE)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iCount = pChunk->iEntrycount;       /* fill the fields */
+
+  MNG_COPY (*aPalette, pChunk->aEntries, sizeof (mng_palette8));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_idat (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iRawlen,
+                                        mng_ptr    *pRawdata)
+{
+  mng_datap pData;
+  mng_idatp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_IDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_idatp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_IDAT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iRawlen  = pChunk->iDatasize;       /* fill the fields */
+  *pRawdata = pChunk->pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_IDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_trns (mng_handle   hHandle,
+                                        mng_handle   hChunk,
+                                        mng_bool     *bEmpty,
+                                        mng_bool     *bGlobal,
+                                        mng_uint8    *iType,
+                                        mng_uint32   *iCount,
+                                        mng_uint8arr *aAlphas,
+                                        mng_uint16   *iGray,
+                                        mng_uint16   *iRed,
+                                        mng_uint16   *iGreen,
+                                        mng_uint16   *iBlue,
+                                        mng_uint32   *iRawlen,
+                                        mng_uint8arr *aRawdata)
+{
+  mng_datap pData;
+  mng_trnsp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TRNS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_trnsp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_tRNS)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty   = pChunk->bEmpty;          /* fill the fields */
+  *bGlobal  = pChunk->bGlobal;
+  *iType    = pChunk->iType;
+  *iCount   = pChunk->iCount;
+  *iGray    = pChunk->iGray;
+  *iRed     = pChunk->iRed;
+  *iGreen   = pChunk->iGreen;
+  *iBlue    = pChunk->iBlue;
+  *iRawlen  = pChunk->iRawlen;
+
+  MNG_COPY (*aAlphas,  pChunk->aEntries, sizeof (mng_uint8arr));
+  MNG_COPY (*aRawdata, pChunk->aRawdata, sizeof (mng_uint8arr));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_gAMA
+mng_retcode MNG_DECL mng_getchunk_gama (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint32 *iGamma)
+{
+  mng_datap pData;
+  mng_gamap pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_GAMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_gamap)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_gAMA)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty = pChunk->bEmpty;            /* fill the fields */
+  *iGamma = pChunk->iGamma;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+mng_retcode MNG_DECL mng_getchunk_chrm (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint32 *iWhitepointx,
+                                        mng_uint32 *iWhitepointy,
+                                        mng_uint32 *iRedx,
+                                        mng_uint32 *iRedy,
+                                        mng_uint32 *iGreenx,
+                                        mng_uint32 *iGreeny,
+                                        mng_uint32 *iBluex,
+                                        mng_uint32 *iBluey)
+{
+  mng_datap pData;
+  mng_chrmp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_CHRM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_chrmp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_cHRM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty       = pChunk->bEmpty;      /* fill the fields */     
+  *iWhitepointx = pChunk->iWhitepointx;
+  *iWhitepointy = pChunk->iWhitepointy;
+  *iRedx        = pChunk->iRedx;
+  *iRedy        = pChunk->iRedy;
+  *iGreenx      = pChunk->iGreenx;
+  *iGreeny      = pChunk->iGreeny;
+  *iBluex       = pChunk->iBluex;
+  *iBluey       = pChunk->iBluey;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sRGB
+mng_retcode MNG_DECL mng_getchunk_srgb (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint8  *iRenderingintent)
+{
+  mng_datap pData;
+  mng_srgbp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SRGB, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_srgbp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_sRGB)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty           = pChunk->bEmpty;  /* fill the fields */        
+  *iRenderingintent = pChunk->iRenderingintent;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_retcode MNG_DECL mng_getchunk_iccp (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint32 *iNamesize,
+                                        mng_pchar  *zName,
+                                        mng_uint8  *iCompression,
+                                        mng_uint32 *iProfilesize,
+                                        mng_ptr    *pProfile)
+{
+  mng_datap pData;
+  mng_iccpp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ICCP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_iccpp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_iCCP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty       = pChunk->bEmpty;      /* fill the fields */     
+  *iNamesize    = pChunk->iNamesize;
+  *zName        = pChunk->zName;
+  *iCompression = pChunk->iCompression;
+  *iProfilesize = pChunk->iProfilesize;
+  *pProfile     = pChunk->pProfile;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+mng_retcode MNG_DECL mng_getchunk_text (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iKeywordsize,
+                                        mng_pchar  *zKeyword,
+                                        mng_uint32 *iTextsize,
+                                        mng_pchar  *zText)
+{
+  mng_datap pData;
+  mng_textp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TEXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_textp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_tEXt)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+                                       /* fill the fields */
+  *iKeywordsize = pChunk->iKeywordsize;
+  *zKeyword     = pChunk->zKeyword;
+  *iTextsize    = pChunk->iTextsize;
+  *zText        = pChunk->zText;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TEXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+mng_retcode MNG_DECL mng_getchunk_ztxt (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iKeywordsize,
+                                        mng_pchar  *zKeyword,
+                                        mng_uint8  *iCompression,
+                                        mng_uint32 *iTextsize,
+                                        mng_pchar  *zText)
+{
+  mng_datap pData;
+  mng_ztxtp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ZTXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_ztxtp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_zTXt)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+                                       /* fill the fields */
+  *iKeywordsize = pChunk->iKeywordsize;
+  *zKeyword     = pChunk->zKeyword;
+  *iCompression = pChunk->iCompression;
+  *iTextsize    = pChunk->iTextsize;
+  *zText        = pChunk->zText;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ZTXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+mng_retcode MNG_DECL mng_getchunk_itxt (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iKeywordsize,
+                                        mng_pchar  *zKeyword,
+                                        mng_uint8  *iCompressionflag,
+                                        mng_uint8  *iCompressionmethod,
+                                        mng_uint32 *iLanguagesize,
+                                        mng_pchar  *zLanguage,
+                                        mng_uint32 *iTranslationsize,
+                                        mng_pchar  *zTranslation,
+                                        mng_uint32 *iTextsize,
+                                        mng_pchar  *zText)
+{
+  mng_datap pData;
+  mng_itxtp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ITXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_itxtp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_iTXt)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+                                       /* fill the fields */
+  *iKeywordsize       = pChunk->iKeywordsize;
+  *zKeyword           = pChunk->zKeyword;
+  *iCompressionflag   = pChunk->iCompressionflag;
+  *iCompressionmethod = pChunk->iCompressionmethod;
+  *iLanguagesize      = pChunk->iLanguagesize;
+  *zLanguage          = pChunk->zLanguage;
+  *iTranslationsize   = pChunk->iTranslationsize;
+  *zTranslation       = pChunk->zTranslation;
+  *iTextsize          = pChunk->iTextsize;
+  *zText              = pChunk->zText;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ITXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+mng_retcode MNG_DECL mng_getchunk_bkgd (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint8  *iType,
+                                        mng_uint8  *iIndex,
+                                        mng_uint16 *iGray,
+                                        mng_uint16 *iRed,
+                                        mng_uint16 *iGreen,
+                                        mng_uint16 *iBlue)
+{
+  mng_datap pData;
+  mng_bkgdp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_BKGD, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_bkgdp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_bKGD)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty = pChunk->bEmpty;            /* fill the fields */
+  *iType  = pChunk->iType;
+  *iIndex = pChunk->iIndex;
+  *iGray  = pChunk->iGray;
+  *iRed   = pChunk->iRed;
+  *iGreen = pChunk->iGreen;
+  *iBlue  = pChunk->iBlue;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYs
+mng_retcode MNG_DECL mng_getchunk_phys (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint32 *iSizex,
+                                        mng_uint32 *iSizey,
+                                        mng_uint8  *iUnit)
+{
+  mng_datap pData;
+  mng_physp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PHYS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_physp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_pHYs)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty = pChunk->bEmpty;            /* fill the fields */
+  *iSizex = pChunk->iSizex;
+  *iSizey = pChunk->iSizey;
+  *iUnit  = pChunk->iUnit;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PHYS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sBIT
+mng_retcode MNG_DECL mng_getchunk_sbit (mng_handle    hHandle,
+                                        mng_handle    hChunk,
+                                        mng_bool      *bEmpty,
+                                        mng_uint8     *iType,
+                                        mng_uint8arr4 *aBits)
+{
+  mng_datap pData;
+  mng_sbitp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SBIT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_sbitp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_sBIT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty     = pChunk->bEmpty;
+  *iType      = pChunk->iType;
+  (*aBits)[0] = pChunk->aBits[0];
+  (*aBits)[1] = pChunk->aBits[1];
+  (*aBits)[2] = pChunk->aBits[2];
+  (*aBits)[3] = pChunk->aBits[3];
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SBIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+mng_retcode MNG_DECL mng_getchunk_splt (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint32 *iNamesize,
+                                        mng_pchar  *zName,
+                                        mng_uint8  *iSampledepth,
+                                        mng_uint32 *iEntrycount,
+                                        mng_ptr    *pEntries)
+{
+  mng_datap pData;
+  mng_spltp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SPLT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_spltp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_sPLT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty       = pChunk->bEmpty;      /* fill the fields */      
+  *iNamesize    = pChunk->iNamesize;
+  *zName        = pChunk->zName;
+  *iSampledepth = pChunk->iSampledepth;
+  *iEntrycount  = pChunk->iEntrycount;
+  *pEntries     = pChunk->pEntries;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+mng_retcode MNG_DECL mng_getchunk_hist (mng_handle    hHandle,
+                                        mng_handle    hChunk,
+                                        mng_uint32    *iEntrycount,
+                                        mng_uint16arr *aEntries)
+{
+  mng_datap pData;
+  mng_histp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_HIST, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_histp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_hIST)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iEntrycount = pChunk->iEntrycount;  /* fill the fields */
+
+  MNG_COPY (*aEntries, pChunk->aEntries, sizeof (mng_uint16arr));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_HIST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tIME
+mng_retcode MNG_DECL mng_getchunk_time (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iYear,
+                                        mng_uint8  *iMonth,
+                                        mng_uint8  *iDay,
+                                        mng_uint8  *iHour,
+                                        mng_uint8  *iMinute,
+                                        mng_uint8  *iSecond)
+{
+  mng_datap pData;
+  mng_timep pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TIME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_timep)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_tIME)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iYear   = pChunk->iYear;            /* fill the fields */ 
+  *iMonth  = pChunk->iMonth;
+  *iDay    = pChunk->iDay;
+  *iHour   = pChunk->iHour;
+  *iMinute = pChunk->iMinute;
+  *iSecond = pChunk->iSecond;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TIME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_mhdr (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iWidth,
+                                        mng_uint32 *iHeight,
+                                        mng_uint32 *iTicks,
+                                        mng_uint32 *iLayercount,
+                                        mng_uint32 *iFramecount,
+                                        mng_uint32 *iPlaytime,
+                                        mng_uint32 *iSimplicity)
+{
+  mng_datap pData;
+  mng_mhdrp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_mhdrp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iWidth      = pChunk->iWidth;       /* fill the fields */   
+  *iHeight     = pChunk->iHeight;
+  *iTicks      = pChunk->iTicks;
+  *iLayercount = pChunk->iLayercount;
+  *iFramecount = pChunk->iFramecount;
+  *iPlaytime   = pChunk->iPlaytime;
+  *iSimplicity = pChunk->iSimplicity;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+mng_retcode MNG_DECL mng_getchunk_loop (mng_handle  hHandle,
+                                        mng_handle  hChunk,
+                                        mng_uint8   *iLevel,
+                                        mng_uint32  *iRepeat,
+                                        mng_uint8   *iTermination,
+                                        mng_uint32  *iItermin,
+                                        mng_uint32  *iItermax,
+                                        mng_uint32  *iCount,
+                                        mng_uint32p *pSignals)
+{
+  mng_datap pData;
+  mng_loopp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_LOOP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_loopp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_LOOP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iLevel       = pChunk->iLevel;      /* fill teh fields */
+  *iRepeat      = pChunk->iRepeat;
+  *iTermination = pChunk->iTermination;
+  *iItermin     = pChunk->iItermin;
+  *iItermax     = pChunk->iItermax;
+  *iCount       = pChunk->iCount;
+  *pSignals     = pChunk->pSignals;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_LOOP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_endl (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint8  *iLevel)
+{
+  mng_datap pData;
+  mng_endlp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ENDL, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_endlp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_ENDL)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iLevel = pChunk->iLevel;            /* fill the field */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+mng_retcode MNG_DECL mng_getchunk_defi (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iObjectid,
+                                        mng_uint8  *iDonotshow,
+                                        mng_uint8  *iConcrete,
+                                        mng_bool   *bHasloca,
+                                        mng_int32  *iXlocation,
+                                        mng_int32  *iYlocation,
+                                        mng_bool   *bHasclip,
+                                        mng_int32  *iLeftcb,
+                                        mng_int32  *iRightcb,
+                                        mng_int32  *iTopcb,
+                                        mng_int32  *iBottomcb)
+{
+  mng_datap pData;
+  mng_defip pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DEFI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_defip)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_DEFI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iObjectid  = pChunk->iObjectid;     /* fill the fields */
+  *iDonotshow = pChunk->iDonotshow;
+  *iConcrete  = pChunk->iConcrete;
+  *bHasloca   = pChunk->bHasloca;
+  *iXlocation = pChunk->iXlocation;
+  *iYlocation = pChunk->iYlocation;
+  *bHasclip   = pChunk->bHasclip;
+  *iLeftcb    = pChunk->iLeftcb;
+  *iRightcb   = pChunk->iRightcb;
+  *iTopcb     = pChunk->iTopcb;
+  *iBottomcb  = pChunk->iBottomcb;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BASI
+mng_retcode MNG_DECL mng_getchunk_basi (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iWidth,
+                                        mng_uint32 *iHeight,
+                                        mng_uint8  *iBitdepth,
+                                        mng_uint8  *iColortype,
+                                        mng_uint8  *iCompression,
+                                        mng_uint8  *iFilter,
+                                        mng_uint8  *iInterlace,
+                                        mng_uint16 *iRed,
+                                        mng_uint16 *iGreen,
+                                        mng_uint16 *iBlue,
+                                        mng_uint16 *iAlpha,
+                                        mng_uint8  *iViewable)
+{
+  mng_datap pData;
+  mng_basip pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_BASI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_basip)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_BASI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iWidth       = pChunk->iWidth;      /* fill the fields */
+  *iHeight      = pChunk->iHeight;
+  *iBitdepth    = pChunk->iBitdepth;
+  *iColortype   = pChunk->iColortype;
+  *iCompression = pChunk->iCompression;
+  *iFilter      = pChunk->iFilter;
+  *iInterlace   = pChunk->iInterlace;
+  *iRed         = pChunk->iRed;
+  *iGreen       = pChunk->iGreen;
+  *iBlue        = pChunk->iBlue;
+  *iAlpha       = pChunk->iAlpha;
+  *iViewable    = pChunk->iViewable;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLON
+mng_retcode MNG_DECL mng_getchunk_clon (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iSourceid,
+                                        mng_uint16 *iCloneid,
+                                        mng_uint8  *iClonetype,
+                                        mng_uint8  *iDonotshow,
+                                        mng_uint8  *iConcrete,
+                                        mng_bool   *bHasloca,
+                                        mng_uint8  *iLocationtype,
+                                        mng_int32  *iLocationx,
+                                        mng_int32  *iLocationy)
+{
+  mng_datap pData;
+  mng_clonp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_CLON, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_clonp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_CLON)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iSourceid     = pChunk->iSourceid;  /* fill the fields */  
+  *iCloneid      = pChunk->iCloneid;
+  *iClonetype    = pChunk->iClonetype;
+  *iDonotshow    = pChunk->iDonotshow;
+  *iConcrete     = pChunk->iConcrete;
+  *bHasloca      = pChunk->bHasloca;
+  *iLocationtype = pChunk->iLocationtype;
+  *iLocationx    = pChunk->iLocationx;
+  *iLocationy    = pChunk->iLocationy;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode MNG_DECL mng_getchunk_past (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iDestid,
+                                        mng_uint8  *iTargettype,
+                                        mng_int32  *iTargetx,
+                                        mng_int32  *iTargety,
+                                        mng_uint32 *iCount)
+{
+  mng_datap pData;
+  mng_pastp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PAST, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_pastp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_PAST)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iDestid     = pChunk->iDestid;       /* fill the fields */
+  *iTargettype = pChunk->iTargettype;
+  *iTargetx    = pChunk->iTargetx;
+  *iTargety    = pChunk->iTargety;
+  *iCount      = pChunk->iCount;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PAST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode MNG_DECL mng_getchunk_past_src (mng_handle hHandle,
+                                            mng_handle hChunk,
+                                            mng_uint32 iEntry,
+                                            mng_uint16 *iSourceid,
+                                            mng_uint8  *iComposition,
+                                            mng_uint8  *iOrientation,
+                                            mng_uint8  *iOffsettype,
+                                            mng_int32  *iOffsetx,
+                                            mng_int32  *iOffsety,
+                                            mng_uint8  *iBoundarytype,
+                                            mng_int32  *iBoundaryl,
+                                            mng_int32  *iBoundaryr,
+                                            mng_int32  *iBoundaryt,
+                                            mng_int32  *iBoundaryb)
+{
+  mng_datap        pData;
+  mng_pastp        pChunk;
+  mng_past_sourcep pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PAST_SRC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_pastp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_PAST)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  if (iEntry >= pChunk->iCount)        /* valid index ? */
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+                                       /* address the entry */
+  pEntry         = pChunk->pSources + iEntry;
+
+  *iSourceid     = pEntry->iSourceid;  /* fill the fields */
+  *iComposition  = pEntry->iComposition;
+  *iOrientation  = pEntry->iOrientation;
+  *iOffsettype   = pEntry->iOffsettype;
+  *iOffsetx      = pEntry->iOffsetx;
+  *iOffsety      = pEntry->iOffsety;
+  *iBoundarytype = pEntry->iBoundarytype;
+  *iBoundaryl    = pEntry->iBoundaryl;
+  *iBoundaryr    = pEntry->iBoundaryr;
+  *iBoundaryt    = pEntry->iBoundaryt;
+  *iBoundaryb    = pEntry->iBoundaryb;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PAST_SRC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+mng_retcode MNG_DECL mng_getchunk_disc (mng_handle  hHandle,
+                                        mng_handle  hChunk,
+                                        mng_uint32  *iCount,
+                                        mng_uint16p *pObjectids)
+{
+  mng_datap pData;
+  mng_discp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DISC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_discp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_DISC)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iCount     = pChunk->iCount;        /* fill the fields */
+  *pObjectids = pChunk->pObjectids;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DISC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BACK
+mng_retcode MNG_DECL mng_getchunk_back (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iRed,
+                                        mng_uint16 *iGreen,
+                                        mng_uint16 *iBlue,
+                                        mng_uint8  *iMandatory,
+                                        mng_uint16 *iImageid,
+                                        mng_uint8  *iTile)
+{
+  mng_datap pData;
+  mng_backp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_BACK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_backp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_BACK)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iRed       = pChunk->iRed;          /* fill the fields */
+  *iGreen     = pChunk->iGreen;
+  *iBlue      = pChunk->iBlue;
+  *iMandatory = pChunk->iMandatory;
+  *iImageid   = pChunk->iImageid;
+  *iTile      = pChunk->iTile;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+mng_retcode MNG_DECL mng_getchunk_fram (mng_handle  hHandle,
+                                        mng_handle  hChunk,
+                                        mng_bool    *bEmpty,
+                                        mng_uint8   *iMode,
+                                        mng_uint32  *iNamesize,
+                                        mng_pchar   *zName,
+                                        mng_uint8   *iChangedelay,
+                                        mng_uint8   *iChangetimeout,
+                                        mng_uint8   *iChangeclipping,
+                                        mng_uint8   *iChangesyncid,
+                                        mng_uint32  *iDelay,
+                                        mng_uint32  *iTimeout,
+                                        mng_uint8   *iBoundarytype,
+                                        mng_int32   *iBoundaryl,
+                                        mng_int32   *iBoundaryr,
+                                        mng_int32   *iBoundaryt,
+                                        mng_int32   *iBoundaryb,
+                                        mng_uint32  *iCount,
+                                        mng_uint32p *pSyncids)
+{
+  mng_datap pData;
+  mng_framp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_FRAM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_framp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_FRAM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty          = pChunk->bEmpty;   /* fill the fields */      
+  *iMode           = pChunk->iMode;
+  *iNamesize       = pChunk->iNamesize;
+  *zName           = pChunk->zName;
+  *iChangedelay    = pChunk->iChangedelay;
+  *iChangetimeout  = pChunk->iChangetimeout;
+  *iChangeclipping = pChunk->iChangeclipping;
+  *iChangesyncid   = pChunk->iChangesyncid;
+  *iDelay          = pChunk->iDelay;
+  *iTimeout        = pChunk->iTimeout;
+  *iBoundarytype   = pChunk->iBoundarytype;
+  *iBoundaryl      = pChunk->iBoundaryl;
+  *iBoundaryr      = pChunk->iBoundaryr;
+  *iBoundaryt      = pChunk->iBoundaryt;
+  *iBoundaryb      = pChunk->iBoundaryb;
+  *iCount          = pChunk->iCount;
+  *pSyncids        = pChunk->pSyncids;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_FRAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MOVE
+mng_retcode MNG_DECL mng_getchunk_move (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iFirstid,
+                                        mng_uint16 *iLastid,
+                                        mng_uint8  *iMovetype,
+                                        mng_int32  *iMovex,
+                                        mng_int32  *iMovey)
+{
+  mng_datap pData;
+  mng_movep pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MOVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_movep)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_MOVE)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iFirstid  = pChunk->iFirstid;       /* fill the fields */
+  *iLastid   = pChunk->iLastid;
+  *iMovetype = pChunk->iMovetype;
+  *iMovex    = pChunk->iMovex;
+  *iMovey    = pChunk->iMovey;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLIP
+mng_retcode MNG_DECL mng_getchunk_clip (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iFirstid,
+                                        mng_uint16 *iLastid,
+                                        mng_uint8  *iCliptype,
+                                        mng_int32  *iClipl,
+                                        mng_int32  *iClipr,
+                                        mng_int32  *iClipt,
+                                        mng_int32  *iClipb)
+{
+  mng_datap pData;
+  mng_clipp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_CLIP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_clipp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_CLIP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iFirstid  = pChunk->iFirstid;       /* fill the fields */
+  *iLastid   = pChunk->iLastid;
+  *iCliptype = pChunk->iCliptype;
+  *iClipl    = pChunk->iClipl;
+  *iClipr    = pChunk->iClipr;
+  *iClipt    = pChunk->iClipt;
+  *iClipb    = pChunk->iClipb;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SHOW
+mng_retcode MNG_DECL mng_getchunk_show (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint16 *iFirstid,
+                                        mng_uint16 *iLastid,
+                                        mng_uint8  *iMode)
+{
+  mng_datap pData;
+  mng_showp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SHOW, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_showp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_SHOW)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty   = pChunk->bEmpty;          /* fill the fields */
+  *iFirstid = pChunk->iFirstid;
+  *iLastid  = pChunk->iLastid;
+  *iMode    = pChunk->iMode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_TERM
+mng_retcode MNG_DECL mng_getchunk_term (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint8  *iTermaction,
+                                        mng_uint8  *iIteraction,
+                                        mng_uint32 *iDelay,
+                                        mng_uint32 *iItermax)
+{
+  mng_datap pData;
+  mng_termp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TERM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_termp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_TERM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iTermaction = pChunk->iTermaction;  /* fill the fields */
+  *iIteraction = pChunk->iIteraction;
+  *iDelay      = pChunk->iDelay;
+  *iItermax    = pChunk->iItermax;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode MNG_DECL mng_getchunk_save (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint8  *iOffsettype,
+                                        mng_uint32 *iCount)
+{
+  mng_datap pData;
+  mng_savep pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SAVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_savep)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_SAVE)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty      = pChunk->bEmpty;       /* fill the fields */
+  *iOffsettype = pChunk->iOffsettype;
+  *iCount      = pChunk->iCount;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_save_entry (mng_handle     hHandle,
+                                              mng_handle     hChunk,
+                                              mng_uint32     iEntry,
+                                              mng_uint8      *iEntrytype,
+                                              mng_uint32arr2 *iOffset,
+                                              mng_uint32arr2 *iStarttime,
+                                              mng_uint32     *iLayernr,
+                                              mng_uint32     *iFramenr,
+                                              mng_uint32     *iNamesize,
+                                              mng_pchar      *zName)
+{
+  mng_datap       pData;
+  mng_savep       pChunk;
+  mng_save_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SAVE_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_savep)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_SAVE)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  if (iEntry >= pChunk->iCount)        /* valid index ? */
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+
+  pEntry  = pChunk->pEntries + iEntry; /* address the entry */
+                                       /* fill the fields */
+  *iEntrytype      = pEntry->iEntrytype;
+  (*iOffset)[0]    = pEntry->iOffset[0];
+  (*iOffset)[1]    = pEntry->iOffset[1];
+  (*iStarttime)[0] = pEntry->iStarttime[0];
+  (*iStarttime)[1] = pEntry->iStarttime[1];
+  *iLayernr        = pEntry->iLayernr;
+  *iFramenr        = pEntry->iFramenr;
+  *iNamesize       = pEntry->iNamesize;
+  *zName           = pEntry->zName;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SAVE_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode MNG_DECL mng_getchunk_seek (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iNamesize,
+                                        mng_pchar  *zName)
+{
+  mng_datap pData;
+  mng_seekp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SEEK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_seekp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_SEEK)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iNamesize = pChunk->iNamesize;      /* fill the fields */
+  *zName     = pChunk->zName;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+mng_retcode MNG_DECL mng_getchunk_expi (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iSnapshotid,
+                                        mng_uint32 *iNamesize,
+                                        mng_pchar  *zName)
+{
+  mng_datap pData;
+  mng_expip pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_EXPI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_expip)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_eXPI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iSnapshotid = pChunk->iSnapshotid;  /* fill the fields */
+  *iNamesize   = pChunk->iNamesize;
+  *zName       = pChunk->zName;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_EXPI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_fPRI
+mng_retcode MNG_DECL mng_getchunk_fpri (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint8  *iDeltatype,
+                                        mng_uint8  *iPriority)
+{
+  mng_datap pData;
+  mng_fprip pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_FPRI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_fprip)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_fPRI)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iDeltatype = pChunk->iDeltatype;    /* fill the fields */
+  *iPriority  = pChunk->iPriority;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_FPRI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+mng_retcode MNG_DECL mng_getchunk_need (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iKeywordssize,
+                                        mng_pchar  *zKeywords)
+{
+  mng_datap pData;
+  mng_needp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_NEED, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_needp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_nEED)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+                                       /* fill the fields */
+  *iKeywordssize = pChunk->iKeywordssize;
+  *zKeywords     = pChunk->zKeywords;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_NEED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYg
+mng_retcode MNG_DECL mng_getchunk_phyg (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_bool   *bEmpty,
+                                        mng_uint32 *iSizex,
+                                        mng_uint32 *iSizey,
+                                        mng_uint8  *iUnit)
+{
+  mng_datap pData;
+  mng_phygp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PHYG, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_phygp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_pHYg)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *bEmpty = pChunk->bEmpty;            /* fill the fields */
+  *iSizex = pChunk->iSizex;
+  *iSizey = pChunk->iSizey;
+  *iUnit  = pChunk->iUnit;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PHYG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+mng_retcode MNG_DECL mng_getchunk_jhdr (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iWidth,
+                                        mng_uint32 *iHeight,
+                                        mng_uint8  *iColortype,
+                                        mng_uint8  *iImagesampledepth,
+                                        mng_uint8  *iImagecompression,
+                                        mng_uint8  *iImageinterlace,
+                                        mng_uint8  *iAlphasampledepth,
+                                        mng_uint8  *iAlphacompression,
+                                        mng_uint8  *iAlphafilter,
+                                        mng_uint8  *iAlphainterlace)
+{
+  mng_datap pData;
+  mng_jhdrp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_JHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_jhdrp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_JHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iWidth            = pChunk->iWidth; /* fill the fields */          
+  *iHeight           = pChunk->iHeight;
+  *iColortype        = pChunk->iColortype;
+  *iImagesampledepth = pChunk->iImagesampledepth;
+  *iImagecompression = pChunk->iImagecompression;
+  *iImageinterlace   = pChunk->iImageinterlace;
+  *iAlphasampledepth = pChunk->iAlphasampledepth;
+  *iAlphacompression = pChunk->iAlphacompression;
+  *iAlphafilter      = pChunk->iAlphafilter;
+  *iAlphainterlace   = pChunk->iAlphainterlace;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+mng_retcode MNG_DECL mng_getchunk_jdat (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iRawlen,
+                                        mng_ptr    *pRawdata)
+{
+  mng_datap pData;
+  mng_jdatp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_JDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_jdatp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_JDAT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iRawlen  = pChunk->iDatasize;       /* fill the fields */
+  *pRawdata = pChunk->pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_JDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+mng_retcode MNG_DECL mng_getchunk_jdaa (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iRawlen,
+                                        mng_ptr    *pRawdata)
+{
+  mng_datap pData;
+  mng_jdaap pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_JDAA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_jdaap)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_JDAA)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iRawlen  = pChunk->iDatasize;       /* fill the fields */
+  *pRawdata = pChunk->pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_JDAA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_getchunk_dhdr (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iObjectid,
+                                        mng_uint8  *iImagetype,
+                                        mng_uint8  *iDeltatype,
+                                        mng_uint32 *iBlockwidth,
+                                        mng_uint32 *iBlockheight,
+                                        mng_uint32 *iBlockx,
+                                        mng_uint32 *iBlocky)
+{
+  mng_datap pData;
+  mng_dhdrp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_dhdrp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_DHDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iObjectid    = pChunk->iObjectid;   /* fill the fields */
+  *iImagetype   = pChunk->iImagetype;
+  *iDeltatype   = pChunk->iDeltatype;
+  *iBlockwidth  = pChunk->iBlockwidth;
+  *iBlockheight = pChunk->iBlockheight;
+  *iBlockx      = pChunk->iBlockx;
+  *iBlocky      = pChunk->iBlocky;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_getchunk_prom (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint8  *iColortype,
+                                        mng_uint8  *iSampledepth,
+                                        mng_uint8  *iFilltype)
+{
+  mng_datap pData;
+  mng_promp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PROM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_promp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_PROM)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iColortype   = pChunk->iColortype;  /* fill the fields */
+  *iSampledepth = pChunk->iSampledepth;
+  *iFilltype    = pChunk->iFilltype;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_getchunk_pplt (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint8  *iDeltatype,
+                                        mng_uint32 *iCount)
+{
+  mng_datap pData;
+  mng_ppltp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PPLT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_ppltp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_PPLT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iDeltatype = pChunk->iDeltatype;    /* fill the fields */
+  *iCount     = pChunk->iCount;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_getchunk_pplt_entry (mng_handle hHandle,
+                                              mng_handle hChunk,
+                                              mng_uint32 iEntry,
+                                              mng_uint16 *iRed,
+                                              mng_uint16 *iGreen,
+                                              mng_uint16 *iBlue,
+                                              mng_uint16 *iAlpha,
+                                              mng_bool   *bUsed)
+{
+  mng_datap       pData;
+  mng_ppltp       pChunk;
+  mng_pplt_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PPLT_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_ppltp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_PPLT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  if (iEntry >= pChunk->iCount)        /* valid index ? */
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+
+  pEntry  = &pChunk->aEntries[iEntry]; /* address the entry */
+
+  *iRed   = pEntry->iRed;              /* fill the fields */
+  *iGreen = pEntry->iGreen;
+  *iBlue  = pEntry->iBlue;
+  *iAlpha = pEntry->iAlpha;
+  *bUsed  = pEntry->bUsed;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_PPLT_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_getchunk_drop (mng_handle   hHandle,
+                                        mng_handle   hChunk,
+                                        mng_uint32   *iCount,
+                                        mng_chunkidp *pChunknames)
+{
+  mng_datap pData;
+  mng_dropp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DROP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_dropp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_DROP)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iCount      = pChunk->iCount;       /* fill the fields */
+  *pChunknames = pChunk->pChunknames;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DROP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+mng_retcode MNG_DECL mng_getchunk_dbyk (mng_handle  hHandle,
+                                        mng_handle  hChunk,
+                                        mng_chunkid *iChunkname,
+                                        mng_uint8   *iPolarity,
+                                        mng_uint32  *iKeywordssize,
+                                        mng_pchar   *zKeywords)
+{
+  mng_datap pData;
+  mng_dbykp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DBYK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_dbykp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_DBYK)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iChunkname    = pChunk->iChunkname; /* fill the fields */  
+  *iPolarity     = pChunk->iPolarity;
+  *iKeywordssize = pChunk->iKeywordssize;
+  *zKeywords     = pChunk->zKeywords;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_DBYK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+mng_retcode MNG_DECL mng_getchunk_ordr (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iCount)
+{
+  mng_datap pData;
+  mng_ordrp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ORDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_ordrp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_ORDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iCount = pChunk->iCount;            /* fill the field */ 
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ORDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+mng_retcode MNG_DECL mng_getchunk_ordr_entry (mng_handle  hHandle,
+                                              mng_handle  hChunk,
+                                              mng_uint32  iEntry,
+                                              mng_chunkid *iChunkname,
+                                              mng_uint8   *iOrdertype)
+{
+  mng_datap       pData;
+  mng_ordrp       pChunk;
+  mng_ordr_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ORDR_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_ordrp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_ORDR)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  if (iEntry >= pChunk->iCount)        /* valid index ? */
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+
+  pEntry = pChunk->pEntries + iEntry;  /* address the proper entry */
+
+  *iChunkname = pEntry->iChunkname;    /* fill the fields */
+  *iOrdertype = pEntry->iOrdertype;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_ORDR_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode MNG_DECL mng_getchunk_magn (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint16 *iFirstid,
+                                        mng_uint16 *iLastid,
+                                        mng_uint16 *iMethodX,
+                                        mng_uint16 *iMX,
+                                        mng_uint16 *iMY,
+                                        mng_uint16 *iML,
+                                        mng_uint16 *iMR,
+                                        mng_uint16 *iMT,
+                                        mng_uint16 *iMB,
+                                        mng_uint16 *iMethodY)
+{
+  mng_datap pData;
+  mng_magnp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MAGN, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_magnp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_MAGN)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iFirstid = pChunk->iFirstid;        /* fill the fields */
+  *iLastid  = pChunk->iLastid;
+  *iMethodX = (mng_uint16)pChunk->iMethodX;
+  *iMX      = pChunk->iMX;
+  *iMY      = pChunk->iMY;
+  *iML      = pChunk->iML;
+  *iMR      = pChunk->iMR;
+  *iMT      = pChunk->iMT;
+  *iMB      = pChunk->iMB;
+  *iMethodY = (mng_uint16)pChunk->iMethodY;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_mpng (mng_handle hHandle,
+                                                mng_handle hChunk,
+                                                mng_uint32 *iFramewidth,
+                                                mng_uint32 *iFrameheight,
+                                                mng_uint16 *iNumplays,
+                                                mng_uint16 *iTickspersec,
+                                                mng_uint8  *iCompressionmethod,
+                                                mng_uint32 *iCount)
+{
+  mng_datap pData;
+  mng_mpngp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MPNG, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_mpngp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_mpNG)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+                                       /* fill the fields */
+  *iFramewidth        = pChunk->iFramewidth;
+  *iFrameheight       = pChunk->iFrameheight;
+  *iNumplays          = pChunk->iNumplays;
+  *iTickspersec       = pChunk->iTickspersec;
+  *iCompressionmethod = pChunk->iCompressionmethod;
+  *iCount             = pChunk->iFramessize / sizeof (mng_mpng_frame);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_EXT mng_retcode MNG_DECL mng_getchunk_mpng_frame (mng_handle hHandle,
+                                                      mng_handle hChunk,
+                                                      mng_uint32 iEntry,
+                                                      mng_uint32 *iX,
+                                                      mng_uint32 *iY,
+                                                      mng_uint32 *iWidth,
+                                                      mng_uint32 *iHeight,
+                                                      mng_int32  *iXoffset,
+                                                      mng_int32  *iYoffset,
+                                                      mng_uint16 *iTicks)
+{
+  mng_datap       pData;
+  mng_mpngp       pChunk;
+  mng_mpng_framep pFrame;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MPNG_FRAME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_mpngp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_mpNG)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+                                       /* valid index ? */
+  if (iEntry >= (pChunk->iFramessize / sizeof (mng_mpng_frame)))
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+
+  pFrame  = pChunk->pFrames + iEntry;  /* address the entry */
+                                       /* fill the fields */
+  *iX        = pFrame->iX;
+  *iY        = pFrame->iY;
+  *iWidth    = pFrame->iWidth;
+  *iHeight   = pFrame->iHeight;
+  *iXoffset  = pFrame->iXoffset;
+  *iYoffset  = pFrame->iYoffset;
+  *iTicks    = pFrame->iTicks;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_MPNG_FRAME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+mng_retcode MNG_DECL mng_getchunk_evnt (mng_handle hHandle,
+                                        mng_handle hChunk,
+                                        mng_uint32 *iCount)
+{
+  mng_datap pData;
+  mng_evntp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_EVNT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_evntp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_evNT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  *iCount = pChunk->iCount;            /* fill the fields */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_EVNT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_evnt_entry (mng_handle hHandle,
+                                              mng_handle hChunk,
+                                              mng_uint32 iEntry,
+                                              mng_uint8  *iEventtype,
+                                              mng_uint8  *iMasktype,
+                                              mng_int32  *iLeft,
+                                              mng_int32  *iRight,
+                                              mng_int32  *iTop,
+                                              mng_int32  *iBottom,
+                                              mng_uint16 *iObjectid,
+                                              mng_uint8  *iIndex,
+                                              mng_uint32 *iSegmentnamesize,
+                                              mng_pchar  *zSegmentname)
+{
+  mng_datap       pData;
+  mng_evntp       pChunk;
+  mng_evnt_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_EVNT_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_evntp)hChunk;          /* address the chunk */
+
+  if (pChunk->sHeader.iChunkname != MNG_UINT_evNT)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+
+  if (iEntry >= pChunk->iCount)        /* valid index ? */
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+
+  pEntry  = pChunk->pEntries + iEntry; /* address the entry */
+                                       /* fill the fields */
+  *iEventtype       = pEntry->iEventtype;
+  *iMasktype        = pEntry->iMasktype;
+  *iLeft            = pEntry->iLeft;    
+  *iRight           = pEntry->iRight;
+  *iTop             = pEntry->iTop;
+  *iBottom          = pEntry->iBottom;
+  *iObjectid        = pEntry->iObjectid;
+  *iIndex           = pEntry->iIndex;
+  *iSegmentnamesize = pEntry->iSegmentnamesize;
+  *zSegmentname     = pEntry->zSegmentname;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_EVNT_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getchunk_unknown (mng_handle  hHandle,
+                                           mng_handle  hChunk,
+                                           mng_chunkid *iChunkname,
+                                           mng_uint32  *iRawlen,
+                                           mng_ptr     *pRawdata)
+{
+  mng_datap          pData;
+  mng_unknown_chunkp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_UNKNOWN, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData  = (mng_datap)hHandle;         /* and make it addressable */
+  pChunk = (mng_unknown_chunkp)hChunk; /* address the chunk */
+
+  if (pChunk->sHeader.fCleanup != mng_free_unknown)
+    MNG_ERROR (pData, MNG_WRONGCHUNK)  /* ouch */
+                                       /* fill the fields */
+  *iChunkname = pChunk->sHeader.iChunkname;
+  *iRawlen    = pChunk->iDatasize;
+  *pRawdata   = pChunk->pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETCHUNK_UNKNOWN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_TERM
+MNG_LOCAL mng_bool check_term (mng_datap   pData,
+                               mng_chunkid iChunkname)
+{
+  mng_chunk_headerp pChunk = (mng_chunk_headerp)pData->pLastchunk;
+
+  if (!pChunk)                         /* nothing added yet ? */
+    return MNG_TRUE;
+                                       /* last added chunk is TERM ? */
+  if (pChunk->iChunkname != MNG_UINT_TERM)
+    return MNG_TRUE;
+                                       /* previous to last is MHDR ? */
+  if ((pChunk->pPrev) && (((mng_chunk_headerp)pChunk->pPrev)->iChunkname == MNG_UINT_MHDR))
+    return MNG_TRUE;
+
+  if (iChunkname == MNG_UINT_SEEK)     /* new chunk to be added is SEEK ? */
+    return MNG_TRUE;
+
+  return MNG_FALSE;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_ihdr (mng_handle hHandle,
+                                        mng_uint32 iWidth,
+                                        mng_uint32 iHeight,
+                                        mng_uint8  iBitdepth,
+                                        mng_uint8  iColortype,
+                                        mng_uint8  iCompression,
+                                        mng_uint8  iFilter,
+                                        mng_uint8  iInterlace)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_IHDR, mng_init_general, mng_free_general, mng_read_ihdr, mng_write_ihdr, mng_assign_general, 0, 0, sizeof(mng_ihdr)};
+#else
+          {MNG_UINT_IHDR, mng_init_ihdr, mng_free_ihdr, mng_read_ihdr, mng_write_ihdr, mng_assign_ihdr, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_IHDR))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_ihdr (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_IHDR, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+  ((mng_ihdrp)pChunk)->iWidth       = iWidth;
+  ((mng_ihdrp)pChunk)->iHeight      = iHeight;
+  ((mng_ihdrp)pChunk)->iBitdepth    = iBitdepth;
+  ((mng_ihdrp)pChunk)->iColortype   = iColortype;
+  ((mng_ihdrp)pChunk)->iCompression = iCompression;
+  ((mng_ihdrp)pChunk)->iFilter      = iFilter;
+  ((mng_ihdrp)pChunk)->iInterlace   = iInterlace;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_plte (mng_handle   hHandle,
+                                        mng_uint32   iCount,
+                                        mng_palette8 aPalette)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_PLTE, mng_init_general, mng_free_general, mng_read_plte, mng_write_plte, mng_assign_general, 0, 0, sizeof(mng_plte)};
+#else
+          {MNG_UINT_PLTE, mng_init_plte, mng_free_plte, mng_read_plte, mng_write_plte, mng_assign_plte, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PLTE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_PLTE))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_plte (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_PLTE, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_pltep)pChunk)->iEntrycount = iCount;
+  ((mng_pltep)pChunk)->bEmpty      = (mng_bool)(iCount == 0);
+
+  MNG_COPY (((mng_pltep)pChunk)->aEntries, aPalette, sizeof (mng_palette8));
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_idat (mng_handle hHandle,
+                                        mng_uint32 iRawlen,
+                                        mng_ptr    pRawdata)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_IDAT, mng_init_general, mng_free_idat, mng_read_idat, mng_write_idat, mng_assign_idat, 0, 0, sizeof(mng_idat)};
+#else
+          {MNG_UINT_IDAT, mng_init_idat, mng_free_idat, mng_read_idat, mng_write_idat, mng_assign_idat, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_IDAT))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_idat (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_IDAT, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_idatp)pChunk)->bEmpty    = (mng_bool)(iRawlen == 0);
+  ((mng_idatp)pChunk)->iDatasize = iRawlen;
+
+  if (iRawlen)
+  {
+    MNG_ALLOC (pData, ((mng_idatp)pChunk)->pData, iRawlen);
+    MNG_COPY (((mng_idatp)pChunk)->pData, pRawdata, iRawlen);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_iend (mng_handle hHandle)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_IEND, mng_init_general, mng_free_general, mng_read_iend, mng_write_iend, mng_assign_general, 0, 0, sizeof(mng_iend)};
+#else
+          {MNG_UINT_IEND, mng_init_iend, mng_free_iend, mng_read_iend, mng_write_iend, mng_assign_iend, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IEND, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_IEND))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_iend (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_IEND, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pData->iFirstchunkadded == MNG_UINT_IHDR) ||
+      (pData->iFirstchunkadded == MNG_UINT_JHDR)    )
+#else
+  if (pData->iFirstchunkadded == MNG_UINT_IHDR)
+#endif
+    pData->bCreating = MNG_FALSE;      /* should be last chunk !!! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_trns (mng_handle   hHandle,
+                                        mng_bool     bEmpty,
+                                        mng_bool     bGlobal,
+                                        mng_uint8    iType,
+                                        mng_uint32   iCount,
+                                        mng_uint8arr aAlphas,
+                                        mng_uint16   iGray,
+                                        mng_uint16   iRed,
+                                        mng_uint16   iGreen,
+                                        mng_uint16   iBlue,
+                                        mng_uint32   iRawlen,
+                                        mng_uint8arr aRawdata)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_tRNS, mng_init_general, mng_free_general, mng_read_trns, mng_write_trns, mng_assign_general, 0, 0, sizeof(mng_trns)};
+#else
+          {MNG_UINT_tRNS, mng_init_trns, mng_free_trns, mng_read_trns, mng_write_trns, mng_assign_trns, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TRNS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_tRNS))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_trns (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_tRNS, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_trnsp)pChunk)->bEmpty   = bEmpty;
+  ((mng_trnsp)pChunk)->bGlobal  = bGlobal;
+  ((mng_trnsp)pChunk)->iType    = iType;
+  ((mng_trnsp)pChunk)->iCount   = iCount;
+  ((mng_trnsp)pChunk)->iGray    = iGray;
+  ((mng_trnsp)pChunk)->iRed     = iRed;
+  ((mng_trnsp)pChunk)->iGreen   = iGreen;
+  ((mng_trnsp)pChunk)->iBlue    = iBlue;
+  ((mng_trnsp)pChunk)->iRawlen  = iRawlen;
+
+  MNG_COPY (((mng_trnsp)pChunk)->aEntries, aAlphas,  sizeof (mng_uint8arr));
+  MNG_COPY (((mng_trnsp)pChunk)->aRawdata, aRawdata, sizeof (mng_uint8arr));
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_gAMA
+mng_retcode MNG_DECL mng_putchunk_gama (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint32 iGamma)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_gAMA, mng_init_general, mng_free_general, mng_read_gama, mng_write_gama, mng_assign_general, 0, 0, sizeof(mng_gama)};
+#else
+          {MNG_UINT_gAMA, mng_init_gama, mng_free_gama, mng_read_gama, mng_write_gama, mng_assign_gama, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_GAMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_gAMA))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_gama (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_gAMA, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_gamap)pChunk)->bEmpty = bEmpty;
+  ((mng_gamap)pChunk)->iGamma = iGamma;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+mng_retcode MNG_DECL mng_putchunk_chrm (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint32 iWhitepointx,
+                                        mng_uint32 iWhitepointy,
+                                        mng_uint32 iRedx,
+                                        mng_uint32 iRedy,
+                                        mng_uint32 iGreenx,
+                                        mng_uint32 iGreeny,
+                                        mng_uint32 iBluex,
+                                        mng_uint32 iBluey)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_cHRM, mng_init_general, mng_free_general, mng_read_chrm, mng_write_chrm, mng_assign_general, 0, 0, sizeof(mng_chrm)};
+#else
+          {MNG_UINT_cHRM, mng_init_chrm, mng_free_chrm, mng_read_chrm, mng_write_chrm, mng_assign_chrm, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_CHRM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_cHRM))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_chrm (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_cHRM, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_chrmp)pChunk)->bEmpty       = bEmpty;
+  ((mng_chrmp)pChunk)->iWhitepointx = iWhitepointx;
+  ((mng_chrmp)pChunk)->iWhitepointy = iWhitepointy;
+  ((mng_chrmp)pChunk)->iRedx        = iRedx;
+  ((mng_chrmp)pChunk)->iRedy        = iRedy;
+  ((mng_chrmp)pChunk)->iGreenx      = iGreenx;
+  ((mng_chrmp)pChunk)->iGreeny      = iGreeny;
+  ((mng_chrmp)pChunk)->iBluex       = iBluex;
+  ((mng_chrmp)pChunk)->iBluey       = iBluey;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sRGB
+mng_retcode MNG_DECL mng_putchunk_srgb (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint8  iRenderingintent)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_sRGB, mng_init_general, mng_free_general, mng_read_srgb, mng_write_srgb, mng_assign_general, 0, 0, sizeof(mng_srgb)};
+#else
+          {MNG_UINT_sRGB, mng_init_srgb, mng_free_srgb, mng_read_srgb, mng_write_srgb, mng_assign_srgb, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SRGB, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_sRGB))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_srgb (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_sRGB, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_srgbp)pChunk)->bEmpty           = bEmpty;
+  ((mng_srgbp)pChunk)->iRenderingintent = iRenderingintent;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_retcode MNG_DECL mng_putchunk_iccp (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint32 iNamesize,
+                                        mng_pchar  zName,
+                                        mng_uint8  iCompression,
+                                        mng_uint32 iProfilesize,
+                                        mng_ptr    pProfile)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_iCCP, mng_init_general, mng_free_iccp, mng_read_iccp, mng_write_iccp, mng_assign_iccp, 0, 0, sizeof(mng_iccp)};
+#else
+          {MNG_UINT_iCCP, mng_init_iccp, mng_free_iccp, mng_read_iccp, mng_write_iccp, mng_assign_iccp, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ICCP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_iCCP))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_iccp (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_iCCP, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_iccpp)pChunk)->bEmpty       = bEmpty;
+  ((mng_iccpp)pChunk)->iNamesize    = iNamesize;
+  ((mng_iccpp)pChunk)->iCompression = iCompression;
+  ((mng_iccpp)pChunk)->iProfilesize = iProfilesize;
+
+  if (iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_iccpp)pChunk)->zName, iNamesize + 1);
+    MNG_COPY (((mng_iccpp)pChunk)->zName, zName, iNamesize);
+  }
+
+  if (iProfilesize)
+  {
+    MNG_ALLOC (pData, ((mng_iccpp)pChunk)->pProfile, iProfilesize);
+    MNG_COPY (((mng_iccpp)pChunk)->pProfile, pProfile, iProfilesize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+mng_retcode MNG_DECL mng_putchunk_text (mng_handle hHandle,
+                                        mng_uint32 iKeywordsize,
+                                        mng_pchar  zKeyword,
+                                        mng_uint32 iTextsize,
+                                        mng_pchar  zText)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_tEXt, mng_init_general, mng_free_text, mng_read_text, mng_write_text, mng_assign_text, 0, 0, sizeof(mng_text)};
+#else
+          {MNG_UINT_tEXt, mng_init_text, mng_free_text, mng_read_text, mng_write_text, mng_assign_text, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TEXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_tEXt))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_text (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_tEXt, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_textp)pChunk)->iKeywordsize = iKeywordsize;
+  ((mng_textp)pChunk)->iTextsize    = iTextsize;
+
+  if (iKeywordsize)
+  {
+    MNG_ALLOC (pData, ((mng_textp)pChunk)->zKeyword, iKeywordsize + 1);
+    MNG_COPY (((mng_textp)pChunk)->zKeyword, zKeyword, iKeywordsize);
+  }
+
+  if (iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_textp)pChunk)->zText, iTextsize + 1);
+    MNG_COPY (((mng_textp)pChunk)->zText, zText, iTextsize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TEXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+mng_retcode MNG_DECL mng_putchunk_ztxt (mng_handle hHandle,
+                                        mng_uint32 iKeywordsize,
+                                        mng_pchar  zKeyword,
+                                        mng_uint8  iCompression,
+                                        mng_uint32 iTextsize,
+                                        mng_pchar  zText)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_zTXt, mng_init_general, mng_free_ztxt, mng_read_ztxt, mng_write_ztxt, mng_assign_ztxt, 0, 0, sizeof(mng_ztxt)};
+#else
+          {MNG_UINT_zTXt, mng_init_ztxt, mng_free_ztxt, mng_read_ztxt, mng_write_ztxt, mng_assign_ztxt, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ZTXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_zTXt))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_ztxt (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_zTXt, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_ztxtp)pChunk)->iKeywordsize = iKeywordsize;
+  ((mng_ztxtp)pChunk)->iCompression = iCompression;
+  ((mng_ztxtp)pChunk)->iTextsize    = iTextsize;
+
+  if (iKeywordsize)
+  {
+    MNG_ALLOC (pData, ((mng_ztxtp)pChunk)->zKeyword, iKeywordsize + 1);
+    MNG_COPY (((mng_ztxtp)pChunk)->zKeyword, zKeyword, iKeywordsize);
+  }
+
+  if (iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_ztxtp)pChunk)->zText, iTextsize + 1);
+    MNG_COPY  (((mng_ztxtp)pChunk)->zText, zText, iTextsize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ZTXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+mng_retcode MNG_DECL mng_putchunk_itxt (mng_handle hHandle,
+                                        mng_uint32 iKeywordsize,
+                                        mng_pchar  zKeyword,
+                                        mng_uint8  iCompressionflag,
+                                        mng_uint8  iCompressionmethod,
+                                        mng_uint32 iLanguagesize,
+                                        mng_pchar  zLanguage,
+                                        mng_uint32 iTranslationsize,
+                                        mng_pchar  zTranslation,
+                                        mng_uint32 iTextsize,
+                                        mng_pchar  zText)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_iTXt, mng_init_general, mng_free_itxt, mng_read_itxt, mng_write_itxt, mng_assign_itxt, 0, 0, sizeof(mng_itxt)};
+#else
+          {MNG_UINT_iTXt, mng_init_itxt, mng_free_itxt, mng_read_itxt, mng_write_itxt, mng_assign_itxt, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ITXT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_iTXt))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_itxt (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_iTXt, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_itxtp)pChunk)->iKeywordsize       = iKeywordsize;
+  ((mng_itxtp)pChunk)->iCompressionflag   = iCompressionflag;
+  ((mng_itxtp)pChunk)->iCompressionmethod = iCompressionmethod;
+  ((mng_itxtp)pChunk)->iLanguagesize      = iLanguagesize;
+  ((mng_itxtp)pChunk)->iTranslationsize   = iTranslationsize;
+  ((mng_itxtp)pChunk)->iTextsize          = iTextsize;
+
+  if (iKeywordsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunk)->zKeyword, iKeywordsize + 1);
+    MNG_COPY (((mng_itxtp)pChunk)->zKeyword, zKeyword, iKeywordsize);
+  }
+
+  if (iLanguagesize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunk)->zLanguage, iLanguagesize + 1);
+    MNG_COPY (((mng_itxtp)pChunk)->zLanguage, zLanguage, iLanguagesize);
+  }
+
+  if (iTranslationsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunk)->zTranslation, iTranslationsize + 1);
+    MNG_COPY (((mng_itxtp)pChunk)->zTranslation, zTranslation, iTranslationsize);
+  }
+
+  if (iTextsize)
+  {
+    MNG_ALLOC (pData, ((mng_itxtp)pChunk)->zText, iTextsize + 1);
+    MNG_COPY (((mng_itxtp)pChunk)->zText, zText, iTextsize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ITXT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+mng_retcode MNG_DECL mng_putchunk_bkgd (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint8  iType,
+                                        mng_uint8  iIndex,
+                                        mng_uint16 iGray,
+                                        mng_uint16 iRed,
+                                        mng_uint16 iGreen,
+                                        mng_uint16 iBlue)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_bKGD, mng_init_general, mng_free_general, mng_read_bkgd, mng_write_bkgd, mng_assign_general, 0, 0, sizeof(mng_bkgd)};
+#else
+          {MNG_UINT_bKGD, mng_init_bkgd, mng_free_bkgd, mng_read_bkgd, mng_write_bkgd, mng_assign_bkgd, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_BKGD, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_bKGD))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_bkgd (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_bKGD, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_bkgdp)pChunk)->bEmpty = bEmpty;
+  ((mng_bkgdp)pChunk)->iType  = iType;
+  ((mng_bkgdp)pChunk)->iIndex = iIndex;
+  ((mng_bkgdp)pChunk)->iGray  = iGray;
+  ((mng_bkgdp)pChunk)->iRed   = iRed;
+  ((mng_bkgdp)pChunk)->iGreen = iGreen;
+  ((mng_bkgdp)pChunk)->iBlue  = iBlue;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYs
+mng_retcode MNG_DECL mng_putchunk_phys (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint32 iSizex,
+                                        mng_uint32 iSizey,
+                                        mng_uint8  iUnit)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_pHYs, mng_init_general, mng_free_general, mng_read_phys, mng_write_phys, mng_assign_general, 0, 0, sizeof(mng_phys)};
+#else
+          {MNG_UINT_pHYs, mng_init_phys, mng_free_phys, mng_read_phys, mng_write_phys, mng_assign_phys, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PHYS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_pHYs))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_phys (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_pHYs, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_physp)pChunk)->bEmpty = bEmpty;
+  ((mng_physp)pChunk)->iSizex = iSizex;
+  ((mng_physp)pChunk)->iSizey = iSizey;
+  ((mng_physp)pChunk)->iUnit  = iUnit;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PHYS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sBIT
+mng_retcode MNG_DECL mng_putchunk_sbit (mng_handle    hHandle,
+                                        mng_bool      bEmpty,
+                                        mng_uint8     iType,
+                                        mng_uint8arr4 aBits)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_sBIT, mng_init_general, mng_free_general, mng_read_sbit, mng_write_sbit, mng_assign_general, 0, 0, sizeof(mng_sbit)};
+#else
+          {MNG_UINT_sBIT, mng_init_sbit, mng_free_sbit, mng_read_sbit, mng_write_sbit, mng_assign_sbit, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SBIT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_sBIT))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_sbit (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_sBIT, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_sbitp)pChunk)->bEmpty   = bEmpty;
+  ((mng_sbitp)pChunk)->iType    = iType;
+  ((mng_sbitp)pChunk)->aBits[0] = aBits[0];
+  ((mng_sbitp)pChunk)->aBits[1] = aBits[1];
+  ((mng_sbitp)pChunk)->aBits[2] = aBits[2];
+  ((mng_sbitp)pChunk)->aBits[3] = aBits[3];
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SBIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+mng_retcode MNG_DECL mng_putchunk_splt (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint32 iNamesize,
+                                        mng_pchar  zName,
+                                        mng_uint8  iSampledepth,
+                                        mng_uint32 iEntrycount,
+                                        mng_ptr    pEntries)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_sPLT, mng_init_general, mng_free_splt, mng_read_splt, mng_write_splt, mng_assign_splt, 0, 0, sizeof(mng_splt)};
+#else
+          {MNG_UINT_sPLT, mng_init_splt, mng_free_splt, mng_read_splt, mng_write_splt, mng_assign_splt, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SPLT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_sPLT))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_splt (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_sPLT, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_spltp)pChunk)->bEmpty       = bEmpty;
+  ((mng_spltp)pChunk)->iNamesize    = iNamesize;
+  ((mng_spltp)pChunk)->iSampledepth = iSampledepth;
+  ((mng_spltp)pChunk)->iEntrycount  = iEntrycount;
+
+  if (iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_spltp)pChunk)->zName, iNamesize + 1);
+    MNG_COPY (((mng_spltp)pChunk)->zName, zName, iNamesize);
+  }
+
+  if (iEntrycount)
+  {
+    mng_uint32 iSize = iEntrycount * ((iSampledepth >> 1) + 2);
+
+    MNG_ALLOC (pData, ((mng_spltp)pChunk)->pEntries, iSize);
+    MNG_COPY  (((mng_spltp)pChunk)->pEntries, pEntries, iSize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+mng_retcode MNG_DECL mng_putchunk_hist (mng_handle    hHandle,
+                                        mng_uint32    iEntrycount,
+                                        mng_uint16arr aEntries)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_hIST, mng_init_general, mng_free_general, mng_read_hist, mng_write_hist, mng_assign_general, 0, 0, sizeof(mng_hist)};
+#else
+          {MNG_UINT_hIST, mng_init_hist, mng_free_hist, mng_read_hist, mng_write_hist, mng_assign_hist, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_HIST, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_hIST))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_hist (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_hIST, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_histp)pChunk)->iEntrycount = iEntrycount;
+
+  MNG_COPY (((mng_histp)pChunk)->aEntries, aEntries, sizeof (mng_uint16arr));
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_HIST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tIME
+mng_retcode MNG_DECL mng_putchunk_time (mng_handle hHandle,
+                                        mng_uint16 iYear,
+                                        mng_uint8  iMonth,
+                                        mng_uint8  iDay,
+                                        mng_uint8  iHour,
+                                        mng_uint8  iMinute,
+                                        mng_uint8  iSecond)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_tIME, mng_init_general, mng_free_general, mng_read_time, mng_write_time, mng_assign_general, 0, 0, sizeof(mng_time)};
+#else
+          {MNG_UINT_tIME, mng_init_time, mng_free_time, mng_read_time, mng_write_time, mng_assign_time, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TIME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_tIME))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_time (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_tIME, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_timep)pChunk)->iYear   = iYear;
+  ((mng_timep)pChunk)->iMonth  = iMonth;
+  ((mng_timep)pChunk)->iDay    = iDay;
+  ((mng_timep)pChunk)->iHour   = iHour;
+  ((mng_timep)pChunk)->iMinute = iMinute;
+  ((mng_timep)pChunk)->iSecond = iSecond;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TIME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_mhdr (mng_handle hHandle,
+                                        mng_uint32 iWidth,
+                                        mng_uint32 iHeight,
+                                        mng_uint32 iTicks,
+                                        mng_uint32 iLayercount,
+                                        mng_uint32 iFramecount,
+                                        mng_uint32 iPlaytime,
+                                        mng_uint32 iSimplicity)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_MHDR, mng_init_general, mng_free_general, mng_read_mhdr, mng_write_mhdr, mng_assign_general, 0, 0, sizeof(mng_mhdr)};
+#else
+          {MNG_UINT_MHDR, mng_init_mhdr, mng_free_mhdr, mng_read_mhdr, mng_write_mhdr, mng_assign_mhdr, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must be very first! */
+  if (pData->iFirstchunkadded != 0)
+    MNG_ERROR (pData, MNG_SEQUENCEERROR)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_MHDR))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_mhdr (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_MHDR, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_mhdrp)pChunk)->iWidth      = iWidth;
+  ((mng_mhdrp)pChunk)->iHeight     = iHeight;
+  ((mng_mhdrp)pChunk)->iTicks      = iTicks;
+  ((mng_mhdrp)pChunk)->iLayercount = iLayercount;
+  ((mng_mhdrp)pChunk)->iFramecount = iFramecount;
+  ((mng_mhdrp)pChunk)->iPlaytime   = iPlaytime;
+  ((mng_mhdrp)pChunk)->iSimplicity = iSimplicity;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_mend (mng_handle hHandle)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_MEND, mng_init_general, mng_free_general, mng_read_mend, mng_write_mend, mng_assign_general, 0, 0, sizeof(mng_mend)};
+#else
+          {MNG_UINT_MEND, mng_init_mend, mng_free_mend, mng_read_mend, mng_write_mend, mng_assign_mend, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MEND, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_MEND))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_mend (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_MEND, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+  pData->bCreating = MNG_FALSE;        /* should be last chunk !!! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+mng_retcode MNG_DECL mng_putchunk_loop (mng_handle  hHandle,
+                                        mng_uint8   iLevel,
+                                        mng_uint32  iRepeat,
+                                        mng_uint8   iTermination,
+                                        mng_uint32  iItermin,
+                                        mng_uint32  iItermax,
+                                        mng_uint32  iCount,
+                                        mng_uint32p pSignals)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_LOOP, mng_init_general, mng_free_loop, mng_read_loop, mng_write_loop, mng_assign_loop, 0, 0, sizeof(mng_loop)};
+#else
+          {MNG_UINT_LOOP, mng_init_loop, mng_free_loop, mng_read_loop, mng_write_loop, mng_assign_loop, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_LOOP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_LOOP))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_loop (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_LOOP, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_loopp)pChunk)->iLevel       = iLevel;
+  ((mng_loopp)pChunk)->iRepeat      = iRepeat;
+  ((mng_loopp)pChunk)->iTermination = iTermination;
+  ((mng_loopp)pChunk)->iItermin     = iItermin;
+  ((mng_loopp)pChunk)->iItermax     = iItermax;
+  ((mng_loopp)pChunk)->iCount       = iCount;
+  ((mng_loopp)pChunk)->pSignals     = pSignals;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_LOOP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_endl (mng_handle hHandle,
+                                        mng_uint8  iLevel)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_ENDL, mng_init_general, mng_free_general, mng_read_endl, mng_write_endl, mng_assign_general, 0, 0, sizeof(mng_endl)};
+#else
+          {MNG_UINT_ENDL, mng_init_endl, mng_free_endl, mng_read_endl, mng_write_endl, mng_assign_endl, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ENDL, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_ENDL))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_endl (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_ENDL, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_endlp)pChunk)->iLevel = iLevel;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+mng_retcode MNG_DECL mng_putchunk_defi (mng_handle hHandle,
+                                        mng_uint16 iObjectid,
+                                        mng_uint8  iDonotshow,
+                                        mng_uint8  iConcrete,
+                                        mng_bool   bHasloca,
+                                        mng_int32  iXlocation,
+                                        mng_int32  iYlocation,
+                                        mng_bool   bHasclip,
+                                        mng_int32  iLeftcb,
+                                        mng_int32  iRightcb,
+                                        mng_int32  iTopcb,
+                                        mng_int32  iBottomcb)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_DEFI, mng_init_general, mng_free_general, mng_read_defi, mng_write_defi, mng_assign_general, 0, 0, sizeof(mng_defi)};
+#else
+          {MNG_UINT_DEFI, mng_init_defi, mng_free_defi, mng_read_defi, mng_write_defi, mng_assign_defi, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DEFI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_DEFI))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_defi (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_DEFI, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_defip)pChunk)->iObjectid  = iObjectid;
+  ((mng_defip)pChunk)->iDonotshow = iDonotshow;
+  ((mng_defip)pChunk)->iConcrete  = iConcrete;
+  ((mng_defip)pChunk)->bHasloca   = bHasloca;
+  ((mng_defip)pChunk)->iXlocation = iXlocation;
+  ((mng_defip)pChunk)->iYlocation = iYlocation;
+  ((mng_defip)pChunk)->bHasclip   = bHasclip;
+  ((mng_defip)pChunk)->iLeftcb    = iLeftcb;
+  ((mng_defip)pChunk)->iRightcb   = iRightcb;
+  ((mng_defip)pChunk)->iTopcb     = iTopcb;
+  ((mng_defip)pChunk)->iBottomcb  = iBottomcb;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BASI
+mng_retcode MNG_DECL mng_putchunk_basi (mng_handle hHandle,
+                                        mng_uint32 iWidth,
+                                        mng_uint32 iHeight,
+                                        mng_uint8  iBitdepth,
+                                        mng_uint8  iColortype,
+                                        mng_uint8  iCompression,
+                                        mng_uint8  iFilter,
+                                        mng_uint8  iInterlace,
+                                        mng_uint16 iRed,
+                                        mng_uint16 iGreen,
+                                        mng_uint16 iBlue,
+                                        mng_uint16 iAlpha,
+                                        mng_uint8  iViewable)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_BASI, mng_init_general, mng_free_general, mng_read_basi, mng_write_basi, mng_assign_general, 0, 0, sizeof(mng_basi)};
+#else
+          {MNG_UINT_BASI, mng_init_basi, mng_free_basi, mng_read_basi, mng_write_basi, mng_assign_basi, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_BASI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_BASI))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_basi (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_BASI, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_basip)pChunk)->iWidth       = iWidth;
+  ((mng_basip)pChunk)->iHeight      = iHeight;
+  ((mng_basip)pChunk)->iBitdepth    = iBitdepth;
+  ((mng_basip)pChunk)->iColortype   = iColortype;
+  ((mng_basip)pChunk)->iCompression = iCompression;
+  ((mng_basip)pChunk)->iFilter      = iFilter;
+  ((mng_basip)pChunk)->iInterlace   = iInterlace;
+  ((mng_basip)pChunk)->iRed         = iRed;
+  ((mng_basip)pChunk)->iGreen       = iGreen;
+  ((mng_basip)pChunk)->iBlue        = iBlue;
+  ((mng_basip)pChunk)->iAlpha       = iAlpha;
+  ((mng_basip)pChunk)->iViewable    = iViewable;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLON
+mng_retcode MNG_DECL mng_putchunk_clon (mng_handle hHandle,
+                                        mng_uint16 iSourceid,
+                                        mng_uint16 iCloneid,
+                                        mng_uint8  iClonetype,
+                                        mng_uint8  iDonotshow,
+                                        mng_uint8  iConcrete,
+                                        mng_bool   bHasloca,
+                                        mng_uint8  iLocationtype,
+                                        mng_int32  iLocationx,
+                                        mng_int32  iLocationy)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_CLON, mng_init_general, mng_free_general, mng_read_clon, mng_write_clon, mng_assign_general, 0, 0, sizeof(mng_clon)};
+#else
+          {MNG_UINT_CLON, mng_init_clon, mng_free_clon, mng_read_clon, mng_write_clon, mng_assign_clon, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_CLON, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_CLON))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_clon (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_CLON, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_clonp)pChunk)->iSourceid     = iSourceid;
+  ((mng_clonp)pChunk)->iCloneid      = iCloneid;
+  ((mng_clonp)pChunk)->iClonetype    = iClonetype;
+  ((mng_clonp)pChunk)->iDonotshow    = iDonotshow;
+  ((mng_clonp)pChunk)->iConcrete     = iConcrete;
+  ((mng_clonp)pChunk)->bHasloca      = bHasloca;
+  ((mng_clonp)pChunk)->iLocationtype = iLocationtype;
+  ((mng_clonp)pChunk)->iLocationx    = iLocationx;
+  ((mng_clonp)pChunk)->iLocationy    = iLocationy;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode MNG_DECL mng_putchunk_past (mng_handle hHandle,
+                                        mng_uint16 iDestid,
+                                        mng_uint8  iTargettype,
+                                        mng_int32  iTargetx,
+                                        mng_int32  iTargety,
+                                        mng_uint32 iCount)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_PAST, mng_init_general, mng_free_past, mng_read_past, mng_write_past, mng_assign_past, 0, 0, sizeof(mng_past)};
+#else
+          {MNG_UINT_PAST, mng_init_past, mng_free_past, mng_read_past, mng_write_past, mng_assign_past, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PAST, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_PAST))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_past (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_PAST, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_pastp)pChunk)->iDestid     = iDestid;
+  ((mng_pastp)pChunk)->iTargettype = iTargettype;
+  ((mng_pastp)pChunk)->iTargetx    = iTargetx;
+  ((mng_pastp)pChunk)->iTargety    = iTargety;
+  ((mng_pastp)pChunk)->iCount      = iCount;
+
+  if (iCount)
+    MNG_ALLOC (pData, ((mng_pastp)pChunk)->pSources, iCount * sizeof (mng_past_source));
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PAST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode MNG_DECL mng_putchunk_past_src (mng_handle hHandle,
+                                            mng_uint32 iEntry,
+                                            mng_uint16 iSourceid,
+                                            mng_uint8  iComposition,
+                                            mng_uint8  iOrientation,
+                                            mng_uint8  iOffsettype,
+                                            mng_int32  iOffsetx,
+                                            mng_int32  iOffsety,
+                                            mng_uint8  iBoundarytype,
+                                            mng_int32  iBoundaryl,
+                                            mng_int32  iBoundaryr,
+                                            mng_int32  iBoundaryt,
+                                            mng_int32  iBoundaryb)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_past_sourcep pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PAST_SRC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+
+  pChunk = pData->pLastchunk;          /* last one must have been PAST ! */
+
+  if (((mng_chunk_headerp)pChunk)->iChunkname != MNG_UINT_PAST)
+    MNG_ERROR (pData, MNG_NOCORRCHUNK)
+                                       /* index out of bounds ? */
+  if (iEntry >= ((mng_pastp)pChunk)->iCount)
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+                                       /* address proper entry */
+  pEntry = ((mng_pastp)pChunk)->pSources + iEntry;
+
+  pEntry->iSourceid     = iSourceid;   /* fill entry */
+  pEntry->iComposition  = iComposition;
+  pEntry->iOrientation  = iOrientation;
+  pEntry->iOffsettype   = iOffsettype;
+  pEntry->iOffsetx      = iOffsetx;
+  pEntry->iOffsety      = iOffsety;
+  pEntry->iBoundarytype = iBoundarytype;
+  pEntry->iBoundaryl    = iBoundaryl;
+  pEntry->iBoundaryr    = iBoundaryr;
+  pEntry->iBoundaryt    = iBoundaryt;
+  pEntry->iBoundaryb    = iBoundaryb;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PAST_SRC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+mng_retcode MNG_DECL mng_putchunk_disc (mng_handle  hHandle,
+                                        mng_uint32  iCount,
+                                        mng_uint16p pObjectids)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_DISC, mng_init_general, mng_free_disc, mng_read_disc, mng_write_disc, mng_assign_disc, 0, 0, sizeof(mng_disc)};
+#else
+          {MNG_UINT_DISC, mng_init_disc, mng_free_disc, mng_read_disc, mng_write_disc, mng_assign_disc, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DISC, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_DISC))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_disc (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_DISC, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_discp)pChunk)->iCount = iCount;
+
+  if (iCount)
+  {
+    mng_uint32 iSize = iCount * sizeof (mng_uint32);
+
+    MNG_ALLOC (pData, ((mng_discp)pChunk)->pObjectids, iSize);
+    MNG_COPY (((mng_discp)pChunk)->pObjectids, pObjectids, iSize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DISC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BACK
+mng_retcode MNG_DECL mng_putchunk_back (mng_handle hHandle,
+                                        mng_uint16 iRed,
+                                        mng_uint16 iGreen,
+                                        mng_uint16 iBlue,
+                                        mng_uint8  iMandatory,
+                                        mng_uint16 iImageid,
+                                        mng_uint8  iTile)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_BACK, mng_init_general, mng_free_general, mng_read_back, mng_write_back, mng_assign_general, 0, 0, sizeof(mng_back)};
+#else
+          {MNG_UINT_BACK, mng_init_back, mng_free_back, mng_read_back, mng_write_back, mng_assign_back, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_BACK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_BACK))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_back (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_BACK, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_backp)pChunk)->iRed       = iRed;
+  ((mng_backp)pChunk)->iGreen     = iGreen;
+  ((mng_backp)pChunk)->iBlue      = iBlue;
+  ((mng_backp)pChunk)->iMandatory = iMandatory;
+  ((mng_backp)pChunk)->iImageid   = iImageid;
+  ((mng_backp)pChunk)->iTile      = iTile;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+mng_retcode MNG_DECL mng_putchunk_fram (mng_handle  hHandle,
+                                        mng_bool    bEmpty,
+                                        mng_uint8   iMode,
+                                        mng_uint32  iNamesize,
+                                        mng_pchar   zName,
+                                        mng_uint8   iChangedelay,
+                                        mng_uint8   iChangetimeout,
+                                        mng_uint8   iChangeclipping,
+                                        mng_uint8   iChangesyncid,
+                                        mng_uint32  iDelay,
+                                        mng_uint32  iTimeout,
+                                        mng_uint8   iBoundarytype,
+                                        mng_int32   iBoundaryl,
+                                        mng_int32   iBoundaryr,
+                                        mng_int32   iBoundaryt,
+                                        mng_int32   iBoundaryb,
+                                        mng_uint32  iCount,
+                                        mng_uint32p pSyncids)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_FRAM, mng_init_general, mng_free_fram, mng_read_fram, mng_write_fram, mng_assign_fram, 0, 0, sizeof(mng_fram)};
+#else
+          {MNG_UINT_FRAM, mng_init_fram, mng_free_fram, mng_read_fram, mng_write_fram, mng_assign_fram, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_FRAM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_FRAM))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_fram (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_FRAM, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_framp)pChunk)->bEmpty          = bEmpty;
+  ((mng_framp)pChunk)->iMode           = iMode;
+  ((mng_framp)pChunk)->iNamesize       = iNamesize;
+  ((mng_framp)pChunk)->iChangedelay    = iChangedelay;
+  ((mng_framp)pChunk)->iChangetimeout  = iChangetimeout;
+  ((mng_framp)pChunk)->iChangeclipping = iChangeclipping;
+  ((mng_framp)pChunk)->iChangesyncid   = iChangesyncid;
+  ((mng_framp)pChunk)->iDelay          = iDelay;
+  ((mng_framp)pChunk)->iTimeout        = iTimeout;
+  ((mng_framp)pChunk)->iBoundarytype   = iBoundarytype;
+  ((mng_framp)pChunk)->iBoundaryl      = iBoundaryl;
+  ((mng_framp)pChunk)->iBoundaryr      = iBoundaryr;
+  ((mng_framp)pChunk)->iBoundaryt      = iBoundaryt;
+  ((mng_framp)pChunk)->iBoundaryb      = iBoundaryb;
+  ((mng_framp)pChunk)->iCount          = iCount;
+
+  if (iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_framp)pChunk)->zName, iNamesize + 1);
+    MNG_COPY (((mng_framp)pChunk)->zName, zName, iNamesize);
+  }
+
+  if (iCount)
+  {
+    mng_uint32 iSize = iCount * sizeof (mng_uint32);
+
+    MNG_ALLOC (pData, ((mng_framp)pChunk)->pSyncids, iSize);
+    MNG_COPY (((mng_framp)pChunk)->pSyncids, pSyncids, iSize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_FRAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MOVE
+mng_retcode MNG_DECL mng_putchunk_move (mng_handle hHandle,
+                                        mng_uint16 iFirstid,
+                                        mng_uint16 iLastid,
+                                        mng_uint8  iMovetype,
+                                        mng_int32  iMovex,
+                                        mng_int32  iMovey)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_MOVE, mng_init_general, mng_free_general, mng_read_move, mng_write_move, mng_assign_general, 0, 0, sizeof(mng_move)};
+#else
+          {MNG_UINT_MOVE, mng_init_move, mng_free_move, mng_read_move, mng_write_move, mng_assign_move, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MOVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_MOVE))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_move (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_MOVE, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_movep)pChunk)->iFirstid  = iFirstid;
+  ((mng_movep)pChunk)->iLastid   = iLastid;
+  ((mng_movep)pChunk)->iMovetype = iMovetype;
+  ((mng_movep)pChunk)->iMovex    = iMovex;
+  ((mng_movep)pChunk)->iMovey    = iMovey;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLIP
+mng_retcode MNG_DECL mng_putchunk_clip (mng_handle hHandle,
+                                        mng_uint16 iFirstid,
+                                        mng_uint16 iLastid,
+                                        mng_uint8  iCliptype,
+                                        mng_int32  iClipl,
+                                        mng_int32  iClipr,
+                                        mng_int32  iClipt,
+                                        mng_int32  iClipb)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_CLIP, mng_init_general, mng_free_general, mng_read_clip, mng_write_clip, mng_assign_general, 0, 0, sizeof(mng_clip)};
+#else
+          {MNG_UINT_CLIP, mng_init_clip, mng_free_clip, mng_read_clip, mng_write_clip, mng_assign_clip, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_CLIP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_CLIP))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_clip (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_CLIP, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_clipp)pChunk)->iFirstid  = iFirstid;
+  ((mng_clipp)pChunk)->iLastid   = iLastid;
+  ((mng_clipp)pChunk)->iCliptype = iCliptype;
+  ((mng_clipp)pChunk)->iClipl    = iClipl;
+  ((mng_clipp)pChunk)->iClipr    = iClipr;
+  ((mng_clipp)pChunk)->iClipt    = iClipt;
+  ((mng_clipp)pChunk)->iClipb    = iClipb;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SHOW
+mng_retcode MNG_DECL mng_putchunk_show (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint16 iFirstid,
+                                        mng_uint16 iLastid,
+                                        mng_uint8  iMode)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_SHOW, mng_init_general, mng_free_general, mng_read_show, mng_write_show, mng_assign_general, 0, 0, sizeof(mng_show)};
+#else
+          {MNG_UINT_SHOW, mng_init_show, mng_free_show, mng_read_show, mng_write_show, mng_assign_show, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SHOW, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_SHOW))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_show (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_SHOW, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_showp)pChunk)->bEmpty   = bEmpty;
+  ((mng_showp)pChunk)->iFirstid = iFirstid;
+  ((mng_showp)pChunk)->iLastid  = iLastid;
+  ((mng_showp)pChunk)->iMode    = iMode;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_TERM
+mng_retcode MNG_DECL mng_putchunk_term (mng_handle hHandle,
+                                        mng_uint8  iTermaction,
+                                        mng_uint8  iIteraction,
+                                        mng_uint32 iDelay,
+                                        mng_uint32 iItermax)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_TERM, mng_init_general, mng_free_general, mng_read_term, mng_write_term, mng_assign_general, 0, 0, sizeof(mng_term)};
+#else
+          {MNG_UINT_TERM, mng_init_term, mng_free_term, mng_read_term, mng_write_term, mng_assign_term, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TERM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_term (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_TERM, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_termp)pChunk)->iTermaction = iTermaction;
+  ((mng_termp)pChunk)->iIteraction = iIteraction;
+  ((mng_termp)pChunk)->iDelay      = iDelay;
+  ((mng_termp)pChunk)->iItermax    = iItermax;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode MNG_DECL mng_putchunk_save (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint8  iOffsettype,
+                                        mng_uint32 iCount)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_SAVE, mng_init_general, mng_free_save, mng_read_save, mng_write_save, mng_assign_save, 0, 0, sizeof(mng_save)};
+#else
+          {MNG_UINT_SAVE, mng_init_save, mng_free_save, mng_read_save, mng_write_save, mng_assign_save, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SAVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_SAVE))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_save (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_SAVE, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_savep)pChunk)->bEmpty      = bEmpty;
+  ((mng_savep)pChunk)->iOffsettype = iOffsettype;
+  ((mng_savep)pChunk)->iCount      = iCount;
+
+  if (iCount)
+    MNG_ALLOC (pData, ((mng_savep)pChunk)->pEntries, iCount * sizeof (mng_save_entry));
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_save_entry (mng_handle     hHandle,
+                                              mng_uint32     iEntry,
+                                              mng_uint8      iEntrytype,
+                                              mng_uint32arr2 iOffset,
+                                              mng_uint32arr2 iStarttime,
+                                              mng_uint32     iLayernr,
+                                              mng_uint32     iFramenr,
+                                              mng_uint32     iNamesize,
+                                              mng_pchar      zName)
+{
+  mng_datap       pData;
+  mng_chunkp      pChunk;
+  mng_save_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SAVE_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+
+  pChunk = pData->pLastchunk;          /* last one must have been SAVE ! */
+
+  if (((mng_chunk_headerp)pChunk)->iChunkname != MNG_UINT_SAVE)
+    MNG_ERROR (pData, MNG_NOCORRCHUNK)
+                                       /* index out of bounds ? */
+  if (iEntry >= ((mng_savep)pChunk)->iCount)
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+                                       /* address proper entry */
+  pEntry = ((mng_savep)pChunk)->pEntries + iEntry;
+
+  pEntry->iEntrytype    = iEntrytype;  /* fill entry */
+  pEntry->iOffset[0]    = iOffset[0];
+  pEntry->iOffset[1]    = iOffset[1];
+  pEntry->iStarttime[0] = iStarttime[0];
+  pEntry->iStarttime[1] = iStarttime[1];
+  pEntry->iLayernr      = iLayernr;
+  pEntry->iFramenr      = iFramenr;
+  pEntry->iNamesize     = iNamesize;
+
+  if (iNamesize)
+  {
+    MNG_ALLOC (pData, pEntry->zName, iNamesize + 1);
+    MNG_COPY (pEntry->zName, zName, iNamesize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SAVE_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode MNG_DECL mng_putchunk_seek (mng_handle hHandle,
+                                        mng_uint32 iNamesize,
+                                        mng_pchar  zName)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_SEEK, mng_init_general, mng_free_seek, mng_read_seek, mng_write_seek, mng_assign_seek, 0, 0, sizeof(mng_seek)};
+#else
+          {MNG_UINT_SEEK, mng_init_seek, mng_free_seek, mng_read_seek, mng_write_seek, mng_assign_seek, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SEEK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_SEEK))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_seek (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_SEEK, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_seekp)pChunk)->iNamesize = iNamesize;
+
+  if (iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_seekp)pChunk)->zName, iNamesize + 1);
+    MNG_COPY (((mng_seekp)pChunk)->zName, zName, iNamesize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+mng_retcode MNG_DECL mng_putchunk_expi (mng_handle hHandle,
+                                        mng_uint16 iSnapshotid,
+                                        mng_uint32 iNamesize,
+                                        mng_pchar  zName)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_eXPI, mng_init_general, mng_free_expi, mng_read_expi, mng_write_expi, mng_assign_general, 0, 0, sizeof(mng_expi)};
+#else
+          {MNG_UINT_eXPI, mng_init_expi, mng_free_expi, mng_read_expi, mng_write_expi, mng_assign_expi, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_EXPI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_eXPI))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_expi (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_eXPI, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_expip)pChunk)->iSnapshotid = iSnapshotid;
+  ((mng_expip)pChunk)->iNamesize   = iNamesize;
+
+  if (iNamesize)
+  {
+    MNG_ALLOC (pData, ((mng_expip)pChunk)->zName, iNamesize + 1);
+    MNG_COPY (((mng_expip)pChunk)->zName, zName, iNamesize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_EXPI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_fPRI
+mng_retcode MNG_DECL mng_putchunk_fpri (mng_handle hHandle,
+                                        mng_uint8  iDeltatype,
+                                        mng_uint8  iPriority)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_fPRI, mng_init_general, mng_free_general, mng_read_fpri, mng_write_fpri, mng_assign_general, 0, 0, sizeof(mng_fpri)};
+#else
+          {MNG_UINT_fPRI, mng_init_fpri, mng_free_fpri, mng_read_fpri, mng_write_fpri, mng_assign_fpri, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_FPRI, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_fPRI))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_fpri (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_fPRI, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_fprip)pChunk)->iDeltatype = iDeltatype;
+  ((mng_fprip)pChunk)->iPriority  = iPriority;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_FPRI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+mng_retcode MNG_DECL mng_putchunk_need (mng_handle hHandle,
+                                        mng_uint32 iKeywordssize,
+                                        mng_pchar  zKeywords)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_nEED, mng_init_general, mng_free_need, mng_read_need, mng_write_need, mng_assign_need, 0, 0, sizeof(mng_need)};
+#else
+          {MNG_UINT_nEED, mng_init_need, mng_free_need, mng_read_need, mng_write_need, mng_assign_need, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_NEED, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_nEED))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_need (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_nEED, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_needp)pChunk)->iKeywordssize = iKeywordssize;
+
+  if (iKeywordssize)
+  {
+    MNG_ALLOC (pData, ((mng_needp)pChunk)->zKeywords, iKeywordssize + 1);
+    MNG_COPY (((mng_needp)pChunk)->zKeywords, zKeywords, iKeywordssize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_NEED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYg
+mng_retcode MNG_DECL mng_putchunk_phyg (mng_handle hHandle,
+                                        mng_bool   bEmpty,
+                                        mng_uint32 iSizex,
+                                        mng_uint32 iSizey,
+                                        mng_uint8  iUnit)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_pHYg, mng_init_general, mng_free_general, mng_read_phyg, mng_write_phyg, mng_assign_general, 0, 0, sizeof(mng_phyg)};
+#else
+          {MNG_UINT_pHYg, mng_init_phyg, mng_free_phyg, mng_read_phyg, mng_write_phyg, mng_assign_phyg, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PHYG, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_pHYg))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_phyg (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_pHYg, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_phygp)pChunk)->bEmpty = bEmpty;
+  ((mng_phygp)pChunk)->iSizex = iSizex;
+  ((mng_phygp)pChunk)->iSizey = iSizey;
+  ((mng_phygp)pChunk)->iUnit  = iUnit;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PHYG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+mng_retcode MNG_DECL mng_putchunk_jhdr (mng_handle hHandle,
+                                        mng_uint32 iWidth,
+                                        mng_uint32 iHeight,
+                                        mng_uint8  iColortype,
+                                        mng_uint8  iImagesampledepth,
+                                        mng_uint8  iImagecompression,
+                                        mng_uint8  iImageinterlace,
+                                        mng_uint8  iAlphasampledepth,
+                                        mng_uint8  iAlphacompression,
+                                        mng_uint8  iAlphafilter,
+                                        mng_uint8  iAlphainterlace)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_JHDR, mng_init_general, mng_free_general, mng_read_jhdr, mng_write_jhdr, mng_assign_general, 0, 0, sizeof(mng_jhdr)};
+#else
+          {MNG_UINT_JHDR, mng_init_jhdr, mng_free_jhdr, mng_read_jhdr, mng_write_jhdr, mng_assign_jhdr, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_JHDR))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_jhdr (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_JHDR, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_jhdrp)pChunk)->iWidth            = iWidth;
+  ((mng_jhdrp)pChunk)->iHeight           = iHeight;
+  ((mng_jhdrp)pChunk)->iColortype        = iColortype;
+  ((mng_jhdrp)pChunk)->iImagesampledepth = iImagesampledepth;
+  ((mng_jhdrp)pChunk)->iImagecompression = iImagecompression;
+  ((mng_jhdrp)pChunk)->iImageinterlace   = iImageinterlace;
+  ((mng_jhdrp)pChunk)->iAlphasampledepth = iAlphasampledepth;
+  ((mng_jhdrp)pChunk)->iAlphacompression = iAlphacompression;
+  ((mng_jhdrp)pChunk)->iAlphafilter      = iAlphafilter;
+  ((mng_jhdrp)pChunk)->iAlphainterlace   = iAlphainterlace;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+mng_retcode MNG_DECL mng_putchunk_jdat (mng_handle hHandle,
+                                        mng_uint32 iRawlen,
+                                        mng_ptr    pRawdata)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_JDAT, mng_init_general, mng_free_jdat, mng_read_jdat, mng_write_jdat, mng_assign_jdat, 0, 0, sizeof(mng_jdat)};
+#else
+          {MNG_UINT_JDAT, mng_init_jdat, mng_free_jdat, mng_read_jdat, mng_write_jdat, mng_assign_jdat, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR or JHDR first! */
+  if ((pData->iFirstchunkadded != MNG_UINT_MHDR) &&
+      (pData->iFirstchunkadded != MNG_UINT_JHDR)    )
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_JDAT))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_jdat (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_JDAT, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_jdatp)pChunk)->iDatasize = iRawlen;
+
+  if (iRawlen)
+  {
+    MNG_ALLOC (pData, ((mng_jdatp)pChunk)->pData, iRawlen);
+    MNG_COPY (((mng_jdatp)pChunk)->pData, pRawdata, iRawlen);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+#endif /*  MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+mng_retcode MNG_DECL mng_putchunk_jdaa (mng_handle hHandle,
+                                        mng_uint32 iRawlen,
+                                        mng_ptr    pRawdata)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_JDAA, mng_init_general, mng_free_jdaa, mng_read_jdaa, mng_write_jdaa, mng_assign_jdaa, 0, 0, sizeof(mng_jdaa)};
+#else
+          {MNG_UINT_JDAA, mng_init_jdaa, mng_free_jdaa, mng_read_jdaa, mng_write_jdaa, mng_assign_jdaa, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JDAA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR or JHDR first! */
+  if ((pData->iFirstchunkadded != MNG_UINT_MHDR) &&
+      (pData->iFirstchunkadded != MNG_UINT_JHDR)    )
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_JDAA))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_jdaa (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_JDAA, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_jdaap)pChunk)->iDatasize = iRawlen;
+
+  if (iRawlen)
+  {
+    MNG_ALLOC (pData, ((mng_jdaap)pChunk)->pData, iRawlen);
+    MNG_COPY (((mng_jdaap)pChunk)->pData, pRawdata, iRawlen);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JDAA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+#endif /*  MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+mng_retcode MNG_DECL mng_putchunk_jsep (mng_handle hHandle)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_JSEP, mng_init_general, mng_free_general, mng_read_jsep, mng_write_jsep, mng_assign_general, 0, 0, sizeof(mng_jsep)};
+#else
+          {MNG_UINT_JSEP, mng_init_jsep, mng_free_jsep, mng_read_jsep, mng_write_jsep, mng_assign_jsep, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JSEP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR or JHDR first! */
+  if ((pData->iFirstchunkadded != MNG_UINT_MHDR) &&
+      (pData->iFirstchunkadded != MNG_UINT_JHDR)    )
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_JSEP))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_jsep (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_JSEP, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_JSEP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_putchunk_dhdr (mng_handle hHandle,
+                                        mng_uint16 iObjectid,
+                                        mng_uint8  iImagetype,
+                                        mng_uint8  iDeltatype,
+                                        mng_uint32 iBlockwidth,
+                                        mng_uint32 iBlockheight,
+                                        mng_uint32 iBlockx,
+                                        mng_uint32 iBlocky)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_DHDR, mng_init_general, mng_free_general, mng_read_dhdr, mng_write_dhdr, mng_assign_general, 0, 0, sizeof(mng_dhdr)};
+#else
+          {MNG_UINT_DHDR, mng_init_dhdr, mng_free_dhdr, mng_read_dhdr, mng_write_dhdr, mng_assign_dhdr, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DHDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_DHDR))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_dhdr (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_DHDR, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_dhdrp)pChunk)->iObjectid    = iObjectid;
+  ((mng_dhdrp)pChunk)->iImagetype   = iImagetype;
+  ((mng_dhdrp)pChunk)->iDeltatype   = iDeltatype;
+  ((mng_dhdrp)pChunk)->iBlockwidth  = iBlockwidth;
+  ((mng_dhdrp)pChunk)->iBlockheight = iBlockheight;
+  ((mng_dhdrp)pChunk)->iBlockx      = iBlockx;
+  ((mng_dhdrp)pChunk)->iBlocky      = iBlocky;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_putchunk_prom (mng_handle hHandle,
+                                        mng_uint8  iColortype,
+                                        mng_uint8  iSampledepth,
+                                        mng_uint8  iFilltype)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_PROM, mng_init_general, mng_free_general, mng_read_prom, mng_write_prom, mng_assign_general, 0, 0, sizeof(mng_prom)};
+#else
+          {MNG_UINT_PROM, mng_init_prom, mng_free_prom, mng_read_prom, mng_write_prom, mng_assign_prom, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PROM, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_PROM))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_prom (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_PROM, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_promp)pChunk)->iColortype   = iColortype;
+  ((mng_promp)pChunk)->iSampledepth = iSampledepth;
+  ((mng_promp)pChunk)->iFilltype    = iFilltype;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_putchunk_ipng (mng_handle hHandle)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_IPNG, mng_init_general, mng_free_general, mng_read_ipng, mng_write_ipng, mng_assign_general, 0, 0, sizeof(mng_ipng)};
+#else
+          {MNG_UINT_IPNG, mng_init_ipng, mng_free_ipng, mng_read_ipng, mng_write_ipng, mng_assign_ipng, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IPNG, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_IPNG))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_ipng (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_IPNG, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_putchunk_pplt (mng_handle hHandle,
+                                        mng_uint8  iDeltatype,
+                                        mng_uint32 iCount)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_PPLT, mng_init_general, mng_free_general, mng_read_pplt, mng_write_pplt, mng_assign_general, 0, 0, sizeof(mng_pplt)};
+#else
+          {MNG_UINT_PPLT, mng_init_pplt, mng_free_pplt, mng_read_pplt, mng_write_pplt, mng_assign_pplt, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PPLT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_PPLT))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_pplt (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_PPLT, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_ppltp)pChunk)->iDeltatype = iDeltatype;
+  ((mng_ppltp)pChunk)->iCount     = iCount;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_putchunk_pplt_entry (mng_handle hHandle,
+                                              mng_uint32 iEntry,
+                                              mng_uint16 iRed,
+                                              mng_uint16 iGreen,
+                                              mng_uint16 iBlue,
+                                              mng_uint16 iAlpha)
+{
+  mng_datap       pData;
+  mng_chunkp      pChunk;
+  mng_pplt_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PPLT_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+
+  pChunk = pData->pLastchunk;          /* last one must have been PPLT ! */
+
+  if (((mng_chunk_headerp)pChunk)->iChunkname != MNG_UINT_PPLT)
+    MNG_ERROR (pData, MNG_NOCORRCHUNK)
+
+                                       /* index out of bounds ? */
+  if (iEntry >= ((mng_ppltp)pChunk)->iCount)
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+                                       /* address proper entry */
+  pEntry = (mng_pplt_entryp)(((mng_ppltp)pChunk)->aEntries) + iEntry;
+
+  pEntry->iRed   = (mng_uint8)iRed;    /* fill the entry */
+  pEntry->iGreen = (mng_uint8)iGreen;
+  pEntry->iBlue  = (mng_uint8)iBlue;
+  pEntry->iAlpha = (mng_uint8)iAlpha;
+  pEntry->bUsed  = MNG_TRUE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_PPLT_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+mng_retcode MNG_DECL mng_putchunk_ijng (mng_handle hHandle)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_IJNG, mng_init_general, mng_free_general, mng_read_ijng, mng_write_ijng, mng_assign_general, 0, 0, sizeof(mng_ijng)};
+#else
+          {MNG_UINT_IJNG, mng_init_ijng, mng_free_ijng, mng_read_ijng, mng_write_ijng, mng_assign_ijng, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IJNG, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_IJNG))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_ijng (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_IJNG, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode MNG_DECL mng_putchunk_drop (mng_handle   hHandle,
+                                        mng_uint32   iCount,
+                                        mng_chunkidp pChunknames)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_DROP, mng_init_general, mng_free_drop, mng_read_drop, mng_write_drop, mng_assign_drop, 0, 0, sizeof(mng_drop)};
+#else
+          {MNG_UINT_DROP, mng_init_drop, mng_free_drop, mng_read_drop, mng_write_drop, mng_assign_drop, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DROP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_DROP))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_drop (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_DROP, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_dropp)pChunk)->iCount = iCount;
+
+  if (iCount)
+  {
+    mng_uint32 iSize = iCount * sizeof (mng_chunkid);
+
+    MNG_ALLOC (pData, ((mng_dropp)pChunk)->pChunknames, iSize);
+    MNG_COPY (((mng_dropp)pChunk)->pChunknames, pChunknames, iSize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DROP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+mng_retcode MNG_DECL mng_putchunk_dbyk (mng_handle  hHandle,
+                                        mng_chunkid iChunkname,
+                                        mng_uint8   iPolarity,
+                                        mng_uint32  iKeywordssize,
+                                        mng_pchar   zKeywords)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_DBYK, mng_init_general, mng_free_dbyk, mng_read_dbyk, mng_write_dbyk, mng_assign_dbyk, 0, 0, sizeof(mng_dbyk)};
+#else
+          {MNG_UINT_DBYK, mng_init_dbyk, mng_free_dbyk, mng_read_dbyk, mng_write_dbyk, mng_assign_dbyk, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DBYK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_DBYK))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_dbyk (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_DBYK, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_dbykp)pChunk)->iChunkname    = iChunkname;
+  ((mng_dbykp)pChunk)->iPolarity     = iPolarity;
+  ((mng_dbykp)pChunk)->iKeywordssize = iKeywordssize;
+
+  if (iKeywordssize)
+  {
+    MNG_ALLOC (pData, ((mng_dbykp)pChunk)->zKeywords, iKeywordssize + 1);
+    MNG_COPY (((mng_dbykp)pChunk)->zKeywords, zKeywords, iKeywordssize);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_DBYK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+mng_retcode MNG_DECL mng_putchunk_ordr (mng_handle hHandle,
+                                        mng_uint32 iCount)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_ORDR, mng_init_general, mng_free_ordr, mng_read_ordr, mng_write_ordr, mng_assign_ordr, 0, 0, sizeof(mng_ordr)};
+#else
+          {MNG_UINT_ORDR, mng_init_ordr, mng_free_ordr, mng_read_ordr, mng_write_ordr, mng_assign_ordr, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ORDR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_ORDR))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_ordr (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_ORDR, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_ordrp)pChunk)->iCount = iCount;
+
+  if (iCount)
+    MNG_ALLOC (pData, ((mng_ordrp)pChunk)->pEntries, iCount * sizeof (mng_ordr_entry));
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ORDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+mng_retcode MNG_DECL mng_putchunk_ordr_entry (mng_handle  hHandle,
+                                              mng_uint32  iEntry,
+                                              mng_chunkid iChunkname,
+                                              mng_uint8   iOrdertype)
+{
+  mng_datap       pData;
+  mng_chunkp      pChunk;
+  mng_ordr_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ORDR_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+
+  pChunk = pData->pLastchunk;          /* last one must have been ORDR ! */
+
+  if (((mng_chunk_headerp)pChunk)->iChunkname != MNG_UINT_ORDR)
+    MNG_ERROR (pData, MNG_NOCORRCHUNK)
+                                       /* index out of bounds ? */
+  if (iEntry >= ((mng_ordrp)pChunk)->iCount)
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+                                       /* address proper entry */
+  pEntry = ((mng_ordrp)pChunk)->pEntries + iEntry;
+
+  pEntry->iChunkname = iChunkname;     /* fill the entry */
+  pEntry->iOrdertype = iOrdertype;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_ORDR_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode MNG_DECL mng_putchunk_magn (mng_handle hHandle,
+                                        mng_uint16 iFirstid,
+                                        mng_uint16 iLastid,
+                                        mng_uint16 iMethodX,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iMY,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint16 iMT,
+                                        mng_uint16 iMB,
+                                        mng_uint16 iMethodY)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_MAGN, mng_init_general, mng_free_general, mng_read_magn, mng_write_magn, mng_assign_general, 0, 0, sizeof(mng_magn)};
+#else
+          {MNG_UINT_MAGN, mng_init_magn, mng_free_magn, mng_read_magn, mng_write_magn, mng_assign_magn, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MAGN, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_MAGN))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_magn (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_MAGN, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_magnp)pChunk)->iFirstid = iFirstid;
+  ((mng_magnp)pChunk)->iLastid  = iLastid;
+  ((mng_magnp)pChunk)->iMethodX = (mng_uint8)iMethodX;
+  ((mng_magnp)pChunk)->iMX      = iMX;
+  ((mng_magnp)pChunk)->iMY      = iMY;
+  ((mng_magnp)pChunk)->iML      = iML;
+  ((mng_magnp)pChunk)->iMR      = iMR;
+  ((mng_magnp)pChunk)->iMT      = iMT;
+  ((mng_magnp)pChunk)->iMB      = iMB;
+  ((mng_magnp)pChunk)->iMethodY = (mng_uint8)iMethodY;
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_mpng (mng_handle hHandle,
+                                                mng_uint32 iFramewidth,
+                                                mng_uint32 iFrameheight,
+                                                mng_uint16 iNumplays,
+                                                mng_uint16 iTickspersec,
+                                                mng_uint8  iCompressionmethod,
+                                                mng_uint32 iCount)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_mpNG, mng_init_general, mng_free_mpng, mng_read_mpng, mng_write_mpng, mng_assign_mpng, 0, 0, sizeof(mng_mpng)};
+#else
+          {MNG_UINT_mpNG, mng_init_mpng, mng_free_mpng, mng_read_mpng, mng_write_mpng, mng_assign_mpng, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MPNG, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a IHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_IHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_mpng (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_mpNG, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_mpngp)pChunk)->iFramewidth        = iFramewidth;
+  ((mng_mpngp)pChunk)->iFrameheight       = iFrameheight;
+  ((mng_mpngp)pChunk)->iNumplays          = iNumplays;
+  ((mng_mpngp)pChunk)->iTickspersec       = iTickspersec;
+  ((mng_mpngp)pChunk)->iCompressionmethod = iCompressionmethod;
+  ((mng_mpngp)pChunk)->iFramessize        = iCount * sizeof (mng_mpng_frame);
+
+  if (iCount)
+    MNG_ALLOC (pData, ((mng_mpngp)pChunk)->pFrames, ((mng_mpngp)pChunk)->iFramessize);
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+MNG_EXT mng_retcode MNG_DECL mng_putchunk_mpng_frame (mng_handle hHandle,
+                                                      mng_uint32 iEntry,
+                                                      mng_uint32 iX,
+                                                      mng_uint32 iY,
+                                                      mng_uint32 iWidth,
+                                                      mng_uint32 iHeight,
+                                                      mng_int32  iXoffset,
+                                                      mng_int32  iYoffset,
+                                                      mng_uint16 iTicks)
+{
+  mng_datap       pData;
+  mng_chunkp      pChunk;
+  mng_mpng_framep pFrame;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MPNG_FRAME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a IHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_IHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+
+  pChunk = pData->pLastchunk;          /* last one must have been mpNG ! */
+
+  if (((mng_chunk_headerp)pChunk)->iChunkname != MNG_UINT_mpNG)
+    MNG_ERROR (pData, MNG_NOCORRCHUNK)
+                                       /* index out of bounds ? */
+  if (iEntry >= (((mng_mpngp)pChunk)->iFramessize / sizeof (mng_mpng_frame)))
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+                                       /* address proper entry */
+  pFrame = ((mng_mpngp)pChunk)->pFrames + iEntry;
+                                       /* fill entry */
+  pFrame->iX        = iX;
+  pFrame->iY        = iY;
+  pFrame->iWidth    = iWidth;
+  pFrame->iHeight   = iHeight;
+  pFrame->iXoffset  = iXoffset;
+  pFrame->iYoffset  = iYoffset;
+  pFrame->iTicks    = iTicks;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_MPNG_FRAME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_evNT
+mng_retcode MNG_DECL mng_putchunk_evnt (mng_handle hHandle,
+                                        mng_uint32 iCount)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_evNT, mng_init_general, mng_free_evnt, mng_read_evnt, mng_write_evnt, mng_assign_evnt, 0, 0, sizeof(mng_evnt)};
+#else
+          {MNG_UINT_evNT, mng_init_evnt, mng_free_evnt, mng_read_evnt, mng_write_evnt, mng_assign_evnt, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_EVNT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, MNG_UINT_evNT))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_evnt (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_evNT, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_evntp)pChunk)->iCount = iCount;
+
+  if (iCount)
+    MNG_ALLOC (pData, ((mng_evntp)pChunk)->pEntries, iCount * sizeof (mng_evnt_entry));
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_EVNT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_evnt_entry (mng_handle hHandle,
+                                              mng_uint32 iEntry,
+                                              mng_uint8  iEventtype,
+                                              mng_uint8  iMasktype,
+                                              mng_int32  iLeft,
+                                              mng_int32  iRight,
+                                              mng_int32  iTop,
+                                              mng_int32  iBottom,
+                                              mng_uint16 iObjectid,
+                                              mng_uint8  iIndex,
+                                              mng_uint32 iSegmentnamesize,
+                                              mng_pchar  zSegmentname)
+{
+  mng_datap       pData;
+  mng_chunkp      pChunk;
+  mng_evnt_entryp pEntry;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_EVNT_ENTRY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a MHDR first! */
+  if (pData->iFirstchunkadded != MNG_UINT_MHDR)
+    MNG_ERROR (pData, MNG_NOHEADER)
+
+  pChunk = pData->pLastchunk;          /* last one must have been evNT ! */
+
+  if (((mng_chunk_headerp)pChunk)->iChunkname != MNG_UINT_evNT)
+    MNG_ERROR (pData, MNG_NOCORRCHUNK)
+                                       /* index out of bounds ? */
+  if (iEntry >= ((mng_evntp)pChunk)->iCount)
+    MNG_ERROR (pData, MNG_INVALIDENTRYIX)
+                                       /* address proper entry */
+  pEntry = ((mng_evntp)pChunk)->pEntries + iEntry;
+                                       /* fill entry */
+  pEntry->iEventtype       = iEventtype;
+  pEntry->iMasktype        = iMasktype;
+  pEntry->iLeft            = iLeft;
+  pEntry->iRight           = iRight;
+  pEntry->iTop             = iTop;
+  pEntry->iBottom          = iBottom;
+  pEntry->iObjectid        = iObjectid;
+  pEntry->iIndex           = iIndex;
+  pEntry->iSegmentnamesize = iSegmentnamesize;
+
+  if (iSegmentnamesize)
+  {
+    MNG_ALLOC (pData, pEntry->zSegmentname, iSegmentnamesize + 1);
+    MNG_COPY (pEntry->zSegmentname, zSegmentname, iSegmentnamesize);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_EVNT_ENTRY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putchunk_unknown (mng_handle  hHandle,
+                                           mng_chunkid iChunkname,
+                                           mng_uint32  iRawlen,
+                                           mng_ptr     pRawdata)
+{
+  mng_datap        pData;
+  mng_chunkp       pChunk;
+  mng_retcode      iRetcode;
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  mng_chunk_header sChunkheader =
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+          {MNG_UINT_HUH, mng_init_general, mng_free_unknown, mng_read_unknown, mng_write_unknown, mng_assign_unknown, 0, 0, sizeof(mng_unknown_chunk)};
+#else
+          {MNG_UINT_HUH, mng_init_unknown, mng_free_unknown, mng_read_unknown, mng_write_unknown, mng_assign_unknown, 0, 0};
+#endif
+#else
+  mng_chunk_header sChunkheader;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_UNKNOWN, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must have had a header first! */
+  if (pData->iFirstchunkadded == 0)
+    MNG_ERROR (pData, MNG_NOHEADER)
+                                       /* prevent misplaced TERM ! */
+  if (!check_term (pData, iChunkname))
+    MNG_ERROR (pData, MNG_TERMSEQERROR)
+                                       /* create the chunk */
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#else
+  iRetcode = mng_init_unknown (pData, &sChunkheader, &pChunk);
+#endif
+#else
+  mng_get_chunkheader(MNG_UINT_HUH, &sChunkheader);
+  iRetcode = mng_init_general (pData, &sChunkheader, &pChunk);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fill the chunk */
+  ((mng_unknown_chunkp)pChunk)->sHeader.iChunkname = iChunkname;
+  ((mng_unknown_chunkp)pChunk)->iDatasize          = iRawlen;
+
+  if (iRawlen)
+  {
+    MNG_ALLOC (pData, ((mng_unknown_chunkp)pChunk)->pData, iRawlen);
+    MNG_COPY (((mng_unknown_chunkp)pChunk)->pData, pRawdata, iRawlen);
+  }
+
+  mng_add_chunk (pData, pChunk);       /* add it to the list */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTCHUNK_UNKNOWN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getimgdata_seq (mng_handle        hHandle,
+                                         mng_uint32        iSeqnr,
+                                         mng_uint32        iCanvasstyle,
+                                         mng_getcanvasline fGetcanvasline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETIMGDATA_SEQ, MNG_LC_START);
+#endif
+
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETIMGDATA_SEQ, MNG_LC_END);
+#endif
+
+  return MNG_FNNOTIMPLEMENTED;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getimgdata_chunkseq (mng_handle        hHandle,
+                                              mng_uint32        iSeqnr,
+                                              mng_uint32        iCanvasstyle,
+                                              mng_getcanvasline fGetcanvasline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETIMGDATA_CHUNKSEQ, MNG_LC_START);
+#endif
+
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETIMGDATA_CHUNKSEQ, MNG_LC_END);
+#endif
+
+  return MNG_FNNOTIMPLEMENTED;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getimgdata_chunk (mng_handle        hHandle,
+                                           mng_handle        hChunk,
+                                           mng_uint32        iCanvasstyle,
+                                           mng_getcanvasline fGetcanvasline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETIMGDATA_CHUNK, MNG_LC_START);
+#endif
+
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETIMGDATA_CHUNK, MNG_LC_END);
+#endif
+
+  return MNG_FNNOTIMPLEMENTED;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_putimgdata_ihdr (mng_handle        hHandle,
+                                          mng_uint32        iWidth,
+                                          mng_uint32        iHeight,
+                                          mng_uint8         iColortype,
+                                          mng_uint8         iBitdepth,
+                                          mng_uint8         iCompression,
+                                          mng_uint8         iFilter,
+                                          mng_uint8         iInterlace,
+                                          mng_uint32        iCanvasstyle,
+                                          mng_getcanvasline fGetcanvasline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTIMGDATA_IHDR, MNG_LC_START);
+#endif
+
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTIMGDATA_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_FNNOTIMPLEMENTED;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+mng_retcode MNG_DECL mng_putimgdata_jhdr (mng_handle        hHandle,
+                                          mng_uint32        iWidth,
+                                          mng_uint32        iHeight,
+                                          mng_uint8         iColortype,
+                                          mng_uint8         iBitdepth,
+                                          mng_uint8         iCompression,
+                                          mng_uint8         iInterlace,
+                                          mng_uint8         iAlphaBitdepth,
+                                          mng_uint8         iAlphaCompression,
+                                          mng_uint8         iAlphaFilter,
+                                          mng_uint8         iAlphaInterlace,
+                                          mng_uint32        iCanvasstyle,
+                                          mng_getcanvasline fGetcanvasline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTIMGDATA_JHDR, MNG_LC_START);
+#endif
+
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_PUTIMGDATA_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_FNNOTIMPLEMENTED;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_updatemngheader (mng_handle hHandle,
+                                          mng_uint32 iFramecount,
+                                          mng_uint32 iLayercount,
+                                          mng_uint32 iPlaytime)
+{
+  mng_datap  pData;
+  mng_chunkp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_UPDATEMNGHEADER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must be a MNG animation! */
+  if ((pData->eImagetype != mng_it_mng) || (pData->iFirstchunkadded != MNG_UINT_MHDR))
+    MNG_ERROR (pData, MNG_NOMHDR)
+
+  pChunk = pData->pFirstchunk;         /* get the first chunk */
+                                       /* and update the variables */
+  ((mng_mhdrp)pChunk)->iFramecount = iFramecount;
+  ((mng_mhdrp)pChunk)->iLayercount = iLayercount;
+  ((mng_mhdrp)pChunk)->iPlaytime   = iPlaytime;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_UPDATEMNGHEADER, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_updatemngsimplicity (mng_handle hHandle,
+                                              mng_uint32 iSimplicity)
+{
+  mng_datap  pData;
+  mng_chunkp pChunk;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_UPDATEMNGSIMPLICITY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = (mng_datap)hHandle;          /* and make it addressable */
+
+  if (!pData->bCreating)               /* aren't we creating a new file ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID)
+                                       /* must be a MNG animation! */
+  if ((pData->eImagetype != mng_it_mng) || (pData->iFirstchunkadded != MNG_UINT_MHDR))
+    MNG_ERROR (pData, MNG_NOMHDR)
+
+  pChunk = pData->pFirstchunk;         /* get the first chunk */
+                                       /* and update the variable */
+  ((mng_mhdrp)pChunk)->iSimplicity = iSimplicity;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_UPDATEMNGSIMPLICITY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+
+#endif /* MNG_ACCESS_CHUNKS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
+
diff --git a/src/3rdparty/libmng/libmng_chunks.h b/src/3rdparty/libmng/libmng_chunks.h
new file mode 100644
index 0000000..d10bf2d
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_chunks.h
@@ -0,0 +1,1026 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_chunks.h           copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Chunk structures (definition)                              * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of known chunk structures                       * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/04/2000 - G.Juyn                                * */
+/* *             - put in some extra comments                               * */
+/* *             0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - fixed layout for sBIT, PPLT                              * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed write callback definition                        * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - fixed layout for PPLT again (missed deltatype ?!?)       * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - removed useless definition (contributed by Tim Rowley)   * */
+/* *             0.5.2 - 06/03/2000 - G.Juyn                                * */
+/* *             - fixed makeup for Linux gcc compile                       * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/10/2000 - G.Juyn                                * */
+/* *             - fixed DEFI behavior                                      * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added JDAA chunk                                         * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - added HLAPI function to copy chunks                      * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 11/28/2002 - G.Juyn                                * */
+/* *             - fixed definition of iMethodX/Y for MAGN chunk            * */
+/* *                                                                        * */
+/* *             1.0.6 - 05/25/2003 - G.R-P                                 * */
+/* *               added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - added conditional around MNG_NO_DELTA_PNG support        * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKINITFREE             * */
+/* *             1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKREADER               * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_chunks_h_
+#define _libmng_chunks_h_
+
+/* ************************************************************************** */
+
+#ifdef MNG_SWAP_ENDIAN
+#define PNG_SIG 0x474e5089L
+#define JNG_SIG 0x474e4a8bL
+#define MNG_SIG 0x474e4d8aL
+#define POST_SIG 0x0a1a0a0dL
+#else
+#define PNG_SIG 0x89504e47L
+#define JNG_SIG 0x8b4a4e47L
+#define MNG_SIG 0x8a4d4e47L
+#define POST_SIG 0x0d0a1a0aL
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+
+typedef mng_retcode (*mng_f_specialfunc)  (mng_datap   pData,
+                                           mng_chunkp  pChunk,
+                                           mng_uint32* piRawlen,
+                                           mng_uint8p* ppRawdata);
+                                           
+typedef mng_retcode (*mng_c_specialfunc)  (mng_datap  pData,
+                                           mng_chunkp pChunk);
+
+#define MNG_FIELD_OPTIONAL    0x0001
+#define MNG_FIELD_TERMINATOR  0x0002
+#define MNG_FIELD_REPETITIVE  0x0004
+#define MNG_FIELD_DEFLATED    0x0008
+#define MNG_FIELD_IFIMGTYPES  0x01F0   /* image-type mask */
+#define MNG_FIELD_IFIMGTYPE0  0x0010
+#define MNG_FIELD_IFIMGTYPE2  0x0020
+#define MNG_FIELD_IFIMGTYPE3  0x0040
+#define MNG_FIELD_IFIMGTYPE4  0x0080
+#define MNG_FIELD_IFIMGTYPE6  0x0100
+#define MNG_FIELD_PUTIMGTYPE  0x0200
+#define MNG_FIELD_NOHIGHBIT   0x0400
+#define MNG_FIELD_GROUPMASK   0x7000
+#define MNG_FIELD_GROUP1      0x1000
+#define MNG_FIELD_GROUP2      0x2000
+#define MNG_FIELD_GROUP3      0x3000
+#define MNG_FIELD_GROUP4      0x4000
+#define MNG_FIELD_GROUP5      0x5000
+#define MNG_FIELD_GROUP6      0x6000
+#define MNG_FIELD_GROUP7      0x7000
+#define MNG_FIELD_INT         0x8000
+
+typedef struct {                       /* chunk-field descriptor */
+           mng_f_specialfunc pSpecialfunc;
+           mng_uint16        iFlags;
+           mng_uint16        iMinvalue;
+           mng_uint16        iMaxvalue;
+           mng_uint16        iLengthmin;
+           mng_uint16        iLengthmax;
+           mng_uint16        iOffsetchunk;
+           mng_uint16        iOffsetchunkind;
+           mng_uint16        iOffsetchunklen;
+        } mng_field_descriptor;
+typedef mng_field_descriptor * mng_field_descp;
+
+#define MNG_DESCR_GLOBAL      0x0001
+#define MNG_DESCR_EMPTY       0x0002
+#define MNG_DESCR_EMPTYEMBED  0x0006
+#define MNG_DESCR_EMPTYGLOBAL 0x000A
+
+#define MNG_DESCR_GenHDR      0x0001   /* IHDR/JHDR/BASI/DHDR */
+#define MNG_DESCR_JngHDR      0x0002   /* JHDR/DHDR */
+#define MNG_DESCR_MHDR        0x0004
+#define MNG_DESCR_IHDR        0x0008
+#define MNG_DESCR_JHDR        0x0010
+#define MNG_DESCR_DHDR        0x0020
+#define MNG_DESCR_LOOP        0x0040
+#define MNG_DESCR_PLTE        0x0080
+#define MNG_DESCR_SAVE        0x0100
+
+#define MNG_DESCR_NOIHDR      0x0001
+#define MNG_DESCR_NOJHDR      0x0002
+#define MNG_DESCR_NOBASI      0x0004
+#define MNG_DESCR_NODHDR      0x0008
+#define MNG_DESCR_NOIDAT      0x0010
+#define MNG_DESCR_NOJDAT      0x0020
+#define MNG_DESCR_NOJDAA      0x0040
+#define MNG_DESCR_NOPLTE      0x0080
+#define MNG_DESCR_NOJSEP      0x0100
+#define MNG_DESCR_NOMHDR      0x0200
+#define MNG_DESCR_NOTERM      0x0400
+#define MNG_DESCR_NOLOOP      0x0800
+#define MNG_DESCR_NOSAVE      0x1000
+
+typedef struct {                       /* chunk descriptor */
+           mng_imgtype       eImgtype;
+           mng_createobjtype eCreateobject;
+           mng_uint16        iObjsize;
+           mng_uint16        iOffsetempty;
+           mng_ptr           pObjcleanup;
+           mng_ptr           pObjprocess;
+           mng_c_specialfunc pSpecialfunc;
+           mng_field_descp   pFielddesc;
+           mng_uint16        iFielddesc;
+           mng_uint16        iAllowed;
+           mng_uint16        iMusthaves;
+           mng_uint16        iMustNOThaves;
+        } mng_chunk_descriptor;
+typedef mng_chunk_descriptor * mng_chunk_descp;
+
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+/* ************************************************************************** */
+
+typedef mng_retcode (*mng_createchunk)  (mng_datap   pData,
+                                         mng_chunkp  pHeader,
+                                         mng_chunkp* ppChunk);
+
+typedef mng_retcode (*mng_cleanupchunk) (mng_datap   pData,
+                                         mng_chunkp  pHeader);
+
+typedef mng_retcode (*mng_readchunk)    (mng_datap   pData,
+                                         mng_chunkp  pHeader,
+                                         mng_uint32  iRawlen,
+                                         mng_uint8p  pRawdata,
+                                         mng_chunkp* pChunk);
+
+typedef mng_retcode (*mng_writechunk)   (mng_datap   pData,
+                                         mng_chunkp  pChunk);
+
+typedef mng_retcode (*mng_assignchunk)  (mng_datap   pData,
+                                         mng_chunkp  pChunkto,
+                                         mng_chunkp  pChunkfrom);
+
+/* ************************************************************************** */
+
+typedef struct {                       /* generic header */
+           mng_chunkid       iChunkname;
+           mng_createchunk   fCreate;
+           mng_cleanupchunk  fCleanup;
+           mng_readchunk     fRead;
+           mng_writechunk    fWrite;
+           mng_assignchunk   fAssign;
+           mng_chunkp        pNext;    /* for double-linked list */
+           mng_chunkp        pPrev;
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+           mng_size_t        iChunksize;
+#endif
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+           mng_chunk_descp   pChunkdescr;
+#endif
+        } mng_chunk_header;
+typedef mng_chunk_header * mng_chunk_headerp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* IHDR */
+           mng_chunk_header  sHeader;
+           mng_uint32        iWidth;
+           mng_uint32        iHeight;
+           mng_uint8         iBitdepth;
+           mng_uint8         iColortype;
+           mng_uint8         iCompression;
+           mng_uint8         iFilter;
+           mng_uint8         iInterlace;
+        } mng_ihdr;
+typedef mng_ihdr * mng_ihdrp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* PLTE */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint32        iEntrycount;
+           mng_rgbpaltab     aEntries;
+        } mng_plte;
+typedef mng_plte * mng_pltep;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* IDAT */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint32        iDatasize;
+           mng_ptr           pData;
+        } mng_idat;
+typedef mng_idat * mng_idatp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* IEND */
+           mng_chunk_header  sHeader;
+        } mng_iend;
+typedef mng_iend * mng_iendp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* tRNS */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_bool          bGlobal;
+           mng_uint8         iType;    /* colortype (0,2,3) */
+           mng_uint32        iCount;
+           mng_uint8arr      aEntries;
+           mng_uint16        iGray;
+           mng_uint16        iRed;
+           mng_uint16        iGreen;
+           mng_uint16        iBlue;
+           mng_uint32        iRawlen;
+           mng_uint8arr      aRawdata;
+        } mng_trns;
+typedef mng_trns * mng_trnsp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* gAMA */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint32        iGamma;
+        } mng_gama;
+typedef mng_gama * mng_gamap;
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+typedef struct {                       /* cHRM */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint32        iWhitepointx;
+           mng_uint32        iWhitepointy;
+           mng_uint32        iRedx;
+           mng_uint32        iRedy;
+           mng_uint32        iGreenx;
+           mng_uint32        iGreeny;
+           mng_uint32        iBluex;
+           mng_uint32        iBluey;
+        } mng_chrm;
+typedef mng_chrm * mng_chrmp;
+#endif
+
+/* ************************************************************************** */
+
+typedef struct {                       /* sRGB */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint8         iRenderingintent;
+        } mng_srgb;
+typedef mng_srgb * mng_srgbp;
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+typedef struct {                       /* iCCP */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint32        iNamesize;
+           mng_pchar         zName;
+           mng_uint8         iCompression;
+           mng_uint32        iProfilesize;
+           mng_ptr           pProfile;
+        } mng_iccp;
+typedef mng_iccp * mng_iccpp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tEXt
+typedef struct {                       /* tEXt */
+           mng_chunk_header  sHeader;
+           mng_uint32        iKeywordsize;
+           mng_pchar         zKeyword;
+           mng_uint32        iTextsize;
+           mng_pchar         zText;
+        } mng_text;
+typedef mng_text * mng_textp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_zTXt
+typedef struct {                       /* zTXt */
+           mng_chunk_header  sHeader;
+           mng_uint32        iKeywordsize;
+           mng_pchar         zKeyword;
+           mng_uint8         iCompression;
+           mng_uint32        iTextsize;
+           mng_pchar         zText;
+        } mng_ztxt;
+typedef mng_ztxt * mng_ztxtp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iTXt
+typedef struct {                       /* iTXt */
+           mng_chunk_header  sHeader;
+           mng_uint32        iKeywordsize;
+           mng_pchar         zKeyword;
+           mng_uint8         iCompressionflag;
+           mng_uint8         iCompressionmethod;
+           mng_uint32        iLanguagesize;
+           mng_pchar         zLanguage;
+           mng_uint32        iTranslationsize;
+           mng_pchar         zTranslation;
+           mng_uint32        iTextsize;
+           mng_pchar         zText;
+        } mng_itxt;
+typedef mng_itxt * mng_itxtp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+typedef struct {                       /* bKGD */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint8         iType;    /* 3=indexed, 0=gray, 2=rgb */
+           mng_uint8         iIndex;
+           mng_uint16        iGray;
+           mng_uint16        iRed;
+           mng_uint16        iGreen;
+           mng_uint16        iBlue;
+        } mng_bkgd;
+typedef mng_bkgd * mng_bkgdp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYs
+typedef struct {                       /* pHYs */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint32        iSizex;
+           mng_uint32        iSizey;
+           mng_uint8         iUnit;
+        } mng_phys;
+typedef mng_phys * mng_physp;
+#endif
+
+/* ************************************************************************** */
+#ifndef MNG_SKIPCHUNK_sBIT
+
+typedef struct {                       /* sBIT */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint8         iType;    /* colortype (0,2,3,4,6,10,12,14,16) */
+           mng_uint8arr4     aBits;
+        } mng_sbit;
+typedef mng_sbit * mng_sbitp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sPLT
+typedef struct {                       /* sPLT */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint32        iNamesize;
+           mng_pchar         zName;
+           mng_uint8         iSampledepth;
+           mng_uint32        iEntrycount;
+           mng_ptr           pEntries;
+        } mng_splt;
+typedef mng_splt * mng_spltp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_hIST
+typedef struct {                       /* hIST */
+           mng_chunk_header  sHeader;
+           mng_uint32        iEntrycount;
+           mng_uint16arr     aEntries;
+        } mng_hist;
+typedef mng_hist * mng_histp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_tIME
+typedef struct {                       /* tIME */
+           mng_chunk_header  sHeader;
+           mng_uint16        iYear;
+           mng_uint8         iMonth;
+           mng_uint8         iDay;
+           mng_uint8         iHour;
+           mng_uint8         iMinute;
+           mng_uint8         iSecond;
+        } mng_time;
+typedef mng_time * mng_timep;
+#endif
+
+/* ************************************************************************** */
+
+typedef struct {                       /* MHDR */
+           mng_chunk_header  sHeader;
+           mng_uint32        iWidth;
+           mng_uint32        iHeight;
+           mng_uint32        iTicks;
+           mng_uint32        iLayercount;
+           mng_uint32        iFramecount;
+           mng_uint32        iPlaytime;
+           mng_uint32        iSimplicity;
+        } mng_mhdr;
+typedef mng_mhdr * mng_mhdrp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* MEND */
+           mng_chunk_header  sHeader;
+        } mng_mend;
+typedef mng_mend * mng_mendp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* LOOP */
+           mng_chunk_header  sHeader;
+           mng_uint8         iLevel;
+           mng_uint32        iRepeat;
+           mng_uint8         iTermination;
+           mng_uint32        iItermin;
+           mng_uint32        iItermax;
+           mng_uint32        iCount;
+           mng_uint32p       pSignals;
+        } mng_loop;
+typedef mng_loop * mng_loopp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* ENDL */
+           mng_chunk_header  sHeader;
+           mng_uint8         iLevel;
+        } mng_endl;
+typedef mng_endl * mng_endlp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* DEFI */
+           mng_chunk_header  sHeader;
+           mng_uint16        iObjectid;
+           mng_bool          bHasdonotshow;
+           mng_uint8         iDonotshow;
+           mng_bool          bHasconcrete;
+           mng_uint8         iConcrete;
+           mng_bool          bHasloca;
+           mng_int32         iXlocation;
+           mng_int32         iYlocation;
+           mng_bool          bHasclip;
+           mng_int32         iLeftcb;
+           mng_int32         iRightcb;
+           mng_int32         iTopcb;
+           mng_int32         iBottomcb;
+        } mng_defi;
+typedef mng_defi * mng_defip;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* BASI */
+           mng_chunk_header  sHeader;
+           mng_uint32        iWidth;
+           mng_uint32        iHeight;
+           mng_uint8         iBitdepth;
+           mng_uint8         iColortype;
+           mng_uint8         iCompression;
+           mng_uint8         iFilter;
+           mng_uint8         iInterlace;
+           mng_uint16        iRed;
+           mng_uint16        iGreen;
+           mng_uint16        iBlue;
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+           mng_bool          bHasalpha;
+#endif
+           mng_uint16        iAlpha;
+           mng_uint8         iViewable;
+        } mng_basi;
+typedef mng_basi * mng_basip;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* CLON */
+           mng_chunk_header  sHeader;
+           mng_uint16        iSourceid;
+           mng_uint16        iCloneid;
+           mng_uint8         iClonetype;
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+           mng_bool          bHasdonotshow;
+#endif
+           mng_uint8         iDonotshow;
+           mng_uint8         iConcrete;
+           mng_bool          bHasloca;
+           mng_uint8         iLocationtype;
+           mng_int32         iLocationx;
+           mng_int32         iLocationy;
+        } mng_clon;
+typedef mng_clon * mng_clonp;
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+typedef struct {                       /* PAST source */
+           mng_uint16        iSourceid;
+           mng_uint8         iComposition;
+           mng_uint8         iOrientation;
+           mng_uint8         iOffsettype;
+           mng_int32         iOffsetx;
+           mng_int32         iOffsety;
+           mng_uint8         iBoundarytype;
+           mng_int32         iBoundaryl;
+           mng_int32         iBoundaryr;
+           mng_int32         iBoundaryt;
+           mng_int32         iBoundaryb;
+        } mng_past_source;
+typedef mng_past_source * mng_past_sourcep;
+
+typedef struct {                       /* PAST */
+           mng_chunk_header  sHeader;
+           mng_uint16        iDestid;
+           mng_uint8         iTargettype;
+           mng_int32         iTargetx;
+           mng_int32         iTargety;
+           mng_uint32        iCount;
+           mng_past_sourcep  pSources;
+        } mng_past;
+typedef mng_past * mng_pastp;
+#endif
+
+/* ************************************************************************** */
+
+typedef struct {                       /* DISC */
+           mng_chunk_header  sHeader;
+           mng_uint32        iCount;
+           mng_uint16p       pObjectids;
+        } mng_disc;
+typedef mng_disc * mng_discp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* BACK */
+           mng_chunk_header  sHeader;
+           mng_uint16        iRed;
+           mng_uint16        iGreen;
+           mng_uint16        iBlue;
+           mng_uint8         iMandatory;
+           mng_uint16        iImageid;
+           mng_uint8         iTile;
+        } mng_back;
+typedef mng_back * mng_backp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* FRAM */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint8         iMode;
+           mng_uint32        iNamesize;
+           mng_pchar         zName;
+           mng_uint8         iChangedelay;
+           mng_uint8         iChangetimeout;
+           mng_uint8         iChangeclipping;
+           mng_uint8         iChangesyncid;
+           mng_uint32        iDelay;
+           mng_uint32        iTimeout;
+           mng_uint8         iBoundarytype;
+           mng_int32         iBoundaryl;
+           mng_int32         iBoundaryr;
+           mng_int32         iBoundaryt;
+           mng_int32         iBoundaryb;
+           mng_uint32        iCount;
+           mng_uint32p       pSyncids;
+        } mng_fram;
+typedef mng_fram * mng_framp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* MOVE */
+           mng_chunk_header  sHeader;
+           mng_uint16        iFirstid;
+           mng_uint16        iLastid;
+           mng_uint8         iMovetype;
+           mng_int32         iMovex;
+           mng_int32         iMovey;
+        } mng_move;
+typedef mng_move * mng_movep;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* CLIP */
+           mng_chunk_header  sHeader;
+           mng_uint16        iFirstid;
+           mng_uint16        iLastid;
+           mng_uint8         iCliptype;
+           mng_int32         iClipl;
+           mng_int32         iClipr;
+           mng_int32         iClipt;
+           mng_int32         iClipb;
+        } mng_clip;
+typedef mng_clip * mng_clipp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* SHOW */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint16        iFirstid;
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+           mng_bool          bHaslastid;
+#endif
+           mng_uint16        iLastid;
+           mng_uint8         iMode;
+        } mng_show;
+typedef mng_show * mng_showp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* TERM */
+           mng_chunk_header  sHeader;
+           mng_uint8         iTermaction;
+           mng_uint8         iIteraction;
+           mng_uint32        iDelay;
+           mng_uint32        iItermax;
+        } mng_term;
+typedef mng_term * mng_termp;
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+typedef struct {                       /* SAVE entry */
+           mng_uint8         iEntrytype;
+           mng_uint32arr2    iOffset;            /* 0=MSI, 1=LSI */
+           mng_uint32arr2    iStarttime;         /* 0=MSI, 1=LSI */
+           mng_uint32        iLayernr;
+           mng_uint32        iFramenr;
+           mng_uint32        iNamesize;
+           mng_pchar         zName;
+        } mng_save_entry;
+typedef mng_save_entry * mng_save_entryp;
+
+typedef struct {                       /* SAVE */
+           mng_chunk_header  sHeader;
+           mng_bool          bEmpty;
+           mng_uint8         iOffsettype;
+           mng_uint32        iCount;
+           mng_save_entryp   pEntries;
+        } mng_save;
+typedef mng_save * mng_savep;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+typedef struct {                       /* SEEK */
+           mng_chunk_header  sHeader;
+           mng_uint32        iNamesize;
+           mng_pchar         zName;
+        } mng_seek;
+typedef mng_seek * mng_seekp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_eXPI
+typedef struct {                       /* eXPI */
+           mng_chunk_header  sHeader;
+           mng_uint16        iSnapshotid;
+           mng_uint32        iNamesize;
+           mng_pchar         zName;
+        } mng_expi;
+typedef mng_expi * mng_expip;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_fPRI
+typedef struct {                       /* fPRI */
+           mng_chunk_header  sHeader;
+           mng_uint8         iDeltatype;
+           mng_uint8         iPriority;
+        } mng_fpri;
+typedef mng_fpri * mng_fprip;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_nEED
+typedef struct {                       /* nEED */
+           mng_chunk_header  sHeader;
+           mng_uint32        iKeywordssize;
+           mng_pchar         zKeywords;
+        } mng_need;
+typedef mng_need * mng_needp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_pHYg
+typedef mng_phys mng_phyg;             /* pHYg */
+typedef mng_phyg * mng_phygp;
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+typedef struct {                       /* JHDR */
+           mng_chunk_header  sHeader;
+           mng_uint32        iWidth;
+           mng_uint32        iHeight;
+           mng_uint8         iColortype;
+           mng_uint8         iImagesampledepth;
+           mng_uint8         iImagecompression;
+           mng_uint8         iImageinterlace;
+           mng_uint8         iAlphasampledepth;
+           mng_uint8         iAlphacompression;
+           mng_uint8         iAlphafilter;
+           mng_uint8         iAlphainterlace;
+        } mng_jhdr;
+typedef mng_jhdr * mng_jhdrp;
+
+/* ************************************************************************** */
+
+typedef mng_idat mng_jdaa;             /* JDAA */
+typedef mng_jdaa * mng_jdaap;
+
+/* ************************************************************************** */
+
+typedef mng_idat mng_jdat;             /* JDAT */
+typedef mng_jdat * mng_jdatp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* JSEP */
+           mng_chunk_header  sHeader;
+        } mng_jsep;
+typedef mng_jsep * mng_jsepp;
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+
+typedef struct {                       /* DHDR */
+           mng_chunk_header  sHeader;
+           mng_uint16        iObjectid;
+           mng_uint8         iImagetype;
+           mng_uint8         iDeltatype;
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+           mng_bool          bHasblocksize;
+#endif
+           mng_uint32        iBlockwidth;
+           mng_uint32        iBlockheight;
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+           mng_bool          bHasblockloc;
+#endif
+           mng_uint32        iBlockx;
+           mng_uint32        iBlocky;
+        } mng_dhdr;
+typedef mng_dhdr * mng_dhdrp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* PROM */
+           mng_chunk_header  sHeader;
+           mng_uint8         iColortype;
+           mng_uint8         iSampledepth;
+           mng_uint8         iFilltype;
+        } mng_prom;
+typedef mng_prom * mng_promp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* IPNG */
+           mng_chunk_header  sHeader;
+        } mng_ipng;
+typedef mng_ipng *mng_ipngp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* PPLT entry */
+           mng_uint8         iRed;
+           mng_uint8         iGreen;
+           mng_uint8         iBlue;
+           mng_uint8         iAlpha;
+           mng_bool          bUsed;
+        } mng_pplt_entry;
+typedef mng_pplt_entry * mng_pplt_entryp;
+
+typedef struct {                       /* PPLT */
+           mng_chunk_header  sHeader;
+           mng_uint8         iDeltatype;
+           mng_uint32        iCount;
+           mng_pplt_entry    aEntries [256];
+        } mng_pplt;
+typedef mng_pplt * mng_ppltp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* IJNG */
+           mng_chunk_header  sHeader;
+        } mng_ijng;
+typedef mng_ijng *mng_ijngp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* DROP */
+           mng_chunk_header  sHeader;
+           mng_uint32        iCount;
+           mng_chunkidp      pChunknames;
+        } mng_drop;
+typedef mng_drop * mng_dropp;
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DBYK
+typedef struct {                       /* DBYK */
+           mng_chunk_header  sHeader;
+           mng_chunkid       iChunkname;
+           mng_uint8         iPolarity;
+           mng_uint32        iKeywordssize;
+           mng_pchar         zKeywords;
+        } mng_dbyk;
+typedef mng_dbyk * mng_dbykp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_ORDR
+typedef struct {                       /* ORDR entry */
+           mng_chunkid       iChunkname;
+           mng_uint8         iOrdertype;
+        } mng_ordr_entry;
+typedef mng_ordr_entry * mng_ordr_entryp;
+
+typedef struct mng_ordr_struct {       /* ORDR */
+           mng_chunk_header  sHeader;
+           mng_uint32        iCount;
+           mng_ordr_entryp   pEntries;
+        } mng_ordr;
+typedef mng_ordr * mng_ordrp;
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+
+typedef struct {                       /* MAGN */
+           mng_chunk_header  sHeader;
+           mng_uint16        iFirstid;
+           mng_uint16        iLastid;
+           mng_uint8         iMethodX;
+           mng_uint16        iMX;
+           mng_uint16        iMY;
+           mng_uint16        iML;
+           mng_uint16        iMR;
+           mng_uint16        iMT;
+           mng_uint16        iMB;
+           mng_uint8         iMethodY;
+        } mng_magn;
+typedef mng_magn * mng_magnp;
+
+/* ************************************************************************** */
+
+typedef struct {                       /* evNT entry */
+           mng_uint8         iEventtype;
+           mng_uint8         iMasktype;
+           mng_int32         iLeft;
+           mng_int32         iRight;
+           mng_int32         iTop;
+           mng_int32         iBottom;
+           mng_uint16        iObjectid;
+           mng_uint8         iIndex;
+           mng_uint32        iSegmentnamesize;
+           mng_pchar         zSegmentname;
+        } mng_evnt_entry;
+typedef mng_evnt_entry * mng_evnt_entryp;
+
+typedef struct {                       /* evNT */
+           mng_chunk_header  sHeader;
+           mng_uint32        iCount;
+           mng_evnt_entryp   pEntries;
+        } mng_evnt;
+typedef mng_evnt * mng_evntp;
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+typedef struct {                       /* mpNG frame */
+           mng_uint32        iX;
+           mng_uint32        iY;
+           mng_uint32        iWidth;
+           mng_uint32        iHeight;
+           mng_int32         iXoffset;
+           mng_int32         iYoffset;
+           mng_uint16        iTicks;
+        } mng_mpng_frame;
+typedef mng_mpng_frame * mng_mpng_framep;
+
+typedef struct {                       /* mpNG */
+           mng_chunk_header  sHeader;
+           mng_uint32        iFramewidth;
+           mng_uint32        iFrameheight;
+           mng_uint16        iNumplays;
+           mng_uint16        iTickspersec;
+           mng_uint8         iCompressionmethod;
+           mng_uint32        iFramessize;
+           mng_mpng_framep   pFrames;
+        } mng_mpng;
+typedef mng_mpng * mng_mpngp;
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+typedef struct {                       /* ahDR */
+           mng_chunk_header  sHeader;
+           mng_uint32        iNumframes;
+           mng_uint32        iTickspersec;
+           mng_uint32        iNumplays;
+           mng_uint32        iTilewidth;
+           mng_uint32        iTileheight;
+           mng_uint8         iInterlace;
+           mng_uint8         iStillused;
+        } mng_ahdr;
+typedef mng_ahdr * mng_ahdrp;
+
+typedef struct {                       /* adAT tile */
+           mng_uint32        iTicks;
+           mng_int32         iXoffset;
+           mng_int32         iYoffset;
+           mng_uint8         iTilesource;
+        } mng_adat_tile;
+typedef mng_adat_tile * mng_adat_tilep;
+
+typedef struct {                       /* adAT */
+           mng_chunk_header  sHeader;
+           mng_uint32        iTilessize;
+           mng_adat_tilep    pTiles;
+        } mng_adat;
+typedef mng_adat * mng_adatp;
+#endif
+
+/* ************************************************************************** */
+
+typedef struct {                       /* unknown chunk */
+           mng_chunk_header  sHeader;
+           mng_uint32        iDatasize;
+           mng_ptr           pData;
+        } mng_unknown_chunk;
+typedef mng_unknown_chunk * mng_unknown_chunkp;
+
+/* ************************************************************************** */
+
+#endif /* _libmng_chunks_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_cms.c b/src/3rdparty/libmng/libmng_cms.c
new file mode 100644
index 0000000..999575f
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_cms.c
@@ -0,0 +1,758 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_cms.c              copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : color management routines (implementation)                 * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the color management routines            * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/01/2000 - G.Juyn                                * */
+/* *             - B001(105795) - fixed a typo and misconception about      * */
+/* *               freeing allocated gamma-table. (reported by Marti Maria) * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/09/2000 - G.Juyn                                * */
+/* *             - filled application-based color-management routines       * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added creatememprofile                                   * */
+/* *             - added callback error-reporting support                   * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.5.2 - 06/10/2000 - G.Juyn                                * */
+/* *             - fixed some compilation-warnings (contrib Jason Morris)   * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - fixed problem with color-correction for stored images    * */
+/* *             0.5.3 - 06/23/2000 - G.Juyn                                * */
+/* *             - fixed problem with incorrect gamma-correction            * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/31/2000 - G.Juyn                                * */
+/* *             - fixed sRGB precedence for gamma_only corection           * */
+/* *                                                                        * */
+/* *             0.9.4 - 12/16/2000 - G.Juyn                                * */
+/* *             - fixed mixup of data- & function-pointers (thanks Dimitri)* */
+/* *                                                                        * */
+/* *             1.0.1 - 03/31/2001 - G.Juyn                                * */
+/* *             - ignore gamma=0 (see png-list for more info)              * */
+/* *             1.0.1 - 04/25/2001 - G.Juyn (reported by Gregg Kelly)      * */
+/* *             - fixed problem with cms profile being created multiple    * */
+/* *               times when both iCCP & cHRM/gAMA are present             * */
+/* *             1.0.1 - 04/25/2001 - G.Juyn                                * */
+/* *             - moved mng_clear_cms to libmng_cms                        * */
+/* *             1.0.1 - 05/02/2001 - G.Juyn                                * */
+/* *             - added "default" sRGB generation (Thanks Marti!)          * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/19/2002 - G.Juyn                                * */
+/* *             - optimized color-correction routines                      * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - added in-memory color-correction of abstract images      * */
+/* *             1.0.5 - 11/08/2002 - G.Juyn                                * */
+/* *             - fixed issues in init_app_cms()                           * */
+/* *                                                                        * */
+/* *             1.0.6 - 04/11/2003 - G.Juyn                                * */
+/* *             - B719420 - fixed several MNG_APP_CMS problems             * */
+/* *             1.0.6 - 07/11/2003 - G. R-P                                * */
+/* *             - added conditional MNG_SKIPCHUNK_cHRM/iCCP                * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_objects.h"
+#include "libmng_cms.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Little CMS helper routines                                             * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_LCMS
+
+#define MNG_CMS_FLAGS 0
+
+/* ************************************************************************** */
+
+void mnglcms_initlibrary ()
+{
+  cmsErrorAction (LCMS_ERROR_IGNORE);  /* LCMS should ignore errors! */
+}
+
+/* ************************************************************************** */
+
+mng_cmsprof mnglcms_createfileprofile (mng_pchar zFilename)
+{
+  return cmsOpenProfileFromFile (zFilename, "r");
+}
+
+/* ************************************************************************** */
+
+mng_cmsprof mnglcms_creatememprofile (mng_uint32 iProfilesize,
+                                      mng_ptr    pProfile)
+{
+  return cmsOpenProfileFromMem (pProfile, iProfilesize);
+}
+
+/* ************************************************************************** */
+
+mng_cmsprof mnglcms_createsrgbprofile (void)
+{
+  cmsCIExyY       D65;
+  cmsCIExyYTRIPLE Rec709Primaries = {
+                                      {0.6400, 0.3300, 1.0},
+                                      {0.3000, 0.6000, 1.0},
+                                      {0.1500, 0.0600, 1.0}
+                                    };
+  LPGAMMATABLE    Gamma24[3];
+  mng_cmsprof     hsRGB;
+
+  cmsWhitePointFromTemp(6504, &D65);
+  Gamma24[0] = Gamma24[1] = Gamma24[2] = cmsBuildGamma(256, 2.4);
+  hsRGB = cmsCreateRGBProfile(&D65, &Rec709Primaries, Gamma24);
+  cmsFreeGamma(Gamma24[0]);
+
+  return hsRGB;
+}
+
+/* ************************************************************************** */
+
+void mnglcms_freeprofile (mng_cmsprof hProf)
+{
+  cmsCloseProfile (hProf);
+  return;
+}
+
+/* ************************************************************************** */
+
+void mnglcms_freetransform (mng_cmstrans hTrans)
+{
+/* B001 start */
+  cmsDeleteTransform (hTrans);
+/* B001 end */
+  return;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_clear_cms (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLEAR_CMS, MNG_LC_START);
+#endif
+
+  if (pData->hTrans)                   /* transformation still active ? */
+    mnglcms_freetransform (pData->hTrans);
+
+  pData->hTrans = 0;
+
+  if (pData->hProf1)                   /* file profile still active ? */
+    mnglcms_freeprofile (pData->hProf1);
+
+  pData->hProf1 = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLEAR_CMS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_LCMS */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Color-management initialization & correction routines                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_LCMS
+
+mng_retcode mng_init_full_cms (mng_datap pData,
+                               mng_bool  bGlobal,
+                               mng_bool  bObject,
+                               mng_bool  bRetrobj)
+{
+  mng_cmsprof    hProf;
+  mng_cmstrans   hTrans;
+  mng_imagep     pImage = MNG_NULL;
+  mng_imagedatap pBuf   = MNG_NULL;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_FULL_CMS, MNG_LC_START);
+#endif
+
+  if (bObject)                         /* use object if present ? */
+  {                                    /* current object ? */
+    if ((mng_imagep)pData->pCurrentobj)
+      pImage = (mng_imagep)pData->pCurrentobj;
+    else                               /* if not; use object 0 */
+      pImage = (mng_imagep)pData->pObjzero;
+  }
+
+  if (bRetrobj)                        /* retrieving from an object ? */
+    pImage = (mng_imagep)pData->pRetrieveobj;
+
+  if (pImage)                          /* are we using an object ? */
+    pBuf = pImage->pImgbuf;            /* then address the buffer */
+
+  if ((!pBuf) || (!pBuf->bCorrected))  /* is the buffer already corrected ? */
+  {
+#ifndef MNG_SKIPCHUNK_iCCP
+    if (((pBuf) && (pBuf->bHasICCP)) || ((bGlobal) && (pData->bHasglobalICCP)))
+    {
+      if (!pData->hProf2)              /* output profile not defined ? */
+      {                                /* then assume sRGB !! */
+        pData->hProf2 = mnglcms_createsrgbprofile ();
+
+        if (!pData->hProf2)            /* handle error ? */
+          MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+      }
+
+      if ((pBuf) && (pBuf->bHasICCP))  /* generate a profile handle */
+        hProf = cmsOpenProfileFromMem (pBuf->pProfile, pBuf->iProfilesize);
+      else
+        hProf = cmsOpenProfileFromMem (pData->pGlobalProfile, pData->iGlobalProfilesize);
+
+      pData->hProf1 = hProf;           /* save for future use */
+
+      if (!hProf)                      /* handle error ? */
+        MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (pData->bIsRGBA16)            /* 16-bit intermediates ? */
+        hTrans = cmsCreateTransform (hProf,         TYPE_RGBA_16_SE,
+                                     pData->hProf2, TYPE_RGBA_16_SE,
+                                     INTENT_PERCEPTUAL, MNG_CMS_FLAGS);
+      else
+#endif
+        hTrans = cmsCreateTransform (hProf,         TYPE_RGBA_8,
+                                     pData->hProf2, TYPE_RGBA_8,
+                                     INTENT_PERCEPTUAL, MNG_CMS_FLAGS);
+
+      pData->hTrans = hTrans;          /* save for future use */
+
+      if (!hTrans)                     /* handle error ? */
+        MNG_ERRORL (pData, MNG_LCMS_NOTRANS);
+                                       /* load color-correction routine */
+      pData->fCorrectrow = (mng_fptr)mng_correct_full_cms;
+
+      return MNG_NOERROR;              /* and done */
+    }
+    else
+#endif
+    if (((pBuf) && (pBuf->bHasSRGB)) || ((bGlobal) && (pData->bHasglobalSRGB)))
+    {
+      mng_uint8 iIntent;
+
+      if (pData->bIssRGB)              /* sRGB system ? */
+        return MNG_NOERROR;            /* no conversion required */
+
+      if (!pData->hProf3)              /* sRGB profile not defined ? */
+      {                                /* then create it implicitly !! */
+        pData->hProf3 = mnglcms_createsrgbprofile ();
+
+        if (!pData->hProf3)            /* handle error ? */
+          MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+      }
+
+      hProf = pData->hProf3;           /* convert from sRGB profile */
+
+      if ((pBuf) && (pBuf->bHasSRGB))  /* determine rendering intent */
+        iIntent = pBuf->iRenderingintent;
+      else
+        iIntent = pData->iGlobalRendintent;
+
+      if (pData->bIsRGBA16)            /* 16-bit intermediates ? */
+        hTrans = cmsCreateTransform (hProf,         TYPE_RGBA_16_SE,
+                                     pData->hProf2, TYPE_RGBA_16_SE,
+                                     iIntent, MNG_CMS_FLAGS);
+      else
+        hTrans = cmsCreateTransform (hProf,         TYPE_RGBA_8,
+                                     pData->hProf2, TYPE_RGBA_8,
+                                     iIntent, MNG_CMS_FLAGS);
+
+      pData->hTrans = hTrans;          /* save for future use */
+
+      if (!hTrans)                     /* handle error ? */
+        MNG_ERRORL (pData, MNG_LCMS_NOTRANS);
+                                       /* load color-correction routine */
+      pData->fCorrectrow = (mng_fptr)mng_correct_full_cms;
+
+      return MNG_NOERROR;              /* and done */
+    }
+    else
+    if ( (((pBuf) && (pBuf->bHasCHRM)) || ((bGlobal) && (pData->bHasglobalCHRM))) &&
+         ( ((pBuf) && (pBuf->bHasGAMA) && (pBuf->iGamma > 0)) ||
+           ((bGlobal) && (pData->bHasglobalGAMA) && (pData->iGlobalGamma > 0))  )    )
+    {
+      mng_CIExyY       sWhitepoint;
+      mng_CIExyYTRIPLE sPrimaries;
+      mng_gammatabp    pGammatable[3];
+      mng_float        dGamma;
+
+      if (!pData->hProf2)              /* output profile not defined ? */
+      {                                /* then assume sRGB !! */
+        pData->hProf2 = mnglcms_createsrgbprofile ();
+
+        if (!pData->hProf2)            /* handle error ? */
+          MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+      }
+
+#ifndef MNG_SKIPCHUNK_cHRM
+      if ((pBuf) && (pBuf->bHasCHRM))  /* local cHRM ? */
+      {
+        sWhitepoint.x      = (mng_float)pBuf->iWhitepointx   / 100000;
+        sWhitepoint.y      = (mng_float)pBuf->iWhitepointy   / 100000;
+        sPrimaries.Red.x   = (mng_float)pBuf->iPrimaryredx   / 100000;
+        sPrimaries.Red.y   = (mng_float)pBuf->iPrimaryredy   / 100000;
+        sPrimaries.Green.x = (mng_float)pBuf->iPrimarygreenx / 100000;
+        sPrimaries.Green.y = (mng_float)pBuf->iPrimarygreeny / 100000;
+        sPrimaries.Blue.x  = (mng_float)pBuf->iPrimarybluex  / 100000;
+        sPrimaries.Blue.y  = (mng_float)pBuf->iPrimarybluey  / 100000;
+      }
+      else
+      {
+        sWhitepoint.x      = (mng_float)pData->iGlobalWhitepointx   / 100000;
+        sWhitepoint.y      = (mng_float)pData->iGlobalWhitepointy   / 100000;
+        sPrimaries.Red.x   = (mng_float)pData->iGlobalPrimaryredx   / 100000;
+        sPrimaries.Red.y   = (mng_float)pData->iGlobalPrimaryredy   / 100000;
+        sPrimaries.Green.x = (mng_float)pData->iGlobalPrimarygreenx / 100000;
+        sPrimaries.Green.y = (mng_float)pData->iGlobalPrimarygreeny / 100000;
+        sPrimaries.Blue.x  = (mng_float)pData->iGlobalPrimarybluex  / 100000;
+        sPrimaries.Blue.y  = (mng_float)pData->iGlobalPrimarybluey  / 100000;
+      }
+#endif
+
+      sWhitepoint.Y      =             /* Y component is always 1.0 */
+      sPrimaries.Red.Y   =
+      sPrimaries.Green.Y =
+      sPrimaries.Blue.Y  = 1.0;
+
+      if ((pBuf) && (pBuf->bHasGAMA))  /* get the gamma value */
+        dGamma = (mng_float)pBuf->iGamma / 100000;
+      else
+        dGamma = (mng_float)pData->iGlobalGamma / 100000;
+
+      dGamma = pData->dViewgamma / dGamma;
+
+      pGammatable [0] =                /* and build the lookup tables */
+      pGammatable [1] =
+      pGammatable [2] = cmsBuildGamma (256, dGamma);
+
+      if (!pGammatable [0])            /* enough memory ? */
+        MNG_ERRORL (pData, MNG_LCMS_NOMEM);
+                                       /* create the profile */
+      hProf = cmsCreateRGBProfile (&sWhitepoint, &sPrimaries, pGammatable);
+
+      cmsFreeGamma (pGammatable [0]);  /* free the temporary gamma tables ? */
+                                       /* yes! but just the one! */
+
+      pData->hProf1 = hProf;           /* save for future use */
+
+      if (!hProf)                      /* handle error ? */
+        MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+
+      if (pData->bIsRGBA16)            /* 16-bit intermediates ? */
+        hTrans = cmsCreateTransform (hProf,         TYPE_RGBA_16_SE,
+                                     pData->hProf2, TYPE_RGBA_16_SE,
+                                     INTENT_PERCEPTUAL, MNG_CMS_FLAGS);
+      else
+        hTrans = cmsCreateTransform (hProf,         TYPE_RGBA_8,
+                                     pData->hProf2, TYPE_RGBA_8,
+                                     INTENT_PERCEPTUAL, MNG_CMS_FLAGS);
+
+      pData->hTrans = hTrans;          /* save for future use */
+
+      if (!hTrans)                     /* handle error ? */
+        MNG_ERRORL (pData, MNG_LCMS_NOTRANS);
+                                       /* load color-correction routine */
+      pData->fCorrectrow = (mng_fptr)mng_correct_full_cms;
+
+      return MNG_NOERROR;              /* and done */
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_FULL_CMS, MNG_LC_END);
+#endif
+                                       /* if we get here, we'll only do gamma */
+  return mng_init_gamma_only (pData, bGlobal, bObject, bRetrobj);
+}
+#endif /* MNG_INCLUDE_LCMS */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_LCMS
+mng_retcode mng_correct_full_cms (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CORRECT_FULL_CMS, MNG_LC_START);
+#endif
+
+  cmsDoTransform (pData->hTrans, pData->pRGBArow, pData->pRGBArow, pData->iRowsamples);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CORRECT_FULL_CMS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_LCMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_GAMMA_ONLY) || defined(MNG_FULL_CMS) || defined(MNG_APP_CMS)
+mng_retcode mng_init_gamma_only (mng_datap pData,
+                                 mng_bool  bGlobal,
+                                 mng_bool  bObject,
+                                 mng_bool  bRetrobj)
+{
+  mng_float      dGamma;
+  mng_imagep     pImage = MNG_NULL;
+  mng_imagedatap pBuf   = MNG_NULL;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GAMMA_ONLY, MNG_LC_START);
+#endif
+
+  if (bObject)                         /* use object if present ? */
+  {                                    /* current object ? */
+    if ((mng_imagep)pData->pCurrentobj)
+      pImage = (mng_imagep)pData->pCurrentobj;
+    else                               /* if not; use object 0 */
+      pImage = (mng_imagep)pData->pObjzero;
+  }
+
+  if (bRetrobj)                        /* retrieving from an object ? */
+    pImage = (mng_imagep)pData->pRetrieveobj;
+
+  if (pImage)                          /* are we using an object ? */
+    pBuf = pImage->pImgbuf;            /* then address the buffer */
+
+  if ((!pBuf) || (!pBuf->bCorrected))  /* is the buffer already corrected ? */
+  {
+    if ((pBuf) && (pBuf->bHasSRGB))    /* get the gamma value */
+      dGamma = 0.45455;
+    else
+    if ((pBuf) && (pBuf->bHasGAMA))
+      dGamma = (mng_float)pBuf->iGamma / 100000;
+    else
+    if ((bGlobal) && (pData->bHasglobalSRGB))
+      dGamma = 0.45455;
+    else
+    if ((bGlobal) && (pData->bHasglobalGAMA))
+      dGamma = (mng_float)pData->iGlobalGamma / 100000;
+    else
+      dGamma = pData->dDfltimggamma;
+
+    if (dGamma > 0)                    /* ignore gamma=0 */
+    {
+      dGamma = pData->dViewgamma / (dGamma * pData->dDisplaygamma);
+
+      if (dGamma != pData->dLastgamma) /* lookup table needs to be computed ? */
+      {
+        mng_int32 iX;
+
+        pData->aGammatab [0] = 0;
+
+        for (iX = 1; iX <= 255; iX++)
+          pData->aGammatab [iX] = (mng_uint8)(pow (iX / 255.0, dGamma) * 255 + 0.5);
+
+        pData->dLastgamma = dGamma;    /* keep for next time */
+      }
+                                       /* load color-correction routine */
+      pData->fCorrectrow = (mng_fptr)mng_correct_gamma_only;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GAMMA_ONLY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_GAMMA_ONLY || MNG_FULL_CMS || MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#if defined(MNG_GAMMA_ONLY) || defined(MNG_FULL_CMS) || defined(MNG_APP_CMS)
+mng_retcode mng_correct_gamma_only (mng_datap pData)
+{
+  mng_uint8p pWork;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CORRECT_GAMMA_ONLY, MNG_LC_START);
+#endif
+
+  pWork = pData->pRGBArow;             /* address intermediate row */
+
+  if (pData->bIsRGBA16)                /* 16-bit intermediate row ? */
+  {
+
+  
+     /* TODO: 16-bit precision gamma processing */
+     /* we'll just do the high-order byte for now */
+
+     
+                                       /* convert all samples in the row */
+     for (iX = 0; iX < pData->iRowsamples; iX++)
+     {                                 /* using the precalculated gamma lookup table */
+       *pWork     = pData->aGammatab [*pWork];
+       *(pWork+2) = pData->aGammatab [*(pWork+2)];
+       *(pWork+4) = pData->aGammatab [*(pWork+4)];
+
+       pWork += 8;
+     }
+  }
+  else
+  {                                    /* convert all samples in the row */
+     for (iX = 0; iX < pData->iRowsamples; iX++)
+     {                                 /* using the precalculated gamma lookup table */
+       *pWork     = pData->aGammatab [*pWork];
+       *(pWork+1) = pData->aGammatab [*(pWork+1)];
+       *(pWork+2) = pData->aGammatab [*(pWork+2)];
+
+       pWork += 4;
+     }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CORRECT_GAMMA_ONLY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_GAMMA_ONLY || MNG_FULL_CMS || MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#ifdef MNG_APP_CMS
+mng_retcode mng_init_app_cms (mng_datap pData,
+                              mng_bool  bGlobal,
+                              mng_bool  bObject,
+                              mng_bool  bRetrobj)
+{
+  mng_imagep     pImage = MNG_NULL;
+  mng_imagedatap pBuf   = MNG_NULL;
+  mng_bool       bDone  = MNG_FALSE;
+  mng_retcode    iRetcode;
+  
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_APP_CMS, MNG_LC_START);
+#endif
+
+  if (bObject)                         /* use object if present ? */
+  {                                    /* current object ? */
+    if ((mng_imagep)pData->pCurrentobj)
+      pImage = (mng_imagep)pData->pCurrentobj;
+    else                               /* if not; use object 0 */
+      pImage = (mng_imagep)pData->pObjzero;
+  }
+
+  if (bRetrobj)                        /* retrieving from an object ? */
+    pImage = (mng_imagep)pData->pRetrieveobj;
+
+  if (pImage)                          /* are we using an object ? */
+    pBuf = pImage->pImgbuf;            /* then address the buffer */
+
+  if ((!pBuf) || (!pBuf->bCorrected))  /* is the buffer already corrected ? */
+  {
+#ifndef MNG_SKIPCHUNK_iCCP
+    if ( (pData->fProcessiccp) &&
+         (((pBuf) && (pBuf->bHasICCP)) || ((bGlobal) && (pData->bHasglobalICCP))) )
+    {
+      mng_uint32 iProfilesize;
+      mng_ptr    pProfile;
+
+      if ((pBuf) && (pBuf->bHasICCP))  /* get the right profile */
+      {
+        iProfilesize = pBuf->iProfilesize;
+        pProfile     = pBuf->pProfile;
+      }
+      else
+      {
+        iProfilesize = pData->iGlobalProfilesize;
+        pProfile     = pData->pGlobalProfile;
+      }
+                                       /* inform the app */
+      if (!pData->fProcessiccp ((mng_handle)pData, iProfilesize, pProfile))
+        MNG_ERROR (pData, MNG_APPCMSERROR);
+                                       /* load color-correction routine */
+      pData->fCorrectrow = (mng_fptr)mng_correct_app_cms;
+      bDone              = MNG_TRUE;
+    }
+#endif
+
+    if ( (pData->fProcesssrgb) &&
+         (((pBuf) && (pBuf->bHasSRGB)) || ((bGlobal) && (pData->bHasglobalSRGB))) )
+    {
+      mng_uint8 iIntent;
+
+      if ((pBuf) && (pBuf->bHasSRGB))  /* determine rendering intent */
+        iIntent = pBuf->iRenderingintent;
+      else
+        iIntent = pData->iGlobalRendintent;
+                                       /* inform the app */
+      if (!pData->fProcesssrgb ((mng_handle)pData, iIntent))
+        MNG_ERROR (pData, MNG_APPCMSERROR);
+                                       /* load color-correction routine */
+      pData->fCorrectrow = (mng_fptr)mng_correct_app_cms;
+      bDone              = MNG_TRUE;
+    }
+
+#ifndef MNG_SKIPCHUNK_cHRM
+    if ( (pData->fProcesschroma) &&
+         (((pBuf) && (pBuf->bHasCHRM)) || ((bGlobal) && (pData->bHasglobalCHRM))) )
+    {
+      mng_uint32 iWhitepointx,   iWhitepointy;
+      mng_uint32 iPrimaryredx,   iPrimaryredy;
+      mng_uint32 iPrimarygreenx, iPrimarygreeny;
+      mng_uint32 iPrimarybluex,  iPrimarybluey;
+
+      if ((pBuf) && (pBuf->bHasCHRM))  /* local cHRM ? */
+      {
+        iWhitepointx   = pBuf->iWhitepointx;
+        iWhitepointy   = pBuf->iWhitepointy;
+        iPrimaryredx   = pBuf->iPrimaryredx;
+        iPrimaryredy   = pBuf->iPrimaryredy;
+        iPrimarygreenx = pBuf->iPrimarygreenx;
+        iPrimarygreeny = pBuf->iPrimarygreeny;
+        iPrimarybluex  = pBuf->iPrimarybluex;
+        iPrimarybluey  = pBuf->iPrimarybluey;
+      }
+      else
+      {
+        iWhitepointx   = pData->iGlobalWhitepointx;
+        iWhitepointy   = pData->iGlobalWhitepointy;
+        iPrimaryredx   = pData->iGlobalPrimaryredx;
+        iPrimaryredy   = pData->iGlobalPrimaryredy;
+        iPrimarygreenx = pData->iGlobalPrimarygreenx;
+        iPrimarygreeny = pData->iGlobalPrimarygreeny;
+        iPrimarybluex  = pData->iGlobalPrimarybluex;
+        iPrimarybluey  = pData->iGlobalPrimarybluey;
+      }
+                                       /* inform the app */
+      if (!pData->fProcesschroma ((mng_handle)pData, iWhitepointx,   iWhitepointy,
+                                                     iPrimaryredx,   iPrimaryredy,
+                                                     iPrimarygreenx, iPrimarygreeny,
+                                                     iPrimarybluex,  iPrimarybluey))
+        MNG_ERROR (pData, MNG_APPCMSERROR);
+                                       /* load color-correction routine */
+      pData->fCorrectrow = (mng_fptr)mng_correct_app_cms;
+      bDone              = MNG_TRUE;
+    }
+#endif
+
+    if ( (pData->fProcessgamma) &&
+         (((pBuf) && (pBuf->bHasGAMA)) || ((bGlobal) && (pData->bHasglobalGAMA))) )
+    {
+      mng_uint32 iGamma;
+
+      if ((pBuf) && (pBuf->bHasGAMA))  /* get the gamma value */
+        iGamma = pBuf->iGamma;
+      else
+        iGamma = pData->iGlobalGamma;
+                                       /* inform the app */
+      if (!pData->fProcessgamma ((mng_handle)pData, iGamma))
+      {                                /* app wants us to use internal routines ! */
+        iRetcode = mng_init_gamma_only (pData, bGlobal, bObject, bRetrobj);
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+      else
+      {                                /* load color-correction routine */
+        pData->fCorrectrow = (mng_fptr)mng_correct_app_cms;
+      }
+
+      bDone = MNG_TRUE;
+    }
+
+    if (!bDone)                        /* no color-info at all ? */
+    {
+                                       /* then use default image gamma ! */
+      if (!pData->fProcessgamma ((mng_handle)pData,
+                                 (mng_uint32)((pData->dDfltimggamma * 100000) + 0.5)))
+      {                                /* app wants us to use internal routines ! */
+        iRetcode = mng_init_gamma_only (pData, bGlobal, bObject, bRetrobj);
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+      else
+      {                                /* load color-correction routine */
+        pData->fCorrectrow = (mng_fptr)mng_correct_app_cms;
+      }  
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_APP_CMS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#ifdef MNG_APP_CMS
+mng_retcode mng_correct_app_cms (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CORRECT_APP_CMS, MNG_LC_START);
+#endif
+
+  if (pData->fProcessarow)             /* let the app do something with our row */
+    if (!pData->fProcessarow ((mng_handle)pData, pData->iRowsamples,
+                              pData->bIsRGBA16, pData->pRGBArow))
+      MNG_ERROR (pData, MNG_APPCMSERROR);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CORRECT_APP_CMS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
+
diff --git a/src/3rdparty/libmng/libmng_cms.h b/src/3rdparty/libmng/libmng_cms.h
new file mode 100644
index 0000000..4459f80
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_cms.h
@@ -0,0 +1,92 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_cms.h              copyright (c) 2000-2003 G.Juyn   * */
+/* * version   : 1.0.6                                                      * */
+/* *                                                                        * */
+/* * purpose   : color management routines (definition)                     * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of color management routines                    * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added creatememprofile                                   * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             1.0.1 - 04/25/2001 - G.Juyn                                * */
+/* *             - moved mng_clear_cms to libmng_cms                        * */
+/* *             1.0.1 - 05/02/2001 - G.Juyn                                * */
+/* *             - added "default" sRGB generation (Thanks Marti!)          * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/19/2002 - G.Juyn                                * */
+/* *             - optimized color-correction routines                      * */
+/* *                                                                        * */
+/* *             1.0.6 - 04/11/2003 - G.Juyn                                * */
+/* *             - B719420 - fixed several MNG_APP_CMS problems             * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_cms_h_
+#define _libmng_cms_h_
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_LCMS
+void        mnglcms_initlibrary       (void);
+mng_cmsprof mnglcms_createfileprofile (mng_pchar    zFilename);
+mng_cmsprof mnglcms_creatememprofile  (mng_uint32   iProfilesize,
+                                       mng_ptr      pProfile );
+mng_cmsprof mnglcms_createsrgbprofile (void);
+void        mnglcms_freeprofile       (mng_cmsprof  hProf    );
+void        mnglcms_freetransform     (mng_cmstrans hTrans   );
+
+mng_retcode mng_clear_cms             (mng_datap    pData    );
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_FULL_CMS
+mng_retcode mng_init_full_cms          (mng_datap pData,
+                                        mng_bool  bGlobal,
+                                        mng_bool  bObject,
+                                        mng_bool  bRetrobj);
+mng_retcode mng_correct_full_cms       (mng_datap pData);
+#endif
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_retcode mng_init_gamma_only        (mng_datap pData,
+                                        mng_bool  bGlobal,
+                                        mng_bool  bObject,
+                                        mng_bool  bRetrobj);
+mng_retcode mng_correct_gamma_only     (mng_datap pData);
+#endif
+
+#ifdef MNG_APP_CMS
+mng_retcode mng_init_app_cms           (mng_datap pData,
+                                        mng_bool  bGlobal,
+                                        mng_bool  bObject,
+                                        mng_bool  bRetrobj);
+mng_retcode mng_correct_app_cms        (mng_datap pData);
+#endif
+
+/* ************************************************************************** */
+
+#endif /* _libmng_cms_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_conf.h b/src/3rdparty/libmng/libmng_conf.h
new file mode 100644
index 0000000..8441ee0
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_conf.h
@@ -0,0 +1,295 @@
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_conf.h             copyright (c) G.Juyn 2000-2004   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : main configuration file                                    * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : The configuration file. Change this to include/exclude     * */
+/* *             the options you want or do not want in libmng.             * */
+/* *                                                                        * */
+/* * changes   : 0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - separated configuration-options into this file           * */
+/* *             - changed to most likely configuration (?)                 * */
+/* *             0.5.2 - 06/03/2000 - G.Juyn                                * */
+/* *             - changed options to create a standard so-library          * */
+/* *               with everything enabled                                  * */
+/* *             0.5.2 - 06/04/2000 - G.Juyn                                * */
+/* *             - changed options to create a standard win32-dll           * */
+/* *               with everything enabled                                  * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/12/2000 - G.Juyn                                * */
+/* *             - added workaround for faulty PhotoShop iCCP chunk         * */
+/* *             0.9.3 - 09/16/2000 - G.Juyn                                * */
+/* *             - removed trace-options from default SO/DLL builds         * */
+/* *                                                                        * */
+/* *             1.0.4 - 06/22/2002 - G.Juyn                                * */
+/* *             - B526138 - returned IJGSRC6B calling convention to        * */
+/* *               default for MSVC                                         * */
+/* *                                                                        * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             - added 'supports' call to check function availability     * */
+/* *                                                                        * */
+/* *             1.0.6 - 06/22/2002 - G.R-P                                 * */
+/* *             - added MNG_NO_INCLUDE_JNG conditional                     * */
+/* *             - added MNG_SKIPCHUNK_evNT conditional                     * */
+/* *             1.0.6 - 07/14/2002 - G.R-P                                 * */
+/* *             - added MNG_NO_SUPPORT_FUNCQUERY conditional               * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/07/2004 - G.R-P                                 * */
+/* *             - added MNG_VERSION_QUERY_SUPPORT_ conditional             * */
+/* *                                                                        * */
+/* *             1.0.9 - 05/12/2004 - G.Juyn                                * */
+/* *             - clearified MNG_BIGENDIAN_SUPPORTED conditional           * */
+/* *             - added MNG_LITTLEENDIAN_SUPPORTED conditional             * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_conf_h_
+#define _libmng_conf_h_
+
+#ifdef MNG_MOZILLA_CFG
+#include "special\mozcfg\mozlibmngconf.h"
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  User-selectable compile-time options                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* enable exactly one(1) of the MNG-(sub)set selectors */
+/* use this to select which (sub)set of the MNG specification you wish
+   to support */
+/* generally you'll want full support as the library provides it automatically
+   for you! if you're really strung on memory-requirements you can opt
+   to enable less support (but it's just NOT a good idea!) */
+/* NOTE that this isn't actually implemented yet */
+
+#if !defined(MNG_SUPPORT_FULL) && !defined(MNG_SUPPORT_LC) && !defined(MNG_SUPPORT_VLC)
+#define MNG_SUPPORT_FULL
+/* #define MNG_SUPPORT_LC */
+/* #define MNG_SUPPORT_VLC */
+#endif
+
+/* ************************************************************************** */
+
+/* enable JPEG support if required */
+/* use this to enable the JNG support routines */
+/* this requires an external jpeg package;
+   currently only IJG's jpgsrc6b is supported! */
+/* NOTE that the IJG code can be either 8- or 12-bit (eg. not both);
+   so choose the one you've defined in jconfig.h; if you don't know what
+   the heck I'm talking about, just leave it at 8-bit support (thank you!) */
+
+#ifndef MNG_NO_INCLUDE_JNG
+#ifdef MNG_SUPPORT_FULL                /* full support includes JNG */
+#define MNG_SUPPORT_IJG6B
+#endif
+
+#ifndef MNG_SUPPORT_IJG6B
+#if defined(MNG_BUILD_SO) || defined(MNG_USE_SO) || defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_SUPPORT_IJG6B
+#endif
+#endif
+
+#if defined(MNG_SUPPORT_IJG6B) && !defined(MNG_SUPPORT_JPEG8) && !defined(MNG_SUPPORT_JPEG12)
+#define MNG_SUPPORT_JPEG8
+/* #define MNG_SUPPORT_JPEG12 */
+#endif
+
+/* The following is required to export the IJG routines from the DLL in
+   the Windows-standard calling convention;
+   currently this only works for Borland C++ !!! */
+
+#if defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#if defined(MNG_SUPPORT_IJG6B) && defined(__BORLANDC__)
+#define MNG_DEFINE_JPEG_STDCALL
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+
+/* enable required high-level functions */
+/* use this to select the high-level functions you require */
+/* if you only need to display a MNG, disable write support! */
+/* if you only need to examine a MNG, disable write & display support! */
+/* if you only need to copy a MNG, disable display support! */
+/* if you only need to create a MNG, disable read & display support! */
+/* NOTE that turning all options off will be very unuseful! */
+
+#if !defined(MNG_SUPPORT_READ) && !defined(MNG_SUPPORT_WRITE) && !defined(MNG_SUPPORT_DISPLAY)
+#define MNG_SUPPORT_READ
+#if defined(MNG_BUILD_SO) || defined(MNG_USE_SO) || defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_SUPPORT_WRITE
+#endif
+#define MNG_SUPPORT_DISPLAY
+#endif
+
+/* ************************************************************************** */
+
+/* enable chunk access functions */
+/* use this to select whether you need access to the individual chunks */
+/* useful if you want to examine a read MNG (you'll also need MNG_STORE_CHUNKS !)*/
+/* required if you need to create & write a new MNG! */
+
+#ifndef MNG_ACCESS_CHUNKS
+#if defined(MNG_BUILD_SO) || defined(MNG_USE_SO) || defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_ACCESS_CHUNKS
+#endif
+#endif
+
+/* ************************************************************************** */
+
+/* enable exactly one(1) of the color-management functionality selectors */
+/* use this to select the level of automatic color support */
+/* MNG_FULL_CMS requires the lcms (little cms) external package ! */
+/* if you want your own app (or the OS) to handle color-management
+   select MNG_APP_CMS */
+
+#define MNG_GAMMA_ONLY
+/* #define MNG_FULL_CMS */
+/* #define MNG_APP_CMS */
+
+/* ************************************************************************** */
+
+/* enable automatic dithering */
+/* use this if you need dithering support to convert high-resolution
+   images to a low-resolution output-device */
+/* NOTE that this is not supported yet */
+
+/* #define MNG_AUTO_DITHER */
+
+/* ************************************************************************** */
+
+/* enable whether chunks should be stored for reference later */
+/* use this if you need to examine the chunks of a MNG you have read,
+   or (re-)write a MNG you have read */
+/* turn this off if you want to reduce memory-consumption */
+
+#ifndef MNG_STORE_CHUNKS
+#if defined(MNG_BUILD_SO) || defined(MNG_USE_SO) || defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_STORE_CHUNKS
+#endif
+#endif
+
+/* ************************************************************************** */
+
+/* enable internal memory management (if your compiler supports it) */
+/* use this if your compiler supports the 'standard' memory functions
+   (calloc & free), and you want the library to use these functions and not
+   bother your app with memory-callbacks */
+
+/* #define MNG_INTERNAL_MEMMNGMT */
+
+/* ************************************************************************** */
+
+/* enable internal tracing-functionality (manual debugging purposes) */
+/* use this if you have trouble location bugs or problems */
+/* NOTE that you'll need to specify the trace callback function! */
+
+/* #define MNG_SUPPORT_TRACE */
+
+/* ************************************************************************** */
+
+/* enable extended error- and trace-telltaling */
+/* use this if you need explanatory messages with errors and/or tracing */
+
+#if !defined(MNG_ERROR_TELLTALE) && !defined(MNG_TRACE_TELLTALE)
+#if defined(MNG_BUILD_SO) || defined(MNG_USE_SO) || defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_ERROR_TELLTALE
+#define MNG_TRACE_TELLTALE
+#endif
+#endif
+
+/* ************************************************************************** */
+
+/* enable BIG/LITTLE endian optimizations */
+/* enable BIG if you're on an architecture that supports big-endian reads
+   and writes that aren't word-aligned */
+/* according to reliable sources this only works for PowerPC (bigendian mode)
+   and 680x0 */
+/* enable LITTLE if you're on an architecture that supports little-endian */
+/* when in doubt leave both off !!! */
+
+/* #define MNG_BIGENDIAN_SUPPORTED */
+/* #define MNG_LITTLEENDIAN_SUPPORTED */
+
+/* ************************************************************************** */
+/* enable 'version' functions */
+#if !defined(MNG_VERSION_QUERY_SUPPORT) && \
+    !defined(MNG_NO_VERSION_QUERY_SUPPORT)
+#define MNG_VERSION_QUERY_SUPPORT
+#endif
+
+/* enable 'supports' function */
+/* use this if you need to query the availability of functions at runtime;
+   useful for apps that dynamically load the library and that need specific
+   functions */
+
+#if !defined(MNG_NO_SUPPORT_FUNCQUERY) && !defined(MNG_SUPPORT_FUNCQUERY)
+#if defined(MNG_BUILD_SO) || defined(MNG_USE_SO) || \
+    defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_SUPPORT_FUNCQUERY
+#endif
+#endif
+
+/* ************************************************************************** */
+
+/* enable dynamic MNG features */
+/* use this if you would like to have dynamic support for specifically
+   designed MNGs; eg. this is useful for 'rollover' effects such as common
+   on the world wide web */
+
+#ifndef MNG_SUPPORT_DYNAMICMNG
+#if defined(MNG_BUILD_SO) || defined(MNG_USE_SO) || defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_SUPPORT_DYNAMICMNG
+#endif
+#endif
+#ifndef MNG_SUPPORT_DYNAMICMNG
+#ifndef MNG_SKIPCHUNK_evNT
+#define MNG_SKIPCHUNK_evNT
+#endif
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+#ifndef MNG_NO_ACCESS_JPEG
+#ifndef MNG_ACCESS_JPEG
+#define MNG_ACCESS_JPEG
+#endif
+#endif
+#endif
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifndef MNG_NO_ACCESS_ZLIB
+#ifndef MNG_ACCESS_ZLIB
+#define MNG_ACCESS_ZLIB
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  End of user-selectable compile-time options                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#endif /* _libmng_conf_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_data.h b/src/3rdparty/libmng/libmng_data.h
new file mode 100644
index 0000000..6a00763
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_data.h
@@ -0,0 +1,1032 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_data.h             copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : main data structure definition                             * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the library main data structure              * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/04/2000 - G.Juyn                                * */
+/* *             - added CRC table to main structure (for thread-safety)    * */
+/* *             0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - added iPLTEentries for checking hIST-length              * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed palette definition to exported palette-type      * */
+/* *             - removed frozen indicator                                 * */
+/* *             - added create/write indicators                            * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/13/2000 - G.Juyn                                * */
+/* *             - added eMNGma hack (will be removed in 1.0.0 !!!)         * */
+/* *             - added TERM animation object pointer (easier reference)   * */
+/* *             - added saved-data structure for SAVE/SEEK processing      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/18/2000 - G.Juyn                                * */
+/* *             - added fields for JNG support (IJG-based)                 * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - changed global tRNS definition                           * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added delta-image fields                                 * */
+/* *             0.5.2 - 06/01/2000 - G.Juyn                                * */
+/* *             - added internal delta-image processing callbacks          * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - changed SWAP_ENDIAN to BIGENDIAN_SUPPORTED               * */
+/* *               (contributed by Tim Rowley)                              * */
+/* *             - added getalphaline callback for RGB8_A8 canvasstyle      * */
+/* *             0.5.2 - 06/06/2000 - G.Juyn                                * */
+/* *             - added parameter for delayed buffer-processing            * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - added update-region parms for refresh calback            * */
+/* *             - added Needrefresh parameter                              * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - added Deltaimmediate parm for faster delta-processing    * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added Speed parameter to facilitate testing              * */
+/* *             - added Imagelevel parameter for processtext callback      * */
+/* *             0.5.3 - 06/26/2000 - G.Juyn                                * */
+/* *             - changed userdata variable to mng_ptr                     * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/07/2000 - G.Juyn                                * */
+/* *             - added variables for go_xxxx processing                   * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - added variables for improved timing support              * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added callbacks for SAVE/SEEK processing                 * */
+/* *             - added variable for NEEDSECTIONWAIT breaks                * */
+/* *             - added variable for freeze & reset processing             * */
+/* *             0.9.1 - 07/17/2000 - G.Juyn                                * */
+/* *             - fixed suspension-buffering for 32K+ chunks               * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/29/2000 - G.Juyn                                * */
+/* *             - removed Nextbackxxx fields (no longer used)              * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - fixed wrapping of suspension parameters                  * */
+/* *             0.9.2 - 08/04/2000 - G.Juyn                                * */
+/* *             - B111096 - fixed large-buffer read-suspension             * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 09/10/2000 - G.Juyn                                * */
+/* *             - fixed DEFI behavior                                      * */
+/* *             0.9.3 - 10/10/2000 - G.Juyn                                * */
+/* *             - added support for alpha-depth prediction                 * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added optional support for bKGD for PNG images           * */
+/* *             - added support for JDAA                                   * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *             - fixed support for bKGD                                   * */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - implemented delayed delta-processing                     * */
+/* *             0.9.4 - 12/16/2000 - G.Juyn                                * */
+/* *             - fixed mixup of data- & function-pointers (thanks Dimitri)* */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *             1.0.1 - 02/13/2001 - G.Juyn                                * */
+/* *             - fixed first FRAM_MODE=4 timing problem                   * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *             - added processterm callback                               * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - added option to turn off progressive refresh             * */
+/* *                                                                        * */
+/* *             1.0.5 - 07/08/2002 - G.Juyn                                * */
+/* *             - B578572 - removed eMNGma hack (thanks Dimitri!)          * */
+/* *             1.0.5 - 07/16/2002 - G.Juyn                                * */
+/* *             - B581625 - large chunks fail with suspension reads        * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - fixed LOOP iteration=0 special case                      * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - finished support for BACK image & tiling                 * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - added another fix for misplaced TERM chunk               * */
+/* *             - completed support for condition=2 in TERM chunk          * */
+/* *             1.0.5 - 10/20/2002 - G.Juyn                                * */
+/* *             - fixed processing for multiple objects in MAGN            * */
+/* *             - fixed display of visible target of PAST operation        * */
+/* *             1.0.5 - 11/07/2002 - G.Juyn                                * */
+/* *             - added support to get totals after mng_read()             * */
+/* *             1.0.5 - 24/02/2003 - G.Juyn                                * */
+/* *             - B683152 - libjpeg suspension not always honored correctly* */
+/* *                                                                        * */
+/* *             1.0.6 - 04/11/2003 - G.Juyn                                * */
+/* *             - B719420 - fixed several MNG_APP_CMS problems             * */
+/* *             1.0.6 - 07/05/2003 - G. R-P                                * */
+/* *             - optionally use zlib's crc32() function                   * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added SKIPCHUNK conditionals around PAST chunk support   * */
+/* *             1.0.6 - 08/17/2003 - G.R-P                                 * */
+/* *             - added iPNGdepth member to pData structure                * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - added more SKIPCHUNK conditionals                        * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/02/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *             1.0.8 - 04/10/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/11/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_DISPLAYCALLS              * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_data_h_
+#define _libmng_data_h_
+
+/* ************************************************************************** */
+
+#define MNG_MAGIC 0x52530a0aL
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Internal structures                                                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef mng_palette8 mng_rgbpaltab;
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * The saved_data structure                                               * */
+/* *                                                                        * */
+/* * This contains the saved data after a SAVE chunk has been processed.    * */
+/* * The data is saved from the main data structure during SAVE processing, * */
+/* * and restored to the main data structure during SEEK processing.        * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef struct mng_savedata_struct {
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+           mng_bool          bHasglobalPLTE;     /* global PLTE chunk processed */
+           mng_bool          bHasglobalTRNS;     /* global tRNS chunk processed */
+           mng_bool          bHasglobalGAMA;     /* global gAMA chunk processed */
+           mng_bool          bHasglobalCHRM;     /* global cHRM chunk processed */
+           mng_bool          bHasglobalSRGB;     /* global sRGB chunk processed */
+           mng_bool          bHasglobalICCP;     /* global iCCP chunk processed */
+           mng_bool          bHasglobalBKGD;     /* global bKGD chunk processed */
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+#ifdef MNG_SUPPORT_DISPLAY
+           mng_uint16        iBACKred;           /* BACK fields */
+           mng_uint16        iBACKgreen;
+           mng_uint16        iBACKblue;
+           mng_uint8         iBACKmandatory;
+           mng_uint16        iBACKimageid;
+           mng_uint8         iBACKtile;
+
+           mng_uint8         iFRAMmode;          /* FRAM fields (global) */
+           mng_uint32        iFRAMdelay;
+           mng_uint32        iFRAMtimeout;
+           mng_bool          bFRAMclipping;
+           mng_int32         iFRAMclipl;
+           mng_int32         iFRAMclipr;
+           mng_int32         iFRAMclipt;
+           mng_int32         iFRAMclipb;
+
+           mng_uint32        iGlobalPLTEcount;   /* global PLTE fields */
+           mng_rgbpaltab     aGlobalPLTEentries;
+
+           mng_uint32        iGlobalTRNSrawlen;  /* global tRNS fields */
+           mng_uint8arr      aGlobalTRNSrawdata;
+
+           mng_uint32        iGlobalGamma;       /* global gAMA fields */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+           mng_uint32        iGlobalWhitepointx; /* global cHRM fields */
+           mng_uint32        iGlobalWhitepointy;
+           mng_uint32        iGlobalPrimaryredx;
+           mng_uint32        iGlobalPrimaryredy;
+           mng_uint32        iGlobalPrimarygreenx;
+           mng_uint32        iGlobalPrimarygreeny;
+           mng_uint32        iGlobalPrimarybluex;
+           mng_uint32        iGlobalPrimarybluey;
+#endif
+
+           mng_uint8         iGlobalRendintent;  /* global sRGB fields */
+
+           mng_uint32        iGlobalProfilesize; /* global iCCP fields */
+           mng_ptr           pGlobalProfile;
+
+           mng_uint16        iGlobalBKGDred;     /* global bKGD fields */
+           mng_uint16        iGlobalBKGDgreen;
+           mng_uint16        iGlobalBKGDblue;
+#endif /* MNG_SUPPORT_DISPLAY */
+
+        } mng_savedata;
+
+typedef mng_savedata * mng_savedatap;
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Internal buffer structure for data push mechanisms                     * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef struct {
+           mng_ptr           pNext;              /* for linked list */
+           mng_ptr           pData;              /* used for chunks & data */
+           mng_uint32        iLength;
+           mng_bool          bOwned;
+           mng_uint8p        pDatanext;          /* only used for data */
+           mng_uint32        iRemaining;
+        } mng_pushdata;
+typedef mng_pushdata * mng_pushdatap;
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * The main libmng data structure                                         * */
+/* *                                                                        * */
+/* * The handle used in all functions points to this structure which        * */
+/* * contains all volatile data necessary to process the network graphic.   * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef struct mng_data_struct {
+
+           mng_uint32        iMagic;             /* magic number to validate
+                                                    a given handle */     
+           mng_ptr           pUserdata;          /* application workdata */
+
+           mng_imgtype       eSigtype;           /* image information */
+           mng_imgtype       eImagetype;         /* initially zeroed */
+           mng_uint32        iWidth;             /* filled after header is processed */
+           mng_uint32        iHeight;
+           mng_uint32        iTicks;             /* these only after MHDR */
+           mng_uint32        iLayercount;
+           mng_uint32        iFramecount;
+           mng_uint32        iPlaytime;
+           mng_uint32        iSimplicity;
+           mng_uint8         iAlphadepth;        /* indicates expected alpha-depth */
+
+           mng_uint32        iImagelevel;        /* level of image inside a stream */
+
+           mng_uint32        iCanvasstyle;       /* layout of the drawing-canvas */
+           mng_uint32        iBkgdstyle;         /* layout of the background-canvas */
+
+           mng_int8          iMagnify;           /* magnification factor (not used yet) */
+           mng_uint32        iOffsetx;           /* x-offset for extremely large image */
+           mng_uint32        iOffsety;           /* y-offset for extremely large image */
+           mng_uint32        iCanvaswidth;       /* real canvas size */
+           mng_uint32        iCanvasheight;      /* must be set by processheader callback */
+
+           mng_uint16        iBGred;             /* default background color */
+           mng_uint16        iBGgreen;           /* initially "black" */
+           mng_uint16        iBGblue;
+           mng_bool          bUseBKGD;           /* preferred use of bKGD for PNG */
+
+           mng_bool          bIssRGB;            /* indicates sRGB system */
+
+#ifdef MNG_FULL_CMS                              /* little CMS variables */
+           mng_cmsprof       hProf1;             /* image input profile */
+           mng_cmsprof       hProf2;             /* default output profile */
+           mng_cmsprof       hProf3;             /* default sRGB profile */
+           mng_cmstrans      hTrans;             /* current transformation handle */
+#endif
+
+           mng_float         dViewgamma;         /* gamma calculation variables */
+           mng_float         dDisplaygamma;      /* initially set for sRGB conditions */
+           mng_float         dDfltimggamma;
+
+           mng_bool          bStorechunks;       /* switch for storing chunkdata */
+           mng_bool          bSectionbreaks;     /* indicate NEEDSECTIONWAIT breaks */
+           mng_bool          bCacheplayback;     /* switch to cache playback info */
+           mng_bool          bDoProgressive;     /* progressive refresh for large images */
+           mng_uint32        iCrcmode;           /* CRC existence & checking flags */
+
+           mng_speedtype     iSpeed;             /* speed-modifier for animations */
+
+           mng_uint32        iMaxwidth;          /* maximum canvas size */
+           mng_uint32        iMaxheight;         /* initially set to 1024 x 1024 */
+
+           mng_int32         iErrorcode;         /* error reporting fields */
+           mng_int8          iSeverity;
+           mng_int32         iErrorx1;
+           mng_int32         iErrorx2;
+           mng_pchar         zErrortext;
+
+           mng_memalloc      fMemalloc;          /* callback pointers */
+           mng_memfree       fMemfree;           /* initially nulled */
+           mng_releasedata   fReleasedata;
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+           mng_openstream    fOpenstream;
+           mng_closestream   fClosestream;
+#endif
+           mng_readdata      fReaddata;
+           mng_writedata     fWritedata;
+           mng_errorproc     fErrorproc;
+           mng_traceproc     fTraceproc;
+           mng_processheader fProcessheader;
+           mng_processtext   fProcesstext;
+           mng_processsave   fProcesssave;
+           mng_processseek   fProcessseek;
+           mng_processneed   fProcessneed;
+           mng_processmend   fProcessmend;
+           mng_processunknown fProcessunknown;
+           mng_processterm   fProcessterm;
+           mng_getcanvasline fGetcanvasline;
+           mng_getbkgdline   fGetbkgdline;
+           mng_getalphaline  fGetalphaline;
+           mng_refresh       fRefresh;
+           mng_gettickcount  fGettickcount;
+           mng_settimer      fSettimer;
+           mng_processgamma  fProcessgamma;
+           mng_processchroma fProcesschroma;
+           mng_processsrgb   fProcesssrgb;
+           mng_processiccp   fProcessiccp;
+           mng_processarow   fProcessarow;
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+#ifndef MNG_NO_OLD_VERSIONS
+           mng_bool          bPreDraft48;        /* flags ancient style draft */
+#endif
+
+           mng_chunkid       iChunkname;         /* read/write-state variables */
+           mng_uint32        iChunkseq;
+           mng_chunkp        pFirstchunk;        /* double-linked list of */
+           mng_chunkp        pLastchunk;         /* stored chunk-structures */
+
+           mng_bool          bHasheader;         /* first header chunk processed */
+           mng_bool          bHasMHDR;           /* inside a MHDR-MEND sequence */
+           mng_bool          bHasIHDR;           /* inside a IHDR-IEND sequence */
+           mng_bool          bHasBASI;           /* inside a BASI-IEND sequence */
+           mng_bool          bHasDHDR;           /* inside a DHDR-IEND sequence */
+#ifdef MNG_INCLUDE_JNG
+           mng_bool          bHasJHDR;           /* inside a JHDR-IEND sequence */
+           mng_bool          bHasJSEP;           /* passed the JSEP separator */
+           mng_bool          bHasJDAA;           /* at least 1 JDAA processed */
+           mng_bool          bHasJDAT;           /* at least 1 JDAT processed */
+#endif
+           mng_bool          bHasPLTE;           /* PLTE chunk processed */
+           mng_bool          bHasTRNS;           /* tRNS chunk processed */
+           mng_bool          bHasGAMA;           /* gAMA chunk processed */
+           mng_bool          bHasCHRM;           /* cHRM chunk processed */
+           mng_bool          bHasSRGB;           /* sRGB chunk processed */
+           mng_bool          bHasICCP;           /* iCCP chunk processed */
+           mng_bool          bHasBKGD;           /* bKGD chunk processed */
+           mng_bool          bHasIDAT;           /* at least 1 IDAT processed */
+           
+           mng_bool          bHasSAVE;           /* SAVE chunk processed */
+           mng_bool          bHasBACK;           /* BACK chunk processed */
+           mng_bool          bHasFRAM;           /* FRAM chunk processed */
+           mng_bool          bHasTERM;           /* TERM chunk processed */
+           mng_bool          bHasLOOP;           /* at least 1 LOOP open */
+
+           mng_bool          bHasglobalPLTE;     /* global PLTE chunk processed */
+           mng_bool          bHasglobalTRNS;     /* global tRNS chunk processed */
+           mng_bool          bHasglobalGAMA;     /* global gAMA chunk processed */
+           mng_bool          bHasglobalCHRM;     /* global cHRM chunk processed */
+           mng_bool          bHasglobalSRGB;     /* global sRGB chunk processed */
+           mng_bool          bHasglobalICCP;     /* global iCCP chunk processed */
+           mng_bool          bHasglobalBKGD;     /* global bKGD chunk processed */
+
+           mng_uint32        iDatawidth;         /* IHDR/BASI/DHDR fields */
+           mng_uint32        iDataheight;        /* valid if inside IHDR-IEND, */
+           mng_uint8         iBitdepth;          /* BASI-IEND or DHDR-IEND */
+           mng_uint8         iColortype;
+           mng_uint8         iCompression;
+           mng_uint8         iFilter;
+           mng_uint8         iInterlace;
+
+           mng_uint32        iPLTEcount;         /* PLTE fields */
+
+#ifdef MNG_INCLUDE_JNG
+           mng_uint8         iJHDRcolortype;     /* JHDR fields */
+           mng_uint8         iJHDRimgbitdepth;   /* valid if inside JHDR-IEND */
+           mng_uint8         iJHDRimgcompression;
+           mng_uint8         iJHDRimginterlace;
+           mng_uint8         iJHDRalphabitdepth;
+           mng_uint8         iJHDRalphacompression;
+           mng_uint8         iJHDRalphafilter;
+           mng_uint8         iJHDRalphainterlace;
+#endif
+
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+#ifdef MNG_SUPPORT_READ
+           mng_bool          bReading;           /* read processing variables */
+           mng_bool          bHavesig;
+           mng_bool          bEOF;
+           mng_uint32        iReadbufsize;
+           mng_uint8p        pReadbuf;
+
+           mng_uint32        iLargebufsize;      /* temp for very large chunks */
+           mng_uint8p        pLargebuf;
+
+           mng_uint32        iSuspendtime;       /* tickcount at last suspension */
+           mng_bool          bSuspended;         /* input-reading has been suspended;
+                                                    we're expecting a call to
+                                                    mng_read_resume! */
+           mng_uint8         iSuspendpoint;      /* indicates at which point the flow
+                                                    was broken to suspend input-reading */
+                                                    
+           mng_bool          bSuspensionmode;    /* I/O-suspension variables */
+           mng_uint32        iSuspendbufsize;
+           mng_uint8p        pSuspendbuf;
+           mng_uint8p        pSuspendbufnext;
+           mng_uint32        iSuspendbufleft;
+           mng_uint32        iChunklen;          /* chunk length */
+           mng_uint8p        pReadbufnext;       /* 32K+ suspension-processing */
+           mng_uint8p        pLargebufnext;
+
+           mng_pushdatap     pFirstpushchunk;    /* variables for push mechanisms */
+           mng_pushdatap     pLastpushchunk;
+           mng_pushdatap     pFirstpushdata;
+           mng_pushdatap     pLastpushdata;
+#endif /* MNG_SUPPORT_READ */
+
+#ifdef MNG_SUPPORT_WRITE
+           mng_bool          bCreating;          /* create/write processing variables */
+           mng_bool          bWriting;
+           mng_chunkid       iFirstchunkadded;
+           mng_uint32        iWritebufsize;
+           mng_uint8p        pWritebuf;
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY
+           mng_bool          bDisplaying;        /* display-state variables */
+           mng_bool          bFramedone;
+           mng_uint32        iFrameseq;
+           mng_uint32        iLayerseq;
+           mng_uint32        iFrametime;         /* millisecs */
+
+           mng_uint32        iTotalframes;       /* end-totals after mng_read() */
+           mng_uint32        iTotallayers;
+           mng_uint32        iTotalplaytime;     /* millisecs */
+
+           mng_bool          bSkipping;          /* LOOP iteration=0 */
+           
+#ifdef MNG_SUPPORT_DYNAMICMNG
+           mng_bool          bDynamic;           /* MNG is dynamic (eg. has events) */
+           mng_bool          bRunningevent;      /* currently processing an event */
+           mng_bool          bStopafterseek;     /* stop after next SEEK */
+           mng_int32         iEventx;            /* X/Y of current event */
+           mng_int32         iEventy;
+           mng_objectp       pLastmousemove;     /* last event triggered */
+#endif
+
+           mng_uint32        iRequestframe;      /* go_xxxx variables */
+           mng_uint32        iRequestlayer;
+           mng_uint32        iRequesttime;
+           mng_bool          bSearching;
+
+           mng_bool          bRestorebkgd;       /* flags restore required before IDAT/JDAT */
+
+           mng_uint32        iRuntime;           /* millisecs since start */
+           mng_uint32        iSynctime;          /* tickcount at last framesync */
+           mng_uint32        iStarttime;         /* tickcount at start */
+           mng_uint32        iEndtime;           /* tickcount at end */
+           mng_bool          bRunning;           /* animation is active */
+           mng_bool          bTimerset;          /* the timer has been set;
+                                                    we're expecting a call to
+                                                    mng_display_resume! */
+           mng_uint8         iBreakpoint;        /* indicates at which point the
+                                                    flow was broken to run the timer */
+           mng_bool          bSectionwait;       /* indicates a section break */
+           mng_bool          bFreezing;          /* indicates app requested a freeze */   
+           mng_bool          bResetting;         /* indicates app requested a reset */   
+           mng_bool          bNeedrefresh;       /* indicates screen-refresh is needed */
+           mng_bool          bMisplacedTERM;     /* indicates TERM is out of place */
+           mng_bool          bOnlyfirstframe;    /* show first frame after TERM and stop */
+           mng_uint32        iFramesafterTERM;   /* determines frame-count after TERM */          
+           mng_objectp       pCurrentobj;        /* current "object" */
+           mng_objectp       pCurraniobj;        /* current animation object
+                                                    "to be"/"being" processed */
+           mng_objectp       pTermaniobj;        /* TERM animation object */
+           mng_uint32        iIterations;        /* TERM/MEND iteration count */
+           mng_objectp       pObjzero;           /* "on-the-fly" image (object = 0) */
+           mng_objectp       pLastclone;         /* last clone */
+           mng_objectp       pStoreobj;          /* current store object for row routines */
+           mng_objectp       pStorebuf;          /* current store object-buffer for row routines */
+           mng_objectp       pRetrieveobj;       /* current retrieve object for row routines */
+           mng_savedatap     pSavedata;          /* pointer to saved data (after SAVE) */
+
+           mng_uint32        iUpdateleft;        /* update region for refresh */
+           mng_uint32        iUpdateright;
+           mng_uint32        iUpdatetop;
+           mng_uint32        iUpdatebottom;
+
+           mng_int8          iPass;              /* current interlacing pass;
+                                                    negative value means no interlace */
+           mng_int32         iRow;               /* current row counter */
+           mng_int32         iRowinc;            /* row increment for this pass */
+           mng_int32         iCol;               /* current starting column */
+           mng_int32         iColinc;            /* column increment for this pass */
+           mng_int32         iRowsamples;        /* nr. of samples in current workrow */
+           mng_int32         iSamplemul;         /* needed to calculate rowsize */
+           mng_int32         iSampleofs;            /* from rowsamples */
+           mng_int32         iSamplediv;
+           mng_int32         iRowsize;           /* size of actual data in work row */
+           mng_int32         iRowmax;            /* maximum size of data in work row */
+           mng_int32         iFilterofs;         /* offset to filter-byte in work row */
+           mng_int32         iPixelofs;          /* offset to pixel-bytes in work row */
+           mng_uint32        iLevel0;            /* leveling variables */
+           mng_uint32        iLevel1;
+           mng_uint32        iLevel2;
+           mng_uint32        iLevel3;
+           mng_uint8p        pWorkrow;           /* working row of pixel-data */
+           mng_uint8p        pPrevrow;           /* previous row of pixel-data */
+           mng_uint8p        pRGBArow;           /* intermediate row of RGBA8 or RGBA16 data */
+           mng_bool          bIsRGBA16;          /* indicates intermediate row is RGBA16 */
+           mng_bool          bIsOpaque;          /* indicates intermediate row is fully opaque */
+           mng_int32         iFilterbpp;         /* bpp index for filtering routines */
+
+           mng_int32         iSourcel;           /* variables for showing objects */
+           mng_int32         iSourcer;
+           mng_int32         iSourcet;
+           mng_int32         iSourceb;
+           mng_int32         iDestl;
+           mng_int32         iDestr;
+           mng_int32         iDestt;
+           mng_int32         iDestb;
+
+           mng_objectp       pFirstimgobj;       /* double-linked list of */
+           mng_objectp       pLastimgobj;        /* image-object structures */
+           mng_objectp       pFirstaniobj;       /* double-linked list of */
+           mng_objectp       pLastaniobj;        /* animation-object structures */
+#ifdef MNG_SUPPORT_DYNAMICMNG
+           mng_objectp       pFirstevent;        /* double-linked list of */
+           mng_objectp       pLastevent;         /* event-object structures */
+#endif
+
+#if defined(MNG_GAMMA_ONLY) || defined(MNG_FULL_CMS) || defined(MNG_APP_CMS)
+           mng_uint8         aGammatab[256];     /* precomputed gamma lookup table */
+           mng_float         dLastgamma;         /* last gamma used to compute table */
+#endif
+
+           mng_fptr          fDisplayrow;        /* internal callback to display an
+                                                    uncompressed/unfiltered/
+                                                    color-corrected row */
+           mng_fptr          fRestbkgdrow;       /* internal callback for restore-
+                                                    background processing of a row */
+           mng_fptr          fCorrectrow;        /* internal callback to color-correct an
+                                                    uncompressed/unfiltered row */
+           mng_fptr          fRetrieverow;       /* internal callback to retrieve an
+                                                    uncompressed/unfiltered row of data */
+           mng_fptr          fStorerow;          /* internal callback to store an
+                                                    uncompressed/unfiltered row of data */
+           mng_fptr          fProcessrow;        /* internal callback to process an
+                                                    uncompressed row of data */
+           mng_fptr          fDifferrow;         /* internal callback to perform
+                                                    added filter leveling and
+                                                    differing on an unfiltered row */
+           mng_fptr          fScalerow;          /* internal callback to scale a
+                                                    delta-row to the bitdepth of its target */
+           mng_fptr          fDeltarow;          /* internal callback to execute a
+                                                    delta-row onto a target */
+#ifndef MNG_SKIPCHUNK_PAST
+           mng_fptr          fFliprow;           /* internal callback to flip a row of pixels
+                                                    left<->right for a PAST operation */
+           mng_fptr          fTilerow;           /* internal callback to tile a row of pixels
+                                                    during a PAST operation */
+#endif
+           mng_fptr          fInitrowproc;       /* internal callback to initialize
+                                                    the row processing */
+
+           mng_uint16        iDEFIobjectid;      /* DEFI fields */
+           mng_bool          bDEFIhasdonotshow;
+           mng_uint8         iDEFIdonotshow;
+           mng_bool          bDEFIhasconcrete;
+           mng_uint8         iDEFIconcrete;
+           mng_bool          bDEFIhasloca;
+           mng_int32         iDEFIlocax;
+           mng_int32         iDEFIlocay;
+           mng_bool          bDEFIhasclip;
+           mng_int32         iDEFIclipl;
+           mng_int32         iDEFIclipr;
+           mng_int32         iDEFIclipt;
+           mng_int32         iDEFIclipb;
+
+           mng_uint16        iBACKred;           /* BACK fields */
+           mng_uint16        iBACKgreen;
+           mng_uint16        iBACKblue;
+           mng_uint8         iBACKmandatory;
+           mng_uint16        iBACKimageid;
+           mng_uint8         iBACKtile;
+
+           mng_int32         iBackimgoffsx;      /* temp variables for restore_bkgd */
+           mng_int32         iBackimgoffsy;
+           mng_uint32        iBackimgwidth;
+           mng_uint32        iBackimgheight;
+
+#ifndef MNG_SKIPCHUNK_FRAM
+           mng_uint8         iFRAMmode;          /* FRAM fields (global) */
+           mng_uint32        iFRAMdelay;
+           mng_uint32        iFRAMtimeout;
+           mng_bool          bFRAMclipping;
+           mng_int32         iFRAMclipl;
+           mng_int32         iFRAMclipr;
+           mng_int32         iFRAMclipt;
+           mng_int32         iFRAMclipb;
+
+           mng_uint8         iFramemode;         /* current subframe variables */
+           mng_uint32        iFramedelay;
+           mng_uint32        iFrametimeout;
+           mng_bool          bFrameclipping;
+           mng_int32         iFrameclipl;
+           mng_int32         iFrameclipr;
+           mng_int32         iFrameclipt;
+           mng_int32         iFrameclipb;
+
+           mng_uint32        iNextdelay;         /* delay *after* next image */
+
+           mng_bool          bForcedelay;
+           mng_uint32        iAccumdelay;
+#endif
+
+#ifndef MNG_SKIPCHUNK_SHOW
+           mng_uint8         iSHOWmode;          /* SHOW fields */
+           mng_uint16        iSHOWfromid;
+           mng_uint16        iSHOWtoid;
+           mng_uint16        iSHOWnextid;
+           mng_int16         iSHOWskip;
+#endif
+
+           mng_uint32        iGlobalPLTEcount;   /* global PLTE fields */
+           mng_rgbpaltab     aGlobalPLTEentries;
+
+           mng_uint32        iGlobalTRNSrawlen;  /* global tRNS fields */
+           mng_uint8arr      aGlobalTRNSrawdata;
+
+           mng_uint32        iGlobalGamma;       /* global gAMA fields */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+           mng_uint32        iGlobalWhitepointx; /* global cHRM fields */
+           mng_uint32        iGlobalWhitepointy;
+           mng_uint32        iGlobalPrimaryredx;
+           mng_uint32        iGlobalPrimaryredy;
+           mng_uint32        iGlobalPrimarygreenx;
+           mng_uint32        iGlobalPrimarygreeny;
+           mng_uint32        iGlobalPrimarybluex;
+           mng_uint32        iGlobalPrimarybluey;
+#endif
+
+           mng_uint8         iGlobalRendintent;  /* global sRGB fields */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+           mng_uint32        iGlobalProfilesize; /* global iCCP fields */
+           mng_ptr           pGlobalProfile;
+#endif
+
+           mng_uint16        iGlobalBKGDred;     /* global bKGD fields */
+           mng_uint16        iGlobalBKGDgreen;
+           mng_uint16        iGlobalBKGDblue;
+
+           mng_ptr           pDeltaImage;        /* delta-image fields */
+           mng_uint8         iDeltaImagetype;
+#endif /* MNG_SUPPORT_DISPLAY */
+           mng_uint8         iDeltatype;         /* need this one in read processing !! */
+#ifdef MNG_SUPPORT_DISPLAY
+           mng_uint32        iDeltaBlockwidth;
+           mng_uint32        iDeltaBlockheight;
+           mng_uint32        iDeltaBlockx;
+           mng_uint32        iDeltaBlocky;
+           mng_bool          bDeltaimmediate;
+
+           mng_fptr          fDeltagetrow;       /* internal delta-proc callbacks */
+           mng_fptr          fDeltaaddrow;
+           mng_fptr          fDeltareplacerow;
+           mng_fptr          fDeltaputrow;
+
+#ifndef MNG_SKIPCHUNK_PROM
+           mng_fptr          fPromoterow;        /* internal PROM fields */
+           mng_fptr          fPromBitdepth;
+           mng_ptr           pPromBuf;
+           mng_uint8         iPromColortype;
+           mng_uint8         iPromBitdepth;
+           mng_uint8         iPromFilltype;
+           mng_uint32        iPromWidth;
+           mng_ptr           pPromSrc;
+           mng_ptr           pPromDst;
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+           mng_uint16        iMAGNfromid;
+           mng_uint16        iMAGNcurrentid;
+           mng_uint16        iMAGNtoid;
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+           mng_uint16        iPASTid;
+           mng_int32         iPastx;             /* target x/y of last PAST */
+           mng_int32         iPasty;
+#endif
+
+           mng_objectp       pLastseek;          /* last processed ani_seek object */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+           mng_objectp       pMPNG;              /* mpNG object if available */
+#endif
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+           mng_objectp       pANG;               /* ANG object if available */
+#endif
+
+#endif /* MNG_SUPPORT_DISPLAY */
+
+#ifdef MNG_INCLUDE_ZLIB
+           z_stream          sZlib;              /* zlib (de)compression variables */
+
+           mng_int32         iZlevel;            /* zlib compression parameters */
+           mng_int32         iZmethod;
+           mng_int32         iZwindowbits;
+           mng_int32         iZmemlevel;
+           mng_int32         iZstrategy;
+
+           mng_uint32        iMaxIDAT;           /* maximum size of IDAT data */
+
+           mng_bool          bInflating;         /* indicates "inflate" in progress */
+           mng_bool          bDeflating;         /* indicates "deflate" in progress */
+#endif /* MNG_INCLUDE_ZLIB */
+
+#ifdef MNG_INCLUDE_JNG
+           mngjpeg_dctmethod eJPEGdctmethod;     /* IJG compression variables */
+           mng_int32         iJPEGquality;
+           mng_int32         iJPEGsmoothing;
+           mng_bool          bJPEGcompressprogr;
+           mng_bool          bJPEGcompressopt;
+
+           mng_uint32        iMaxJDAT;           /* maximum size of JDAT/JDAA data */
+
+           mngjpeg_compp     pJPEGcinfo;         /* compression structure */
+           mngjpeg_errorp    pJPEGcerr;          /* error-manager compress */
+
+           mngjpeg_decompp   pJPEGdinfo;         /* decompression structure (JDAT) */
+           mngjpeg_errorp    pJPEGderr;          /* error-manager decompress (JDAT) */
+           mngjpeg_sourcep   pJPEGdsrc;          /* source-manager decompress (JDAT) */
+
+           mngjpeg_decompp   pJPEGdinfo2;        /* decompression structure (JDAA) */
+           mngjpeg_errorp    pJPEGderr2;         /* error-manager decompress (JDAA) */
+           mngjpeg_sourcep   pJPEGdsrc2;         /* source-manager decompress (JDAA) */
+
+           mng_uint8p        pJPEGbuf;           /* buffer for JPEG (de)compression (JDAT) */
+           mng_uint32        iJPEGbufmax;        /* allocated space for buffer (JDAT) */
+           mng_uint8p        pJPEGcurrent;       /* current pointer into buffer (JDAT) */
+           mng_uint32        iJPEGbufremain;     /* remaining bytes in buffer (JDAT) */
+           mng_uint32        iJPEGtoskip;        /* bytes to skip on next input-block (JDAT) */
+
+           mng_uint8p        pJPEGbuf2;          /* buffer for JPEG (de)compression (JDAA) */
+           mng_uint32        iJPEGbufmax2;       /* allocated space for buffer (JDAA) */
+           mng_uint8p        pJPEGcurrent2;      /* current pointer into buffer (JDAA) */
+           mng_uint32        iJPEGbufremain2;    /* remaining bytes in buffer (JDAA) */
+           mng_uint32        iJPEGtoskip2;       /* bytes to skip on next input-block (JDAA) */
+
+           mng_uint8p        pJPEGrow;           /* buffer for a JPEG row of samples (JDAT) */
+           mng_uint32        iJPEGrowlen;
+
+           mng_uint8p        pJPEGrow2;          /* buffer for a JPEG row of samples (JDAA) */
+           mng_uint32        iJPEGrowlen2;
+
+           mng_bool          bJPEGcompress;      /* indicates "compress" initialized */
+
+           mng_bool          bJPEGdecompress;    /* indicates "decompress" initialized (JDAT) */
+           mng_bool          bJPEGhasheader;     /* indicates "readheader" succeeded (JDAT) */
+           mng_bool          bJPEGdecostarted;   /* indicates "decompress" started (JDAT) */
+           mng_bool          bJPEGscanstarted;   /* indicates "first scan" started (JDAT) */
+           mng_bool          bJPEGscanending;    /* indicates "finish_output" suspended (JDAT) */
+           mng_bool          bJPEGprogressive;   /* indicates a progressive image (JDAT) */
+
+           mng_bool          bJPEGdecompress2;   /* indicates "decompress" initialized (JDAA) */
+           mng_bool          bJPEGhasheader2;    /* indicates "readheader" succeeded (JDAA) */
+           mng_bool          bJPEGdecostarted2;  /* indicates "decompress" started (JDAA) */
+           mng_bool          bJPEGscanstarted2;  /* indicates "first scan" started (JDAA) */
+           mng_bool          bJPEGprogressive2;  /* indicates a progressive image (JDAA) */
+
+           mng_fptr          fStorerow2;         /* internal callback to store an
+                                                    uncompressed/unfiltered row of JPEG-data (JDAT) */
+
+           mng_fptr          fStorerow3;         /* internal callback to store an
+                                                    uncompressed/unfiltered row of JPEG-data (JDAA) */
+
+           mng_uint32        iJPEGrow;           /* row-number for current JPEG row */
+           mng_uint32        iJPEGalpharow;      /* nr. of rows filled with alpha */
+           mng_uint32        iJPEGrgbrow;        /* nr. of rows filled with 'color'-info */
+           mng_uint32        iJPEGdisprow;       /* nr. of rows already displayed "on-the-fly" */
+
+#if defined(MNG_USE_SETJMP) && defined (MNG_INCLUDE_IJG6B)
+           jmp_buf           sErrorbuf;          /* setjmp/longjmp buffer (error-recovery) */
+#endif
+
+#endif /* MNG_INCLUDE_JNG */
+
+#ifndef MNG_USE_ZLIB_CRC
+           mng_uint32        aCRCtable [256];    /* CRC prefab table */
+           mng_bool          bCRCcomputed;       /* "has been built" indicator */
+#endif
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+           png_imgtype       ePng_imgtype;
+#endif
+
+#if defined(MNG_NO_1_2_4BIT_SUPPORT) || defined(MNG_NO_16BIT_SUPPORT)
+           mng_uint8         iPNGdepth;          /* Real input depth */
+           mng_uint8         iPNGmult;
+#endif
+
+#ifdef MNG_OPTIMIZE_DISPLAYCALLS
+           mng_uint32        iRawlen;            /* temp vars for display processing */
+           mng_uint8p        pRawdata;
+#ifndef MNG_SKIPCHUNK_BASI
+           mng_uint16        iBASIred;
+           mng_uint16        iBASIgreen;
+           mng_uint16        iBASIblue;
+           mng_bool          bBASIhasalpha;
+           mng_uint16        iBASIalpha;
+           mng_uint8         iBASIviewable;
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+           mng_uint16        iCLONsourceid;
+           mng_uint16        iCLONcloneid;
+           mng_uint8         iCLONclonetype;
+           mng_bool          bCLONhasdonotshow;
+           mng_uint8         iCLONdonotshow;
+           mng_uint8         iCLONconcrete;
+           mng_bool          bCLONhasloca;
+           mng_uint8         iCLONlocationtype;
+           mng_int32         iCLONlocationx;
+           mng_int32         iCLONlocationy;
+#endif
+#ifndef MNG_SKIPCHUNK_DISC
+           mng_uint32        iDISCcount;
+           mng_uint16p       pDISCids;
+#endif
+#ifndef MNG_SKIPCHUNK_FRAM
+           mng_uint8         iTempFramemode;
+           mng_uint8         iTempChangedelay;
+           mng_uint32        iTempDelay;
+           mng_uint8         iTempChangetimeout;
+           mng_uint32        iTempTimeout;
+           mng_uint8         iTempChangeclipping;
+           mng_uint8         iTempCliptype;
+           mng_int32         iTempClipl;
+           mng_int32         iTempClipr;
+           mng_int32         iTempClipt;
+           mng_int32         iTempClipb;
+#endif
+#ifndef MNG_SKIPCHUNK_MOVE
+           mng_uint16        iMOVEfromid;
+           mng_uint16        iMOVEtoid;
+           mng_uint8         iMOVEmovetype;
+           mng_int32         iMOVEmovex;
+           mng_int32         iMOVEmovey;
+#endif
+#ifndef MNG_SKIPCHUNK_CLIP
+           mng_uint16        iCLIPfromid;
+           mng_uint16        iCLIPtoid;
+           mng_uint8         iCLIPcliptype;
+           mng_int32         iCLIPclipl;
+           mng_int32         iCLIPclipr;
+           mng_int32         iCLIPclipt;
+           mng_int32         iCLIPclipb;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+           mng_uint16        iDHDRobjectid;
+           mng_uint8         iDHDRimagetype;
+           mng_uint8         iDHDRdeltatype;
+           mng_uint32        iDHDRblockwidth;
+           mng_uint32        iDHDRblockheight;
+           mng_uint32        iDHDRblockx;
+           mng_uint32        iDHDRblocky;
+           mng_uint8         iPROMbitdepth;
+           mng_uint8         iPROMcolortype;
+           mng_uint8         iPROMfilltype;
+           mng_uint8         iPPLTtype;
+           mng_uint32        iPPLTcount;
+           mng_palette8ep    paPPLTindexentries;
+           mng_uint8p        paPPLTalphaentries;
+           mng_uint8p        paPPLTusedentries;
+#endif
+#ifndef MNG_SKIPCHUNK_MAGN
+           mng_uint16        iMAGNfirstid;
+           mng_uint16        iMAGNlastid;
+           mng_uint8         iMAGNmethodX;
+           mng_uint16        iMAGNmX;
+           mng_uint16        iMAGNmY;
+           mng_uint16        iMAGNmL;
+           mng_uint16        iMAGNmR;
+           mng_uint16        iMAGNmT;
+           mng_uint16        iMAGNmB;
+           mng_uint8         iMAGNmethodY;
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+           mng_uint16        iPASTtargetid;
+           mng_uint8         iPASTtargettype;
+           mng_int32         iPASTtargetx;
+           mng_int32         iPASTtargety;
+           mng_uint32        iPASTcount;
+           mng_ptr           pPASTsources;
+#endif
+#endif /* MNG_OPTIMIZE_DISPLAYCALLS */
+
+        } mng_data;
+
+typedef mng_data * mng_datap;
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Internal Callback-Function prototypes                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef mng_retcode(*mng_displayrow)  (mng_datap  pData);
+typedef mng_retcode(*mng_restbkgdrow) (mng_datap  pData);
+typedef mng_retcode(*mng_correctrow)  (mng_datap  pData);
+typedef mng_retcode(*mng_retrieverow) (mng_datap  pData);
+typedef mng_retcode(*mng_storerow)    (mng_datap  pData);
+typedef mng_retcode(*mng_processrow)  (mng_datap  pData);
+typedef mng_retcode(*mng_initrowproc) (mng_datap  pData);
+typedef mng_retcode(*mng_differrow)   (mng_datap  pData);
+typedef mng_retcode(*mng_scalerow)    (mng_datap  pData);
+typedef mng_retcode(*mng_deltarow)    (mng_datap  pData);
+typedef mng_retcode(*mng_promoterow)  (mng_datap  pData);
+typedef mng_retcode(*mng_fliprow)     (mng_datap  pData);
+typedef mng_retcode(*mng_tilerow)     (mng_datap  pData);
+
+typedef mng_uint8  (*mng_bitdepth_8)  (mng_uint8  iB);
+typedef mng_uint16 (*mng_bitdepth_16) (mng_uint8  iB);
+
+typedef mng_retcode(*mng_magnify_x)   (mng_datap  pData,
+                                       mng_uint16 iMX,
+                                       mng_uint16 iML,
+                                       mng_uint16 iMR,
+                                       mng_uint32 iWidth,
+                                       mng_uint8p iSrcline,
+                                       mng_uint8p iDstline);
+typedef mng_retcode(*mng_magnify_y)   (mng_datap  pData,
+                                       mng_int32  iM,
+                                       mng_int32  iS,
+                                       mng_uint32 iWidth,
+                                       mng_uint8p iSrcline1,
+                                       mng_uint8p iSrcline2,
+                                       mng_uint8p iDstline);
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Routines for swapping byte-order from and to graphic files             * */
+/* * (This code is adapted from the libpng package)                         * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_BIGENDIAN_SUPPORTED
+mng_uint32 mng_get_uint32 (mng_uint8p pBuf);
+mng_int32  mng_get_int32  (mng_uint8p pBuf);
+mng_uint16 mng_get_uint16 (mng_uint8p pBuf);
+void       mng_put_uint32 (mng_uint8p pBuf,
+                           mng_uint32 i);
+void       mng_put_int32  (mng_uint8p pBuf,
+                           mng_int32  i);
+void       mng_put_uint16 (mng_uint8p pBuf,
+                           mng_uint16 i);
+#else /* MNG_BIGENDIAN_SUPPORTED */
+#define mng_get_uint32(P)   *(mng_uint32p)(P)
+#define mng_get_int32(P)    *(mng_int32p)(P)
+#define mng_get_uint16(P)   *(mng_uint16p)(P)
+#define mng_put_uint32(P,I) *(mng_uint32p)(P) = (I)
+#define mng_put_int32(P,I)  *(mng_int32p)(P) = (I)
+#define mng_put_uint16(P,I) *(mng_uint16p)(P) = (I)
+#endif /* MNG_BIGENDIAN_SUPPORTED */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Some handy(?) macro definitions                                        * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MAX_COORD(a, b)  (((a) > (b)) ? (a) : (b))
+#define MIN_COORD(a, b)  (((a) < (b)) ? (a) : (b))
+
+/* ************************************************************************** */
+
+#endif /* _libmng_data_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_display.c b/src/3rdparty/libmng/libmng_display.c
new file mode 100644
index 0000000..81c2484
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_display.c
@@ -0,0 +1,7140 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_display.c          copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Display management (implementation)                        * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the display management routines          * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added callback error-reporting support                   * */
+/* *             - fixed frame_delay misalignment                           * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - added sanity check for frozen status                     * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *             0.5.1 - 05/13/2000 - G.Juyn                                * */
+/* *             - changed display_mend to reset state to initial or SAVE   * */
+/* *             - added eMNGma hack (will be removed in 1.0.0 !!!)         * */
+/* *             - added TERM animation object pointer (easier reference)   * */
+/* *             - added process_save & process_seek routines               * */
+/* *             0.5.1 - 05/14/2000 - G.Juyn                                * */
+/* *             - added save_state and restore_state for SAVE/SEEK/TERM    * */
+/* *               processing                                               * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - added JNG support (JHDR/JDAT)                            * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - fixed problem with DEFI clipping                         * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added delta-image support (DHDR,PROM,IPNG,IJNG)          * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - fixed pointer confusion (contributed by Tim Rowley)      * */
+/* *             0.5.2 - 06/03/2000 - G.Juyn                                * */
+/* *             - fixed makeup for Linux gcc compile                       * */
+/* *             0.5.2 - 06/05/2000 - G.Juyn                                * */
+/* *             - added support for RGB8_A8 canvasstyle                    * */
+/* *             0.5.2 - 06/09/2000 - G.Juyn                                * */
+/* *             - fixed timer-handling to run with Mozilla (Tim Rowley)    * */
+/* *             0.5.2 - 06/10/2000 - G.Juyn                                * */
+/* *             - fixed some compilation-warnings (contrib Jason Morris)   * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/12/2000 - G.Juyn                                * */
+/* *             - fixed display of stored JNG images                       * */
+/* *             0.5.3 - 06/13/2000 - G.Juyn                                * */
+/* *             - fixed problem with BASI-IEND as object 0                 * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - changed progressive-display processing                   * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - changed delta-image processing                           * */
+/* *             0.5.3 - 06/20/2000 - G.Juyn                                * */
+/* *             - fixed some minor stuff                                   * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added speed-modifier to timing routine                   * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - added support for PPLT chunk processing                  * */
+/* *             0.5.3 - 06/29/2000 - G.Juyn                                * */
+/* *             - swapped refresh parameters                               * */
+/* *                                                                        * */
+/* *             0.9.0 - 06/30/2000 - G.Juyn                                * */
+/* *             - changed refresh parameters to 'x,y,width,height'         * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/07/2000 - G.Juyn                                * */
+/* *             - implemented support for freeze/reset/resume & go_xxxx    * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - added support for improved timing                        * */
+/* *             0.9.1 - 07/14/2000 - G.Juyn                                * */
+/* *             - changed EOF processing behavior                          * */
+/* *             - fixed TERM delay processing                              * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - fixed freeze & reset processing                          * */
+/* *             0.9.1 - 07/16/2000 - G.Juyn                                * */
+/* *             - fixed storage of images during mng_read()                * */
+/* *             - fixed support for mng_display() after mng_read()         * */
+/* *             0.9.1 - 07/24/2000 - G.Juyn                                * */
+/* *             - fixed reading of still-images                            * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/07/2000 - G.Juyn                                * */
+/* *             - B111300 - fixup for improved portability                 * */
+/* *             0.9.3 - 08/21/2000 - G.Juyn                                * */
+/* *             - fixed TERM processing delay of 0 msecs                   * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/10/2000 - G.Juyn                                * */
+/* *             - fixed problem with no refresh after TERM                 * */
+/* *             - fixed DEFI behavior                                      * */
+/* *             0.9.3 - 09/16/2000 - G.Juyn                                * */
+/* *             - fixed timing & refresh behavior for single PNG/JNG       * */
+/* *             0.9.3 - 09/19/2000 - G.Juyn                                * */
+/* *             - refixed timing & refresh behavior for single PNG/JNG     * */
+/* *             0.9.3 - 10/02/2000 - G.Juyn                                * */
+/* *             - fixed timing again (this is getting boring...)           * */
+/* *             - refixed problem with no refresh after TERM               * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added JDAA chunk                                         * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - fixed support for bKGD                                   * */
+/* *             0.9.3 - 10/18/2000 - G.Juyn                                * */
+/* *             - fixed delta-processing behavior                          * */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - added storage for pixel-/alpha-sampledepth for delta's   * */
+/* *             0.9.3 - 10/27/2000 - G.Juyn                                * */
+/* *             - fixed separate read() & display() processing             * */
+/* *                                                                        * */
+/* *             0.9.4 - 10/31/2000 - G.Juyn                                * */
+/* *             - fixed possible loop in display_resume() (Thanks Vova!)   * */
+/* *             0.9.4 - 11/20/2000 - G.Juyn                                * */
+/* *             - fixed unwanted repetition in mng_readdisplay()           * */
+/* *             0.9.4 - 11/24/2000 - G.Juyn                                * */
+/* *             - moved restore of object 0 to libmng_display              * */
+/* *             - added restore of object 0 to TERM processing !!!         * */
+/* *             - fixed TERM delay processing                              * */
+/* *             - fixed TERM end processing (count = 0)                    * */
+/* *             0.9.4 - 12/16/2000 - G.Juyn                                * */
+/* *             - fixed mixup of data- & function-pointers (thanks Dimitri)* */
+/* *             0.9.4 -  1/18/2001 - G.Juyn                                * */
+/* *             - removed test filter-methods 1 & 65                       * */
+/* *             - set default level-set for filtertype=64 to all zeroes    * */
+/* *                                                                        * */
+/* *             0.9.5 -  1/20/2001 - G.Juyn                                * */
+/* *             - fixed compiler-warnings Mozilla (thanks Tim)             * */
+/* *             0.9.5 -  1/23/2001 - G.Juyn                                * */
+/* *             - fixed timing-problem with switching framing_modes        * */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *             1.0.1 - 02/13/2001 - G.Juyn                                * */
+/* *             - fixed first FRAM_MODE=4 timing problem                   * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn                                * */
+/* *             - fixed memory-leak for JNGs with alpha (Thanks Gregg!)    * */
+/* *             - added BGRA8 canvas with premultiplied alpha              * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - fixed memory-leak with delta-images (Thanks Michael!)    * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             - completed delta-image support                            * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/13/2002 - G.Juyn                                * */
+/* *             - fixed read/write of MAGN chunk                           * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - fixed LOOP iteration=0 special case                      * */
+/* *             1.0.5 - 09/19/2002 - G.Juyn                                * */
+/* *             - fixed color-correction for restore-background handling   * */
+/* *             - optimized restore-background for bKGD cases              * */
+/* *             - cleaned up some old stuff                                * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - finished support for BACK image & tiling                 * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 09/22/2002 - G.Juyn                                * */
+/* *             - added bgrx8 canvas (filler byte)                         * */
+/* *             1.0.5 - 10/05/2002 - G.Juyn                                * */
+/* *             - fixed dropping mix of frozen/unfrozen objects            * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - added proposed change in handling of TERM- & if-delay    * */
+/* *             - added another fix for misplaced TERM chunk               * */
+/* *             - completed support for condition=2 in TERM chunk          * */
+/* *             1.0.5 - 10/18/2002 - G.Juyn                                * */
+/* *             - fixed clipping-problem with BACK tiling (Thanks Sakura!) * */
+/* *             1.0.5 - 10/20/2002 - G.Juyn                                * */
+/* *             - fixed processing for multiple objects in MAGN            * */
+/* *             - fixed display of visible target of PAST operation        * */
+/* *             1.0.5 - 10/30/2002 - G.Juyn                                * */
+/* *             - modified TERM/MEND processing for max(1, TERM_delay,     * */
+/* *               interframe_delay)                                        * */
+/* *             1.0.5 - 11/04/2002 - G.Juyn                                * */
+/* *             - fixed layer- & frame-counting during read()              * */
+/* *             - fixed goframe/golayer/gotime processing                  * */
+/* *             1.0.5 - 01/19/2003 - G.Juyn                                * */
+/* *             - B654627 - fixed SEGV when no gettickcount callback       * */
+/* *             - B664383 - fixed typo                                     * */
+/* *             - finalized changes in TERM/final_delay to elected proposal* */
+/* *                                                                        * */
+/* *             1.0.6 - 05/11/2003 - G. Juyn                               * */
+/* *             - added conditionals around canvas update routines         * */
+/* *             1.0.6 - 05/25/2003 - G.R-P                                 * */
+/* *             - added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added conditionals around some JNG-supporting code       * */
+/* *             - added conditionals around 16-bit supporting code         * */
+/* *             - reversed some loops to use decrementing counter          * */
+/* *             - combined init functions into one function                * */
+/* *             1.0.6 - 07/10/2003 - G.R-P                                 * */
+/* *             - replaced nested switches with simple init setup function * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *             1.0.6 - 08/17/2003 - G.R-P                                 * */
+/* *             - added conditionals around non-VLC chunk support          * */
+/* *                                                                        * */
+/* *             1.0.7 - 11/27/2003 - R.A                                   * */
+/* *             - added CANVAS_RGB565 and CANVAS_BGR565                    * */
+/* *             1.0.7 - 12/06/2003 - R.A                                   * */
+/* *             - added CANVAS_RGBA565 and CANVAS_BGRA565                  * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *                                                                        * */
+/* *             1.0.8 - 03/31/2004 - G.Juyn                                * */
+/* *             - fixed problem with PAST usage where source > dest        * */
+/* *             1.0.8 - 05/04/2004 - G.R-P.                                * */
+/* *             - fixed misplaced 16-bit conditionals                      * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/18/2004 - G.R-P.                                * */
+/* *             - revised some SKIPCHUNK conditionals                      * */
+/* *             1.0.9 - 10/10/2004 - G.R-P.                                * */
+/* *             - added MNG_NO_1_2_4BIT_SUPPORT                            * */
+/* *             1.0.9 - 10/14/2004 - G.Juyn                                * */
+/* *             - added bgr565_a8 canvas-style (thanks to J. Elvander)     * */
+/* *             1.0.9 - 12/11/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_DISPLAYCALLS              * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* *             1.0.10 - 07/06/2005 - G.R-P.                               * */
+/* *             - added more SKIPCHUNK conditionals                        * */
+/* *             1.0.10 - 12/28/2005 - G.R-P.                               * */
+/* *             - added missing SKIPCHUNK_MAGN conditional                 * */
+/* *             1.0.10 - 03/07/2006 - (thanks to W. Manthey)               * */
+/* *             - added CANVAS_RGB555 and CANVAS_BGR555                    * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - fixed several compiler warnings                          * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_chunks.h"
+#include "libmng_objects.h"
+#include "libmng_object_prc.h"
+#include "libmng_memory.h"
+#include "libmng_zlib.h"
+#include "libmng_jpeg.h"
+#include "libmng_cms.h"
+#include "libmng_pixels.h"
+#include "libmng_display.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode set_delay (mng_datap  pData,
+                                 mng_uint32 iInterval)
+{
+  if (!iInterval)                      /* at least 1 msec please! */
+    iInterval = 1;
+
+  if (pData->bRunning)                 /* only when really displaying */
+    if (!pData->fSettimer ((mng_handle)pData, iInterval))
+      MNG_ERROR (pData, MNG_APPTIMERERROR);
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+  if ((!pData->bDynamic) || (pData->bRunning))
+#else
+  if (pData->bRunning)
+#endif
+    pData->bTimerset = MNG_TRUE;       /* and indicate so */
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_uint32 calculate_delay (mng_datap  pData,
+                                      mng_uint32 iDelay)
+{
+  mng_uint32 iTicks   = pData->iTicks;
+  mng_uint32 iWaitfor = 1;             /* default non-MNG delay */
+
+  if (!iTicks)                         /* tick_count not specified ? */
+    if (pData->eImagetype == mng_it_mng)
+      iTicks = 1000;
+
+  if (iTicks)
+  {
+    switch (pData->iSpeed)             /* honor speed modifier */
+    {
+      case mng_st_fast :
+        {
+          iWaitfor = (mng_uint32)(( 500 * iDelay) / iTicks);
+          break;
+        }
+      case mng_st_slow :
+        {
+          iWaitfor = (mng_uint32)((3000 * iDelay) / iTicks);
+          break;
+        }
+      case mng_st_slowest :
+        {
+          iWaitfor = (mng_uint32)((8000 * iDelay) / iTicks);
+          break;
+        }
+      default :
+        {
+          iWaitfor = (mng_uint32)((1000 * iDelay) / iTicks);
+        }
+    }
+  }
+
+  return iWaitfor;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Progressive display refresh - does the call to the refresh callback    * */
+/* * and sets the timer to allow the app to perform the actual refresh to   * */
+/* * the screen (eg. process its main message-loop)                         * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_display_progressive_refresh (mng_datap  pData,
+                                             mng_uint32 iInterval)
+{
+  {                                    /* let the app refresh first ? */
+    if ((pData->bRunning) && (!pData->bSkipping) &&
+        (pData->iUpdatetop < pData->iUpdatebottom) && (pData->iUpdateleft < pData->iUpdateright))
+    {
+      if (!pData->fRefresh (((mng_handle)pData),
+                            pData->iUpdateleft, pData->iUpdatetop,
+                            pData->iUpdateright  - pData->iUpdateleft,
+                            pData->iUpdatebottom - pData->iUpdatetop))
+        MNG_ERROR (pData, MNG_APPMISCERROR);
+
+      pData->iUpdateleft   = 0;        /* reset update-region */
+      pData->iUpdateright  = 0;
+      pData->iUpdatetop    = 0;
+      pData->iUpdatebottom = 0;        /* reset refreshneeded indicator */
+      pData->bNeedrefresh  = MNG_FALSE;
+                                       /* interval requested ? */
+      if ((!pData->bFreezing) && (iInterval))
+      {                                /* setup the timer */
+        mng_retcode iRetcode = set_delay (pData, iInterval);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+    }
+  }
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Generic display routines                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode interframe_delay (mng_datap pData)
+{
+  mng_uint32  iWaitfor = 0;
+  mng_uint32  iInterval;
+  mng_uint32  iRuninterval;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INTERFRAME_DELAY, MNG_LC_START);
+#endif
+
+  {
+#ifndef MNG_SKIPCHUNK_FRAM
+    if (pData->iFramedelay > 0 || pData->bForcedelay) /* real delay ? */
+    {                                  /* let the app refresh first ? */
+      pData->bForcedelay = MNG_FALSE;
+      if ((pData->bRunning) && (!pData->bSkipping) &&
+          (pData->iUpdatetop < pData->iUpdatebottom) && (pData->iUpdateleft < pData->iUpdateright))
+        if (!pData->fRefresh (((mng_handle)pData),
+                              pData->iUpdateleft,  pData->iUpdatetop,
+                              pData->iUpdateright - pData->iUpdateleft,
+                              pData->iUpdatebottom - pData->iUpdatetop))
+          MNG_ERROR (pData, MNG_APPMISCERROR);
+
+      pData->iUpdateleft   = 0;        /* reset update-region */
+      pData->iUpdateright  = 0;
+      pData->iUpdatetop    = 0;
+      pData->iUpdatebottom = 0;        /* reset refreshneeded indicator */
+      pData->bNeedrefresh  = MNG_FALSE;
+
+#ifndef MNG_SKIPCHUNK_TERM
+      if (pData->bOnlyfirstframe)      /* only processing first frame after TERM ? */
+      {
+        pData->iFramesafterTERM++;
+                                       /* did we do a frame yet ? */
+        if (pData->iFramesafterTERM > 1)
+        {                              /* then that's it; just stop right here ! */
+          pData->pCurraniobj = MNG_NULL;
+          pData->bRunning    = MNG_FALSE;
+
+          return MNG_NOERROR;
+        }
+      }
+#endif
+
+      if (pData->fGettickcount)
+      {                                /* get current tickcount */
+        pData->iRuntime = pData->fGettickcount ((mng_handle)pData);
+                                       /* calculate interval since last sync-point */
+        if (pData->iRuntime < pData->iSynctime)
+          iRuninterval    = pData->iRuntime + ~pData->iSynctime + 1;
+        else
+          iRuninterval    = pData->iRuntime - pData->iSynctime;
+                                       /* calculate actual run-time */
+        if (pData->iRuntime < pData->iStarttime)
+          pData->iRuntime = pData->iRuntime + ~pData->iStarttime + 1;
+        else
+          pData->iRuntime = pData->iRuntime - pData->iStarttime;
+      }
+      else
+      {
+        iRuninterval = 0;
+      }
+
+      iWaitfor = calculate_delay (pData, pData->iFramedelay);
+
+      if (iWaitfor > iRuninterval)     /* delay necessary ? */
+        iInterval = iWaitfor - iRuninterval;
+      else
+        iInterval = 1;                 /* force app to process messageloop */
+                                       /* set the timer ? */
+      if (((pData->bRunning) || (pData->bSearching) || (pData->bReading)) &&
+          (!pData->bSkipping))
+      {
+        iRetcode = set_delay (pData, iInterval);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+    }
+
+    if (!pData->bSkipping)             /* increase frametime in advance */
+      pData->iFrametime = pData->iFrametime + iWaitfor;
+                                       /* setup for next delay */
+    pData->iFramedelay = pData->iNextdelay;
+    pData->iAccumdelay += pData->iFramedelay;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INTERFRAME_DELAY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL void set_display_routine (mng_datap pData)
+{                                        /* actively running ? */
+  if (((pData->bRunning) || (pData->bSearching)) && (!pData->bSkipping))
+  {
+    switch (pData->iCanvasstyle)         /* determine display routine */
+    {
+#ifndef MNG_SKIPCANVAS_RGB8
+      case MNG_CANVAS_RGB8    : { pData->fDisplayrow = (mng_fptr)mng_display_rgb8;     break; }
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA8
+      case MNG_CANVAS_RGBA8   : { pData->fDisplayrow = (mng_fptr)mng_display_rgba8;    break; }
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA8_PM
+      case MNG_CANVAS_RGBA8_PM: { pData->fDisplayrow = (mng_fptr)mng_display_rgba8_pm; break; }
+#endif
+#ifndef MNG_SKIPCANVAS_ARGB8
+      case MNG_CANVAS_ARGB8   : { pData->fDisplayrow = (mng_fptr)mng_display_argb8;    break; }
+#endif
+#ifndef MNG_SKIPCANVAS_ARGB8_PM
+      case MNG_CANVAS_ARGB8_PM: { pData->fDisplayrow = (mng_fptr)mng_display_argb8_pm; break; }
+#endif
+#ifndef MNG_SKIPCANVAS_RGB8_A8
+      case MNG_CANVAS_RGB8_A8 : { pData->fDisplayrow = (mng_fptr)mng_display_rgb8_a8;  break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGR8
+      case MNG_CANVAS_BGR8    : { pData->fDisplayrow = (mng_fptr)mng_display_bgr8;     break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGRX8
+      case MNG_CANVAS_BGRX8   : { pData->fDisplayrow = (mng_fptr)mng_display_bgrx8;    break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA8
+      case MNG_CANVAS_BGRA8   : { pData->fDisplayrow = (mng_fptr)mng_display_bgra8;    break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA8_PM
+      case MNG_CANVAS_BGRA8_PM: { pData->fDisplayrow = (mng_fptr)mng_display_bgra8_pm; break; }
+#endif
+#ifndef MNG_SKIPCANVAS_ABGR8
+      case MNG_CANVAS_ABGR8   : { pData->fDisplayrow = (mng_fptr)mng_display_abgr8;    break; }
+#endif
+#ifndef MNG_SKIPCANVAS_ABGR8_PM
+      case MNG_CANVAS_ABGR8_PM: { pData->fDisplayrow = (mng_fptr)mng_display_abgr8_pm; break; }
+#endif
+#ifndef MNG_SKIPCANVAS_RGB565
+      case MNG_CANVAS_RGB565  : { pData->fDisplayrow = (mng_fptr)mng_display_rgb565;   break; }
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA565
+      case MNG_CANVAS_RGBA565 : { pData->fDisplayrow = (mng_fptr)mng_display_rgba565;  break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565
+      case MNG_CANVAS_BGR565  : { pData->fDisplayrow = (mng_fptr)mng_display_bgr565;   break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA565
+      case MNG_CANVAS_BGRA565 : { pData->fDisplayrow = (mng_fptr)mng_display_bgra565;  break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565_A8
+      case MNG_CANVAS_BGR565_A8 : { pData->fDisplayrow = (mng_fptr)mng_display_bgr565_a8;  break; }
+#endif
+#ifndef MNG_SKIPCANVAS_RGB555
+      case MNG_CANVAS_RGB555  : { pData->fDisplayrow = (mng_fptr)mng_display_rgb555;  break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGR555
+      case MNG_CANVAS_BGR555  : { pData->fDisplayrow = (mng_fptr)mng_display_bgr555;  break; }
+#endif
+
+#ifndef MNG_NO_16BIT_SUPPORT
+/*      case MNG_CANVAS_RGB16   : { pData->fDisplayrow = (mng_fptr)mng_display_rgb16;    break; } */
+/*      case MNG_CANVAS_RGBA16  : { pData->fDisplayrow = (mng_fptr)mng_display_rgba16;   break; } */
+/*      case MNG_CANVAS_ARGB16  : { pData->fDisplayrow = (mng_fptr)mng_display_argb16;   break; } */
+/*      case MNG_CANVAS_BGR16   : { pData->fDisplayrow = (mng_fptr)mng_display_bgr16;    break; } */
+/*      case MNG_CANVAS_BGRA16  : { pData->fDisplayrow = (mng_fptr)mng_display_bgra16;   break; } */
+/*      case MNG_CANVAS_ABGR16  : { pData->fDisplayrow = (mng_fptr)mng_display_abgr16;   break; } */
+#endif
+/*      case MNG_CANVAS_INDEX8  : { pData->fDisplayrow = (mng_fptr)mng_display_index8;   break; } */
+/*      case MNG_CANVAS_INDEXA8 : { pData->fDisplayrow = (mng_fptr)mng_display_indexa8;  break; } */
+/*      case MNG_CANVAS_AINDEX8 : { pData->fDisplayrow = (mng_fptr)mng_display_aindex8;  break; } */
+/*      case MNG_CANVAS_GRAY8   : { pData->fDisplayrow = (mng_fptr)mng_display_gray8;    break; } */
+/*      case MNG_CANVAS_AGRAY8  : { pData->fDisplayrow = (mng_fptr)mng_display_agray8;   break; } */
+/*      case MNG_CANVAS_GRAYA8  : { pData->fDisplayrow = (mng_fptr)mng_display_graya8;   break; } */
+#ifndef MNG_NO_16BIT_SUPPORT
+/*      case MNG_CANVAS_GRAY16  : { pData->fDisplayrow = (mng_fptr)mng_display_gray16;   break; } */
+/*      case MNG_CANVAS_GRAYA16 : { pData->fDisplayrow = (mng_fptr)mng_display_graya16;  break; } */
+/*      case MNG_CANVAS_AGRAY16 : { pData->fDisplayrow = (mng_fptr)mng_display_agray16;  break; } */
+#endif
+/*      case MNG_CANVAS_DX15    : { pData->fDisplayrow = (mng_fptr)mng_display_dx15;     break; } */
+/*      case MNG_CANVAS_DX16    : { pData->fDisplayrow = (mng_fptr)mng_display_dx16;     break; } */
+    }
+  }
+
+  return;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode load_bkgdlayer (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_LOAD_BKGDLAYER, MNG_LC_START);
+#endif
+                                       /* actively running ? */
+  if (((pData->bRunning) || (pData->bSearching)) && (!pData->bSkipping))
+  {
+    mng_int32   iY;
+    mng_retcode iRetcode;
+    mng_bool    bColorcorr   = MNG_FALSE;
+                                       /* save values */
+    mng_int32   iDestl       = pData->iDestl;
+    mng_int32   iDestr       = pData->iDestr;
+    mng_int32   iDestt       = pData->iDestt;
+    mng_int32   iDestb       = pData->iDestb;
+    mng_int32   iSourcel     = pData->iSourcel;
+    mng_int32   iSourcer     = pData->iSourcer;
+    mng_int32   iSourcet     = pData->iSourcet;
+    mng_int32   iSourceb     = pData->iSourceb;
+    mng_int8    iPass        = pData->iPass;
+    mng_int32   iRow         = pData->iRow;
+    mng_int32   iRowinc      = pData->iRowinc;
+    mng_int32   iCol         = pData->iCol;
+    mng_int32   iColinc      = pData->iColinc;
+    mng_int32   iRowsamples  = pData->iRowsamples;
+    mng_int32   iRowsize     = pData->iRowsize;
+    mng_uint8p  pPrevrow     = pData->pPrevrow;
+    mng_uint8p  pRGBArow     = pData->pRGBArow;
+    mng_bool    bIsRGBA16    = pData->bIsRGBA16;
+    mng_bool    bIsOpaque    = pData->bIsOpaque;
+    mng_fptr    fCorrectrow  = pData->fCorrectrow;
+    mng_fptr    fDisplayrow  = pData->fDisplayrow;
+    mng_fptr    fRetrieverow = pData->fRetrieverow;
+    mng_objectp pCurrentobj  = pData->pCurrentobj;
+    mng_objectp pRetrieveobj = pData->pRetrieveobj;
+
+    pData->iDestl   = 0;               /* determine clipping region */
+    pData->iDestt   = 0;
+    pData->iDestr   = pData->iWidth;
+    pData->iDestb   = pData->iHeight;
+
+#ifndef MNG_SKIPCHUNK_FRAM
+    if (pData->bFrameclipping)         /* frame clipping specified ? */
+    {
+      pData->iDestl = MAX_COORD (pData->iDestl,  pData->iFrameclipl);
+      pData->iDestt = MAX_COORD (pData->iDestt,  pData->iFrameclipt);
+      pData->iDestr = MIN_COORD (pData->iDestr,  pData->iFrameclipr);
+      pData->iDestb = MIN_COORD (pData->iDestb,  pData->iFrameclipb);
+    }
+#endif
+                                       /* anything to clear ? */
+    if ((pData->iDestr >= pData->iDestl) && (pData->iDestb >= pData->iDestt))
+    {
+      pData->iPass       = -1;         /* these are the object's dimensions now */
+      pData->iRow        = 0;
+      pData->iRowinc     = 1;
+      pData->iCol        = 0;
+      pData->iColinc     = 1;
+      pData->iRowsamples = pData->iWidth;
+      pData->iRowsize    = pData->iRowsamples << 2;
+      pData->bIsRGBA16   = MNG_FALSE;  /* let's keep it simple ! */
+      pData->bIsOpaque   = MNG_TRUE;
+
+      pData->iSourcel    = 0;          /* source relative to destination */
+      pData->iSourcer    = pData->iDestr - pData->iDestl;
+      pData->iSourcet    = 0;
+      pData->iSourceb    = pData->iDestb - pData->iDestt;
+
+      set_display_routine (pData);     /* determine display routine */
+                                       /* default restore using preset BG color */
+      pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_bgcolor;
+
+#ifndef MNG_SKIPCHUNK_bKGD
+      if (((pData->eImagetype == mng_it_png) || (pData->eImagetype == mng_it_jng)) &&
+          (pData->bUseBKGD))
+      {                                /* prefer bKGD in PNG/JNG */
+        if (!pData->pCurrentobj)
+          pData->pCurrentobj = pData->pObjzero;
+
+        if (((mng_imagep)pData->pCurrentobj)->pImgbuf->bHasBKGD)
+        {
+          pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_bkgd;
+          bColorcorr          = MNG_TRUE;
+        }
+      }
+#endif
+
+      if (pData->fGetbkgdline)         /* background-canvas-access callback set ? */
+      {
+        switch (pData->iBkgdstyle)
+        {
+#ifndef MNG_SKIPCANVAS_RGB8
+          case MNG_CANVAS_RGB8    : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_rgb8;    break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGR8
+          case MNG_CANVAS_BGR8    : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_bgr8;    break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGRX8
+          case MNG_CANVAS_BGRX8   : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_bgrx8;   break; }
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565
+          case MNG_CANVAS_BGR565  : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_bgr565;  break; }
+#endif
+#ifndef MNG_SKIPCANVAS_RGB565
+          case MNG_CANVAS_RGB565  : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_rgb565;  break; }
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+  /*        case MNG_CANVAS_RGB16   : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_rgb16;   break; } */
+  /*        case MNG_CANVAS_BGR16   : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_bgr16;   break; } */
+#endif
+  /*        case MNG_CANVAS_INDEX8  : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_index8;  break; } */
+  /*        case MNG_CANVAS_GRAY8   : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_gray8;   break; } */
+#ifndef MNG_NO_16BIT_SUPPORT
+  /*        case MNG_CANVAS_GRAY16  : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_gray16;  break; } */
+#endif
+  /*        case MNG_CANVAS_DX15    : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_dx15;    break; } */
+  /*        case MNG_CANVAS_DX16    : { pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_dx16;    break; } */
+        }
+      }
+
+#ifndef MNG_SKIPCHUNK_BACK
+      if (pData->bHasBACK)
+      {                                /* background image ? */
+        if ((pData->iBACKmandatory & 0x02) && (pData->iBACKimageid))
+        {
+          pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_backcolor;
+          bColorcorr          = MNG_TRUE;
+        }
+        else                           /* background color ? */
+        if (pData->iBACKmandatory & 0x01)
+        {
+          pData->fRestbkgdrow = (mng_fptr)mng_restore_bkgd_backcolor;
+          bColorcorr          = MNG_TRUE;
+        }
+      }
+#endif
+
+      pData->fCorrectrow = MNG_NULL;   /* default no color-correction */
+
+      if (bColorcorr)                  /* do we have to do color-correction ? */
+      {
+#ifdef MNG_NO_CMS
+        iRetcode = MNG_NOERROR;
+#else
+#if defined(MNG_FULL_CMS)              /* determine color-management routine */
+        iRetcode = mng_init_full_cms   (pData, MNG_TRUE, MNG_FALSE, MNG_FALSE);
+#elif defined(MNG_GAMMA_ONLY)
+        iRetcode = mng_init_gamma_only (pData, MNG_TRUE, MNG_FALSE, MNG_FALSE);
+#elif defined(MNG_APP_CMS)
+        iRetcode = mng_init_app_cms    (pData, MNG_TRUE, MNG_FALSE, MNG_FALSE);
+#endif
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+#endif /* MNG_NO_CMS */
+      }
+                                       /* get a temporary row-buffer */
+      MNG_ALLOC (pData, pData->pRGBArow, pData->iRowsize);
+
+      iY       = pData->iDestt;        /* this is where we start */
+      iRetcode = MNG_NOERROR;          /* so far, so good */
+
+      while ((!iRetcode) && (iY < pData->iDestb))
+      {                                /* restore a background row */
+        iRetcode = ((mng_restbkgdrow)pData->fRestbkgdrow) (pData);
+                                       /* color correction ? */
+        if ((!iRetcode) && (pData->fCorrectrow))
+          iRetcode = ((mng_correctrow)pData->fCorrectrow) (pData);
+
+        if (!iRetcode)                 /* so... display it */
+          iRetcode = ((mng_displayrow)pData->fDisplayrow) (pData);
+
+        if (!iRetcode)
+          iRetcode = mng_next_row (pData);
+
+        iY++;                          /* and next line */
+      }
+                                       /* drop the temporary row-buffer */
+      MNG_FREE (pData, pData->pRGBArow, pData->iRowsize);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+
+#if defined(MNG_FULL_CMS)              /* cleanup cms stuff */
+      if (bColorcorr)                  /* did we do color-correction ? */
+      {
+        iRetcode = mng_clear_cms (pData);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+#endif
+#ifndef MNG_SKIPCHUNK_BACK
+                                       /* background image ? */
+      if ((pData->bHasBACK) && (pData->iBACKmandatory & 0x02) && (pData->iBACKimageid))
+      {
+        mng_imagep pImage;
+                                       /* let's find that object then */
+        pData->pRetrieveobj = mng_find_imageobject (pData, pData->iBACKimageid);
+        pImage              = (mng_imagep)pData->pRetrieveobj;
+                                       /* exists, viewable and visible ? */
+        if ((pImage) && (pImage->bViewable) && (pImage->bVisible))
+        {                              /* will it fall within the target region ? */
+          if ((pImage->iPosx < pData->iDestr) && (pImage->iPosy < pData->iDestb)             &&
+              ((pData->iBACKtile) ||
+               ((pImage->iPosx + (mng_int32)pImage->pImgbuf->iWidth  >= pData->iDestl) &&
+                (pImage->iPosy + (mng_int32)pImage->pImgbuf->iHeight >= pData->iDestt)    )) &&
+              ((!pImage->bClipped) ||
+               ((pImage->iClipl <= pImage->iClipr) && (pImage->iClipt <= pImage->iClipb)     &&
+                (pImage->iClipl < pData->iDestr)   && (pImage->iClipr >= pData->iDestl)      &&
+                (pImage->iClipt < pData->iDestb)   && (pImage->iClipb >= pData->iDestt)         )))
+          {                            /* right; we've got ourselves something to do */
+            if (pImage->bClipped)      /* clip output region with image's clipping region ? */
+            {
+              if (pImage->iClipl > pData->iDestl)
+                pData->iDestl = pImage->iClipl;
+              if (pImage->iClipr < pData->iDestr)
+                pData->iDestr = pImage->iClipr;
+              if (pImage->iClipt > pData->iDestt)
+                pData->iDestt = pImage->iClipt;
+              if (pImage->iClipb < pData->iDestb)
+                pData->iDestb = pImage->iClipb;
+            }
+                                       /* image offset does some extra clipping too ! */
+            if (pImage->iPosx > pData->iDestl)
+              pData->iDestl = pImage->iPosx;
+            if (pImage->iPosy > pData->iDestt)
+              pData->iDestt = pImage->iPosy;
+
+            if (!pData->iBACKtile)     /* without tiling further clipping is needed */
+            {
+              if (pImage->iPosx + (mng_int32)pImage->pImgbuf->iWidth  < pData->iDestr)
+                pData->iDestr = pImage->iPosx + (mng_int32)pImage->pImgbuf->iWidth;
+              if (pImage->iPosy + (mng_int32)pImage->pImgbuf->iHeight < pData->iDestb)
+                pData->iDestb = pImage->iPosy + (mng_int32)pImage->pImgbuf->iHeight;
+            }
+            
+            pData->iSourcel    = 0;    /* source relative to destination */
+            pData->iSourcer    = pData->iDestr - pData->iDestl;
+            pData->iSourcet    = 0;
+            pData->iSourceb    = pData->iDestb - pData->iDestt;
+                                       /* 16-bit background ? */
+
+#ifdef MNG_NO_16BIT_SUPPORT
+            pData->bIsRGBA16   = MNG_FALSE;
+#else
+            pData->bIsRGBA16      = (mng_bool)(pImage->pImgbuf->iBitdepth > 8);
+#endif
+                                       /* let restore routine know the offsets !!! */
+            pData->iBackimgoffsx  = pImage->iPosx;
+            pData->iBackimgoffsy  = pImage->iPosy;
+            pData->iBackimgwidth  = pImage->pImgbuf->iWidth;
+            pData->iBackimgheight = pImage->pImgbuf->iHeight;
+            pData->iRow           = 0; /* start at the top again !! */
+                                       /* determine background object retrieval routine */
+            switch (pImage->pImgbuf->iColortype)
+            {
+              case  0 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                          if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_g16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_g8;
+
+                          pData->bIsOpaque      = (mng_bool)(!pImage->pImgbuf->bHasTRNS);
+                          break;
+                        }
+
+              case  2 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                          if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb8;
+
+                          pData->bIsOpaque      = (mng_bool)(!pImage->pImgbuf->bHasTRNS);
+                          break;
+                        }
+
+              case  3 : { pData->fRetrieverow   = (mng_fptr)mng_retrieve_idx8;
+                          pData->bIsOpaque      = (mng_bool)(!pImage->pImgbuf->bHasTRNS);
+                          break;
+                        }
+
+              case  4 : { 
+#ifndef MNG_NO_16BIT_SUPPORT
+			if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_ga16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_ga8;
+
+                          pData->bIsOpaque      = MNG_FALSE;
+                          break;
+                        }
+
+              case  6 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                          if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+
+                          pData->bIsOpaque      = MNG_FALSE;
+                          break;
+                        }
+
+              case  8 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                          if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_g16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_g8;
+
+                          pData->bIsOpaque      = MNG_TRUE;
+                          break;
+                        }
+
+              case 10 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                          if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb8;
+
+                          pData->bIsOpaque      = MNG_TRUE;
+                          break;
+                        }
+
+              case 12 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                          if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_ga16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_ga8;
+
+                          pData->bIsOpaque      = MNG_FALSE;
+                          break;
+                        }
+
+              case 14 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                          if (pImage->pImgbuf->iBitdepth > 8)
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba16;
+                          else
+#endif
+                            pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+
+                          pData->bIsOpaque      = MNG_FALSE;
+                          break;
+                        }
+            }
+
+#ifdef MNG_NO_CMS
+            iRetcode = MNG_NOERROR;
+#else
+#if defined(MNG_FULL_CMS)              /* determine color-management routine */
+            iRetcode = mng_init_full_cms   (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_GAMMA_ONLY)
+            iRetcode = mng_init_gamma_only (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_APP_CMS)
+            iRetcode = mng_init_app_cms    (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#endif
+            if (iRetcode)              /* on error bail out */
+              return iRetcode;
+#endif /* MNG_NO_CMS */
+                                       /* get temporary row-buffers */
+            MNG_ALLOC (pData, pData->pPrevrow, pData->iRowsize);
+            MNG_ALLOC (pData, pData->pRGBArow, pData->iRowsize);
+
+            iY       = pData->iDestt;  /* this is where we start */
+            iRetcode = MNG_NOERROR;    /* so far, so good */
+
+            while ((!iRetcode) && (iY < pData->iDestb))
+            {                          /* restore a background row */
+              iRetcode = mng_restore_bkgd_backimage (pData);
+                                       /* color correction ? */
+              if ((!iRetcode) && (pData->fCorrectrow))
+                iRetcode = ((mng_correctrow)pData->fCorrectrow) (pData);
+
+              if (!iRetcode)           /* so... display it */
+                iRetcode = ((mng_displayrow)pData->fDisplayrow) (pData);
+
+              if (!iRetcode)
+                iRetcode = mng_next_row (pData);
+
+              iY++;                    /* and next line */
+            }
+                                       /* drop temporary row-buffers */
+            MNG_FREE (pData, pData->pRGBArow, pData->iRowsize);
+            MNG_FREE (pData, pData->pPrevrow, pData->iRowsize);
+
+            if (iRetcode)              /* on error bail out */
+              return iRetcode;
+
+#if defined(MNG_FULL_CMS)              /* cleanup cms stuff */
+            iRetcode = mng_clear_cms (pData);
+
+            if (iRetcode)              /* on error bail out */
+              return iRetcode;
+#endif
+          }
+        }
+      }
+#endif
+    }
+
+    pData->iDestl       = iDestl;      /* restore values */
+    pData->iDestr       = iDestr;
+    pData->iDestt       = iDestt;
+    pData->iDestb       = iDestb;
+    pData->iSourcel     = iSourcel;
+    pData->iSourcer     = iSourcer;
+    pData->iSourcet     = iSourcet;
+    pData->iSourceb     = iSourceb;
+    pData->iPass        = iPass;
+    pData->iRow         = iRow;
+    pData->iRowinc      = iRowinc;
+    pData->iCol         = iCol;
+    pData->iColinc      = iColinc;
+    pData->iRowsamples  = iRowsamples;
+    pData->iRowsize     = iRowsize;
+    pData->pPrevrow     = pPrevrow;
+    pData->pRGBArow     = pRGBArow;
+    pData->bIsRGBA16    = bIsRGBA16;
+    pData->bIsOpaque    = bIsOpaque;
+    pData->fCorrectrow  = fCorrectrow;
+    pData->fDisplayrow  = fDisplayrow; 
+    pData->fRetrieverow = fRetrieverow;
+    pData->pCurrentobj  = pCurrentobj;
+    pData->pRetrieveobj = pRetrieveobj;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_LOAD_BKGDLAYER, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode clear_canvas (mng_datap pData)
+{
+  mng_int32   iY;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLEAR_CANVAS, MNG_LC_START);
+#endif
+
+  pData->iDestl      = 0;              /* clipping region is full canvas! */
+  pData->iDestt      = 0;
+  pData->iDestr      = pData->iWidth;
+  pData->iDestb      = pData->iHeight;
+
+  pData->iSourcel    = 0;              /* source is same as destination */
+  pData->iSourcer    = pData->iWidth;
+  pData->iSourcet    = 0;
+  pData->iSourceb    = pData->iHeight;
+
+  pData->iPass       = -1;             /* these are the object's dimensions now */
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iWidth;
+  pData->iRowsize    = pData->iRowsamples << 2;
+  pData->bIsRGBA16   = MNG_FALSE;      /* let's keep it simple ! */
+  pData->bIsOpaque   = MNG_TRUE;
+
+  set_display_routine (pData);         /* determine display routine */
+                                       /* get a temporary row-buffer */
+                                       /* it's transparent black by default!! */
+  MNG_ALLOC (pData, pData->pRGBArow, pData->iRowsize);
+
+  iY       = pData->iDestt;            /* this is where we start */
+  iRetcode = MNG_NOERROR;              /* so far, so good */
+
+  while ((!iRetcode) && (iY < pData->iDestb))
+  {                                    /* clear a row then */
+    iRetcode = ((mng_displayrow)pData->fDisplayrow) (pData);
+
+    if (!iRetcode)
+      iRetcode = mng_next_row (pData); /* adjust variables for next row */
+
+    iY++;                              /* and next line */
+  }
+                                       /* drop the temporary row-buffer */
+  MNG_FREE (pData, pData->pRGBArow, pData->iRowsize);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLEAR_CANVAS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode next_frame (mng_datap  pData,
+                                  mng_uint8  iFramemode,
+                                  mng_uint8  iChangedelay,
+                                  mng_uint32 iDelay,
+                                  mng_uint8  iChangetimeout,
+                                  mng_uint32 iTimeout,
+                                  mng_uint8  iChangeclipping,
+                                  mng_uint8  iCliptype,
+                                  mng_int32  iClipl,
+                                  mng_int32  iClipr,
+                                  mng_int32  iClipt,
+                                  mng_int32  iClipb)
+{
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_FRAME, MNG_LC_START);
+#endif
+
+  if (!pData->iBreakpoint)             /* no previous break here ? */
+  {
+#ifndef MNG_SKIPCHUNK_FRAM
+    mng_uint8 iOldmode = pData->iFramemode;
+                                       /* interframe delay required ? */
+    if ((iOldmode == 2) || (iOldmode == 4))
+    {
+      if ((pData->iFrameseq) && (iFramemode != 1) && (iFramemode != 3))
+        iRetcode = interframe_delay (pData);
+      else
+        pData->iFramedelay = pData->iNextdelay;
+    }
+    else
+    {                                  /* delay before inserting background layer? */
+      if ((pData->bFramedone) && (iFramemode == 4))
+        iRetcode = interframe_delay (pData);
+    }
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* now we'll assume we're in the next frame! */
+    if (iFramemode)                    /* save the new framing mode ? */
+    {
+      pData->iFRAMmode  = iFramemode;
+      pData->iFramemode = iFramemode;
+    }
+    else                               /* reload default */
+      pData->iFramemode = pData->iFRAMmode;
+
+    if (iChangedelay)                  /* delay changed ? */
+    {
+      pData->iNextdelay = iDelay;      /* for *after* next subframe */
+
+      if ((iOldmode == 2) || (iOldmode == 4))
+        pData->iFramedelay = pData->iFRAMdelay;
+
+      if (iChangedelay == 2)           /* also overall ? */
+        pData->iFRAMdelay = iDelay;
+    }
+    else
+    {                                  /* reload default */
+      pData->iNextdelay = pData->iFRAMdelay;
+    }
+
+    if (iChangetimeout)                /* timeout changed ? */
+    {                                  /* for next subframe */
+      pData->iFrametimeout = iTimeout;
+
+      if ((iChangetimeout == 2) ||     /* also overall ? */
+          (iChangetimeout == 4) ||
+          (iChangetimeout == 6) ||
+          (iChangetimeout == 8))
+        pData->iFRAMtimeout = iTimeout;
+    }
+    else                               /* reload default */
+      pData->iFrametimeout = pData->iFRAMtimeout;
+
+    if (iChangeclipping)               /* clipping changed ? */
+    {
+      pData->bFrameclipping = MNG_TRUE;
+
+      if (!iCliptype)                  /* absolute ? */
+      {
+        pData->iFrameclipl = iClipl;
+        pData->iFrameclipr = iClipr;
+        pData->iFrameclipt = iClipt;
+        pData->iFrameclipb = iClipb;
+      }
+      else                             /* relative */
+      {
+        pData->iFrameclipl = pData->iFrameclipl + iClipl;
+        pData->iFrameclipr = pData->iFrameclipr + iClipr;
+        pData->iFrameclipt = pData->iFrameclipt + iClipt;
+        pData->iFrameclipb = pData->iFrameclipb + iClipb;
+      }
+
+      if (iChangeclipping == 2)        /* also overall ? */
+      {
+        pData->bFRAMclipping = MNG_TRUE;
+
+        if (!iCliptype)                /* absolute ? */
+        {
+          pData->iFRAMclipl = iClipl;
+          pData->iFRAMclipr = iClipr;
+          pData->iFRAMclipt = iClipt;
+          pData->iFRAMclipb = iClipb;
+        }
+        else                           /* relative */
+        {
+          pData->iFRAMclipl = pData->iFRAMclipl + iClipl;
+          pData->iFRAMclipr = pData->iFRAMclipr + iClipr;
+          pData->iFRAMclipt = pData->iFRAMclipt + iClipt;
+          pData->iFRAMclipb = pData->iFRAMclipb + iClipb;
+        }
+      }
+    }
+    else
+    {                                  /* reload defaults */
+      pData->bFrameclipping = pData->bFRAMclipping;
+      pData->iFrameclipl    = pData->iFRAMclipl;
+      pData->iFrameclipr    = pData->iFRAMclipr;
+      pData->iFrameclipt    = pData->iFRAMclipt;
+      pData->iFrameclipb    = pData->iFRAMclipb;
+    }
+#endif
+  }
+
+  if (!pData->bTimerset)               /* timer still off ? */
+  {
+    if (
+#ifndef MNG_SKIPCHUNK_FRAM
+       (pData->iFramemode == 4) ||    /* insert background layer after a new frame */
+#endif
+        (!pData->iLayerseq))           /* and certainly before the very first layer */
+      iRetcode = load_bkgdlayer (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    pData->iFrameseq++;                /* count the frame ! */
+    pData->bFramedone = MNG_TRUE;      /* and indicate we've done one */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_FRAME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode next_layer (mng_datap pData)
+{
+  mng_imagep  pImage;
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_LAYER, MNG_LC_START);
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+  if (!pData->iBreakpoint)             /* no previous break here ? */
+  {                                    /* interframe delay required ? */
+    if ((pData->eImagetype == mng_it_mng) && (pData->iLayerseq) &&
+        ((pData->iFramemode == 1) || (pData->iFramemode == 3)))
+      iRetcode = interframe_delay (pData);
+    else
+      pData->iFramedelay = pData->iNextdelay;
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif
+
+  if (!pData->bTimerset)               /* timer still off ? */
+  {
+    if (!pData->iLayerseq)             /* restore background for the very first layer ? */
+    {                                  /* wait till IDAT/JDAT for PNGs & JNGs !!! */
+      if ((pData->eImagetype == mng_it_png) || (pData->eImagetype == mng_it_jng))
+        pData->bRestorebkgd = MNG_TRUE;
+      else
+      {                                /* for MNG we do it right away */
+        iRetcode = load_bkgdlayer (pData);
+        pData->iLayerseq++;            /* and it counts as a layer then ! */
+      }
+    }
+#ifndef MNG_SKIPCHUNK_FRAM
+    else
+    if (pData->iFramemode == 3)        /* restore background for each layer ? */
+      iRetcode = load_bkgdlayer (pData);
+#endif
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* processing a delta-image ? */
+      pImage = (mng_imagep)pData->pDeltaImage;
+    else
+#endif
+      pImage = (mng_imagep)pData->pCurrentobj;
+
+    if (!pImage)                       /* not an active object ? */
+      pImage = (mng_imagep)pData->pObjzero;
+                                       /* determine display rectangle */
+    pData->iDestl   = MAX_COORD ((mng_int32)0,   pImage->iPosx);
+    pData->iDestt   = MAX_COORD ((mng_int32)0,   pImage->iPosy);
+                                       /* is it a valid buffer ? */
+    if ((pImage->pImgbuf->iWidth) && (pImage->pImgbuf->iHeight))
+    {
+      pData->iDestr = MIN_COORD ((mng_int32)pData->iWidth,
+                                 pImage->iPosx + (mng_int32)pImage->pImgbuf->iWidth );
+      pData->iDestb = MIN_COORD ((mng_int32)pData->iHeight,
+                                 pImage->iPosy + (mng_int32)pImage->pImgbuf->iHeight);
+    }
+    else                               /* it's a single image ! */
+    {
+      pData->iDestr = MIN_COORD ((mng_int32)pData->iWidth,
+                                 (mng_int32)pData->iDatawidth );
+      pData->iDestb = MIN_COORD ((mng_int32)pData->iHeight,
+                                 (mng_int32)pData->iDataheight);
+    }
+
+#ifndef MNG_SKIPCHUNK_FRAM
+    if (pData->bFrameclipping)         /* frame clipping specified ? */
+    {
+      pData->iDestl = MAX_COORD (pData->iDestl,  pData->iFrameclipl);
+      pData->iDestt = MAX_COORD (pData->iDestt,  pData->iFrameclipt);
+      pData->iDestr = MIN_COORD (pData->iDestr,  pData->iFrameclipr);
+      pData->iDestb = MIN_COORD (pData->iDestb,  pData->iFrameclipb);
+    }
+#endif
+
+    if (pImage->bClipped)              /* is the image clipped itself ? */
+    {
+      pData->iDestl = MAX_COORD (pData->iDestl,  pImage->iClipl);
+      pData->iDestt = MAX_COORD (pData->iDestt,  pImage->iClipt);
+      pData->iDestr = MIN_COORD (pData->iDestr,  pImage->iClipr);
+      pData->iDestb = MIN_COORD (pData->iDestb,  pImage->iClipb);
+    }
+                                       /* determine source starting point */
+    pData->iSourcel = MAX_COORD ((mng_int32)0,   pData->iDestl - pImage->iPosx);
+    pData->iSourcet = MAX_COORD ((mng_int32)0,   pData->iDestt - pImage->iPosy);
+
+    if ((pImage->pImgbuf->iWidth) && (pImage->pImgbuf->iHeight))
+    {                                  /* and maximum size  */
+      pData->iSourcer = MIN_COORD ((mng_int32)pImage->pImgbuf->iWidth,
+                                   pData->iSourcel + pData->iDestr - pData->iDestl);
+      pData->iSourceb = MIN_COORD ((mng_int32)pImage->pImgbuf->iHeight,
+                                   pData->iSourcet + pData->iDestb - pData->iDestt);
+    }
+    else                               /* it's a single image ! */
+    {
+      pData->iSourcer = pData->iSourcel + pData->iDestr - pData->iDestl;
+      pData->iSourceb = pData->iSourcet + pData->iDestb - pData->iDestt;
+    }
+
+    pData->iLayerseq++;                /* count the layer ! */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_LAYER, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_display_image (mng_datap  pData,
+                               mng_imagep pImage,
+                               mng_bool   bLayeradvanced)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_IMAGE, MNG_LC_START);
+#endif
+                                       /* actively running ? */
+#ifndef MNG_SKIPCHUNK_MAGN
+  if (((pData->bRunning) || (pData->bSearching)) && (!pData->bSkipping))
+  {
+    if ( (!pData->iBreakpoint) &&      /* needs magnification ? */
+         ( (pImage->iMAGN_MethodX) || (pImage->iMAGN_MethodY) ) )
+    {
+      iRetcode = mng_magnify_imageobject (pData, pImage);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+#endif
+
+  pData->pRetrieveobj = pImage;        /* so retrieve-row and color-correction can find it */
+
+  if (!bLayeradvanced)                 /* need to advance the layer ? */
+  {
+    mng_imagep pSave    = pData->pCurrentobj;
+    pData->pCurrentobj  = pImage;
+    next_layer (pData);                /* advance to next layer */
+    pData->pCurrentobj  = pSave;
+  }
+                                       /* need to restore the background ? */
+  if ((!pData->bTimerset) && (pData->bRestorebkgd))
+  {
+    mng_imagep pSave    = pData->pCurrentobj;
+    pData->pCurrentobj  = pImage;
+    pData->bRestorebkgd = MNG_FALSE;
+    iRetcode            = load_bkgdlayer (pData);
+    pData->pCurrentobj  = pSave;
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    pData->iLayerseq++;                /* and it counts as a layer then ! */
+  }
+                                       /* actively running ? */
+  if (((pData->bRunning) || (pData->bSearching)) && (!pData->bSkipping))
+  {
+    if (!pData->bTimerset)             /* all systems still go ? */
+    {
+      pData->iBreakpoint = 0;          /* let's make absolutely sure... */
+                                       /* anything to display ? */
+      if ((pData->iDestr >= pData->iDestl) && (pData->iDestb >= pData->iDestt))
+      {
+        mng_int32 iY;
+
+        set_display_routine (pData);   /* determine display routine */
+                                       /* and image-buffer retrieval routine */
+        switch (pImage->pImgbuf->iColortype)
+        {
+          case  0 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_g16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_g8;
+
+                      pData->bIsOpaque      = (mng_bool)(!pImage->pImgbuf->bHasTRNS);
+                      break;
+                    }
+
+          case  2 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb8;
+
+                      pData->bIsOpaque      = (mng_bool)(!pImage->pImgbuf->bHasTRNS);
+                      break;
+                    }
+
+
+          case  3 : { pData->fRetrieverow   = (mng_fptr)mng_retrieve_idx8;
+                      pData->bIsOpaque      = (mng_bool)(!pImage->pImgbuf->bHasTRNS);
+                      break;
+                    }
+
+
+          case  4 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_ga16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_ga8;
+
+                      pData->bIsOpaque      = MNG_FALSE;
+                      break;
+                    }
+
+
+          case  6 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+
+                      pData->bIsOpaque      = MNG_FALSE;
+                      break;
+                    }
+
+          case  8 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_g16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_g8;
+
+                      pData->bIsOpaque      = MNG_TRUE;
+                      break;
+                    }
+
+          case 10 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb8;
+
+                      pData->bIsOpaque      = MNG_TRUE;
+                      break;
+                    }
+
+
+          case 12 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_ga16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_ga8;
+
+                      pData->bIsOpaque      = MNG_FALSE;
+                      break;
+                    }
+
+
+          case 14 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                      if (pImage->pImgbuf->iBitdepth > 8)
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba16;
+                      else
+#endif
+                        pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+
+                      pData->bIsOpaque      = MNG_FALSE;
+                      break;
+                    }
+
+        }
+
+        pData->iPass       = -1;       /* these are the object's dimensions now */
+        pData->iRow        = pData->iSourcet;
+        pData->iRowinc     = 1;
+        pData->iCol        = 0;
+        pData->iColinc     = 1;
+        pData->iRowsamples = pImage->pImgbuf->iWidth;
+        pData->iRowsize    = pData->iRowsamples << 2;
+        pData->bIsRGBA16   = MNG_FALSE;
+                                       /* adjust for 16-bit object ? */
+#ifndef MNG_NO_16BIT_SUPPORT
+        if (pImage->pImgbuf->iBitdepth > 8)
+        {
+          pData->bIsRGBA16 = MNG_TRUE;
+          pData->iRowsize  = pData->iRowsamples << 3;
+        }
+#endif
+
+        pData->fCorrectrow = MNG_NULL; /* default no color-correction */
+
+#ifdef MNG_NO_CMS
+        iRetcode = MNG_NOERROR;
+#else
+#if defined(MNG_FULL_CMS)              /* determine color-management routine */
+        iRetcode = mng_init_full_cms   (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_GAMMA_ONLY)
+        iRetcode = mng_init_gamma_only (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_APP_CMS)
+        iRetcode = mng_init_app_cms    (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#endif
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+#endif /* MNG_NO_CMS */
+                                       /* get a temporary row-buffer */
+        MNG_ALLOC (pData, pData->pRGBArow, pData->iRowsize);
+
+        iY = pData->iSourcet;          /* this is where we start */
+
+        while ((!iRetcode) && (iY < pData->iSourceb))
+        {                              /* get a row */
+          iRetcode = ((mng_retrieverow)pData->fRetrieverow) (pData);
+                                       /* color correction ? */
+          if ((!iRetcode) && (pData->fCorrectrow))
+            iRetcode = ((mng_correctrow)pData->fCorrectrow) (pData);
+
+          if (!iRetcode)               /* so... display it */
+            iRetcode = ((mng_displayrow)pData->fDisplayrow) (pData);
+
+          if (!iRetcode)               /* adjust variables for next row */
+            iRetcode = mng_next_row (pData);
+
+          iY++;                        /* and next line */
+        }
+                                       /* drop the temporary row-buffer */
+        MNG_FREE (pData, pData->pRGBArow, pData->iRowsize);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+
+#if defined(MNG_FULL_CMS)              /* cleanup cms stuff */
+        iRetcode = mng_clear_cms (pData);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+#endif
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_IMAGE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* whehehe, this is good ! */
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_execute_delta_image (mng_datap  pData,
+                                     mng_imagep pTarget,
+                                     mng_imagep pDelta)
+{
+  mng_imagedatap pBuftarget = pTarget->pImgbuf;
+  mng_imagedatap pBufdelta  = pDelta->pImgbuf;
+  mng_uint32     iY;
+  mng_retcode    iRetcode;
+  mng_ptr        pSaveRGBA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_EXECUTE_DELTA_IMAGE, MNG_LC_START);
+#endif
+                                       /* actively running ? */
+  if (((pData->bRunning) || (pData->bSearching)) && (!pData->bSkipping))
+  {
+    if (pBufdelta->bHasPLTE)           /* palette in delta ? */
+    {
+      mng_uint32 iX;
+                                       /* new palette larger than old one ? */
+      if ((!pBuftarget->bHasPLTE) || (pBuftarget->iPLTEcount < pBufdelta->iPLTEcount))
+        pBuftarget->iPLTEcount = pBufdelta->iPLTEcount;
+                                       /* it's definitely got a PLTE now */
+      pBuftarget->bHasPLTE = MNG_TRUE;
+
+      for (iX = 0; iX < pBufdelta->iPLTEcount; iX++)
+      {
+        pBuftarget->aPLTEentries[iX].iRed   = pBufdelta->aPLTEentries[iX].iRed;
+        pBuftarget->aPLTEentries[iX].iGreen = pBufdelta->aPLTEentries[iX].iGreen;
+        pBuftarget->aPLTEentries[iX].iBlue  = pBufdelta->aPLTEentries[iX].iBlue;
+      }
+    }
+
+    if (pBufdelta->bHasTRNS)           /* cheap transparency in delta ? */
+    {
+      switch (pData->iColortype)       /* drop it into the target */
+      {
+        case 0: {                      /* gray */
+                  pBuftarget->iTRNSgray  = pBufdelta->iTRNSgray;
+                  pBuftarget->iTRNSred   = 0;
+                  pBuftarget->iTRNSgreen = 0;
+                  pBuftarget->iTRNSblue  = 0;
+                  pBuftarget->iTRNScount = 0;
+                  break;
+                }
+        case 2: {                      /* rgb */
+                  pBuftarget->iTRNSgray  = 0;
+                  pBuftarget->iTRNSred   = pBufdelta->iTRNSred;
+                  pBuftarget->iTRNSgreen = pBufdelta->iTRNSgreen;
+                  pBuftarget->iTRNSblue  = pBufdelta->iTRNSblue;
+                  pBuftarget->iTRNScount = 0;
+                  break;
+                }
+        case 3: {                      /* indexed */
+                  pBuftarget->iTRNSgray  = 0;
+                  pBuftarget->iTRNSred   = 0;
+                  pBuftarget->iTRNSgreen = 0;
+                  pBuftarget->iTRNSblue  = 0;
+                                       /* existing range smaller than new one ? */
+                  if ((!pBuftarget->bHasTRNS) || (pBuftarget->iTRNScount < pBufdelta->iTRNScount))
+                    pBuftarget->iTRNScount = pBufdelta->iTRNScount;
+
+                  MNG_COPY (pBuftarget->aTRNSentries, pBufdelta->aTRNSentries, pBufdelta->iTRNScount);
+                  break;
+                }
+      }
+
+      pBuftarget->bHasTRNS = MNG_TRUE; /* tell it it's got a tRNS now */
+    }
+
+#ifndef MNG_SKIPCHUNK_bKGD
+    if (pBufdelta->bHasBKGD)           /* bkgd in source ? */
+    {                                  /* drop it onto the target */
+      pBuftarget->bHasBKGD   = MNG_TRUE;
+      pBuftarget->iBKGDindex = pBufdelta->iBKGDindex;
+      pBuftarget->iBKGDgray  = pBufdelta->iBKGDgray;
+      pBuftarget->iBKGDred   = pBufdelta->iBKGDred;
+      pBuftarget->iBKGDgreen = pBufdelta->iBKGDgreen;
+      pBuftarget->iBKGDblue  = pBufdelta->iBKGDblue;
+    }
+#endif
+
+    if (pBufdelta->bHasGAMA)           /* gamma in source ? */
+    {
+      pBuftarget->bHasGAMA = MNG_TRUE; /* drop it onto the target */
+      pBuftarget->iGamma   = pBufdelta->iGamma;
+    }
+
+#ifndef MNG_SKIPCHUNK_cHRM
+    if (pBufdelta->bHasCHRM)           /* chroma in delta ? */
+    {                                  /* drop it onto the target */
+      pBuftarget->bHasCHRM       = MNG_TRUE;
+      pBuftarget->iWhitepointx   = pBufdelta->iWhitepointx;
+      pBuftarget->iWhitepointy   = pBufdelta->iWhitepointy;
+      pBuftarget->iPrimaryredx   = pBufdelta->iPrimaryredx;
+      pBuftarget->iPrimaryredy   = pBufdelta->iPrimaryredy;
+      pBuftarget->iPrimarygreenx = pBufdelta->iPrimarygreenx;
+      pBuftarget->iPrimarygreeny = pBufdelta->iPrimarygreeny;
+      pBuftarget->iPrimarybluex  = pBufdelta->iPrimarybluex;
+      pBuftarget->iPrimarybluey  = pBufdelta->iPrimarybluey;
+    }
+#endif
+
+#ifndef MNG_SKIPCHUNK_sRGB
+    if (pBufdelta->bHasSRGB)           /* sRGB in delta ? */
+    {                                  /* drop it onto the target */
+      pBuftarget->bHasSRGB         = MNG_TRUE;
+      pBuftarget->iRenderingintent = pBufdelta->iRenderingintent;
+    }
+#endif
+
+#ifndef MNG_SKIPCHUNK_iCCP
+    if (pBufdelta->bHasICCP)           /* ICC profile in delta ? */
+    {
+      pBuftarget->bHasICCP = MNG_TRUE; /* drop it onto the target */
+
+      if (pBuftarget->pProfile)        /* profile existed ? */
+        MNG_FREEX (pData, pBuftarget->pProfile, pBuftarget->iProfilesize);
+                                       /* allocate a buffer & copy it */
+      MNG_ALLOC (pData, pBuftarget->pProfile, pBufdelta->iProfilesize);
+      MNG_COPY  (pBuftarget->pProfile, pBufdelta->pProfile, pBufdelta->iProfilesize);
+                                       /* store its length as well */
+      pBuftarget->iProfilesize = pBufdelta->iProfilesize;
+    }
+#endif
+                                       /* need to execute delta pixels ? */
+    if ((!pData->bDeltaimmediate) && (pData->iDeltatype != MNG_DELTATYPE_NOCHANGE))
+    {
+      pData->fScalerow = MNG_NULL;     /* not needed by default */
+
+      switch (pBufdelta->iBitdepth)    /* determine scaling routine */
+      {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        case  1 : {
+                    switch (pBuftarget->iBitdepth)
+                    {
+                      case  2 : { pData->fScalerow = (mng_fptr)mng_scale_g1_g2;  break; }
+                      case  4 : { pData->fScalerow = (mng_fptr)mng_scale_g1_g4;  break; }
+
+                      case  8 : { pData->fScalerow = (mng_fptr)mng_scale_g1_g8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                      case 16 : { pData->fScalerow = (mng_fptr)mng_scale_g1_g16; break; }
+#endif
+                    }
+                    break;
+                  }
+
+        case  2 : {
+                    switch (pBuftarget->iBitdepth)
+                    {
+                      case  1 : { pData->fScalerow = (mng_fptr)mng_scale_g2_g1;  break; }
+                      case  4 : { pData->fScalerow = (mng_fptr)mng_scale_g2_g4;  break; }
+                      case  8 : { pData->fScalerow = (mng_fptr)mng_scale_g2_g8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                      case 16 : { pData->fScalerow = (mng_fptr)mng_scale_g2_g16; break; }
+#endif
+                    }
+                    break;
+                  }
+
+        case  4 : {
+                    switch (pBuftarget->iBitdepth)
+                    {
+                      case  1 : { pData->fScalerow = (mng_fptr)mng_scale_g4_g1;  break; }
+                      case  2 : { pData->fScalerow = (mng_fptr)mng_scale_g4_g2;  break; }
+                      case  8 : { pData->fScalerow = (mng_fptr)mng_scale_g4_g8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                      case 16 : { pData->fScalerow = (mng_fptr)mng_scale_g4_g16; break; }
+#endif
+                    }
+                    break;
+                  }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+        case  8 : {
+                    switch (pBufdelta->iColortype)
+                    {
+                      case  0 : ;
+                      case  3 : ;
+                      case  8 : {
+                                  switch (pBuftarget->iBitdepth)
+                                  {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                                    case  1 : { pData->fScalerow = (mng_fptr)mng_scale_g8_g1;  break; }
+                                    case  2 : { pData->fScalerow = (mng_fptr)mng_scale_g8_g2;  break; }
+                                    case  4 : { pData->fScalerow = (mng_fptr)mng_scale_g8_g4;  break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+#ifndef MNG_NO_16BIT_SUPPORT
+                                    case 16 : { pData->fScalerow = (mng_fptr)mng_scale_g8_g16; break; }
+#endif
+                                  }
+                                  break;
+                                }
+                      case  2 : ;
+                      case 10 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                                  if (pBuftarget->iBitdepth == 16)
+                                    pData->fScalerow = (mng_fptr)mng_scale_rgb8_rgb16;
+#endif
+                                  break;
+                                }
+                      case  4 : ;
+                      case 12 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                                  if (pBuftarget->iBitdepth == 16)
+                                    pData->fScalerow = (mng_fptr)mng_scale_ga8_ga16;
+#endif
+                                  break;
+                                }
+                      case  6 : ;
+                      case 14 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                                  if (pBuftarget->iBitdepth == 16)
+                                    pData->fScalerow = (mng_fptr)mng_scale_rgba8_rgba16;
+#endif
+                                  break;
+                                }
+                    }
+                    break;
+                  }
+
+#ifndef MNG_NO_16BIT_SUPPORT
+        case 16 : {
+                    switch (pBufdelta->iColortype)
+                    {
+                      case  0 : ;
+                      case  3 : ;
+                      case  8 : {
+                                  switch (pBuftarget->iBitdepth)
+                                  {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                                    case 1 : { pData->fScalerow = (mng_fptr)mng_scale_g16_g1; break; }
+                                    case 2 : { pData->fScalerow = (mng_fptr)mng_scale_g16_g2; break; }
+                                    case 4 : { pData->fScalerow = (mng_fptr)mng_scale_g16_g4; break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                                    case 8 : { pData->fScalerow = (mng_fptr)mng_scale_g16_g8; break; }
+                                  }
+                                  break;
+                                }
+                      case  2 : ;
+                      case 10 : {
+                                  if (pBuftarget->iBitdepth == 8)
+                                    pData->fScalerow = (mng_fptr)mng_scale_rgb16_rgb8;
+                                  break;
+                                }
+                      case  4 : ;
+                      case 12 : {
+                                  if (pBuftarget->iBitdepth == 8)
+                                    pData->fScalerow = (mng_fptr)mng_scale_ga16_ga8;
+                                  break;
+                                }
+                      case  6 : ;
+                      case 14 : {
+                                  if (pBuftarget->iBitdepth == 8)
+                                    pData->fScalerow = (mng_fptr)mng_scale_rgba16_rgba8;
+                                  break;
+                                }
+                    }
+                    break;
+                  }
+#endif
+
+      }
+
+      pData->fDeltarow = MNG_NULL;     /* let's assume there's nothing to do */
+
+      switch (pBuftarget->iColortype)  /* determine delta processing routine */
+      {
+        case  0 : ;
+        case  8 : {                     /* gray */
+                    if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 0) || (pBufdelta->iColortype == 3) ||
+                          (pBufdelta->iColortype == 8))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                          case  1 : { pData->fDeltarow = (mng_fptr)mng_delta_g1_g1;   break; }
+                          case  2 : { pData->fDeltarow = (mng_fptr)mng_delta_g2_g2;   break; }
+                          case  4 : { pData->fDeltarow = (mng_fptr)mng_delta_g4_g4;   break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_g8_g8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_g16_g16; break; }
+#endif
+                        }
+                      }
+                    }
+
+                    break;
+                  }
+
+        case  2 : ;
+        case 10 : {                     /* rgb */
+                    if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 2) || (pBufdelta->iColortype == 10))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_rgb8_rgb8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_rgb16_rgb16; break; }
+#endif
+                        }
+                      }
+                    }
+
+                    break;
+                  }
+
+        case  3 : {                     /* indexed; abuse gray routines */
+                    if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 0) || (pBufdelta->iColortype == 3))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                          case  1 : { pData->fDeltarow = (mng_fptr)mng_delta_g1_g1; break; }
+                          case  2 : { pData->fDeltarow = (mng_fptr)mng_delta_g2_g2; break; }
+                          case  4 : { pData->fDeltarow = (mng_fptr)mng_delta_g4_g4; break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_g8_g8; break; }
+                        }
+                      }
+                    }
+
+                    break;
+                  }
+
+        case  4 : ;
+        case 12 : {                     /* gray + alpha */
+                    if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 4) || (pBufdelta->iColortype == 12))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_ga8_ga8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_ga16_ga16; break; }
+#endif
+                        }
+                      }
+                    }
+                    else
+                    if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 0) || (pBufdelta->iColortype == 3) ||
+                          (pBufdelta->iColortype == 8))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_ga8_g8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_ga16_g16; break; }
+#endif
+                        }
+                      }
+                    }
+                    else
+                    if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 0) || (pBufdelta->iColortype == 3))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_ga8_a8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_ga16_a16; break; }
+#endif
+                        }
+                      }
+                    }
+
+                    break;
+                  }
+
+        case  6 : ;
+        case 14 : {                     /* rgb + alpha */
+                    if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 6) || (pBufdelta->iColortype == 14))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_rgba8_rgba8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_rgba16_rgba16; break; }
+#endif
+                        }
+                      }
+                    }
+                    else
+                    if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 2) || (pBufdelta->iColortype == 10))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_rgba8_rgb8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_rgba16_rgb16; break; }
+#endif
+                        }
+                      }
+                    }
+                    else
+                    if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD    ) ||
+                        (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)    )
+                    {
+                      if ((pBufdelta->iColortype == 0) || (pBufdelta->iColortype == 3))
+                      {
+                        switch (pBuftarget->iBitdepth)
+                        {
+                          case  8 : { pData->fDeltarow = (mng_fptr)mng_delta_rgba8_a8;   break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                          case 16 : { pData->fDeltarow = (mng_fptr)mng_delta_rgba16_a16; break; }
+#endif
+                        }
+                      }
+                    }
+
+                    break;
+                  }
+
+      }
+
+      if (pData->fDeltarow)            /* do we need to take action ? */
+      {
+        pData->iPass        = -1;      /* setup row dimensions and stuff */
+        pData->iRow         = pData->iDeltaBlocky;
+        pData->iRowinc      = 1;
+        pData->iCol         = pData->iDeltaBlockx;
+        pData->iColinc      = 1;
+        pData->iRowsamples  = pBufdelta->iWidth;
+        pData->iRowsize     = pBuftarget->iRowsize;
+                                       /* indicate where to retrieve & where to store */
+        pData->pRetrieveobj = (mng_objectp)pDelta;
+        pData->pStoreobj    = (mng_objectp)pTarget;
+
+        pSaveRGBA = pData->pRGBArow;   /* save current temp-buffer! */
+                                       /* get a temporary row-buffer */
+        MNG_ALLOC (pData, pData->pRGBArow, (pBufdelta->iRowsize << 1));
+
+        iY       = 0;                  /* this is where we start */
+        iRetcode = MNG_NOERROR;        /* still oke for now */
+
+        while ((!iRetcode) && (iY < pBufdelta->iHeight))
+        {                              /* get a row */
+          mng_uint8p pWork = pBufdelta->pImgdata + (iY * pBufdelta->iRowsize);
+
+          MNG_COPY (pData->pRGBArow, pWork, pBufdelta->iRowsize);
+
+          if (pData->fScalerow)        /* scale it (if necessary) */
+            iRetcode = ((mng_scalerow)pData->fScalerow) (pData);
+
+          if (!iRetcode)               /* and... execute it */
+            iRetcode = ((mng_deltarow)pData->fDeltarow) (pData);
+
+          if (!iRetcode)               /* adjust variables for next row */
+            iRetcode = mng_next_row (pData);
+
+          iY++;                        /* and next line */
+        }
+                                       /* drop the temporary row-buffer */
+        MNG_FREE (pData, pData->pRGBArow, (pBufdelta->iRowsize << 1));
+        pData->pRGBArow = pSaveRGBA;   /* restore saved temp-buffer! */
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+
+      }
+      else
+        MNG_ERROR (pData, MNG_INVALIDDELTA);
+
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_EXECUTE_DELTA_IMAGE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+MNG_LOCAL mng_retcode save_state (mng_datap pData)
+{
+  mng_savedatap pSave;
+  mng_imagep    pImage;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SAVE_STATE, MNG_LC_START);
+#endif
+
+  if (pData->pSavedata)                /* sanity check */
+    MNG_ERROR (pData, MNG_INTERNALERROR);
+                                       /* get a buffer for saving */
+  MNG_ALLOC (pData, pData->pSavedata, sizeof (mng_savedata));
+
+  pSave = pData->pSavedata;            /* address it more directly */
+                                       /* and copy global data from the main struct */
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+  pSave->bHasglobalPLTE       = pData->bHasglobalPLTE;
+  pSave->bHasglobalTRNS       = pData->bHasglobalTRNS;
+  pSave->bHasglobalGAMA       = pData->bHasglobalGAMA;
+  pSave->bHasglobalCHRM       = pData->bHasglobalCHRM;
+  pSave->bHasglobalSRGB       = pData->bHasglobalSRGB;
+  pSave->bHasglobalICCP       = pData->bHasglobalICCP;
+  pSave->bHasglobalBKGD       = pData->bHasglobalBKGD;
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+#ifndef MNG_SKIPCHUNK_BACK
+  pSave->iBACKred             = pData->iBACKred;
+  pSave->iBACKgreen           = pData->iBACKgreen;
+  pSave->iBACKblue            = pData->iBACKblue;
+  pSave->iBACKmandatory       = pData->iBACKmandatory;
+  pSave->iBACKimageid         = pData->iBACKimageid;
+  pSave->iBACKtile            = pData->iBACKtile;
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+  pSave->iFRAMmode            = pData->iFRAMmode;
+  pSave->iFRAMdelay           = pData->iFRAMdelay;
+  pSave->iFRAMtimeout         = pData->iFRAMtimeout;
+  pSave->bFRAMclipping        = pData->bFRAMclipping;
+  pSave->iFRAMclipl           = pData->iFRAMclipl;
+  pSave->iFRAMclipr           = pData->iFRAMclipr;
+  pSave->iFRAMclipt           = pData->iFRAMclipt;
+  pSave->iFRAMclipb           = pData->iFRAMclipb;
+#endif
+
+  pSave->iGlobalPLTEcount     = pData->iGlobalPLTEcount;
+
+  MNG_COPY (pSave->aGlobalPLTEentries, pData->aGlobalPLTEentries, sizeof (mng_rgbpaltab));
+
+  pSave->iGlobalTRNSrawlen    = pData->iGlobalTRNSrawlen;
+  MNG_COPY (pSave->aGlobalTRNSrawdata, pData->aGlobalTRNSrawdata, 256);
+
+  pSave->iGlobalGamma         = pData->iGlobalGamma;
+
+#ifndef MNG_SKIPCHUNK_cHRM
+  pSave->iGlobalWhitepointx   = pData->iGlobalWhitepointx;
+  pSave->iGlobalWhitepointy   = pData->iGlobalWhitepointy;
+  pSave->iGlobalPrimaryredx   = pData->iGlobalPrimaryredx;
+  pSave->iGlobalPrimaryredy   = pData->iGlobalPrimaryredy;
+  pSave->iGlobalPrimarygreenx = pData->iGlobalPrimarygreenx;
+  pSave->iGlobalPrimarygreeny = pData->iGlobalPrimarygreeny;
+  pSave->iGlobalPrimarybluex  = pData->iGlobalPrimarybluex;
+  pSave->iGlobalPrimarybluey  = pData->iGlobalPrimarybluey;
+#endif
+
+#ifndef MNG_SKIPCHUNK_sRGB
+  pSave->iGlobalRendintent    = pData->iGlobalRendintent;
+#endif
+
+#ifndef MNG_SKIPCHUNK_iCCP
+  pSave->iGlobalProfilesize   = pData->iGlobalProfilesize;
+
+  if (pSave->iGlobalProfilesize)       /* has a profile ? */
+  {                                    /* then copy that ! */
+    MNG_ALLOC (pData, pSave->pGlobalProfile, pSave->iGlobalProfilesize);
+    MNG_COPY (pSave->pGlobalProfile, pData->pGlobalProfile, pSave->iGlobalProfilesize);
+  }
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+  pSave->iGlobalBKGDred       = pData->iGlobalBKGDred;
+  pSave->iGlobalBKGDgreen     = pData->iGlobalBKGDgreen;
+  pSave->iGlobalBKGDblue      = pData->iGlobalBKGDblue;
+#endif
+
+                                       /* freeze current image objects */
+  pImage = (mng_imagep)pData->pFirstimgobj;
+
+  while (pImage)
+  {                                    /* freeze the object AND its buffer */
+    pImage->bFrozen          = MNG_TRUE;
+    pImage->pImgbuf->bFrozen = MNG_TRUE;
+                                       /* neeeext */
+    pImage = (mng_imagep)pImage->sHeader.pNext;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SAVE_STATE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_reset_objzero (mng_datap pData)
+{
+  mng_imagep  pImage   = (mng_imagep)pData->pObjzero;
+  mng_retcode iRetcode = mng_reset_object_details (pData, pImage, 0, 0, 0,
+                                                   0, 0, 0, 0, MNG_TRUE);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  pImage->bVisible             = MNG_TRUE;
+  pImage->bViewable            = MNG_TRUE;
+  pImage->iPosx                = 0;
+  pImage->iPosy                = 0;
+  pImage->bClipped             = MNG_FALSE;
+  pImage->iClipl               = 0;
+  pImage->iClipr               = 0;
+  pImage->iClipt               = 0;
+  pImage->iClipb               = 0;
+#ifndef MNG_SKIPCHUNK_MAGN
+  pImage->iMAGN_MethodX        = 0;
+  pImage->iMAGN_MethodY        = 0;
+  pImage->iMAGN_MX             = 0;
+  pImage->iMAGN_MY             = 0;
+  pImage->iMAGN_ML             = 0;
+  pImage->iMAGN_MR             = 0;
+  pImage->iMAGN_MT             = 0;
+  pImage->iMAGN_MB             = 0;
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode restore_state (mng_datap pData)
+{
+#ifndef MNG_SKIPCHUNK_SAVE
+  mng_savedatap pSave;
+#endif
+  mng_imagep    pImage;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_STATE, MNG_LC_START);
+#endif
+                                       /* restore object 0 status !!! */
+  iRetcode = mng_reset_objzero (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* fresh cycle; fake no frames done yet */
+  pData->bFramedone             = MNG_FALSE;
+
+#ifndef MNG_SKIPCHUNK_SAVE
+  if (pData->pSavedata)                /* do we have a saved state ? */
+  {
+    pSave = pData->pSavedata;          /* address it more directly */
+                                       /* and copy it back to the main struct */
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+    pData->bHasglobalPLTE       = pSave->bHasglobalPLTE;
+    pData->bHasglobalTRNS       = pSave->bHasglobalTRNS;
+    pData->bHasglobalGAMA       = pSave->bHasglobalGAMA;
+    pData->bHasglobalCHRM       = pSave->bHasglobalCHRM;
+    pData->bHasglobalSRGB       = pSave->bHasglobalSRGB;
+    pData->bHasglobalICCP       = pSave->bHasglobalICCP;
+    pData->bHasglobalBKGD       = pSave->bHasglobalBKGD;
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+#ifndef MNG_SKIPCHUNK_BACK
+    pData->iBACKred             = pSave->iBACKred;
+    pData->iBACKgreen           = pSave->iBACKgreen;
+    pData->iBACKblue            = pSave->iBACKblue;
+    pData->iBACKmandatory       = pSave->iBACKmandatory;
+    pData->iBACKimageid         = pSave->iBACKimageid;
+    pData->iBACKtile            = pSave->iBACKtile;
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+    pData->iFRAMmode            = pSave->iFRAMmode;
+/*    pData->iFRAMdelay           = pSave->iFRAMdelay; */
+    pData->iFRAMtimeout         = pSave->iFRAMtimeout;
+    pData->bFRAMclipping        = pSave->bFRAMclipping;
+    pData->iFRAMclipl           = pSave->iFRAMclipl;
+    pData->iFRAMclipr           = pSave->iFRAMclipr;
+    pData->iFRAMclipt           = pSave->iFRAMclipt;
+    pData->iFRAMclipb           = pSave->iFRAMclipb;
+                                       /* NOOOOOOOOOOOO */
+/*    pData->iFramemode           = pSave->iFRAMmode;
+    pData->iFramedelay          = pSave->iFRAMdelay;
+    pData->iFrametimeout        = pSave->iFRAMtimeout;
+    pData->bFrameclipping       = pSave->bFRAMclipping;
+    pData->iFrameclipl          = pSave->iFRAMclipl;
+    pData->iFrameclipr          = pSave->iFRAMclipr;
+    pData->iFrameclipt          = pSave->iFRAMclipt;
+    pData->iFrameclipb          = pSave->iFRAMclipb; */
+
+/*    pData->iNextdelay           = pSave->iFRAMdelay; */
+    pData->iNextdelay           = pData->iFramedelay;
+#endif
+
+    pData->iGlobalPLTEcount     = pSave->iGlobalPLTEcount;
+    MNG_COPY (pData->aGlobalPLTEentries, pSave->aGlobalPLTEentries, sizeof (mng_rgbpaltab));
+
+    pData->iGlobalTRNSrawlen    = pSave->iGlobalTRNSrawlen;
+    MNG_COPY (pData->aGlobalTRNSrawdata, pSave->aGlobalTRNSrawdata, 256);
+
+    pData->iGlobalGamma         = pSave->iGlobalGamma;
+
+#ifndef MNG_SKIPCHUNK_cHRM
+    pData->iGlobalWhitepointx   = pSave->iGlobalWhitepointx;
+    pData->iGlobalWhitepointy   = pSave->iGlobalWhitepointy;
+    pData->iGlobalPrimaryredx   = pSave->iGlobalPrimaryredx;
+    pData->iGlobalPrimaryredy   = pSave->iGlobalPrimaryredy;
+    pData->iGlobalPrimarygreenx = pSave->iGlobalPrimarygreenx;
+    pData->iGlobalPrimarygreeny = pSave->iGlobalPrimarygreeny;
+    pData->iGlobalPrimarybluex  = pSave->iGlobalPrimarybluex;
+    pData->iGlobalPrimarybluey  = pSave->iGlobalPrimarybluey;
+#endif
+
+    pData->iGlobalRendintent    = pSave->iGlobalRendintent;
+
+#ifndef MNG_SKIPCHUNK_iCCP
+    pData->iGlobalProfilesize   = pSave->iGlobalProfilesize;
+
+    if (pData->iGlobalProfilesize)     /* has a profile ? */
+    {                                  /* then copy that ! */
+      MNG_ALLOC (pData, pData->pGlobalProfile, pData->iGlobalProfilesize);
+      MNG_COPY (pData->pGlobalProfile, pSave->pGlobalProfile, pData->iGlobalProfilesize);
+    }
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+    pData->iGlobalBKGDred       = pSave->iGlobalBKGDred;
+    pData->iGlobalBKGDgreen     = pSave->iGlobalBKGDgreen;
+    pData->iGlobalBKGDblue      = pSave->iGlobalBKGDblue;
+#endif
+  }
+  else                                 /* no saved-data; so reset the lot */
+#endif /* SKIPCHUNK_SAVE */
+  {
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+    pData->bHasglobalPLTE       = MNG_FALSE;
+    pData->bHasglobalTRNS       = MNG_FALSE;
+    pData->bHasglobalGAMA       = MNG_FALSE;
+    pData->bHasglobalCHRM       = MNG_FALSE;
+    pData->bHasglobalSRGB       = MNG_FALSE;
+    pData->bHasglobalICCP       = MNG_FALSE;
+    pData->bHasglobalBKGD       = MNG_FALSE;
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+#ifndef MNG_SKIPCHUNK_TERM
+    if (!pData->bMisplacedTERM)        /* backward compatible ugliness !!! */
+    {
+      pData->iBACKred           = 0;
+      pData->iBACKgreen         = 0;
+      pData->iBACKblue          = 0;
+      pData->iBACKmandatory     = 0;
+      pData->iBACKimageid       = 0;
+      pData->iBACKtile          = 0;
+    }
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+    pData->iFRAMmode            = 1;
+/*    pData->iFRAMdelay           = 1; */
+    pData->iFRAMtimeout         = 0x7fffffffl;
+    pData->bFRAMclipping        = MNG_FALSE;
+    pData->iFRAMclipl           = 0;
+    pData->iFRAMclipr           = 0;
+    pData->iFRAMclipt           = 0;
+    pData->iFRAMclipb           = 0;
+                                       /* NOOOOOOOOOOOO */
+/*    pData->iFramemode           = 1;
+    pData->iFramedelay          = 1;
+    pData->iFrametimeout        = 0x7fffffffl;
+    pData->bFrameclipping       = MNG_FALSE;
+    pData->iFrameclipl          = 0;
+    pData->iFrameclipr          = 0;
+    pData->iFrameclipt          = 0;
+    pData->iFrameclipb          = 0; */
+
+/*    pData->iNextdelay           = 1; */
+    pData->iNextdelay           = pData->iFramedelay;
+#endif
+
+    pData->iGlobalPLTEcount     = 0;
+
+    pData->iGlobalTRNSrawlen    = 0;
+
+    pData->iGlobalGamma         = 0;
+
+#ifndef MNG_SKIPCHUNK_cHRM
+    pData->iGlobalWhitepointx   = 0;
+    pData->iGlobalWhitepointy   = 0;
+    pData->iGlobalPrimaryredx   = 0;
+    pData->iGlobalPrimaryredy   = 0;
+    pData->iGlobalPrimarygreenx = 0;
+    pData->iGlobalPrimarygreeny = 0;
+    pData->iGlobalPrimarybluex  = 0;
+    pData->iGlobalPrimarybluey  = 0;
+#endif
+
+    pData->iGlobalRendintent    = 0;
+
+#ifndef MNG_SKIPCHUNK_iCCP
+    if (pData->iGlobalProfilesize)     /* free a previous profile ? */
+      MNG_FREE (pData, pData->pGlobalProfile, pData->iGlobalProfilesize);
+
+    pData->iGlobalProfilesize   = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+    pData->iGlobalBKGDred       = 0;
+    pData->iGlobalBKGDgreen     = 0;
+    pData->iGlobalBKGDblue      = 0;
+#endif
+  }
+
+#ifndef MNG_SKIPCHUNK_TERM
+  if (!pData->bMisplacedTERM)          /* backward compatible ugliness !!! */
+  {
+    pImage = (mng_imagep)pData->pFirstimgobj;
+                                       /* drop un-frozen image objects */
+    while (pImage)
+    {
+      mng_imagep pNext = (mng_imagep)pImage->sHeader.pNext;
+
+      if (!pImage->bFrozen)            /* is it un-frozen ? */
+      {
+        mng_imagep pPrev = (mng_imagep)pImage->sHeader.pPrev;
+
+        if (pPrev)                     /* unlink it */
+          pPrev->sHeader.pNext = pNext;
+        else
+          pData->pFirstimgobj  = pNext;
+
+        if (pNext)
+          pNext->sHeader.pPrev = pPrev;
+        else
+          pData->pLastimgobj   = pPrev;
+
+        if (pImage->pImgbuf->bFrozen)  /* buffer frozen ? */
+        {
+          if (pImage->pImgbuf->iRefcount < 2)
+            MNG_ERROR (pData, MNG_INTERNALERROR);
+                                       /* decrease ref counter */
+          pImage->pImgbuf->iRefcount--;
+                                       /* just cleanup the object then */
+          MNG_FREEX (pData, pImage, sizeof (mng_image));
+        }
+        else
+        {                              /* free the image buffer */
+          iRetcode = mng_free_imagedataobject (pData, pImage->pImgbuf);
+                                       /* and cleanup the object */
+          MNG_FREEX (pData, pImage, sizeof (mng_image));
+
+          if (iRetcode)                /* on error bail out */
+            return iRetcode;
+        }
+      }
+
+      pImage = pNext;                  /* neeeext */
+    }
+  }
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_STATE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * General display processing routine                                     * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_process_display (mng_datap pData)
+{
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY, MNG_LC_START);
+#endif
+
+  if (!pData->iBreakpoint)             /* not broken previously ? */
+  {
+    if ((pData->iRequestframe) || (pData->iRequestlayer) || (pData->iRequesttime))
+    {
+      pData->bSearching = MNG_TRUE;    /* indicate we're searching */
+
+      iRetcode = clear_canvas (pData); /* make the canvas virgin black ?!? */
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+                                       /* let's start from the top, shall we */
+      pData->pCurraniobj = pData->pFirstaniobj;
+    }
+  }
+
+  do                                   /* process the objects */
+  {
+    if (pData->bSearching)             /* clear timer-flag when searching !!! */
+      pData->bTimerset = MNG_FALSE;
+                                       /* do we need to finish something first ? */
+    if ((pData->iBreakpoint) && (pData->iBreakpoint < 99))
+    {
+      switch (pData->iBreakpoint)      /* return to broken display routine */
+      {
+#ifndef MNG_SKIPCHUNK_FRAM
+        case  1 : { iRetcode = mng_process_display_fram2 (pData); break; }
+#endif
+#ifndef MNG_SKIPCHUNK_SHOW
+        case  3 : ;                    /* same as 4 !!! */
+        case  4 : { iRetcode = mng_process_display_show  (pData); break; }
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+        case  5 : { iRetcode = mng_process_display_clon2 (pData); break; }
+#endif
+#ifndef MNG_SKIPCHUNK_MAGN
+        case  9 : { iRetcode = mng_process_display_magn2 (pData); break; }
+        case 10 : { iRetcode = mng_process_display_mend2 (pData); break; }
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+        case 11 : { iRetcode = mng_process_display_past2 (pData); break; }
+#endif
+        default : MNG_ERROR (pData, MNG_INTERNALERROR);
+      }
+    }
+    else
+    {
+      if (pData->pCurraniobj)
+        iRetcode = ((mng_object_headerp)pData->pCurraniobj)->fProcess (pData, pData->pCurraniobj);
+    }
+
+    if (!pData->bTimerset)             /* reset breakpoint flag ? */
+      pData->iBreakpoint = 0;
+                                       /* can we advance to next object ? */
+    if ((!iRetcode) && (pData->pCurraniobj) &&
+        (!pData->bTimerset) && (!pData->bSectionwait))
+    {
+      pData->pCurraniobj = ((mng_object_headerp)pData->pCurraniobj)->pNext;
+                                       /* MEND processing to be done ? */
+      if ((pData->eImagetype == mng_it_mng) && (!pData->pCurraniobj))
+        iRetcode = mng_process_display_mend (pData);
+
+      if (!pData->pCurraniobj)         /* refresh after last image ? */
+        pData->bNeedrefresh = MNG_TRUE;
+    }
+
+    if (pData->bSearching)             /* are we looking for something ? */
+    {
+      if ((pData->iRequestframe) && (pData->iRequestframe <= pData->iFrameseq))
+      {
+        pData->iRequestframe = 0;      /* found the frame ! */
+        pData->bSearching    = MNG_FALSE;
+      }
+      else
+      if ((pData->iRequestlayer) && (pData->iRequestlayer <= pData->iLayerseq))
+      {
+        pData->iRequestlayer = 0;      /* found the layer ! */
+        pData->bSearching    = MNG_FALSE;
+      }
+      else
+      if ((pData->iRequesttime) && (pData->iRequesttime <= pData->iFrametime))
+      {
+        pData->iRequesttime  = 0;      /* found the playtime ! */
+        pData->bSearching    = MNG_FALSE;
+      }
+    }
+  }                                    /* until error or a break or no more objects */
+  while ((!iRetcode) && (pData->pCurraniobj) &&
+         (((pData->bRunning) && (!pData->bTimerset)) || (pData->bSearching)) &&
+         (!pData->bSectionwait) && (!pData->bFreezing));
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* refresh needed ? */
+  if ((!pData->bTimerset) && (pData->bNeedrefresh))
+  {
+    iRetcode = mng_display_progressive_refresh (pData, 1);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+                                       /* timer break ? */
+  if ((pData->bTimerset) && (!pData->iBreakpoint))
+    pData->iBreakpoint = 99;
+  else
+  if (!pData->bTimerset)
+    pData->iBreakpoint = 0;            /* reset if no timer break */
+
+  if ((!pData->bTimerset) && (!pData->pCurraniobj))
+    pData->bRunning = MNG_FALSE;       /* all done now ! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Chunk display processing routines                                      * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+png_imgtype mng_png_imgtype(mng_uint8 colortype, mng_uint8 bitdepth)
+{
+  png_imgtype ret;
+  switch (bitdepth)
+  {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case 1:
+    {
+      png_imgtype imgtype[]={png_g1,png_none,png_none,png_idx1};
+      ret=imgtype[colortype];
+      break;
+    }
+    case 2:
+    {
+      png_imgtype imgtype[]={png_g2,png_none,png_none,png_idx2};
+      ret=imgtype[colortype];
+      break;
+    }
+    case 4:
+    {
+      png_imgtype imgtype[]={png_g4,png_none,png_none,png_idx4};
+      ret=imgtype[colortype];
+      break;
+    }
+#endif
+    case 8:
+    {
+      png_imgtype imgtype[]={png_g8,png_none,png_rgb8,png_idx8,png_ga8,
+          png_none,png_rgba8};
+      ret=imgtype[colortype];
+      break;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    case 16:
+    {
+      png_imgtype imgtype[]={png_g16,png_none,png_rgb16,png_none,png_ga16,
+          png_none,png_rgba16};
+      ret=imgtype[colortype];
+      break;
+    }
+#endif
+    default:
+      ret=png_none;
+      break;
+  }
+  return (ret);
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_display_ihdr (mng_datap pData)
+{                                      /* address the current "object" if any */
+  mng_imagep pImage = (mng_imagep)pData->pCurrentobj;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IHDR, MNG_LC_START);
+#endif
+
+  if (!pData->bHasDHDR)
+  {
+    pData->fInitrowproc = MNG_NULL;    /* do nothing by default */
+    pData->fDisplayrow  = MNG_NULL;
+    pData->fCorrectrow  = MNG_NULL;
+    pData->fStorerow    = MNG_NULL;
+    pData->fProcessrow  = MNG_NULL;
+    pData->fDifferrow   = MNG_NULL;
+    pData->pStoreobj    = MNG_NULL;
+  }
+
+  if (!pData->iBreakpoint)             /* not previously broken ? */
+  {
+    mng_retcode iRetcode = MNG_NOERROR;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* is a delta-image ? */
+    {
+      if (pData->iDeltatype == MNG_DELTATYPE_REPLACE)
+        iRetcode = mng_reset_object_details (pData, (mng_imagep)pData->pDeltaImage,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iBitdepth, pData->iColortype,
+                                             pData->iCompression, pData->iFilter,
+                                             pData->iInterlace, MNG_TRUE);
+      else
+      if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+          (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+      {
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iPixelsampledepth = pData->iBitdepth;
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iAlphasampledepth = pData->iBitdepth;
+      }
+      else
+      if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD    ) ||
+          (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)    )
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iAlphasampledepth = pData->iBitdepth;
+      else
+      if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD    ) ||
+          (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)    )
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iPixelsampledepth = pData->iBitdepth;
+
+      if (!iRetcode)
+      {                                /* process immediately if bitdepth & colortype are equal */
+        pData->bDeltaimmediate =
+          (mng_bool)((pData->iBitdepth  == ((mng_imagep)pData->pDeltaImage)->pImgbuf->iBitdepth ) &&
+                     (pData->iColortype == ((mng_imagep)pData->pDeltaImage)->pImgbuf->iColortype)    );
+                                       /* be sure to reset object 0 */
+        iRetcode = mng_reset_object_details (pData, (mng_imagep)pData->pObjzero,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iBitdepth, pData->iColortype,
+                                             pData->iCompression, pData->iFilter,
+                                             pData->iInterlace, MNG_TRUE);
+      }
+    }
+    else
+#endif
+    {
+      if (pImage)                      /* update object buffer ? */
+        iRetcode = mng_reset_object_details (pData, pImage,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iBitdepth, pData->iColortype,
+                                             pData->iCompression, pData->iFilter,
+                                             pData->iInterlace, MNG_TRUE);
+      else
+        iRetcode = mng_reset_object_details (pData, (mng_imagep)pData->pObjzero,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iBitdepth, pData->iColortype,
+                                             pData->iCompression, pData->iFilter,
+                                             pData->iInterlace, MNG_TRUE);
+    }
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+#ifndef MNG_NO_DELTA_PNG
+  if (!pData->bHasDHDR)
+#endif
+  {
+    if (pImage)                        /* real object ? */
+      pData->pStoreobj = pImage;       /* tell the row routines */
+    else                               /* otherwise use object 0 */
+      pData->pStoreobj = pData->pObjzero;
+
+#if !defined(MNG_INCLUDE_MPNG_PROPOSAL) && !defined(MNG_INCLUDE_ANG_PROPOSAL)
+    if (                               /* display "on-the-fly" ? */
+#ifndef MNG_SKIPCHUNK_MAGN
+         (((mng_imagep)pData->pStoreobj)->iMAGN_MethodX == 0) &&
+         (((mng_imagep)pData->pStoreobj)->iMAGN_MethodY == 0) &&
+#endif
+         ( (pData->eImagetype == mng_it_png         ) ||
+           (((mng_imagep)pData->pStoreobj)->bVisible)    )       )
+    {
+      next_layer (pData);              /* that's a new layer then ! */
+
+      if (pData->bTimerset)            /* timer break ? */
+        pData->iBreakpoint = 2;
+      else
+      {
+        pData->iBreakpoint = 0;
+                                       /* anything to display ? */
+        if ((pData->iDestr > pData->iDestl) && (pData->iDestb > pData->iDestt))
+          set_display_routine (pData); /* then determine display routine */
+      }
+    }
+#endif
+  }
+
+  if (!pData->bTimerset)               /* no timer break ? */
+  {
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+    pData->fInitrowproc = (mng_fptr)mng_init_rowproc;
+    pData->ePng_imgtype=mng_png_imgtype(pData->iColortype,pData->iBitdepth);
+#else
+    switch (pData->iColortype)         /* determine row initialization routine */
+    {
+      case 0 : {                       /* gray */
+                 switch (pData->iBitdepth)
+                 {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                   case  1 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g1_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g1_i;
+
+                               break;
+                             }
+                   case  2 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g2_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g2_i;
+
+                               break;
+                             }
+                   case  4 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g4_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g4_i;
+                               break;
+                             }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g8_i;
+
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_g16_i;
+
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+      case 2 : {                       /* rgb */
+                 switch (pData->iBitdepth)
+                 {
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb8_i;
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgb16_i;
+
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+      case 3 : {                       /* indexed */
+                 switch (pData->iBitdepth)
+                 {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                   case  1 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx1_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx1_i;
+
+                               break;
+                             }
+                   case  2 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx2_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx2_i;
+
+                               break;
+                             }
+                   case  4 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx4_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx4_i;
+
+                               break;
+                             }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_idx8_i;
+
+                               break;
+                             }
+                 }
+
+                 break;
+               }
+      case 4 : {                       /* gray+alpha */
+                 switch (pData->iBitdepth)
+                 {
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga8_i;
+
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_ga16_i;
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+      case 6 : {                       /* rgb+alpha */
+                 switch (pData->iBitdepth)
+                 {
+                   case  8 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba8_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba8_i;
+
+                               break;
+                             }
+#ifndef MNG_NO_16BIT_SUPPORT
+                   case 16 : {
+                               if (!pData->iInterlace)
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba16_ni;
+                               else
+                                 pData->fInitrowproc = (mng_fptr)mng_init_rgba16_i;
+
+                               break;
+                             }
+#endif
+                 }
+
+                 break;
+               }
+    }
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+
+    pData->iFilterofs = 0;             /* determine filter characteristics */
+    pData->iLevel0    = 0;             /* default levels */
+    pData->iLevel1    = 0;    
+    pData->iLevel2    = 0;
+    pData->iLevel3    = 0;
+
+#ifdef FILTER192                       /* leveling & differing ? */
+    if (pData->iFilter == MNG_FILTER_DIFFERING)
+    {
+      switch (pData->iColortype)
+      {
+        case 0 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 1;
+                   else
+                     pData->iFilterofs = 2;
+
+                   break;
+                 }
+        case 2 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 3;
+                   else
+                     pData->iFilterofs = 6;
+
+                   break;
+                 }
+        case 3 : {
+                   pData->iFilterofs = 1;
+                   break;
+                 }
+        case 4 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 2;
+                   else
+                     pData->iFilterofs = 4;
+
+                   break;
+                 }
+        case 6 : {
+                   if (pData->iBitdepth <= 8)
+                     pData->iFilterofs = 4;
+                   else
+                     pData->iFilterofs = 8;
+
+                   break;
+                 }
+      }
+    }
+#endif
+
+#ifdef FILTER193                       /* no adaptive filtering ? */
+    if (pData->iFilter == MNG_FILTER_NOFILTER)
+      pData->iPixelofs = pData->iFilterofs;
+    else
+#endif    
+      pData->iPixelofs = pData->iFilterofs + 1;
+
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+mng_retcode mng_process_display_mpng (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MPNG, MNG_LC_START);
+#endif
+
+  pData->iAlphadepth = 8;              /* assume transparency !! */
+
+  if (pData->fProcessheader)           /* inform the app (creating the output canvas) ? */
+  {
+    pData->iWidth  = ((mng_mpng_objp)pData->pMPNG)->iFramewidth;
+    pData->iHeight = ((mng_mpng_objp)pData->pMPNG)->iFrameheight;
+
+    if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+  next_layer (pData);                  /* first mPNG layer then ! */
+  pData->bTimerset   = MNG_FALSE;
+  pData->iBreakpoint = 0;
+
+  if ((pData->iDestr > pData->iDestl) && (pData->iDestb > pData->iDestt))
+    set_display_routine (pData);       /* then determine display routine */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+mng_retcode mng_process_display_ang (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_ANG, MNG_LC_START);
+#endif
+
+  if (pData->fProcessheader)           /* inform the app (creating the output canvas) ? */
+  {
+    if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+      MNG_ERROR (pData, MNG_APPMISCERROR);
+  }
+
+  next_layer (pData);                  /* first mPNG layer then ! */
+  pData->bTimerset   = MNG_FALSE;
+  pData->iBreakpoint = 0;
+
+  if ((pData->iDestr > pData->iDestl) && (pData->iDestb > pData->iDestt))
+    set_display_routine (pData);       /* then determine display routine */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_ANG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_idat (mng_datap  pData,
+                                      mng_uint32 iRawlen,
+                                      mng_uint8p pRawdata)
+#else
+mng_retcode mng_process_display_idat (mng_datap  pData)
+#endif
+{
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IDAT, MNG_LC_START);
+#endif
+
+#if defined(MNG_INCLUDE_MPNG_PROPOSAL) || defined(MNG_INCLUDE_ANG_PROPOSAL) 
+  if ((pData->eImagetype == mng_it_png) && (pData->iLayerseq <= 0))
+  {
+    if (pData->fProcessheader)         /* inform the app (creating the output canvas) ? */
+      if (!pData->fProcessheader (((mng_handle)pData), pData->iWidth, pData->iHeight))
+        MNG_ERROR (pData, MNG_APPMISCERROR);
+
+    next_layer (pData);                /* first regular PNG layer then ! */
+    pData->bTimerset   = MNG_FALSE;
+    pData->iBreakpoint = 0;
+
+    if ((pData->iDestr > pData->iDestl) && (pData->iDestb > pData->iDestt))
+      set_display_routine (pData);     /* then determine display routine */
+  }
+#endif
+
+  if (pData->bRestorebkgd)             /* need to restore the background ? */
+  {
+    pData->bRestorebkgd = MNG_FALSE;
+    iRetcode            = load_bkgdlayer (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    pData->iLayerseq++;                /* and it counts as a layer then ! */
+  }
+
+  if (pData->fInitrowproc)             /* need to initialize row processing? */
+  {
+    iRetcode = ((mng_initrowproc)pData->fInitrowproc) (pData);
+    pData->fInitrowproc = MNG_NULL;    /* only call this once !!! */
+  }
+
+  if ((!iRetcode) && (!pData->bInflating))
+                                       /* initialize inflate */
+    iRetcode = mngzlib_inflateinit (pData);
+
+  if (!iRetcode)                       /* all ok? then inflate, my man */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    iRetcode = mngzlib_inflaterows (pData, iRawlen, pRawdata);
+#else
+    iRetcode = mngzlib_inflaterows (pData, pData->iRawlen, pData->pRawdata);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+    
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_display_iend (mng_datap pData)
+{
+  mng_retcode iRetcode, iRetcode2;
+  mng_bool bDodisplay = MNG_FALSE;
+  mng_bool bMagnify   = MNG_FALSE;
+  mng_bool bCleanup   = (mng_bool)(pData->iBreakpoint != 0);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IEND, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_JNG                 /* progressive+alpha JNG can be displayed now */
+  if ( (pData->bHasJHDR                                         ) &&
+       ( (pData->bJPEGprogressive) || (pData->bJPEGprogressive2)) &&
+       ( (pData->eImagetype == mng_it_jng         ) ||
+         (((mng_imagep)pData->pStoreobj)->bVisible)             ) &&
+       ( (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA ) ||
+         (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )    )
+    bDodisplay = MNG_TRUE;
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+  if ( (pData->pStoreobj) &&           /* on-the-fly magnification ? */
+       ( (((mng_imagep)pData->pStoreobj)->iMAGN_MethodX) ||
+         (((mng_imagep)pData->pStoreobj)->iMAGN_MethodY)    ) )
+    bMagnify = MNG_TRUE;
+#endif
+
+  if ((pData->bHasBASI) ||             /* was it a BASI stream */
+      (bDodisplay)      ||             /* or should we display the JNG */
+#ifndef MNG_SKIPCHUNK_MAGN
+      (bMagnify)        ||             /* or should we magnify it */
+#endif
+                                       /* or did we get broken here last time ? */
+      ((pData->iBreakpoint) && (pData->iBreakpoint != 8)))
+  {
+    mng_imagep pImage = (mng_imagep)pData->pCurrentobj;
+
+    if (!pImage)                       /* or was it object 0 ? */
+      pImage = (mng_imagep)pData->pObjzero;
+                                       /* display it now then ? */
+    if ((pImage->bVisible) && (pImage->bViewable))
+    {                                  /* ok, so do it */
+      iRetcode = mng_display_image (pData, pImage, bDodisplay);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+
+      if (pData->bTimerset)            /* timer break ? */
+        pData->iBreakpoint = 6;
+    }
+  }
+#ifndef MNG_NO_DELTA_PNG
+  else
+  if ((pData->bHasDHDR) ||             /* was it a DHDR stream */
+      (pData->iBreakpoint == 8))       /* or did we get broken here last time ? */
+  {
+    mng_imagep pImage = (mng_imagep)pData->pDeltaImage;
+
+    if (!pData->iBreakpoint)
+    {                                  /* perform the delta operations needed */
+      iRetcode = mng_execute_delta_image (pData, pImage, (mng_imagep)pData->pObjzero);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+                                       /* display it now then ? */
+    if ((pImage->bVisible) && (pImage->bViewable))
+    {                                  /* ok, so do it */
+      iRetcode = mng_display_image (pData, pImage, MNG_FALSE);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+
+      if (pData->bTimerset)            /* timer break ? */
+        pData->iBreakpoint = 8;
+    }
+  }
+#endif
+
+  if (!pData->bTimerset)               /* can we continue ? */
+  {
+    pData->iBreakpoint = 0;            /* clear this flag now ! */
+
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    if (pData->eImagetype == mng_it_mpng)
+    {
+      pData->pCurraniobj = pData->pFirstaniobj;
+    } else
+#endif
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+    if (pData->eImagetype == mng_it_ang)
+    {
+      pData->pCurraniobj = pData->pFirstaniobj;
+    } else
+#endif
+    {                                  /* cleanup object 0 */
+      mng_reset_object_details (pData, (mng_imagep)pData->pObjzero,
+                                0, 0, 0, 0, 0, 0, 0, MNG_TRUE);
+    }
+
+    if (pData->bInflating)             /* if we've been inflating */
+    {                                  /* cleanup row-processing, */
+      iRetcode  = mng_cleanup_rowproc (pData);
+                                       /* also cleanup inflate! */
+      iRetcode2 = mngzlib_inflatefree (pData);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+      if (iRetcode2)
+        return iRetcode2;
+    }
+
+#ifdef MNG_INCLUDE_JNG
+    if (pData->bJPEGdecompress)        /* if we've been decompressing JDAT */
+    {                                  /* cleanup row-processing, */
+      iRetcode  = mng_cleanup_rowproc (pData);
+                                       /* also cleanup decompress! */
+      iRetcode2 = mngjpeg_decompressfree (pData);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+      if (iRetcode2)
+        return iRetcode2;
+    }
+
+    if (pData->bJPEGdecompress2)       /* if we've been decompressing JDAA */
+    {                                  /* cleanup row-processing, */
+      iRetcode  = mng_cleanup_rowproc (pData);
+                                       /* also cleanup decompress! */
+      iRetcode2 = mngjpeg_decompressfree2 (pData);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+      if (iRetcode2)
+        return iRetcode2;
+    }
+#endif
+
+    if (bCleanup)                      /* if we got broken last time we need to cleanup */
+    {
+      pData->bHasIHDR = MNG_FALSE;     /* IEND signals the end for most ... */
+      pData->bHasBASI = MNG_FALSE;
+      pData->bHasDHDR = MNG_FALSE;
+#ifdef MNG_INCLUDE_JNG
+      pData->bHasJHDR = MNG_FALSE;
+      pData->bHasJSEP = MNG_FALSE;
+      pData->bHasJDAA = MNG_FALSE;
+      pData->bHasJDAT = MNG_FALSE;
+#endif
+      pData->bHasPLTE = MNG_FALSE;
+      pData->bHasTRNS = MNG_FALSE;
+      pData->bHasGAMA = MNG_FALSE;
+      pData->bHasCHRM = MNG_FALSE;
+      pData->bHasSRGB = MNG_FALSE;
+      pData->bHasICCP = MNG_FALSE;
+      pData->bHasBKGD = MNG_FALSE;
+      pData->bHasIDAT = MNG_FALSE;
+    }
+                                       /* if the image was displayed on the fly, */
+                                       /* we'll have to make the app refresh */
+    if ((pData->eImagetype != mng_it_mng) && (pData->fDisplayrow))
+      pData->bNeedrefresh = MNG_TRUE;
+     
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+/* change in the MNG spec with regards to TERM delay & interframe_delay
+   as proposed by Adam M. Costello (option 4) and finalized by official vote
+   during december 2002 / check the 'mng-list' archives for more details */
+
+mng_retcode mng_process_display_mend (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MEND, MNG_LC_START);
+#endif
+
+  pData->bForcedelay = pData->iAccumdelay ? MNG_FALSE : MNG_TRUE;
+  pData->iAccumdelay = 0;
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+  if (pData->bStopafterseek)           /* need to stop after this ? */
+  {
+    pData->bFreezing      = MNG_TRUE;  /* stop processing on this one */
+    pData->bRunningevent  = MNG_FALSE;
+    pData->bStopafterseek = MNG_FALSE;
+    pData->bNeedrefresh   = MNG_TRUE;  /* make sure the last bit is displayed ! */
+  }
+#endif
+
+#ifndef MNG_SKIPCHUNK_TERM
+                                       /* TERM processed ? */
+  if ((pData->bDisplaying) && (pData->bRunning) &&
+      (pData->bHasTERM) && (pData->pTermaniobj))
+  {
+    mng_retcode   iRetcode;
+    mng_ani_termp pTERM;
+                                       /* get the right animation object ! */
+    pTERM = (mng_ani_termp)pData->pTermaniobj;
+
+    pData->iIterations++;              /* increase iteration count */
+
+    switch (pTERM->iTermaction)        /* determine what to do! */
+    {
+      case 0 : {                       /* show last frame indefinitly */
+                 break;                /* piece of cake, that is... */
+               }
+
+      case 1 : {                       /* cease displaying anything */
+                                       /* max(1, TERM delay, interframe_delay) */
+#ifndef MNG_SKIPCHUNK_FRAM
+                 if (pTERM->iDelay > pData->iFramedelay)
+                   pData->iFramedelay = pTERM->iDelay;
+                 if (!pData->iFramedelay)
+                   pData->iFramedelay = 1;
+#endif
+
+                 iRetcode = interframe_delay (pData);
+                                       /* no interframe_delay? then fake it */
+                 if ((!iRetcode) && (!pData->bTimerset))
+                   iRetcode = set_delay (pData, 1);
+
+                 if (iRetcode)
+                   return iRetcode;
+
+                 pData->iBreakpoint = 10;
+                 break;
+               }
+
+      case 2 : {                       /* show first image after TERM */
+                 iRetcode = restore_state (pData);
+
+                 if (iRetcode)         /* on error bail out */
+                   return iRetcode;
+                                       /* notify the app ? */
+                 if (pData->fProcessmend)
+                   if (!pData->fProcessmend ((mng_handle)pData, pData->iIterations, 0))
+                     MNG_ERROR (pData, MNG_APPMISCERROR);
+
+                                       /* show first frame after TERM chunk */
+                 pData->pCurraniobj      = pTERM;
+                 pData->bOnlyfirstframe  = MNG_TRUE;
+                 pData->iFramesafterTERM = 0;
+
+                                       /* max(1, TERM delay, interframe_delay) */
+#ifndef MNG_SKIPCHUNK_FRAM
+                 if (pTERM->iDelay > pData->iFramedelay)
+                   pData->iFramedelay = pTERM->iDelay;
+                 if (!pData->iFramedelay)
+                   pData->iFramedelay = 1;
+#endif
+
+                 break;
+               }
+
+      case 3 : {                       /* repeat */
+                 if ((pTERM->iItermax) && (pTERM->iItermax < 0x7FFFFFFF))
+                   pTERM->iItermax--;
+
+                 if (pTERM->iItermax)  /* go back to TERM ? */
+                 {                     /* restore to initial or SAVE state */
+                   iRetcode = restore_state (pData);
+
+                   if (iRetcode)       /* on error bail out */
+                     return iRetcode;
+                                       /* notify the app ? */
+                   if (pData->fProcessmend)
+                     if (!pData->fProcessmend ((mng_handle)pData,
+                                               pData->iIterations, pTERM->iItermax))
+                       MNG_ERROR (pData, MNG_APPMISCERROR);
+
+                                       /* restart from TERM chunk */
+                   pData->pCurraniobj = pTERM;
+
+                   if (pTERM->iDelay)  /* set the delay (?) */
+                   {
+                                       /* max(1, TERM delay, interframe_delay) */
+#ifndef MNG_SKIPCHUNK_FRAM
+                     if (pTERM->iDelay > pData->iFramedelay)
+                       pData->iFramedelay = pTERM->iDelay;
+                     if (!pData->iFramedelay)
+                       pData->iFramedelay = 1;
+#endif
+
+                     pData->bNeedrefresh = MNG_TRUE;
+                   }
+                 }
+                 else
+                 {
+                   switch (pTERM->iIteraction)
+                   {
+                     case 0 : {        /* show last frame indefinitly */
+                                break; /* piece of cake, that is... */
+                              }
+
+                     case 1 : {        /* cease displaying anything */
+                                       /* max(1, TERM delay, interframe_delay) */
+#ifndef MNG_SKIPCHUNK_FRAM
+                                if (pTERM->iDelay > pData->iFramedelay)
+                                  pData->iFramedelay = pTERM->iDelay;
+                                if (!pData->iFramedelay)
+                                  pData->iFramedelay = 1;
+#endif
+
+                                iRetcode = interframe_delay (pData);
+                                       /* no interframe_delay? then fake it */
+                                if ((!iRetcode) && (!pData->bTimerset))
+                                  iRetcode = set_delay (pData, 1);
+
+                                if (iRetcode)
+                                  return iRetcode;
+
+                                pData->iBreakpoint = 10;
+                                break;
+                              }
+
+                     case 2 : {        /* show first image after TERM */
+                                iRetcode = restore_state (pData);
+                                       /* on error bail out */
+                                if (iRetcode)
+                                  return iRetcode;
+                                       /* notify the app ? */
+                                if (pData->fProcessmend)
+                                  if (!pData->fProcessmend ((mng_handle)pData,
+                                                            pData->iIterations, 0))
+                                    MNG_ERROR (pData, MNG_APPMISCERROR);
+
+                                       /* show first frame after TERM chunk */
+                                pData->pCurraniobj      = pTERM;
+                                pData->bOnlyfirstframe  = MNG_TRUE;
+                                pData->iFramesafterTERM = 0;
+                                       /* max(1, TERM delay, interframe_delay) */
+#ifndef MNG_SKIPCHUNK_FRAM
+                                if (pTERM->iDelay > pData->iFramedelay)
+                                  pData->iFramedelay = pTERM->iDelay;
+                                if (!pData->iFramedelay)
+                                  pData->iFramedelay = 1;
+#endif
+
+                                break;
+                              }
+                   }
+                 }
+
+                 break;
+               }
+    }
+  }
+#endif /* MNG_SKIPCHUNK_TERM */
+                                       /* just reading ? */
+  if ((!pData->bDisplaying) && (pData->bReading))
+    if (pData->fProcessmend)           /* inform the app ? */
+      if (!pData->fProcessmend ((mng_handle)pData, 0, 0))
+        MNG_ERROR (pData, MNG_APPMISCERROR);
+
+  if (!pData->pCurraniobj)             /* always let the app refresh at the end ! */
+    pData->bNeedrefresh = MNG_TRUE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_display_mend2 (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MEND, MNG_LC_START);
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+  pData->bFrameclipping = MNG_FALSE;   /* nothing to do but restore the app background */
+#endif
+  load_bkgdlayer (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MEND, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+mng_retcode mng_process_display_defi (mng_datap pData)
+{
+  mng_imagep pImage;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_DEFI, MNG_LC_START);
+#endif
+
+  if (!pData->iDEFIobjectid)           /* object id=0 ? */
+  {
+    pImage             = (mng_imagep)pData->pObjzero;
+
+    if (pData->bDEFIhasdonotshow)
+      pImage->bVisible = (mng_bool)(pData->iDEFIdonotshow == 0);
+
+    if (pData->bDEFIhasloca)
+    {
+      pImage->iPosx    = pData->iDEFIlocax;
+      pImage->iPosy    = pData->iDEFIlocay;
+    }
+
+    if (pData->bDEFIhasclip)
+    {
+      pImage->bClipped = pData->bDEFIhasclip;
+      pImage->iClipl   = pData->iDEFIclipl;
+      pImage->iClipr   = pData->iDEFIclipr;
+      pImage->iClipt   = pData->iDEFIclipt;
+      pImage->iClipb   = pData->iDEFIclipb;
+    }
+
+    pData->pCurrentobj = 0;            /* not a real object ! */
+  }
+  else
+  {                                    /* already exists ? */
+    pImage = (mng_imagep)mng_find_imageobject (pData, pData->iDEFIobjectid);
+
+    if (!pImage)                       /* if not; create new */
+    {
+      mng_retcode iRetcode = mng_create_imageobject (pData, pData->iDEFIobjectid,
+                                                     (mng_bool)(pData->iDEFIconcrete == 1),
+                                                     (mng_bool)(pData->iDEFIdonotshow == 0),
+                                                     MNG_FALSE, 0, 0, 0, 0, 0, 0, 0,
+                                                     pData->iDEFIlocax, pData->iDEFIlocay,
+                                                     pData->bDEFIhasclip,
+                                                     pData->iDEFIclipl, pData->iDEFIclipr,
+                                                     pData->iDEFIclipt, pData->iDEFIclipb,
+                                                     &pImage);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+    else
+    {                                  /* exists; then set new info */
+      if (pData->bDEFIhasdonotshow)
+        pImage->bVisible = (mng_bool)(pData->iDEFIdonotshow == 0);
+
+      pImage->bViewable  = MNG_FALSE;
+
+      if (pData->bDEFIhasloca)
+      {
+        pImage->iPosx    = pData->iDEFIlocax;
+        pImage->iPosy    = pData->iDEFIlocay;
+      }
+
+      if (pData->bDEFIhasclip)
+      {
+        pImage->bClipped = pData->bDEFIhasclip;
+        pImage->iClipl   = pData->iDEFIclipl;
+        pImage->iClipr   = pData->iDEFIclipr;
+        pImage->iClipt   = pData->iDEFIclipt;
+        pImage->iClipb   = pData->iDEFIclipb;
+      }
+
+      if (pData->bDEFIhasconcrete)
+        pImage->pImgbuf->bConcrete = (mng_bool)(pData->iDEFIconcrete == 1);
+    }
+
+    pData->pCurrentobj = pImage;       /* others may want to know this */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BASI
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_basi (mng_datap  pData,
+                                      mng_uint16 iRed,
+                                      mng_uint16 iGreen,
+                                      mng_uint16 iBlue,
+                                      mng_bool   bHasalpha,
+                                      mng_uint16 iAlpha,
+                                      mng_uint8  iViewable)
+#else
+mng_retcode mng_process_display_basi (mng_datap  pData)
+#endif
+{                                      /* address the current "object" if any */
+  mng_imagep     pImage = (mng_imagep)pData->pCurrentobj;
+  mng_uint8p     pWork;
+  mng_uint32     iX;
+  mng_imagedatap pBuf;
+  mng_retcode    iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_BASI, MNG_LC_START);
+#endif
+
+  if (!pImage)                         /* or is it an "on-the-fly" image ? */
+    pImage = (mng_imagep)pData->pObjzero;
+                                       /* address the object-buffer */
+  pBuf               = pImage->pImgbuf;
+
+  pData->fDisplayrow = MNG_NULL;       /* do nothing by default */
+  pData->fCorrectrow = MNG_NULL;
+  pData->fStorerow   = MNG_NULL;
+  pData->fProcessrow = MNG_NULL;
+                                       /* set parms now that they're known */
+  iRetcode = mng_reset_object_details (pData, pImage, pData->iDatawidth,
+                                       pData->iDataheight, pData->iBitdepth,
+                                       pData->iColortype, pData->iCompression,
+                                       pData->iFilter, pData->iInterlace, MNG_FALSE);
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+                                       /* save the viewable flag */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  pImage->bViewable = (mng_bool)(iViewable == 1);
+#else
+  pImage->bViewable = (mng_bool)(pData->iBASIviewable == 1);
+#endif
+  pBuf->bViewable   = pImage->bViewable;
+  pData->pStoreobj  = pImage;          /* let row-routines know which object */
+
+  pWork = pBuf->pImgdata;              /* fill the object-buffer with the specified
+                                          "color" sample */
+  switch (pData->iColortype)           /* depending on color_type & bit_depth */
+  {
+    case 0 : {                         /* gray */
+#ifndef MNG_NO_16BIT_SUPPORT
+               if (pData->iBitdepth == 16)
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   mng_put_uint16 (pWork, iRed);
+#else
+                   mng_put_uint16 (pWork, pData->iBASIred);
+#endif
+                   pWork += 2;
+                 }
+               }
+               else
+#endif
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   *pWork = (mng_uint8)iRed;
+#else
+                   *pWork = (mng_uint8)pData->iBASIred;
+#endif
+                   pWork++;
+                 }
+               }
+                                       /* force tRNS ? */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+               if ((bHasalpha) && (!iAlpha))
+#else
+               if ((pData->bBASIhasalpha) && (!pData->iBASIalpha))
+#endif
+               {
+                 pBuf->bHasTRNS  = MNG_TRUE;
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                 pBuf->iTRNSgray = iRed;
+#else
+                 pBuf->iTRNSgray = pData->iBASIred;
+#endif
+               }
+
+               break;
+             }
+
+    case 2 : {                         /* rgb */
+#ifndef MNG_NO_16BIT_SUPPORT
+               if (pData->iBitdepth == 16)
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   mng_put_uint16 (pWork,   iRed  );
+                   mng_put_uint16 (pWork+2, iGreen);
+                   mng_put_uint16 (pWork+4, iBlue );
+#else
+                   mng_put_uint16 (pWork,   pData->iBASIred  );
+                   mng_put_uint16 (pWork+2, pData->iBASIgreen);
+                   mng_put_uint16 (pWork+4, pData->iBASIblue );
+#endif
+                   pWork += 6;
+                 }
+               }
+               else
+#endif
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   *pWork     = (mng_uint8)iRed;
+                   *(pWork+1) = (mng_uint8)iGreen;
+                   *(pWork+2) = (mng_uint8)iBlue;
+#else
+                   *pWork     = (mng_uint8)pData->iBASIred;
+                   *(pWork+1) = (mng_uint8)pData->iBASIgreen;
+                   *(pWork+2) = (mng_uint8)pData->iBASIblue;
+#endif
+                   pWork += 3;
+                 }
+               }
+                                       /* force tRNS ? */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+               if ((bHasalpha) && (!iAlpha))
+#else
+               if ((pData->bBASIhasalpha) && (!pData->iBASIalpha))
+#endif
+               {
+                 pBuf->bHasTRNS   = MNG_TRUE;
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                 pBuf->iTRNSred   = iRed;
+                 pBuf->iTRNSgreen = iGreen;
+                 pBuf->iTRNSblue  = iBlue;
+#else
+                 pBuf->iTRNSred   = pData->iBASIred;
+                 pBuf->iTRNSgreen = pData->iBASIgreen;
+                 pBuf->iTRNSblue  = pData->iBASIblue;
+#endif
+               }
+
+               break;
+             }
+
+    case 3 : {                         /* indexed */
+               pBuf->bHasPLTE = MNG_TRUE;
+
+               switch (pData->iBitdepth)
+               {
+                 case 1  : { pBuf->iPLTEcount =   2; break; }
+                 case 2  : { pBuf->iPLTEcount =   4; break; }
+                 case 4  : { pBuf->iPLTEcount =  16; break; }
+                 case 8  : { pBuf->iPLTEcount = 256; break; }
+                 default : { pBuf->iPLTEcount =   1; break; }
+               }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+               pBuf->aPLTEentries [0].iRed   = (mng_uint8)iRed;
+               pBuf->aPLTEentries [0].iGreen = (mng_uint8)iGreen;
+               pBuf->aPLTEentries [0].iBlue  = (mng_uint8)iBlue;
+#else
+               pBuf->aPLTEentries [0].iRed   = (mng_uint8)pData->iBASIred;
+               pBuf->aPLTEentries [0].iGreen = (mng_uint8)pData->iBASIgreen;
+               pBuf->aPLTEentries [0].iBlue  = (mng_uint8)pData->iBASIblue;
+#endif
+
+               for (iX = 1; iX < pBuf->iPLTEcount; iX++)
+               {
+                 pBuf->aPLTEentries [iX].iRed   = 0;
+                 pBuf->aPLTEentries [iX].iGreen = 0;
+                 pBuf->aPLTEentries [iX].iBlue  = 0;
+               }
+                                       /* force tRNS ? */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+               if ((bHasalpha) && (iAlpha < 255))
+#else
+               if ((pData->bBASIhasalpha) && (pData->iBASIalpha < 255))
+#endif
+               {
+                 pBuf->bHasTRNS         = MNG_TRUE;
+                 pBuf->iTRNScount       = 1;
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                 pBuf->aTRNSentries [0] = (mng_uint8)iAlpha;
+#else
+                 pBuf->aTRNSentries [0] = (mng_uint8)pData->iBASIalpha;
+#endif
+               }
+
+               break;
+             }
+
+    case 4 : {                         /* gray+alpha */
+#ifndef MNG_NO_16BIT_SUPPORT
+               if (pData->iBitdepth == 16)
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   mng_put_uint16 (pWork,   iRed);
+                   mng_put_uint16 (pWork+2, iAlpha);
+#else
+                   mng_put_uint16 (pWork,   pData->iBASIred);
+                   mng_put_uint16 (pWork+2, pData->iBASIalpha);
+#endif
+                   pWork += 4;
+                 }
+               }
+               else
+#endif
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   *pWork     = (mng_uint8)iRed;
+                   *(pWork+1) = (mng_uint8)iAlpha;
+#else
+                   *pWork     = (mng_uint8)pData->iBASIred;
+                   *(pWork+1) = (mng_uint8)pData->iBASIalpha;
+#endif
+                   pWork += 2;
+                 }
+               }
+
+               break;
+             }
+
+    case 6 : {                         /* rgb+alpha */
+#ifndef MNG_NO_16BIT_SUPPORT
+               if (pData->iBitdepth == 16)
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   mng_put_uint16 (pWork,   iRed);
+                   mng_put_uint16 (pWork+2, iGreen);
+                   mng_put_uint16 (pWork+4, iBlue);
+                   mng_put_uint16 (pWork+6, iAlpha);
+#else
+                   mng_put_uint16 (pWork,   pData->iBASIred);
+                   mng_put_uint16 (pWork+2, pData->iBASIgreen);
+                   mng_put_uint16 (pWork+4, pData->iBASIblue);
+                   mng_put_uint16 (pWork+6, pData->iBASIalpha);
+#endif
+                   pWork += 8;
+                 }
+               }
+               else
+#endif
+               {
+#ifdef MNG_DECREMENT_LOOPS
+                 for (iX = pData->iDatawidth * pData->iDataheight;
+                    iX > 0;iX--)
+#else
+                 for (iX = 0; iX < pData->iDatawidth * pData->iDataheight; iX++)
+#endif
+                 {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   *pWork     = (mng_uint8)iRed;
+                   *(pWork+1) = (mng_uint8)iGreen;
+                   *(pWork+2) = (mng_uint8)iBlue;
+                   *(pWork+3) = (mng_uint8)iAlpha;
+#else
+                   *pWork     = (mng_uint8)pData->iBASIred;
+                   *(pWork+1) = (mng_uint8)pData->iBASIgreen;
+                   *(pWork+2) = (mng_uint8)pData->iBASIblue;
+                   *(pWork+3) = (mng_uint8)pData->iBASIalpha;
+#endif
+                   pWork += 4;
+                 }
+               }
+
+               break;
+             }
+
+  }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+  pData->fInitrowproc = (mng_fptr)mng_init_rowproc;
+  pData->ePng_imgtype=mng_png_imgtype(pData->iColortype,pData->iBitdepth);
+#else
+  switch (pData->iColortype)           /* determine row initialization routine */
+  {                                    /* just to accomodate IDAT if it arrives */
+    case 0 : {                         /* gray */
+               switch (pData->iBitdepth)
+               {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                 case  1 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_g1_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_g1_i;
+
+                             break;
+                           }
+                 case  2 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_g2_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_g2_i;
+
+                             break;
+                           }
+                 case  4 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_g4_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_g4_i;
+
+                             break;
+                           }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                 case  8 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_g8_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_g8_i;
+
+                             break;
+                           }
+#ifndef MNG_NO_16BIT_SUPPORT
+                 case 16 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_g16_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_g16_i;
+
+                             break;
+                           }
+#endif
+               }
+
+               break;
+             }
+    case 2 : {                         /* rgb */
+               switch (pData->iBitdepth)
+               {
+                 case  8 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgb8_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgb8_i;
+
+                             break;
+                           }
+#ifndef MNG_NO_16BIT_SUPPORT
+                 case 16 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgb16_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgb16_i;
+
+                             break;
+                           }
+#endif
+               }
+
+               break;
+             }
+    case 3 : {                         /* indexed */
+               switch (pData->iBitdepth)
+               {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                 case  1 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx1_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx1_i;
+
+                             break;
+                           }
+                 case  2 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx2_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx2_i;
+
+                             break;
+                           }
+                 case  4 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx4_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx4_i;
+
+                             break;
+                           }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                 case  8 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx8_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_idx8_i;
+
+                             break;
+                           }
+               }
+
+               break;
+             }
+    case 4 : {                         /* gray+alpha */
+               switch (pData->iBitdepth)
+               {
+                 case  8 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_ga8_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_ga8_i;
+
+                             break;
+                           }
+#ifndef MNG_NO_16BIT_SUPPORT
+                 case 16 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_ga16_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_ga16_i;
+
+                             break;
+                           }
+#endif
+               }
+
+               break;
+             }
+    case 6 : {                         /* rgb+alpha */
+               switch (pData->iBitdepth)
+               {
+                 case  8 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgba8_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgba8_i;
+
+                             break;
+                           }
+#ifndef MNG_NO_16BIT_SUPPORT
+                 case 16 : {
+                             if (!pData->iInterlace)
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgba16_ni;
+                             else
+                               pData->fInitrowproc = (mng_fptr)mng_init_rgba16_i;
+
+                             break;
+                           }
+#endif
+               }
+
+               break;
+             }
+  }
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+
+  pData->iFilterofs = 0;               /* determine filter characteristics */
+  pData->iLevel0    = 0;               /* default levels */
+  pData->iLevel1    = 0;
+  pData->iLevel2    = 0;
+  pData->iLevel3    = 0;
+
+#ifdef FILTER192
+  if (pData->iFilter == 0xC0)          /* leveling & differing ? */
+  {
+    switch (pData->iColortype)
+    {
+      case 0 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (pData->iBitdepth <= 8)
+#endif
+                   pData->iFilterofs = 1;
+#ifndef MNG_NO_16BIT_SUPPORT
+                 else
+                   pData->iFilterofs = 2;
+#endif
+
+                 break;
+               }
+      case 2 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (pData->iBitdepth <= 8)
+#endif
+                   pData->iFilterofs = 3;
+#ifndef MNG_NO_16BIT_SUPPORT
+                 else
+                   pData->iFilterofs = 6;
+#endif
+
+                 break;
+               }
+      case 3 : {
+                 pData->iFilterofs = 1;
+                 break;
+               }
+      case 4 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (pData->iBitdepth <= 8)
+#endif
+                   pData->iFilterofs = 2;
+#ifndef MNG_NO_16BIT_SUPPORT
+                 else
+                   pData->iFilterofs = 4;
+#endif
+
+                 break;
+               }
+      case 6 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (pData->iBitdepth <= 8)
+#endif
+                   pData->iFilterofs = 4;
+#ifndef MNG_NO_16BIT_SUPPORT
+                 else
+                   pData->iFilterofs = 8;
+#endif
+
+                 break;
+               }
+    }
+  }
+#endif
+
+#ifdef FILTER193
+  if (pData->iFilter == 0xC1)          /* no adaptive filtering ? */
+    pData->iPixelofs = pData->iFilterofs;
+  else
+#endif
+    pData->iPixelofs = pData->iFilterofs + 1;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLON
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_clon (mng_datap  pData,
+                                      mng_uint16 iSourceid,
+                                      mng_uint16 iCloneid,
+                                      mng_uint8  iClonetype,
+                                      mng_bool   bHasdonotshow,
+                                      mng_uint8  iDonotshow,
+                                      mng_uint8  iConcrete,
+                                      mng_bool   bHasloca,
+                                      mng_uint8  iLocationtype,
+                                      mng_int32  iLocationx,
+                                      mng_int32  iLocationy)
+#else
+mng_retcode mng_process_display_clon (mng_datap  pData)
+#endif
+{
+  mng_imagep  pSource, pClone;
+  mng_bool    bVisible, bAbstract;
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_CLON, MNG_LC_START);
+#endif
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                                       /* locate the source object first */
+  pSource = mng_find_imageobject (pData, iSourceid);
+                                       /* check if the clone exists */
+  pClone  = mng_find_imageobject (pData, iCloneid);
+#else
+                                       /* locate the source object first */
+  pSource = mng_find_imageobject (pData, pData->iCLONsourceid);
+                                       /* check if the clone exists */
+  pClone  = mng_find_imageobject (pData, pData->iCLONcloneid);
+#endif
+
+  if (!pSource)                        /* source must exist ! */
+    MNG_ERROR (pData, MNG_OBJECTUNKNOWN);
+
+  if (pClone)                          /* clone must not exist ! */
+    MNG_ERROR (pData, MNG_OBJECTEXISTS);
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  if (bHasdonotshow)                   /* DoNotShow flag filled ? */
+    bVisible = (mng_bool)(iDonotshow == 0);
+  else
+    bVisible = pSource->bVisible;
+#else
+  if (pData->bCLONhasdonotshow)        /* DoNotShow flag filled ? */
+    bVisible = (mng_bool)(pData->iCLONdonotshow == 0);
+  else
+    bVisible = pSource->bVisible;
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  bAbstract  = (mng_bool)(iConcrete == 1);
+#else
+  bAbstract  = (mng_bool)(pData->iCLONconcrete == 1);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  switch (iClonetype)                  /* determine action to take */
+  {
+    case 0 : {                         /* full clone */
+               iRetcode = mng_clone_imageobject (pData, iCloneid, MNG_FALSE,
+                                                 bVisible, bAbstract, bHasloca,
+                                                 iLocationtype, iLocationx, iLocationy,
+                                                 pSource, &pClone);
+               break;
+             }
+
+    case 1 : {                         /* partial clone */
+               iRetcode = mng_clone_imageobject (pData, iCloneid, MNG_TRUE,
+                                                 bVisible, bAbstract, bHasloca,
+                                                 iLocationtype, iLocationx, iLocationy,
+                                                 pSource, &pClone);
+               break;
+             }
+
+    case 2 : {                         /* renumber object */
+               iRetcode = mng_renum_imageobject (pData, pSource, iCloneid,
+                                                 bVisible, bAbstract, bHasloca,
+                                                 iLocationtype, iLocationx, iLocationy);
+               pClone   = pSource;
+               break;
+             }
+
+  }
+#else
+  switch (pData->iCLONclonetype)       /* determine action to take */
+  {
+    case 0 : {                         /* full clone */
+               iRetcode = mng_clone_imageobject (pData, pData->iCLONcloneid, MNG_FALSE,
+                                                 bVisible, bAbstract,
+                                                 pData->bCLONhasloca, pData->iCLONlocationtype,
+                                                 pData->iCLONlocationx, pData->iCLONlocationy,
+                                                 pSource, &pClone);
+               break;
+             }
+
+    case 1 : {                         /* partial clone */
+               iRetcode = mng_clone_imageobject (pData, pData->iCLONcloneid, MNG_TRUE,
+                                                 bVisible, bAbstract,
+                                                 pData->bCLONhasloca, pData->iCLONlocationtype,
+                                                 pData->iCLONlocationx, pData->iCLONlocationy,
+                                                 pSource, &pClone);
+               break;
+             }
+
+    case 2 : {                         /* renumber object */
+               iRetcode = mng_renum_imageobject (pData, pSource, pData->iCLONcloneid,
+                                                 bVisible, bAbstract,
+                                                 pData->bCLONhasloca, pData->iCLONlocationtype,
+                                                 pData->iCLONlocationx, pData->iCLONlocationy);
+               pClone   = pSource;
+               break;
+             }
+
+  }
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+                                       /* display on the fly ? */
+  if ((pClone->bViewable) && (pClone->bVisible))
+  {
+    pData->pLastclone = pClone;        /* remember in case of timer break ! */
+                                       /* display it */
+    mng_display_image (pData, pClone, MNG_FALSE);
+
+    if (pData->bTimerset)              /* timer break ? */
+      pData->iBreakpoint = 5;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_display_clon2 (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_CLON, MNG_LC_START);
+#endif
+                                       /* only called after timer break ! */
+  mng_display_image (pData, (mng_imagep)pData->pLastclone, MNG_FALSE);
+  pData->iBreakpoint = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_disc (mng_datap   pData,
+                                      mng_uint32  iCount,
+                                      mng_uint16p pIds)
+#else
+mng_retcode mng_process_display_disc (mng_datap   pData)
+#endif
+{
+  mng_uint32 iX;
+  mng_imagep pImage;
+  mng_uint32 iRetcode;
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_DISC, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  if (iCount)                          /* specific list ? */
+#else
+  if (pData->iDISCcount)               /* specific list ? */
+#endif
+  {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    mng_uint16p pWork = pIds;
+#else
+    mng_uint16p pWork = pData->pDISCids;
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifdef MNG_DECREMENT_LOOPS             /* iterate the list */
+    for (iX = iCount; iX > 0; iX--)
+#else
+    for (iX = 0; iX < iCount; iX++)
+#endif
+#else
+#ifdef MNG_DECREMENT_LOOPS             /* iterate the list */
+    for (iX = pData->iDISCcount; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iDISCcount; iX++)
+#endif
+#endif
+    {
+      pImage = mng_find_imageobject (pData, *pWork++);
+
+      if (pImage)                      /* found the object ? */
+      {                                /* then drop it */
+        iRetcode = mng_free_imageobject (pData, pImage);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+    }
+  }
+  else                                 /* empty: drop all un-frozen objects */
+  {
+    mng_imagep pNext = (mng_imagep)pData->pFirstimgobj;
+
+    while (pNext)                      /* any left ? */
+    {
+      pImage = pNext;
+      pNext  = pImage->sHeader.pNext;
+
+      if (!pImage->bFrozen)            /* not frozen ? */
+      {                                /* then drop it */
+        iRetcode = mng_free_imageobject (pData, pImage);
+                       
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_DISC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_fram (mng_datap  pData,
+                                      mng_uint8  iFramemode,
+                                      mng_uint8  iChangedelay,
+                                      mng_uint32 iDelay,
+                                      mng_uint8  iChangetimeout,
+                                      mng_uint32 iTimeout,
+                                      mng_uint8  iChangeclipping,
+                                      mng_uint8  iCliptype,
+                                      mng_int32  iClipl,
+                                      mng_int32  iClipr,
+                                      mng_int32  iClipt,
+                                      mng_int32  iClipb)
+#else
+mng_retcode mng_process_display_fram (mng_datap  pData)
+#endif
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_FRAM, MNG_LC_START);
+#endif
+                                       /* advance a frame then */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = next_frame (pData, iFramemode, iChangedelay, iDelay,
+                         iChangetimeout, iTimeout, iChangeclipping,
+                         iCliptype, iClipl, iClipr, iClipt, iClipb);
+#else
+  iRetcode = next_frame (pData, pData->iTempFramemode, pData->iTempChangedelay,
+                         pData->iTempDelay, pData->iTempChangetimeout,
+                         pData->iTempTimeout, pData->iTempChangeclipping,
+                         pData->iTempCliptype, pData->iTempClipl, pData->iTempClipr,
+                         pData->iTempClipt, pData->iTempClipb);
+#endif
+
+  if (pData->bTimerset)                /* timer break ? */
+    pData->iBreakpoint = 1;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_FRAM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_display_fram2 (mng_datap pData)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_FRAM, MNG_LC_START);
+#endif
+                                       /* again; after the break */
+  iRetcode = next_frame (pData, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+  pData->iBreakpoint = 0;              /* not again! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_FRAM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MOVE
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_move (mng_datap  pData,
+                                      mng_uint16 iFromid,
+                                      mng_uint16 iToid,
+                                      mng_uint8  iMovetype,
+                                      mng_int32  iMovex,
+                                      mng_int32  iMovey)
+#else
+mng_retcode mng_process_display_move (mng_datap  pData)
+#endif
+{
+  mng_uint16 iX;
+  mng_imagep pImage;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MOVE, MNG_LC_START);
+#endif
+                                       /* iterate the list */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  for (iX = iFromid; iX <= iToid; iX++)
+#else
+  for (iX = pData->iMOVEfromid; iX <= pData->iMOVEtoid; iX++)
+#endif
+  {
+    if (!iX)                           /* object id=0 ? */
+      pImage = (mng_imagep)pData->pObjzero;
+    else
+      pImage = mng_find_imageobject (pData, iX);
+
+    if (pImage)                        /* object exists ? */
+    {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      switch (iMovetype)
+#else
+      switch (pData->iMOVEmovetype)
+#endif
+      {
+        case 0 : {                     /* absolute */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   pImage->iPosx = iMovex;
+                   pImage->iPosy = iMovey;
+#else
+                   pImage->iPosx = pData->iMOVEmovex;
+                   pImage->iPosy = pData->iMOVEmovey;
+#endif
+                   break;
+                 }
+        case 1 : {                     /* relative */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   pImage->iPosx = pImage->iPosx + iMovex;
+                   pImage->iPosy = pImage->iPosy + iMovey;
+#else
+                   pImage->iPosx = pImage->iPosx + pData->iMOVEmovex;
+                   pImage->iPosy = pImage->iPosy + pData->iMOVEmovey;
+#endif
+                   break;
+                 }
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLIP
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_clip (mng_datap  pData,
+                                      mng_uint16 iFromid,
+                                      mng_uint16 iToid,
+                                      mng_uint8  iCliptype,
+                                      mng_int32  iClipl,
+                                      mng_int32  iClipr,
+                                      mng_int32  iClipt,
+                                      mng_int32  iClipb)
+#else
+mng_retcode mng_process_display_clip (mng_datap  pData)
+#endif
+{
+  mng_uint16 iX;
+  mng_imagep pImage;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_CLIP, MNG_LC_START);
+#endif
+                                       /* iterate the list */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  for (iX = iFromid; iX <= iToid; iX++)
+#else
+  for (iX = pData->iCLIPfromid; iX <= pData->iCLIPtoid; iX++)
+#endif
+  {
+    if (!iX)                           /* object id=0 ? */
+      pImage = (mng_imagep)pData->pObjzero;
+    else
+      pImage = mng_find_imageobject (pData, iX);
+
+    if (pImage)                        /* object exists ? */
+    {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      switch (iCliptype)
+#else
+      switch (pData->iCLIPcliptype)
+#endif
+      {
+        case 0 : {                     /* absolute */
+                   pImage->bClipped = MNG_TRUE;
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   pImage->iClipl   = iClipl;
+                   pImage->iClipr   = iClipr;
+                   pImage->iClipt   = iClipt;
+                   pImage->iClipb   = iClipb;
+#else
+                   pImage->iClipl   = pData->iCLIPclipl;
+                   pImage->iClipr   = pData->iCLIPclipr;
+                   pImage->iClipt   = pData->iCLIPclipt;
+                   pImage->iClipb   = pData->iCLIPclipb;
+#endif
+                   break;
+                 }
+        case 1 : {                    /* relative */
+                   pImage->bClipped = MNG_TRUE;
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   pImage->iClipl   = pImage->iClipl + iClipl;
+                   pImage->iClipr   = pImage->iClipr + iClipr;
+                   pImage->iClipt   = pImage->iClipt + iClipt;
+                   pImage->iClipb   = pImage->iClipb + iClipb;
+#else
+                   pImage->iClipl   = pImage->iClipl + pData->iCLIPclipl;
+                   pImage->iClipr   = pImage->iClipr + pData->iCLIPclipr;
+                   pImage->iClipt   = pImage->iClipt + pData->iCLIPclipt;
+                   pImage->iClipb   = pImage->iClipb + pData->iCLIPclipb;
+#endif
+                   break;
+                 }
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SHOW
+mng_retcode mng_process_display_show (mng_datap pData)
+{
+  mng_int16  iX, iS, iFrom, iTo;
+  mng_imagep pImage;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_SHOW, MNG_LC_START);
+#endif
+
+  /* TODO: optimization for the cases where "abs (iTo - iFrom)" is rather high;
+     especially where ((iFrom==1) && (iTo==65535)); eg. an empty SHOW !!! */
+
+  if (pData->iBreakpoint == 3)         /* previously broken during cycle-mode ? */
+  {
+    pImage = mng_find_imageobject (pData, pData->iSHOWnextid);
+                 
+    if (pImage)                        /* still there ? */
+      mng_display_image (pData, pImage, MNG_FALSE);
+
+    pData->iBreakpoint = 0;            /* let's not go through this again! */
+  }
+  else
+  {
+    if (pData->iBreakpoint)            /* previously broken at other point ? */
+    {                                  /* restore last parms */
+      iFrom = (mng_int16)pData->iSHOWfromid;
+      iTo   = (mng_int16)pData->iSHOWtoid;
+      iX    = (mng_int16)pData->iSHOWnextid;
+      iS    = (mng_int16)pData->iSHOWskip;
+    }
+    else
+    {                                  /* regular sequence ? */
+      if (pData->iSHOWtoid >= pData->iSHOWfromid)
+        iS  = 1;
+      else                             /* reverse sequence ! */
+        iS  = -1;
+
+      iFrom = (mng_int16)pData->iSHOWfromid;
+      iTo   = (mng_int16)pData->iSHOWtoid;
+      iX    = iFrom;
+
+      pData->iSHOWfromid = (mng_uint16)iFrom;
+      pData->iSHOWtoid   = (mng_uint16)iTo;
+      pData->iSHOWskip   = iS;
+    }
+                                       /* cycle mode ? */
+    if ((pData->iSHOWmode == 6) || (pData->iSHOWmode == 7))
+    {
+      mng_uint16 iTrigger = 0;
+      mng_uint16 iFound   = 0;
+      mng_uint16 iPass    = 0;
+      mng_imagep pFound   = 0;
+
+      do
+      {
+        iPass++;                       /* lets prevent endless loops when there
+                                          are no potential candidates in the list! */
+
+        if (iS > 0)                    /* forward ? */
+        {
+          for (iX = iFrom; iX <= iTo; iX += iS)
+          {
+            pImage = mng_find_imageobject (pData, (mng_uint16)iX);
+                         
+            if (pImage)                /* object exists ? */
+            {
+              if (iFound)              /* already found a candidate ? */
+                pImage->bVisible = MNG_FALSE;
+              else
+              if (iTrigger)            /* found the trigger ? */
+              {
+                pImage->bVisible = MNG_TRUE;
+                iFound           = iX;
+                pFound           = pImage;
+              }
+              else
+              if (pImage->bVisible)    /* ok, this is the trigger */
+              {
+                pImage->bVisible = MNG_FALSE;
+                iTrigger         = iX;
+              }
+            }
+          }
+        }
+        else
+        {
+          for (iX = iFrom; iX >= iTo; iX += iS)
+          {
+            pImage = mng_find_imageobject (pData, (mng_uint16)iX);
+                         
+            if (pImage)                /* object exists ? */
+            {
+              if (iFound)              /* already found a candidate ? */
+                pImage->bVisible = MNG_FALSE;
+              else
+              if (iTrigger)            /* found the trigger ? */
+              {
+                pImage->bVisible = MNG_TRUE;
+                iFound           = iX;
+                pFound           = pImage;
+              }
+              else
+              if (pImage->bVisible)    /* ok, this is the trigger */
+              {
+                pImage->bVisible = MNG_FALSE;
+                iTrigger         = iX;
+              }
+            }
+          }
+        }
+
+        if (!iTrigger)                 /* did not find a trigger ? */
+          iTrigger = 1;                /* then fake it so the first image
+                                          gets nominated */
+      }                                /* cycle back to beginning ? */
+      while ((iPass < 2) && (iTrigger) && (!iFound));
+
+      pData->iBreakpoint = 0;          /* just a sanity precaution */
+                                       /* display it ? */
+      if ((pData->iSHOWmode == 6) && (pFound))
+      {
+        mng_display_image (pData, pFound, MNG_FALSE);
+
+        if (pData->bTimerset)          /* timer set ? */
+        {
+          pData->iBreakpoint = 3;
+          pData->iSHOWnextid = iFound; /* save it for after the break */
+        }
+      }
+    }
+    else
+    {
+      do
+      {
+        pImage = mng_find_imageobject (pData, iX);
+                     
+        if (pImage)                    /* object exists ? */
+        {
+          if (pData->iBreakpoint)      /* did we get broken last time ? */
+          {                            /* could only happen in the display routine */
+            mng_display_image (pData, pImage, MNG_FALSE);
+            pData->iBreakpoint = 0;    /* only once inside this loop please ! */
+          }
+          else
+          {
+            switch (pData->iSHOWmode)  /* do what ? */
+            {
+              case 0 : {
+                         pImage->bVisible = MNG_TRUE;
+                         mng_display_image (pData, pImage, MNG_FALSE);
+                         break;
+                       }
+              case 1 : {
+                         pImage->bVisible = MNG_FALSE;
+                         break;
+                       }
+              case 2 : {
+                         if (pImage->bVisible)
+                           mng_display_image (pData, pImage, MNG_FALSE);
+                         break;
+                       }
+              case 3 : {
+                         pImage->bVisible = MNG_TRUE;
+                         break;
+                       }
+              case 4 : {
+                         pImage->bVisible = (mng_bool)(!pImage->bVisible);
+                         if (pImage->bVisible)
+                           mng_display_image (pData, pImage, MNG_FALSE);
+                         break;
+                       }
+              case 5 : {
+                         pImage->bVisible = (mng_bool)(!pImage->bVisible);
+                       }
+            }
+          }
+        }
+
+        if (!pData->bTimerset)         /* next ? */
+          iX += iS;
+
+      }                                /* continue ? */
+      while ((!pData->bTimerset) && (((iS > 0) && (iX <= iTo)) ||
+                                     ((iS < 0) && (iX >= iTo))    ));
+
+      if (pData->bTimerset)            /* timer set ? */
+      {
+        pData->iBreakpoint = 4;
+        pData->iSHOWnextid = iX;       /* save for next time */
+      }
+      else
+        pData->iBreakpoint = 0;
+        
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_process_display_save (mng_datap pData)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_SAVE, MNG_LC_START);
+#endif
+
+  iRetcode = save_state (pData);       /* save the current state */
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode mng_process_display_seek (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_SEEK, MNG_LC_START);
+#endif
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+  if (pData->bStopafterseek)           /* need to stop after this SEEK ? */
+  {
+    pData->bFreezing      = MNG_TRUE;  /* stop processing on this one */
+    pData->bRunningevent  = MNG_FALSE;
+    pData->bStopafterseek = MNG_FALSE;
+    pData->bNeedrefresh   = MNG_TRUE;  /* make sure the last bit is displayed ! */
+  }
+  else
+#endif
+  {                                    /* restore the initial or SAVE state */
+    mng_retcode iRetcode = restore_state (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+                                       /* stop after next SEEK ? */
+    if ((pData->bDynamic) || (pData->bRunningevent))
+      pData->bStopafterseek = MNG_TRUE;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_process_display_jhdr (mng_datap pData)
+{                                      /* address the current "object" if any */
+  mng_imagep  pImage   = (mng_imagep)pData->pCurrentobj;
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_JHDR, MNG_LC_START);
+#endif
+
+  if (!pData->bHasDHDR)
+  {
+    pData->fInitrowproc  = MNG_NULL;   /* do nothing by default */
+    pData->fDisplayrow   = MNG_NULL;
+    pData->fCorrectrow   = MNG_NULL;
+    pData->fStorerow     = MNG_NULL;
+    pData->fProcessrow   = MNG_NULL;
+    pData->fDifferrow    = MNG_NULL;
+    pData->fStorerow2    = MNG_NULL;
+    pData->fStorerow3    = MNG_NULL;
+
+    pData->pStoreobj     = MNG_NULL;   /* initialize important work-parms */
+
+    pData->iJPEGrow      = 0;
+    pData->iJPEGalpharow = 0;
+    pData->iJPEGrgbrow   = 0;
+    pData->iRowmax       = 0;          /* so init_rowproc does the right thing ! */
+  }
+
+  if (!pData->iBreakpoint)             /* not previously broken ? */
+  {
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* delta-image ? */
+    {
+      if (pData->iDeltatype == MNG_DELTATYPE_REPLACE)
+      {
+        iRetcode = mng_reset_object_details (pData, (mng_imagep)pData->pDeltaImage,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iJHDRimgbitdepth, pData->iJHDRcolortype,
+                                             pData->iJHDRalphacompression, pData->iJHDRalphafilter,
+                                             pData->iJHDRalphainterlace, MNG_TRUE);
+
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iAlphabitdepth    = pData->iJHDRalphabitdepth;
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iJHDRcompression  = pData->iJHDRimgcompression;
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iJHDRinterlace    = pData->iJHDRimginterlace;
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iAlphasampledepth = pData->iJHDRalphabitdepth;
+      }
+      else
+      if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+          (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+      {
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iPixelsampledepth = pData->iJHDRimgbitdepth;
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iAlphasampledepth = pData->iJHDRalphabitdepth;
+      }
+      else
+      if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD    ) ||
+          (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)    )
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iAlphasampledepth = pData->iJHDRalphabitdepth;
+      else
+      if ((pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD    ) ||
+          (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)    )
+        ((mng_imagep)pData->pDeltaImage)->pImgbuf->iPixelsampledepth = pData->iJHDRimgbitdepth;
+        
+    }
+    else
+#endif /* MNG_NO_DELTA_PNG */
+    {
+      if (pImage)                      /* update object buffer ? */
+      {
+        iRetcode = mng_reset_object_details (pData, pImage,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iJHDRimgbitdepth, pData->iJHDRcolortype,
+                                             pData->iJHDRalphacompression, pData->iJHDRalphafilter,
+                                             pData->iJHDRalphainterlace, MNG_TRUE);
+
+        pImage->pImgbuf->iAlphabitdepth    = pData->iJHDRalphabitdepth;
+        pImage->pImgbuf->iJHDRcompression  = pData->iJHDRimgcompression;
+        pImage->pImgbuf->iJHDRinterlace    = pData->iJHDRimginterlace;
+        pImage->pImgbuf->iAlphasampledepth = pData->iJHDRalphabitdepth;
+      }
+      else                             /* update object 0 */
+      {
+        iRetcode = mng_reset_object_details (pData, (mng_imagep)pData->pObjzero,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iJHDRimgbitdepth, pData->iJHDRcolortype,
+                                             pData->iJHDRalphacompression, pData->iJHDRalphafilter,
+                                             pData->iJHDRalphainterlace, MNG_TRUE);
+
+        ((mng_imagep)pData->pObjzero)->pImgbuf->iAlphabitdepth    = pData->iJHDRalphabitdepth;
+        ((mng_imagep)pData->pObjzero)->pImgbuf->iJHDRcompression  = pData->iJHDRimgcompression;
+        ((mng_imagep)pData->pObjzero)->pImgbuf->iJHDRinterlace    = pData->iJHDRimginterlace;
+        ((mng_imagep)pData->pObjzero)->pImgbuf->iAlphasampledepth = pData->iJHDRalphabitdepth;
+      }
+    }
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+  if (!pData->bHasDHDR)
+  {                                    /* we're always storing a JPEG */
+    if (pImage)                        /* real object ? */
+      pData->pStoreobj = pImage;       /* tell the row routines */
+    else                               /* otherwise use object 0 */
+      pData->pStoreobj = pData->pObjzero;
+                                       /* display "on-the-fly" ? */
+    if (
+#ifndef MNG_SKIPCHUNK_MAGN
+         ( ((mng_imagep)pData->pStoreobj)->iMAGN_MethodX == 0) &&
+         ( ((mng_imagep)pData->pStoreobj)->iMAGN_MethodY == 0) &&
+#endif
+         ( (pData->eImagetype == mng_it_jng         ) ||
+           (((mng_imagep)pData->pStoreobj)->bVisible)    )       )
+    {
+      next_layer (pData);              /* that's a new layer then ! */
+
+      pData->iBreakpoint = 0;
+
+      if (pData->bTimerset)            /* timer break ? */
+        pData->iBreakpoint = 7;
+      else
+      if (pData->bRunning)             /* still running ? */
+      {                                /* anything to display ? */
+        if ((pData->iDestr > pData->iDestl) && (pData->iDestb > pData->iDestt))
+        {
+          set_display_routine (pData); /* then determine display routine */
+                                       /* display from the object we store in */
+          pData->pRetrieveobj = pData->pStoreobj;
+        }
+      }
+    }
+  }
+
+  if (!pData->bTimerset)               /* no timer break ? */
+  {                                    /* default row initialization ! */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+    pData->ePng_imgtype=png_none;
+#endif
+    pData->fInitrowproc = (mng_fptr)mng_init_rowproc;
+
+    if ((!pData->bHasDHDR) || (pData->iDeltatype == MNG_DELTATYPE_REPLACE))
+    {                                  /* 8-bit JPEG ? */
+      if (pData->iJHDRimgbitdepth == 8)
+      {                                /* intermediate row is 8-bit deep */
+        pData->bIsRGBA16   = MNG_FALSE;
+        pData->iRowsamples = pData->iDatawidth;
+
+        switch (pData->iJHDRcolortype) /* determine pixel processing routines */
+        {
+          case MNG_COLORTYPE_JPEGGRAY :
+               {
+                 pData->fStorerow2   = (mng_fptr)mng_store_jpeg_g8;
+                 pData->fRetrieverow = (mng_fptr)mng_retrieve_g8;
+                 pData->bIsOpaque    = MNG_TRUE;
+                 break;
+               }
+          case MNG_COLORTYPE_JPEGCOLOR :
+               {
+                 pData->fStorerow2   = (mng_fptr)mng_store_jpeg_rgb8;
+                 pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb8;
+                 pData->bIsOpaque    = MNG_TRUE;
+                 break;
+               }
+          case MNG_COLORTYPE_JPEGGRAYA :
+               {
+                 pData->fStorerow2   = (mng_fptr)mng_store_jpeg_ga8;
+                 pData->fRetrieverow = (mng_fptr)mng_retrieve_ga8;
+                 pData->bIsOpaque    = MNG_FALSE;
+                 break;
+               }
+          case MNG_COLORTYPE_JPEGCOLORA :
+               {
+                 pData->fStorerow2   = (mng_fptr)mng_store_jpeg_rgba8;
+                 pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+                 pData->bIsOpaque    = MNG_FALSE;
+                 break;
+               }
+        }
+      }
+#ifndef MNG_NO_16BIT_SUPPORT
+      else
+      {
+        pData->bIsRGBA16 = MNG_TRUE;   /* intermediate row is 16-bit deep */
+
+        /* TODO: 12-bit JPEG */
+        /* TODO: 8- + 12-bit JPEG (eg. type=20) */
+
+      }
+#endif
+                                       /* possible IDAT alpha-channel ? */
+      if (pData->iJHDRalphacompression == MNG_COMPRESSION_DEFLATE)
+      {
+                                       /* determine alpha processing routine */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+        pData->fInitrowproc = (mng_fptr)mng_init_rowproc;
+#endif
+        switch (pData->iJHDRalphabitdepth)
+        {
+#ifndef MNG_OPTIMIZE_FOOTPRINT_INIT
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+          case  1 : { pData->fInitrowproc = (mng_fptr)mng_init_jpeg_a1_ni;  break; }
+          case  2 : { pData->fInitrowproc = (mng_fptr)mng_init_jpeg_a2_ni;  break; }
+          case  4 : { pData->fInitrowproc = (mng_fptr)mng_init_jpeg_a4_ni;  break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+          case  8 : { pData->fInitrowproc = (mng_fptr)mng_init_jpeg_a8_ni;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+          case 16 : { pData->fInitrowproc = (mng_fptr)mng_init_jpeg_a16_ni; break; }
+#endif
+#else
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+          case  1 : { pData->ePng_imgtype = png_jpeg_a1;  break; }
+          case  2 : { pData->ePng_imgtype = png_jpeg_a2;  break; }
+          case  4 : { pData->ePng_imgtype = png_jpeg_a4;  break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+          case  8 : { pData->ePng_imgtype = png_jpeg_a8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+          case 16 : { pData->ePng_imgtype = png_jpeg_a16; break; }
+#endif
+#endif
+        }
+      }
+      else                             /* possible JDAA alpha-channel ? */
+      if (pData->iJHDRalphacompression == MNG_COMPRESSION_BASELINEJPEG)
+      {                                /* 8-bit JPEG ? */
+        if (pData->iJHDRimgbitdepth == 8)
+        {
+          if (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA)
+            pData->fStorerow3 = (mng_fptr)mng_store_jpeg_g8_alpha;
+          else
+          if (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)
+            pData->fStorerow3 = (mng_fptr)mng_store_jpeg_rgb8_alpha;
+        }
+        else
+        {
+          /* TODO: 12-bit JPEG with 8-bit JDAA */
+        }
+      }
+                                       /* initialize JPEG library */
+      iRetcode = mngjpeg_initialize (pData);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+    else
+    {                                  /* must be alpha add/replace !! */
+      if ((pData->iDeltatype != MNG_DELTATYPE_BLOCKALPHAADD    ) &&
+          (pData->iDeltatype != MNG_DELTATYPE_BLOCKALPHAREPLACE)    )
+        MNG_ERROR (pData, MNG_INVDELTATYPE);
+                                       /* determine alpha processing routine */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+        pData->fInitrowproc = (mng_fptr)mng_init_rowproc;
+#endif
+      switch (pData->iJHDRalphabitdepth)
+      {
+#ifndef MNG_OPTIMIZE_FOOTPRINT_INIT
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        case  1 : { pData->fInitrowproc = (mng_fptr)mng_init_g1_ni;  break; }
+        case  2 : { pData->fInitrowproc = (mng_fptr)mng_init_g2_ni;  break; }
+        case  4 : { pData->fInitrowproc = (mng_fptr)mng_init_g4_ni;  break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+        case  8 : { pData->fInitrowproc = (mng_fptr)mng_init_g8_ni;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+        case 16 : { pData->fInitrowproc = (mng_fptr)mng_init_g16_ni; break; }
+#endif
+#else
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        case  1 : { pData->ePng_imgtype = png_jpeg_a1;  break; }
+        case  2 : { pData->ePng_imgtype = png_jpeg_a2;  break; }
+        case  4 : { pData->ePng_imgtype = png_jpeg_a4;  break; }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+        case  8 : { pData->ePng_imgtype = png_jpeg_a8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+        case 16 : { pData->ePng_imgtype = png_jpeg_a16; break; }
+#endif
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+      }
+    }
+
+    pData->iFilterofs = 0;             /* determine filter characteristics */
+    pData->iLevel0    = 0;             /* default levels */
+    pData->iLevel1    = 0;    
+    pData->iLevel2    = 0;
+    pData->iLevel3    = 0;
+
+#ifdef FILTER192                       /* leveling & differing ? */
+    if (pData->iJHDRalphafilter == 0xC0)
+    {
+       if (pData->iJHDRalphabitdepth <= 8)
+         pData->iFilterofs = 1;
+       else
+         pData->iFilterofs = 2;
+
+    }
+#endif
+#ifdef FILTER193                       /* no adaptive filtering ? */
+    if (pData->iJHDRalphafilter == 0xC1)
+      pData->iPixelofs = pData->iFilterofs;
+    else
+#endif
+      pData->iPixelofs = pData->iFilterofs + 1;
+
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_JHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_jdaa (mng_datap  pData,
+                                      mng_uint32 iRawlen,
+                                      mng_uint8p pRawdata)
+#else
+mng_retcode mng_process_display_jdaa (mng_datap  pData)
+#endif
+{
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_JDAA, MNG_LC_START);
+#endif
+
+  if (!pData->bJPEGdecompress2)        /* if we're not decompressing already */
+  {
+    if (pData->fInitrowproc)           /* initialize row-processing? */
+    {
+      iRetcode = ((mng_initrowproc)pData->fInitrowproc) (pData);
+      pData->fInitrowproc = MNG_NULL;  /* only call this once !!! */
+    }
+
+    if (!iRetcode)                     /* initialize decompress */
+      iRetcode = mngjpeg_decompressinit2 (pData);
+  }
+
+  if (!iRetcode)                       /* all ok? then decompress, my man */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    iRetcode = mngjpeg_decompressdata2 (pData, iRawlen, pRawdata);
+#else
+    iRetcode = mngjpeg_decompressdata2 (pData, pData->iRawlen, pData->pRawdata);
+#endif
+
+  if (iRetcode)
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_JDAA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_jdat (mng_datap  pData,
+                                      mng_uint32 iRawlen,
+                                      mng_uint8p pRawdata)
+#else
+mng_retcode mng_process_display_jdat (mng_datap  pData)
+#endif
+{
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_JDAT, MNG_LC_START);
+#endif
+
+  if (pData->bRestorebkgd)             /* need to restore the background ? */
+  {
+    pData->bRestorebkgd = MNG_FALSE;
+    iRetcode            = load_bkgdlayer (pData);
+
+    pData->iLayerseq++;                /* and it counts as a layer then ! */
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+  if (!pData->bJPEGdecompress)         /* if we're not decompressing already */
+  {
+    if (pData->fInitrowproc)           /* initialize row-processing? */
+    {
+      iRetcode = ((mng_initrowproc)pData->fInitrowproc) (pData);
+      pData->fInitrowproc = MNG_NULL;  /* only call this once !!! */
+    }
+
+    if (!iRetcode)                     /* initialize decompress */
+      iRetcode = mngjpeg_decompressinit (pData);
+  }
+
+  if (!iRetcode)                       /* all ok? then decompress, my man */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    iRetcode = mngjpeg_decompressdata (pData, iRawlen, pRawdata);
+#else
+    iRetcode = mngjpeg_decompressdata (pData, pData->iRawlen, pData->pRawdata);
+#endif
+
+  if (iRetcode)
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_JDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_dhdr (mng_datap  pData,
+                                      mng_uint16 iObjectid,
+                                      mng_uint8  iImagetype,
+                                      mng_uint8  iDeltatype,
+                                      mng_uint32 iBlockwidth,
+                                      mng_uint32 iBlockheight,
+                                      mng_uint32 iBlockx,
+                                      mng_uint32 iBlocky)
+#else
+mng_retcode mng_process_display_dhdr (mng_datap  pData)
+#endif
+{
+  mng_imagep  pImage;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_DHDR, MNG_LC_START);
+#endif
+
+  pData->fInitrowproc     = MNG_NULL;  /* do nothing by default */
+  pData->fDisplayrow      = MNG_NULL;
+  pData->fCorrectrow      = MNG_NULL;
+  pData->fStorerow        = MNG_NULL;
+  pData->fProcessrow      = MNG_NULL;
+  pData->pStoreobj        = MNG_NULL;
+
+  pData->fDeltagetrow     = MNG_NULL;
+  pData->fDeltaaddrow     = MNG_NULL;
+  pData->fDeltareplacerow = MNG_NULL;
+  pData->fDeltaputrow     = MNG_NULL;
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  pImage = mng_find_imageobject (pData, iObjectid);
+#else
+  pImage = mng_find_imageobject (pData, pData->iDHDRobjectid);
+#endif
+
+  if (pImage)                          /* object exists ? */
+  {
+    if (pImage->pImgbuf->bConcrete)    /* is it concrete ? */
+    {                                  /* previous magnification to be done ? */
+#ifndef MNG_SKIPCHUNK_MAGN
+      if ((pImage->iMAGN_MethodX) || (pImage->iMAGN_MethodY))
+      {
+        iRetcode = mng_magnify_imageobject (pData, pImage);
+                       
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+      }
+#endif
+                                       /* save delta fields */
+      pData->pDeltaImage           = (mng_ptr)pImage;
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      pData->iDeltaImagetype       = iImagetype;
+      pData->iDeltatype            = iDeltatype;
+      pData->iDeltaBlockwidth      = iBlockwidth;
+      pData->iDeltaBlockheight     = iBlockheight;
+      pData->iDeltaBlockx          = iBlockx;
+      pData->iDeltaBlocky          = iBlocky;
+#else
+      pData->iDeltaImagetype       = pData->iDHDRimagetype;
+      pData->iDeltatype            = pData->iDHDRdeltatype;
+      pData->iDeltaBlockwidth      = pData->iDHDRblockwidth;
+      pData->iDeltaBlockheight     = pData->iDHDRblockheight;
+      pData->iDeltaBlockx          = pData->iDHDRblockx;
+      pData->iDeltaBlocky          = pData->iDHDRblocky;
+#endif
+                                       /* restore target-object fields */
+      pData->iDatawidth            = pImage->pImgbuf->iWidth;
+      pData->iDataheight           = pImage->pImgbuf->iHeight;
+      pData->iBitdepth             = pImage->pImgbuf->iBitdepth;
+      pData->iColortype            = pImage->pImgbuf->iColortype;
+      pData->iCompression          = pImage->pImgbuf->iCompression;
+      pData->iFilter               = pImage->pImgbuf->iFilter;
+      pData->iInterlace            = pImage->pImgbuf->iInterlace;
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      if ((iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+          (iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+        pData->iBitdepth           = pImage->pImgbuf->iPixelsampledepth;
+      else
+      if ((iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD    ) ||
+          (iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)    )
+        pData->iBitdepth           = pImage->pImgbuf->iAlphasampledepth;
+      else
+      if ((iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD    ) ||
+          (iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)    )
+        pData->iBitdepth           = pImage->pImgbuf->iPixelsampledepth;
+#else
+      if ((pData->iDHDRdeltatype == MNG_DELTATYPE_BLOCKPIXELADD    ) ||
+          (pData->iDHDRdeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+        pData->iBitdepth           = pImage->pImgbuf->iPixelsampledepth;
+      else
+      if ((pData->iDHDRdeltatype == MNG_DELTATYPE_BLOCKALPHAADD    ) ||
+          (pData->iDHDRdeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)    )
+        pData->iBitdepth           = pImage->pImgbuf->iAlphasampledepth;
+      else
+      if ((pData->iDHDRdeltatype == MNG_DELTATYPE_BLOCKCOLORADD    ) ||
+          (pData->iDHDRdeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)    )
+        pData->iBitdepth           = pImage->pImgbuf->iPixelsampledepth;
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+      pData->iJHDRimgbitdepth      = pImage->pImgbuf->iBitdepth;
+      pData->iJHDRcolortype        = pImage->pImgbuf->iColortype;
+      pData->iJHDRimgcompression   = pImage->pImgbuf->iJHDRcompression;
+      pData->iJHDRimginterlace     = pImage->pImgbuf->iJHDRinterlace;
+      pData->iJHDRalphacompression = pImage->pImgbuf->iCompression;
+      pData->iJHDRalphafilter      = pImage->pImgbuf->iFilter;
+      pData->iJHDRalphainterlace   = pImage->pImgbuf->iInterlace;
+      pData->iJHDRalphabitdepth    = pImage->pImgbuf->iAlphabitdepth;
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                                       /* block size specified ? */
+      if (iDeltatype != MNG_DELTATYPE_NOCHANGE)
+      {                                /* block entirely within target ? */
+        if (iDeltatype != MNG_DELTATYPE_REPLACE)
+        {
+          if (((iBlockx + iBlockwidth ) > pData->iDatawidth ) ||
+              ((iBlocky + iBlockheight) > pData->iDataheight)    )
+            MNG_ERROR (pData, MNG_INVALIDBLOCK);
+        }
+
+        pData->iDatawidth          = iBlockwidth;
+        pData->iDataheight         = iBlockheight;
+      }
+#else
+                                       /* block size specified ? */
+      if (pData->iDHDRdeltatype != MNG_DELTATYPE_NOCHANGE)
+      {                                /* block entirely within target ? */
+        if (pData->iDHDRdeltatype != MNG_DELTATYPE_REPLACE)
+        {
+          if (((pData->iDHDRblockx + pData->iDHDRblockwidth ) > pData->iDatawidth ) ||
+              ((pData->iDHDRblocky + pData->iDHDRblockheight) > pData->iDataheight)    )
+            MNG_ERROR (pData, MNG_INVALIDBLOCK);
+        }
+
+        pData->iDatawidth          = pData->iDHDRblockwidth;
+        pData->iDataheight         = pData->iDHDRblockheight;
+      }
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      switch (iDeltatype)              /* determine nr of delta-channels */
+#else
+      switch (pData->iDHDRdeltatype)   /* determine nr of delta-channels */
+#endif
+      {
+         case MNG_DELTATYPE_BLOCKALPHAADD : ;
+         case MNG_DELTATYPE_BLOCKALPHAREPLACE :
+              {
+#ifdef MNG_INCLUDE_JNG
+                if ((pData->iColortype     == MNG_COLORTYPE_GRAYA    ) ||
+                    (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA)    )
+                {
+                  pData->iColortype     = MNG_COLORTYPE_GRAY;
+                  pData->iJHDRcolortype = MNG_COLORTYPE_JPEGGRAY;
+                }
+                else
+                if ((pData->iColortype     == MNG_COLORTYPE_RGBA      ) ||
+                    (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )
+                {
+                  pData->iColortype     = MNG_COLORTYPE_GRAY;
+                  pData->iJHDRcolortype = MNG_COLORTYPE_JPEGGRAY;
+                }
+#else
+                if (pData->iColortype      == MNG_COLORTYPE_GRAYA)
+                  pData->iColortype     = MNG_COLORTYPE_GRAY;
+                else
+                if (pData->iColortype      == MNG_COLORTYPE_RGBA)
+                  pData->iColortype     = MNG_COLORTYPE_GRAY;
+#endif
+                else                   /* target has no alpha; that sucks! */
+                  MNG_ERROR (pData, MNG_TARGETNOALPHA);
+
+                break;
+              }
+
+         case MNG_DELTATYPE_BLOCKCOLORADD : ;
+         case MNG_DELTATYPE_BLOCKCOLORREPLACE :
+              {
+#ifdef MNG_INCLUDE_JNG
+                if ((pData->iColortype     == MNG_COLORTYPE_GRAYA    ) ||
+                    (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA)    )
+                {
+                  pData->iColortype     = MNG_COLORTYPE_GRAY;
+                  pData->iJHDRcolortype = MNG_COLORTYPE_JPEGGRAY;
+                }
+                else
+                if ((pData->iColortype     == MNG_COLORTYPE_RGBA      ) ||
+                    (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )
+                {
+                  pData->iColortype     = MNG_COLORTYPE_RGB;
+                  pData->iJHDRcolortype = MNG_COLORTYPE_JPEGCOLOR;
+                }
+#else
+                if (pData->iColortype == MNG_COLORTYPE_GRAYA)
+                  pData->iColortype = MNG_COLORTYPE_GRAY;
+                else
+                if (pData->iColortype == MNG_COLORTYPE_RGBA)
+                  pData->iColortype = MNG_COLORTYPE_RGB;
+#endif                  
+                else                   /* target has no alpha; that sucks! */
+                  MNG_ERROR (pData, MNG_TARGETNOALPHA);
+
+                break;
+              }
+
+      }
+                                       /* full image replace ? */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      if (iDeltatype == MNG_DELTATYPE_REPLACE)
+#else
+      if (pData->iDHDRdeltatype == MNG_DELTATYPE_REPLACE)
+#endif
+      {
+        iRetcode = mng_reset_object_details (pData, pImage,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iBitdepth, pData->iColortype,
+                                             pData->iCompression, pData->iFilter,
+                                             pData->iInterlace, MNG_FALSE);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+
+        pData->pStoreobj = pImage;     /* and store straight into this object */
+      }
+      else
+      {
+        mng_imagedatap pBufzero, pBuf;
+                                       /* we store in object 0 and process it later */
+        pData->pStoreobj = pData->pObjzero;
+                                       /* make sure to initialize object 0 then */
+        iRetcode = mng_reset_object_details (pData, (mng_imagep)pData->pObjzero,
+                                             pData->iDatawidth, pData->iDataheight,
+                                             pData->iBitdepth, pData->iColortype,
+                                             pData->iCompression, pData->iFilter,
+                                             pData->iInterlace, MNG_TRUE);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+
+        pBuf     = pImage->pImgbuf;    /* copy possible palette & cheap transparency */
+        pBufzero = ((mng_imagep)pData->pObjzero)->pImgbuf;
+
+        pBufzero->bHasPLTE = pBuf->bHasPLTE;
+        pBufzero->bHasTRNS = pBuf->bHasTRNS;
+
+        if (pBufzero->bHasPLTE)        /* copy palette ? */
+        {
+          mng_uint32 iX;
+
+          pBufzero->iPLTEcount = pBuf->iPLTEcount;
+
+          for (iX = 0; iX < pBuf->iPLTEcount; iX++)
+          {
+            pBufzero->aPLTEentries [iX].iRed   = pBuf->aPLTEentries [iX].iRed;
+            pBufzero->aPLTEentries [iX].iGreen = pBuf->aPLTEentries [iX].iGreen;
+            pBufzero->aPLTEentries [iX].iBlue  = pBuf->aPLTEentries [iX].iBlue;
+          }
+        }
+
+        if (pBufzero->bHasTRNS)        /* copy cheap transparency ? */
+        {
+          pBufzero->iTRNSgray  = pBuf->iTRNSgray;
+          pBufzero->iTRNSred   = pBuf->iTRNSred;
+          pBufzero->iTRNSgreen = pBuf->iTRNSgreen;
+          pBufzero->iTRNSblue  = pBuf->iTRNSblue;
+          pBufzero->iTRNScount = pBuf->iTRNScount;
+
+          MNG_COPY (pBufzero->aTRNSentries, pBuf->aTRNSentries,
+                    sizeof (pBufzero->aTRNSentries));
+        }
+                                       /* process immediately if bitdepth & colortype are equal */
+        pData->bDeltaimmediate =
+          (mng_bool)((pData->bDisplaying) && (!pData->bSkipping) &&
+                     ((pData->bRunning) || (pData->bSearching)) &&
+                     (pData->iBitdepth  == ((mng_imagep)pData->pDeltaImage)->pImgbuf->iBitdepth ) &&
+                     (pData->iColortype == ((mng_imagep)pData->pDeltaImage)->pImgbuf->iColortype)    );
+      }
+ 
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+  pData->fInitrowproc = (mng_fptr)mng_init_rowproc;
+  pData->ePng_imgtype = mng_png_imgtype (pData->iColortype, pData->iBitdepth);
+#else
+      switch (pData->iColortype)       /* determine row initialization routine */
+      {
+        case 0 : {                     /* gray */
+                   switch (pData->iBitdepth)
+                   {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                     case  1 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g1_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g1_i;
+
+                                 break;
+                               }
+                     case  2 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g2_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g2_i;
+
+                                 break;
+                               }
+                     case  4 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g4_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g4_i;
+
+                                 break;
+                               }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                     case  8 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g8_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g8_i;
+
+                                 break;
+                               }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g16_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_g16_i;
+
+                                 break;
+                               }
+#endif
+                   }
+
+                   break;
+                 }
+        case 2 : {                     /* rgb */
+                   switch (pData->iBitdepth)
+                   {
+                     case  8 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgb8_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgb8_i;
+
+                                 break;
+                               }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgb16_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgb16_i;
+
+                                 break;
+                               }
+#endif
+                   }
+
+                   break;
+                 }
+        case 3 : {                     /* indexed */
+                   switch (pData->iBitdepth)
+                   {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                     case  1 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx1_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx1_i;
+
+                                 break;
+                               }
+                     case  2 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx2_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx2_i;
+
+                                 break;
+                               }
+                     case  4 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx4_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx4_i;
+
+                                 break;
+                               }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+                     case  8 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx8_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_idx8_i;
+
+                                 break;
+                               }
+                   }
+
+                   break;
+                 }
+        case 4 : {                     /* gray+alpha */
+                   switch (pData->iBitdepth)
+                   {
+                     case  8 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_ga8_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_ga8_i;
+
+                                 break;
+                               }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_ga16_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_ga16_i;
+
+                                 break;
+                               }
+#endif
+                   }
+
+                   break;
+                 }
+        case 6 : {                     /* rgb+alpha */
+                   switch (pData->iBitdepth)
+                   {
+                     case  8 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgba8_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgba8_i;
+
+                                 break;
+                               }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : {
+                                 if (!pData->iInterlace)
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgba16_ni;
+                                 else
+                                   pData->fInitrowproc = (mng_fptr)mng_init_rgba16_i;
+
+                                 break;
+                               }
+#endif
+                   }
+
+                   break;
+                 }
+      }
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+    }
+    else
+      MNG_ERROR (pData, MNG_OBJNOTCONCRETE);
+
+  }
+  else
+    MNG_ERROR (pData, MNG_OBJECTUNKNOWN);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_prom (mng_datap  pData,
+                                      mng_uint8  iBitdepth,
+                                      mng_uint8  iColortype,
+                                      mng_uint8  iFilltype)
+#else
+mng_retcode mng_process_display_prom (mng_datap  pData)
+#endif
+{
+  mng_imagep     pImage;
+  mng_imagedatap pBuf;
+  mng_retcode    iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PROM, MNG_LC_START);
+#endif
+
+  if (!pData->pDeltaImage)             /* gotta have this now! */
+    MNG_ERROR (pData, MNG_INVALIDDELTA);
+
+  pImage = (mng_imagep)pData->pDeltaImage;
+  pBuf   = pImage->pImgbuf;
+                                       /* can't demote bitdepth! */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  if (iBitdepth < pBuf->iBitdepth)
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if ( ((pBuf->iColortype == MNG_COLORTYPE_GRAY      ) &&
+        (iColortype       != MNG_COLORTYPE_GRAY      ) &&
+        (iColortype       != MNG_COLORTYPE_GRAYA     ) &&
+        (iColortype       != MNG_COLORTYPE_RGB       ) &&
+        (iColortype       != MNG_COLORTYPE_RGBA      )    ) ||
+       ((pBuf->iColortype == MNG_COLORTYPE_GRAYA     ) &&
+        (iColortype       != MNG_COLORTYPE_GRAYA     ) &&
+        (iColortype       != MNG_COLORTYPE_RGBA      )    ) ||
+       ((pBuf->iColortype == MNG_COLORTYPE_RGB       ) &&
+        (iColortype       != MNG_COLORTYPE_RGB       ) &&
+        (iColortype       != MNG_COLORTYPE_RGBA      )    ) ||
+       ((pBuf->iColortype == MNG_COLORTYPE_RGBA      ) &&
+        (iColortype       != MNG_COLORTYPE_RGBA      )    ) ||
+#ifdef MNG_INCLUDE_JNG
+       ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAY  ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGGRAY  ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGCOLOR ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGGRAYA ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+       ((pBuf->iColortype == MNG_COLORTYPE_JPEGCOLOR ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGCOLOR ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+       ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAYA ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGGRAYA ) &&
+        (iColortype       != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+       ((pBuf->iColortype == MNG_COLORTYPE_JPEGCOLORA) &&
+        (iColortype       != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+#endif
+       ((pBuf->iColortype == MNG_COLORTYPE_INDEXED   ) &&
+        (iColortype       != MNG_COLORTYPE_INDEXED   ) &&
+        (iColortype       != MNG_COLORTYPE_RGB       ) &&
+        (iColortype       != MNG_COLORTYPE_RGBA      )    )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  iRetcode = mng_promote_imageobject (pData, pImage, iBitdepth, iColortype, iFilltype);
+#else
+  if (pData->iPROMbitdepth < pBuf->iBitdepth)
+    MNG_ERROR (pData, MNG_INVALIDBITDEPTH);
+
+  if ( ((pBuf->iColortype      == MNG_COLORTYPE_GRAY      ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_GRAY      ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_GRAYA     ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGB       ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGBA      )    ) ||
+       ((pBuf->iColortype      == MNG_COLORTYPE_GRAYA     ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_GRAYA     ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGBA      )    ) ||
+       ((pBuf->iColortype      == MNG_COLORTYPE_RGB       ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGB       ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGBA      )    ) ||
+       ((pBuf->iColortype      == MNG_COLORTYPE_RGBA      ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGBA      )    ) ||
+#ifdef MNG_INCLUDE_JNG
+       ((pBuf->iColortype      == MNG_COLORTYPE_JPEGGRAY  ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGGRAY  ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGCOLOR ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGGRAYA ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+       ((pBuf->iColortype      == MNG_COLORTYPE_JPEGCOLOR ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGCOLOR ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+       ((pBuf->iColortype      == MNG_COLORTYPE_JPEGGRAYA ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGGRAYA ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+       ((pBuf->iColortype      == MNG_COLORTYPE_JPEGCOLORA) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_JPEGCOLORA)    ) ||
+#endif
+       ((pBuf->iColortype      == MNG_COLORTYPE_INDEXED   ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_INDEXED   ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGB       ) &&
+        (pData->iPROMcolortype != MNG_COLORTYPE_RGBA      )    )    )
+    MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+  iRetcode = mng_promote_imageobject (pData, pImage, pData->iPROMbitdepth,
+                                      pData->iPROMcolortype, pData->iPROMfilltype);
+#endif
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_process_display_ipng (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IPNG, MNG_LC_START);
+#endif
+                                       /* indicate it for what it is now */
+  pData->iDeltaImagetype = MNG_IMAGETYPE_PNG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_process_display_ijng (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IJNG, MNG_LC_START);
+#endif
+                                       /* indicate it for what it is now */
+  pData->iDeltaImagetype = MNG_IMAGETYPE_JNG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_pplt (mng_datap      pData,
+                                      mng_uint8      iType,
+                                      mng_uint32     iCount,
+                                      mng_palette8ep paIndexentries,
+                                      mng_uint8p     paAlphaentries,
+                                      mng_uint8p     paUsedentries)
+#else
+mng_retcode mng_process_display_pplt (mng_datap      pData)
+#endif
+{
+  mng_uint32     iX;
+  mng_imagep     pImage = (mng_imagep)pData->pObjzero;
+  mng_imagedatap pBuf   = pImage->pImgbuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PPLT, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iX = iCount;
+#else
+  iX = pData->iPPLTcount;
+#endif
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  switch (iType)
+#else
+  switch (pData->iPPLTtype)
+#endif
+  {
+    case MNG_DELTATYPE_REPLACERGB :
+      {
+#ifdef MNG_DECREMENT_LOOPS
+        for (; iX > 0;iX--)
+#else
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+        for (iX = 0; iX < iCount; iX++)
+#else
+        for (iX = 0; iX < pData->iPPLTcount; iX++)
+#endif
+#endif
+        {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+          if (paUsedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   = paIndexentries [iX].iRed;
+            pBuf->aPLTEentries [iX].iGreen = paIndexentries [iX].iGreen;
+            pBuf->aPLTEentries [iX].iBlue  = paIndexentries [iX].iBlue;
+          }
+#else
+          if (pData->paPPLTusedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   = pData->paPPLTindexentries [iX].iRed;
+            pBuf->aPLTEentries [iX].iGreen = pData->paPPLTindexentries [iX].iGreen;
+            pBuf->aPLTEentries [iX].iBlue  = pData->paPPLTindexentries [iX].iBlue;
+          }
+#endif
+        }
+
+        break;
+      }
+    case MNG_DELTATYPE_DELTARGB :
+      {
+#ifdef MNG_DECREMENT_LOOPS
+        for (; iX > 0;iX--)
+#else
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+        for (iX = 0; iX < iCount; iX++)
+#else
+        for (iX = 0; iX < pData->iPPLTcount; iX++)
+#endif
+#endif
+        {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+          if (paUsedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iRed   +
+                                           paIndexentries [iX].iRed  );
+            pBuf->aPLTEentries [iX].iGreen =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iGreen +
+                                           paIndexentries [iX].iGreen);
+            pBuf->aPLTEentries [iX].iBlue  =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iBlue  +
+                                           paIndexentries [iX].iBlue );
+          }
+#else
+          if (pData->paPPLTusedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iRed   +
+                                           pData->paPPLTindexentries [iX].iRed  );
+            pBuf->aPLTEentries [iX].iGreen =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iGreen +
+                                           pData->paPPLTindexentries [iX].iGreen);
+            pBuf->aPLTEentries [iX].iBlue  =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iBlue  +
+                                           pData->paPPLTindexentries [iX].iBlue );
+          }
+#endif
+        }
+
+        break;
+      }
+    case MNG_DELTATYPE_REPLACEALPHA :
+      {
+#ifdef MNG_DECREMENT_LOOPS
+        for (; iX > 0;iX--)
+#else
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+        for (iX = 0; iX < iCount; iX++)
+#else
+        for (iX = 0; iX < pData->iPPLTcount; iX++)
+#endif
+#endif
+        {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+          if (paUsedentries [iX])
+            pBuf->aTRNSentries [iX] = paAlphaentries [iX];
+        }
+#else
+          if (pData->paPPLTusedentries [iX])
+            pBuf->aTRNSentries [iX] = pData->paPPLTalphaentries [iX];
+        }
+#endif
+
+        break;
+      }
+    case MNG_DELTATYPE_DELTAALPHA :
+      {
+#ifdef MNG_DECREMENT_LOOPS
+        for (; iX > 0;iX--)
+#else
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+        for (iX = 0; iX < iCount; iX++)
+#else
+        for (iX = 0; iX < pData->iPPLTcount; iX++)
+#endif
+#endif
+        {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+          if (paUsedentries [iX])
+            pBuf->aTRNSentries [iX] =
+                               (mng_uint8)(pBuf->aTRNSentries [iX] +
+                                           paAlphaentries [iX]);
+#else
+          if (pData->paPPLTusedentries [iX])
+            pBuf->aTRNSentries [iX] =
+                               (mng_uint8)(pBuf->aTRNSentries [iX] +
+                                           pData->paPPLTalphaentries [iX]);
+#endif
+        }
+
+        break;
+      }
+    case MNG_DELTATYPE_REPLACERGBA :
+      {
+#ifdef MNG_DECREMENT_LOOPS
+        for (; iX > 0;iX--)
+#else
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+        for (iX = 0; iX < iCount; iX++)
+#else
+        for (iX = 0; iX < pData->iPPLTcount; iX++)
+#endif
+#endif
+        {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+          if (paUsedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   = paIndexentries [iX].iRed;
+            pBuf->aPLTEentries [iX].iGreen = paIndexentries [iX].iGreen;
+            pBuf->aPLTEentries [iX].iBlue  = paIndexentries [iX].iBlue;
+            pBuf->aTRNSentries [iX]        = paAlphaentries [iX];
+          }
+#else
+          if (pData->paPPLTusedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   = pData->paPPLTindexentries [iX].iRed;
+            pBuf->aPLTEentries [iX].iGreen = pData->paPPLTindexentries [iX].iGreen;
+            pBuf->aPLTEentries [iX].iBlue  = pData->paPPLTindexentries [iX].iBlue;
+            pBuf->aTRNSentries [iX]        = pData->paPPLTalphaentries [iX];
+          }
+#endif
+        }
+
+        break;
+      }
+    case MNG_DELTATYPE_DELTARGBA :
+      {
+#ifdef MNG_DECREMENT_LOOPS
+        for (; iX > 0;iX--)
+#else
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+        for (iX = 0; iX < iCount; iX++)
+#else
+        for (iX = 0; iX < pData->iPPLTcount; iX++)
+#endif
+#endif
+        {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+          if (paUsedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iRed   +
+                                           paIndexentries [iX].iRed  );
+            pBuf->aPLTEentries [iX].iGreen =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iGreen +
+                                           paIndexentries [iX].iGreen);
+            pBuf->aPLTEentries [iX].iBlue  =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iBlue  +
+                                           paIndexentries [iX].iBlue );
+            pBuf->aTRNSentries [iX] =
+                               (mng_uint8)(pBuf->aTRNSentries [iX] +
+                                           paAlphaentries [iX]);
+          }
+#else
+          if (pData->paPPLTusedentries [iX])
+          {
+            pBuf->aPLTEentries [iX].iRed   =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iRed   +
+                                           pData->paPPLTindexentries [iX].iRed  );
+            pBuf->aPLTEentries [iX].iGreen =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iGreen +
+                                           pData->paPPLTindexentries [iX].iGreen);
+            pBuf->aPLTEentries [iX].iBlue  =
+                               (mng_uint8)(pBuf->aPLTEentries [iX].iBlue  +
+                                           pData->paPPLTindexentries [iX].iBlue );
+            pBuf->aTRNSentries [iX] =
+                               (mng_uint8)(pBuf->aTRNSentries [iX] +
+                                           pData->paPPLTalphaentries [iX]);
+          }
+#endif
+        }
+
+        break;
+      }
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  if ((iType != MNG_DELTATYPE_REPLACERGB) && (iType != MNG_DELTATYPE_DELTARGB))
+#else
+  if ((pData->iPPLTtype != MNG_DELTATYPE_REPLACERGB) &&
+      (pData->iPPLTtype != MNG_DELTATYPE_DELTARGB  )    )
+#endif
+  {
+    if (pBuf->bHasTRNS)
+    {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      if (iCount > pBuf->iTRNScount)
+        pBuf->iTRNScount = iCount;
+#else
+      if (pData->iPPLTcount > pBuf->iTRNScount)
+        pBuf->iTRNScount = pData->iPPLTcount;
+#endif
+    }
+    else
+    {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      pBuf->iTRNScount = iCount;
+      pBuf->bHasTRNS   = MNG_TRUE;
+#else
+      pBuf->iTRNScount = pData->iPPLTcount;
+      pBuf->bHasTRNS   = MNG_TRUE;
+#endif
+    }
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  if ((iType != MNG_DELTATYPE_REPLACEALPHA) && (iType != MNG_DELTATYPE_DELTAALPHA))
+#else
+  if ((pData->iPPLTtype != MNG_DELTATYPE_REPLACEALPHA) &&
+      (pData->iPPLTtype != MNG_DELTATYPE_DELTAALPHA  )    )
+#endif
+  {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    if (iCount > pBuf->iPLTEcount)
+      pBuf->iPLTEcount = iCount;
+#else
+    if (pData->iPPLTcount > pBuf->iPLTEcount)
+      pBuf->iPLTEcount = pData->iPPLTcount;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_magn (mng_datap  pData,
+                                      mng_uint16 iFirstid,
+                                      mng_uint16 iLastid,
+                                      mng_uint8  iMethodX,
+                                      mng_uint16 iMX,
+                                      mng_uint16 iMY,
+                                      mng_uint16 iML,
+                                      mng_uint16 iMR,
+                                      mng_uint16 iMT,
+                                      mng_uint16 iMB,
+                                      mng_uint8  iMethodY)
+#else
+mng_retcode mng_process_display_magn (mng_datap  pData)
+#endif
+{
+  mng_uint16 iX;
+  mng_imagep pImage;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MAGN, MNG_LC_START);
+#endif
+                                       /* iterate the object-ids */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  for (iX = iFirstid; iX <= iLastid; iX++)
+#else
+  for (iX = pData->iMAGNfirstid; iX <= pData->iMAGNlastid; iX++)
+#endif
+  {
+    if (iX == 0)                       /* process object 0 ? */
+    {
+      pImage = (mng_imagep)pData->pObjzero;
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      pImage->iMAGN_MethodX = iMethodX;
+      pImage->iMAGN_MethodY = iMethodY;
+      pImage->iMAGN_MX      = iMX;
+      pImage->iMAGN_MY      = iMY;
+      pImage->iMAGN_ML      = iML;
+      pImage->iMAGN_MR      = iMR;
+      pImage->iMAGN_MT      = iMT;
+      pImage->iMAGN_MB      = iMB;
+#else
+      pImage->iMAGN_MethodX = pData->iMAGNmethodX;
+      pImage->iMAGN_MethodY = pData->iMAGNmethodY;
+      pImage->iMAGN_MX      = pData->iMAGNmX;
+      pImage->iMAGN_MY      = pData->iMAGNmY;
+      pImage->iMAGN_ML      = pData->iMAGNmL;
+      pImage->iMAGN_MR      = pData->iMAGNmR;
+      pImage->iMAGN_MT      = pData->iMAGNmT;
+      pImage->iMAGN_MB      = pData->iMAGNmB;
+#endif
+    }
+    else
+    {
+      pImage = mng_find_imageobject (pData, iX);
+                                       /* object exists & is not frozen ? */
+      if ((pImage) && (!pImage->bFrozen))
+      {                                /* previous magnification to be done ? */
+        if ((pImage->iMAGN_MethodX) || (pImage->iMAGN_MethodY))
+        {
+          mng_retcode iRetcode = mng_magnify_imageobject (pData, pImage);
+          if (iRetcode)                /* on error bail out */
+            return iRetcode;
+        }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+        pImage->iMAGN_MethodX = iMethodX;
+        pImage->iMAGN_MethodY = iMethodY;
+        pImage->iMAGN_MX      = iMX;
+        pImage->iMAGN_MY      = iMY;
+        pImage->iMAGN_ML      = iML;
+        pImage->iMAGN_MR      = iMR;
+        pImage->iMAGN_MT      = iMT;
+        pImage->iMAGN_MB      = iMB;
+#else
+        pImage->iMAGN_MethodX = pData->iMAGNmethodX;
+        pImage->iMAGN_MethodY = pData->iMAGNmethodY;
+        pImage->iMAGN_MX      = pData->iMAGNmX;
+        pImage->iMAGN_MY      = pData->iMAGNmY;
+        pImage->iMAGN_ML      = pData->iMAGNmL;
+        pImage->iMAGN_MR      = pData->iMAGNmR;
+        pImage->iMAGN_MT      = pData->iMAGNmT;
+        pImage->iMAGN_MB      = pData->iMAGNmB;
+#endif
+      }
+    }
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  pData->iMAGNfromid = iFirstid;
+  pData->iMAGNtoid   = iLastid;
+  iX                 = iFirstid;
+#else
+  pData->iMAGNfromid = pData->iMAGNfirstid;
+  pData->iMAGNtoid   = pData->iMAGNlastid;
+  iX                 = pData->iMAGNfirstid;
+#endif
+                                       /* iterate again for showing */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  while ((iX <= iLastid) && (!pData->bTimerset))
+#else
+  while ((iX <= pData->iMAGNlastid) && (!pData->bTimerset))
+#endif
+  {
+    pData->iMAGNcurrentid = iX;
+
+    if (iX)                            /* only real objects ! */
+    {
+      pImage = mng_find_imageobject (pData, iX);
+                                       /* object exists & is not frozen  &
+                                          is visible & is viewable ? */
+      if ((pImage) && (!pImage->bFrozen) &&
+          (pImage->bVisible) && (pImage->bViewable))
+      {
+        mng_retcode iRetcode = mng_display_image (pData, pImage, MNG_FALSE);
+        if (iRetcode)
+          return iRetcode;
+      }
+    }
+
+    iX++;
+  }
+
+  if (pData->bTimerset)                /* broken ? */
+    pData->iBreakpoint = 9;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_display_magn2 (mng_datap pData)
+{
+  mng_uint16 iX;
+  mng_imagep pImage;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MAGN, MNG_LC_START);
+#endif
+
+  iX = pData->iMAGNcurrentid;
+                                       /* iterate again for showing */
+  while ((iX <= pData->iMAGNtoid) && (!pData->bTimerset))
+  {
+    pData->iMAGNcurrentid = iX;
+
+    if (iX)                            /* only real objects ! */
+    {
+      pImage = mng_find_imageobject (pData, iX);
+                                       /* object exists & is not frozen  &
+                                          is visible & is viewable ? */
+      if ((pImage) && (!pImage->bFrozen) &&
+          (pImage->bVisible) && (pImage->bViewable))
+      {
+        mng_retcode iRetcode = mng_display_image (pData, pImage, MNG_FALSE);
+        if (iRetcode)
+          return iRetcode;
+      }
+    }
+
+    iX++;
+  }
+
+  if (pData->bTimerset)                /* broken ? */
+    pData->iBreakpoint = 9;
+  else
+    pData->iBreakpoint = 0;            /* not again ! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+mng_retcode mng_process_display_past (mng_datap  pData,
+                                      mng_uint16 iTargetid,
+                                      mng_uint8  iTargettype,
+                                      mng_int32  iTargetx,
+                                      mng_int32  iTargety,
+                                      mng_uint32 iCount,
+                                      mng_ptr    pSources)
+#else
+mng_retcode mng_process_display_past (mng_datap  pData)
+#endif
+{
+  mng_retcode      iRetcode = MNG_NOERROR;
+  mng_imagep       pTargetimg;
+  mng_imagep       pSourceimg;
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  mng_past_sourcep pSource = (mng_past_sourcep)pSources;
+#else
+  mng_past_sourcep pSource = (mng_past_sourcep)pData->pPASTsources;
+#endif
+  mng_uint32       iX      = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PAST, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  if (iTargetid)                       /* a real destination object ? */
+#else
+  if (pData->iPASTtargetid)            /* a real destination object ? */
+#endif
+  {                                    /* let's find it then */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    pTargetimg = (mng_imagep)mng_find_imageobject (pData, iTargetid);
+#else
+    pTargetimg = (mng_imagep)mng_find_imageobject (pData, pData->iPASTtargetid);
+#endif
+
+    if (!pTargetimg)                   /* if it doesn't exists; do a barf */
+      MNG_ERROR (pData, MNG_OBJECTUNKNOWN);
+                                       /* it's gotta be abstract !!! */
+    if (pTargetimg->pImgbuf->bConcrete)
+      MNG_ERROR (pData, MNG_OBJNOTABSTRACT);
+                                       /* we want 32-/64-bit RGBA to play with ! */
+    if ((pTargetimg->pImgbuf->iBitdepth <= MNG_BITDEPTH_8)          ||
+        (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_GRAY)    ||
+        (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_RGB)     ||
+        (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_INDEXED) ||
+        (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_GRAYA)      )
+      iRetcode = mng_promote_imageobject (pData, pTargetimg, MNG_BITDEPTH_8,
+                                          MNG_COLORTYPE_RGBA,
+                                          MNG_FILLMETHOD_LEFTBITREPLICATE);
+    else
+    if ((pTargetimg->pImgbuf->iBitdepth > MNG_BITDEPTH_8)              &&
+        ((pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_GRAY)  ||
+         (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_RGB)   ||
+         (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_GRAYA)    )   )
+      iRetcode = mng_promote_imageobject (pData, pTargetimg, MNG_BITDEPTH_16,
+                                          MNG_COLORTYPE_RGBA,
+                                          MNG_FILLMETHOD_LEFTBITREPLICATE);
+#ifdef MNG_INCLUDE_JNG
+    else
+    if ((pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_JPEGGRAY)  ||
+        (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_JPEGCOLOR) ||
+        (pTargetimg->pImgbuf->iColortype ==  MNG_COLORTYPE_JPEGGRAYA)    )
+      iRetcode = mng_promote_imageobject (pData, pTargetimg,
+                                          pTargetimg->pImgbuf->iBitdepth,
+                                          MNG_COLORTYPE_JPEGCOLORA,
+                                          MNG_FILLMETHOD_LEFTBITREPLICATE);
+#endif
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+                                       /* make it really abstract ? */
+    if (!pTargetimg->pImgbuf->bCorrected)
+    {
+      iRetcode = mng_colorcorrect_object (pData, pTargetimg);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+  else
+  {                                    /* pasting into object 0 !!! */
+    pTargetimg = (mng_imagep)pData->pObjzero;
+                                       /* is it usable ??? */
+    if ((pTargetimg->bClipped) &&
+        (pTargetimg->iClipr > pTargetimg->iPosx) &&
+        (pTargetimg->iClipb > pTargetimg->iPosy))
+    {
+                                       /* make it 32-bit RGBA please !!! */
+      iRetcode = mng_reset_object_details (pData, pTargetimg,
+                                           pTargetimg->iClipr - pTargetimg->iPosx,
+                                           pTargetimg->iClipb - pTargetimg->iPosy,
+                                           MNG_BITDEPTH_8, MNG_COLORTYPE_RGBA,
+                                           0, 0, 0, MNG_FALSE);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+    else
+      pTargetimg = MNG_NULL;           /* clipped beyond visibility ! */
+  }
+
+  if (pTargetimg)                      /* usable destination ? */
+  {
+    mng_int32      iSourceY;
+    mng_int32      iSourceYinc;
+    mng_int32      iSourcerowsize;
+    mng_int32      iSourcesamples;
+    mng_bool       bSourceRGBA16;
+    mng_int32      iTargetY;
+    mng_int32      iTargetrowsize;
+    mng_int32      iTargetsamples;
+    mng_bool       bTargetRGBA16 = MNG_FALSE;
+    mng_int32      iTemprowsize;
+    mng_imagedatap pBuf;
+#ifndef MNG_SKIPCHUNK_MAGN
+                                       /* needs magnification ? */
+    if ((pTargetimg->iMAGN_MethodX) || (pTargetimg->iMAGN_MethodY))
+      iRetcode = mng_magnify_imageobject (pData, pTargetimg);
+#endif
+
+    if (!iRetcode)                     /* still ok ? */
+    {
+      bTargetRGBA16 = (mng_bool)(pTargetimg->pImgbuf->iBitdepth > 8);
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+      switch (iTargettype)             /* determine target x/y */
+#else
+      switch (pData->iPASTtargettype)  /* determine target x/y */
+#endif
+      {
+        case 0 : {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   pData->iPastx = iTargetx;
+                   pData->iPasty = iTargety;
+#else
+                   pData->iPastx = pData->iPASTtargetx;
+                   pData->iPasty = pData->iPASTtargety;
+#endif
+                   break;
+                 }
+
+        case 1 : {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   pData->iPastx = pTargetimg->iPastx + iTargetx;
+                   pData->iPasty = pTargetimg->iPasty + iTargety;
+#else
+                   pData->iPastx = pTargetimg->iPastx + pData->iPASTtargetx;
+                   pData->iPasty = pTargetimg->iPasty + pData->iPASTtargety;
+#endif
+                   break;
+                 }
+
+        case 2 : {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+                   pData->iPastx += iTargetx;
+                   pData->iPasty += iTargety;
+#else
+                   pData->iPastx += pData->iPASTtargetx;
+                   pData->iPasty += pData->iPASTtargety;
+#endif
+                   break;
+                 }
+      }
+                                       /* save for next time ... */
+      pTargetimg->iPastx      = pData->iPastx;
+      pTargetimg->iPasty      = pData->iPasty;
+                                       /* address destination for row-routines */
+      pData->pStoreobj        = (mng_objectp)pTargetimg;
+      pData->pStorebuf        = (mng_objectp)pTargetimg->pImgbuf;
+    }
+                                       /* process the sources one by one */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    while ((!iRetcode) && (iX < iCount))
+#else
+    while ((!iRetcode) && (iX < pData->iPASTcount))
+#endif
+    {                                  /* find the little bastards first */
+      pSourceimg              = (mng_imagep)mng_find_imageobject (pData, pSource->iSourceid);
+                                       /* exists and viewable? */
+      if ((pSourceimg) && (pSourceimg->bViewable))
+      {                                /* needs magnification ? */
+#ifndef MNG_SKIPCHUNK_MAGN
+        if ((pSourceimg->iMAGN_MethodX) || (pSourceimg->iMAGN_MethodY))
+          iRetcode = mng_magnify_imageobject (pData, pSourceimg);
+#endif
+
+        if (!iRetcode)                 /* still ok ? */
+        {
+          pBuf                = (mng_imagedatap)pSourceimg->pImgbuf;
+                                       /* address source for row-routines */
+          pData->pRetrieveobj = (mng_objectp)pSourceimg;
+
+          pData->iPass        = -1;    /* init row-processing variables */
+          pData->iRowinc      = 1;
+          pData->iColinc      = 1;
+          pData->iPixelofs    = 0;
+          iSourcesamples      = (mng_int32)pBuf->iWidth;
+          iSourcerowsize      = pBuf->iRowsize;
+          bSourceRGBA16       = (mng_bool)(pBuf->iBitdepth > 8);
+                                       /* make sure the delta-routines do the right thing */
+          pData->iDeltatype   = MNG_DELTATYPE_BLOCKPIXELREPLACE;
+
+          switch (pBuf->iColortype)
+          {
+            case  0 : { 
+#ifndef MNG_NO_16BIT_SUPPORT
+                         if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_g16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_g8;
+
+                        pData->bIsOpaque      = (mng_bool)(!pBuf->bHasTRNS);
+                        break;
+                      }
+
+            case  2 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                        if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb8;
+
+                        pData->bIsOpaque      = (mng_bool)(!pBuf->bHasTRNS);
+                        break;
+                      }
+
+
+            case  3 : { pData->fRetrieverow   = (mng_fptr)mng_retrieve_idx8;
+                        pData->bIsOpaque      = (mng_bool)(!pBuf->bHasTRNS);
+                        break;
+                      }
+
+
+            case  4 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                        if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_ga16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_ga8;
+
+                        pData->bIsOpaque      = MNG_FALSE;
+                        break;
+                      }
+
+
+            case  6 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                         if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+
+                        pData->bIsOpaque      = MNG_FALSE;
+                        break;
+                      }
+
+            case  8 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                         if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_g16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_g8;
+
+                        pData->bIsOpaque      = MNG_TRUE;
+                        break;
+                      }
+
+            case 10 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                         if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgb8;
+
+                        pData->bIsOpaque      = MNG_TRUE;
+                        break;
+                      }
+
+
+            case 12 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                         if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_ga16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_ga8;
+
+                        pData->bIsOpaque      = MNG_FALSE;
+                        break;
+                      }
+
+
+            case 14 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                         if (bSourceRGBA16)
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba16;
+                        else
+#endif
+                          pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+
+                        pData->bIsOpaque      = MNG_FALSE;
+                        break;
+                      }
+          }
+                                       /* determine scaling */
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_NO_DELTA_PNG
+          if ((!bSourceRGBA16) && (bTargetRGBA16))
+            pData->fScalerow = (mng_fptr)mng_scale_rgba8_rgba16;
+          else
+          if ((bSourceRGBA16) && (!bTargetRGBA16))
+            pData->fScalerow = (mng_fptr)mng_scale_rgba16_rgba8;
+          else
+#endif
+#endif
+            pData->fScalerow = MNG_NULL;
+
+                                       /* default no color-correction */
+          pData->fCorrectrow = MNG_NULL;
+
+#if defined(MNG_FULL_CMS)              /* determine color-management routine */
+          iRetcode = mng_init_full_cms   (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_GAMMA_ONLY)
+          iRetcode = mng_init_gamma_only (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_APP_CMS)
+          iRetcode = mng_init_app_cms    (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#endif
+        }
+
+        if (!iRetcode)                 /* still ok ? */
+        {  
+          pData->fFliprow = MNG_NULL;  /* no flipping or tiling by default */
+          pData->fTilerow = MNG_NULL;
+                                       /* but perhaps we do have to ... */
+          switch (pSource->iOrientation)
+          {
+            case 2 : ;
+            case 4 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                       if (bTargetRGBA16)
+                         pData->fFliprow = (mng_fptr)mng_flip_rgba16;
+                       else
+#endif
+                         pData->fFliprow = (mng_fptr)mng_flip_rgba8;
+                       break;
+                     }
+
+            case 8 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                       if (bTargetRGBA16)
+                         pData->fTilerow = (mng_fptr)mng_tile_rgba16;
+                       else
+#endif
+                         pData->fTilerow = (mng_fptr)mng_tile_rgba8;
+                       break;
+                     }
+          }
+                                       /* determine composition routine */
+                                       /* note that we're abusing the delta-routine setup !!! */
+          switch (pSource->iComposition)
+          {
+            case 0 : {                 /* composite over */
+#ifndef MNG_NO_16BIT_SUPPORT
+                       if (bTargetRGBA16)
+                         pData->fDeltarow = (mng_fptr)mng_composeover_rgba16;
+                       else
+#endif
+                         pData->fDeltarow = (mng_fptr)mng_composeover_rgba8;
+                       break;
+                     }
+
+            case 1 : {                 /* replace */
+#ifndef MNG_NO_16BIT_SUPPORT
+                       if (bTargetRGBA16)
+                         pData->fDeltarow = (mng_fptr)mng_delta_rgba16_rgba16;
+                       else
+#endif
+                         pData->fDeltarow = (mng_fptr)mng_delta_rgba8_rgba8;
+                       break;
+                     }
+
+            case 2 : {                 /* composite under */
+#ifndef MNG_NO_16BIT_SUPPORT
+                       if (bTargetRGBA16)
+                         pData->fDeltarow = (mng_fptr)mng_composeunder_rgba16;
+                       else
+#endif
+                         pData->fDeltarow = (mng_fptr)mng_composeunder_rgba8;
+                       break;
+                     }
+          }
+                                       /* determine offsets & clipping */
+          if (pSource->iOffsettype == 1)
+          {
+            pData->iDestl          = pData->iPastx + pSource->iOffsetx;
+            pData->iDestt          = pData->iPasty + pSource->iOffsety;
+          }
+          else
+          {
+            pData->iDestl          = pSource->iOffsetx;
+            pData->iDestt          = pSource->iOffsety;
+          }
+
+          pData->iDestr            = (mng_int32)pTargetimg->pImgbuf->iWidth;
+          pData->iDestb            = (mng_int32)pTargetimg->pImgbuf->iHeight;
+                                       /* take the source dimension into account ? */
+          if (pSource->iOrientation != 8)
+          {
+            pData->iDestr          = MIN_COORD (pData->iDestr, pData->iDestl + (mng_int32)pBuf->iWidth);
+            pData->iDestb          = MIN_COORD (pData->iDestb, pData->iDestt + (mng_int32)pBuf->iHeight);
+          }
+                                       /* source clipping */
+          if (pSource->iBoundarytype == 1)
+          {
+            if (pData->iDestl < pData->iPastx + pSource->iBoundaryl)
+              pData->iSourcel      = pData->iPastx + pSource->iBoundaryl - pData->iDestl;
+            else
+              pData->iSourcel      = 0;
+
+            if (pData->iDestt < pData->iPasty + pSource->iBoundaryt)
+              pData->iSourcet      = pData->iPasty + pSource->iBoundaryt - pData->iDestt;
+            else
+              pData->iSourcet      = 0;
+
+            pData->iDestl          = MAX_COORD (pData->iDestl, pData->iPastx + pSource->iBoundaryl);
+            pData->iDestt          = MAX_COORD (pData->iDestt, pData->iPasty + pSource->iBoundaryt);
+            pData->iDestr          = MIN_COORD (pData->iDestr, pData->iPastx + pSource->iBoundaryr);
+            pData->iDestb          = MIN_COORD (pData->iDestb, pData->iPasty + pSource->iBoundaryb);
+          }
+          else
+          {
+            if (pData->iDestl < pSource->iBoundaryl)
+              pData->iSourcel      = pSource->iBoundaryl - pData->iDestl;
+            else
+              pData->iSourcel      = 0;
+
+            if (pData->iDestt < pSource->iBoundaryt)
+              pData->iSourcet      = pSource->iBoundaryt - pData->iDestt;
+            else
+              pData->iSourcet      = 0;
+
+            pData->iDestl          = MAX_COORD (pData->iDestl, pSource->iBoundaryl);
+            pData->iDestt          = MAX_COORD (pData->iDestt, pSource->iBoundaryt);
+            pData->iDestr          = MIN_COORD (pData->iDestr, pSource->iBoundaryr);
+            pData->iDestb          = MIN_COORD (pData->iDestb, pSource->iBoundaryb);
+          }
+
+          if (pData->iSourcel)         /* indent source ? */
+          {
+#ifndef MNG_NO_16BIT_SUPPORT
+             if (bTargetRGBA16)        /* abuse tiling routine to shift source-pixels */
+               pData->fTilerow = (mng_fptr)mng_tile_rgba16;
+             else
+#endif
+               pData->fTilerow = (mng_fptr)mng_tile_rgba8;
+          }
+                                       /* anything to display ? */
+          if ((pData->iDestl <= pData->iDestr) && (pData->iDestt <= pData->iDestb))
+          {                            /* init variables for the loop */
+            if ((pSource->iOrientation == 2) || (pSource->iOrientation == 6))
+            {
+              iSourceY             = (mng_int32)pBuf->iHeight - 1 - pData->iSourcet;
+              iSourceYinc          = -1;
+            }
+            else
+            {
+              iSourceY             = pData->iSourcet;
+              iSourceYinc          = 1;
+            }
+
+            iTargetY               = pData->iDestt;
+            pData->iCol            = pData->iDestl;
+
+            iTargetsamples         = pData->iDestr - pData->iDestl;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+            if (bTargetRGBA16)
+              iTargetrowsize       = (iTargetsamples << 3);
+            else
+#endif
+              iTargetrowsize       = (iTargetsamples << 2);
+
+                                       /* get temporary work-buffers */
+            if (iSourcerowsize > iTargetrowsize)
+              iTemprowsize         = iSourcerowsize << 1;
+            else
+              iTemprowsize         = iTargetrowsize << 1;
+            MNG_ALLOC (pData, pData->pRGBArow, iTemprowsize);
+            MNG_ALLOC (pData, pData->pWorkrow, iTemprowsize);
+
+            while ((!iRetcode) && (iTargetY < pData->iDestb))
+            {                          /* get a row */
+              pData->iRow          = iSourceY;
+              pData->iRowsamples   = iSourcesamples;
+              pData->iRowsize      = iSourcerowsize;
+              pData->bIsRGBA16     = bSourceRGBA16;
+              iRetcode             = ((mng_retrieverow)pData->fRetrieverow) (pData);
+                                       /* scale it (if necessary) */
+              if ((!iRetcode) && (pData->fScalerow))
+                iRetcode           = ((mng_scalerow)pData->fScalerow) (pData);
+
+              pData->bIsRGBA16     = bTargetRGBA16;
+                                       /* color correction (if necessary) */
+              if ((!iRetcode) && (pData->fCorrectrow))
+                iRetcode           = ((mng_correctrow)pData->fCorrectrow) (pData);
+                                       /* flipping (if necessary) */
+              if ((!iRetcode) && (pData->fFliprow))
+                iRetcode           = ((mng_fliprow)pData->fFliprow) (pData);
+                                       /* tiling (if necessary) */
+              if ((!iRetcode) && (pData->fTilerow))
+                iRetcode           = ((mng_tilerow)pData->fTilerow) (pData);
+
+              if (!iRetcode)           /* and paste..... */
+              {
+                pData->iRow        = iTargetY;
+                pData->iRowsamples = iTargetsamples;
+                pData->iRowsize    = iTargetrowsize;
+                iRetcode           = ((mng_deltarow)pData->fDeltarow) (pData);
+              }
+
+              iSourceY += iSourceYinc; /* and next line */
+
+              if (iSourceY < 0)
+                iSourceY = (mng_int32)pBuf->iHeight - 1;
+              else
+              if (iSourceY >= (mng_int32)pBuf->iHeight)
+                iSourceY = 0;
+
+              iTargetY++;
+            }
+                                       /* drop the temporary row-buffer */
+            MNG_FREEX (pData, pData->pWorkrow, iTemprowsize);
+            MNG_FREEX (pData, pData->pRGBArow, iTemprowsize);
+          }
+
+#if defined(MNG_FULL_CMS)              /* cleanup cms stuff */
+          if (!iRetcode)
+            iRetcode = mng_clear_cms (pData);
+#endif
+        }
+
+        pSource++;                     /* neeeeext */
+        iX++;
+      }
+    }
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    if (!iTargetid)                    /* did we paste into object 0 ? */
+#else
+    if (!pData->iPASTtargetid)         /* did we paste into object 0 ? */
+#endif
+    {                                  /* display it then ! */
+      iRetcode = mng_display_image (pData, pTargetimg, MNG_FALSE);
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+    else
+    {                                  /* target is visible & viewable ? */
+      if ((pTargetimg->bVisible) && (pTargetimg->bViewable))
+      {
+        iRetcode = mng_display_image (pData, pTargetimg, MNG_FALSE);
+        if (iRetcode)
+          return iRetcode;
+      }
+    }  
+  }
+
+  if (pData->bTimerset)                /* broken ? */
+  {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    pData->iPASTid     = iTargetid;
+#else
+    pData->iPASTid     = pData->iPASTtargetid;
+#endif
+    pData->iBreakpoint = 11;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PAST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SKIPCHUNK_PAST */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_process_display_past2 (mng_datap pData)
+{
+  mng_retcode iRetcode;
+  mng_imagep  pTargetimg;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PAST, MNG_LC_START);
+#endif
+
+  if (pData->iPASTid)                  /* a real destination object ? */
+    pTargetimg = (mng_imagep)mng_find_imageobject (pData, pData->iPASTid);
+  else                                 /* otherwise object 0 */
+    pTargetimg = (mng_imagep)pData->pObjzero;
+
+  iRetcode = mng_display_image (pData, pTargetimg, MNG_FALSE);
+  if (iRetcode)
+    return iRetcode;
+
+  pData->iBreakpoint = 0;              /* only once */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_PAST, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SKIPCHUNK_PAST */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
diff --git a/src/3rdparty/libmng/libmng_display.h b/src/3rdparty/libmng/libmng_display.h
new file mode 100644
index 0000000..f394dd2
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_display.h
@@ -0,0 +1,343 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_display.h          copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Display management (definition)                            * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the display managament routines              * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - added JNG support stuff                                  * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - changed progressive-display processing                   * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - added support for delta-image processing                 * */
+/* *             - added support for PPLT chunk processing                  * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *             0.9.3 - 08/07/2000 - G.Juyn                                * */
+/* *             - B111300 - fixup for improved portability                 * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added JDAA chunk                                         * */
+/* *                                                                        * */
+/* *             0.9.4 - 11/24/2000 - G.Juyn                                * */
+/* *             - moved restore of object 0 to libmng_display              * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/13/2002 - G.Juyn                                * */
+/* *             - fixed read/write of MAGN chunk                           * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - added proposed change in handling of TERM- & if-delay    * */
+/* *             1.0.5 - 10/20/2002 - G.Juyn                                * */
+/* *             - fixed display of visible target of PAST operation        * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/24/2004 - G.R-P.                                * */
+/* *             - added some SKIPCHUNK conditionals                        * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/11/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_DISPLAYCALLS              * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_display_h_
+#define _libmng_display_h_
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+
+/* ************************************************************************** */
+
+mng_retcode mng_display_progressive_refresh (mng_datap  pData,
+                                             mng_uint32 iInterval);
+
+/* ************************************************************************** */
+
+mng_retcode mng_reset_objzero         (mng_datap      pData);
+
+mng_retcode mng_display_image         (mng_datap      pData,
+                                       mng_imagep     pImage,
+                                       mng_bool       bLayeradvanced);
+
+mng_retcode mng_execute_delta_image   (mng_datap      pData,
+                                       mng_imagep     pTarget,
+                                       mng_imagep     pDelta);
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_display       (mng_datap      pData);
+
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+png_imgtype mng_png_imgtype           (mng_uint8      colortype,
+                                       mng_uint8      bitdepth);
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+
+mng_retcode mng_process_display_ihdr  (mng_datap      pData);
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+mng_retcode mng_process_display_mpng  (mng_datap      pData);
+#endif
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+mng_retcode mng_process_display_ang   (mng_datap      pData);
+#endif
+
+mng_retcode mng_process_display_idat  (mng_datap      pData,
+                                       mng_uint32     iRawlen,
+                                       mng_uint8p     pRawdata);
+
+mng_retcode mng_process_display_iend  (mng_datap      pData);
+mng_retcode mng_process_display_mend  (mng_datap      pData);
+mng_retcode mng_process_display_mend2 (mng_datap      pData);
+mng_retcode mng_process_display_defi  (mng_datap      pData);
+
+#ifndef MNG_SKIPCHUNK_BASI
+mng_retcode mng_process_display_basi  (mng_datap      pData,
+                                       mng_uint16     iRed,
+                                       mng_uint16     iGreen,
+                                       mng_uint16     iBlue,
+                                       mng_bool       bHasalpha,
+                                       mng_uint16     iAlpha,
+                                       mng_uint8      iViewable);
+#endif
+
+#ifndef MNG_SKIPCHUNK_CLON
+mng_retcode mng_process_display_clon  (mng_datap      pData,
+                                       mng_uint16     iSourceid,
+                                       mng_uint16     iCloneid,
+                                       mng_uint8      iClonetype,
+                                       mng_bool       bHasdonotshow,
+                                       mng_uint8      iDonotshow,
+                                       mng_uint8      iConcrete,
+                                       mng_bool       bHasloca,
+                                       mng_uint8      iLocationtype,
+                                       mng_int32      iLocationx,
+                                       mng_int32      iLocationy);
+mng_retcode mng_process_display_clon2 (mng_datap      pData);
+#endif
+
+#ifndef MNG_SKIPCHUNK_DISC
+mng_retcode mng_process_display_disc  (mng_datap      pData,
+                                       mng_uint32     iCount,
+                                       mng_uint16p    pIds);
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+mng_retcode mng_process_display_fram  (mng_datap      pData,
+                                       mng_uint8      iFramemode,
+                                       mng_uint8      iChangedelay,
+                                       mng_uint32     iDelay,
+                                       mng_uint8      iChangetimeout,
+                                       mng_uint32     iTimeout,
+                                       mng_uint8      iChangeclipping,
+                                       mng_uint8      iCliptype,
+                                       mng_int32      iClipl,
+                                       mng_int32      iClipr,
+                                       mng_int32      iClipt,
+                                       mng_int32      iClipb);
+mng_retcode mng_process_display_fram2 (mng_datap      pData);
+#endif
+
+#ifndef MNG_SKIPCHUNK_MOVE
+mng_retcode mng_process_display_move  (mng_datap      pData,
+                                       mng_uint16     iFromid,
+                                       mng_uint16     iToid,
+                                       mng_uint8      iMovetype,
+                                       mng_int32      iMovex,
+                                       mng_int32      iMovey);
+#endif
+
+#ifndef MNG_SKIPCHUNK_CLIP
+mng_retcode mng_process_display_clip  (mng_datap      pData,
+                                       mng_uint16     iFromid,
+                                       mng_uint16     iToid,
+                                       mng_uint8      iCliptype,
+                                       mng_int32      iClipl,
+                                       mng_int32      iClipr,
+                                       mng_int32      iClipt,
+                                       mng_int32      iClipb);
+#endif
+
+#ifndef MNG_SKIPCHUNK_SHOW
+mng_retcode mng_process_display_show  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_process_display_save  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode mng_process_display_seek  (mng_datap      pData);
+#endif
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_process_display_jhdr  (mng_datap      pData);
+
+mng_retcode mng_process_display_jdaa  (mng_datap      pData,
+                                       mng_uint32     iRawlen,
+                                       mng_uint8p     pRawdata);
+
+mng_retcode mng_process_display_jdat  (mng_datap      pData,
+                                       mng_uint32     iRawlen,
+                                       mng_uint8p     pRawdata);
+
+#endif
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_process_display_dhdr  (mng_datap      pData,
+                                       mng_uint16     iObjectid,
+                                       mng_uint8      iImagetype,
+                                       mng_uint8      iDeltatype,
+                                       mng_uint32     iBlockwidth,
+                                       mng_uint32     iBlockheight,
+                                       mng_uint32     iBlockx,
+                                       mng_uint32     iBlocky);
+
+mng_retcode mng_process_display_prom  (mng_datap      pData,
+                                       mng_uint8      iBitdepth,
+                                       mng_uint8      iColortype,
+                                       mng_uint8      iFilltype);
+
+mng_retcode mng_process_display_ipng  (mng_datap      pData);
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_process_display_ijng  (mng_datap      pData);
+#endif
+
+mng_retcode mng_process_display_pplt  (mng_datap      pData,
+                                       mng_uint8      iType,
+                                       mng_uint32     iCount,
+                                       mng_palette8ep paIndexentries,
+                                       mng_uint8p     paAlphaentries,
+                                       mng_uint8p     paUsedentries);
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode mng_process_display_magn  (mng_datap      pData,
+                                       mng_uint16     iFirstid,
+                                       mng_uint16     iLastid,
+                                       mng_uint8      iMethodX,
+                                       mng_uint16     iMX,
+                                       mng_uint16     iMY,
+                                       mng_uint16     iML,
+                                       mng_uint16     iMR,
+                                       mng_uint16     iMT,
+                                       mng_uint16     iMB,
+                                       mng_uint8      iMethodY);
+mng_retcode mng_process_display_magn2 (mng_datap      pData);
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_process_display_past  (mng_datap      pData,
+                                       mng_uint16     iTargetid,
+                                       mng_uint8      iTargettype,
+                                       mng_int32      iTargetx,
+                                       mng_int32      iTargety,
+                                       mng_uint32     iCount,
+                                       mng_ptr        pSources);
+mng_retcode mng_process_display_past2 (mng_datap      pData);
+#endif
+
+#else /* MNG_OPTIMIZE_DISPLAYCALLS */
+
+mng_retcode mng_process_display_ihdr  (mng_datap      pData);
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+mng_retcode mng_process_display_mpng  (mng_datap      pData);
+#endif
+mng_retcode mng_process_display_idat  (mng_datap      pData);
+mng_retcode mng_process_display_iend  (mng_datap      pData);
+mng_retcode mng_process_display_mend  (mng_datap      pData);
+mng_retcode mng_process_display_mend2 (mng_datap      pData);
+mng_retcode mng_process_display_defi  (mng_datap      pData);
+#ifndef MNG_SKIPCHUNK_BASI
+mng_retcode mng_process_display_basi  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+mng_retcode mng_process_display_clon  (mng_datap      pData);
+mng_retcode mng_process_display_clon2 (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_DISC
+mng_retcode mng_process_display_disc  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_FRAM
+mng_retcode mng_process_display_fram  (mng_datap      pData);
+mng_retcode mng_process_display_fram2 (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_MOVE
+mng_retcode mng_process_display_move  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_CLIP
+mng_retcode mng_process_display_clip  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_SHOW
+mng_retcode mng_process_display_show  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_process_display_save  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode mng_process_display_seek  (mng_datap      pData);
+#endif
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_process_display_jhdr  (mng_datap      pData);
+mng_retcode mng_process_display_jdaa  (mng_datap      pData);
+mng_retcode mng_process_display_jdat  (mng_datap      pData);
+#endif
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_process_display_dhdr  (mng_datap      pData);
+mng_retcode mng_process_display_prom  (mng_datap      pData);
+mng_retcode mng_process_display_ipng  (mng_datap      pData);
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_process_display_ijng  (mng_datap      pData);
+#endif
+mng_retcode mng_process_display_pplt  (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode mng_process_display_magn  (mng_datap      pData);
+mng_retcode mng_process_display_magn2 (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_process_display_past  (mng_datap      pData);
+mng_retcode mng_process_display_past2 (mng_datap      pData);
+#endif
+
+#endif /* MNG_OPTIMIZE_DISPLAYCALLS */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+
+#endif /* _libmng_display_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_dither.c b/src/3rdparty/libmng/libmng_dither.c
new file mode 100644
index 0000000..e23850c
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_dither.c
@@ -0,0 +1,58 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_dither.c           copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : Dithering routines (implementation)                        * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the dithering routines                   * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_dither.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_dither_a_row (mng_datap  pData,
+                              mng_uint8p pRow)
+{
+
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
+
diff --git a/src/3rdparty/libmng/libmng_dither.h b/src/3rdparty/libmng/libmng_dither.h
new file mode 100644
index 0000000..d9217c0
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_dither.h
@@ -0,0 +1,45 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_dither.h           copyright (c) 2000-2002 G.Juyn   * */
+/* * version   : 1.0.5                                                      * */
+/* *                                                                        * */
+/* * purpose   : Dithering routines (definition)                            * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the dithering routines                       * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_dither_h_
+#define _libmng_dither_h_
+
+/* ************************************************************************** */
+
+mng_retcode mng_dither_a_row (mng_datap  pData,
+                              mng_uint8p pRow);
+
+/* ************************************************************************** */
+
+#endif /* _libmng_dither_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_error.c b/src/3rdparty/libmng/libmng_error.c
new file mode 100644
index 0000000..3a4da20
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_error.c
@@ -0,0 +1,326 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_error.c            copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Error routines (implementation)                            * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the general error handling routines      * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - added error telltaling                                   * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added errorstrings for delta-image processing            * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - fixed up punctuation (contributed by Tim Rowley)         * */
+/* *             0.5.2 - 06/06/2000 - G.Juyn                                * */
+/* *             - added errorstring for delayed buffer-processing          * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/06/2000 - G.Juyn                                * */
+/* *             - added MNG_NEEDTIMERWAIT errorstring                      * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added NEEDSECTIONWAIT errorstring                        * */
+/* *             - added macro + routine to set returncode without          * */
+/* *               calling error callback                                   * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - added errorstring for updatemngheader if not a MNG       * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/09/2000 - G.Juyn                                * */
+/* *             - added check for simplicity-bits in MHDR                  * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - fixed processing of unknown critical chunks              * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/20/2000 - G.Juyn                                * */
+/* *             - added errorcode for delayed delta-processing             * */
+/* *                                                                        * */
+/* *             0.9.4 - 01/18/2001 - G.Juyn                                * */
+/* *             - added errorcode for MAGN methods                         * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *                                                                        * */
+/* *             1.0.5 - 07/04/2002 - G.Juyn                                * */
+/* *             - added errorcode for extreme chunk-sizes                  * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed delta-image support                            * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - fixed LOOP iteration=0 special case                      * */
+/* *             1.0.5 - 09/19/2002 - G.Juyn                                * */
+/* *             - warnings are ignored by default now!                     * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - added check for TERM placement during create/write       * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G. R-P                                * */
+/* *             - added MNG_SKIPCHUNK_CHNK, MNG_NO_DELTA_PNG reductions.   * */
+/* *             - skipped more code when MNG_INCLUDE_JNG is not enabled.   * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditional around evNT chunk support              * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - fixed typo on SKIPCHUNK_evNT (->PAST)                    * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ERROR_STRINGS
+MNG_LOCAL mng_error_entry const error_table [] =
+  {
+    {MNG_NOERROR,          "No error"},
+    {MNG_OUTOFMEMORY,      "Out of memory"},
+    {MNG_INVALIDHANDLE,    "The handle is invalid"},
+    {MNG_NOCALLBACK,       "A required callback is not defined"},
+    {MNG_UNEXPECTEDEOF,    "Encountered unexpected end-of-file"},
+    {MNG_ZLIBERROR,        "zlib encountered an error"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_JPEGERROR,        "ijgsrc6b encountered an error"},
+#endif
+    {MNG_LCMSERROR,        "lcms encountered an error"},
+    {MNG_NOOUTPUTPROFILE,  "No output-profile defined for CMS"},
+    {MNG_NOSRGBPROFILE,    "No sRGB-profile defined for CMS"},
+    {MNG_BUFOVERFLOW,      "Internal buffer-overflow"},
+    {MNG_FUNCTIONINVALID,  "Function is invalid at this point"},
+    {MNG_OUTPUTERROR,      "Writing was unsuccessful; disk full?"},
+    {MNG_JPEGBUFTOOSMALL,  "Internal buffer for JPEG processing too small"},
+    {MNG_NEEDMOREDATA,     "Reading suspended; waiting for I/O to catch up"},
+    {MNG_NEEDTIMERWAIT,    "Timer suspension; normal animation delay"},
+    {MNG_NEEDSECTIONWAIT,  "SEEK suspension; application decides"},
+    {MNG_LOOPWITHCACHEOFF, "LOOP encountered when playback cache is turned off"},
+
+    {MNG_APPIOERROR,       "Application signalled I/O error"},
+    {MNG_APPTIMERERROR,    "Application signalled timing error"},
+    {MNG_APPCMSERROR,      "Application signalled CMS error"},
+    {MNG_APPMISCERROR,     "Application signalled an error"},
+    {MNG_APPTRACEABORT,    "Application signalled error during trace-callback"},
+
+    {MNG_INTERNALERROR,    "Internal error in libmng"},
+
+    {MNG_INVALIDSIG,       "The signature is invalid"},
+    {MNG_INVALIDCRC,       "The CRC for this chunk is invalid"},
+    {MNG_INVALIDLENGTH,    "Chunk-length is invalid"},
+    {MNG_SEQUENCEERROR,    "Chunk out of sequence"},
+    {MNG_CHUNKNOTALLOWED,  "Chunk not allowed at this point"},
+    {MNG_MULTIPLEERROR,    "Chunk cannot occur multiple times"},
+    {MNG_PLTEMISSING,      "Missing PLTE chunk"},
+    {MNG_IDATMISSING,      "Missing IDAT chunk(s)"},
+    {MNG_CANNOTBEEMPTY,    "Chunk cannot be empty"},
+    {MNG_GLOBALLENGTHERR,  "Global data length invalid"},
+    {MNG_INVALIDBITDEPTH,  "The bit_depth is invalid"},
+    {MNG_INVALIDCOLORTYPE, "The color_type is invalid"},
+    {MNG_INVALIDCOMPRESS,  "The compression_method is invalid"},
+    {MNG_INVALIDFILTER,    "The filter_method or filter_type is invalid"},
+    {MNG_INVALIDINTERLACE, "The interlace_method is invalid"},
+    {MNG_NOTENOUGHIDAT,    "There is not enough data in the IDAT chunk(s)"},
+    {MNG_PLTEINDEXERROR,   "Palette-index out of bounds"},
+    {MNG_NULLNOTFOUND,     "NULL separator not found"},
+    {MNG_KEYWORDNULL,      "Keyword cannot be zero-length"},
+    {MNG_OBJECTUNKNOWN,    "Object does not exist"},
+    {MNG_OBJECTEXISTS,     "Object already exists"},
+    {MNG_TOOMUCHIDAT,      "Too much data in IDAT chunk(s)"},
+    {MNG_INVSAMPLEDEPTH,   "The sample_depth is invalid"},
+    {MNG_INVOFFSETSIZE,    "The offset_type is invalid"},
+    {MNG_INVENTRYTYPE,     "The entry_type is invalid"},
+    {MNG_ENDWITHNULL,      "Chunk must not end with NULL byte"},
+    {MNG_INVIMAGETYPE,     "The image_type is invalid"},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_INVDELTATYPE,     "The delta_type is invalid"},
+#endif
+    {MNG_INVALIDINDEX,     "Index-value out of bounds"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_TOOMUCHJDAT,      "Too much data in JDAT chunk(s)"},
+    {MNG_JPEGPARMSERR,     "JHDR parameters & JFIF-data do not match"},
+#endif
+    {MNG_INVFILLMETHOD,    "The fill_method is invalid"},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_OBJNOTCONCRETE,   "Target object for DHDR must be concrete"},
+#endif
+    {MNG_TARGETNOALPHA,    "Target object must have alpha-channel"},
+    {MNG_MNGTOOCOMPLEX,    "MHDR simplicity indicates unsupported feature(s)"},
+    {MNG_UNKNOWNCRITICAL,  "Unknown critical chunk encountered"},
+#ifndef MNG_SKIPCHUNK_nEED
+    {MNG_UNSUPPORTEDNEED,  "Requested nEED resources are not supported"},
+#endif
+    {MNG_INVALIDDELTA,     "The delta operation is invalid (mismatched color_types?)"},
+    {MNG_INVALIDMETHOD,    "Method is invalid"},
+    {MNG_IMPROBABLELENGTH, "Chunklength is incredibly large"},
+    {MNG_INVALIDBLOCK,     "Delta block width and or height invalid"},
+    {MNG_INVALIDEVENT,     "Event type is invalid"},
+    {MNG_INVALIDMASK,      "Mask type is invalid"},
+    {MNG_NOMATCHINGLOOP,   "ENDL without matching LOOP"},
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_SEEKNOTFOUND,     "evNT points to unknown SEEK"},
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_OBJNOTABSTRACT,   "Destination object for PAST must be abstract"},
+#endif
+    {MNG_TERMSEQERROR,     "TERM misplaced during creation of MNG stream"},
+    {MNG_INVALIDFIELDVAL,  "invalid fieldvalue (generic)"},
+    {MNG_INVALIDWIDTH,     "invalid frame/image width"},
+    {MNG_INVALIDHEIGHT,    "invalid frame/image height"},
+
+    {MNG_INVALIDCNVSTYLE,  "Canvas_style is invalid"},
+    {MNG_WRONGCHUNK,       "Attempt to access the wrong chunk"},
+    {MNG_INVALIDENTRYIX,   "Attempt to access an non-existing entry"},
+    {MNG_NOHEADER,         "No valid header-chunk"},
+    {MNG_NOCORRCHUNK,      "Parent chunk not found"},
+    {MNG_NOMHDR,           "No MNG header (MHDR) found"},
+
+    {MNG_IMAGETOOLARGE,    "Image is larger than defined maximum"},
+    {MNG_NOTANANIMATION,   "Image is not an animation"},
+    {MNG_FRAMENRTOOHIGH,   "Framenr out of bounds"},
+    {MNG_LAYERNRTOOHIGH,   "Layernr out of bounds"},
+    {MNG_PLAYTIMETOOHIGH,  "Playtime out of bounds"},
+    {MNG_FNNOTIMPLEMENTED, "Function not yet implemented"},
+    {MNG_IMAGEFROZEN,      "Image is frozen"},
+
+    {MNG_LCMS_NOHANDLE,    "Handle could not be initialized"},
+    {MNG_LCMS_NOMEM,       "No memory for gamma-table(s)"},
+    {MNG_LCMS_NOTRANS,     "Transformation could not be initialized"}
+  };
+#endif /* MNG_INCLUDE_ERROR_STRINGS */
+
+/* ************************************************************************** */
+
+mng_bool mng_store_error (mng_datap   pData,
+                          mng_retcode iError,
+                          mng_retcode iExtra1,
+                          mng_retcode iExtra2)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (pData, MNG_FN_STORE_ERROR, MNG_LC_START);
+#endif
+
+  if (pData != 0)
+  {
+    pData->iErrorcode = iError;        /* save also for getlasterror */
+    pData->iErrorx1   = iExtra1;
+    pData->iErrorx2   = iExtra2;
+
+#ifdef MNG_INCLUDE_ERROR_STRINGS
+    {                                  /* binary search variables */
+      mng_int32        iTop, iLower, iUpper, iMiddle;
+      mng_error_entryp pEntry;         /* pointer to found entry */
+                                       /* determine max index of table */
+      iTop = (sizeof (error_table) / sizeof (error_table [0])) - 1;
+
+      iLower  = 0;                     /* initialize binary search */
+      iMiddle = iTop >> 1;             /* start in the middle */
+      iUpper  = iTop;
+      pEntry  = 0;                     /* no goods yet! */
+
+      do                               /* the binary search itself */
+        {
+          if (error_table [iMiddle].iError < iError)
+            iLower = iMiddle + 1;
+          else if (error_table [iMiddle].iError > iError)
+            iUpper = iMiddle - 1;
+          else
+          {
+            pEntry = &error_table [iMiddle];
+            break;
+          }
+
+          iMiddle = (iLower + iUpper) >> 1;
+        }
+      while (iLower <= iUpper);
+
+      if (pEntry)                      /* found it ? */
+        pData->zErrortext = pEntry->zErrortext;
+      else
+        pData->zErrortext = "Unknown error";
+      }
+#else /* MNG_INCLUDE_ERROR_STRINGS */
+    pData->zErrortext = 0;
+#endif /* MNG_INCLUDE_ERROR_STRINGS */
+
+    if (iError == 0)                   /* no error is not severe ! */
+    {
+      pData->iSeverity = 0;
+    }
+    else
+    {
+      switch (iError&0x3C00)           /* determine the severity */
+      {
+        case 0x0800 : { pData->iSeverity = 5; break; }
+        case 0x1000 : { pData->iSeverity = 2; break; }
+        case 0x2000 : { pData->iSeverity = 1; break; }      
+        default     : { pData->iSeverity = 9; }
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (pData, MNG_FN_STORE_ERROR, MNG_LC_END);
+#endif
+
+  return MNG_TRUE;
+}
+
+/* ************************************************************************** */
+
+mng_bool mng_process_error (mng_datap   pData,
+                            mng_retcode iError,
+                            mng_retcode iExtra1,
+                            mng_retcode iExtra2)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (pData, MNG_FN_PROCESS_ERROR, MNG_LC_START);
+#endif
+
+  mng_store_error (pData, iError, iExtra1, iExtra2);
+
+  if ((pData != MNG_NULL) && (pData->iMagic == MNG_MAGIC))
+  {
+    if (pData->fErrorproc)             /* callback defined ? */
+      return pData->fErrorproc (((mng_handle)pData), iError, pData->iSeverity,
+                                pData->iChunkname, pData->iChunkseq,
+                                pData->iErrorx1, pData->iErrorx2, pData->zErrortext);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (pData, MNG_FN_PROCESS_ERROR, MNG_LC_END);
+#endif
+
+  return MNG_TRUE;                     /* warnings are ignored by default ! */
+}
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_error.h b/src/3rdparty/libmng/libmng_error.h
new file mode 100644
index 0000000..b49ff73
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_error.h
@@ -0,0 +1,119 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_error.h            copyright (c) 2000-2002 G.Juyn   * */
+/* * version   : 1.0.5                                                      * */
+/* *                                                                        * */
+/* * purpose   : Error functions (definition)                               * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the generic error-codes and functions        * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - added some errorcodes                                    * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - added some errorcodes                                    * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added application errorcodes (used with callbacks)       * */
+/* *             - moved chunk-access errorcodes to severity 5              * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - added JNG errorcodes                                     * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - added error tell-tale definition                         * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added errorcodes for delta-image processing              * */
+/* *             0.5.2 - 06/06/2000 - G.Juyn                                * */
+/* *             - added errorcode for delayed buffer-processing            * */
+/* *             - moved errorcodes to "libmng.h"                           * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added macro + routine to set returncode without          * */
+/* *               calling error callback                                   * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 08/20/2002 - G.Juyn                                * */
+/* *             - added option for soft-handling of errors                 * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_error_h_
+#define _libmng_error_h_
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Default error routines                                                 * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_bool mng_store_error   (mng_datap   pData,
+                            mng_retcode iError,
+                            mng_retcode iExtra1,
+                            mng_retcode iExtra2);
+
+mng_bool mng_process_error (mng_datap   pData,
+                            mng_retcode iError,
+                            mng_retcode iExtra1,
+                            mng_retcode iExtra2);
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Error handling macros                                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_SOFTERRORS
+#define MNG_ERROR(D,C)      { if (!mng_process_error (D, C, 0, 0)) return C; }
+#define MNG_ERRORZ(D,Z)     { if (!mng_process_error (D, MNG_ZLIBERROR, Z, 0)) return MNG_ZLIBERROR; }
+#define MNG_ERRORJ(D,J)     { if (!mng_process_error (D, MNG_JPEGERROR, J, 0)) return MNG_JPEGERROR; }
+#define MNG_ERRORL(D,L)     { if (!mng_process_error (D, MNG_LCMSERROR, L, 0)) return MNG_LCMSERROR; }
+#else
+#define MNG_ERROR(D,C)      { mng_process_error (D, C, 0, 0); return C; }
+#define MNG_ERRORZ(D,Z)     { mng_process_error (D, MNG_ZLIBERROR, Z, 0); return MNG_ZLIBERROR; }
+#define MNG_ERRORJ(D,J)     { mng_process_error (D, MNG_JPEGERROR, J, 0); return MNG_JPEGERROR; }
+#define MNG_ERRORL(D,L)     { mng_process_error (D, MNG_LCMSERROR, L, 0); return MNG_LCMSERROR; }
+#endif
+
+#define MNG_RETURN(D,C)     { mng_store_error (D, C, 0, 0); return C; }
+
+#define MNG_WARNING(D,C)    { if (!mng_process_error (D, C, 0, 0)) return C; }
+
+#define MNG_VALIDHANDLE(H)  { if ((H == 0) || (((mng_datap)H)->iMagic != MNG_MAGIC)) \
+                                return MNG_INVALIDHANDLE; }
+#define MNG_VALIDHANDLEX(H) { if ((H == 0) || (((mng_datap)H)->iMagic != MNG_MAGIC)) \
+                                return 0; }
+#define MNG_VALIDCB(D,C)    { if (!((mng_datap)D)->C) \
+                                MNG_ERROR (((mng_datap)D), MNG_NOCALLBACK) }
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Error string-table entry                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef struct {
+                 mng_retcode iError;
+                 mng_pchar   zErrortext;
+               } mng_error_entry;
+typedef mng_error_entry const * mng_error_entryp;
+
+/* ************************************************************************** */
+
+#endif /* _libmng_error_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_filter.c b/src/3rdparty/libmng/libmng_filter.c
new file mode 100644
index 0000000..ed69a75
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_filter.c
@@ -0,0 +1,978 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_filter.c           copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : Filtering routines (implementation)                        * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the filtering routines                   * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/07/2002 - G.Juyn                                * */
+/* *             - added test-option for PNG filter method 193 (=no filter) * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - reversed some loops to use decrementing counter          * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_filter.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_FILTERS
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode filter_sub (mng_datap pData)
+{
+  mng_uint32 iBpp;
+  mng_uint8p pRawx;
+  mng_uint8p pRawx_prev;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_SUB, MNG_LC_START);
+#endif
+
+  iBpp       = pData->iFilterbpp;
+  pRawx      = pData->pWorkrow + pData->iPixelofs + iBpp;
+  pRawx_prev = pData->pWorkrow + pData->iPixelofs;
+
+  for (iX = iBpp; iX < pData->iRowsize; iX++)
+  {
+    *pRawx = (mng_uint8)(*pRawx + *pRawx_prev);
+    pRawx++;
+    pRawx_prev++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_SUB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode filter_up (mng_datap pData)
+{
+  mng_uint8p pRawx;
+  mng_uint8p pPriorx;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_UP, MNG_LC_START);
+#endif
+
+  pRawx   = pData->pWorkrow + pData->iPixelofs;
+  pPriorx = pData->pPrevrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsize - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsize; iX++)
+#endif
+  {
+    *pRawx = (mng_uint8)(*pRawx + *pPriorx);
+    pRawx++;
+    pPriorx++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_UP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode filter_average (mng_datap pData)
+{
+  mng_int32  iBpp;
+  mng_uint8p pRawx;
+  mng_uint8p pRawx_prev;
+  mng_uint8p pPriorx;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_AVERAGE, MNG_LC_START);
+#endif
+
+  iBpp       = pData->iFilterbpp;
+  pRawx      = pData->pWorkrow + pData->iPixelofs;
+  pPriorx    = pData->pPrevrow + pData->iPixelofs;
+  pRawx_prev = pData->pWorkrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = iBpp - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < iBpp; iX++)
+#endif
+  {
+    *pRawx = (mng_uint8)(*pRawx + ((*pPriorx) >> 1));
+    pRawx++;
+    pPriorx++;
+  }
+
+  for (iX = iBpp; iX < pData->iRowsize; iX++)
+  {
+    *pRawx = (mng_uint8)(*pRawx + ((*pRawx_prev + *pPriorx) >> 1));
+    pRawx++;
+    pPriorx++;
+    pRawx_prev++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_AVERAGE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode filter_paeth (mng_datap pData)
+{
+  mng_int32  iBpp;
+  mng_uint8p pRawx;
+  mng_uint8p pRawx_prev;
+  mng_uint8p pPriorx;
+  mng_uint8p pPriorx_prev;
+  mng_int32  iX;
+  mng_uint32 iA, iB, iC;
+  mng_uint32 iP;
+  mng_uint32 iPa, iPb, iPc;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_PAETH, MNG_LC_START);
+#endif
+
+  iBpp         = pData->iFilterbpp;
+  pRawx        = pData->pWorkrow + pData->iPixelofs;
+  pPriorx      = pData->pPrevrow + pData->iPixelofs;
+  pRawx_prev   = pData->pWorkrow + pData->iPixelofs;
+  pPriorx_prev = pData->pPrevrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = iBpp - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < iBpp; iX++)
+#endif
+  {
+    *pRawx = (mng_uint8)(*pRawx + *pPriorx);
+
+    pRawx++;
+    pPriorx++;
+  }
+
+  for (iX = iBpp; iX < pData->iRowsize; iX++)
+  {
+    iA  = (mng_uint32)*pRawx_prev;
+    iB  = (mng_uint32)*pPriorx;
+    iC  = (mng_uint32)*pPriorx_prev;
+    iP  = iA + iB - iC;
+    iPa = abs (iP - iA);
+    iPb = abs (iP - iB);
+    iPc = abs (iP - iC);
+
+    if ((iPa <= iPb) && (iPa <= iPc))
+      *pRawx = (mng_uint8)(*pRawx + iA);
+    else
+      if (iPb <= iPc)
+        *pRawx = (mng_uint8)(*pRawx + iB);
+      else
+        *pRawx = (mng_uint8)(*pRawx + iC);
+
+    pRawx++;
+    pPriorx++;
+    pRawx_prev++;
+    pPriorx_prev++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_PAETH, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_filter_a_row (mng_datap pData)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_A_ROW, MNG_LC_START);
+#endif
+
+  switch (*(pData->pWorkrow + pData->iFilterofs))
+  {
+    case 1  : {
+                iRetcode = filter_sub     (pData);
+                break;
+              }
+    case 2  : {
+                iRetcode = filter_up      (pData);
+                break;
+              }
+    case 3  : {
+                iRetcode = filter_average (pData);
+                break;
+              }
+    case 4  : {
+                iRetcode = filter_paeth   (pData);
+                break;
+              }
+
+    default : iRetcode = MNG_INVALIDFILTER;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FILTER_A_ROW, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifdef FILTER192
+mng_retcode mng_init_rowdiffering (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ROWDIFFERING, MNG_LC_START);
+#endif
+
+  if (pData->iFilter == 0xC0)          /* has leveling parameters ? */
+  {
+    switch (pData->iColortype)         /* salvage leveling parameters */
+    {
+      case 0 : {                       /* gray */
+                 if (pData->iBitdepth <= 8)
+                   pData->iLevel0 = (mng_uint16)*pData->pWorkrow;
+                 else
+                   pData->iLevel0 = mng_get_uint16 (pData->pWorkrow);
+
+                 break;
+               }
+      case 2 : {                       /* rgb */
+                 if (pData->iBitdepth <= 8)
+                 {
+                   pData->iLevel0 = (mng_uint16)*pData->pWorkrow;
+                   pData->iLevel1 = (mng_uint16)*(pData->pWorkrow+1);
+                   pData->iLevel2 = (mng_uint16)*(pData->pWorkrow+2);
+                 }
+                 else
+                 {
+                   pData->iLevel0 = mng_get_uint16 (pData->pWorkrow);
+                   pData->iLevel1 = mng_get_uint16 (pData->pWorkrow+2);
+                   pData->iLevel2 = mng_get_uint16 (pData->pWorkrow+4);
+                 }
+
+                 break;
+               }
+      case 3 : {                       /* indexed */
+                 pData->iLevel0 = (mng_uint16)*pData->pWorkrow;
+                 break;
+               }
+      case 4 : {                       /* gray+alpha */
+                 if (pData->iBitdepth <= 8)
+                 {
+                   pData->iLevel0 = (mng_uint16)*pData->pWorkrow;
+                   pData->iLevel1 = (mng_uint16)*(pData->pWorkrow+1);
+                 }
+                 else
+                 {
+                   pData->iLevel0 = mng_get_uint16 (pData->pWorkrow);
+                   pData->iLevel1 = mng_get_uint16 (pData->pWorkrow+2);
+                 }
+
+                 break;
+               }
+      case 6 : {                       /* rgb+alpha */
+                 if (pData->iBitdepth <= 8)
+                 {
+                   pData->iLevel0 = (mng_uint16)*pData->pWorkrow;
+                   pData->iLevel1 = (mng_uint16)*(pData->pWorkrow+1);
+                   pData->iLevel2 = (mng_uint16)*(pData->pWorkrow+2);
+                   pData->iLevel3 = (mng_uint16)*(pData->pWorkrow+3);
+                 }
+                 else
+                 {
+                   pData->iLevel0 = mng_get_uint16 (pData->pWorkrow);
+                   pData->iLevel1 = mng_get_uint16 (pData->pWorkrow+2);
+                   pData->iLevel2 = mng_get_uint16 (pData->pWorkrow+4);
+                   pData->iLevel3 = mng_get_uint16 (pData->pWorkrow+6);
+                 }
+
+                 break;
+               }
+    }
+  }
+                                       /* shift the entire row back in place */
+  pRawi = pData->pWorkrow + pData->iFilterofs;
+  pRawo = pData->pWorkrow;
+
+  for (iX = 0; iX < pData->iRowsize + pData->iPixelofs - pData->iFilterofs; iX++)
+    *pRawo++ = *pRawi++;
+
+  pData->iFilterofs = 0;               /* indicate so ! */
+
+#ifdef FILTER193
+  if (pData->iFilter == 0xC1)          /* no adaptive filtering ? */
+    pData->iPixelofs = pData->iFilterofs;
+  else
+#endif
+    pData->iPixelofs = pData->iFilterofs + 1;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ROWDIFFERING, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_g1 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G1, MNG_LC_START);
+#endif
+
+  if (pData->iLevel0 & 0x01)           /* is it uneven level ? */
+  {
+    pRawi = pData->pWorkrow + pData->iPixelofs;
+    pRawo = pData->pPrevrow + pData->iPixelofs;
+                                       /* just invert every bit */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsize - 1; iX >= 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsize; iX++)
+#endif
+      *pRawo++ = (mng_uint8)(~(*pRawi++));
+
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_g2 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+  mng_int32  iC, iS;
+  mng_uint8  iB, iN, iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G2, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+  iC    = 0;
+  iB    = 0;
+  iN    = 0;
+  iS    = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iC)
+    {
+      iC = 4;
+      iB = *pRawi++;
+      iN = 0;
+      iS = 8;
+    }
+
+    iS -= 2;
+    iQ = (mng_uint8)(((iB >> iS) + pData->iLevel0) & 0x03);
+    iN = (mng_uint8)((iN << 2) + iQ);
+    iC--;
+
+    if (!iC)
+      *pRawo++ = iN;
+
+  }
+
+  if (iC)
+    *pRawo = (mng_uint8)(iN << iS);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_g4 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+  mng_int32  iC, iS;
+  mng_uint8  iB, iN, iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G4, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+  iC    = 0;
+  iB    = 0;
+  iN    = 0;
+  iS    = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iC)
+    {
+      iC = 2;
+      iB = *pRawi++;
+      iN = 0;
+      iS = 8;
+    }
+
+    iS -= 4;
+    iQ = (mng_uint8)(((iB >> iS) + pData->iLevel0) & 0x0F);
+    iN = (mng_uint8)((iN << 4) + iQ);
+    iC--;
+
+    if (!iC)
+      *pRawo++ = iN;
+
+  }
+
+  if (iC)
+    *pRawo = (mng_uint8)(iN << iS);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_g8 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G8, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pRawo++ = (mng_uint8)(((mng_uint16)*pRawi + pData->iLevel0) & 0xFF);
+
+    pRawi++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_g16 (mng_datap pData)
+{
+  mng_uint16p pRawi, pRawo;
+  mng_int32   iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G16, MNG_LC_START);
+#endif
+
+  pRawi = (mng_uint16p)(pData->pWorkrow + pData->iPixelofs);
+  pRawo = (mng_uint16p)(pData->pPrevrow + pData->iPixelofs);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pRawo++ = (mng_uint16)(((mng_uint32)*pRawi + (mng_uint32)pData->iLevel0) & 0xFFFF);
+
+    pRawi++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_rgb8 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGB8, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pRawo+1) = (mng_uint8)(((mng_uint16)*(pRawi+1) + pData->iLevel1) & 0xFF);
+    *pRawo     = (mng_uint8)(((mng_uint16)*pRawi     + pData->iLevel0 +
+                              (mng_uint16)*(pRawo+1)) & 0xFF);
+    *(pRawo+2) = (mng_uint8)(((mng_uint16)*(pRawi+2) + pData->iLevel2 +
+                              (mng_uint16)*(pRawo+1)) & 0xFF);
+
+    pRawi += 3;
+    pRawo += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_rgb16 (mng_datap pData)
+{
+  mng_uint16p pRawi, pRawo;
+  mng_int32   iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGB16, MNG_LC_START);
+#endif
+
+  pRawi = (mng_uint16p)(pData->pWorkrow + pData->iPixelofs);
+  pRawo = (mng_uint16p)(pData->pPrevrow + pData->iPixelofs);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pRawo+1) = (mng_uint16)(((mng_uint32)*(pRawi+1) + (mng_uint32)pData->iLevel1) & 0xFFFF);
+    *pRawo     = (mng_uint16)(((mng_uint32)*pRawi     + (mng_uint32)pData->iLevel0 +
+                               (mng_uint32)*(pRawo+1)) & 0xFFFF);
+    *(pRawo+2) = (mng_uint16)(((mng_uint32)*(pRawi+2) + (mng_uint32)pData->iLevel2 +
+                               (mng_uint32)*(pRawo+1)) & 0xFFFF);
+
+    pRawi += 3;
+    pRawo += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_idx1 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX1, MNG_LC_START);
+#endif
+
+  if (pData->iLevel0 & 0x01)           /* is it uneven level ? */
+  {
+    pRawi = pData->pWorkrow + pData->iPixelofs;
+    pRawo = pData->pPrevrow + pData->iPixelofs;
+                                       /* just invert every bit */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsize - 1; iX >= 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsize; iX++)
+#endif
+      *pRawo++ = (mng_uint8)(~(*pRawi++));
+
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_idx2 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+  mng_int32  iC, iS;
+  mng_uint8  iB, iN, iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX2, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+  iC    = 0;
+  iB    = 0;
+  iN    = 0;
+  iS    = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iC)
+    {
+      iC = 4;
+      iB = *pRawi++;
+      iN = 0;
+      iS = 8;
+    }
+
+    iS -= 2;
+    iQ = (mng_uint8)(((iB >> iS) + pData->iLevel0) & 0x03);
+    iN = (mng_uint8)((iN << 2) + iQ);
+    iC--;
+
+    if (!iC)
+      *pRawo++ = iN;
+
+  }
+
+  if (iC)
+    *pRawo = (mng_uint8)(iN << iS);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_idx4 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+  mng_int32  iC, iS;
+  mng_uint8  iB, iN, iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX4, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+  iC    = 0;
+  iB    = 0;
+  iN    = 0;
+  iS    = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iC)
+    {
+      iC = 2;
+      iB = *pRawi++;
+      iN = 0;
+      iS = 8;
+    }
+
+    iS -= 4;
+    iQ = (mng_uint8)(((iB >> iS) + pData->iLevel0) & 0x0F);
+    iN = (mng_uint8)((iN << 4) + iQ);
+    iC--;
+
+    if (!iC)
+      *pRawo++ = iN;
+
+  }
+
+  if (iC)
+    *pRawo = (mng_uint8)(iN << iS);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_idx8 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX8, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pRawo++ = (mng_uint8)(((mng_uint16)*pRawi + pData->iLevel0) & 0xFF);
+
+    pRawi++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_IDX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_ga8 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_GA8, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pRawo     = (mng_uint8)(((mng_uint16)*pRawi     + pData->iLevel0) & 0xFF);
+    *(pRawo+1) = (mng_uint8)(((mng_uint16)*(pRawi+1) + pData->iLevel1) & 0xFF);
+
+    pRawi += 2;
+    pRawo += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_GA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_ga16 (mng_datap pData)
+{
+  mng_uint16p pRawi, pRawo;
+  mng_int32   iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_GA16, MNG_LC_START);
+#endif
+
+  pRawi = (mng_uint16p)(pData->pWorkrow + pData->iPixelofs);
+  pRawo = (mng_uint16p)(pData->pPrevrow + pData->iPixelofs);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pRawo     = (mng_uint16)(((mng_uint32)*pRawi     + (mng_uint32)pData->iLevel0) & 0xFFFF);
+    *(pRawo+1) = (mng_uint16)(((mng_uint32)*(pRawi+1) + (mng_uint32)pData->iLevel1) & 0xFFFF);
+
+    pRawi += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_rgba8 (mng_datap pData)
+{
+  mng_uint8p pRawi, pRawo;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGBA8, MNG_LC_START);
+#endif
+
+  pRawi = pData->pWorkrow + pData->iPixelofs;
+  pRawo = pData->pPrevrow + pData->iPixelofs;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pRawo+1) = (mng_uint8)(((mng_uint16)*(pRawi+1) + pData->iLevel1) & 0xFF);
+    *pRawo     = (mng_uint8)(((mng_uint16)*pRawi     + pData->iLevel0 +
+                              (mng_uint16)*(pRawo+1)) & 0xFF);
+    *(pRawo+2) = (mng_uint8)(((mng_uint16)*(pRawi+2) + pData->iLevel2 +
+                              (mng_uint16)*(pRawo+1)) & 0xFF);
+    *(pRawo+3) = (mng_uint8)(((mng_uint16)*(pRawi+3) + pData->iLevel3) & 0xFF);
+
+    pRawi += 4;
+    pRawo += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_differ_rgba16 (mng_datap pData)
+{
+  mng_uint16p pRawi, pRawo;
+  mng_int32   iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGBA16, MNG_LC_START);
+#endif
+
+  pRawi = (mng_uint16p)(pData->pWorkrow + pData->iPixelofs);
+  pRawo = (mng_uint16p)(pData->pPrevrow + pData->iPixelofs);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples - 1; iX >= 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pRawo+1) = (mng_uint16)(((mng_uint32)*(pRawi+1) + (mng_uint32)pData->iLevel1) & 0xFFFF);
+    *pRawo     = (mng_uint16)(((mng_uint32)*pRawi     + (mng_uint32)pData->iLevel0 +
+                               (mng_uint32)*(pRawo+1)) & 0xFFFF);
+    *(pRawo+2) = (mng_uint16)(((mng_uint32)*(pRawi+2) + (mng_uint32)pData->iLevel2 +
+                               (mng_uint32)*(pRawo+1)) & 0xFFFF);
+    *(pRawo+3) = (mng_uint16)(((mng_uint32)*(pRawi+3) + (mng_uint32)pData->iLevel3) & 0xFFFF);
+
+    pRawi += 4;
+    pRawo += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DIFFER_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* FILTER192 */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_FILTERS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_filter.h b/src/3rdparty/libmng/libmng_filter.h
new file mode 100644
index 0000000..9ac9c7f
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_filter.h
@@ -0,0 +1,69 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_filter.h           copyright (c) 2000-2002 G.Juyn   * */
+/* * version   : 1.0.5                                                      * */
+/* *                                                                        * */
+/* * purpose   : Filtering routines (definition)                            * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the filtering routines                       * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_filter_h_
+#define _libmng_filter_h_
+
+/* ************************************************************************** */
+
+mng_retcode mng_filter_a_row         (mng_datap pData);
+
+/* ************************************************************************** */
+
+#ifdef FILTER192
+mng_retcode mng_init_rowdiffering    (mng_datap pData);
+
+mng_retcode mng_differ_g1            (mng_datap pData);
+mng_retcode mng_differ_g2            (mng_datap pData);
+mng_retcode mng_differ_g4            (mng_datap pData);
+mng_retcode mng_differ_g8            (mng_datap pData);
+mng_retcode mng_differ_g16           (mng_datap pData);
+mng_retcode mng_differ_rgb8          (mng_datap pData);
+mng_retcode mng_differ_rgb16         (mng_datap pData);
+mng_retcode mng_differ_idx1          (mng_datap pData);
+mng_retcode mng_differ_idx2          (mng_datap pData);
+mng_retcode mng_differ_idx4          (mng_datap pData);
+mng_retcode mng_differ_idx8          (mng_datap pData);
+mng_retcode mng_differ_ga8           (mng_datap pData);
+mng_retcode mng_differ_ga16          (mng_datap pData);
+mng_retcode mng_differ_rgba8         (mng_datap pData);
+mng_retcode mng_differ_rgba16        (mng_datap pData);
+#endif
+
+/* ************************************************************************** */
+
+#endif /* _libmng_filter_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_hlapi.c b/src/3rdparty/libmng/libmng_hlapi.c
new file mode 100644
index 0000000..e710347
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_hlapi.c
@@ -0,0 +1,3001 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_hlapi.c            copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : high-level application API (implementation)                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the high-level function interface        * */
+/* *             for applications.                                          * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - added init of iPLTEcount                                 * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed calling-convention definition                    * */
+/* *             - changed status-handling of display-routines              * */
+/* *             - added versioning-control routines                        * */
+/* *             - filled the write routine                                 * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added callback error-reporting support                   * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *             0.5.1 - 05/13/2000 - G.Juyn                                * */
+/* *             - added eMNGma hack (will be removed in 1.0.0 !!!)         * */
+/* *             - added TERM animation object pointer (easier reference)   * */
+/* *             0.5.1 - 05/14/2000 - G.Juyn                                * */
+/* *             - added cleanup of saved-data (SAVE/SEEK processing)       * */
+/* *             0.5.1 - 05/16/2000 - G.Juyn                                * */
+/* *             - moved the actual write_graphic functionality from here   * */
+/* *               to its appropriate function in the mng_write module      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/19/2000 - G.Juyn                                * */
+/* *             - cleaned up some code regarding mixed support             * */
+/* *             - added JNG support                                        * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - moved init of default zlib parms here from "mng_zlib.c"  * */
+/* *             - added init of default IJG parms                          * */
+/* *             0.5.2 - 05/29/2000 - G.Juyn                                * */
+/* *             - fixed inconsistancy with freeing global iCCP profile     * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added delta-image field initialization                   * */
+/* *             0.5.2 - 06/06/2000 - G.Juyn                                * */
+/* *             - added initialization of the buffer-suspend parameter     * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - added initialization of update-region for refresh        * */
+/* *             - added initialization of Needrefresh parameter            * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - added initialization of Deltaimmediate                   * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added initialization of Speed                            * */
+/* *             - added initialization of Imagelevel                       * */
+/* *             0.5.3 - 06/26/2000 - G.Juyn                                * */
+/* *             - changed userdata variable to mng_ptr                     * */
+/* *             0.5.3 - 06/29/2000 - G.Juyn                                * */
+/* *             - fixed initialization routine for new mng_handle type     * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/06/2000 - G.Juyn                                * */
+/* *             - changed mng_display_resume to allow to be called after   * */
+/* *               a suspension return with MNG_NEEDMOREDATA                * */
+/* *             - added returncode MNG_NEEDTIMERWAIT for timer breaks      * */
+/* *             0.9.1 - 07/07/2000 - G.Juyn                                * */
+/* *             - implemented support for freeze/reset/resume & go_xxxx    * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - added support for improved timing                        * */
+/* *             - added support for improved I/O-suspension                * */
+/* *             0.9.1 - 07/14/2000 - G.Juyn                                * */
+/* *             - changed EOF processing behavior                          * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added callbacks for SAVE/SEEK processing                 * */
+/* *             - added variable for NEEDSECTIONWAIT breaks                * */
+/* *             - added variable for freeze & reset processing             * */
+/* *             0.9.1 - 07/17/2000 - G.Juyn                                * */
+/* *             - added error cleanup processing                           * */
+/* *             - fixed support for mng_display_reset()                    * */
+/* *             - fixed suspension-buffering for 32K+ chunks               * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/29/2000 - G.Juyn                                * */
+/* *             - fixed small bugs in display processing                   * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - fixed wrapping of suspension parameters                  * */
+/* *             0.9.2 - 08/04/2000 - G.Juyn                                * */
+/* *             - B111096 - fixed large-buffer read-suspension             * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 09/10/2000 - G.Juyn                                * */
+/* *             - fixed DEFI behavior                                      * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added optional support for bKGD for PNG images           * */
+/* *             - raised initial maximum canvas size                       * */
+/* *             - added support for JDAA                                   * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *             - fixed support for delta-images during read() / display() * */
+/* *             0.9.3 - 10/18/2000 - G.Juyn                                * */
+/* *             - added closestream() processing for mng_cleanup()         * */
+/* *             0.9.3 - 10/27/2000 - G.Juyn                                * */
+/* *             - fixed separate read() & display() processing             * */
+/* *                                                                        * */
+/* *             0.9.4 - 11/20/2000 - G.Juyn                                * */
+/* *             - fixed unwanted repetition in mng_readdisplay()           * */
+/* *             0.9.4 - 11/24/2000 - G.Juyn                                * */
+/* *             - moved restore of object 0 to libmng_display              * */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *             1.0.1 - 02/13/2001 - G.Juyn                                * */
+/* *             - fixed first FRAM_MODE=4 timing problem                   * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn                                * */
+/* *             - fixed bug with display_reset/display_resume (Thanks G!)  * */
+/* *             1.0.1 - 04/22/2001 - G.Juyn                                * */
+/* *             - fixed memory-leak (Thanks Gregg!)                        * */
+/* *             1.0.1 - 04/23/2001 - G.Juyn                                * */
+/* *             - fixed reset_rundata to drop all objects                  * */
+/* *             1.0.1 - 04/25/2001 - G.Juyn                                * */
+/* *             - moved mng_clear_cms to libmng_cms                        * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *             - added processterm callback                               * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - added option to turn off progressive refresh             * */
+/* *                                                                        * */
+/* *             1.0.5 - 07/08/2002 - G.Juyn                                * */
+/* *             - B578572 - removed eMNGma hack (thanks Dimitri!)          * */
+/* *             1.0.5 - 07/16/2002 - G.Juyn                                * */
+/* *             - B581625 - large chunks fail with suspension reads        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - fixed LOOP iteration=0 special case                      * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - added another fix for misplaced TERM chunk               * */
+/* *             - completed support for condition=2 in TERM chunk          * */
+/* *             - added beta version function & constant                   * */
+/* *             1.0.5 - 10/11/2002 - G.Juyn                                * */
+/* *             - added mng_status_dynamic to supports function            * */
+/* *             1.0.5 - 11/04/2002 - G.Juyn                                * */
+/* *             - changed FRAMECOUNT/LAYERCOUNT/PLAYTIME error to warning  * */
+/* *             1.0.5 - 11/07/2002 - G.Juyn                                * */
+/* *             - added support to get totals after mng_read()             * */
+/* *             1.0.5 - 11/29/2002 - G.Juyn                                * */
+/* *             - fixed goxxxxx() support for zero values                  * */
+/* *                                                                        * */
+/* *             1.0.6 - 05/25/2003 - G.R-P                                 * */
+/* *             - added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             1.0.6 - 07/11/2003 - G.R-P                                 * */
+/* *             - added conditionals zlib and jpeg property accessors      * */
+/* *             1.0.6 - 07/14/2003 - G.R-P                                 * */
+/* *             - added conditionals around "mng_display_go*" and other    * */
+/* *               unused functions                                         * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/07/2004 - G. Randers-Pehrson                    * */
+/* *             - put gamma, cms-related declarations inside #ifdef        * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - fixed zTXT -> zTXt typo                                  * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/02/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *             1.0.8 - 04/10/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *             1.0.8 - 07/06/2004 - G.R-P                                 * */
+/* *             - defend against using undefined openstream function       * */
+/* *             1.0.8 - 08/02/2004 - G.Juyn                                * */
+/* *             - added conditional to allow easier writing of large MNG's * */
+/* *                                                                        * */
+/* *             1.0.9 - 08/17/2004 - G.R-P                                 * */
+/* *             - added more SKIPCHUNK conditionals                        * */
+/* *             1.0.9 - 09/25/2004 - G.Juyn                                * */
+/* *             - replaced MNG_TWEAK_LARGE_FILES with permanent solution   * */
+/* *             1.0.9 - 10/03/2004 - G.Juyn                                * */
+/* *             - added function to retrieve current FRAM delay            * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* *             1.0.10 - 07/06/2005 - G.R-P                                * */
+/* *             - added more SKIPCHUNK conditionals                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *             1.0.10 - 07/06/2007 - G.R-P bugfix by Lucas Quintana       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_objects.h"
+#include "libmng_object_prc.h"
+#include "libmng_chunks.h"
+#include "libmng_memory.h"
+#include "libmng_read.h"
+#include "libmng_write.h"
+#include "libmng_display.h"
+#include "libmng_zlib.h"
+#include "libmng_jpeg.h"
+#include "libmng_cms.h"
+#include "libmng_pixels.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * local routines                                                         * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_LOCAL mng_retcode mng_drop_objects (mng_datap pData,
+                                        mng_bool  bDropaniobj)
+{
+  mng_objectp       pObject;
+  mng_objectp       pNext;
+  mng_cleanupobject fCleanup;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_OBJECTS, MNG_LC_START);
+#endif
+
+  pObject = pData->pFirstimgobj;       /* get first stored image-object (if any) */
+
+  while (pObject)                      /* more objects to discard ? */
+  {
+    pNext = ((mng_object_headerp)pObject)->pNext;
+                                       /* call appropriate cleanup */
+    fCleanup = ((mng_object_headerp)pObject)->fCleanup;
+    fCleanup (pData, pObject);
+
+    pObject = pNext;                   /* neeeext */
+  }
+
+  pData->pFirstimgobj = MNG_NULL;      /* clean this up!!! */
+  pData->pLastimgobj  = MNG_NULL;
+
+  if (bDropaniobj)                     /* drop animation objects ? */
+  {
+    pObject = pData->pFirstaniobj;     /* get first stored animation-object (if any) */
+
+    while (pObject)                    /* more objects to discard ? */
+    {
+      pNext = ((mng_object_headerp)pObject)->pNext;
+                                       /* call appropriate cleanup */
+      fCleanup = ((mng_object_headerp)pObject)->fCleanup;
+      fCleanup (pData, pObject);
+
+      pObject = pNext;                 /* neeeext */
+    }
+
+    pData->pFirstaniobj = MNG_NULL;    /* clean this up!!! */
+    pData->pLastaniobj  = MNG_NULL;
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+    pObject = pData->pFirstevent;      /* get first event-object (if any) */
+
+    while (pObject)                    /* more objects to discard ? */
+    {
+      pNext = ((mng_object_headerp)pObject)->pNext;
+                                       /* call appropriate cleanup */
+      fCleanup = ((mng_object_headerp)pObject)->fCleanup;
+      fCleanup (pData, pObject);
+
+      pObject = pNext;                 /* neeeext */
+    }
+
+    pData->pFirstevent = MNG_NULL;     /* clean this up!!! */
+    pData->pLastevent  = MNG_NULL;
+#endif
+  }
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+  if (pData->pMPNG)                    /* drop MPNG data (if any) */
+  {
+    fCleanup = ((mng_object_headerp)pData->pMPNG)->fCleanup;
+    fCleanup (pData, pData->pMPNG);
+    pData->pMPNG = MNG_NULL;
+  }
+#endif
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+  if (pData->pANG)                     /* drop ANG data (if any) */
+  {
+    fCleanup = ((mng_object_headerp)pData->pANG)->fCleanup;
+    fCleanup (pData, pData->pANG);
+    pData->pANG = MNG_NULL;
+  }
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_OBJECTS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_SKIPCHUNK_SAVE
+MNG_LOCAL mng_retcode mng_drop_savedata (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_SAVEDATA, MNG_LC_START);
+#endif
+
+  if (pData->pSavedata)                /* sanity check */
+  {                                    /* address it more directly */
+    mng_savedatap pSave = pData->pSavedata;
+
+    if (pSave->iGlobalProfilesize)     /* cleanup the profile ? */
+      MNG_FREEX (pData, pSave->pGlobalProfile, pSave->iGlobalProfilesize);
+                                       /* cleanup the save structure */
+    MNG_FREE (pData, pData->pSavedata, sizeof (mng_savedata));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_SAVEDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+MNG_LOCAL mng_retcode mng_reset_rundata (mng_datap pData)
+{
+  mng_drop_invalid_objects (pData);    /* drop invalidly stored objects */
+#ifndef MNG_SKIPCHUNK_SAVE
+  mng_drop_savedata        (pData);    /* drop stored savedata */
+#endif
+  mng_reset_objzero        (pData);    /* reset object 0 */
+                                       /* drop stored objects (if any) */
+  mng_drop_objects         (pData, MNG_FALSE);
+
+  pData->bFramedone            = MNG_FALSE;
+  pData->iFrameseq             = 0;    /* reset counters & stuff */
+  pData->iLayerseq             = 0;
+  pData->iFrametime            = 0;
+
+  pData->bSkipping             = MNG_FALSE;
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+  pData->bRunningevent         = MNG_FALSE;
+  pData->bStopafterseek        = MNG_FALSE;
+  pData->iEventx               = 0;
+  pData->iEventy               = 0;
+  pData->pLastmousemove        = MNG_NULL;
+#endif
+
+  pData->iRequestframe         = 0;
+  pData->iRequestlayer         = 0;
+  pData->iRequesttime          = 0;
+  pData->bSearching            = MNG_FALSE;
+
+  pData->iRuntime              = 0;
+  pData->iSynctime             = 0;
+  pData->iStarttime            = 0;
+  pData->iEndtime              = 0;
+  pData->bRunning              = MNG_FALSE;
+  pData->bTimerset             = MNG_FALSE;
+  pData->iBreakpoint           = 0;
+  pData->bSectionwait          = MNG_FALSE;
+  pData->bFreezing             = MNG_FALSE;
+  pData->bResetting            = MNG_FALSE;
+  pData->bNeedrefresh          = MNG_FALSE;
+  pData->bOnlyfirstframe       = MNG_FALSE;
+  pData->iFramesafterTERM      = 0;
+
+  pData->iIterations           = 0;
+                                       /* start of animation objects! */
+  pData->pCurraniobj           = MNG_NULL;
+
+  pData->iUpdateleft           = 0;    /* reset region */
+  pData->iUpdateright          = 0;
+  pData->iUpdatetop            = 0;
+  pData->iUpdatebottom         = 0;
+  pData->iPLTEcount            = 0;    /* reset PLTE data */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+  pData->iDEFIobjectid         = 0;    /* reset DEFI data */
+  pData->bDEFIhasdonotshow     = MNG_FALSE;
+  pData->iDEFIdonotshow        = 0;
+  pData->bDEFIhasconcrete      = MNG_FALSE;
+  pData->iDEFIconcrete         = 0;
+  pData->bDEFIhasloca          = MNG_FALSE;
+  pData->iDEFIlocax            = 0;
+  pData->iDEFIlocay            = 0;
+  pData->bDEFIhasclip          = MNG_FALSE;
+  pData->iDEFIclipl            = 0;
+  pData->iDEFIclipr            = 0;
+  pData->iDEFIclipt            = 0;
+  pData->iDEFIclipb            = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_BACK
+  pData->iBACKred              = 0;    /* reset BACK data */
+  pData->iBACKgreen            = 0;
+  pData->iBACKblue             = 0;
+  pData->iBACKmandatory        = 0;
+  pData->iBACKimageid          = 0;
+  pData->iBACKtile             = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+  pData->iFRAMmode             = 1;     /* default global FRAM variables */
+  pData->iFRAMdelay            = 1;
+  pData->iFRAMtimeout          = 0x7fffffffl;
+  pData->bFRAMclipping         = MNG_FALSE;
+  pData->iFRAMclipl            = 0;
+  pData->iFRAMclipr            = 0;
+  pData->iFRAMclipt            = 0;
+  pData->iFRAMclipb            = 0;
+
+  pData->iFramemode            = 1;     /* again for the current frame */
+  pData->iFramedelay           = 1;
+  pData->iFrametimeout         = 0x7fffffffl;
+  pData->bFrameclipping        = MNG_FALSE;
+  pData->iFrameclipl           = 0;
+  pData->iFrameclipr           = 0;
+  pData->iFrameclipt           = 0;
+  pData->iFrameclipb           = 0;
+
+  pData->iNextdelay            = 1;
+
+  pData->bForcedelay           = MNG_FALSE;
+  pData->iAccumdelay           = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_SHOW
+  pData->iSHOWmode             = 0;    /* reset SHOW data */
+  pData->iSHOWfromid           = 0;
+  pData->iSHOWtoid             = 0;
+  pData->iSHOWnextid           = 0;
+  pData->iSHOWskip             = 0;
+#endif
+
+  pData->iGlobalPLTEcount      = 0;    /* reset global PLTE data */
+
+  pData->iGlobalTRNSrawlen     = 0;    /* reset global tRNS data */
+
+  pData->iGlobalGamma          = 0;    /* reset global gAMA data */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+  pData->iGlobalWhitepointx    = 0;    /* reset global cHRM data */
+  pData->iGlobalWhitepointy    = 0;
+  pData->iGlobalPrimaryredx    = 0;
+  pData->iGlobalPrimaryredy    = 0;
+  pData->iGlobalPrimarygreenx  = 0;
+  pData->iGlobalPrimarygreeny  = 0;
+  pData->iGlobalPrimarybluex   = 0;
+  pData->iGlobalPrimarybluey   = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_sRGB
+  pData->iGlobalRendintent     = 0;    /* reset global sRGB data */
+#endif
+
+#ifndef MNG_SKIPCHUNK_iCCP
+  if (pData->iGlobalProfilesize)       /* drop global profile (if any) */
+    MNG_FREE (pData, pData->pGlobalProfile, pData->iGlobalProfilesize);
+
+  pData->iGlobalProfilesize    = 0;    
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+  pData->iGlobalBKGDred        = 0;    /* reset global bKGD data */
+  pData->iGlobalBKGDgreen      = 0;
+  pData->iGlobalBKGDblue       = 0;
+#endif
+#ifndef MNG_NO_DELTA_PNG
+                                       /* reset delta-image */
+  pData->pDeltaImage           = MNG_NULL;
+  pData->iDeltaImagetype       = 0;
+  pData->iDeltatype            = 0;
+  pData->iDeltaBlockwidth      = 0;
+  pData->iDeltaBlockheight     = 0;
+  pData->iDeltaBlockx          = 0;
+  pData->iDeltaBlocky          = 0;
+  pData->bDeltaimmediate       = MNG_FALSE;
+
+  pData->fDeltagetrow          = MNG_NULL;
+  pData->fDeltaaddrow          = MNG_NULL;
+  pData->fDeltareplacerow      = MNG_NULL;
+  pData->fDeltaputrow          = MNG_NULL;
+
+  pData->fPromoterow           = MNG_NULL;
+  pData->fPromBitdepth         = MNG_NULL;
+  pData->pPromBuf              = MNG_NULL;
+  pData->iPromColortype        = 0;
+  pData->iPromBitdepth         = 0;
+  pData->iPromFilltype         = 0;
+  pData->iPromWidth            = 0;
+  pData->pPromSrc              = MNG_NULL;
+  pData->pPromDst              = MNG_NULL;
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+  pData->iMAGNfromid           = 0;
+  pData->iMAGNtoid             = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+  pData->iPastx                = 0;
+  pData->iPasty                = 0;
+#endif
+
+  pData->pLastseek             = MNG_NULL;
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+MNG_LOCAL void cleanup_errors (mng_datap pData)
+{
+  pData->iErrorcode = MNG_NOERROR;
+  pData->iSeverity  = 0;
+  pData->iErrorx1   = 0;
+  pData->iErrorx2   = 0;
+  pData->zErrortext = MNG_NULL;
+
+  return;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+MNG_LOCAL mng_retcode make_pushbuffer (mng_datap       pData,
+                                       mng_ptr         pPushdata,
+                                       mng_size_t      iLength,
+                                       mng_bool        bTakeownership,
+                                       mng_pushdatap * pPush)
+{
+  mng_pushdatap pTemp;
+
+  MNG_ALLOC (pData, pTemp, sizeof(mng_pushdata));
+
+  pTemp->pNext      = MNG_NULL;
+
+  if (bTakeownership)                  /* are we going to own the buffer? */
+  {                                    /* then just copy the pointer */
+    pTemp->pData    = (mng_uint8p)pPushdata;
+  }
+  else
+  {                                    /* otherwise create new buffer */
+    MNG_ALLOCX (pData, pTemp->pData, iLength);
+    if (!pTemp->pData)                 /* succeeded? */
+    {
+      MNG_FREEX (pData, pTemp, sizeof(mng_pushdata));
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+                                       /* and copy the bytes across */
+    MNG_COPY (pTemp->pData, pPushdata, iLength);
+  }
+
+  pTemp->iLength    = iLength;
+  pTemp->bOwned     = bTakeownership;
+  pTemp->pDatanext  = pTemp->pData;
+  pTemp->iRemaining = iLength;
+
+  *pPush            = pTemp;           /* return it */
+
+  return MNG_NOERROR;                  /* and all's well */
+}
+#endif
+
+#ifdef MNG_VERSION_QUERY_SUPPORT
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Versioning control                                                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_pchar MNG_DECL mng_version_text    (void)
+{
+  return MNG_VERSION_TEXT;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_version_so      (void)
+{
+  return MNG_VERSION_SO;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_version_dll     (void)
+{
+  return MNG_VERSION_DLL;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_version_major   (void)
+{
+  return MNG_VERSION_MAJOR;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_version_minor   (void)
+{
+  return MNG_VERSION_MINOR;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_version_release (void)
+{
+  return MNG_VERSION_RELEASE;
+}
+
+/* ************************************************************************** */
+
+mng_bool MNG_DECL mng_version_beta (void)
+{
+  return MNG_VERSION_BETA;
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * 'supports' function                                                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_FUNCQUERY
+typedef struct {
+                 mng_pchar  zFunction;
+                 mng_uint8  iMajor;    /* Major == 0 means not implemented ! */ 
+                 mng_uint8  iMinor;
+                 mng_uint8  iRelease;
+               } mng_func_entry;
+typedef mng_func_entry const * mng_func_entryp;
+
+MNG_LOCAL mng_func_entry const func_table [] =
+  {                                    /* keep it alphabetically sorted !!!!! */
+    {"mng_cleanup",                1, 0, 0},
+    {"mng_copy_chunk",             1, 0, 5},
+    {"mng_create",                 1, 0, 0},
+    {"mng_display",                1, 0, 0},
+    {"mng_display_freeze",         1, 0, 0},
+#ifndef MNG_NO_DISPLAY_GO_SUPPORTED
+    {"mng_display_goframe",        1, 0, 0},
+    {"mng_display_golayer",        1, 0, 0},
+    {"mng_display_gotime",         1, 0, 0},
+#endif
+    {"mng_display_reset",          1, 0, 0},
+    {"mng_display_resume",         1, 0, 0},
+    {"mng_get_alphabitdepth",      1, 0, 0},
+    {"mng_get_alphacompression",   1, 0, 0},
+    {"mng_get_alphadepth",         1, 0, 0},
+    {"mng_get_alphafilter",        1, 0, 0},
+    {"mng_get_alphainterlace",     1, 0, 0},
+    {"mng_get_bgcolor",            1, 0, 0},
+    {"mng_get_bitdepth",           1, 0, 0},
+    {"mng_get_bkgdstyle",          1, 0, 0},
+    {"mng_get_cacheplayback",      1, 0, 2},
+    {"mng_get_canvasstyle",        1, 0, 0},
+    {"mng_get_colortype",          1, 0, 0},
+    {"mng_get_compression",        1, 0, 0},
+#ifndef MNG_NO_CURRENT_INFO
+    {"mng_get_currentframe",       1, 0, 0},
+    {"mng_get_currentlayer",       1, 0, 0},
+    {"mng_get_currentplaytime",    1, 0, 0},
+#endif
+    {"mng_get_currframdelay",      1, 0, 9},
+#ifndef MNG_NO_DFLT_INFO
+    {"mng_get_dfltimggamma",       1, 0, 0},
+    {"mng_get_dfltimggammaint",    1, 0, 0},
+#endif
+    {"mng_get_displaygamma",       1, 0, 0},
+    {"mng_get_displaygammaint",    1, 0, 0},
+    {"mng_get_doprogressive",      1, 0, 2},
+    {"mng_get_filter",             1, 0, 0},
+    {"mng_get_framecount",         1, 0, 0},
+    {"mng_get_imageheight",        1, 0, 0},
+    {"mng_get_imagelevel",         1, 0, 0},
+    {"mng_get_imagetype",          1, 0, 0},
+    {"mng_get_imagewidth",         1, 0, 0},
+    {"mng_get_interlace",          1, 0, 0},
+#ifdef MNG_ACCESS_JPEG
+    {"mng_get_jpeg_dctmethod",     1, 0, 0},
+    {"mng_get_jpeg_maxjdat",       1, 0, 0},
+    {"mng_get_jpeg_optimized",     1, 0, 0},
+    {"mng_get_jpeg_progressive",   1, 0, 0},
+    {"mng_get_jpeg_quality",       1, 0, 0},
+    {"mng_get_jpeg_smoothing",     1, 0, 0},
+#endif
+    {"mng_get_lastbackchunk",      1, 0, 3},
+    {"mng_get_lastseekname",       1, 0, 5},
+    {"mng_get_layercount",         1, 0, 0},
+#ifndef MNG_SKIP_MAXCANVAS
+    {"mng_get_maxcanvasheight",    1, 0, 0},
+    {"mng_get_maxcanvaswidth",     1, 0, 0},
+#endif
+    {"mng_get_playtime",           1, 0, 0},
+    {"mng_get_refreshpass",        1, 0, 0},
+    {"mng_get_runtime",            1, 0, 0},
+    {"mng_get_sectionbreaks",      1, 0, 0},
+    {"mng_get_sigtype",            1, 0, 0},
+    {"mng_get_simplicity",         1, 0, 0},
+    {"mng_get_speed",              1, 0, 0},
+    {"mng_get_srgb",               1, 0, 0},
+    {"mng_get_starttime",          1, 0, 0},
+    {"mng_get_storechunks",        1, 0, 0},
+    {"mng_get_suspensionmode",     1, 0, 0},
+    {"mng_get_ticks",              1, 0, 0},
+#ifndef MNG_NO_CURRENT_INFO
+    {"mng_get_totalframes",        1, 0, 5},
+    {"mng_get_totallayers",        1, 0, 5},
+    {"mng_get_totalplaytime",      1, 0, 5},
+#endif
+    {"mng_get_usebkgd",            1, 0, 0},
+    {"mng_get_userdata",           1, 0, 0},
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+    {"mng_get_viewgamma",          1, 0, 0},
+    {"mng_get_viewgammaint",       1, 0, 0},
+#endif
+#ifdef MNG_ACCESS_ZLIB
+    {"mng_get_zlib_level",         1, 0, 0},
+    {"mng_get_zlib_maxidat",       1, 0, 0},
+    {"mng_get_zlib_memlevel",      1, 0, 0},
+    {"mng_get_zlib_method",        1, 0, 0},
+    {"mng_get_zlib_strategy",      1, 0, 0},
+    {"mng_get_zlib_windowbits",    1, 0, 0},
+#endif
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+    {"mng_getcb_closestream",      1, 0, 0},
+#endif
+    {"mng_getcb_errorproc",        1, 0, 0},
+    {"mng_getcb_getalphaline",     1, 0, 0},
+    {"mng_getcb_getbkgdline",      1, 0, 0},
+    {"mng_getcb_getcanvasline",    1, 0, 0},
+    {"mng_getcb_gettickcount",     1, 0, 0},
+    {"mng_getcb_memalloc",         1, 0, 0},
+    {"mng_getcb_memfree",          1, 0, 0},
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+    {"mng_getcb_openstream",       1, 0, 0},
+#endif
+    {"mng_getcb_processarow",      1, 0, 0},
+    {"mng_getcb_processchroma",    1, 0, 0},
+    {"mng_getcb_processgamma",     1, 0, 0},
+    {"mng_getcb_processheader",    1, 0, 0},
+    {"mng_getcb_processiccp",      1, 0, 0},
+    {"mng_getcb_processmend",      1, 0, 1},
+    {"mng_getcb_processneed",      1, 0, 0},
+    {"mng_getcb_processsave",      1, 0, 0},
+    {"mng_getcb_processseek",      1, 0, 0},
+    {"mng_getcb_processsrgb",      1, 0, 0},
+    {"mng_getcb_processterm",      1, 0, 2},
+    {"mng_getcb_processtext",      1, 0, 0},
+    {"mng_getcb_processunknown",   1, 0, 0},
+    {"mng_getcb_readdata",         1, 0, 0},
+    {"mng_getcb_refresh",          1, 0, 0},
+    {"mng_getcb_releasedata",      1, 0, 8},
+    {"mng_getcb_settimer",         1, 0, 0},
+    {"mng_getcb_traceproc",        1, 0, 0},
+    {"mng_getcb_writedata",        1, 0, 0},
+    {"mng_getchunk_back",          1, 0, 0},
+    {"mng_getchunk_basi",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_bKGD
+    {"mng_getchunk_bkgd",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_cHRM
+    {"mng_getchunk_chrm",          1, 0, 0},
+#endif
+    {"mng_getchunk_clip",          1, 0, 0},
+    {"mng_getchunk_clon",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_dBYK
+    {"mng_getchunk_dbyk",          1, 0, 0},
+#endif
+#endif
+    {"mng_getchunk_defi",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+    {"mng_getchunk_dhdr",          1, 0, 0},
+#endif
+    {"mng_getchunk_disc",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+    {"mng_getchunk_drop",          1, 0, 0},
+#endif
+    {"mng_getchunk_endl",          1, 0, 0},
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {"mng_getchunk_mpng",          1, 0, 10},
+    {"mng_getchunk_mpng_frame",    1, 0, 10},
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {"mng_getchunk_evnt",          1, 0, 5},
+    {"mng_getchunk_evnt_entry",    1, 0, 5},
+#endif
+#ifndef MNG_SKIPCHUNK_eXPI
+    {"mng_getchunk_expi",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+    {"mng_getchunk_fpri",          1, 0, 0},
+#endif
+    {"mng_getchunk_fram",          1, 0, 0},
+    {"mng_getchunk_gama",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_hIST
+    {"mng_getchunk_hist",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+    {"mng_getchunk_iccp",          1, 0, 0},
+#endif
+    {"mng_getchunk_idat",          1, 0, 0},
+    {"mng_getchunk_iend",          1, 0, 0},
+    {"mng_getchunk_ihdr",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+    {"mng_getchunk_ijng",          1, 0, 0},
+#endif
+    {"mng_getchunk_ipng",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+    {"mng_getchunk_itxt",          1, 0, 0},
+#endif
+#ifdef MNG_INCLUDE_JNG
+    {"mng_getchunk_jdaa",          1, 0, 0},
+    {"mng_getchunk_jdat",          1, 0, 0},
+    {"mng_getchunk_jhdr",          1, 0, 0},
+    {"mng_getchunk_jsep",          1, 0, 0},
+#endif
+    {"mng_getchunk_loop",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_MAGN
+    {"mng_getchunk_magn",          1, 0, 0},
+#endif
+    {"mng_getchunk_mend",          1, 0, 0},
+    {"mng_getchunk_mhdr",          1, 0, 0},
+    {"mng_getchunk_move",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_nEED
+    {"mng_getchunk_need",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_ORDR
+#ifndef MNG_NO_DELTA_PNG
+    {"mng_getchunk_ordr",          1, 0, 0},
+    {"mng_getchunk_ordr_entry",    1, 0, 0},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+    {"mng_getchunk_past",          1, 0, 0},
+    {"mng_getchunk_past_src",      1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYg
+    {"mng_getchunk_phyg",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+    {"mng_getchunk_phys",          1, 0, 0},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {"mng_getchunk_plte",          1, 0, 0},
+    {"mng_getchunk_pplt",          1, 0, 0},
+    {"mng_getchunk_pplt_entry",    1, 0, 0},
+    {"mng_getchunk_prom",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+    {"mng_getchunk_save",          1, 0, 0},
+    {"mng_getchunk_save_entry",    1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+    {"mng_getchunk_sbit",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+    {"mng_getchunk_seek",          1, 0, 0},
+#endif
+    {"mng_getchunk_show",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_sPLT
+    {"mng_getchunk_splt",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_sRGB
+    {"mng_getchunk_srgb",          1, 0, 0},
+#endif
+    {"mng_getchunk_term",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_tEXt
+    {"mng_getchunk_text",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+    {"mng_getchunk_time",          1, 0, 0},
+#endif
+    {"mng_getchunk_trns",          1, 0, 0},
+    {"mng_getchunk_unkown",        1, 0, 0},
+#ifndef MNG_SKIPCHUNK_zTXt
+    {"mng_getchunk_ztxt",          1, 0, 0},
+#endif
+    {"mng_getimgdata_chunk",       0, 0, 0},
+    {"mng_getimgdata_chunkseq",    0, 0, 0},
+    {"mng_getimgdata_seq",         0, 0, 0},
+    {"mng_getlasterror",           1, 0, 0},
+    {"mng_initialize",             1, 0, 0},
+    {"mng_iterate_chunks",         1, 0, 0},
+    {"mng_putchunk_back",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_BASI
+    {"mng_putchunk_basi",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+    {"mng_putchunk_bkgd",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_cHRM
+    {"mng_putchunk_chrm",          1, 0, 0},
+#endif
+    {"mng_putchunk_clip",          1, 0, 0},
+    {"mng_putchunk_clon",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+    {"mng_putchunk_dbyk",          1, 0, 0},
+#endif
+#endif
+    {"mng_putchunk_defi",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+    {"mng_putchunk_dhdr",          1, 0, 0},
+#endif
+    {"mng_putchunk_disc",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+    {"mng_putchunk_drop",          1, 0, 0},
+#endif
+    {"mng_putchunk_endl",          1, 0, 0},
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {"mng_putchunk_mpng",          1, 0, 10},
+    {"mng_putchunk_mpng_frame",    1, 0, 10},
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {"mng_putchunk_evnt",          1, 0, 5},
+    {"mng_putchunk_evnt_entry",    1, 0, 5},
+#endif
+#ifndef MNG_SKIPCHUNK_eXPI
+    {"mng_putchunk_expi",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+    {"mng_putchunk_fpri",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_FRAM
+    {"mng_putchunk_fram",          1, 0, 0},
+#endif
+    {"mng_putchunk_gama",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_hIST
+    {"mng_putchunk_hist",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+    {"mng_putchunk_iccp",          1, 0, 0},
+#endif
+    {"mng_putchunk_idat",          1, 0, 0},
+    {"mng_putchunk_iend",          1, 0, 0},
+    {"mng_putchunk_ihdr",          1, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+    {"mng_putchunk_ijng",          1, 0, 0},
+#endif
+    {"mng_putchunk_ipng",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+    {"mng_putchunk_itxt",          1, 0, 0},
+#endif
+#ifdef MNG_INCLUDE_JNG
+    {"mng_putchunk_jdaa",          1, 0, 0},
+    {"mng_putchunk_jdat",          1, 0, 0},
+    {"mng_putchunk_jhdr",          1, 0, 0},
+    {"mng_putchunk_jsep",          1, 0, 0},
+#endif
+    {"mng_putchunk_loop",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_MAGN
+    {"mng_putchunk_magn",          1, 0, 0},
+#endif
+    {"mng_putchunk_mend",          1, 0, 0},
+    {"mng_putchunk_mhdr",          1, 0, 0},
+    {"mng_putchunk_move",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_nEED
+    {"mng_putchunk_need",          1, 0, 0},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+    {"mng_putchunk_ordr",          1, 0, 0},
+    {"mng_putchunk_ordr_entry",    1, 0, 0},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+    {"mng_putchunk_past",          1, 0, 0},
+    {"mng_putchunk_past_src",      1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYg
+    {"mng_putchunk_phyg",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+    {"mng_putchunk_phys",          1, 0, 0},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {"mng_putchunk_plte",          1, 0, 0},
+    {"mng_putchunk_pplt",          1, 0, 0},
+    {"mng_putchunk_pplt_entry",    1, 0, 0},
+    {"mng_putchunk_prom",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+    {"mng_putchunk_save",          1, 0, 0},
+    {"mng_putchunk_save_entry",    1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+    {"mng_putchunk_sbit",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+    {"mng_putchunk_seek",          1, 0, 0},
+#endif
+    {"mng_putchunk_show",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_sPLT
+    {"mng_putchunk_splt",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_sRGB
+    {"mng_putchunk_srgb",          1, 0, 0},
+#endif
+    {"mng_putchunk_term",          1, 0, 0},
+#ifndef MNG_SKIPCHUNK_tEXt
+    {"mng_putchunk_text",          1, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+    {"mng_putchunk_time",          1, 0, 0},
+#endif
+    {"mng_putchunk_trns",          1, 0, 0},
+    {"mng_putchunk_unkown",        1, 0, 0},
+#ifndef MNG_SKIPCHUNK_zTXt
+    {"mng_putchunk_ztxt",          1, 0, 0},
+#endif
+    {"mng_putimgdata_ihdr",        0, 0, 0},
+    {"mng_putimgdata_jhdr",        0, 0, 0},
+    {"mng_reset",                  1, 0, 0},
+    {"mng_read",                   1, 0, 0},
+    {"mng_read_pushchunk",         1, 0, 8},
+    {"mng_read_pushdata",          1, 0, 8},
+    {"mng_read_pushsig",           1, 0, 8},
+    {"mng_read_resume",            1, 0, 0},
+    {"mng_readdisplay",            1, 0, 0},
+    {"mng_set_bgcolor",            1, 0, 0},
+    {"mng_set_bkgdstyle",          1, 0, 0},
+    {"mng_set_cacheplayback",      1, 0, 2},
+    {"mng_set_canvasstyle",        1, 0, 0},
+    {"mng_set_dfltimggamma",       1, 0, 0},
+#ifndef MNG_NO_DFLT_INFO
+    {"mng_set_dfltimggammaint",    1, 0, 0},
+#endif
+    {"mng_set_displaygamma",       1, 0, 0},
+    {"mng_set_displaygammaint",    1, 0, 0},
+    {"mng_set_doprogressive",      1, 0, 2},
+#ifdef MNG_ACCESS_JPEG
+    {"mng_set_jpeg_dctmethod",     1, 0, 0},
+    {"mng_set_jpeg_maxjdat",       1, 0, 0},
+    {"mng_set_jpeg_optimized",     1, 0, 0},
+    {"mng_set_jpeg_progressive",   1, 0, 0},
+    {"mng_set_jpeg_quality",       1, 0, 0},
+    {"mng_set_jpeg_smoothing",     1, 0, 0},
+#endif
+#ifndef MNG_SKIP_MAXCANVAS
+    {"mng_set_maxcanvasheight",    1, 0, 0},
+    {"mng_set_maxcanvassize",      1, 0, 0},
+    {"mng_set_maxcanvaswidth",     1, 0, 0},
+#endif
+    {"mng_set_outputprofile",      1, 0, 0},
+    {"mng_set_outputprofile2",     1, 0, 0},
+    {"mng_set_outputsrgb",         1, 0, 1},
+    {"mng_set_sectionbreaks",      1, 0, 0},
+    {"mng_set_speed",              1, 0, 0},
+    {"mng_set_srgb",               1, 0, 0},
+    {"mng_set_srgbimplicit",       1, 0, 1},
+    {"mng_set_srgbprofile",        1, 0, 0},
+    {"mng_set_srgbprofile2",       1, 0, 0},
+    {"mng_set_storechunks",        1, 0, 0},
+    {"mng_set_suspensionmode",     1, 0, 0},
+    {"mng_set_usebkgd",            1, 0, 0},
+    {"mng_set_userdata",           1, 0, 0},
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+    {"mng_set_viewgamma",          1, 0, 0},
+    {"mng_set_viewgammaint",       1, 0, 0},
+#endif
+#ifdef MNG_ACCESS_ZLIB
+    {"mng_set_zlib_level",         1, 0, 0},
+    {"mng_set_zlib_maxidat",       1, 0, 0},
+    {"mng_set_zlib_memlevel",      1, 0, 0},
+    {"mng_set_zlib_method",        1, 0, 0},
+    {"mng_set_zlib_strategy",      1, 0, 0},
+    {"mng_set_zlib_windowbits",    1, 0, 0},
+#endif
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+    {"mng_setcb_closestream",      1, 0, 0},
+#endif
+    {"mng_setcb_errorproc",        1, 0, 0},
+    {"mng_setcb_getalphaline",     1, 0, 0},
+    {"mng_setcb_getbkgdline",      1, 0, 0},
+    {"mng_setcb_getcanvasline",    1, 0, 0},
+    {"mng_setcb_gettickcount",     1, 0, 0},
+    {"mng_setcb_memalloc",         1, 0, 0},
+    {"mng_setcb_memfree",          1, 0, 0},
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+    {"mng_setcb_openstream",       1, 0, 0},
+#endif
+    {"mng_setcb_processarow",      1, 0, 0},
+    {"mng_setcb_processchroma",    1, 0, 0},
+    {"mng_setcb_processgamma",     1, 0, 0},
+    {"mng_setcb_processheader",    1, 0, 0},
+    {"mng_setcb_processiccp",      1, 0, 0},
+    {"mng_setcb_processmend",      1, 0, 1},
+    {"mng_setcb_processneed",      1, 0, 0},
+    {"mng_setcb_processsave",      1, 0, 0},
+    {"mng_setcb_processseek",      1, 0, 0},
+    {"mng_setcb_processsrgb",      1, 0, 0},
+    {"mng_setcb_processterm",      1, 0, 2},
+    {"mng_setcb_processtext",      1, 0, 0},
+    {"mng_setcb_processunknown",   1, 0, 0},
+    {"mng_setcb_readdata",         1, 0, 0},
+    {"mng_setcb_refresh",          1, 0, 0},
+    {"mng_setcb_releasedata",      1, 0, 8},
+    {"mng_setcb_settimer",         1, 0, 0},
+    {"mng_setcb_traceproc",        1, 0, 0},
+    {"mng_setcb_writedata",        1, 0, 0},
+    {"mng_status_creating",        1, 0, 0},
+    {"mng_status_displaying",      1, 0, 0},
+    {"mng_status_dynamic",         1, 0, 5},
+    {"mng_status_error",           1, 0, 0},
+    {"mng_status_reading",         1, 0, 0},
+    {"mng_status_running",         1, 0, 0},
+    {"mng_status_runningevent",    1, 0, 5},
+    {"mng_status_suspendbreak",    1, 0, 0},
+    {"mng_status_timerbreak",      1, 0, 0},
+    {"mng_status_writing",         1, 0, 0},
+    {"mng_supports_func",          1, 0, 5},
+    {"mng_trapevent",              1, 0, 5},
+    {"mng_updatemngheader",        1, 0, 0},
+    {"mng_updatemngsimplicity",    1, 0, 0},
+    {"mng_version_beta",           1, 0, 5},
+    {"mng_version_dll",            1, 0, 0},
+    {"mng_version_major",          1, 0, 0},
+    {"mng_version_minor",          1, 0, 0},
+    {"mng_version_release",        1, 0, 0},
+    {"mng_version_so",             1, 0, 0},
+    {"mng_version_text",           1, 0, 0},
+    {"mng_write",                  1, 0, 0},
+  };
+
+mng_bool MNG_DECL mng_supports_func (mng_pchar  zFunction,
+                                     mng_uint8* iMajor,
+                                     mng_uint8* iMinor,
+                                     mng_uint8* iRelease)
+{
+  mng_int32       iTop, iLower, iUpper, iMiddle;
+  mng_func_entryp pEntry;          /* pointer to found entry */
+                                   /* determine max index of table */
+  iTop = (sizeof (func_table) / sizeof (func_table [0])) - 1;
+
+  iLower  = 0;                     /* initialize binary search */
+  iMiddle = iTop >> 1;             /* start in the middle */
+  iUpper  = iTop;
+  pEntry  = 0;                     /* no goods yet! */
+
+  do                               /* the binary search itself */
+    {
+      mng_int32 iRslt = strcmp(func_table [iMiddle].zFunction, zFunction);
+      if (iRslt < 0)
+        iLower = iMiddle + 1;
+      else if (iRslt > 0)
+        iUpper = iMiddle - 1;
+      else
+      {
+        pEntry = &func_table [iMiddle];
+        break;
+      };
+
+      iMiddle = (iLower + iUpper) >> 1;
+    }
+  while (iLower <= iUpper);
+
+  if (pEntry)                      /* found it ? */
+  {
+    *iMajor   = pEntry->iMajor;
+    *iMinor   = pEntry->iMinor;
+    *iRelease = pEntry->iRelease;
+    return MNG_TRUE;
+  }
+  else
+  {
+    *iMajor   = 0;
+    *iMinor   = 0;
+    *iRelease = 0;
+    return MNG_FALSE;
+  }
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * HLAPI routines                                                         * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_handle MNG_DECL mng_initialize (mng_ptr       pUserdata,
+                                    mng_memalloc  fMemalloc,
+                                    mng_memfree   fMemfree,
+                                    mng_traceproc fTraceproc)
+{
+  mng_datap   pData;
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_retcode iRetcode;
+  mng_imagep  pImage;
+#endif
+
+#ifdef MNG_INTERNAL_MEMMNGMT           /* allocate the main datastruc */
+  pData = (mng_datap)calloc (1, sizeof (mng_data));
+#else
+  pData = (mng_datap)fMemalloc (sizeof (mng_data));
+#endif
+
+  if (!pData)
+    return MNG_NULL;                   /* error: out of memory?? */
+                                       /* validate the structure */
+  pData->iMagic                = MNG_MAGIC;
+                                       /* save userdata field */
+  pData->pUserdata             = pUserdata;
+                                       /* remember trace callback */
+  pData->fTraceproc            = fTraceproc;
+
+#ifdef MNG_SUPPORT_TRACE
+  if (mng_trace (pData, MNG_FN_INITIALIZE, MNG_LC_INITIALIZE))
+  {
+    MNG_FREEX (pData, pData, sizeof (mng_data));
+    return MNG_NULL;
+  }
+#endif
+                                       /* default canvas styles are 8-bit RGB */
+  pData->iCanvasstyle          = MNG_CANVAS_RGB8;
+  pData->iBkgdstyle            = MNG_CANVAS_RGB8;
+
+  pData->iBGred                = 0;  /* black */
+  pData->iBGgreen              = 0;
+  pData->iBGblue               = 0;
+
+  pData->bUseBKGD              = MNG_TRUE;
+
+#ifdef MNG_FULL_CMS
+  pData->bIssRGB               = MNG_TRUE;
+  pData->hProf1                = 0;    /* no profiles yet */
+  pData->hProf2                = 0;
+  pData->hProf3                = 0;
+  pData->hTrans                = 0;
+#endif
+
+  pData->dViewgamma            = 1.0;
+  pData->dDisplaygamma         = 2.2;
+  pData->dDfltimggamma         = 0.45455;
+                                       /* initially remember chunks */
+  pData->bStorechunks          = MNG_TRUE;
+                                       /* no breaks at section-borders */
+  pData->bSectionbreaks        = MNG_FALSE;
+                                       /* initially cache playback info */
+  pData->bCacheplayback        = MNG_TRUE;
+                                       /* progressive refresh for large images */
+  pData->bDoProgressive        = MNG_TRUE;
+                                       /* crc exists; should check; error for
+                                          critical chunks; warning for ancillery;
+                                          generate crc for output */
+  pData->iCrcmode              = MNG_CRC_DEFAULT;
+                                       /* normal animation-speed ! */
+  pData->iSpeed                = mng_st_normal;
+                                       /* initial image limits */
+  pData->iMaxwidth             = 10000;
+  pData->iMaxheight            = 10000;
+
+#ifdef MNG_INTERNAL_MEMMNGMT           /* internal management */
+  pData->fMemalloc             = MNG_NULL;
+  pData->fMemfree              = MNG_NULL;
+#else                                  /* keep callbacks */
+  pData->fMemalloc             = fMemalloc;
+  pData->fMemfree              = fMemfree;
+#endif
+                                       /* no value (yet) */
+  pData->fReleasedata          = MNG_NULL;    
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+  pData->fOpenstream           = MNG_NULL;
+  pData->fClosestream          = MNG_NULL;
+#endif
+  pData->fReaddata             = MNG_NULL;
+  pData->fWritedata            = MNG_NULL;
+  pData->fErrorproc            = MNG_NULL;
+  pData->fProcessheader        = MNG_NULL;
+  pData->fProcesstext          = MNG_NULL;
+  pData->fProcesssave          = MNG_NULL;
+  pData->fProcessseek          = MNG_NULL;
+  pData->fProcessneed          = MNG_NULL;
+  pData->fProcessmend          = MNG_NULL;
+  pData->fProcessunknown       = MNG_NULL;
+  pData->fProcessterm          = MNG_NULL;
+  pData->fGetcanvasline        = MNG_NULL;
+  pData->fGetbkgdline          = MNG_NULL;
+  pData->fGetalphaline         = MNG_NULL;
+  pData->fRefresh              = MNG_NULL;
+  pData->fGettickcount         = MNG_NULL;
+  pData->fSettimer             = MNG_NULL;
+  pData->fProcessgamma         = MNG_NULL;
+  pData->fProcesschroma        = MNG_NULL;
+  pData->fProcesssrgb          = MNG_NULL;
+  pData->fProcessiccp          = MNG_NULL;
+  pData->fProcessarow          = MNG_NULL;
+
+#if defined(MNG_SUPPORT_DISPLAY) && (defined(MNG_GAMMA_ONLY) || defined(MNG_FULL_CMS))
+  pData->dLastgamma            = 0;    /* lookup table needs first-time calc */
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY             /* create object 0 */
+  iRetcode = mng_create_imageobject (pData, 0, MNG_TRUE, MNG_TRUE, MNG_TRUE,
+                                     0, 0, 0, 0, 0, 0, 0, 0, 0, MNG_FALSE,
+                                     0, 0, 0, 0, &pImage);
+
+  if (iRetcode)                        /* on error drop out */
+  {
+    MNG_FREEX (pData, pData, sizeof (mng_data));
+    return MNG_NULL;
+  }
+
+  pData->pObjzero = pImage;
+#endif
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_INCLUDE_LCMS)
+  mnglcms_initlibrary ();              /* init lcms particulars */
+#endif
+
+#ifdef MNG_SUPPORT_READ
+  pData->bSuspensionmode       = MNG_FALSE;
+  pData->iSuspendbufsize       = 0;
+  pData->pSuspendbuf           = MNG_NULL;
+  pData->pSuspendbufnext       = MNG_NULL;
+  pData->iSuspendbufleft       = 0;
+  pData->iChunklen             = 0;
+  pData->pReadbufnext          = MNG_NULL;
+  pData->pLargebufnext         = MNG_NULL;
+
+  pData->pFirstpushchunk       = MNG_NULL;
+  pData->pLastpushchunk        = MNG_NULL;
+  pData->pFirstpushdata        = MNG_NULL;
+  pData->pLastpushdata         = MNG_NULL;
+#endif
+
+#ifdef MNG_INCLUDE_ZLIB
+  mngzlib_initialize (pData);          /* initialize zlib structures and such */
+                                       /* default zlib compression parameters */
+  pData->iZlevel               = MNG_ZLIB_LEVEL;
+  pData->iZmethod              = MNG_ZLIB_METHOD;
+  pData->iZwindowbits          = MNG_ZLIB_WINDOWBITS;
+  pData->iZmemlevel            = MNG_ZLIB_MEMLEVEL;
+  pData->iZstrategy            = MNG_ZLIB_STRATEGY;
+                                       /* default maximum IDAT data size */
+  pData->iMaxIDAT              = MNG_MAX_IDAT_SIZE;
+#endif
+
+#ifdef MNG_INCLUDE_JNG                 /* default IJG compression parameters */
+  pData->eJPEGdctmethod        = MNG_JPEG_DCT;
+  pData->iJPEGquality          = MNG_JPEG_QUALITY;
+  pData->iJPEGsmoothing        = MNG_JPEG_SMOOTHING;
+  pData->bJPEGcompressprogr    = MNG_JPEG_PROGRESSIVE;
+  pData->bJPEGcompressopt      = MNG_JPEG_OPTIMIZED;
+                                       /* default maximum JDAT data size */
+  pData->iMaxJDAT              = MNG_MAX_JDAT_SIZE;
+#endif
+
+  mng_reset ((mng_handle)pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  if (mng_trace (pData, MNG_FN_INITIALIZE, MNG_LC_END))
+  {
+    MNG_FREEX (pData, pData, sizeof (mng_data));
+    return MNG_NULL;
+  }
+#endif
+
+  return (mng_handle)pData;            /* if we get here, we're in business */
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_reset (mng_handle hHandle)
+{
+  mng_datap pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_RESET, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)(hHandle));      /* address main structure */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_SKIPCHUNK_SAVE
+  mng_drop_savedata (pData);           /* cleanup saved-data from SAVE/SEEK */
+#endif
+#endif
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_FULL_CMS)
+  mng_clear_cms (pData);               /* cleanup left-over cms stuff if any */
+#endif
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_INCLUDE_JNG)
+  mngjpeg_cleanup (pData);             /* cleanup jpeg stuff */
+#endif
+
+#ifdef MNG_INCLUDE_ZLIB
+  if (pData->bInflating)               /* if we've been inflating */
+  {
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+    mng_cleanup_rowproc (pData);       /* cleanup row-processing, */
+#endif
+    mngzlib_inflatefree (pData);       /* cleanup inflate! */
+  }
+#endif /* MNG_INCLUDE_ZLIB */
+
+#ifdef MNG_SUPPORT_READ
+  if ((pData->bReading) && (!pData->bEOF))
+    mng_process_eof (pData);           /* cleanup app streaming */
+                                       /* cleanup default read buffers */
+  MNG_FREE (pData, pData->pReadbuf,    pData->iReadbufsize);
+  MNG_FREE (pData, pData->pLargebuf,   pData->iLargebufsize);
+  MNG_FREE (pData, pData->pSuspendbuf, pData->iSuspendbufsize);
+
+  while (pData->pFirstpushdata)        /* release any pushed data & chunks */
+    mng_release_pushdata (pData);
+  while (pData->pFirstpushchunk)
+    mng_release_pushchunk (pData);
+#endif
+
+#ifdef MNG_SUPPORT_WRITE               /* cleanup default write buffer */
+  MNG_FREE (pData, pData->pWritebuf, pData->iWritebufsize);
+#endif
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+  mng_drop_chunks  (pData);            /* drop stored chunks (if any) */
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY
+  mng_drop_objects (pData, MNG_TRUE);  /* drop stored objects (if any) */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+  if (pData->iGlobalProfilesize)       /* drop global profile (if any) */
+    MNG_FREEX (pData, pData->pGlobalProfile, pData->iGlobalProfilesize);
+#endif
+#endif
+
+  pData->eSigtype              = mng_it_unknown;
+  pData->eImagetype            = mng_it_unknown;
+  pData->iWidth                = 0;    /* these are unknown yet */
+  pData->iHeight               = 0;
+  pData->iTicks                = 0;
+  pData->iLayercount           = 0;
+  pData->iFramecount           = 0;
+  pData->iPlaytime             = 0;
+  pData->iSimplicity           = 0;
+  pData->iAlphadepth           = 16;   /* assume the worst! */
+
+  pData->iImagelevel           = 0;    /* no image encountered */
+
+  pData->iMagnify              = 0;    /* 1-to-1 display */
+  pData->iOffsetx              = 0;    /* no offsets */
+  pData->iOffsety              = 0;
+  pData->iCanvaswidth          = 0;    /* let the app decide during processheader */
+  pData->iCanvasheight         = 0;
+                                       /* so far, so good */
+  pData->iErrorcode            = MNG_NOERROR;
+  pData->iSeverity             = 0;
+  pData->iErrorx1              = 0;
+  pData->iErrorx2              = 0;
+  pData->zErrortext            = MNG_NULL;
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+                                       /* let's assume the best scenario */
+#ifndef MNG_NO_OLD_VERSIONS
+  pData->bPreDraft48           = MNG_FALSE;
+#endif
+                                       /* the unknown chunk */
+  pData->iChunkname            = MNG_UINT_HUH;
+  pData->iChunkseq             = 0;
+  pData->pFirstchunk           = MNG_NULL;
+  pData->pLastchunk            = MNG_NULL;
+                                       /* nothing processed yet */
+  pData->bHasheader            = MNG_FALSE;
+  pData->bHasMHDR              = MNG_FALSE;
+  pData->bHasIHDR              = MNG_FALSE;
+  pData->bHasBASI              = MNG_FALSE;
+  pData->bHasDHDR              = MNG_FALSE;
+#ifdef MNG_INCLUDE_JNG
+  pData->bHasJHDR              = MNG_FALSE;
+  pData->bHasJSEP              = MNG_FALSE;
+  pData->bHasJDAA              = MNG_FALSE;
+  pData->bHasJDAT              = MNG_FALSE;
+#endif
+  pData->bHasPLTE              = MNG_FALSE;
+  pData->bHasTRNS              = MNG_FALSE;
+  pData->bHasGAMA              = MNG_FALSE;
+  pData->bHasCHRM              = MNG_FALSE;
+  pData->bHasSRGB              = MNG_FALSE;
+  pData->bHasICCP              = MNG_FALSE;
+  pData->bHasBKGD              = MNG_FALSE;
+  pData->bHasIDAT              = MNG_FALSE;
+
+  pData->bHasSAVE              = MNG_FALSE;
+  pData->bHasBACK              = MNG_FALSE;
+  pData->bHasFRAM              = MNG_FALSE;
+  pData->bHasTERM              = MNG_FALSE;
+  pData->bHasLOOP              = MNG_FALSE;
+                                       /* there's no global stuff yet either */
+  pData->bHasglobalPLTE        = MNG_FALSE;
+  pData->bHasglobalTRNS        = MNG_FALSE;
+  pData->bHasglobalGAMA        = MNG_FALSE;
+  pData->bHasglobalCHRM        = MNG_FALSE;
+  pData->bHasglobalSRGB        = MNG_FALSE;
+  pData->bHasglobalICCP        = MNG_FALSE;
+
+  pData->iDatawidth            = 0;    /* no IHDR/BASI/DHDR done yet */
+  pData->iDataheight           = 0;
+  pData->iBitdepth             = 0;
+  pData->iColortype            = 0;
+  pData->iCompression          = 0;
+  pData->iFilter               = 0;
+  pData->iInterlace            = 0;
+
+#ifdef MNG_INCLUDE_JNG
+  pData->iJHDRcolortype        = 0;    /* no JHDR data */
+  pData->iJHDRimgbitdepth      = 0;
+  pData->iJHDRimgcompression   = 0;
+  pData->iJHDRimginterlace     = 0;
+  pData->iJHDRalphabitdepth    = 0;
+  pData->iJHDRalphacompression = 0;
+  pData->iJHDRalphafilter      = 0;
+  pData->iJHDRalphainterlace   = 0;
+#endif
+
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+#ifdef MNG_SUPPORT_READ                /* no reading done */
+  pData->bReading              = MNG_FALSE;
+  pData->bHavesig              = MNG_FALSE;
+  pData->bEOF                  = MNG_FALSE;
+  pData->iReadbufsize          = 0;
+  pData->pReadbuf              = MNG_NULL;
+
+  pData->iLargebufsize         = 0;
+  pData->pLargebuf             = MNG_NULL;
+
+  pData->iSuspendtime          = 0;
+  pData->bSuspended            = MNG_FALSE;
+  pData->iSuspendpoint         = 0;
+
+  pData->pSuspendbufnext       = pData->pSuspendbuf;
+  pData->iSuspendbufleft       = 0;
+#endif /* MNG_SUPPORT_READ */
+
+#ifdef MNG_SUPPORT_WRITE               /* no creating/writing done */
+  pData->bCreating             = MNG_FALSE;
+  pData->bWriting              = MNG_FALSE;
+  pData->iFirstchunkadded      = 0;
+  pData->iWritebufsize         = 0;
+  pData->pWritebuf             = MNG_NULL;
+#endif /* MNG_SUPPORT_WRITE */
+
+#ifdef MNG_SUPPORT_DISPLAY             /* done nuttin' yet */
+  pData->bDisplaying           = MNG_FALSE;
+  pData->iFrameseq             = 0;
+  pData->iLayerseq             = 0;
+  pData->iFrametime            = 0;
+
+  pData->iTotallayers          = 0;
+  pData->iTotalframes          = 0;
+  pData->iTotalplaytime        = 0;
+
+  pData->bSkipping             = MNG_FALSE;
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+  pData->bDynamic              = MNG_FALSE;
+  pData->bRunningevent         = MNG_FALSE;
+  pData->bStopafterseek        = MNG_FALSE;
+  pData->iEventx               = 0;
+  pData->iEventy               = 0;
+  pData->pLastmousemove        = MNG_NULL;
+#endif
+
+  pData->iRequestframe         = 0;
+  pData->iRequestlayer         = 0;
+  pData->iRequesttime          = 0;
+  pData->bSearching            = MNG_FALSE;
+
+  pData->bRestorebkgd          = MNG_FALSE;
+
+  pData->iRuntime              = 0;
+  pData->iSynctime             = 0;
+  pData->iStarttime            = 0;
+  pData->iEndtime              = 0;
+  pData->bRunning              = MNG_FALSE;
+  pData->bTimerset             = MNG_FALSE;
+  pData->iBreakpoint           = 0;
+  pData->bSectionwait          = MNG_FALSE;
+  pData->bFreezing             = MNG_FALSE;
+  pData->bResetting            = MNG_FALSE;
+  pData->bNeedrefresh          = MNG_FALSE;
+  pData->bMisplacedTERM        = MNG_FALSE;
+  pData->bOnlyfirstframe       = MNG_FALSE;
+  pData->iFramesafterTERM      = 0;
+                                       /* these don't exist yet */
+  pData->pCurrentobj           = MNG_NULL;
+  pData->pCurraniobj           = MNG_NULL;
+  pData->pTermaniobj           = MNG_NULL;
+  pData->pLastclone            = MNG_NULL;
+  pData->pStoreobj             = MNG_NULL;
+  pData->pStorebuf             = MNG_NULL;
+  pData->pRetrieveobj          = MNG_NULL;
+                                       /* no saved data ! */
+  pData->pSavedata             = MNG_NULL;
+
+  pData->iUpdateleft           = 0;    /* no region updated yet */
+  pData->iUpdateright          = 0;
+  pData->iUpdatetop            = 0;
+  pData->iUpdatebottom         = 0;
+
+  pData->iPass                 = -1;   /* interlacing stuff and temp buffers */
+  pData->iRow                  = 0;
+  pData->iRowinc               = 1;
+  pData->iCol                  = 0;
+  pData->iColinc               = 1;
+  pData->iRowsamples           = 0;
+  pData->iSamplemul            = 0;
+  pData->iSampleofs            = 0;
+  pData->iSamplediv            = 0;
+  pData->iRowsize              = 0;
+  pData->iRowmax               = 0;
+  pData->iFilterofs            = 0;
+  pData->iPixelofs             = 1;
+  pData->iLevel0               = 0;
+  pData->iLevel1               = 0;
+  pData->iLevel2               = 0;
+  pData->iLevel3               = 0;
+  pData->pWorkrow              = MNG_NULL;
+  pData->pPrevrow              = MNG_NULL;
+  pData->pRGBArow              = MNG_NULL;
+  pData->bIsRGBA16             = MNG_TRUE;
+  pData->bIsOpaque             = MNG_TRUE;
+  pData->iFilterbpp            = 1;
+
+  pData->iSourcel              = 0;    /* always initialized just before */
+  pData->iSourcer              = 0;    /* compositing the next layer */
+  pData->iSourcet              = 0;
+  pData->iSourceb              = 0;
+  pData->iDestl                = 0;
+  pData->iDestr                = 0;
+  pData->iDestt                = 0;
+  pData->iDestb                = 0;
+                                       /* lists are empty */
+  pData->pFirstimgobj          = MNG_NULL;
+  pData->pLastimgobj           = MNG_NULL;
+  pData->pFirstaniobj          = MNG_NULL;
+  pData->pLastaniobj           = MNG_NULL;
+#ifdef MNG_SUPPORT_DYNAMICMNG
+  pData->pFirstevent           = MNG_NULL;
+  pData->pLastevent            = MNG_NULL;
+#endif
+                                       /* no processing callbacks */
+  pData->fDisplayrow           = MNG_NULL;
+  pData->fRestbkgdrow          = MNG_NULL;
+  pData->fCorrectrow           = MNG_NULL;
+  pData->fRetrieverow          = MNG_NULL;
+  pData->fStorerow             = MNG_NULL;
+  pData->fProcessrow           = MNG_NULL;
+  pData->fDifferrow            = MNG_NULL;
+  pData->fScalerow             = MNG_NULL;
+  pData->fDeltarow             = MNG_NULL;
+#ifndef MNG_SKIPCHUNK_PAST
+  pData->fFliprow              = MNG_NULL;
+  pData->fTilerow              = MNG_NULL;
+#endif
+  pData->fInitrowproc          = MNG_NULL;
+
+  pData->iPLTEcount            = 0;    /* no PLTE data */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+  pData->iDEFIobjectid         = 0;    /* no DEFI data */
+  pData->bDEFIhasdonotshow     = MNG_FALSE;
+  pData->iDEFIdonotshow        = 0;
+  pData->bDEFIhasconcrete      = MNG_FALSE;
+  pData->iDEFIconcrete         = 0;
+  pData->bDEFIhasloca          = MNG_FALSE;
+  pData->iDEFIlocax            = 0;
+  pData->iDEFIlocay            = 0;
+  pData->bDEFIhasclip          = MNG_FALSE;
+  pData->iDEFIclipl            = 0;
+  pData->iDEFIclipr            = 0;
+  pData->iDEFIclipt            = 0;
+  pData->iDEFIclipb            = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_BACK
+  pData->iBACKred              = 0;    /* no BACK data */
+  pData->iBACKgreen            = 0;
+  pData->iBACKblue             = 0;
+  pData->iBACKmandatory        = 0;
+  pData->iBACKimageid          = 0;
+  pData->iBACKtile             = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_FRAM
+  pData->iFRAMmode             = 1;     /* default global FRAM variables */
+  pData->iFRAMdelay            = 1;
+  pData->iFRAMtimeout          = 0x7fffffffl;
+  pData->bFRAMclipping         = MNG_FALSE;
+  pData->iFRAMclipl            = 0;
+  pData->iFRAMclipr            = 0;
+  pData->iFRAMclipt            = 0;
+  pData->iFRAMclipb            = 0;
+
+  pData->iFramemode            = 1;     /* again for the current frame */
+  pData->iFramedelay           = 1;
+  pData->iFrametimeout         = 0x7fffffffl;
+  pData->bFrameclipping        = MNG_FALSE;
+  pData->iFrameclipl           = 0;
+  pData->iFrameclipr           = 0;
+  pData->iFrameclipt           = 0;
+  pData->iFrameclipb           = 0;
+
+  pData->iNextdelay            = 1;
+
+  pData->bForcedelay           = MNG_FALSE;
+  pData->iAccumdelay           = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_SHOW
+  pData->iSHOWmode             = 0;    /* no SHOW data */
+  pData->iSHOWfromid           = 0;
+  pData->iSHOWtoid             = 0;
+  pData->iSHOWnextid           = 0;
+  pData->iSHOWskip             = 0;
+#endif
+
+  pData->iGlobalPLTEcount      = 0;    /* no global PLTE data */
+
+  pData->iGlobalTRNSrawlen     = 0;    /* no global tRNS data */
+
+  pData->iGlobalGamma          = 0;    /* no global gAMA data */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+  pData->iGlobalWhitepointx    = 0;    /* no global cHRM data */
+  pData->iGlobalWhitepointy    = 0;
+  pData->iGlobalPrimaryredx    = 0;
+  pData->iGlobalPrimaryredy    = 0;
+  pData->iGlobalPrimarygreenx  = 0;
+  pData->iGlobalPrimarygreeny  = 0;
+  pData->iGlobalPrimarybluex   = 0;
+  pData->iGlobalPrimarybluey   = 0;
+#endif
+
+  pData->iGlobalRendintent     = 0;    /* no global sRGB data */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+  pData->iGlobalProfilesize    = 0;    /* no global iCCP data */
+  pData->pGlobalProfile        = MNG_NULL;
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+  pData->iGlobalBKGDred        = 0;    /* no global bKGD data */
+  pData->iGlobalBKGDgreen      = 0;
+  pData->iGlobalBKGDblue       = 0;
+#endif
+                                       /* no delta-image */
+#ifndef MNG_NO_DELTA_PNG
+  pData->pDeltaImage           = MNG_NULL;
+  pData->iDeltaImagetype       = 0;
+  pData->iDeltatype            = 0;
+  pData->iDeltaBlockwidth      = 0;
+  pData->iDeltaBlockheight     = 0;
+  pData->iDeltaBlockx          = 0;
+  pData->iDeltaBlocky          = 0;
+  pData->bDeltaimmediate       = MNG_FALSE;
+
+  pData->fDeltagetrow          = MNG_NULL;
+  pData->fDeltaaddrow          = MNG_NULL;
+  pData->fDeltareplacerow      = MNG_NULL;
+  pData->fDeltaputrow          = MNG_NULL;
+
+  pData->fPromoterow           = MNG_NULL;
+  pData->fPromBitdepth         = MNG_NULL;
+  pData->pPromBuf              = MNG_NULL;
+  pData->iPromColortype        = 0;
+  pData->iPromBitdepth         = 0;
+  pData->iPromFilltype         = 0;
+  pData->iPromWidth            = 0;
+  pData->pPromSrc              = MNG_NULL;
+  pData->pPromDst              = MNG_NULL;
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+  pData->iMAGNfromid           = 0;
+  pData->iMAGNtoid             = 0;
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+  pData->iPastx                = 0;
+  pData->iPasty                = 0;
+#endif
+
+  pData->pLastseek             = MNG_NULL;
+#endif
+
+#ifdef MNG_INCLUDE_ZLIB
+  pData->bInflating            = 0;    /* no inflating or deflating */
+  pData->bDeflating            = 0;    /* going on at the moment */
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY             /* reset object 0 */
+  mng_reset_objzero (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_RESET, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_cleanup (mng_handle* hHandle)
+{
+  mng_datap pData;                     /* local vars */
+#ifndef MNG_INTERNAL_MEMMNGMT
+  mng_memfree fFree;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)*hHandle), MNG_FN_CLEANUP, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (*hHandle)           /* check validity handle */
+  pData = ((mng_datap)(*hHandle));     /* and address main structure */
+
+  mng_reset (*hHandle);                /* do an implicit reset to cleanup most stuff */
+
+#ifdef MNG_SUPPORT_DISPLAY             /* drop object 0 */
+  mng_free_imageobject (pData, (mng_imagep)pData->pObjzero);
+#endif
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_FULL_CMS)
+  if (pData->hProf2)                   /* output profile defined ? */
+    mnglcms_freeprofile (pData->hProf2);
+
+  if (pData->hProf3)                   /* sRGB profile defined ? */
+    mnglcms_freeprofile (pData->hProf3);
+#endif 
+
+#ifdef MNG_INCLUDE_ZLIB
+  mngzlib_cleanup (pData);             /* cleanup zlib stuff */
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)*hHandle), MNG_FN_CLEANUP, MNG_LC_CLEANUP)
+#endif
+
+  pData->iMagic = 0;                   /* invalidate the actual memory */
+
+#ifdef MNG_INTERNAL_MEMMNGMT
+  free ((void *)*hHandle);             /* cleanup the data-structure */
+#else
+  fFree = ((mng_datap)*hHandle)->fMemfree;
+  fFree ((mng_ptr)*hHandle, sizeof (mng_data));
+#endif
+
+  *hHandle = 0;                        /* wipe pointer to inhibit future use */
+
+  return MNG_NOERROR;                  /* and we're done */
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_read (mng_handle hHandle)
+{
+  mng_datap   pData;                   /* local vars */
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle and callbacks */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+  MNG_VALIDCB (hHandle, fMemalloc)
+  MNG_VALIDCB (hHandle, fMemfree)
+#endif
+
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+  MNG_VALIDCB (hHandle, fOpenstream)
+  MNG_VALIDCB (hHandle, fClosestream)
+#endif
+  MNG_VALIDCB (hHandle, fReaddata)
+
+#ifdef MNG_SUPPORT_DISPLAY             /* valid at this point ? */
+  if ((pData->bReading) || (pData->bDisplaying))
+#else
+  if (pData->bReading)
+#endif
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+#ifdef MNG_SUPPORT_WRITE
+  if ((pData->bWriting) || (pData->bCreating))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+#endif
+
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  pData->bReading = MNG_TRUE;          /* read only! */
+
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+  if (pData->fOpenstream && !pData->fOpenstream (hHandle))
+    /* open it and start reading */
+    iRetcode = MNG_APPIOERROR;
+  else
+#endif
+    iRetcode = mng_read_graphic (pData);
+
+  if (pData->bEOF)                     /* already at EOF ? */
+  {
+    pData->bReading = MNG_FALSE;       /* then we're no longer reading */
+    
+#ifdef MNG_SUPPORT_DISPLAY
+    mng_reset_rundata (pData);         /* reset rundata */
+#endif
+  }
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  if (pData->bSuspended)               /* read suspension ? */
+  {
+     iRetcode            = MNG_NEEDMOREDATA;
+     pData->iSuspendtime = pData->fGettickcount ((mng_handle)pData);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_read_pushdata (mng_handle hHandle,
+                                        mng_ptr    pData,
+                                        mng_size_t iLength,
+                                        mng_bool   bTakeownership)
+{
+  mng_datap     pMyData;               /* local vars */
+  mng_pushdatap pPush;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_PUSHDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pMyData = ((mng_datap)hHandle);      /* and make it addressable */
+                                       /* create a containing buffer */
+  iRetcode = make_pushbuffer (pMyData, pData, iLength, bTakeownership, &pPush);
+  if (iRetcode)
+    return iRetcode;
+
+  if (pMyData->pLastpushdata)          /* and update the buffer chain */
+    pMyData->pLastpushdata->pNext = pPush;
+  else
+    pMyData->pFirstpushdata = pPush;
+
+  pMyData->pLastpushdata = pPush;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_PUSHDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_read_pushsig (mng_handle  hHandle,
+                                       mng_imgtype eSigtype)
+{
+  mng_datap pData;                     /* local vars */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_PUSHSIG, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  if (pData->bHavesig)                 /* can we expect this call ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  pData->eSigtype = eSigtype;
+  pData->bHavesig = MNG_TRUE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_PUSHSIG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_read_pushchunk (mng_handle hHandle,
+                                         mng_ptr    pChunk,
+                                         mng_size_t iLength,
+                                         mng_bool   bTakeownership)
+{
+  mng_datap     pMyData;               /* local vars */
+  mng_pushdatap pPush;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_PUSHCHUNK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pMyData = ((mng_datap)hHandle);      /* and make it addressable */
+                                       /* create a containing buffer */
+  iRetcode = make_pushbuffer (pMyData, pChunk, iLength, bTakeownership, &pPush);
+  if (iRetcode)
+    return iRetcode;
+
+  if (pMyData->pLastpushchunk)         /* and update the buffer chain */
+    pMyData->pLastpushchunk->pNext = pPush;
+  else
+    pMyData->pFirstpushchunk = pPush;
+
+  pMyData->pLastpushchunk = pPush;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_PUSHCHUNK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_read_resume (mng_handle hHandle)
+{
+  mng_datap   pData;                   /* local vars */
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_RESUME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+                                       /* can we expect this call ? */
+  if ((!pData->bReading) || (!pData->bSuspended))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  pData->bSuspended = MNG_FALSE;       /* reset the flag */
+
+#ifdef MNG_SUPPORT_DISPLAY             /* re-synchronize ? */
+  if ((pData->bDisplaying) && (pData->bRunning))
+    pData->iSynctime  = pData->iSynctime - pData->iSuspendtime +
+                        pData->fGettickcount (hHandle);
+#endif
+
+  iRetcode = mng_read_graphic (pData); /* continue reading now */
+
+  if (pData->bEOF)                     /* at EOF ? */
+  {
+    pData->bReading = MNG_FALSE;       /* then we're no longer reading */
+    
+#ifdef MNG_SUPPORT_DISPLAY
+    mng_reset_rundata (pData);         /* reset rundata */
+#endif
+  }
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  if (pData->bSuspended)               /* read suspension ? */
+  {
+     iRetcode            = MNG_NEEDMOREDATA;
+     pData->iSuspendtime = pData->fGettickcount ((mng_handle)pData);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READ_RESUME, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_write (mng_handle hHandle)
+{
+  mng_datap   pData;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_WRITE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle and callbacks */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+  MNG_VALIDCB (hHandle, fMemalloc)
+  MNG_VALIDCB (hHandle, fMemfree)
+#endif
+
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+  MNG_VALIDCB (hHandle, fOpenstream)
+  MNG_VALIDCB (hHandle, fClosestream)
+#endif
+  MNG_VALIDCB (hHandle, fWritedata)
+
+#ifdef MNG_SUPPORT_READ
+  if (pData->bReading)                 /* valid at this point ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+#endif
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  iRetcode = mng_write_graphic (pData);/* do the write */
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_WRITE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_create (mng_handle hHandle)
+{
+  mng_datap   pData;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_CREATE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle and callbacks */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+  MNG_VALIDCB (hHandle, fMemalloc)
+  MNG_VALIDCB (hHandle, fMemfree)
+#endif
+
+#ifdef MNG_SUPPORT_READ
+  if (pData->bReading)                 /* valid at this point ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+#endif
+
+  if ((pData->bWriting) || (pData->bCreating))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  iRetcode = mng_reset (hHandle);      /* clear any previous stuff */
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  pData->bCreating = MNG_TRUE;         /* indicate we're creating a new file */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_CREATE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_SUPPORT_READ)
+mng_retcode MNG_DECL mng_readdisplay (mng_handle hHandle)
+{
+  mng_datap   pData;                   /* local vars */
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READDISPLAY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle and callbacks */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+  MNG_VALIDCB (hHandle, fMemalloc)
+  MNG_VALIDCB (hHandle, fMemfree)
+#endif
+
+  MNG_VALIDCB (hHandle, fReaddata)
+  MNG_VALIDCB (hHandle, fGetcanvasline)
+  MNG_VALIDCB (hHandle, fRefresh)
+  MNG_VALIDCB (hHandle, fGettickcount)
+  MNG_VALIDCB (hHandle, fSettimer)
+                                       /* valid at this point ? */
+  if ((pData->bReading) || (pData->bDisplaying))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+#ifdef MNG_SUPPORT_WRITE
+  if ((pData->bWriting) || (pData->bCreating))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+#endif
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  pData->bReading      = MNG_TRUE;     /* read & display! */
+  pData->bDisplaying   = MNG_TRUE;
+  pData->bRunning      = MNG_TRUE;
+  pData->iFrameseq     = 0;
+  pData->iLayerseq     = 0;
+  pData->iFrametime    = 0;
+  pData->iRequestframe = 0;
+  pData->iRequestlayer = 0;
+  pData->iRequesttime  = 0;
+  pData->bSearching    = MNG_FALSE;
+  pData->iRuntime      = 0;
+  pData->iSynctime     = pData->fGettickcount (hHandle);
+  pData->iSuspendtime  = 0;
+  pData->iStarttime    = pData->iSynctime;
+  pData->iEndtime      = 0;
+
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+  if (pData->fOpenstream && !pData->fOpenstream (hHandle))
+    /* open it and start reading */
+    iRetcode = MNG_APPIOERROR;
+  else
+#endif
+    iRetcode = mng_read_graphic (pData);
+
+  if (pData->bEOF)                     /* already at EOF ? */
+  {
+    pData->bReading = MNG_FALSE;       /* then we're no longer reading */
+    mng_drop_invalid_objects (pData);  /* drop invalidly stored objects */
+  }
+  
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  if (pData->bSuspended)               /* read suspension ? */
+  {
+     iRetcode            = MNG_NEEDMOREDATA;
+     pData->iSuspendtime = pData->fGettickcount ((mng_handle)pData);
+  }
+  else
+  if (pData->bTimerset)                /* indicate timer break ? */
+    iRetcode = MNG_NEEDTIMERWAIT;
+  else
+  if (pData->bSectionwait)             /* indicate section break ? */
+    iRetcode = MNG_NEEDSECTIONWAIT;
+  else
+  {                                    /* no breaks = end of run */
+    pData->bRunning = MNG_FALSE;
+
+    if (pData->bFreezing)              /* dynamic MNG reached SEEK ? */
+      pData->bFreezing = MNG_FALSE;    /* reset it ! */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_READDISPLAY, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif /* MNG_SUPPORT_DISPLAY && MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_display (mng_handle hHandle)
+{
+  mng_datap   pData;                   /* local vars */
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle and callbacks */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+#ifndef MNG_INTERNAL_MEMMNGMT
+  MNG_VALIDCB (hHandle, fMemalloc)
+  MNG_VALIDCB (hHandle, fMemfree)
+#endif
+
+  MNG_VALIDCB (hHandle, fGetcanvasline)
+  MNG_VALIDCB (hHandle, fRefresh)
+  MNG_VALIDCB (hHandle, fGettickcount)
+  MNG_VALIDCB (hHandle, fSettimer)
+
+  if (pData->bDisplaying)              /* valid at this point ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+    
+#ifdef MNG_SUPPORT_READ
+  if (pData->bReading)
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+#endif
+
+#ifdef MNG_SUPPORT_WRITE
+  if ((pData->bWriting) || (pData->bCreating))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+#endif
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  pData->bDisplaying   = MNG_TRUE;     /* display! */
+  pData->bRunning      = MNG_TRUE;
+  pData->iFrameseq     = 0;
+  pData->iLayerseq     = 0;
+  pData->iFrametime    = 0;
+  pData->iRequestframe = 0;
+  pData->iRequestlayer = 0;
+  pData->iRequesttime  = 0;
+  pData->bSearching    = MNG_FALSE;
+  pData->iRuntime      = 0;
+  pData->iSynctime     = pData->fGettickcount (hHandle);
+#ifdef MNG_SUPPORT_READ
+  pData->iSuspendtime  = 0;
+#endif  
+  pData->iStarttime    = pData->iSynctime;
+  pData->iEndtime      = 0;
+  pData->pCurraniobj   = pData->pFirstaniobj;
+                                       /* go do it */
+  iRetcode = mng_process_display (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  if (pData->bTimerset)                /* indicate timer break ? */
+    iRetcode = MNG_NEEDTIMERWAIT;
+  else
+  {                                    /* no breaks = end of run */
+    pData->bRunning = MNG_FALSE;
+
+    if (pData->bFreezing)              /* dynamic MNG reached SEEK ? */
+      pData->bFreezing = MNG_FALSE;    /* reset it ! */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_display_resume (mng_handle hHandle)
+{
+  mng_datap   pData;                   /* local vars */
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_RESUME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  if (!pData->bDisplaying)             /* can we expect this call ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+                                       /* was it running ? */
+  if ((pData->bRunning) || (pData->bReading))
+  {                                    /* are we expecting this call ? */
+    if ((pData->bTimerset) || (pData->bSuspended) || (pData->bSectionwait)) 
+    {
+      pData->bTimerset    = MNG_FALSE; /* reset the flags */
+      pData->bSectionwait = MNG_FALSE;
+
+#ifdef MNG_SUPPORT_READ
+      if (pData->bReading)             /* set during read&display ? */
+      {
+        if (pData->bSuspended)         /* calculate proper synchronization */
+          pData->iSynctime = pData->iSynctime - pData->iSuspendtime +
+                             pData->fGettickcount (hHandle);
+        else
+          pData->iSynctime = pData->fGettickcount (hHandle);
+
+        pData->bSuspended = MNG_FALSE; /* now reset this flag */  
+                                       /* and continue reading */
+        iRetcode = mng_read_graphic (pData);
+
+        if (pData->bEOF)               /* already at EOF ? */
+        {
+          pData->bReading = MNG_FALSE; /* then we're no longer reading */
+                                       /* drop invalidly stored objects */
+          mng_drop_invalid_objects (pData);
+        }
+      }
+      else
+#endif /* MNG_SUPPORT_READ */
+      {                                /* synchronize timing */
+        pData->iSynctime = pData->fGettickcount (hHandle);
+                                       /* resume display processing */
+        iRetcode = mng_process_display (pData);
+      }
+    }
+    else
+    {
+      MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+    }
+  }
+  else
+  {                                    /* synchronize timing */
+    pData->iSynctime = pData->fGettickcount (hHandle);
+    pData->bRunning  = MNG_TRUE;       /* it's restarted again ! */
+                                       /* resume display processing */
+    iRetcode = mng_process_display (pData);
+  }
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+  if (pData->bSuspended)               /* read suspension ? */
+  {
+     iRetcode            = MNG_NEEDMOREDATA;
+     pData->iSuspendtime = pData->fGettickcount ((mng_handle)pData);
+  }
+  else
+  if (pData->bTimerset)                /* indicate timer break ? */
+    iRetcode = MNG_NEEDTIMERWAIT;
+  else
+  if (pData->bSectionwait)             /* indicate section break ? */
+    iRetcode = MNG_NEEDSECTIONWAIT;
+  else
+  {                                    /* no breaks = end of run */
+    pData->bRunning = MNG_FALSE;
+
+    if (pData->bFreezing)              /* trying to freeze ? */
+      pData->bFreezing = MNG_FALSE;    /* then we're there */
+
+    if (pData->bResetting)             /* trying to reset as well ? */
+    {                                  /* full stop!!! */
+      pData->bDisplaying = MNG_FALSE;
+
+      iRetcode = mng_reset_rundata (pData);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+  
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_RESUME, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_display_freeze (mng_handle hHandle)
+{
+  mng_datap pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_FREEZE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+                                       /* can we expect this call ? */
+  if ((!pData->bDisplaying) || (pData->bReading))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  if (pData->bRunning)                 /* is it running ? */
+  {
+    mng_retcode iRetcode;
+
+    pData->bFreezing = MNG_TRUE;       /* indicate we need to freeze */
+                                       /* continue "normal" processing */
+    iRetcode = mng_display_resume (hHandle);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_FREEZE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_display_reset (mng_handle hHandle)
+{
+  mng_datap   pData;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_RESET, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+                                       /* can we expect this call ? */
+  if ((!pData->bDisplaying) || (pData->bReading))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  if (pData->bRunning)                 /* is it running ? */
+  {
+    pData->bFreezing  = MNG_TRUE;      /* indicate we need to freeze */
+    pData->bResetting = MNG_TRUE;      /* indicate we're about to reset too */
+                                       /* continue normal processing ? */
+    iRetcode = mng_display_resume (hHandle);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+  else
+  {                                    /* full stop!!! */
+    pData->bDisplaying = MNG_FALSE;
+
+    iRetcode = mng_reset_rundata (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_RESET, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_DISPLAY_GO_SUPPORTED
+mng_retcode MNG_DECL mng_display_goframe (mng_handle hHandle,
+                                          mng_uint32 iFramenr)
+{
+  mng_datap   pData;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_GOFRAME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  if (pData->eImagetype != mng_it_mng) /* is it an animation ? */
+    MNG_ERROR (pData, MNG_NOTANANIMATION);
+                                       /* can we expect this call ? */
+  if ((!pData->bDisplaying) || (pData->bRunning))
+    MNG_ERROR ((mng_datap)hHandle, MNG_FUNCTIONINVALID);
+
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  if (iFramenr > pData->iTotalframes)  /* is the parameter within bounds ? */
+    MNG_ERROR (pData, MNG_FRAMENRTOOHIGH);
+                                       /* within MHDR bounds ? */
+  if ((pData->iFramecount) && (iFramenr > pData->iFramecount))
+    MNG_WARNING (pData, MNG_FRAMENRTOOHIGH);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  if (pData->iFrameseq > iFramenr)     /* search from current or go back to start ? */
+  {
+    iRetcode = mng_reset_rundata (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+  if (iFramenr)
+  {
+    pData->iRequestframe = iFramenr;   /* go find the requested frame then */
+    iRetcode = mng_process_display (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    pData->bTimerset = MNG_FALSE;      /* reset just to be safe */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_GOFRAME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_DISPLAY_GO_SUPPORTED
+mng_retcode MNG_DECL mng_display_golayer (mng_handle hHandle,
+                                          mng_uint32 iLayernr)
+{
+  mng_datap   pData;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_GOLAYER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  if (pData->eImagetype != mng_it_mng) /* is it an animation ? */
+    MNG_ERROR (pData, MNG_NOTANANIMATION);
+                                       /* can we expect this call ? */
+  if ((!pData->bDisplaying) || (pData->bRunning))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  if (iLayernr > pData->iTotallayers)  /* is the parameter within bounds ? */
+    MNG_ERROR (pData, MNG_LAYERNRTOOHIGH);
+                                       /* within MHDR bounds ? */
+  if ((pData->iLayercount) && (iLayernr > pData->iLayercount))
+    MNG_WARNING (pData, MNG_LAYERNRTOOHIGH);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  if (pData->iLayerseq > iLayernr)     /* search from current or go back to start ? */
+  {
+    iRetcode = mng_reset_rundata (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+  if (iLayernr)
+  {
+    pData->iRequestlayer = iLayernr;   /* go find the requested layer then */
+    iRetcode = mng_process_display (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    pData->bTimerset = MNG_FALSE;      /* reset just to be safe */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_GOLAYER, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_DISPLAY_GO_SUPPORTED
+mng_retcode MNG_DECL mng_display_gotime (mng_handle hHandle,
+                                         mng_uint32 iPlaytime)
+{
+  mng_datap   pData;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_GOTIME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  if (pData->eImagetype != mng_it_mng) /* is it an animation ? */
+    MNG_ERROR (pData, MNG_NOTANANIMATION);
+                                       /* can we expect this call ? */
+  if ((!pData->bDisplaying) || (pData->bRunning))
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+                                       /* is the parameter within bounds ? */
+  if (iPlaytime > pData->iTotalplaytime)
+    MNG_ERROR (pData, MNG_PLAYTIMETOOHIGH);
+                                       /* within MHDR bounds ? */
+  if ((pData->iPlaytime) && (iPlaytime > pData->iPlaytime))
+    MNG_WARNING (pData, MNG_PLAYTIMETOOHIGH);
+
+  cleanup_errors (pData);              /* cleanup previous errors */
+
+  if (pData->iFrametime > iPlaytime)   /* search from current or go back to start ? */
+  {
+    iRetcode = mng_reset_rundata (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+  if (iPlaytime)
+  {
+    pData->iRequesttime = iPlaytime;   /* go find the requested playtime then */
+    iRetcode = mng_process_display (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    pData->bTimerset = MNG_FALSE;      /* reset just to be safe */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_DISPLAY_GOTIME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_DISPLAY) && defined(MNG_SUPPORT_DYNAMICMNG)
+mng_retcode MNG_DECL mng_trapevent (mng_handle hHandle,
+                                    mng_uint8  iEventtype,
+                                    mng_int32  iX,
+                                    mng_int32  iY)
+{
+  mng_datap   pData;
+  mng_eventp  pEvent;
+  mng_bool    bFound = MNG_FALSE;
+  mng_retcode iRetcode;
+  mng_imagep  pImage;
+  mng_uint8p  pPixel;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_TRAPEVENT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  if (pData->eImagetype != mng_it_mng) /* is it an animation ? */
+    MNG_ERROR (pData, MNG_NOTANANIMATION);
+
+  if (!pData->bDisplaying)             /* can we expect this call ? */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  if (!pData->bCacheplayback)          /* must store playback info to work!! */
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+                                       /* let's find a matching event object */
+  pEvent = (mng_eventp)pData->pFirstevent;
+
+  while ((pEvent) && (!bFound))
+  {                                    /* matching eventtype ? */
+    if (pEvent->iEventtype == iEventtype)
+    {
+      switch (pEvent->iMasktype)       /* check X/Y on basis of masktype */
+      {
+        case MNG_MASK_NONE :           /* no mask is easy */
+          {
+            bFound = MNG_TRUE;
+            break;
+          }
+
+        case MNG_MASK_BOX :            /* inside the given box ? */
+          {                            /* right- and bottom-border don't count ! */
+            if ((iX >= pEvent->iLeft) && (iX < pEvent->iRight) &&
+                (iY >= pEvent->iTop) && (iY < pEvent->iBottom))
+              bFound = MNG_TRUE;
+            break;
+          }
+          
+        case MNG_MASK_OBJECT :         /* non-zero pixel in the image object ? */
+          {
+            pImage = mng_find_imageobject (pData, pEvent->iObjectid);
+                                       /* valid image ? */
+            if ((pImage) && (pImage->pImgbuf->iBitdepth <= 8) &&
+                ((pImage->pImgbuf->iColortype == 0) || (pImage->pImgbuf->iColortype == 3)) &&
+                ((mng_int32)pImage->pImgbuf->iWidth  > iX) &&
+                ((mng_int32)pImage->pImgbuf->iHeight > iY))
+            {
+              pPixel = pImage->pImgbuf->pImgdata + ((pImage->pImgbuf->iWidth * iY) + iX);
+
+              if (*pPixel)             /* non-zero ? */
+                bFound = MNG_TRUE;
+            }
+
+            break;
+          }
+
+        case MNG_MASK_OBJECTIX :       /* pixel in the image object matches index ? */
+          {
+            pImage = mng_find_imageobject (pData, pEvent->iObjectid);
+                                       /* valid image ? */
+            if ((pImage) && (pImage->pImgbuf->iBitdepth <= 8) &&
+                ((pImage->pImgbuf->iColortype == 0) || (pImage->pImgbuf->iColortype == 3)) &&
+                ((mng_int32)pImage->pImgbuf->iWidth  > iX) && (iX >= 0) &&
+                ((mng_int32)pImage->pImgbuf->iHeight > iY) && (iY >= 0))
+            {
+              pPixel = pImage->pImgbuf->pImgdata + ((pImage->pImgbuf->iWidth * iY) + iX);
+                                       /* matching index ? */
+              if (*pPixel == pEvent->iIndex)
+                bFound = MNG_TRUE;
+            }
+
+            break;
+          }
+
+        case MNG_MASK_BOXOBJECT :      /* non-zero pixel in the image object ? */
+          {
+            mng_int32 iTempx = iX - pEvent->iLeft;
+            mng_int32 iTempy = iY - pEvent->iTop;
+
+            pImage = mng_find_imageobject (pData, pEvent->iObjectid);
+                                       /* valid image ? */
+            if ((pImage) && (pImage->pImgbuf->iBitdepth <= 8) &&
+                ((pImage->pImgbuf->iColortype == 0) || (pImage->pImgbuf->iColortype == 3)) &&
+                (iTempx < (mng_int32)pImage->pImgbuf->iWidth) &&
+                (iTempx >= 0) && (iX < pEvent->iRight) &&
+                (iTempy < (mng_int32)pImage->pImgbuf->iHeight) &&
+                (iTempy >= 0) && (iY < pEvent->iBottom))
+            {
+              pPixel = pImage->pImgbuf->pImgdata + ((pImage->pImgbuf->iWidth * iTempy) + iTempx);
+
+              if (*pPixel)             /* non-zero ? */
+                bFound = MNG_TRUE;
+            }
+
+            break;
+          }
+
+        case MNG_MASK_BOXOBJECTIX :    /* pixel in the image object matches index ? */
+          {
+            mng_int32 iTempx = iX - pEvent->iLeft;
+            mng_int32 iTempy = iY - pEvent->iTop;
+
+            pImage = mng_find_imageobject (pData, pEvent->iObjectid);
+                                       /* valid image ? */
+            if ((pImage) && (pImage->pImgbuf->iBitdepth <= 8) &&
+                ((pImage->pImgbuf->iColortype == 0) || (pImage->pImgbuf->iColortype == 3)) &&
+                (iTempx < (mng_int32)pImage->pImgbuf->iWidth) &&
+                (iTempx >= 0) && (iX < pEvent->iRight) &&
+                (iTempy < (mng_int32)pImage->pImgbuf->iHeight) &&
+                (iTempy >= 0) && (iY < pEvent->iBottom))
+            {
+              pPixel = pImage->pImgbuf->pImgdata + ((pImage->pImgbuf->iWidth * iTempy) + iTempx);
+                                       /* matching index ? */
+              if (*pPixel == pEvent->iIndex)
+                bFound = MNG_TRUE;
+            }
+
+            break;
+          }
+
+      }
+    }
+
+    if (!bFound)                       /* try the next one */
+      pEvent = (mng_eventp)pEvent->sHeader.pNext;
+  }
+                                       /* found one that's not the last mousemove ? */
+  if ((pEvent) && ((mng_objectp)pEvent != pData->pLastmousemove))
+  {                                    /* can we start an event process now ? */
+    if ((!pData->bReading) && (!pData->bRunning))
+    {
+      pData->iEventx = iX;             /* save coordinates */
+      pData->iEventy = iY;
+                                       /* do it then ! */
+      iRetcode = pEvent->sHeader.fProcess (pData, pEvent);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+                                       /* remember last mousemove event */
+      if (pEvent->iEventtype == MNG_EVENT_MOUSEMOVE)
+        pData->pLastmousemove = (mng_objectp)pEvent;
+      else
+        pData->pLastmousemove = MNG_NULL;
+    }
+    else
+    {
+
+      /* TODO: store unprocessed events or not ??? */
+
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_TRAPEVENT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_getlasterror (mng_handle   hHandle,
+                                       mng_int8*    iSeverity,
+                                       mng_chunkid* iChunkname,
+                                       mng_uint32*  iChunkseq,
+                                       mng_int32*   iExtra1,
+                                       mng_int32*   iExtra2,
+                                       mng_pchar*   zErrortext)
+{
+  mng_datap pData;                     /* local vars */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETLASTERROR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)            /* check validity handle */
+  pData = ((mng_datap)hHandle);        /* and make it addressable */
+
+  *iSeverity  = pData->iSeverity;      /* return the appropriate fields */
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+  *iChunkname = pData->iChunkname;
+  *iChunkseq  = pData->iChunkseq;
+#else
+  *iChunkname = MNG_UINT_HUH;
+  *iChunkseq  = 0;
+#endif
+
+  *iExtra1    = pData->iErrorx1;
+  *iExtra2    = pData->iErrorx2;
+  *zErrortext = pData->zErrortext;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GETLASTERROR, MNG_LC_END);
+#endif
+
+  return pData->iErrorcode;            /* and the errorcode */
+}
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
diff --git a/src/3rdparty/libmng/libmng_jpeg.c b/src/3rdparty/libmng/libmng_jpeg.c
new file mode 100644
index 0000000..5042e1d
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_jpeg.c
@@ -0,0 +1,1088 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_jpeg.c             copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : JPEG library interface (implementation)                    * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the JPEG library interface               * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/22/2000 - G.Juyn                                * */
+/* *             - implemented all the JNG routines                         * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - added tracing of JPEG calls                              * */
+/* *             0.5.3 - 06/24/2000 - G.Juyn                                * */
+/* *             - fixed inclusion of IJG read/write code                   * */
+/* *             0.5.3 - 06/29/2000 - G.Juyn                                * */
+/* *             - fixed some 64-bit warnings                               * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for JDAA                                   * */
+/* *                                                                        * */
+/* *             1.0.1 - 04/19/2001 - G.Juyn                                * */
+/* *             - added export of JPEG functions for DLL                   * */
+/* *             1.0.1 - 04/22/2001 - G.Juyn                                * */
+/* *             - fixed memory-leaks (Thanks Gregg!)                       * */
+/* *                                                                        * */
+/* *             1.0.4 - 06/22/2002 - G.Juyn                                * */
+/* *             - B526138 - returned IJGSRC6B calling convention to        * */
+/* *               default for MSVC                                         * */
+/* *                                                                        * */
+/* *             1.0.5 - 24/02/2003 - G.Juyn                                * */
+/* *             - B683152 - libjpeg suspension not always honored correctly* */
+/* *                                                                        * */
+/* *             1.0.6 - 03/04/2003 - G.Juyn                                * */
+/* *             - fixed some compiler-warnings                             * */
+/* *                                                                        * */
+/* *             1.0.8 - 08/01/2004 - G.Juyn                                * */
+/* *             - added support for 3+byte pixelsize for JPEG's            * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_pixels.h"
+#include "libmng_jpeg.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#if defined(MNG_INCLUDE_JNG) && defined(MNG_INCLUDE_DISPLAY_PROCS)
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Local IJG callback routines (source-manager, error-manager and such)   * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_IJG6B
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+#ifdef MNG_DEFINE_JPEG_STDCALL
+void MNG_DECL mng_init_source (j_decompress_ptr cinfo)
+#else
+void mng_init_source (j_decompress_ptr cinfo)
+#endif
+{
+  return;                              /* nothing needed */
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+#ifdef MNG_DEFINE_JPEG_STDCALL
+boolean MNG_DECL mng_fill_input_buffer (j_decompress_ptr cinfo)
+#else
+boolean mng_fill_input_buffer (j_decompress_ptr cinfo)
+#endif
+{
+  return FALSE;                        /* force IJG routine to return to caller */
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+#ifdef MNG_DEFINE_JPEG_STDCALL
+void MNG_DECL mng_skip_input_data (j_decompress_ptr cinfo, long num_bytes)
+#else
+void mng_skip_input_data (j_decompress_ptr cinfo, long num_bytes)
+#endif
+{
+  if (num_bytes > 0)                   /* ignore fony calls */
+  {                                    /* address my generic structure */
+    mng_datap pData = (mng_datap)cinfo->client_data;
+                                       /* address source manager */
+    mngjpeg_sourcep pSrc = pData->pJPEGdinfo->src;
+                                       /* problem scenario ? */
+    if (pSrc->bytes_in_buffer < (size_t)num_bytes)
+    {                                  /* tell the boss we need to skip some data! */
+      pData->iJPEGtoskip = (mng_uint32)((size_t)num_bytes - pSrc->bytes_in_buffer);
+
+      pSrc->bytes_in_buffer = 0;       /* let the JPEG lib suspend */
+      pSrc->next_input_byte = MNG_NULL;
+    }
+    else
+    {                                  /* simply advance in the buffer */
+      pSrc->bytes_in_buffer -= num_bytes;
+      pSrc->next_input_byte += num_bytes;
+    }
+  }
+
+  return;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+#ifdef MNG_DEFINE_JPEG_STDCALL
+void MNG_DECL mng_skip_input_data2 (j_decompress_ptr cinfo, long num_bytes)
+#else
+void mng_skip_input_data2 (j_decompress_ptr cinfo, long num_bytes)
+#endif
+{
+  if (num_bytes > 0)                   /* ignore fony calls */
+  {                                    /* address my generic structure */
+    mng_datap pData = (mng_datap)cinfo->client_data;
+                                       /* address source manager */
+    mngjpeg_sourcep pSrc = pData->pJPEGdinfo2->src;
+                                       /* problem scenario ? */
+    if (pSrc->bytes_in_buffer < (size_t)num_bytes)
+    {                                  /* tell the boss we need to skip some data! */
+      pData->iJPEGtoskip2 = (mng_uint32)((size_t)num_bytes - pSrc->bytes_in_buffer);
+
+      pSrc->bytes_in_buffer = 0;       /* let the JPEG lib suspend */
+      pSrc->next_input_byte = MNG_NULL;
+    }
+    else
+    {                                  /* simply advance in the buffer */
+      pSrc->bytes_in_buffer -= num_bytes;
+      pSrc->next_input_byte += num_bytes;
+    }
+  }
+
+  return;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+#ifdef MNG_DEFINE_JPEG_STDCALL
+void MNG_DECL mng_term_source (j_decompress_ptr cinfo)
+#else
+void mng_term_source (j_decompress_ptr cinfo)
+#endif
+{
+  return;                              /* nothing needed */
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_USE_SETJMP
+#ifdef MNG_DEFINE_JPEG_STDCALL
+void MNG_DECL mng_error_exit (j_common_ptr cinfo)
+#else
+void mng_error_exit (j_common_ptr cinfo)
+#endif
+{                                      /* address my generic structure */
+  mng_datap pData = (mng_datap)cinfo->client_data;
+
+#ifdef MNG_ERROR_TELLTALE              /* fill the message text ??? */
+  (*cinfo->err->output_message) (cinfo);
+#endif
+                                       /* return to the point of no return... */
+  longjmp (pData->sErrorbuf, cinfo->err->msg_code);
+}
+#endif /* MNG_USE_SETJMP */
+
+/* ************************************************************************** */
+
+#ifdef MNG_USE_SETJMP
+#ifdef MNG_DEFINE_JPEG_STDCALL
+void MNG_DECL mng_output_message (j_common_ptr cinfo)
+#else
+void mng_output_message (j_common_ptr cinfo)
+#endif
+{
+  return;                              /* just do nothing ! */
+}
+#endif /* MNG_USE_SETJMP */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_IJG6B */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Global JPEG routines                                                   * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mngjpeg_initialize (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_INITIALIZE, MNG_LC_START);
+#endif
+                                       /* allocate space for JPEG structures if necessary */
+#ifdef MNG_INCLUDE_JNG_READ
+  if (pData->pJPEGderr   == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGderr,   sizeof (mngjpeg_error ));
+  if (pData->pJPEGdsrc   == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGdsrc,   sizeof (mngjpeg_source));
+  if (pData->pJPEGdinfo  == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGdinfo,  sizeof (mngjpeg_decomp));
+                                       /* enable reverse addressing */
+  pData->pJPEGdinfo->client_data  = pData;
+
+  if (pData->pJPEGderr2  == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGderr2,  sizeof (mngjpeg_error ));
+  if (pData->pJPEGdsrc2  == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGdsrc2,  sizeof (mngjpeg_source));
+  if (pData->pJPEGdinfo2 == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGdinfo2, sizeof (mngjpeg_decomp));
+                                       /* enable reverse addressing */
+  pData->pJPEGdinfo2->client_data = pData;
+#endif
+
+#ifdef MNG_INCLUDE_JNG_WRITE
+  if (pData->pJPEGcerr  == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGcerr,  sizeof (mngjpeg_error ));
+  if (pData->pJPEGcinfo == MNG_NULL)
+    MNG_ALLOC (pData, pData->pJPEGcinfo, sizeof (mngjpeg_comp  ));
+                                       /* enable reverse addressing */
+  pData->pJPEGcinfo->client_data = pData;
+#endif
+
+  if (pData->pJPEGbuf   == MNG_NULL)   /* initialize temporary buffers */
+  {
+    pData->iJPEGbufmax     = MNG_JPEG_MAXBUF;
+    MNG_ALLOC (pData, pData->pJPEGbuf, pData->iJPEGbufmax);
+  }
+
+  if (pData->pJPEGbuf2  == MNG_NULL) 
+  {
+    pData->iJPEGbufmax2    = MNG_JPEG_MAXBUF;
+    MNG_ALLOC (pData, pData->pJPEGbuf2, pData->iJPEGbufmax2);
+  }
+
+  pData->pJPEGcurrent      = pData->pJPEGbuf;
+  pData->iJPEGbufremain    = 0;
+  pData->pJPEGrow          = MNG_NULL;
+  pData->iJPEGrowlen       = 0;
+  pData->iJPEGtoskip       = 0;
+
+  pData->pJPEGcurrent2     = pData->pJPEGbuf2;
+  pData->iJPEGbufremain2   = 0;
+  pData->pJPEGrow2         = MNG_NULL;
+  pData->iJPEGrowlen2      = 0;
+  pData->iJPEGtoskip2      = 0;
+                                      /* not doing anything yet ! */
+  pData->bJPEGcompress     = MNG_FALSE;
+  
+  pData->bJPEGdecompress   = MNG_FALSE;
+  pData->bJPEGhasheader    = MNG_FALSE;
+  pData->bJPEGdecostarted  = MNG_FALSE;
+  pData->bJPEGscanstarted  = MNG_FALSE;
+  pData->bJPEGscanending   = MNG_FALSE;
+
+  pData->bJPEGdecompress2  = MNG_FALSE;
+  pData->bJPEGhasheader2   = MNG_FALSE;
+  pData->bJPEGdecostarted2 = MNG_FALSE;
+  pData->bJPEGscanstarted2 = MNG_FALSE;
+
+  pData->iJPEGrow          = 0;        /* zero input/output lines */
+  pData->iJPEGalpharow     = 0;
+  pData->iJPEGrgbrow       = 0;
+  pData->iJPEGdisprow      = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_INITIALIZE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngjpeg_cleanup (mng_datap pData)
+{
+#if defined(MNG_INCLUDE_IJG6B) && defined(MNG_USE_SETJMP)
+  mng_retcode iRetcode;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_CLEANUP, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_IJG6B
+#ifdef MNG_USE_SETJMP
+  iRetcode = setjmp (pData->sErrorbuf);/* setup local JPEG error-recovery */
+  if (iRetcode != 0)                   /* got here from longjmp ? */
+    MNG_ERRORJ (pData, iRetcode);      /* then IJG-lib issued an error */
+#endif
+
+#ifdef MNG_INCLUDE_JNG_READ            /* still decompressing something ? */
+  if (pData->bJPEGdecompress)
+    jpeg_destroy_decompress (pData->pJPEGdinfo);
+  if (pData->bJPEGdecompress2)
+    jpeg_destroy_decompress (pData->pJPEGdinfo2);
+#endif
+
+#ifdef MNG_INCLUDE_JNG_WRITE
+  if (pData->bJPEGcompress)            /* still compressing something ? */
+    jpeg_destroy_compress (pData->pJPEGcinfo);
+#endif
+
+#endif /* MNG_INCLUDE_IJG6B */
+                                       /* cleanup temporary buffers */
+  MNG_FREE (pData, pData->pJPEGbuf2, pData->iJPEGbufmax2);
+  MNG_FREE (pData, pData->pJPEGbuf,  pData->iJPEGbufmax);
+                                       /* cleanup space for JPEG structures */
+#ifdef MNG_INCLUDE_JNG_WRITE
+  MNG_FREE (pData, pData->pJPEGcinfo,  sizeof (mngjpeg_comp  ));
+  MNG_FREE (pData, pData->pJPEGcerr,   sizeof (mngjpeg_error ));
+#endif
+
+#ifdef MNG_INCLUDE_JNG_READ
+  MNG_FREE (pData, pData->pJPEGdinfo,  sizeof (mngjpeg_decomp));
+  MNG_FREE (pData, pData->pJPEGdsrc,   sizeof (mngjpeg_source));
+  MNG_FREE (pData, pData->pJPEGderr,   sizeof (mngjpeg_error ));
+  MNG_FREE (pData, pData->pJPEGdinfo2, sizeof (mngjpeg_decomp));
+  MNG_FREE (pData, pData->pJPEGdsrc2,  sizeof (mngjpeg_source));
+  MNG_FREE (pData, pData->pJPEGderr2,  sizeof (mngjpeg_error ));
+#endif
+
+  MNG_FREE (pData, pData->pJPEGrow2, pData->iJPEGrowlen2);
+  MNG_FREE (pData, pData->pJPEGrow,  pData->iJPEGrowlen);
+                                       /* whatever we were doing ... */
+                                       /* we don't anymore ... */
+  pData->bJPEGcompress     = MNG_FALSE;
+
+  pData->bJPEGdecompress   = MNG_FALSE;
+  pData->bJPEGhasheader    = MNG_FALSE;
+  pData->bJPEGdecostarted  = MNG_FALSE;
+  pData->bJPEGscanstarted  = MNG_FALSE;
+  pData->bJPEGscanending   = MNG_FALSE;
+
+  pData->bJPEGdecompress2  = MNG_FALSE;
+  pData->bJPEGhasheader2   = MNG_FALSE;
+  pData->bJPEGdecostarted2 = MNG_FALSE;
+  pData->bJPEGscanstarted2 = MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_CLEANUP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * JPEG decompression routines (JDAT)                                     * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+mng_retcode mngjpeg_decompressinit (mng_datap pData)
+{
+#if defined(MNG_INCLUDE_IJG6B) && defined(MNG_USE_SETJMP)
+  mng_retcode iRetcode;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSINIT, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_IJG6B
+  /* allocate and initialize a JPEG decompression object */
+  pData->pJPEGdinfo->err = jpeg_std_error (pData->pJPEGderr);
+
+#ifdef MNG_USE_SETJMP                  /* setup local JPEG error-routines */
+  pData->pJPEGderr->error_exit     = mng_error_exit;
+  pData->pJPEGderr->output_message = mng_output_message;
+
+  iRetcode = setjmp (pData->sErrorbuf);/* setup local JPEG error-recovery */
+  if (iRetcode != 0)                   /* got here from longjmp ? */
+    MNG_ERRORJ (pData, iRetcode);      /* then IJG-lib issued an error */
+#endif /* MNG_USE_SETJMP */
+
+  /* allocate and initialize a JPEG decompression object (continued) */
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSINIT, MNG_LC_JPEG_CREATE_DECOMPRESS)
+#endif
+  jpeg_create_decompress (pData->pJPEGdinfo);
+
+  pData->bJPEGdecompress = MNG_TRUE;   /* indicate it's initialized */
+
+  /* specify the source of the compressed data (eg, a file) */
+                                       /* no, not a file; we have buffered input */
+  pData->pJPEGdinfo->src = pData->pJPEGdsrc;
+                                       /* use the default handler */
+  pData->pJPEGdinfo->src->resync_to_restart = jpeg_resync_to_restart;
+                                       /* setup local source routine & parms */
+  pData->pJPEGdinfo->src->init_source       = mng_init_source;
+  pData->pJPEGdinfo->src->fill_input_buffer = mng_fill_input_buffer;
+  pData->pJPEGdinfo->src->skip_input_data   = mng_skip_input_data;
+  pData->pJPEGdinfo->src->term_source       = mng_term_source;
+  pData->pJPEGdinfo->src->next_input_byte   = pData->pJPEGcurrent;
+  pData->pJPEGdinfo->src->bytes_in_buffer   = pData->iJPEGbufremain;
+
+#endif /* MNG_INCLUDE_IJG6B */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSINIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+mng_retcode mngjpeg_decompressdata (mng_datap  pData,
+                                    mng_uint32 iRawsize,
+                                    mng_uint8p pRawdata)
+{
+  mng_retcode iRetcode;
+  mng_uint32  iRemain;
+  mng_uint8p  pWork;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_START);
+#endif
+
+#if defined (MNG_INCLUDE_IJG6B) && defined(MNG_USE_SETJMP)
+  iRetcode = setjmp (pData->sErrorbuf);/* initialize local JPEG error-recovery */
+  if (iRetcode != 0)                   /* got here from longjmp ? */
+    MNG_ERRORJ (pData, iRetcode);      /* then IJG-lib issued an error */
+#endif
+
+  pWork   = pRawdata;
+  iRemain = iRawsize;
+
+  if (pData->iJPEGtoskip)              /* JPEG-lib told us to skip some more data ? */
+  {
+    if (iRemain > pData->iJPEGtoskip)  /* enough data in this buffer ? */
+    {
+      iRemain -= pData->iJPEGtoskip;   /* skip enough to access the next byte */
+      pWork   += pData->iJPEGtoskip;
+
+      pData->iJPEGtoskip = 0;          /* no more to skip then */
+    }
+    else
+    {
+      pData->iJPEGtoskip -= iRemain;   /* skip all data in the buffer */
+      iRemain = 0;                     /* and indicate this accordingly */
+    }
+                                       /* the skip set current-pointer to NULL ! */
+    pData->pJPEGcurrent = pData->pJPEGbuf;
+  }
+
+  while (iRemain)                      /* repeat until no more input-bytes */
+  {                                    /* need to shift anything ? */
+    if ((pData->pJPEGcurrent > pData->pJPEGbuf) &&
+        (pData->pJPEGcurrent - pData->pJPEGbuf + pData->iJPEGbufremain + iRemain > pData->iJPEGbufmax))
+    {
+      if (pData->iJPEGbufremain > 0)   /* then do so */
+        MNG_COPY (pData->pJPEGbuf, pData->pJPEGcurrent, pData->iJPEGbufremain);
+
+      pData->pJPEGcurrent = pData->pJPEGbuf;
+    }
+                                       /* does the remaining input fit into the buffer ? */
+    if (pData->iJPEGbufremain + iRemain <= pData->iJPEGbufmax)
+    {                                  /* move the lot */
+      MNG_COPY ((pData->pJPEGcurrent + pData->iJPEGbufremain), pWork, iRemain);
+
+      pData->iJPEGbufremain += iRemain;/* adjust remaining_bytes counter */
+      iRemain = 0;                     /* and indicate there's no input left */
+    }
+    else
+    {                                  /* calculate what does fit */
+      mng_uint32 iFits = pData->iJPEGbufmax - pData->iJPEGbufremain;
+
+      if (iFits <= 0)                  /* no space is just bugger 'm all */
+        MNG_ERROR (pData, MNG_JPEGBUFTOOSMALL);
+                                       /* move that */
+      MNG_COPY ((pData->pJPEGcurrent + pData->iJPEGbufremain), pWork, iFits);
+
+      pData->iJPEGbufremain += iFits;  /* adjust remain_bytes counter */
+      iRemain -= iFits;                /* and the input-parms */
+      pWork   += iFits;
+    }
+
+#ifdef MNG_INCLUDE_IJG6B
+    pData->pJPEGdinfo->src->next_input_byte = pData->pJPEGcurrent;
+    pData->pJPEGdinfo->src->bytes_in_buffer = pData->iJPEGbufremain;
+
+    if (!pData->bJPEGhasheader)        /* haven't got the header yet ? */
+    {
+      /* call jpeg_read_header() to obtain image info */
+#ifdef MNG_SUPPORT_TRACE
+      MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_READ_HEADER)
+#endif
+      if (jpeg_read_header (pData->pJPEGdinfo, TRUE) != JPEG_SUSPENDED)
+      {                                /* indicate the header's oke */
+        pData->bJPEGhasheader = MNG_TRUE;
+                                       /* let's do some sanity checks ! */
+        if ((pData->pJPEGdinfo->image_width  != pData->iDatawidth ) ||
+            (pData->pJPEGdinfo->image_height != pData->iDataheight)    )
+          MNG_ERROR (pData, MNG_JPEGPARMSERR);
+
+        if ( ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAY ) ||
+              (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA)    ) &&
+             (pData->pJPEGdinfo->jpeg_color_space != JCS_GRAYSCALE  )    )
+          MNG_ERROR (pData, MNG_JPEGPARMSERR);
+
+        if ( ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLOR ) ||
+              (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    ) &&
+             (pData->pJPEGdinfo->jpeg_color_space != JCS_YCbCr       )    )
+          MNG_ERROR (pData, MNG_JPEGPARMSERR);
+                                       /* indicate whether or not it's progressive */
+        pData->bJPEGprogressive = (mng_bool)jpeg_has_multiple_scans (pData->pJPEGdinfo);
+                                       /* progressive+alpha can't display "on-the-fly"!! */
+        if ((pData->bJPEGprogressive) &&
+            ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA ) ||
+             (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    ))
+          pData->fDisplayrow = MNG_NULL;
+                                       /* allocate a row of JPEG-samples */
+        if (pData->pJPEGdinfo->jpeg_color_space == JCS_YCbCr)
+          pData->iJPEGrowlen = pData->pJPEGdinfo->image_width * RGB_PIXELSIZE;
+        else
+          pData->iJPEGrowlen = pData->pJPEGdinfo->image_width;
+
+        MNG_ALLOC (pData, pData->pJPEGrow, pData->iJPEGrowlen);
+
+        pData->iJPEGrgbrow = 0;        /* quite empty up to now */
+      }
+
+      pData->pJPEGcurrent   = (mng_uint8p)pData->pJPEGdinfo->src->next_input_byte;
+      pData->iJPEGbufremain = (mng_uint32)pData->pJPEGdinfo->src->bytes_in_buffer;
+    }
+                                       /* decompress not started ? */
+    if ((pData->bJPEGhasheader) && (!pData->bJPEGdecostarted))
+    {
+      /* set parameters for decompression */
+
+      if (pData->bJPEGprogressive)     /* progressive display ? */
+        pData->pJPEGdinfo->buffered_image = TRUE;
+
+      /* jpeg_start_decompress(...); */
+#ifdef MNG_SUPPORT_TRACE
+      MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_START_DECOMPRESS)
+#endif
+      if (jpeg_start_decompress (pData->pJPEGdinfo) == TRUE)
+                                       /* indicate it started */
+        pData->bJPEGdecostarted = MNG_TRUE;
+
+      pData->pJPEGcurrent   = (mng_uint8p)pData->pJPEGdinfo->src->next_input_byte;
+      pData->iJPEGbufremain = (mng_uint32)pData->pJPEGdinfo->src->bytes_in_buffer;
+    }
+                                       /* process some scanlines ? */
+    if ((pData->bJPEGhasheader) && (pData->bJPEGdecostarted) &&
+	    ((!jpeg_input_complete (pData->pJPEGdinfo)) ||
+         (pData->pJPEGdinfo->output_scanline < pData->pJPEGdinfo->output_height) ||
+         ((pData->bJPEGprogressive) && (pData->bJPEGscanending))))
+    {
+      mng_int32 iLines = 0;
+
+      /* for (each output pass) */
+      do
+      {                                /* address the row output buffer */
+        JSAMPROW pRow = (JSAMPROW)pData->pJPEGrow;
+
+                                       /* init new pass ? */
+        if ((pData->bJPEGprogressive) && (!pData->bJPEGscanstarted))
+        {
+          pData->bJPEGscanstarted = MNG_TRUE;
+
+          /* adjust output decompression parameters if required */
+          /* nop */
+
+          /* start a new output pass */
+#ifdef MNG_SUPPORT_TRACE
+          MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_START_OUTPUT)
+#endif
+          jpeg_start_output (pData->pJPEGdinfo, pData->pJPEGdinfo->input_scan_number);
+
+          pData->iJPEGrow = 0;         /* start at row 0 in the image again */
+        }
+
+        /* while (scan lines remain to be read) */
+        if ((!pData->bJPEGprogressive) || (!pData->bJPEGscanending))
+        {
+          do
+          {
+          /*   jpeg_read_scanlines(...); */
+#ifdef MNG_SUPPORT_TRACE
+            MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_READ_SCANLINES)
+#endif
+            iLines = jpeg_read_scanlines (pData->pJPEGdinfo, (JSAMPARRAY)&pRow, 1);
+
+            pData->pJPEGcurrent   = (mng_uint8p)pData->pJPEGdinfo->src->next_input_byte;
+            pData->iJPEGbufremain = (mng_uint32)pData->pJPEGdinfo->src->bytes_in_buffer;
+
+            if (iLines > 0)            /* got something ? */
+            {
+              if (pData->fStorerow2)   /* store in object ? */
+              {
+                iRetcode = ((mng_storerow)pData->fStorerow2) (pData);
+
+                if (iRetcode)          /* on error bail out */
+                return iRetcode;
+
+              }
+            }
+          }
+          while ((pData->pJPEGdinfo->output_scanline < pData->pJPEGdinfo->output_height) &&
+                 (iLines > 0));        /* until end-of-image or not enough input-data */
+        }
+
+        /* terminate output pass */
+        if ((pData->bJPEGprogressive) &&
+            (pData->pJPEGdinfo->output_scanline >= pData->pJPEGdinfo->output_height))
+        {
+#ifdef MNG_SUPPORT_TRACE
+          MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_FINISH_OUTPUT)
+#endif
+          if (jpeg_finish_output (pData->pJPEGdinfo) != JPEG_SUSPENDED)
+          {                            /* this scan has ended */
+            pData->bJPEGscanstarted = MNG_FALSE;
+            pData->bJPEGscanending  = MNG_FALSE;
+          }
+          else
+          {
+            pData->bJPEGscanending  = MNG_TRUE;
+          }
+        }
+      }
+      while ((!jpeg_input_complete (pData->pJPEGdinfo)) &&
+             (iLines > 0) && (!pData->bJPEGscanending));
+    }
+                                       /* end of image ? */
+    if ((pData->bJPEGhasheader) && (pData->bJPEGdecostarted) &&
+        (!pData->bJPEGscanending) && (jpeg_input_complete (pData->pJPEGdinfo)) &&
+        (pData->pJPEGdinfo->input_scan_number == pData->pJPEGdinfo->output_scan_number))
+    {
+      /* jpeg_finish_decompress(...); */
+#ifdef MNG_SUPPORT_TRACE
+      MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_FINISH_DECOMPRESS)
+#endif
+      if (jpeg_finish_decompress (pData->pJPEGdinfo) == TRUE)
+      {                                /* indicate it's done */
+        pData->bJPEGhasheader   = MNG_FALSE;
+        pData->bJPEGdecostarted = MNG_FALSE;
+        pData->pJPEGcurrent     = (mng_uint8p)pData->pJPEGdinfo->src->next_input_byte;
+        pData->iJPEGbufremain   = (mng_uint32)pData->pJPEGdinfo->src->bytes_in_buffer;
+                                       /* remaining fluff is an error ! */
+        if ((pData->iJPEGbufremain > 0) || (iRemain > 0))
+          MNG_ERROR (pData, MNG_TOOMUCHJDAT);
+      }
+    }
+#endif /* MNG_INCLUDE_IJG6B */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+mng_retcode mngjpeg_decompressfree (mng_datap pData)
+{
+#if defined(MNG_INCLUDE_IJG6B) && defined(MNG_USE_SETJMP)
+  mng_retcode iRetcode;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSFREE, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_IJG6B
+#ifdef MNG_USE_SETJMP
+  iRetcode = setjmp (pData->sErrorbuf);/* setup local JPEG error-recovery */
+  if (iRetcode != 0)                   /* got here from longjmp ? */
+    MNG_ERRORJ (pData, iRetcode);      /* then IJG-lib issued an error */
+#endif
+                                       /* free the row of JPEG-samples*/
+  MNG_FREE (pData, pData->pJPEGrow, pData->iJPEGrowlen);
+
+  /* release the JPEG decompression object */
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSFREE, MNG_LC_JPEG_DESTROY_DECOMPRESS)
+#endif
+  jpeg_destroy_decompress (pData->pJPEGdinfo);
+
+  pData->bJPEGdecompress = MNG_FALSE;  /* indicate it's done */
+
+#endif /* MNG_INCLUDE_IJG6B */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSFREE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * JPEG decompression routines (JDAA)                                     * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+mng_retcode mngjpeg_decompressinit2 (mng_datap pData)
+{
+#if defined(MNG_INCLUDE_IJG6B) && defined(MNG_USE_SETJMP)
+  mng_retcode iRetcode;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSINIT, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_IJG6B
+  /* allocate and initialize a JPEG decompression object */
+  pData->pJPEGdinfo2->err = jpeg_std_error (pData->pJPEGderr2);
+
+#ifdef MNG_USE_SETJMP                  /* setup local JPEG error-routines */
+  pData->pJPEGderr2->error_exit     = mng_error_exit;
+  pData->pJPEGderr2->output_message = mng_output_message;
+
+  iRetcode = setjmp (pData->sErrorbuf);/* setup local JPEG error-recovery */
+  if (iRetcode != 0)                   /* got here from longjmp ? */
+    MNG_ERRORJ (pData, iRetcode);      /* then IJG-lib issued an error */
+#endif /* MNG_USE_SETJMP */
+
+  /* allocate and initialize a JPEG decompression object (continued) */
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSINIT, MNG_LC_JPEG_CREATE_DECOMPRESS)
+#endif
+  jpeg_create_decompress (pData->pJPEGdinfo2);
+
+  pData->bJPEGdecompress2 = MNG_TRUE;  /* indicate it's initialized */
+
+  /* specify the source of the compressed data (eg, a file) */
+                                       /* no, not a file; we have buffered input */
+  pData->pJPEGdinfo2->src = pData->pJPEGdsrc2;
+                                       /* use the default handler */
+  pData->pJPEGdinfo2->src->resync_to_restart = jpeg_resync_to_restart;
+                                       /* setup local source routine & parms */
+  pData->pJPEGdinfo2->src->init_source       = mng_init_source;
+  pData->pJPEGdinfo2->src->fill_input_buffer = mng_fill_input_buffer;
+  pData->pJPEGdinfo2->src->skip_input_data   = mng_skip_input_data2;
+  pData->pJPEGdinfo2->src->term_source       = mng_term_source;
+  pData->pJPEGdinfo2->src->next_input_byte   = pData->pJPEGcurrent2;
+  pData->pJPEGdinfo2->src->bytes_in_buffer   = pData->iJPEGbufremain2;
+
+#endif /* MNG_INCLUDE_IJG6B */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSINIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+mng_retcode mngjpeg_decompressdata2 (mng_datap  pData,
+                                     mng_uint32 iRawsize,
+                                     mng_uint8p pRawdata)
+{
+  mng_retcode iRetcode;
+  mng_uint32  iRemain;
+  mng_uint8p  pWork;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_START);
+#endif
+
+#if defined (MNG_INCLUDE_IJG6B) && defined(MNG_USE_SETJMP)
+  iRetcode = setjmp (pData->sErrorbuf);/* initialize local JPEG error-recovery */
+  if (iRetcode != 0)                   /* got here from longjmp ? */
+    MNG_ERRORJ (pData, iRetcode);      /* then IJG-lib issued an error */
+#endif
+
+  pWork   = pRawdata;
+  iRemain = iRawsize;
+
+  if (pData->iJPEGtoskip2)             /* JPEG-lib told us to skip some more data ? */
+  {
+    if (iRemain > pData->iJPEGtoskip2) /* enough data in this buffer ? */
+    {
+      iRemain -= pData->iJPEGtoskip2;  /* skip enough to access the next byte */
+      pWork   += pData->iJPEGtoskip2;
+
+      pData->iJPEGtoskip2 = 0;         /* no more to skip then */
+    }
+    else
+    {
+      pData->iJPEGtoskip2 -= iRemain;  /* skip all data in the buffer */
+      iRemain = 0;                     /* and indicate this accordingly */
+    }
+                                       /* the skip set current-pointer to NULL ! */
+    pData->pJPEGcurrent2 = pData->pJPEGbuf2;
+  }
+
+  while (iRemain)                      /* repeat until no more input-bytes */
+  {                                    /* need to shift anything ? */
+    if ((pData->pJPEGcurrent2 > pData->pJPEGbuf2) &&
+        (pData->pJPEGcurrent2 - pData->pJPEGbuf2 + pData->iJPEGbufremain2 + iRemain > pData->iJPEGbufmax2))
+    {
+      if (pData->iJPEGbufremain2 > 0)  /* then do so */
+        MNG_COPY (pData->pJPEGbuf2, pData->pJPEGcurrent2, pData->iJPEGbufremain2);
+
+      pData->pJPEGcurrent2 = pData->pJPEGbuf2;
+    }
+                                       /* does the remaining input fit into the buffer ? */
+    if (pData->iJPEGbufremain2 + iRemain <= pData->iJPEGbufmax2)
+    {                                  /* move the lot */
+      MNG_COPY ((pData->pJPEGcurrent2 + pData->iJPEGbufremain2), pWork, iRemain);
+                                       /* adjust remaining_bytes counter */
+      pData->iJPEGbufremain2 += iRemain;
+      iRemain = 0;                     /* and indicate there's no input left */
+    }
+    else
+    {                                  /* calculate what does fit */
+      mng_uint32 iFits = pData->iJPEGbufmax2 - pData->iJPEGbufremain2;
+
+      if (iFits <= 0)                  /* no space is just bugger 'm all */
+        MNG_ERROR (pData, MNG_JPEGBUFTOOSMALL);
+                                       /* move that */
+      MNG_COPY ((pData->pJPEGcurrent2 + pData->iJPEGbufremain2), pWork, iFits);
+
+      pData->iJPEGbufremain2 += iFits; /* adjust remain_bytes counter */
+      iRemain -= iFits;                /* and the input-parms */
+      pWork   += iFits;
+    }
+
+#ifdef MNG_INCLUDE_IJG6B
+    pData->pJPEGdinfo2->src->next_input_byte = pData->pJPEGcurrent2;
+    pData->pJPEGdinfo2->src->bytes_in_buffer = pData->iJPEGbufremain2;
+
+    if (!pData->bJPEGhasheader2)       /* haven't got the header yet ? */
+    {
+      /* call jpeg_read_header() to obtain image info */
+#ifdef MNG_SUPPORT_TRACE
+      MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_READ_HEADER)
+#endif
+      if (jpeg_read_header (pData->pJPEGdinfo2, TRUE) != JPEG_SUSPENDED)
+      {                                /* indicate the header's oke */
+        pData->bJPEGhasheader2 = MNG_TRUE;
+                                       /* let's do some sanity checks ! */
+        if ((pData->pJPEGdinfo2->image_width  != pData->iDatawidth ) ||
+            (pData->pJPEGdinfo2->image_height != pData->iDataheight)    )
+          MNG_ERROR (pData, MNG_JPEGPARMSERR);
+
+        if (pData->pJPEGdinfo2->jpeg_color_space != JCS_GRAYSCALE)
+          MNG_ERROR (pData, MNG_JPEGPARMSERR);
+                                       /* indicate whether or not it's progressive */
+        pData->bJPEGprogressive2 = (mng_bool)jpeg_has_multiple_scans (pData->pJPEGdinfo2);
+
+        if (pData->bJPEGprogressive2)  /* progressive alphachannel not allowed !!! */
+          MNG_ERROR (pData, MNG_JPEGPARMSERR);
+                                       /* allocate a row of JPEG-samples */
+        if (pData->pJPEGdinfo2->jpeg_color_space == JCS_YCbCr)
+          pData->iJPEGrowlen2 = pData->pJPEGdinfo2->image_width * RGB_PIXELSIZE;
+        else
+          pData->iJPEGrowlen2 = pData->pJPEGdinfo2->image_width;
+
+        MNG_ALLOC (pData, pData->pJPEGrow2, pData->iJPEGrowlen2);
+
+        pData->iJPEGalpharow = 0;      /* quite empty up to now */
+      }
+
+      pData->pJPEGcurrent2   = (mng_uint8p)pData->pJPEGdinfo2->src->next_input_byte;
+      pData->iJPEGbufremain2 = (mng_uint32)pData->pJPEGdinfo2->src->bytes_in_buffer;
+    }
+                                       /* decompress not started ? */
+    if ((pData->bJPEGhasheader2) && (!pData->bJPEGdecostarted2))
+    {
+      /* set parameters for decompression */
+
+      if (pData->bJPEGprogressive2)    /* progressive display ? */
+        pData->pJPEGdinfo2->buffered_image = TRUE;
+
+      /* jpeg_start_decompress(...); */
+#ifdef MNG_SUPPORT_TRACE
+      MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_START_DECOMPRESS)
+#endif
+      if (jpeg_start_decompress (pData->pJPEGdinfo2) == TRUE)
+                                       /* indicate it started */
+        pData->bJPEGdecostarted2 = MNG_TRUE;
+
+      pData->pJPEGcurrent2   = (mng_uint8p)pData->pJPEGdinfo2->src->next_input_byte;
+      pData->iJPEGbufremain2 = (mng_uint32)pData->pJPEGdinfo2->src->bytes_in_buffer;
+    }
+                                       /* process some scanlines ? */
+    if ((pData->bJPEGhasheader2) && (pData->bJPEGdecostarted2) &&
+	    ((!jpeg_input_complete (pData->pJPEGdinfo2)) ||
+         (pData->pJPEGdinfo2->output_scanline < pData->pJPEGdinfo2->output_height)))
+    {
+      mng_int32 iLines;
+
+      /* for (each output pass) */
+      do
+      {                                /* address the row output buffer */
+        JSAMPROW pRow = (JSAMPROW)pData->pJPEGrow2;
+
+                                       /* init new pass ? */
+        if ((pData->bJPEGprogressive2) &&
+            ((!pData->bJPEGscanstarted2) ||
+             (pData->pJPEGdinfo2->output_scanline >= pData->pJPEGdinfo2->output_height)))
+        {
+          pData->bJPEGscanstarted2 = MNG_TRUE;
+
+          /* adjust output decompression parameters if required */
+          /* nop */
+
+          /* start a new output pass */
+#ifdef MNG_SUPPORT_TRACE
+          MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_START_OUTPUT)
+#endif
+          jpeg_start_output (pData->pJPEGdinfo2, pData->pJPEGdinfo2->input_scan_number);
+
+          pData->iJPEGrow = 0;         /* start at row 0 in the image again */
+        }
+
+        /* while (scan lines remain to be read) */
+        do
+        {
+          /*   jpeg_read_scanlines(...); */
+#ifdef MNG_SUPPORT_TRACE
+          MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_READ_SCANLINES)
+#endif
+          iLines = jpeg_read_scanlines (pData->pJPEGdinfo2, (JSAMPARRAY)&pRow, 1);
+
+          pData->pJPEGcurrent2   = (mng_uint8p)pData->pJPEGdinfo2->src->next_input_byte;
+          pData->iJPEGbufremain2 = (mng_uint32)pData->pJPEGdinfo2->src->bytes_in_buffer;
+
+          if (iLines > 0)              /* got something ? */
+          {
+            if (pData->fStorerow3)     /* store in object ? */
+            {
+              iRetcode = ((mng_storerow)pData->fStorerow3) (pData);
+
+              if (iRetcode)            /* on error bail out */
+                return iRetcode;
+
+            }
+          }
+        }
+        while ((pData->pJPEGdinfo2->output_scanline < pData->pJPEGdinfo2->output_height) &&
+               (iLines > 0));          /* until end-of-image or not enough input-data */
+
+        /* terminate output pass */
+        if ((pData->bJPEGprogressive2) &&
+            (pData->pJPEGdinfo2->output_scanline >= pData->pJPEGdinfo2->output_height))
+        {
+#ifdef MNG_SUPPORT_TRACE
+          MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_FINISH_OUTPUT)
+#endif
+          if (jpeg_finish_output (pData->pJPEGdinfo2) == JPEG_SUSPENDED)
+            jpeg_finish_output (pData->pJPEGdinfo2);
+                                       /* this scan has ended */
+          pData->bJPEGscanstarted2 = MNG_FALSE;
+        }
+      }
+      while ((!jpeg_input_complete (pData->pJPEGdinfo2)) && (iLines > 0));
+    }
+                                       /* end of image ? */
+    if ((pData->bJPEGhasheader2) && (pData->bJPEGdecostarted2) &&
+        (jpeg_input_complete (pData->pJPEGdinfo2)) &&
+        (pData->pJPEGdinfo2->input_scan_number == pData->pJPEGdinfo2->output_scan_number))
+    {
+      /* jpeg_finish_decompress(...); */
+#ifdef MNG_SUPPORT_TRACE
+      MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_JPEG_FINISH_DECOMPRESS)
+#endif
+      if (jpeg_finish_decompress (pData->pJPEGdinfo2) == TRUE)
+      {                                /* indicate it's done */
+        pData->bJPEGhasheader2   = MNG_FALSE;
+        pData->bJPEGdecostarted2 = MNG_FALSE;
+        pData->pJPEGcurrent2     = (mng_uint8p)pData->pJPEGdinfo2->src->next_input_byte;
+        pData->iJPEGbufremain2   = (mng_uint32)pData->pJPEGdinfo2->src->bytes_in_buffer;
+                                       /* remaining fluff is an error ! */
+        if ((pData->iJPEGbufremain2 > 0) || (iRemain > 0))
+          MNG_ERROR (pData, MNG_TOOMUCHJDAT);
+      }
+    }
+#endif /* MNG_INCLUDE_IJG6B */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG_READ
+mng_retcode mngjpeg_decompressfree2 (mng_datap pData)
+{
+#if defined(MNG_INCLUDE_IJG6B) && defined(MNG_USE_SETJMP)
+  mng_retcode iRetcode;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSFREE, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_IJG6B
+#ifdef MNG_USE_SETJMP
+  iRetcode = setjmp (pData->sErrorbuf);/* setup local JPEG error-recovery */
+  if (iRetcode != 0)                   /* got here from longjmp ? */
+    MNG_ERRORJ (pData, iRetcode);      /* then IJG-lib issued an error */
+#endif
+                                       /* free the row of JPEG-samples*/
+  MNG_FREE (pData, pData->pJPEGrow2, pData->iJPEGrowlen2);
+
+  /* release the JPEG decompression object */
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSFREE, MNG_LC_JPEG_DESTROY_DECOMPRESS)
+#endif
+  jpeg_destroy_decompress (pData->pJPEGdinfo2);
+
+  pData->bJPEGdecompress2 = MNG_FALSE; /* indicate it's done */
+
+#endif /* MNG_INCLUDE_IJG6B */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_JPEG_DECOMPRESSFREE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_INCLUDE_JNG_READ */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_JNG && MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_jpeg.h b/src/3rdparty/libmng/libmng_jpeg.h
new file mode 100644
index 0000000..a072af9
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_jpeg.h
@@ -0,0 +1,57 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_jpeg.h             copyright (c) 2000-2002 G.Juyn   * */
+/* * version   : 1.0.0                                                      * */
+/* *                                                                        * */
+/* * purpose   : JPEG library interface (definition)                        * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the JPEG library interface                   * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for JDAA                                   * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_jpeg_h_
+#define _libmng_jpeg_h_
+
+/* ************************************************************************** */
+
+mng_retcode mngjpeg_initialize      (mng_datap  pData);
+mng_retcode mngjpeg_cleanup         (mng_datap  pData);
+
+mng_retcode mngjpeg_decompressinit  (mng_datap  pData);
+mng_retcode mngjpeg_decompressdata  (mng_datap  pData,
+                                     mng_uint32 iRawsize,
+                                     mng_uint8p pRawdata);
+mng_retcode mngjpeg_decompressfree  (mng_datap  pData);
+
+mng_retcode mngjpeg_decompressinit2 (mng_datap  pData);
+mng_retcode mngjpeg_decompressdata2 (mng_datap  pData,
+                                     mng_uint32 iRawsize,
+                                     mng_uint8p pRawdata);
+mng_retcode mngjpeg_decompressfree2 (mng_datap  pData);
+
+/* ************************************************************************** */
+
+#endif /* _libmng_jpeg_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_memory.h b/src/3rdparty/libmng/libmng_memory.h
new file mode 100644
index 0000000..b92d0c1
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_memory.h
@@ -0,0 +1,64 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_memory.h           copyright (c) 2000-2003 G.Juyn   * */
+/* * version   : 1.0.0                                                      * */
+/* *                                                                        * */
+/* * purpose   : Memory management (definition)                             * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of memory management functions                  * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/12/2000 - G.Juyn                                * */
+/* *             - swapped MNG_COPY parameter-names                         * */
+/* *             0.5.3 - 06/27/2000 - G.Juyn                                * */
+/* *             - changed size parameter to mng_size_t                     * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_memory_h_
+#define _libmng_memory_h_
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Generic memory manager macros                                          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INTERNAL_MEMMNGMT
+#define MNG_ALLOC(H,P,L)  { P = calloc (1, (mng_size_t)(L)); \
+                            if (P == 0) { MNG_ERROR (H, MNG_OUTOFMEMORY) } }
+#define MNG_ALLOCX(H,P,L) { P = calloc (1, (mng_size_t)(L)); }
+#define MNG_FREE(H,P,L)   { if (P) { free (P); P = 0; } }
+#define MNG_FREEX(H,P,L)  { if (P) free (P); }
+#else
+#define MNG_ALLOC(H,P,L)  { P = H->fMemalloc ((mng_size_t)(L)); \
+                            if (P == 0) { MNG_ERROR (H, MNG_OUTOFMEMORY) } }
+#define MNG_ALLOCX(H,P,L) { P = H->fMemalloc ((mng_size_t)(L)); }
+#define MNG_FREE(H,P,L)   { if (P) { H->fMemfree (P, (mng_size_t)(L)); P = 0; } }
+#define MNG_FREEX(H,P,L)  { if (P) { H->fMemfree (P, (mng_size_t)(L)); } }
+#endif /* mng_internal_memmngmt */
+
+#define MNG_COPY(D,S,L)   { memcpy (D, S, (mng_size_t)(L)); }
+
+/* ************************************************************************** */
+
+#endif /* _libmng_memory_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_object_prc.c b/src/3rdparty/libmng/libmng_object_prc.c
new file mode 100644
index 0000000..e1724b4
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_object_prc.c
@@ -0,0 +1,6998 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_object_prc.c       copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Object processing routines (implementation)                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the internal object processing routines  * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - fixed to support JNG objects                             * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added support for global color-chunks in animation       * */
+/* *             - added support for global PLTE,tRNS,bKGD in animation     * */
+/* *             - added SAVE & SEEK animation objects                      * */
+/* *             0.5.2 - 05/29/2000 - G.Juyn                                * */
+/* *             - added initialization of framenr/layernr/playtime         * */
+/* *             - changed ani_object create routines not to return the     * */
+/* *               created object (wasn't necessary)                        * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added object promotion routine (PROM handling)           * */
+/* *             - added ani-object routines for delta-image processing     * */
+/* *             - added compression/filter/interlace fields to             * */
+/* *               object-buffer for delta-image processing                 * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - changed support for delta-image processing               * */
+/* *             0.5.3 - 06/20/2000 - G.Juyn                                * */
+/* *             - fixed some small things (as precaution)                  * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added processing of PLTE/tRNS & color-info for           * */
+/* *               delta-images in the ani_objects chain                    * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - added support for PPLT chunk                             * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/07/2000 - G.Juyn                                * */
+/* *             - added support for freeze/restart/resume & go_xxxx        * */
+/* *             0.9.1 - 07/16/2000 - G.Juyn                                * */
+/* *             - fixed support for mng_display() after mng_read()         * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/29/2000 - G.Juyn                                * */
+/* *             - fixed small bugs in display processing                   * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/07/2000 - G.Juyn                                * */
+/* *             - B111300 - fixup for improved portability                 * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/10/2000 - G.Juyn                                * */
+/* *             - fixed DEFI behavior                                      * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added valid-flag to stored objects for read() / display()* */
+/* *             - added routine to discard "invalid" objects               * */
+/* *             0.9.3 - 10/18/2000 - G.Juyn                                * */
+/* *             - fixed delta-processing behavior                          * */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - added storage for pixel-/alpha-sampledepth for delta's   * */
+/* *                                                                        * */
+/* *             0.9.4 -  1/18/2001 - G.Juyn                                * */
+/* *             - removed "old" MAGN methods 3 & 4                         * */
+/* *             - added "new" MAGN methods 3, 4 & 5                        * */
+/* *                                                                        * */
+/* *             0.9.5 -  1/22/2001 - G.Juyn                                * */
+/* *             - B129681 - fixed compiler warnings SGI/Irix               * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             1.0.5 - 08/16/2002 - G.Juyn                                * */
+/* *             - completed MAGN support (16-bit functions)                * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/13/2002 - G.Juyn                                * */
+/* *             - fixed read/write of MAGN chunk                           * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - fixed reset_object_detail to clear old buffer            * */
+/* *             - added in-memory color-correction of abstract images      * */
+/* *             1.0.5 - 10/05/2002 - G.Juyn                                * */
+/* *             - fixed problem with cloned objects marked as invalid      * */
+/* *             - fixed problem cloning frozen object_buffers              * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - fixed DISC support                                       * */
+/* *             1.0.5 - 11/04/2002 - G.Juyn                                * */
+/* *             - fixed goframe/golayer/gotime processing                  * */
+/* *             1.0.5 - 11/07/2002 - G.Juyn                                * */
+/* *             - fixed magnification bug with object 0                    * */
+/* *             1.0.5 - 01/19/2003 - G.Juyn                                * */
+/* *             - B664911 - fixed buffer overflow during init              * */
+/* *                                                                        * */
+/* *             1.0.6 - 04/19/2003 - G.Juyn                                * */
+/* *             - fixed problem with infinite loops during readdisplay()   * */
+/* *             1.0.6 - 05/25/2003 - G.R-P                                 * */
+/* *             - added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             1.0.6 - 06/09/2003 - G. R-P                                * */
+/* *             - added conditionals around 8-bit magn routines            * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added conditionals around some JNG-supporting code       * */
+/* *             - removed conditionals around 8-bit magn routines          * */
+/* *             - added conditionals around delta-png and 16-bit code      * */
+/* *             1.0.6 - 07/14/2003 - G.R-P                                 * */
+/* *             - added MNG_NO_LOOP_SIGNALS_SUPPORTED conditional          * */
+/* *             1.0.6 - 07/29/2003 - G.Juyn                                * */
+/* *             - fixed invalid test in promote_imageobject                * */
+/* *             1.0.6 - 07/29/2003 - G.R-P.                                * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *             1.0.6 - 08/17/2003 - G.R-P.                                * */
+/* *             - added conditionals around MAGN chunk support             * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/21/2004 - G.Juyn                                * */
+/* *             - fixed some 64-bit platform compiler warnings             * */
+/* *                                                                        * */
+/* *             1.0.9 - 10/10/2004 - G.R-P.                                * */
+/* *             - added MNG_NO_1_2_4BIT_SUPPORT support                    * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_OBJCLEANUP                * */
+/* *             1.0.9 - 12/11/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_DISPLAYCALLS              * */
+/* *             1.0.9 - 12/31/2004 - G.R-P.                                * */
+/* *             - fixed warnings about possible uninitialized pointers     * */
+/* *             1.0.9 - 01/02/2005 - G.Juyn                                * */
+/* *             - fixing some compiler-warnings                            * */
+/* *                                                                        * */
+/* *             1.0.10 - 02/07/2005 - G.Juyn                               * */
+/* *             - fixed some compiler-warnings                             * */
+/* *             1.0.10 - 07/30/2005 - G.Juyn                               * */
+/* *             - fixed problem with CLON object during readdisplay()      * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_chunks.h"
+#include "libmng_objects.h"
+#include "libmng_display.h"
+#include "libmng_pixels.h"
+#include "libmng_object_prc.h"
+#include "libmng_cms.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Generic object routines                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_drop_invalid_objects (mng_datap pData)
+{
+  mng_objectp       pObject;
+  mng_objectp       pNext;
+  mng_cleanupobject fCleanup;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_INVALID_OBJECTS, MNG_LC_START);
+#endif
+
+  pObject = pData->pFirstimgobj;       /* get first stored image-object (if any) */
+
+  while (pObject)                      /* more objects to check ? */
+  {
+    pNext = ((mng_object_headerp)pObject)->pNext;
+                                       /* invalid ? */
+    if (!((mng_imagep)pObject)->bValid)
+    {                                  /* call appropriate cleanup */
+      fCleanup = ((mng_object_headerp)pObject)->fCleanup;
+      fCleanup (pData, pObject);
+    }
+
+    pObject = pNext;                   /* neeeext */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_INVALID_OBJECTS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+MNG_LOCAL mng_retcode create_obj_general (mng_datap          pData,
+                                          mng_size_t         iObjsize,
+                                          mng_cleanupobject  fCleanup,
+                                          mng_processobject  fProcess,
+                                          mng_ptr            *ppObject)
+{
+  mng_object_headerp pWork;
+
+  MNG_ALLOC (pData, pWork, iObjsize);
+
+  pWork->fCleanup = fCleanup;
+  pWork->fProcess = fProcess;
+  pWork->iObjsize = iObjsize;
+  *ppObject       = (mng_ptr)pWork;
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode mng_free_obj_general (mng_datap   pData,
+                                            mng_objectp pObject)
+{
+  MNG_FREEX (pData, pObject, ((mng_object_headerp)pObject)->iObjsize);
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Image-data-object routines                                             * */
+/* *                                                                        * */
+/* * these handle the "object buffer" as defined by the MNG specification   * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_create_imagedataobject (mng_datap      pData,
+                                        mng_bool       bConcrete,
+                                        mng_bool       bViewable,
+                                        mng_uint32     iWidth,
+                                        mng_uint32     iHeight,
+                                        mng_uint8      iBitdepth,
+                                        mng_uint8      iColortype,
+                                        mng_uint8      iCompression,
+                                        mng_uint8      iFilter,
+                                        mng_uint8      iInterlace,
+                                        mng_imagedatap *ppObject)
+{
+  mng_imagedatap pImagedata;
+  mng_uint32 iSamplesize = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_IMGDATAOBJECT, MNG_LC_START);
+#endif
+                                       /* get a buffer */
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+  {
+    mng_ptr pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_imagedata),
+                                               (mng_cleanupobject)mng_free_imagedataobject,
+                                               MNG_NULL, &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pImagedata = (mng_imagedatap)pTemp;
+  }
+#else
+  MNG_ALLOC (pData, pImagedata, sizeof (mng_imagedata));
+                                       /* fill the appropriate fields */
+  pImagedata->sHeader.fCleanup   = (mng_cleanupobject)mng_free_imagedataobject;
+  pImagedata->sHeader.fProcess   = MNG_NULL;
+#endif
+  pImagedata->iRefcount          = 1;
+  pImagedata->bFrozen            = MNG_FALSE;
+  pImagedata->bConcrete          = bConcrete;
+  pImagedata->bViewable          = bViewable;
+  pImagedata->iWidth             = iWidth;
+  pImagedata->iHeight            = iHeight;
+  pImagedata->iBitdepth          = iBitdepth;
+  pImagedata->iColortype         = iColortype;
+  pImagedata->iCompression       = iCompression;
+  pImagedata->iFilter            = iFilter;
+  pImagedata->iInterlace         = iInterlace;
+  pImagedata->bCorrected         = MNG_FALSE;
+  pImagedata->iAlphabitdepth     = 0;
+  pImagedata->iJHDRcompression   = 0;
+  pImagedata->iJHDRinterlace     = 0;
+  pImagedata->iPixelsampledepth  = iBitdepth;
+  pImagedata->iAlphasampledepth  = iBitdepth;
+                                       /* determine samplesize from color_type/bit_depth */
+  switch (iColortype)                  /* for < 8-bit samples we just reserve 8 bits */
+  {
+    case  0  : ;                       /* gray */
+    case  8  : {                       /* JPEG gray */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 2;
+                 else
+#endif
+                   iSamplesize = 1;
+
+                 break;
+               }
+    case  2  : ;                       /* rgb */
+    case 10  : {                       /* JPEG rgb */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 6;
+                 else
+#endif
+                   iSamplesize = 3;
+
+                 break;
+               }
+    case  3  : {                       /* indexed */
+                 iSamplesize = 1;
+                 break;
+               }
+    case  4  : ;                       /* gray+alpha */
+    case 12  : {                       /* JPEG gray+alpha */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 4;
+                 else
+#endif
+                   iSamplesize = 2;
+
+                 break;
+               }
+    case  6  : ;                       /* rgb+alpha */
+    case 14  : {                       /* JPEG rgb+alpha */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 8;
+                 else
+#endif
+                   iSamplesize = 4;
+
+                 break;
+               }
+  }
+                                       /* make sure we remember all this */
+  pImagedata->iSamplesize  = iSamplesize;
+  pImagedata->iRowsize     = iSamplesize * iWidth;
+  pImagedata->iImgdatasize = pImagedata->iRowsize * iHeight;
+
+  if (pImagedata->iImgdatasize)        /* need a buffer ? */
+  {                                    /* so allocate it */
+    MNG_ALLOCX (pData, pImagedata->pImgdata, pImagedata->iImgdatasize);
+
+    if (!pImagedata->pImgdata)         /* enough memory ? */
+    {
+      MNG_FREEX (pData, pImagedata, sizeof (mng_imagedata));
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+  }
+                                       /* check global stuff */
+  pImagedata->bHasGAMA           = pData->bHasglobalGAMA;
+#ifndef MNG_SKIPCHUNK_cHRM
+  pImagedata->bHasCHRM           = pData->bHasglobalCHRM;
+#endif
+  pImagedata->bHasSRGB           = pData->bHasglobalSRGB;
+#ifndef MNG_SKIPCHUNK_iCCP
+  pImagedata->bHasICCP           = pData->bHasglobalICCP;
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+  pImagedata->bHasBKGD           = pData->bHasglobalBKGD;
+#endif
+
+  if (pData->bHasglobalGAMA)           /* global gAMA present ? */
+    pImagedata->iGamma           = pData->iGlobalGamma;
+
+#ifndef MNG_SKIPCHUNK_cHRM
+  if (pData->bHasglobalCHRM)           /* global cHRM present ? */
+  {
+    pImagedata->iWhitepointx     = pData->iGlobalWhitepointx;
+    pImagedata->iWhitepointy     = pData->iGlobalWhitepointy;
+    pImagedata->iPrimaryredx     = pData->iGlobalPrimaryredx;
+    pImagedata->iPrimaryredy     = pData->iGlobalPrimaryredy;
+    pImagedata->iPrimarygreenx   = pData->iGlobalPrimarygreenx;
+    pImagedata->iPrimarygreeny   = pData->iGlobalPrimarygreeny;
+    pImagedata->iPrimarybluex    = pData->iGlobalPrimarybluex;
+    pImagedata->iPrimarybluey    = pData->iGlobalPrimarybluey;
+  }
+#endif
+
+  if (pData->bHasglobalSRGB)           /* glbal sRGB present ? */
+    pImagedata->iRenderingintent = pData->iGlobalRendintent;
+
+#ifndef MNG_SKIPCHUNK_iCCP
+  if (pData->bHasglobalICCP)           /* glbal iCCP present ? */
+  {
+    pImagedata->iProfilesize     = pData->iGlobalProfilesize;
+
+    if (pImagedata->iProfilesize)
+    {
+      MNG_ALLOCX (pData, pImagedata->pProfile, pImagedata->iProfilesize);
+
+      if (!pImagedata->pProfile)       /* enough memory ? */
+      {
+        MNG_FREEX (pData, pImagedata->pImgdata, pImagedata->iImgdatasize);
+        MNG_FREEX (pData, pImagedata, sizeof (mng_imagedata));
+        MNG_ERROR (pData, MNG_OUTOFMEMORY);
+      }
+
+      MNG_COPY  (pImagedata->pProfile, pData->pGlobalProfile, pImagedata->iProfilesize);
+    }
+  }
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+  if (pData->bHasglobalBKGD)           /* global bKGD present ? */
+  {
+    pImagedata->iBKGDred         = pData->iGlobalBKGDred;
+    pImagedata->iBKGDgreen       = pData->iGlobalBKGDgreen;
+    pImagedata->iBKGDblue        = pData->iGlobalBKGDblue;
+  }
+#endif
+
+  *ppObject = pImagedata;              /* return it */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_IMGDATAOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_imagedataobject   (mng_datap      pData,
+                                        mng_imagedatap pImagedata)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IMGDATAOBJECT, MNG_LC_START);
+#endif
+
+  if (pImagedata->iRefcount)           /* decrease reference count */
+    pImagedata->iRefcount--;
+
+  if (!pImagedata->iRefcount)          /* reached zero ? */
+  {
+#ifndef MNG_SKIPCHUNK_iCCP
+    if (pImagedata->iProfilesize)      /* stored an iCCP profile ? */
+      MNG_FREEX (pData, pImagedata->pProfile, pImagedata->iProfilesize);
+#endif
+    if (pImagedata->iImgdatasize)      /* sample-buffer present ? */
+      MNG_FREEX (pData, pImagedata->pImgdata, pImagedata->iImgdatasize);
+                                       /* drop the buffer */
+    MNG_FREEX (pData, pImagedata, sizeof (mng_imagedata));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IMGDATAOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_clone_imagedataobject  (mng_datap      pData,
+                                        mng_bool       bConcrete,
+                                        mng_imagedatap pSource,
+                                        mng_imagedatap *ppClone)
+{
+  mng_imagedatap pNewdata;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLONE_IMGDATAOBJECT, MNG_LC_START);
+#endif
+                                       /* get a buffer */
+  MNG_ALLOC (pData, pNewdata, sizeof (mng_imagedata));
+                                       /* blatently copy the original buffer */
+  MNG_COPY (pNewdata, pSource, sizeof (mng_imagedata));
+
+  pNewdata->iRefcount = 1;             /* only the reference count */
+  pNewdata->bConcrete = bConcrete;     /* and concrete-flag are different */
+  pNewdata->bFrozen   = MNG_FALSE;
+
+  if (pNewdata->iImgdatasize)          /* sample buffer present ? */
+  {
+    MNG_ALLOCX (pData, pNewdata->pImgdata, pNewdata->iImgdatasize);
+
+    if (!pNewdata->pImgdata)           /* not enough memory ? */
+    {
+      MNG_FREEX (pData, pNewdata, sizeof (mng_imagedata));
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+                                       /* make a copy */
+    MNG_COPY (pNewdata->pImgdata, pSource->pImgdata, pNewdata->iImgdatasize);
+  }
+
+#ifndef MNG_SKIPCHUNK_iCCP
+  if (pNewdata->iProfilesize)          /* iCCP profile present ? */
+  {
+    MNG_ALLOCX (pData, pNewdata->pProfile, pNewdata->iProfilesize);
+
+    if (!pNewdata->pProfile)           /* enough memory ? */
+    {
+      MNG_FREEX (pData, pNewdata, sizeof (mng_imagedata));
+      MNG_ERROR (pData, MNG_OUTOFMEMORY);
+    }
+                                       /* make a copy */
+    MNG_COPY (pNewdata->pProfile, pSource->pProfile, pNewdata->iProfilesize);
+  }
+#endif
+
+  *ppClone = pNewdata;                 /* return the clone */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLONE_IMGDATAOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Image-object routines                                                  * */
+/* *                                                                        * */
+/* * these handle the "object" as defined by the MNG specification          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_create_imageobject (mng_datap  pData,
+                                    mng_uint16 iId,
+                                    mng_bool   bConcrete,
+                                    mng_bool   bVisible,
+                                    mng_bool   bViewable,
+                                    mng_uint32 iWidth,
+                                    mng_uint32 iHeight,
+                                    mng_uint8  iBitdepth,
+                                    mng_uint8  iColortype,
+                                    mng_uint8  iCompression,
+                                    mng_uint8  iFilter,
+                                    mng_uint8  iInterlace,
+                                    mng_int32  iPosx,
+                                    mng_int32  iPosy,
+                                    mng_bool   bClipped,
+                                    mng_int32  iClipl,
+                                    mng_int32  iClipr,
+                                    mng_int32  iClipt,
+                                    mng_int32  iClipb,
+                                    mng_imagep *ppObject)
+{
+  mng_imagep     pImage;
+  mng_imagep     pPrev, pNext;
+  mng_retcode    iRetcode;
+  mng_imagedatap pImgbuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_IMGOBJECT, MNG_LC_START);
+#endif
+                                       /* get a buffer */
+  MNG_ALLOC (pData, pImage, sizeof (mng_image));
+                                       /* now get a new "object buffer" */
+  iRetcode = mng_create_imagedataobject (pData, bConcrete, bViewable,
+                                         iWidth, iHeight, iBitdepth, iColortype,
+                                         iCompression, iFilter, iInterlace,
+                                         &pImgbuf);
+
+  if (iRetcode)                        /* on error bail out */
+  {
+    MNG_FREEX (pData, pImage, sizeof (mng_image));
+    return iRetcode;
+  }
+                                       /* fill the appropriate fields */
+  pImage->sHeader.fCleanup = (mng_cleanupobject)mng_free_imageobject;
+  pImage->sHeader.fProcess = MNG_NULL;
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+  pImage->sHeader.iObjsize = sizeof (mng_image);
+#endif
+  pImage->iId              = iId;
+  pImage->bFrozen          = MNG_FALSE;
+  pImage->bVisible         = bVisible;
+  pImage->bViewable        = bViewable;
+  pImage->bValid           = (mng_bool)((pData->bDisplaying) &&
+                                        ((pData->bRunning) || (pData->bSearching)) &&
+                                        (!pData->bFreezing));
+  pImage->iPosx            = iPosx;
+  pImage->iPosy            = iPosy;
+  pImage->bClipped         = bClipped;
+  pImage->iClipl           = iClipl;
+  pImage->iClipr           = iClipr;
+  pImage->iClipt           = iClipt;
+  pImage->iClipb           = iClipb;
+#ifndef MNG_SKIPCHUNK_MAGN
+  pImage->iMAGN_MethodX    = 0;
+  pImage->iMAGN_MethodY    = 0;
+  pImage->iMAGN_MX         = 0;
+  pImage->iMAGN_MY         = 0;
+  pImage->iMAGN_ML         = 0;
+  pImage->iMAGN_MR         = 0;
+  pImage->iMAGN_MT         = 0;
+  pImage->iMAGN_MB         = 0;
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+  pImage->iPastx           = 0;
+  pImage->iPasty           = 0;
+#endif
+  pImage->pImgbuf          = pImgbuf;
+
+  if (iId)                             /* only if not object 0 ! */
+  {                                    /* find previous lower object-id */
+    pPrev = (mng_imagep)pData->pLastimgobj;
+
+    while ((pPrev) && (pPrev->iId > iId))
+      pPrev = (mng_imagep)pPrev->sHeader.pPrev;
+
+    if (pPrev)                         /* found it ? */
+    {
+      pImage->sHeader.pPrev = pPrev;   /* than link it in place */
+      pImage->sHeader.pNext = pPrev->sHeader.pNext;
+      pPrev->sHeader.pNext  = pImage;
+    }
+    else                               /* if not found, it becomes the first ! */
+    {
+      pImage->sHeader.pNext = pData->pFirstimgobj;
+      pData->pFirstimgobj   = pImage;
+    }
+
+    pNext                   = (mng_imagep)pImage->sHeader.pNext;
+
+    if (pNext)
+      pNext->sHeader.pPrev  = pImage;
+    else
+      pData->pLastimgobj    = pImage;
+    
+  }  
+
+  *ppObject = pImage;                  /* and return the new buffer */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_IMGOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* okido */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_imageobject (mng_datap  pData,
+                                  mng_imagep pImage)
+{
+  mng_retcode    iRetcode;
+  mng_imagep     pPrev   = pImage->sHeader.pPrev;
+  mng_imagep     pNext   = pImage->sHeader.pNext;
+  mng_imagedatap pImgbuf = pImage->pImgbuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IMGOBJECT, MNG_LC_START);
+#endif
+
+  if (pImage->iId)                     /* not for object 0 */
+  {
+    if (pPrev)                         /* unlink from the list first ! */
+      pPrev->sHeader.pNext = pImage->sHeader.pNext;
+    else
+      pData->pFirstimgobj  = pImage->sHeader.pNext;
+
+    if (pNext)
+      pNext->sHeader.pPrev = pImage->sHeader.pPrev;
+    else
+      pData->pLastimgobj   = pImage->sHeader.pPrev;
+
+  }
+                                       /* unlink the image-data buffer */
+  iRetcode = mng_free_imagedataobject (pData, pImgbuf);
+                                       /* drop its own buffer */
+  MNG_FREEX (pData, pImage, sizeof (mng_image));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_IMGOBJECT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+mng_imagep mng_find_imageobject (mng_datap  pData,
+                                 mng_uint16 iId)
+{
+  mng_imagep pImage = (mng_imagep)pData->pFirstimgobj;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (pData, MNG_FN_FIND_IMGOBJECT, MNG_LC_START);
+#endif
+                                       /* look up the right id */
+  while ((pImage) && (pImage->iId != iId))
+    pImage = (mng_imagep)pImage->sHeader.pNext;
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+  if ((!pImage) && (pData->eImagetype == mng_it_mpng))
+    pImage = pData->pObjzero;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (pData, MNG_FN_FIND_IMGOBJECT, MNG_LC_END);
+#endif
+
+  return pImage;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_clone_imageobject (mng_datap  pData,
+                                   mng_uint16 iId,
+                                   mng_bool   bPartial,
+                                   mng_bool   bVisible,
+                                   mng_bool   bAbstract,
+                                   mng_bool   bHasloca,
+                                   mng_uint8  iLocationtype,
+                                   mng_int32  iLocationx,
+                                   mng_int32  iLocationy,
+                                   mng_imagep pSource,
+                                   mng_imagep *ppClone)
+{
+  mng_imagep     pNew;
+  mng_imagep     pPrev, pNext;
+  mng_retcode    iRetcode;
+  mng_imagedatap pImgbuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLONE_IMGOBJECT, MNG_LC_START);
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+  if ((pSource->iId) &&                /* needs magnification ? */
+      ((pSource->iMAGN_MethodX) || (pSource->iMAGN_MethodY)))
+  {
+    iRetcode = mng_magnify_imageobject (pData, pSource);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif
+                                       /* get a buffer */
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+  {
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_image),
+                                               (mng_cleanupobject)mng_free_imageobject,
+                                               MNG_NULL, &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pNew = (mng_imagep)pTemp;
+  }
+#else
+  MNG_ALLOC (pData, pNew, sizeof (mng_image));
+                                       /* fill or copy the appropriate fields */
+  pNew->sHeader.fCleanup = (mng_cleanupobject)mng_free_imageobject;
+  pNew->sHeader.fProcess = MNG_NULL;
+#endif
+  pNew->iId              = iId;
+  pNew->bFrozen          = MNG_FALSE;
+  pNew->bVisible         = bVisible;
+  pNew->bViewable        = pSource->bViewable;
+  pNew->bValid           = MNG_TRUE;
+
+  if (bHasloca)                        /* location info available ? */
+  {
+    if (iLocationtype == 0)            /* absolute position ? */
+    {
+      pNew->iPosx        = iLocationx;
+      pNew->iPosy        = iLocationy;
+    }
+    else                               /* relative */
+    {
+      pNew->iPosx        = pSource->iPosx + iLocationx;
+      pNew->iPosy        = pSource->iPosy + iLocationy;
+    }
+  }
+  else                                 /* copy from source */
+  {
+    pNew->iPosx          = pSource->iPosx;
+    pNew->iPosy          = pSource->iPosy;
+  }
+                                       /* copy clipping info */
+  pNew->bClipped         = pSource->bClipped;
+  pNew->iClipl           = pSource->iClipl;
+  pNew->iClipr           = pSource->iClipr;
+  pNew->iClipt           = pSource->iClipt;
+  pNew->iClipb           = pSource->iClipb;
+#ifndef MNG_SKIPCHUNK_MAGN
+                                       /* copy magnification info */
+/*  pNew->iMAGN_MethodX    = pSource->iMAGN_MethodX;     LET'S NOT !!!!!!
+  pNew->iMAGN_MethodY    = pSource->iMAGN_MethodY;
+  pNew->iMAGN_MX         = pSource->iMAGN_MX;
+  pNew->iMAGN_MY         = pSource->iMAGN_MY;
+  pNew->iMAGN_ML         = pSource->iMAGN_ML;
+  pNew->iMAGN_MR         = pSource->iMAGN_MR;
+  pNew->iMAGN_MT         = pSource->iMAGN_MT;
+  pNew->iMAGN_MB         = pSource->iMAGN_MB; */
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+  pNew->iPastx           = 0;          /* initialize PAST info */
+  pNew->iPasty           = 0;
+#endif
+
+  if (iId)                             /* not for object 0 */
+  {                                    /* find previous lower object-id */
+    pPrev = (mng_imagep)pData->pLastimgobj;
+    while ((pPrev) && (pPrev->iId > iId))
+      pPrev = (mng_imagep)pPrev->sHeader.pPrev;
+
+    if (pPrev)                         /* found it ? */
+    {
+      pNew->sHeader.pPrev  = pPrev;    /* than link it in place */
+      pNew->sHeader.pNext  = pPrev->sHeader.pNext;
+      pPrev->sHeader.pNext = pNew;
+    }
+    else                               /* if not found, it becomes the first ! */
+    {
+      pNew->sHeader.pNext  = pData->pFirstimgobj;
+      pData->pFirstimgobj  = pNew;
+    }
+
+    pNext                  = (mng_imagep)pNew->sHeader.pNext;
+
+    if (pNext)
+      pNext->sHeader.pPrev = pNew;
+    else
+      pData->pLastimgobj   = pNew;
+
+  }
+
+  if (bPartial)                        /* partial clone ? */
+  {
+    pNew->pImgbuf = pSource->pImgbuf;  /* use the same object buffer */
+    pNew->pImgbuf->iRefcount++;        /* and increase the reference count */
+  }
+  else                                 /* create a full clone ! */
+  {
+    mng_bool bConcrete = MNG_FALSE;    /* it's abstract by default (?) */
+
+    if (!bAbstract)                    /* determine concreteness from source ? */
+      bConcrete = pSource->pImgbuf->bConcrete;
+                                       /* create a full clone ! */
+    iRetcode = mng_clone_imagedataobject (pData, bConcrete, pSource->pImgbuf, &pImgbuf);
+
+    if (iRetcode)                      /* on error bail out */
+    {
+      MNG_FREEX (pData, pNew, sizeof (mng_image));
+      return iRetcode;
+    }
+
+    pNew->pImgbuf = pImgbuf;           /* and remember it */
+  }
+
+  *ppClone = pNew;                     /* return it */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLONE_IMGOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_renum_imageobject (mng_datap  pData,
+                                   mng_imagep pSource,
+                                   mng_uint16 iId,
+                                   mng_bool   bVisible,
+                                   mng_bool   bAbstract,
+                                   mng_bool   bHasloca,
+                                   mng_uint8  iLocationtype,
+                                   mng_int32  iLocationx,
+                                   mng_int32  iLocationy)
+{
+  mng_imagep pPrev, pNext;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RENUM_IMGOBJECT, MNG_LC_START);
+#endif
+
+  pSource->bVisible  = bVisible;       /* store the new visibility */
+
+  if (bHasloca)                        /* location info available ? */
+  {
+    if (iLocationtype == 0)            /* absolute position ? */
+    {
+      pSource->iPosx = iLocationx;
+      pSource->iPosy = iLocationy;
+    }
+    else                               /* relative */
+    {
+      pSource->iPosx = pSource->iPosx + iLocationx;
+      pSource->iPosy = pSource->iPosy + iLocationy;
+    }
+  }
+
+  if (iId)                             /* not for object 0 */
+  {                                    /* find previous lower object-id */
+    pPrev = (mng_imagep)pData->pLastimgobj;
+    while ((pPrev) && (pPrev->iId > iId))
+      pPrev = (mng_imagep)pPrev->sHeader.pPrev;
+                                       /* different from current ? */
+    if (pPrev != (mng_imagep)pSource->sHeader.pPrev)
+    {
+      if (pSource->sHeader.pPrev)      /* unlink from current position !! */
+        ((mng_imagep)pSource->sHeader.pPrev)->sHeader.pNext = pSource->sHeader.pNext;
+      else
+        pData->pFirstimgobj                                 = pSource->sHeader.pNext;
+
+      if (pSource->sHeader.pNext)
+        ((mng_imagep)pSource->sHeader.pNext)->sHeader.pPrev = pSource->sHeader.pPrev;
+      else
+        pData->pLastimgobj                                  = pSource->sHeader.pPrev;
+
+      if (pPrev)                       /* found the previous ? */
+      {                                /* than link it in place */
+        pSource->sHeader.pPrev = pPrev;
+        pSource->sHeader.pNext = pPrev->sHeader.pNext;
+        pPrev->sHeader.pNext   = pSource;
+      }
+      else                             /* if not found, it becomes the first ! */
+      {
+        pSource->sHeader.pNext = pData->pFirstimgobj;
+        pData->pFirstimgobj    = pSource;
+      }
+
+      pNext                    = (mng_imagep)pSource->sHeader.pNext;
+
+      if (pNext)
+        pNext->sHeader.pPrev   = pSource;
+      else
+        pData->pLastimgobj     = pSource;
+
+    }
+  }
+
+  pSource->iId = iId;                  /* now set the new id! */
+
+  if (bAbstract)                       /* force it to abstract ? */
+    pSource->pImgbuf->bConcrete = MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RENUM_IMGOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_reset_object_details (mng_datap  pData,
+                                      mng_imagep pImage,
+                                      mng_uint32 iWidth,
+                                      mng_uint32 iHeight,
+                                      mng_uint8  iBitdepth,
+                                      mng_uint8  iColortype,
+                                      mng_uint8  iCompression,
+                                      mng_uint8  iFilter,
+                                      mng_uint8  iInterlace,
+                                      mng_bool   bResetall)
+{
+  mng_imagedatap pBuf  = pImage->pImgbuf;
+  mng_uint32     iSamplesize = 0;
+  mng_uint32     iRowsize;
+  mng_uint32     iImgdatasize;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESET_OBJECTDETAILS, MNG_LC_START);
+#endif
+
+  pBuf->iWidth         = iWidth;       /* set buffer characteristics */
+  pBuf->iHeight        = iHeight;
+  pBuf->iBitdepth      = iBitdepth;
+  pBuf->iColortype     = iColortype;
+  pBuf->iCompression   = iCompression;
+  pBuf->iFilter        = iFilter;
+  pBuf->iInterlace     = iInterlace;
+  pBuf->bCorrected     = MNG_FALSE;
+  pBuf->iAlphabitdepth = 0;
+                                       /* determine samplesize from color_type/bit_depth */
+  switch (iColortype)                  /* for < 8-bit samples we just reserve 8 bits */
+  {
+    case  0  : ;                       /* gray */
+    case  8  : {                       /* JPEG gray */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 2;
+                 else
+#endif
+                   iSamplesize = 1;
+
+                 break;
+               }
+    case  2  : ;                       /* rgb */
+    case 10  : {                       /* JPEG rgb */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 6;
+                 else
+#endif
+                   iSamplesize = 3;
+
+                 break;
+               }
+    case  3  : {                       /* indexed */
+                 iSamplesize = 1;
+                 break;
+               }
+    case  4  : ;                       /* gray+alpha */
+    case 12  : {                       /* JPEG gray+alpha */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 4;
+                 else
+#endif
+                   iSamplesize = 2;
+
+                 break;
+               }
+    case  6  : ;                       /* rgb+alpha */
+    case 14  : {                       /* JPEG rgb+alpha */
+#ifndef MNG_NO_16BIT_SUPPORT
+                 if (iBitdepth > 8)
+                   iSamplesize = 8;
+                 else
+#endif
+                   iSamplesize = 4;
+
+                 break;
+               }
+  }
+
+  iRowsize     = iSamplesize * iWidth;
+  iImgdatasize = iRowsize    * iHeight;
+                                       /* buffer size changed ? */
+  if (iImgdatasize != pBuf->iImgdatasize)
+  {                                    /* drop the old one */
+    MNG_FREE (pData, pBuf->pImgdata, pBuf->iImgdatasize);
+
+    if (iImgdatasize)                  /* allocate new sample-buffer ? */
+      MNG_ALLOC (pData, pBuf->pImgdata, iImgdatasize);
+  }
+  else
+  {
+    if (iImgdatasize)                  /* clear old buffer */
+    {
+      mng_uint8p pTemp = pBuf->pImgdata;
+      mng_uint32 iX;
+      
+      for (iX = 0; iX < (iImgdatasize & (mng_uint32)(~3L)); iX += 4)
+      {
+        *((mng_uint32p)pTemp) = 0x00000000l;
+        pTemp += 4;
+      }
+
+      while (pTemp < (pBuf->pImgdata + iImgdatasize))
+      {
+        *pTemp = 0;
+        pTemp++;
+      }
+    }
+  }
+
+  pBuf->iSamplesize  = iSamplesize;    /* remember new sizes */
+  pBuf->iRowsize     = iRowsize;
+  pBuf->iImgdatasize = iImgdatasize;
+
+  if (!pBuf->iPixelsampledepth)        /* set delta sampledepths if empty */
+    pBuf->iPixelsampledepth = iBitdepth;
+  if (!pBuf->iAlphasampledepth)
+    pBuf->iAlphasampledepth = iBitdepth;
+                                       /* dimension set and clipping not ? */
+  if ((iWidth) && (iHeight) && (!pImage->bClipped))
+  {
+    pImage->iClipl   = 0;              /* set clipping to dimension by default */
+    pImage->iClipr   = iWidth;
+    pImage->iClipt   = 0;
+    pImage->iClipb   = iHeight;
+  }
+
+#ifndef MNG_SKIPCHUNK_MAGN
+  if (pImage->iId)                     /* reset magnification info ? */
+  {
+    pImage->iMAGN_MethodX = 0;
+    pImage->iMAGN_MethodY = 0;
+    pImage->iMAGN_MX      = 0;
+    pImage->iMAGN_MY      = 0;
+    pImage->iMAGN_ML      = 0;
+    pImage->iMAGN_MR      = 0;
+    pImage->iMAGN_MT      = 0;
+    pImage->iMAGN_MB      = 0;
+  }
+#endif
+
+  if (bResetall)                       /* reset the other characteristics ? */
+  {
+#ifndef MNG_SKIPCHUNK_PAST
+    pImage->iPastx = 0;
+    pImage->iPasty = 0;
+#endif
+
+    pBuf->bHasPLTE = MNG_FALSE;
+    pBuf->bHasTRNS = MNG_FALSE;
+    pBuf->bHasGAMA = pData->bHasglobalGAMA;
+#ifndef MNG_SKIPCHUNK_cHRM
+    pBuf->bHasCHRM = pData->bHasglobalCHRM;
+#endif
+    pBuf->bHasSRGB = pData->bHasglobalSRGB;
+#ifndef MNG_SKIPCHUNK_iCCP
+    pBuf->bHasICCP = pData->bHasglobalICCP;
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+    pBuf->bHasBKGD = pData->bHasglobalBKGD;
+#endif
+
+#ifndef MNG_SKIPCHUNK_iCCP
+    if (pBuf->iProfilesize)            /* drop possibly old ICC profile */
+    {
+      MNG_FREE (pData, pBuf->pProfile, pBuf->iProfilesize);
+      pBuf->iProfilesize     = 0;
+    }  
+#endif
+
+    if (pData->bHasglobalGAMA)         /* global gAMA present ? */
+      pBuf->iGamma           = pData->iGlobalGamma;
+
+#ifndef MNG_SKIPCHUNK_cHRM
+    if (pData->bHasglobalCHRM)         /* global cHRM present ? */
+    {
+      pBuf->iWhitepointx     = pData->iGlobalWhitepointx;
+      pBuf->iWhitepointy     = pData->iGlobalWhitepointy;
+      pBuf->iPrimaryredx     = pData->iGlobalPrimaryredx;
+      pBuf->iPrimaryredy     = pData->iGlobalPrimaryredy;
+      pBuf->iPrimarygreenx   = pData->iGlobalPrimarygreenx;
+      pBuf->iPrimarygreeny   = pData->iGlobalPrimarygreeny;
+      pBuf->iPrimarybluex    = pData->iGlobalPrimarybluex;
+      pBuf->iPrimarybluey    = pData->iGlobalPrimarybluey;
+    }
+#endif
+
+    if (pData->bHasglobalSRGB)           /* global sRGB present ? */
+      pBuf->iRenderingintent = pData->iGlobalRendintent;
+
+#ifndef MNG_SKIPCHUNK_iCCP
+    if (pData->bHasglobalICCP)           /* global iCCP present ? */
+    {
+      if (pData->iGlobalProfilesize)
+      {
+        MNG_ALLOC (pData, pBuf->pProfile, pData->iGlobalProfilesize);
+        MNG_COPY  (pBuf->pProfile, pData->pGlobalProfile, pData->iGlobalProfilesize);
+      }
+
+      pBuf->iProfilesize     = pData->iGlobalProfilesize;
+    }
+#endif
+
+#ifndef MNG_SKIPCHUNK_bKGD
+    if (pData->bHasglobalBKGD)           /* global bKGD present ? */
+    {
+      pBuf->iBKGDred         = pData->iGlobalBKGDred;
+      pBuf->iBKGDgreen       = pData->iGlobalBKGDgreen;
+      pBuf->iBKGDblue        = pData->iGlobalBKGDblue;
+    }
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESET_OBJECTDETAILS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#if !defined(MNG_NO_DELTA_PNG) || !defined(MNG_SKIPCHUNK_PAST) || !defined(MNG_SKIPCHUNK_MAGN)
+mng_retcode mng_promote_imageobject (mng_datap  pData,
+                                     mng_imagep pImage,
+                                     mng_uint8  iBitdepth,
+                                     mng_uint8  iColortype,
+                                     mng_uint8  iFilltype)
+{
+  mng_retcode    iRetcode       = MNG_NOERROR;
+  mng_imagedatap pBuf           = pImage->pImgbuf;
+  mng_uint32     iW             = pBuf->iWidth;
+  mng_uint32     iH             = pBuf->iHeight;
+  mng_uint8p     pNewbuf;
+  mng_uint32     iNewbufsize;
+  mng_uint32     iNewrowsize;
+  mng_uint32     iNewsamplesize = pBuf->iSamplesize;
+  mng_uint32     iY;
+  mng_uint8      iTempdepth;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IMGOBJECT, MNG_LC_START);
+#endif
+
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+  if (iBitdepth < 8)
+    iBitdepth=8;
+  if (pBuf->iBitdepth < 8)
+    pBuf->iBitdepth=8;
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+  if (iBitdepth > 8)
+    iBitdepth=8;
+  if (pBuf->iBitdepth > 8)
+    pBuf->iBitdepth=8;
+#endif
+
+  pData->fPromoterow    = MNG_NULL;    /* init promotion fields */
+  pData->fPromBitdepth  = MNG_NULL;
+  pData->iPromColortype = iColortype;
+  pData->iPromBitdepth  = iBitdepth;
+  pData->iPromFilltype  = iFilltype;
+
+  if (iBitdepth != pBuf->iBitdepth)    /* determine bitdepth promotion */
+  {
+    if (pBuf->iColortype == MNG_COLORTYPE_INDEXED)
+      iTempdepth = 8;
+    else
+      iTempdepth = pBuf->iBitdepth;
+
+#ifndef MNG_NO_DELTA_PNG
+    if (iFilltype == MNG_FILLMETHOD_ZEROFILL)
+    {
+      switch (iTempdepth)
+      {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        case 1 : {
+                   switch (iBitdepth)
+                   {
+                     case  2 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_1_2;  break; }
+                     case  4 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_1_4;  break; }
+                     case  8 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_1_8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_1_16; break; }
+#endif
+                   }
+                   break;
+                 }
+        case 2 : {
+                   switch (iBitdepth)
+                   {
+                     case  4 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_2_4;  break; }
+                     case  8 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_2_8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_2_16; break; }
+#endif
+                   }
+                   break;
+                 }
+        case 4 : {
+                   switch (iBitdepth)
+                   {
+                     case  8 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_4_8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : { pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_4_16; break; }
+#endif
+                   }
+                   break;
+                 }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+        case 8 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                   if (iBitdepth == 16)
+                     pData->fPromBitdepth = (mng_fptr)mng_promote_zerofill_8_16;
+#endif
+                   break;
+                 }
+      }
+    }
+    else
+#endif
+    {
+      switch (iTempdepth)
+      {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        case 1 : {
+                   switch (iBitdepth)
+                   {
+                     case  2 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_1_2;  break; }
+                     case  4 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_1_4;  break; }
+                     case  8 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_1_8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_1_16; break; }
+#endif
+                   }
+                   break;
+                 }
+        case 2 : {
+                   switch (iBitdepth)
+                   {
+                     case  4 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_2_4;  break; }
+                     case  8 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_2_8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_2_16; break; }
+#endif
+                   }
+                   break;
+                 }
+        case 4 : {
+                   switch (iBitdepth)
+                   {
+                     case  8 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_4_8;  break; }
+#ifndef MNG_NO_16BIT_SUPPORT
+                     case 16 : { pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_4_16; break; }
+#endif
+                   }
+                   break;
+                 }
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+        case 8 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+                   if (iBitdepth == 16)
+                     pData->fPromBitdepth = (mng_fptr)mng_promote_replicate_8_16;
+#endif
+                   break;
+                 }
+      }
+    }
+  }
+                                       /* g -> g */
+  if ((pBuf->iColortype == MNG_COLORTYPE_GRAY) &&
+      (iColortype == MNG_COLORTYPE_GRAY))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_g16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_g8;
+    }
+
+    iNewsamplesize = 1;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 2;
+#endif
+  }
+  else                                 /* g -> ga */
+  if ((pBuf->iColortype == MNG_COLORTYPE_GRAY) &&
+      (iColortype == MNG_COLORTYPE_GRAYA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_ga16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_ga8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_g16_ga16;
+#endif
+
+    iNewsamplesize = 2;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 4;
+#endif
+  }
+  else                                 /* g -> rgb */
+  if ((pBuf->iColortype == MNG_COLORTYPE_GRAY) &&
+      (iColortype == MNG_COLORTYPE_RGB))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgb16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgb8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_g16_rgb16;
+#endif
+
+    iNewsamplesize = 3;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 6;
+#endif
+  }
+  else                                 /* g -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_GRAY) &&
+      (iColortype == MNG_COLORTYPE_RGBA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgba16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgba8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_g16_rgba16;
+#endif
+
+    iNewsamplesize = 4;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+  else                                 /* ga -> ga */
+  if ((pBuf->iColortype == MNG_COLORTYPE_GRAYA) &&
+      (iColortype == MNG_COLORTYPE_GRAYA))
+  {
+    iNewsamplesize = 2;
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_ga8_ga16;
+    if (iBitdepth == 16)
+      iNewsamplesize = 4;
+#endif
+  }
+  else                                 /* ga -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_GRAYA) &&
+      (iColortype == MNG_COLORTYPE_RGBA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_ga8_rgba16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_ga8_rgba8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_ga16_rgba16;
+#endif
+
+    iNewsamplesize = 4;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+  else                                 /* rgb -> rgb */
+  if ((pBuf->iColortype == MNG_COLORTYPE_RGB) &&
+      (iColortype == MNG_COLORTYPE_RGB))
+  {
+    iNewsamplesize = 3;
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_rgb8_rgb16;
+    if (iBitdepth == 16)
+      iNewsamplesize = 6;
+#endif
+  }
+  else                                 /* rgb -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_RGB) &&
+      (iColortype == MNG_COLORTYPE_RGBA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_rgb8_rgba16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_rgb8_rgba8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_rgb16_rgba16;
+#endif
+
+    iNewsamplesize = 4;
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+  else                                 /* indexed -> rgb */
+  if ((pBuf->iColortype == MNG_COLORTYPE_INDEXED) &&
+      (iColortype == MNG_COLORTYPE_RGB))
+  {
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)
+      pData->fPromoterow = (mng_fptr)mng_promote_idx8_rgb16;
+    else
+#endif
+      pData->fPromoterow = (mng_fptr)mng_promote_idx8_rgb8;
+
+    iNewsamplesize = 3;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 6;
+#endif
+  }
+  else                                 /* indexed -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_INDEXED) &&
+      (iColortype == MNG_COLORTYPE_RGBA))
+  {
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)
+      pData->fPromoterow = (mng_fptr)mng_promote_idx8_rgba16;
+    else
+#endif
+      pData->fPromoterow = (mng_fptr)mng_promote_idx8_rgba8;
+
+    iNewsamplesize = 4;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+  else                                 /* rgba -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_RGBA) &&
+      (iColortype == MNG_COLORTYPE_RGBA))
+  {
+    iNewsamplesize = 4;
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_rgba8_rgba16;
+    }
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+#ifdef MNG_INCLUDE_JNG
+  else                                 /* JPEG g -> g */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAY) &&
+      (iColortype == MNG_COLORTYPE_JPEGGRAY))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_g16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_g8;
+    }
+
+    iNewsamplesize = 1;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 2;
+#endif
+  }
+  else                                 /* JPEG g -> ga */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAY) &&
+      (iColortype == MNG_COLORTYPE_JPEGGRAYA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_ga16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_ga8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_g16_ga16;
+#endif
+
+    iNewsamplesize = 2;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 4;
+#endif
+  }
+  else                                 /* JPEG g -> rgb */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAY) &&
+      (iColortype == MNG_COLORTYPE_JPEGCOLOR))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgb16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgb8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_g16_rgb16;
+#endif
+
+    iNewsamplesize = 3;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 6;
+#endif
+  }
+  else                                 /* JPEG g -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAY) &&
+      (iColortype == MNG_COLORTYPE_JPEGCOLORA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgba16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_g8_rgba8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_g16_rgba16;
+#endif
+
+    iNewsamplesize = 4;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+  else                                 /* JPEG ga -> ga */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAYA) &&
+      (iColortype == MNG_COLORTYPE_JPEGGRAYA))
+  {
+    iNewsamplesize = 2;
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_ga8_ga16;
+    if (iBitdepth == 16)
+      iNewsamplesize = 4;
+#endif
+
+  }
+  else                                 /* JPEG ga -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGGRAYA) &&
+      (iColortype == MNG_COLORTYPE_JPEGCOLORA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_ga8_rgba16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_ga8_rgba8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_ga16_rgba16;
+#endif
+
+    iNewsamplesize = 4;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+  else                                 /* JPEG rgb -> rgb */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGCOLOR) &&
+      (iColortype == MNG_COLORTYPE_JPEGCOLOR))
+  {
+    iNewsamplesize = 3;
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_rgb8_rgb16;
+    if (iBitdepth == 16)
+      iNewsamplesize = 6;
+#endif
+
+  }
+  else                                 /* JPEG rgb -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGCOLOR) &&
+      (iColortype == MNG_COLORTYPE_JPEGCOLORA))
+  {
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+    {
+#ifndef MNG_NO_16BIT_SUPPORT
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_rgb8_rgba16;
+      else
+#endif
+        pData->fPromoterow = (mng_fptr)mng_promote_rgb8_rgba8;
+    }
+#ifndef MNG_NO_16BIT_SUPPORT
+    else                               /* source = 16 bits */
+      pData->fPromoterow = (mng_fptr)mng_promote_rgb16_rgba16;
+#endif
+
+    iNewsamplesize = 4;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (iBitdepth == 16)               /* 16-bit wide ? */
+      iNewsamplesize = 8;
+#endif
+  }
+  else                                 /* JPEG rgba -> rgba */
+  if ((pBuf->iColortype == MNG_COLORTYPE_JPEGCOLORA) &&
+      (iColortype == MNG_COLORTYPE_JPEGCOLORA))
+  {
+    iNewsamplesize = 4;
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth <= 8)          /* source <= 8 bits */
+      if (iBitdepth == 16)
+        pData->fPromoterow = (mng_fptr)mng_promote_rgba8_rgba16;
+    if (iBitdepth == 16)
+      iNewsamplesize = 8;
+#endif
+  }
+#endif /* JNG */
+
+  /* found a proper promotion ? */
+  if (pData->fPromoterow)
+  {
+    pData->pPromBuf    = (mng_ptr)pBuf;
+    pData->iPromWidth  = pBuf->iWidth;
+    iNewrowsize        = iW * iNewsamplesize;
+    iNewbufsize        = iH * iNewrowsize;
+
+    MNG_ALLOC (pData, pNewbuf, iNewbufsize);
+
+    pData->pPromSrc    = (mng_ptr)pBuf->pImgdata;
+    pData->pPromDst    = (mng_ptr)pNewbuf;
+    iY                 = 0;
+
+    while ((!iRetcode) && (iY < iH))
+    {
+      iRetcode         = ((mng_promoterow)pData->fPromoterow) (pData);
+      pData->pPromSrc  = (mng_uint8p)pData->pPromSrc + pBuf->iRowsize;
+      pData->pPromDst  = (mng_uint8p)pData->pPromDst + iNewrowsize;
+/*      pData->pPromSrc  = (mng_ptr)((mng_uint32)pData->pPromSrc + pBuf->iRowsize); */
+/*      pData->pPromDst  = (mng_ptr)((mng_uint32)pData->pPromDst + iNewrowsize); */
+      iY++;
+    }
+
+    MNG_FREEX (pData, pBuf->pImgdata, pBuf->iImgdatasize);
+
+    pBuf->iBitdepth    = iBitdepth;
+    pBuf->iColortype   = iColortype;
+    pBuf->iSamplesize  = iNewsamplesize;
+    pBuf->iRowsize     = iNewrowsize;
+    pBuf->iImgdatasize = iNewbufsize;
+    pBuf->pImgdata     = pNewbuf;
+    pBuf->bHasPLTE     = MNG_FALSE;
+    pBuf->iPLTEcount   = 0;
+    pBuf->bHasTRNS     = MNG_FALSE;
+    pBuf->iTRNScount   = 0;
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IMGOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode mng_magnify_imageobject (mng_datap  pData,
+                                     mng_imagep pImage)
+{
+  mng_uint8p     pNewdata;
+  mng_uint8p     pSrcline1;
+  mng_uint8p     pSrcline2;
+  mng_uint8p     pTempline;
+  mng_uint8p     pDstline;
+  mng_uint32     iNewrowsize;
+  mng_uint32     iNewsize;
+  mng_uint32     iY;
+  mng_int32      iS, iM;
+  mng_retcode    iRetcode;
+
+  mng_imagedatap pBuf      = pImage->pImgbuf;
+  mng_uint32     iNewW     = pBuf->iWidth;
+  mng_uint32     iNewH     = pBuf->iHeight;
+  mng_magnify_x  fMagnifyX = MNG_NULL;
+  mng_magnify_y  fMagnifyY = MNG_NULL;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_IMGOBJECT, MNG_LC_START);
+#endif
+
+  if (pBuf->iColortype == MNG_COLORTYPE_INDEXED)           /* indexed color ? */
+  {                                    /* concrete buffer ? */
+    if ((pBuf->bConcrete) && (pImage->iId))
+      MNG_ERROR (pData, MNG_INVALIDCOLORTYPE);
+
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+    if (pBuf->iTRNScount)              /* with transparency ? */
+      iRetcode = mng_promote_imageobject (pData, pImage, 8, 6, 0);
+    else
+      iRetcode = mng_promote_imageobject (pData, pImage, 8, 2, 0);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+#endif
+  }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_MAGN
+  /* Promote everything to RGBA, using fill method 0 (LBR) */
+  iRetcode = mng_promote_imageobject (pData, pImage, 8, 6, 0);           
+  if (iRetcode)                      /* on error bail out */
+    return iRetcode;
+#endif
+
+  if (pImage->iMAGN_MethodX)           /* determine new width */
+  {
+    if (pImage->iMAGN_MethodX == 1)
+    {
+      iNewW   = pImage->iMAGN_ML;
+      if (pBuf->iWidth  > 1)
+        iNewW = iNewW + pImage->iMAGN_MR;
+      if (pBuf->iWidth  > 2)
+        iNewW = iNewW + (pBuf->iWidth  - 2) * (pImage->iMAGN_MX);
+    }
+    else
+    {
+      iNewW   = pBuf->iWidth  + pImage->iMAGN_ML - 1;
+      if (pBuf->iWidth  > 2)
+        iNewW = iNewW + pImage->iMAGN_MR - 1;
+      if (pBuf->iWidth  > 3)
+        iNewW = iNewW + (pBuf->iWidth  - 3) * (pImage->iMAGN_MX - 1);
+    }
+  }
+
+  if (pImage->iMAGN_MethodY)           /* determine new height */
+  {
+    if (pImage->iMAGN_MethodY == 1)
+    {
+      iNewH   = pImage->iMAGN_MT;
+      if (pBuf->iHeight > 1)
+        iNewH = iNewH + pImage->iMAGN_ML;
+      if (pBuf->iHeight > 2)
+        iNewH = iNewH + (pBuf->iHeight - 2) * (pImage->iMAGN_MY);
+    }
+    else
+    {
+      iNewH   = pBuf->iHeight + pImage->iMAGN_MT - 1;
+      if (pBuf->iHeight > 2)
+        iNewH = iNewH + pImage->iMAGN_MB - 1;
+      if (pBuf->iHeight > 3)
+        iNewH = iNewH + (pBuf->iHeight - 3) * (pImage->iMAGN_MY - 1);
+    }
+  }
+                                       /* get new buffer */
+  iNewrowsize  = iNewW * pBuf->iSamplesize;
+  iNewsize     = iNewH * iNewrowsize;
+
+  MNG_ALLOC (pData, pNewdata, iNewsize);
+
+  switch (pBuf->iColortype)            /* determine magnification routines */
+  {
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+    case  0 : ;
+    case  8 : {
+                if (pBuf->iBitdepth <= 8)
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_g8_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_g8_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_g8_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_g8_x2; break; }
+                    case 5  : { fMagnifyX = mng_magnify_g8_x3; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_g8_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_g8_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_g8_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_g8_y2; break; }
+                    case 5  : { fMagnifyY = mng_magnify_g8_y3; break; }
+                  }
+                }
+#ifndef MNG_NO_16BIT_SUPPORT
+                else
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_g16_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_g16_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_g16_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_g16_x2; break; }
+                    case 5  : { fMagnifyX = mng_magnify_g16_x3; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_g16_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_g16_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_g16_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_g16_y2; break; }
+                    case 5  : { fMagnifyY = mng_magnify_g16_y3; break; }
+                  }
+                }
+#endif
+
+                break;
+              }
+
+    case  2 : ;
+    case 10 : {
+                if (pBuf->iBitdepth <= 8)
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_rgb8_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_rgb8_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_rgb8_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_rgb8_x2; break; }
+                    case 5  : { fMagnifyX = mng_magnify_rgb8_x3; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_rgb8_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_rgb8_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_rgb8_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_rgb8_y2; break; }
+                    case 5  : { fMagnifyY = mng_magnify_rgb8_y3; break; }
+                  }
+                }
+#ifndef MNG_NO_16BIT_SUPPORT
+                else
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_rgb16_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_rgb16_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_rgb16_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_rgb16_x2; break; }
+                    case 5  : { fMagnifyX = mng_magnify_rgb16_x3; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_rgb16_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_rgb16_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_rgb16_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_rgb16_y2; break; }
+                    case 5  : { fMagnifyY = mng_magnify_rgb16_y3; break; }
+                  }
+                }
+#endif
+
+                break;
+              }
+
+    case  4 : ;
+    case 12 : {
+                if (pBuf->iBitdepth <= 8)
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_ga8_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_ga8_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_ga8_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_ga8_x4; break; }
+                    case 5  : { fMagnifyX = mng_magnify_ga8_x5; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_ga8_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_ga8_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_ga8_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_ga8_y4; break; }
+                    case 5  : { fMagnifyY = mng_magnify_ga8_y5; break; }
+                  }
+                }
+#ifndef MNG_NO_16BIT_SUPPORT
+                else
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_ga16_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_ga16_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_ga16_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_ga16_x4; break; }
+                    case 5  : { fMagnifyX = mng_magnify_ga16_x5; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_ga16_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_ga16_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_ga16_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_ga16_y4; break; }
+                    case 5  : { fMagnifyY = mng_magnify_ga16_y5; break; }
+                  }
+                }
+#endif
+
+                break;
+              }
+#endif
+
+    case  6 : ;
+    case 14 : {
+                if (pBuf->iBitdepth <= 8)
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_rgba8_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_rgba8_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_rgba8_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_rgba8_x4; break; }
+                    case 5  : { fMagnifyX = mng_magnify_rgba8_x5; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_rgba8_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_rgba8_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_rgba8_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_rgba8_y4; break; }
+                    case 5  : { fMagnifyY = mng_magnify_rgba8_y5; break; }
+                  }
+                }
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+                else
+                {
+                  switch (pImage->iMAGN_MethodX)
+                  {
+                    case 1  : { fMagnifyX = mng_magnify_rgba16_x1; break; }
+                    case 2  : { fMagnifyX = mng_magnify_rgba16_x2; break; }
+                    case 3  : { fMagnifyX = mng_magnify_rgba16_x3; break; }
+                    case 4  : { fMagnifyX = mng_magnify_rgba16_x4; break; }
+                    case 5  : { fMagnifyX = mng_magnify_rgba16_x5; break; }
+                  }
+
+                  switch (pImage->iMAGN_MethodY)
+                  {
+                    case 1  : { fMagnifyY = mng_magnify_rgba16_y1; break; }
+                    case 2  : { fMagnifyY = mng_magnify_rgba16_y2; break; }
+                    case 3  : { fMagnifyY = mng_magnify_rgba16_y3; break; }
+                    case 4  : { fMagnifyY = mng_magnify_rgba16_y4; break; }
+                    case 5  : { fMagnifyY = mng_magnify_rgba16_y5; break; }
+                  }
+                }
+#endif
+#endif
+                break;
+              }
+  }
+
+  pSrcline1 = pBuf->pImgdata;          /* initialize row-loop variables */
+  pDstline  = pNewdata;
+                                       /* allocate temporary row */
+  MNG_ALLOC (pData, pTempline, iNewrowsize);
+
+  for (iY = 0; iY < pBuf->iHeight; iY++)
+  {
+    pSrcline2 = pSrcline1 + pBuf->iRowsize;
+
+    if (fMagnifyX)                     /* magnifying in X-direction ? */
+    {
+      iRetcode = fMagnifyX (pData, pImage->iMAGN_MX,
+                            pImage->iMAGN_ML, pImage->iMAGN_MR,
+                            pBuf->iWidth, pSrcline1, pDstline);
+
+      if (iRetcode)                    /* on error bail out */
+      {
+        MNG_FREEX (pData, pTempline, iNewrowsize);
+        MNG_FREEX (pData, pNewdata,  iNewsize);
+        return iRetcode;
+      }
+    }
+    else
+    {
+      MNG_COPY (pDstline, pSrcline1, iNewrowsize);
+    }
+
+    pDstline += iNewrowsize;
+                                       /* magnifying in Y-direction ? */
+    if ((fMagnifyY) &&
+        ((iY < pBuf->iHeight - 1) || (pBuf->iHeight == 1) || (pImage->iMAGN_MethodY == 1)))
+    {
+      if (iY == 0)                     /* first interval ? */
+      {
+        if (pBuf->iHeight == 1)        /* single row ? */
+          pSrcline2 = MNG_NULL;
+
+        iM = (mng_int32)pImage->iMAGN_MT;
+      }
+      else                             /* last interval ? */
+      if (((pImage->iMAGN_MethodY == 1) && (iY == (pBuf->iHeight - 1))) ||
+          ((pImage->iMAGN_MethodY != 1) && (iY == (pBuf->iHeight - 2)))    )
+        iM = (mng_int32)pImage->iMAGN_MB;
+      else                             /* middle interval */
+        iM = (mng_int32)pImage->iMAGN_MY;
+
+      for (iS = 1; iS < iM; iS++)
+      {
+        iRetcode = fMagnifyY (pData, iS, iM, pBuf->iWidth,
+                              pSrcline1, pSrcline2, pTempline);
+
+        if (iRetcode)                  /* on error bail out */
+        {
+          MNG_FREEX (pData, pTempline, iNewrowsize);
+          MNG_FREEX (pData, pNewdata,  iNewsize);
+          return iRetcode;
+        }
+
+        if (fMagnifyX)                   /* magnifying in X-direction ? */
+        {
+          iRetcode = fMagnifyX (pData, pImage->iMAGN_MX,
+                                pImage->iMAGN_ML, pImage->iMAGN_MR,
+                                pBuf->iWidth, pTempline, pDstline);
+
+          if (iRetcode)                  /* on error bail out */
+          {
+            MNG_FREEX (pData, pTempline, iNewrowsize);
+            MNG_FREEX (pData, pNewdata,  iNewsize);
+            return iRetcode;
+          }
+        }
+        else
+        {
+          MNG_COPY (pDstline, pTempline, iNewrowsize);
+        }
+
+        pDstline  += iNewrowsize;
+      }
+    }
+
+    pSrcline1 += pBuf->iRowsize;
+  }
+                                       /* drop temporary row */
+  MNG_FREEX (pData, pTempline, iNewrowsize);
+                                       /* drop old pixel-data */
+  MNG_FREEX (pData, pBuf->pImgdata, pBuf->iImgdatasize);
+
+  pBuf->pImgdata     = pNewdata;       /* save new buffer dimensions */
+  pBuf->iRowsize     = iNewrowsize;
+  pBuf->iImgdatasize = iNewsize;
+  pBuf->iWidth       = iNewW;
+  pBuf->iHeight      = iNewH;
+
+  if (pImage->iId)                     /* real object ? */
+  {
+    pImage->iMAGN_MethodX = 0;         /* it's done; don't do it again !!! */
+    pImage->iMAGN_MethodY = 0;
+    pImage->iMAGN_MX      = 0;
+    pImage->iMAGN_MY      = 0;
+    pImage->iMAGN_ML      = 0;
+    pImage->iMAGN_MR      = 0;
+    pImage->iMAGN_MT      = 0;
+    pImage->iMAGN_MB      = 0;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_IMGOBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_colorcorrect_object (mng_datap  pData,
+                                     mng_imagep pImage)
+{
+  mng_imagedatap pBuf = pImage->pImgbuf;
+  mng_retcode    iRetcode;
+  mng_uint32     iY;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COLORCORRECT_OBJECT, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+  if ((pBuf->iBitdepth < 8) ||         /* we need 8- or 16-bit RGBA !!! */
+      ((pBuf->iColortype != MNG_COLORTYPE_RGBA      ) &&
+       (pBuf->iColortype != MNG_COLORTYPE_JPEGCOLORA)    ))
+#else
+  if (pBuf->iBitdepth < 8)         /* we need 8- or 16-bit RGBA !!! */
+#endif
+    MNG_ERROR (pData, MNG_OBJNOTABSTRACT);
+
+  if (!pBuf->bCorrected)               /* only if not already done ! */
+  {                                    /* so the row routines now to find it */
+    pData->pRetrieveobj   = (mng_objectp)pImage;
+    pData->pStoreobj      = (mng_objectp)pImage;
+    pData->pStorebuf      = (mng_objectp)pImage->pImgbuf;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth > 8)
+    {
+      pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba16;
+      pData->fStorerow    = (mng_fptr)mng_store_rgba16;
+    }
+    else
+#endif
+    {
+      pData->fRetrieverow = (mng_fptr)mng_retrieve_rgba8;
+      pData->fStorerow    = (mng_fptr)mng_store_rgba8;
+    }
+
+    pData->bIsOpaque      = MNG_FALSE;
+
+    pData->iPass          = -1;        /* these are the object's dimensions now */
+    pData->iRow           = 0;
+    pData->iRowinc        = 1;
+    pData->iCol           = 0;
+    pData->iColinc        = 1;
+    pData->iRowsamples    = pBuf->iWidth;
+    pData->iRowsize       = pData->iRowsamples << 2;
+    pData->iPixelofs      = 0;
+    pData->bIsRGBA16      = MNG_FALSE;
+                                       /* adjust for 16-bit object ? */
+#ifndef MNG_NO_16BIT_SUPPORT
+    if (pBuf->iBitdepth > 8)
+    {
+      pData->bIsRGBA16    = MNG_TRUE;
+      pData->iRowsize     = pData->iRowsamples << 3;
+    }
+#endif
+
+    pData->fCorrectrow    = MNG_NULL;  /* default no color-correction */
+
+#ifdef MNG_NO_CMS
+    iRetcode = MNG_NOERROR;
+#else
+#if defined(MNG_FULL_CMS)              /* determine color-management routine */
+    iRetcode = mng_init_full_cms   (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_GAMMA_ONLY)
+    iRetcode = mng_init_gamma_only (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#elif defined(MNG_APP_CMS)
+    iRetcode = mng_init_app_cms    (pData, MNG_FALSE, MNG_FALSE, MNG_TRUE);
+#endif
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+#endif /* MNG_NO_CMS */
+
+    if (pData->fCorrectrow)            /* really correct something ? */
+    {                                  /* get a temporary row-buffer */
+      MNG_ALLOC (pData, pData->pRGBArow, pData->iRowsize);
+
+      pData->pWorkrow = pData->pRGBArow;
+      iY              = 0;             /* start from the top */
+
+      while ((!iRetcode) && (iY < pBuf->iHeight))
+      {                                /* get a row */
+        iRetcode = ((mng_retrieverow)pData->fRetrieverow) (pData);
+
+        if (!iRetcode)                 /* color correct it */
+          iRetcode = ((mng_correctrow)pData->fCorrectrow) (pData);
+
+        if (!iRetcode)                 /* store it back ! */
+          iRetcode = ((mng_storerow)pData->fStorerow) (pData);
+
+        if (!iRetcode)                 /* adjust variables for next row */
+          iRetcode = mng_next_row (pData);
+
+        iY++;                          /* and next line */
+      }
+                                       /* drop the temporary row-buffer */
+      MNG_FREEX (pData, pData->pRGBArow, pData->iRowsize);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+
+#if defined(MNG_FULL_CMS)              /* cleanup cms stuff */
+      iRetcode = mng_clear_cms (pData);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+#endif
+    }
+
+    pBuf->bCorrected = MNG_TRUE;       /* let's not go through that again ! */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COLORCORRECT_OBJECT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Animation-object routines                                              * */
+/* *                                                                        * */
+/* * these handle the animation objects used to re-run parts of a MNG.      * */
+/* * eg. during LOOP or TERM processing                                     * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+void mng_add_ani_object (mng_datap          pData,
+                         mng_object_headerp pObject)
+{
+  mng_object_headerp pLast = (mng_object_headerp)pData->pLastaniobj;
+
+  if (pLast)                           /* link it as last in the chain */
+  {
+    pObject->pPrev      = pLast;
+    pLast->pNext        = pObject;
+  }
+  else
+  {
+    pObject->pPrev      = MNG_NULL;    /* be on the safe side */
+    pData->pFirstaniobj = pObject;
+  }
+
+  pObject->pNext        = MNG_NULL;    /* be on the safe side */
+  pData->pLastaniobj    = pObject;
+                                       /* keep track for jumping */
+  pObject->iFramenr     = pData->iFrameseq;
+  pObject->iLayernr     = pData->iLayerseq;
+  pObject->iPlaytime    = pData->iFrametime;
+                                       /* save restart object ? */
+  if ((pData->bDisplaying) && (!pData->bRunning) && (!pData->pCurraniobj))
+    pData->pCurraniobj  = pObject;
+
+  return;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+mng_retcode mng_create_ani_image (mng_datap pData)
+{
+  mng_ani_imagep pImage;
+  mng_imagep     pCurrent;
+  mng_retcode    iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_IMAGE, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifndef MNG_NO_DELTA_PNG
+    if (pData->bHasDHDR)               /* processing delta-image ? */
+      pCurrent = (mng_imagep)pData->pObjzero;
+    else                               /* get the current object */
+#endif
+      pCurrent = (mng_imagep)pData->pCurrentobj;
+
+    if (!pCurrent)                     /* otherwise object 0 */
+      pCurrent = (mng_imagep)pData->pObjzero;
+                                       /* now just clone the object !!! */
+    iRetcode  = mng_clone_imageobject (pData, 0, MNG_FALSE, pCurrent->bVisible,
+                                       MNG_FALSE, MNG_FALSE, 0, 0, 0, pCurrent,
+                                       &pImage);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+
+    pImage->sHeader.fCleanup = mng_free_ani_image;
+    pImage->sHeader.fProcess = mng_process_ani_image;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pImage);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_IMAGE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* okido */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_ani_image (mng_datap   pData,
+                                mng_objectp pObject)
+{
+  mng_ani_imagep pImage = (mng_ani_imagep)pObject;
+  mng_imagedatap pImgbuf = pImage->pImgbuf;
+  mng_retcode    iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_IMAGE, MNG_LC_START);
+#endif
+                                       /* unlink the image-data buffer */
+  iRetcode = mng_free_imagedataobject (pData, pImgbuf);
+                                       /* drop its own buffer */
+  MNG_FREEX (pData, pImage, sizeof (mng_ani_image));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_IMAGE, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_image (mng_datap   pData,
+                                   mng_objectp pObject)
+{
+  mng_retcode    iRetcode = MNG_NOERROR;
+  mng_ani_imagep pImage   = (mng_imagep)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_IMAGE, MNG_LC_START);
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+  if (pData->bHasDHDR)                 /* processing delta-image ? */
+  {
+    mng_imagep pDelta = (mng_imagep)pData->pDeltaImage;
+
+    if (!pData->iBreakpoint)           /* only execute if not broken before */
+    {                                  /* make sure to process pixels as well */
+      pData->bDeltaimmediate = MNG_FALSE;
+                                       /* execute the delta process */
+      iRetcode = mng_execute_delta_image (pData, pDelta, (mng_imagep)pObject);
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+                                       /* now go and shoot it off (if required) */
+    if ((pDelta->bVisible) && (pDelta->bViewable))
+      iRetcode = mng_display_image (pData, pDelta, MNG_FALSE);
+
+    if (!pData->bTimerset)
+      pData->bHasDHDR = MNG_FALSE;     /* this image signifies IEND !! */
+
+  }
+  else
+#endif
+  if (pData->pCurrentobj)              /* active object ? */
+  {
+    mng_imagep     pCurrent = (mng_imagep)pData->pCurrentobj;
+    mng_imagedatap pBuf     = pCurrent->pImgbuf;
+
+    if (!pData->iBreakpoint)           /* don't copy it again ! */
+    {
+      if (pBuf->iImgdatasize)          /* buffer present in active object ? */
+                                       /* then drop it */
+        MNG_FREE (pData, pBuf->pImgdata, pBuf->iImgdatasize);
+
+#ifndef MNG_SKIPCHUNK_iCCP
+      if (pBuf->iProfilesize)          /* iCCP profile present ? */
+                                       /* then drop it */
+        MNG_FREE (pData, pBuf->pProfile, pBuf->iProfilesize);
+#endif
+                                       /* now blatently copy the animation buffer */
+      MNG_COPY (pBuf, pImage->pImgbuf, sizeof (mng_imagedata));
+                                       /* copy viewability */
+      pCurrent->bViewable = pImage->bViewable;
+
+      if (pBuf->iImgdatasize)          /* sample buffer present ? */
+      {                                /* then make a copy */
+        MNG_ALLOC (pData, pBuf->pImgdata, pBuf->iImgdatasize);
+        MNG_COPY (pBuf->pImgdata, pImage->pImgbuf->pImgdata, pBuf->iImgdatasize);
+      }
+
+#ifndef MNG_SKIPCHUNK_iCCP
+      if (pBuf->iProfilesize)          /* iCCP profile present ? */
+      {                                /* then make a copy */
+        MNG_ALLOC (pData, pBuf->pProfile, pBuf->iProfilesize);
+        MNG_COPY (pBuf->pProfile, pImage->pImgbuf->pProfile, pBuf->iProfilesize);
+      }
+#endif
+    }
+                                       /* now go and shoot it off (if required) */
+    if ((pCurrent->bVisible) && (pCurrent->bViewable))
+      iRetcode = mng_display_image (pData, pCurrent, MNG_FALSE);
+  }
+  else
+  {
+    mng_imagep     pObjzero = (mng_imagep)pData->pObjzero;
+    mng_imagedatap pBuf     = pObjzero->pImgbuf;
+
+    if (!pData->iBreakpoint)           /* don't copy it again ! */
+    {
+      if (pBuf->iImgdatasize)          /* buffer present in active object ? */
+                                       /* then drop it */
+        MNG_FREE (pData, pBuf->pImgdata, pBuf->iImgdatasize);
+
+#ifndef MNG_SKIPCHUNK_iCCP
+      if (pBuf->iProfilesize)          /* iCCP profile present ? */
+                                       /* then drop it */
+        MNG_FREE (pData, pBuf->pProfile, pBuf->iProfilesize);
+#endif
+                                       /* now blatently copy the animation buffer */
+      MNG_COPY (pBuf, pImage->pImgbuf, sizeof (mng_imagedata));
+                                       /* copy viewability */
+      pObjzero->bViewable = pImage->bViewable;
+
+      if (pBuf->iImgdatasize)          /* sample buffer present ? */
+      {                                /* then make a copy */
+        MNG_ALLOC (pData, pBuf->pImgdata, pBuf->iImgdatasize);
+        MNG_COPY (pBuf->pImgdata, pImage->pImgbuf->pImgdata, pBuf->iImgdatasize);
+      }
+
+#ifndef MNG_SKIPCHUNK_iCCP
+      if (pBuf->iProfilesize)          /* iCCP profile present ? */
+      {                                /* then make a copy */
+        MNG_ALLOC (pData, pBuf->pProfile, pBuf->iProfilesize);
+        MNG_COPY (pBuf->pProfile, pImage->pImgbuf->pProfile, pBuf->iProfilesize);
+      }
+#endif
+    }
+                                       /* now go and show it */
+    iRetcode = mng_display_image (pData, pObjzero, MNG_FALSE);
+  }
+
+  if (!iRetcode)                       /* all's well ? */
+  {
+    if (pData->bTimerset)              /* timer break ? */
+      pData->iBreakpoint = 99;         /* fictive number; no more processing needed! */
+    else
+      pData->iBreakpoint = 0;          /* else clear it */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_IMAGE, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_plte (mng_datap      pData,
+                                 mng_uint32     iEntrycount,
+                                 mng_palette8ep paEntries)
+#else
+mng_retcode mng_create_ani_plte (mng_datap      pData)
+#endif
+{
+  mng_ani_pltep pPLTE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PLTE, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_plte),
+                                               mng_free_obj_general,
+                                               mng_process_ani_plte,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pPLTE = (mng_ani_pltep)pTemp;
+#else
+    MNG_ALLOC (pData, pPLTE, sizeof (mng_ani_plte));
+
+    pPLTE->sHeader.fCleanup = mng_free_ani_plte;
+    pPLTE->sHeader.fProcess = mng_process_ani_plte;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pPLTE);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pPLTE->iEntrycount = iEntrycount;
+    MNG_COPY (pPLTE->aEntries, paEntries, sizeof (pPLTE->aEntries));
+#else
+    pPLTE->iEntrycount = pData->iGlobalPLTEcount;
+    MNG_COPY (pPLTE->aEntries, pData->aGlobalPLTEentries, sizeof (pPLTE->aEntries));
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_plte (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PLTE, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_plte));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_plte (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_pltep pPLTE = (mng_ani_pltep)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PLTE, MNG_LC_START);
+#endif
+
+  pData->bHasglobalPLTE   = MNG_TRUE;
+  pData->iGlobalPLTEcount = pPLTE->iEntrycount;
+
+  MNG_COPY (pData->aGlobalPLTEentries, pPLTE->aEntries, sizeof (pPLTE->aEntries));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PLTE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_trns (mng_datap    pData,
+                                 mng_uint32   iRawlen,
+                                 mng_uint8p   pRawdata)
+#else
+mng_retcode mng_create_ani_trns (mng_datap    pData)
+#endif
+{
+  mng_ani_trnsp pTRNS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_TRNS, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_trns),
+                                               mng_free_obj_general,
+                                               mng_process_ani_trns,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pTRNS = (mng_ani_trnsp)pTemp;
+#else
+    MNG_ALLOC (pData, pTRNS, sizeof (mng_ani_trns));
+
+    pTRNS->sHeader.fCleanup = mng_free_ani_trns;
+    pTRNS->sHeader.fProcess = mng_process_ani_trns;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pTRNS);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pTRNS->iRawlen = iRawlen;
+    MNG_COPY (pTRNS->aRawdata, pRawdata, sizeof (pTRNS->aRawdata));
+#else
+    pTRNS->iRawlen = pData->iGlobalTRNSrawlen;
+    MNG_COPY (pTRNS->aRawdata, pData->aGlobalTRNSrawdata, sizeof (pTRNS->aRawdata));
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_trns (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_TRNS, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_trns));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_trns (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_trnsp pTRNS = (mng_ani_trnsp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_TRNS, MNG_LC_START);
+#endif
+
+  pData->bHasglobalTRNS    = MNG_TRUE;
+  pData->iGlobalTRNSrawlen = pTRNS->iRawlen;
+
+  MNG_COPY (pData->aGlobalTRNSrawdata, pTRNS->aRawdata, sizeof (pTRNS->aRawdata));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_TRNS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_gAMA
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_gama (mng_datap  pData,
+                                 mng_bool   bEmpty,
+                                 mng_uint32 iGamma)
+#else
+mng_retcode mng_create_ani_gama (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_gamap pGAMA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_GAMA, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_gama),
+                                               mng_free_obj_general,
+                                               mng_process_ani_gama,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pGAMA = (mng_ani_gamap)pTemp;
+#else
+    MNG_ALLOC (pData, pGAMA, sizeof (mng_ani_gama));
+
+    pGAMA->sHeader.fCleanup = mng_free_ani_gama;
+    pGAMA->sHeader.fProcess = mng_process_ani_gama;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pGAMA);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pGAMA->bEmpty = bEmpty;
+    pGAMA->iGamma = iGamma;
+#else
+    pGAMA->bEmpty = ((mng_gamap)pChunk)->bEmpty;
+    pGAMA->iGamma = ((mng_gamap)pChunk)->iGamma;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_gama (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_GAMA, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_gama));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_gama (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_gamap pGAMA = (mng_ani_gamap)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_GAMA, MNG_LC_START);
+#endif
+
+  if (pGAMA->bEmpty)                   /* empty chunk ? */
+  {                                    /* clear global gAMA */
+    pData->bHasglobalGAMA = MNG_FALSE;
+    pData->iGlobalGamma   = 0;
+  }
+  else
+  {                                    /* set global gAMA */
+    pData->bHasglobalGAMA = MNG_TRUE;
+    pData->iGlobalGamma   = pGAMA->iGamma;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_GAMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_chrm (mng_datap  pData,
+                                 mng_bool   bEmpty,
+                                 mng_uint32 iWhitepointx,
+                                 mng_uint32 iWhitepointy,
+                                 mng_uint32 iRedx,
+                                 mng_uint32 iRedy,
+                                 mng_uint32 iGreenx,
+                                 mng_uint32 iGreeny,
+                                 mng_uint32 iBluex,
+                                 mng_uint32 iBluey)
+#else
+mng_retcode mng_create_ani_chrm (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_chrmp pCHRM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_CHRM, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr       pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_chrm),
+                                               mng_free_obj_general,
+                                               mng_process_ani_chrm,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pCHRM = (mng_ani_chrmp)pTemp;
+#else
+    MNG_ALLOC (pData, pCHRM, sizeof (mng_ani_chrm));
+
+    pCHRM->sHeader.fCleanup = mng_free_ani_chrm;
+    pCHRM->sHeader.fProcess = mng_process_ani_chrm;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pCHRM);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pCHRM->bEmpty       = bEmpty;
+    pCHRM->iWhitepointx = iWhitepointx;
+    pCHRM->iWhitepointy = iWhitepointy;
+    pCHRM->iRedx        = iRedx;
+    pCHRM->iRedy        = iRedy;
+    pCHRM->iGreenx      = iGreenx;
+    pCHRM->iGreeny      = iGreeny;
+    pCHRM->iBluex       = iBluex;
+    pCHRM->iBluey       = iBluey;
+#else
+    pCHRM->bEmpty       = ((mng_chrmp)pChunk)->bEmpty;
+    pCHRM->iWhitepointx = ((mng_chrmp)pChunk)->iWhitepointx;
+    pCHRM->iWhitepointy = ((mng_chrmp)pChunk)->iWhitepointy;
+    pCHRM->iRedx        = ((mng_chrmp)pChunk)->iRedx;
+    pCHRM->iRedy        = ((mng_chrmp)pChunk)->iRedy;
+    pCHRM->iGreenx      = ((mng_chrmp)pChunk)->iGreenx;
+    pCHRM->iGreeny      = ((mng_chrmp)pChunk)->iGreeny;
+    pCHRM->iBluex       = ((mng_chrmp)pChunk)->iBluex;
+    pCHRM->iBluey       = ((mng_chrmp)pChunk)->iBluey;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_chrm (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_CHRM, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_chrm));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_chrm (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_chrmp pCHRM = (mng_ani_chrmp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_CHRM, MNG_LC_START);
+#endif
+
+  if (pCHRM->bEmpty)                   /* empty chunk ? */
+  {                                    /* clear global cHRM */
+    pData->bHasglobalCHRM       = MNG_FALSE;
+    pData->iGlobalWhitepointx   = 0;
+    pData->iGlobalWhitepointy   = 0;
+    pData->iGlobalPrimaryredx   = 0;
+    pData->iGlobalPrimaryredy   = 0;
+    pData->iGlobalPrimarygreenx = 0;
+    pData->iGlobalPrimarygreeny = 0;
+    pData->iGlobalPrimarybluex  = 0;
+    pData->iGlobalPrimarybluey  = 0;
+  }
+  else
+  {                                    /* set global cHRM */
+    pData->bHasglobalCHRM       = MNG_TRUE;
+    pData->iGlobalWhitepointx   = pCHRM->iWhitepointx;
+    pData->iGlobalWhitepointy   = pCHRM->iWhitepointy;
+    pData->iGlobalPrimaryredx   = pCHRM->iRedx;
+    pData->iGlobalPrimaryredy   = pCHRM->iRedy;
+    pData->iGlobalPrimarygreenx = pCHRM->iGreenx;
+    pData->iGlobalPrimarygreeny = pCHRM->iGreeny;
+    pData->iGlobalPrimarybluex  = pCHRM->iBluex;
+    pData->iGlobalPrimarybluey  = pCHRM->iBluey;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_CHRM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_sRGB
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_srgb (mng_datap pData,
+                                 mng_bool  bEmpty,
+                                 mng_uint8 iRenderingintent)
+#else
+mng_retcode mng_create_ani_srgb (mng_datap pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_srgbp pSRGB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SRGB, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_srgb),
+                                               mng_free_obj_general,
+                                               mng_process_ani_srgb,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pSRGB = (mng_ani_srgbp)pTemp;
+#else
+    MNG_ALLOC (pData, pSRGB, sizeof (mng_ani_srgb));
+
+    pSRGB->sHeader.fCleanup = mng_free_ani_srgb;
+    pSRGB->sHeader.fProcess = mng_process_ani_srgb;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pSRGB);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pSRGB->bEmpty           = bEmpty;
+    pSRGB->iRenderingintent = iRenderingintent;
+#else
+    pSRGB->bEmpty           = ((mng_srgbp)pChunk)->bEmpty;
+    pSRGB->iRenderingintent = ((mng_srgbp)pChunk)->iRenderingintent;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_srgb (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SRGB, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_srgb));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_srgb (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_srgbp pSRGB = (mng_ani_srgbp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SRGB, MNG_LC_START);
+#endif
+
+  if (pSRGB->bEmpty)                   /* empty chunk ? */
+  {                                    /* clear global sRGB */
+    pData->bHasglobalSRGB    = MNG_FALSE;
+    pData->iGlobalRendintent = 0;
+  }
+  else
+  {                                    /* set global sRGB */
+    pData->bHasglobalSRGB    = MNG_TRUE;
+    pData->iGlobalRendintent = pSRGB->iRenderingintent;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_iccp (mng_datap  pData,
+                                 mng_bool   bEmpty,
+                                 mng_uint32 iProfilesize,
+                                 mng_ptr    pProfile)
+#else
+mng_retcode mng_create_ani_iccp (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_iccpp pICCP;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_ICCP, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr       pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_iccp),
+                                               mng_free_ani_iccp,
+                                               mng_process_ani_iccp,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pICCP = (mng_ani_iccpp)pTemp;
+#else
+    MNG_ALLOC (pData, pICCP, sizeof (mng_ani_iccp));
+
+    pICCP->sHeader.fCleanup = mng_free_ani_iccp;
+    pICCP->sHeader.fProcess = mng_process_ani_iccp;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pICCP);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pICCP->bEmpty       = bEmpty;
+    pICCP->iProfilesize = iProfilesize;
+
+    if (iProfilesize)
+    {
+      MNG_ALLOC (pData, pICCP->pProfile, iProfilesize);
+      MNG_COPY (pICCP->pProfile, pProfile, iProfilesize);
+    }
+#else
+    pICCP->bEmpty       = ((mng_iccpp)pChunk)->bEmpty;
+    pICCP->iProfilesize = ((mng_iccpp)pChunk)->iProfilesize;
+
+    if (pICCP->iProfilesize)
+    {
+      MNG_ALLOC (pData, pICCP->pProfile, pICCP->iProfilesize);
+      MNG_COPY (pICCP->pProfile, ((mng_iccpp)pChunk)->pProfile, pICCP->iProfilesize);
+    }
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_ICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_ani_iccp (mng_datap   pData,
+                               mng_objectp pObject)
+{
+  mng_ani_iccpp pICCP = (mng_ani_iccpp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_ICCP, MNG_LC_START);
+#endif
+
+  if (pICCP->iProfilesize)
+    MNG_FREEX (pData, pICCP->pProfile, pICCP->iProfilesize);
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_iccp));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_ICCP, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_iccp (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_iccpp pICCP = (mng_ani_iccpp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_ICCP, MNG_LC_START);
+#endif
+
+  if (pICCP->bEmpty)                   /* empty chunk ? */
+  {                                    /* clear global iCCP */
+    pData->bHasglobalICCP = MNG_FALSE;
+
+    if (pData->iGlobalProfilesize)
+      MNG_FREEX (pData, pData->pGlobalProfile, pData->iGlobalProfilesize);
+
+    pData->iGlobalProfilesize = 0;
+    pData->pGlobalProfile     = MNG_NULL;
+  }
+  else
+  {                                    /* set global iCCP */
+    pData->bHasglobalICCP     = MNG_TRUE;
+    pData->iGlobalProfilesize = pICCP->iProfilesize;
+
+    if (pICCP->iProfilesize)
+    {
+      MNG_ALLOC (pData, pData->pGlobalProfile, pICCP->iProfilesize);
+      MNG_COPY (pData->pGlobalProfile, pICCP->pProfile, pICCP->iProfilesize);
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_ICCP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_bkgd (mng_datap  pData,
+                                 mng_uint16 iRed,
+                                 mng_uint16 iGreen,
+                                 mng_uint16 iBlue)
+#else
+mng_retcode mng_create_ani_bkgd (mng_datap  pData)
+#endif
+{
+  mng_ani_bkgdp pBKGD;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_BKGD, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr       pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_bkgd),
+                                               mng_free_obj_general,
+                                               mng_process_ani_bkgd,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pBKGD = (mng_ani_bkgdp)pTemp;
+#else
+    MNG_ALLOC (pData, pBKGD, sizeof (mng_ani_bkgd));
+
+    pBKGD->sHeader.fCleanup = mng_free_ani_bkgd;
+    pBKGD->sHeader.fProcess = mng_process_ani_bkgd;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pBKGD);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pBKGD->iRed   = iRed;
+    pBKGD->iGreen = iGreen;
+    pBKGD->iBlue  = iBlue;
+#else
+    pBKGD->iRed   = pData->iGlobalBKGDred;
+    pBKGD->iGreen = pData->iGlobalBKGDgreen;
+    pBKGD->iBlue  = pData->iGlobalBKGDblue;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_bkgd (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_BKGD, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_bkgd));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_bkgd (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_bkgdp pBKGD = (mng_ani_bkgdp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_BKGD, MNG_LC_START);
+#endif
+
+  pData->bHasglobalBKGD   = MNG_TRUE;
+  pData->iGlobalBKGDred   = pBKGD->iRed;
+  pData->iGlobalBKGDgreen = pBKGD->iGreen;
+  pData->iGlobalBKGDblue  = pBKGD->iBlue;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_LOOP
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_loop (mng_datap   pData,
+                                 mng_uint8   iLevel,
+                                 mng_uint32  iRepeatcount,
+                                 mng_uint8   iTermcond,
+                                 mng_uint32  iItermin,
+                                 mng_uint32  iItermax,
+                                 mng_uint32  iCount,
+                                 mng_uint32p pSignals)
+#else
+mng_retcode mng_create_ani_loop (mng_datap   pData,
+                                 mng_chunkp  pChunk)
+#endif
+{
+  mng_ani_loopp pLOOP;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_LOOP, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_loop),
+                                               mng_free_ani_loop,
+                                               mng_process_ani_loop,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pLOOP = (mng_ani_loopp)pTemp;
+#else
+    MNG_ALLOC (pData, pLOOP, sizeof (mng_ani_loop));
+
+    pLOOP->sHeader.fCleanup = mng_free_ani_loop;
+    pLOOP->sHeader.fProcess = mng_process_ani_loop;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pLOOP);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pLOOP->iLevel       = iLevel;
+    pLOOP->iRepeatcount = iRepeatcount;
+    pLOOP->iTermcond    = iTermcond;
+    pLOOP->iItermin     = iItermin;
+    pLOOP->iItermax     = iItermax;
+    pLOOP->iCount       = iCount;
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+    if (iCount)
+    {
+      MNG_ALLOC (pData, pLOOP->pSignals, (iCount << 1));
+      MNG_COPY (pLOOP->pSignals, pSignals, (iCount << 1));
+    }
+#endif
+#else /* MNG_OPTIMIZE_CHUNKREADER */
+    pLOOP->iLevel       = ((mng_loopp)pChunk)->iLevel;
+    pLOOP->iRepeatcount = ((mng_loopp)pChunk)->iRepeat;
+    pLOOP->iTermcond    = ((mng_loopp)pChunk)->iTermination;
+    pLOOP->iItermin     = ((mng_loopp)pChunk)->iItermin;
+    pLOOP->iItermax     = ((mng_loopp)pChunk)->iItermax;
+    pLOOP->iCount       = ((mng_loopp)pChunk)->iCount;
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+    if (pLOOP->iCount)
+    {
+      MNG_ALLOC (pData, pLOOP->pSignals, (pLOOP->iCount << 1));
+      MNG_COPY (pLOOP->pSignals, ((mng_loopp)pChunk)->pSignals, (pLOOP->iCount << 1));
+    }
+#endif
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+                                         /* running counter starts with repeat_count */
+    pLOOP->iRunningcount = pLOOP->iRepeatcount;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_LOOP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_ani_loop (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+  mng_ani_loopp pLOOP = (mng_ani_loopp)pObject;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_LOOP, MNG_LC_START);
+#endif
+
+#ifndef MNG_NO_LOOP_SIGNALS_SUPPORTED
+  if (pLOOP->iCount)                   /* drop signal buffer ? */
+    MNG_FREEX (pData, pLOOP->pSignals, (pLOOP->iCount << 1));
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_loop));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_LOOP, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_loop (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_loopp pLOOP = (mng_ani_loopp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_LOOP, MNG_LC_START);
+#endif
+                                       /* just reset the running counter */
+  pLOOP->iRunningcount = pLOOP->iRepeatcount;
+                                       /* iteration=0 means we're skipping ! */
+  if ((!pData->bSkipping) && (pLOOP->iRepeatcount == 0))
+    pData->bSkipping = MNG_TRUE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_LOOP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+mng_retcode mng_create_ani_endl (mng_datap pData,
+                                 mng_uint8 iLevel)
+{
+  mng_ani_endlp pENDL;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_ENDL, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+    mng_retcode iRetcode;
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_endl),
+                                               mng_free_obj_general,
+                                               mng_process_ani_endl,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pENDL = (mng_ani_endlp)pTemp;
+#else
+    MNG_ALLOC (pData, pENDL, sizeof (mng_ani_endl));
+
+    pENDL->sHeader.fCleanup = mng_free_ani_endl;
+    pENDL->sHeader.fProcess = mng_process_ani_endl;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pENDL);
+
+    pENDL->iLevel = iLevel;
+
+    iRetcode = mng_process_ani_endl (pData, (mng_objectp)pENDL);
+    if (iRetcode)
+      return iRetcode;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_endl (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_ENDL, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_endl));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_endl (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_endlp pENDL = (mng_ani_endlp)pObject;
+  mng_ani_loopp pLOOP;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_ENDL, MNG_LC_START);
+#endif
+
+  if (((pData->bDisplaying) && ((pData->bRunning) || (pData->bSearching))) ||
+      (pData->bReading)                                                       )
+  {
+    pLOOP = pENDL->pLOOP;              /* determine matching LOOP */
+
+    if (!pLOOP)                        /* haven't got it yet ? */
+    {                                  /* go and look back in the list */
+      pLOOP = (mng_ani_loopp)pENDL->sHeader.pPrev;
+
+      while ((pLOOP) &&
+             ((pLOOP->sHeader.fCleanup != mng_free_ani_loop) ||
+              (pLOOP->iLevel           != pENDL->iLevel)        ))
+        pLOOP = pLOOP->sHeader.pPrev;
+    }
+                                       /* got it now ? */
+    if ((pLOOP) && (pLOOP->iLevel == pENDL->iLevel))
+    {
+      pENDL->pLOOP = pLOOP;            /* save for next time ! */
+                                       /* decrease running counter ? */
+      if ((pLOOP->iRunningcount) && (pLOOP->iRunningcount < 0x7fffffffL))
+        pLOOP->iRunningcount--;
+
+      if ((!pData->bDisplaying) && (pData->bReading) &&
+          (pLOOP->iRunningcount >= 0x7fffffffL))
+      {
+        pData->iTotalframes   = 0x7fffffffL;
+        pData->iTotallayers   = 0x7fffffffL;
+        pData->iTotalplaytime = 0x7fffffffL;
+      }
+      else
+      {
+        /* TODO: we're cheating out on the termination_condition,
+           iteration_min, iteration_max and possible signals;
+           the code is just not ready for that can of worms.... */
+
+        if (!pLOOP->iRunningcount)     /* reached zero ? */
+        {                              /* was this the outer LOOP ? */
+          if (pData->pFirstaniobj == (mng_objectp)pLOOP)  /* TODO: THIS IS WRONG!! */
+            pData->bHasLOOP = MNG_FALSE;
+        }
+        else
+        {
+          if (pData->pCurraniobj)      /* was we processing objects ? */
+            pData->pCurraniobj = pLOOP;/* then restart with LOOP */
+          else                         /* else restart behind LOOP !!! */
+            pData->pCurraniobj = pLOOP->sHeader.pNext;
+        }
+      }
+                                       /* does this match a 'skipping' LOOP? */
+      if ((pData->bSkipping) && (pLOOP->iRepeatcount == 0))
+        pData->bSkipping = MNG_FALSE;
+    }
+    else
+      MNG_ERROR (pData, MNG_NOMATCHINGLOOP);
+
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_ENDL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DEFI
+mng_retcode mng_create_ani_defi (mng_datap pData)
+{               
+  mng_ani_defip pDEFI;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_DEFI, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_defi),
+                                               mng_free_obj_general,
+                                               mng_process_ani_defi,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pDEFI = (mng_ani_defip)pTemp;
+#else
+    MNG_ALLOC (pData, pDEFI, sizeof (mng_ani_defi));
+
+    pDEFI->sHeader.fCleanup = mng_free_ani_defi;
+    pDEFI->sHeader.fProcess = mng_process_ani_defi;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pDEFI);
+
+    pDEFI->iId              = pData->iDEFIobjectid;
+    pDEFI->bHasdonotshow    = pData->bDEFIhasdonotshow;
+    pDEFI->iDonotshow       = pData->iDEFIdonotshow;
+    pDEFI->bHasconcrete     = pData->bDEFIhasconcrete;
+    pDEFI->iConcrete        = pData->iDEFIconcrete;
+    pDEFI->bHasloca         = pData->bDEFIhasloca;
+    pDEFI->iLocax           = pData->iDEFIlocax;
+    pDEFI->iLocay           = pData->iDEFIlocay;
+    pDEFI->bHasclip         = pData->bDEFIhasclip;
+    pDEFI->iClipl           = pData->iDEFIclipl;
+    pDEFI->iClipr           = pData->iDEFIclipr;
+    pDEFI->iClipt           = pData->iDEFIclipt;
+    pDEFI->iClipb           = pData->iDEFIclipb;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_defi (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_DEFI, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_defi));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_defi (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_defip pDEFI = (mng_ani_defip)pObject;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_DEFI, MNG_LC_START);
+#endif
+
+  pData->iDEFIobjectid     = pDEFI->iId;
+  pData->bDEFIhasdonotshow = pDEFI->bHasdonotshow;
+  pData->iDEFIdonotshow    = pDEFI->iDonotshow;
+  pData->bDEFIhasconcrete  = pDEFI->bHasconcrete;
+  pData->iDEFIconcrete     = pDEFI->iConcrete;
+  pData->bDEFIhasloca      = pDEFI->bHasloca;
+  pData->iDEFIlocax        = pDEFI->iLocax;
+  pData->iDEFIlocay        = pDEFI->iLocay;
+  pData->bDEFIhasclip      = pDEFI->bHasclip;
+  pData->iDEFIclipl        = pDEFI->iClipl;
+  pData->iDEFIclipr        = pDEFI->iClipr;
+  pData->iDEFIclipt        = pDEFI->iClipt;
+  pData->iDEFIclipb        = pDEFI->iClipb;
+
+  iRetcode = mng_process_display_defi (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_DEFI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BASI
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_basi (mng_datap  pData,
+                                 mng_uint16 iRed,
+                                 mng_uint16 iGreen,
+                                 mng_uint16 iBlue,
+                                 mng_bool   bHasalpha,
+                                 mng_uint16 iAlpha,
+                                 mng_uint8  iViewable)
+#else
+mng_retcode mng_create_ani_basi (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_basip pBASI;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_BASI, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_basi),
+                                   mng_free_obj_general,
+                                   mng_process_ani_basi,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pBASI = (mng_ani_basip)pTemp;
+#else
+    MNG_ALLOC (pData, pBASI, sizeof (mng_ani_basi));
+
+    pBASI->sHeader.fCleanup = mng_free_ani_basi;
+    pBASI->sHeader.fProcess = mng_process_ani_basi;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pBASI);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pBASI->iRed      = iRed;
+    pBASI->iGreen    = iGreen;
+    pBASI->iBlue     = iBlue;
+    pBASI->bHasalpha = bHasalpha;
+    pBASI->iAlpha    = iAlpha;
+    pBASI->iViewable = iViewable;
+#else
+    pBASI->iRed      = ((mng_basip)pChunk)->iRed;
+    pBASI->iGreen    = ((mng_basip)pChunk)->iGreen;
+    pBASI->iBlue     = ((mng_basip)pChunk)->iBlue;
+    pBASI->bHasalpha = ((mng_basip)pChunk)->bHasalpha;
+    pBASI->iAlpha    = ((mng_basip)pChunk)->iAlpha;
+    pBASI->iViewable = ((mng_basip)pChunk)->iViewable;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_basi (pData, iRed, iGreen, iBlue,
+                                       bHasalpha, iAlpha, iViewable);
+#else
+  iRetcode = mng_process_display_basi (pData,
+                                       ((mng_basip)pChunk)->iRed,
+                                       ((mng_basip)pChunk)->iGreen,
+                                       ((mng_basip)pChunk)->iBlue,
+                                       ((mng_basip)pChunk)->bHasalpha,
+                                       ((mng_basip)pChunk)->iAlpha,
+                                       ((mng_basip)pChunk)->iViewable);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iBASIred      = iRed;
+  pData->iBASIgreen    = iGreen;
+  pData->iBASIblue     = iBlue;
+  pData->bBASIhasalpha = bHasalpha;
+  pData->iBASIalpha    = iAlpha;
+  pData->iBASIviewable = iViewable;
+#else
+  pData->iBASIred      = ((mng_basip)pChunk)->iRed;
+  pData->iBASIgreen    = ((mng_basip)pChunk)->iGreen;
+  pData->iBASIblue     = ((mng_basip)pChunk)->iBlue;
+  pData->bBASIhasalpha = ((mng_basip)pChunk)->bHasalpha;
+  pData->iBASIalpha    = ((mng_basip)pChunk)->iAlpha;
+  pData->iBASIviewable = ((mng_basip)pChunk)->iViewable;
+#endif
+
+  iRetcode = mng_process_display_basi (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_BASI, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_basi (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_BASI, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_basi));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_BASI, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_basi (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_basip pBASI = (mng_ani_basip)pObject;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_BASI, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_basi (pData, pBASI->iRed, pBASI->iGreen, pBASI->iBlue,
+                                       pBASI->bHasalpha, pBASI->iAlpha, pBASI->iViewable);
+#else
+  pData->iBASIred      = pBASI->iRed;
+  pData->iBASIgreen    = pBASI->iGreen;
+  pData->iBASIblue     = pBASI->iBlue;
+  pData->bBASIhasalpha = pBASI->bHasalpha;
+  pData->iBASIalpha    = pBASI->iAlpha;
+  pData->iBASIviewable = pBASI->iViewable;
+
+  iRetcode = mng_process_display_basi (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_BASI, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLON
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_clon (mng_datap  pData,
+                                 mng_uint16 iSourceid,
+                                 mng_uint16 iCloneid,
+                                 mng_uint8  iClonetype,
+                                 mng_bool   bHasdonotshow,
+                                 mng_uint8  iDonotshow,
+                                 mng_uint8  iConcrete,
+                                 mng_bool   bHasloca,
+                                 mng_uint8  iLocatype,
+                                 mng_int32  iLocax,
+                                 mng_int32  iLocay)
+#else
+mng_retcode mng_create_ani_clon (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_clonp pCLON;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_CLON, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_clon),
+                                   mng_free_obj_general,
+                                   mng_process_ani_clon,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pCLON = (mng_ani_clonp)pTemp;
+#else
+    MNG_ALLOC (pData, pCLON, sizeof (mng_ani_clon));
+
+    pCLON->sHeader.fCleanup = mng_free_ani_clon;
+    pCLON->sHeader.fProcess = mng_process_ani_clon;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pCLON);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pCLON->iSourceid     = iSourceid;
+    pCLON->iCloneid      = iCloneid;
+    pCLON->iClonetype    = iClonetype;
+    pCLON->bHasdonotshow = bHasdonotshow;
+    pCLON->iDonotshow    = iDonotshow;
+    pCLON->iConcrete     = iConcrete;
+    pCLON->bHasloca      = bHasloca;
+    pCLON->iLocatype     = iLocatype;
+    pCLON->iLocax        = iLocax;
+    pCLON->iLocay        = iLocay;
+#else
+    pCLON->iSourceid     = ((mng_clonp)pChunk)->iSourceid;
+    pCLON->iCloneid      = ((mng_clonp)pChunk)->iCloneid;
+    pCLON->iClonetype    = ((mng_clonp)pChunk)->iClonetype;
+    pCLON->bHasdonotshow = ((mng_clonp)pChunk)->bHasdonotshow;
+    pCLON->iDonotshow    = ((mng_clonp)pChunk)->iDonotshow;
+    pCLON->iConcrete     = ((mng_clonp)pChunk)->iConcrete;
+    pCLON->bHasloca      = ((mng_clonp)pChunk)->bHasloca;
+    pCLON->iLocatype     = ((mng_clonp)pChunk)->iLocationtype;
+    pCLON->iLocax        = ((mng_clonp)pChunk)->iLocationx;
+    pCLON->iLocay        = ((mng_clonp)pChunk)->iLocationy;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_clon (pData, iSourceid, iCloneid, iClonetype,
+                                       bHasdonotshow, iDonotshow, iConcrete,
+                                       bHasloca, iLocatype, iLocax, iLocay);
+#else
+  iRetcode = mng_process_display_clon (pData,
+                                       ((mng_clonp)pChunk)->iSourceid,
+                                       ((mng_clonp)pChunk)->iCloneid,
+                                       ((mng_clonp)pChunk)->iClonetype,
+                                       ((mng_clonp)pChunk)->bHasdonotshow,
+                                       ((mng_clonp)pChunk)->iDonotshow,
+                                       ((mng_clonp)pChunk)->iConcrete,
+                                       ((mng_clonp)pChunk)->bHasloca,
+                                       ((mng_clonp)pChunk)->iLocationtype,
+                                       ((mng_clonp)pChunk)->iLocationx,
+                                       ((mng_clonp)pChunk)->iLocationy);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iCLONsourceid     = iSourceid;
+  pData->iCLONcloneid      = iCloneid;
+  pData->iCLONclonetype    = iClonetype;
+  pData->bCLONhasdonotshow = bHasdonotshow;
+  pData->iCLONdonotshow    = iDonotshow;
+  pData->iCLONconcrete     = iConcrete;
+  pData->bCLONhasloca      = bHasloca;
+  pData->iCLONlocationtype = iLocatype;
+  pData->iCLONlocationx    = iLocax;
+  pData->iCLONlocationy    = iLocay;
+#else
+  pData->iCLONsourceid     = ((mng_clonp)pChunk)->iSourceid;
+  pData->iCLONcloneid      = ((mng_clonp)pChunk)->iCloneid;
+  pData->iCLONclonetype    = ((mng_clonp)pChunk)->iClonetype;
+  pData->bCLONhasdonotshow = ((mng_clonp)pChunk)->bHasdonotshow;
+  pData->iCLONdonotshow    = ((mng_clonp)pChunk)->iDonotshow;
+  pData->iCLONconcrete     = ((mng_clonp)pChunk)->iConcrete;
+  pData->bCLONhasloca      = ((mng_clonp)pChunk)->bHasloca;
+  pData->iCLONlocationtype = ((mng_clonp)pChunk)->iLocationtype;
+  pData->iCLONlocationx    = ((mng_clonp)pChunk)->iLocationx;
+  pData->iCLONlocationy    = ((mng_clonp)pChunk)->iLocationy;
+#endif
+
+  iRetcode = mng_process_display_clon (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_CLON, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_clon (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_CLON, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_clon));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_CLON, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_clon (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_clonp pCLON = (mng_ani_clonp)pObject;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_CLON, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_clon (pData, pCLON->iSourceid, pCLON->iCloneid,
+                                       pCLON->iClonetype, pCLON->bHasdonotshow,
+                                       pCLON->iDonotshow, pCLON->iConcrete,
+                                       pCLON->bHasloca, pCLON->iLocatype,
+                                       pCLON->iLocax, pCLON->iLocay);
+#else
+  pData->iCLONcloneid      = pCLON->iCloneid;
+  pData->iCLONsourceid     = pCLON->iSourceid;
+  pData->iCLONclonetype    = pCLON->iClonetype;
+  pData->bCLONhasdonotshow = pCLON->bHasdonotshow;
+  pData->iCLONdonotshow    = pCLON->iDonotshow;
+  pData->iCLONconcrete     = pCLON->iConcrete;
+  pData->bCLONhasloca      = pCLON->bHasloca;
+  pData->iCLONlocationtype = pCLON->iLocatype;
+  pData->iCLONlocationx    = pCLON->iLocax;
+  pData->iCLONlocationy    = pCLON->iLocay;
+
+  iRetcode = mng_process_display_clon (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_CLON, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_BACK
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_back (mng_datap  pData,
+                                 mng_uint16 iRed,
+                                 mng_uint16 iGreen,
+                                 mng_uint16 iBlue,
+                                 mng_uint8  iMandatory,
+                                 mng_uint16 iImageid,
+                                 mng_uint8  iTile)
+#else
+mng_retcode mng_create_ani_back (mng_datap  pData)
+#endif
+{
+  mng_ani_backp pBACK;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_BACK, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_back),
+                                               mng_free_obj_general,
+                                               mng_process_ani_back,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pBACK = (mng_ani_backp)pTemp;
+#else
+    MNG_ALLOC (pData, pBACK, sizeof (mng_ani_back));
+
+    pBACK->sHeader.fCleanup = mng_free_ani_back;
+    pBACK->sHeader.fProcess = mng_process_ani_back;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pBACK);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pBACK->iRed       = iRed;
+    pBACK->iGreen     = iGreen;
+    pBACK->iBlue      = iBlue;
+    pBACK->iMandatory = iMandatory;
+    pBACK->iImageid   = iImageid;
+    pBACK->iTile      = iTile;
+#else
+    pBACK->iRed       = pData->iBACKred;      
+    pBACK->iGreen     = pData->iBACKgreen;
+    pBACK->iBlue      = pData->iBACKblue;
+    pBACK->iMandatory = pData->iBACKmandatory;
+    pBACK->iImageid   = pData->iBACKimageid;
+    pBACK->iTile      = pData->iBACKtile;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_back (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_BACK, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_back));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_back (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_backp pBACK = (mng_ani_backp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_BACK, MNG_LC_START);
+#endif
+
+  pData->iBACKred       = pBACK->iRed;
+  pData->iBACKgreen     = pBACK->iGreen;
+  pData->iBACKblue      = pBACK->iBlue;
+  pData->iBACKmandatory = pBACK->iMandatory;
+  pData->iBACKimageid   = pBACK->iImageid;
+  pData->iBACKtile      = pBACK->iTile;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_BACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_FRAM
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_fram (mng_datap  pData,
+                                 mng_uint8  iFramemode,
+                                 mng_uint8  iChangedelay,
+                                 mng_uint32 iDelay,
+                                 mng_uint8  iChangetimeout,
+                                 mng_uint32 iTimeout,
+                                 mng_uint8  iChangeclipping,
+                                 mng_uint8  iCliptype,
+                                 mng_int32  iClipl,
+                                 mng_int32  iClipr,
+                                 mng_int32  iClipt,
+                                 mng_int32  iClipb)
+#else
+mng_retcode mng_create_ani_fram (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_framp pFRAM;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_FRAM, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_fram),
+                                   mng_free_obj_general,
+                                   mng_process_ani_fram,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pFRAM = (mng_ani_framp)pTemp;
+#else
+    MNG_ALLOC (pData, pFRAM, sizeof (mng_ani_fram));
+
+    pFRAM->sHeader.fCleanup = mng_free_ani_fram;
+    pFRAM->sHeader.fProcess = mng_process_ani_fram;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pFRAM);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pFRAM->iFramemode      = iFramemode;
+    pFRAM->iChangedelay    = iChangedelay;
+    pFRAM->iDelay          = iDelay;
+    pFRAM->iChangetimeout  = iChangetimeout;
+    pFRAM->iTimeout        = iTimeout;
+    pFRAM->iChangeclipping = iChangeclipping;
+    pFRAM->iCliptype       = iCliptype;
+    pFRAM->iClipl          = iClipl;
+    pFRAM->iClipr          = iClipr;
+    pFRAM->iClipt          = iClipt;
+    pFRAM->iClipb          = iClipb;
+#else
+    pFRAM->iFramemode      = ((mng_framp)pChunk)->iMode;
+    pFRAM->iChangedelay    = ((mng_framp)pChunk)->iChangedelay;
+    pFRAM->iDelay          = ((mng_framp)pChunk)->iDelay;
+    pFRAM->iChangetimeout  = ((mng_framp)pChunk)->iChangetimeout;
+    pFRAM->iTimeout        = ((mng_framp)pChunk)->iTimeout;
+    pFRAM->iChangeclipping = ((mng_framp)pChunk)->iChangeclipping;
+    pFRAM->iCliptype       = ((mng_framp)pChunk)->iBoundarytype;
+    pFRAM->iClipl          = ((mng_framp)pChunk)->iBoundaryl;
+    pFRAM->iClipr          = ((mng_framp)pChunk)->iBoundaryr;
+    pFRAM->iClipt          = ((mng_framp)pChunk)->iBoundaryt;
+    pFRAM->iClipb          = ((mng_framp)pChunk)->iBoundaryb;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_fram (pData, iFramemode,
+                                       iChangedelay, iDelay,
+                                       iChangetimeout, iTimeout,
+                                       iChangeclipping, iCliptype,
+                                       iClipl, iClipr,
+                                       iClipt, iClipb);
+#else
+  iRetcode = mng_process_display_fram (pData,
+                                       ((mng_framp)pChunk)->iMode,
+                                       ((mng_framp)pChunk)->iChangedelay,
+                                       ((mng_framp)pChunk)->iDelay,
+                                       ((mng_framp)pChunk)->iChangetimeout,
+                                       ((mng_framp)pChunk)->iTimeout,
+                                       ((mng_framp)pChunk)->iChangeclipping,
+                                       ((mng_framp)pChunk)->iBoundarytype,
+                                       ((mng_framp)pChunk)->iBoundaryl,
+                                       ((mng_framp)pChunk)->iBoundaryr,
+                                       ((mng_framp)pChunk)->iBoundaryt,
+                                       ((mng_framp)pChunk)->iBoundaryb);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iTempFramemode      = iFramemode;
+  pData->iTempChangedelay    = iChangedelay;
+  pData->iTempDelay          = iDelay;
+  pData->iTempChangetimeout  = iChangetimeout;
+  pData->iTempTimeout        = iTimeout;
+  pData->iTempChangeclipping = iChangeclipping;
+  pData->iTempCliptype       = iCliptype;
+  pData->iTempClipl          = iClipl;
+  pData->iTempClipr          = iClipr;
+  pData->iTempClipt          = iClipt;
+  pData->iTempClipb          = iClipb;
+#else
+  pData->iTempFramemode      = ((mng_framp)pChunk)->iMode;
+  pData->iTempChangedelay    = ((mng_framp)pChunk)->iChangedelay;
+  pData->iTempDelay          = ((mng_framp)pChunk)->iDelay;
+  pData->iTempChangetimeout  = ((mng_framp)pChunk)->iChangetimeout;
+  pData->iTempTimeout        = ((mng_framp)pChunk)->iTimeout;
+  pData->iTempChangeclipping = ((mng_framp)pChunk)->iChangeclipping;
+  pData->iTempCliptype       = ((mng_framp)pChunk)->iBoundarytype;
+  pData->iTempClipl          = ((mng_framp)pChunk)->iBoundaryl;
+  pData->iTempClipr          = ((mng_framp)pChunk)->iBoundaryr;
+  pData->iTempClipt          = ((mng_framp)pChunk)->iBoundaryt;
+  pData->iTempClipb          = ((mng_framp)pChunk)->iBoundaryb;
+#endif
+
+  iRetcode = mng_process_display_fram (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_FRAM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_fram (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_FRAM, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_fram));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_FRAM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_fram (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_framp pFRAM = (mng_ani_framp)pObject;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_FRAM, MNG_LC_START);
+#endif
+
+  if (pData->iBreakpoint)              /* previously broken ? */
+  {
+    iRetcode           = mng_process_display_fram2 (pData);
+    pData->iBreakpoint = 0;            /* not again */
+  }
+  else
+  {
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+    iRetcode = mng_process_display_fram (pData, pFRAM->iFramemode,
+                                         pFRAM->iChangedelay, pFRAM->iDelay,
+                                         pFRAM->iChangetimeout, pFRAM->iTimeout,
+                                         pFRAM->iChangeclipping, pFRAM->iCliptype,
+                                         pFRAM->iClipl, pFRAM->iClipr,
+                                         pFRAM->iClipt, pFRAM->iClipb);
+#else
+    pData->iTempFramemode      = pFRAM->iFramemode;
+    pData->iTempChangedelay    = pFRAM->iChangedelay;
+    pData->iTempDelay          = pFRAM->iDelay;
+    pData->iTempChangetimeout  = pFRAM->iChangetimeout;
+    pData->iTempTimeout        = pFRAM->iTimeout;
+    pData->iTempChangeclipping = pFRAM->iChangeclipping;
+    pData->iTempCliptype       = pFRAM->iCliptype;
+    pData->iTempClipl          = pFRAM->iClipl;
+    pData->iTempClipr          = pFRAM->iClipr;
+    pData->iTempClipt          = pFRAM->iClipt;
+    pData->iTempClipb          = pFRAM->iClipb;
+
+    iRetcode = mng_process_display_fram (pData);
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_FRAM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MOVE
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_move (mng_datap  pData,
+                                 mng_uint16 iFirstid,
+                                 mng_uint16 iLastid,
+                                 mng_uint8  iType,
+                                 mng_int32  iLocax,
+                                 mng_int32  iLocay)
+#else
+mng_retcode mng_create_ani_move (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_movep pMOVE;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_MOVE, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_move),
+                                   mng_free_obj_general,
+                                   mng_process_ani_move,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pMOVE = (mng_ani_movep)pTemp;
+#else
+    MNG_ALLOC (pData, pMOVE, sizeof (mng_ani_move));
+
+    pMOVE->sHeader.fCleanup = mng_free_ani_move;
+    pMOVE->sHeader.fProcess = mng_process_ani_move;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pMOVE);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pMOVE->iFirstid = iFirstid;
+    pMOVE->iLastid  = iLastid;
+    pMOVE->iType    = iType;
+    pMOVE->iLocax   = iLocax;
+    pMOVE->iLocay   = iLocay;
+#else
+    pMOVE->iFirstid = ((mng_movep)pChunk)->iFirstid;
+    pMOVE->iLastid  = ((mng_movep)pChunk)->iLastid;
+    pMOVE->iType    = ((mng_movep)pChunk)->iMovetype;
+    pMOVE->iLocax   = ((mng_movep)pChunk)->iMovex;
+    pMOVE->iLocay   = ((mng_movep)pChunk)->iMovey;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_move (pData, iFirstid, iLastid,
+                                       iType, iLocax, iLocay);
+#else
+  iRetcode = mng_process_display_move (pData,
+                                       ((mng_movep)pChunk)->iFirstid,
+                                       ((mng_movep)pChunk)->iLastid,
+                                       ((mng_movep)pChunk)->iMovetype,
+                                       ((mng_movep)pChunk)->iMovex,
+                                       ((mng_movep)pChunk)->iMovey);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iMOVEfromid   = iFirstid;
+  pData->iMOVEtoid     = iLastid;
+  pData->iMOVEmovetype = iType;
+  pData->iMOVEmovex    = iLocax;
+  pData->iMOVEmovey    = iLocay;
+#else
+  pData->iMOVEfromid   = ((mng_movep)pChunk)->iFirstid;
+  pData->iMOVEtoid     = ((mng_movep)pChunk)->iLastid;
+  pData->iMOVEmovetype = ((mng_movep)pChunk)->iMovetype;
+  pData->iMOVEmovex    = ((mng_movep)pChunk)->iMovex;
+  pData->iMOVEmovey    = ((mng_movep)pChunk)->iMovey;
+#endif
+
+  iRetcode = mng_process_display_move (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_MOVE, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_move (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_MOVE, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_move));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_MOVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_move (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_retcode   iRetcode;
+  mng_ani_movep pMOVE = (mng_ani_movep)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_MOVE, MNG_LC_START);
+#endif
+                                       /* re-process the MOVE chunk */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_move (pData, pMOVE->iFirstid, pMOVE->iLastid,
+                                       pMOVE->iType, pMOVE->iLocax, pMOVE->iLocay);
+#else
+  pData->iMOVEfromid   = pMOVE->iFirstid;
+  pData->iMOVEtoid     = pMOVE->iLastid;
+  pData->iMOVEmovetype = pMOVE->iType;
+  pData->iMOVEmovex    = pMOVE->iLocax;
+  pData->iMOVEmovey    = pMOVE->iLocay;
+
+  iRetcode = mng_process_display_move (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_MOVE, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_CLIP
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_clip (mng_datap  pData,
+                                 mng_uint16 iFirstid,
+                                 mng_uint16 iLastid,
+                                 mng_uint8  iType,
+                                 mng_int32  iClipl,
+                                 mng_int32  iClipr,
+                                 mng_int32  iClipt,
+                                 mng_int32  iClipb)
+#else
+mng_retcode mng_create_ani_clip (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_clipp pCLIP;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_CLIP, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_clip),
+                                   mng_free_obj_general,
+                                   mng_process_ani_clip,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pCLIP = (mng_ani_clipp)pTemp;
+#else
+    MNG_ALLOC (pData, pCLIP, sizeof (mng_ani_clip));
+
+    pCLIP->sHeader.fCleanup = mng_free_ani_clip;
+    pCLIP->sHeader.fProcess = mng_process_ani_clip;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pCLIP);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pCLIP->iFirstid = iFirstid;
+    pCLIP->iLastid  = iLastid;
+    pCLIP->iType    = iType;
+    pCLIP->iClipl   = iClipl;
+    pCLIP->iClipr   = iClipr;
+    pCLIP->iClipt   = iClipt;
+    pCLIP->iClipb   = iClipb;
+#else
+    pCLIP->iFirstid = ((mng_clipp)pChunk)->iFirstid;
+    pCLIP->iLastid  = ((mng_clipp)pChunk)->iLastid;
+    pCLIP->iType    = ((mng_clipp)pChunk)->iCliptype;
+    pCLIP->iClipl   = ((mng_clipp)pChunk)->iClipl;
+    pCLIP->iClipr   = ((mng_clipp)pChunk)->iClipr;
+    pCLIP->iClipt   = ((mng_clipp)pChunk)->iClipt;
+    pCLIP->iClipb   = ((mng_clipp)pChunk)->iClipb;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_clip (pData, iFirstid, iLastid,
+                                       iType, iClipl, iClipr,
+                                       iClipt, iClipb);
+#else
+  iRetcode = mng_process_display_clip (pData,
+                                       ((mng_clipp)pChunk)->iFirstid,
+                                       ((mng_clipp)pChunk)->iLastid,
+                                       ((mng_clipp)pChunk)->iCliptype,
+                                       ((mng_clipp)pChunk)->iClipl,
+                                       ((mng_clipp)pChunk)->iClipr,
+                                       ((mng_clipp)pChunk)->iClipt,
+                                       ((mng_clipp)pChunk)->iClipb);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iCLIPfromid   = iFirstid;
+  pData->iCLIPtoid     = iLastid;
+  pData->iCLIPcliptype = iType;
+  pData->iCLIPclipl    = iClipl;
+  pData->iCLIPclipr    = iClipr;
+  pData->iCLIPclipt    = iClipt;
+  pData->iCLIPclipb    = iClipb;
+#else
+  pData->iCLIPfromid   = ((mng_clipp)pChunk)->iFirstid;
+  pData->iCLIPtoid     = ((mng_clipp)pChunk)->iLastid;
+  pData->iCLIPcliptype = ((mng_clipp)pChunk)->iCliptype;
+  pData->iCLIPclipl    = ((mng_clipp)pChunk)->iClipl;
+  pData->iCLIPclipr    = ((mng_clipp)pChunk)->iClipr;
+  pData->iCLIPclipt    = ((mng_clipp)pChunk)->iClipt;
+  pData->iCLIPclipb    = ((mng_clipp)pChunk)->iClipb;
+#endif
+
+  iRetcode = mng_process_display_clip (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_CLIP, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_clip (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_CLIP, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_clip));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_CLIP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_clip (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_retcode   iRetcode;
+  mng_ani_clipp pCLIP = (mng_ani_clipp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_CLIP, MNG_LC_START);
+#endif
+                                       /* re-process the CLIP chunk */
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_clip (pData, pCLIP->iFirstid, pCLIP->iLastid,
+                                       pCLIP->iType, pCLIP->iClipl, pCLIP->iClipr,
+                                       pCLIP->iClipt, pCLIP->iClipb);
+#else
+  pData->iCLIPfromid   = pCLIP->iFirstid;
+  pData->iCLIPtoid     = pCLIP->iLastid;
+  pData->iCLIPcliptype = pCLIP->iType;
+  pData->iCLIPclipl    = pCLIP->iClipl;
+  pData->iCLIPclipr    = pCLIP->iClipr;
+  pData->iCLIPclipt    = pCLIP->iClipt;
+  pData->iCLIPclipb    = pCLIP->iClipb;
+
+  iRetcode = mng_process_display_clip (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_CLIP, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SHOW
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_show (mng_datap  pData,
+                                 mng_uint16 iFirstid,
+                                 mng_uint16 iLastid,
+                                 mng_uint8  iMode)
+#else
+mng_retcode mng_create_ani_show (mng_datap  pData)
+#endif
+{
+  mng_ani_showp pSHOW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SHOW, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_show),
+                                               mng_free_obj_general,
+                                               mng_process_ani_show,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pSHOW = (mng_ani_showp)pTemp;
+#else
+    MNG_ALLOC (pData, pSHOW, sizeof (mng_ani_show));
+
+    pSHOW->sHeader.fCleanup = mng_free_ani_show;
+    pSHOW->sHeader.fProcess = mng_process_ani_show;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pSHOW);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pSHOW->iFirstid = iFirstid;
+    pSHOW->iLastid  = iLastid;
+    pSHOW->iMode    = iMode;
+#else
+    pSHOW->iFirstid = pData->iSHOWfromid;
+    pSHOW->iLastid  = pData->iSHOWtoid;
+    pSHOW->iMode    = pData->iSHOWmode;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_show (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SHOW, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_show));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SHOW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_show (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_retcode   iRetcode;
+  mng_ani_showp pSHOW = (mng_ani_showp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SHOW, MNG_LC_START);
+#endif
+
+  if (pData->iBreakpoint)              /* returning from breakpoint ? */
+  {
+    iRetcode           = mng_process_display_show (pData);
+  }
+  else
+  {                                    /* "re-run" SHOW chunk */
+    pData->iSHOWmode   = pSHOW->iMode;
+    pData->iSHOWfromid = pSHOW->iFirstid;
+    pData->iSHOWtoid   = pSHOW->iLastid;
+
+    iRetcode           = mng_process_display_show (pData);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SHOW, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_TERM
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_term (mng_datap  pData,
+                                 mng_uint8  iTermaction,
+                                 mng_uint8  iIteraction,
+                                 mng_uint32 iDelay,
+                                 mng_uint32 iItermax)
+#else
+mng_retcode mng_create_ani_term (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_termp pTERM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_TERM, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_term),
+                                               mng_free_obj_general,
+                                               mng_process_ani_term,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pTERM = (mng_ani_termp)pTemp;
+#else
+    MNG_ALLOC (pData, pTERM, sizeof (mng_ani_term));
+
+    pTERM->sHeader.fCleanup = mng_free_ani_term;
+    pTERM->sHeader.fProcess = mng_process_ani_term;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pTERM);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pTERM->iTermaction = iTermaction;
+    pTERM->iIteraction = iIteraction;
+    pTERM->iDelay      = iDelay;
+    pTERM->iItermax    = iItermax;
+#else
+    pTERM->iTermaction = ((mng_termp)pChunk)->iTermaction;
+    pTERM->iIteraction = ((mng_termp)pChunk)->iIteraction;
+    pTERM->iDelay      = ((mng_termp)pChunk)->iDelay;
+    pTERM->iItermax    = ((mng_termp)pChunk)->iItermax;
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_term (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_TERM, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_term));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_term (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_TERM, MNG_LC_START);
+#endif
+
+  /* dummy: no action required! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_TERM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_create_ani_save (mng_datap pData)
+{
+  mng_ani_savep pSAVE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SAVE, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr       pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_save),
+                                               mng_free_obj_general,
+                                               mng_process_ani_save,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pSAVE = (mng_ani_savep)pTemp;
+#else
+    MNG_ALLOC (pData, pSAVE, sizeof (mng_ani_save));
+
+    pSAVE->sHeader.fCleanup = mng_free_ani_save;
+    pSAVE->sHeader.fProcess = mng_process_ani_save;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pSAVE);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_save (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SAVE, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_save));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_save (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SAVE, MNG_LC_START);
+#endif
+
+  iRetcode = mng_process_display_save (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SAVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_SEEK
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_seek (mng_datap  pData,
+                                 mng_uint32 iSegmentnamesize,
+                                 mng_pchar  zSegmentname)
+#else
+mng_retcode mng_create_ani_seek (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_seekp pSEEK;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SEEK, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr       pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_seek),
+                                               mng_free_ani_seek,
+                                               mng_process_ani_seek,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pSEEK = (mng_ani_seekp)pTemp;
+#else
+    MNG_ALLOC (pData, pSEEK, sizeof (mng_ani_seek));
+
+    pSEEK->sHeader.fCleanup = mng_free_ani_seek;
+    pSEEK->sHeader.fProcess = mng_process_ani_seek;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pSEEK);
+
+    pData->pLastseek = (mng_objectp)pSEEK;
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pSEEK->iSegmentnamesize = iSegmentnamesize;
+    if (iSegmentnamesize)
+    {
+      MNG_ALLOC (pData, pSEEK->zSegmentname, iSegmentnamesize + 1);
+      MNG_COPY (pSEEK->zSegmentname, zSegmentname, iSegmentnamesize);
+    }
+#else
+    pSEEK->iSegmentnamesize = ((mng_seekp)pChunk)->iNamesize;
+    if (pSEEK->iSegmentnamesize)
+    {
+      MNG_ALLOC (pData, pSEEK->zSegmentname, pSEEK->iSegmentnamesize + 1);
+      MNG_COPY (pSEEK->zSegmentname, ((mng_seekp)pChunk)->zName, pSEEK->iSegmentnamesize);
+    }
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_ani_seek (mng_datap   pData,
+                               mng_objectp pObject)
+{
+  mng_ani_seekp pSEEK = (mng_ani_seekp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SEEK, MNG_LC_START);
+#endif
+
+  if (pSEEK->iSegmentnamesize)
+    MNG_FREEX (pData, pSEEK->zSegmentname, pSEEK->iSegmentnamesize + 1);
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_seek));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_SEEK, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_seek (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_seekp pSEEK = (mng_ani_seekp)pObject;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SEEK, MNG_LC_START);
+#endif
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+  if (!pData->bStopafterseek)          /* can we really process this one ? */
+#endif  
+  {
+    pData->pLastseek = pObject;
+
+    if (pData->fProcessseek)           /* inform the app ? */
+    {
+      mng_bool  bOke;
+      mng_pchar zName;
+
+      MNG_ALLOC (pData, zName, pSEEK->iSegmentnamesize + 1);
+
+      if (pSEEK->iSegmentnamesize)
+        MNG_COPY (zName, pSEEK->zSegmentname, pSEEK->iSegmentnamesize);
+
+      bOke = pData->fProcessseek ((mng_handle)pData, zName);
+
+      MNG_FREEX (pData, zName, pSEEK->iSegmentnamesize + 1);
+
+      if (!bOke)
+        MNG_ERROR (pData, MNG_APPMISCERROR);
+    }
+  }
+
+  iRetcode = mng_process_display_seek (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_SEEK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_dhdr (mng_datap  pData,
+                                 mng_uint16 iObjectid,
+                                 mng_uint8  iImagetype,
+                                 mng_uint8  iDeltatype,
+                                 mng_uint32 iBlockwidth,
+                                 mng_uint32 iBlockheight,
+                                 mng_uint32 iBlockx,
+                                 mng_uint32 iBlocky)
+#else
+mng_retcode mng_create_ani_dhdr (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_dhdrp pDHDR;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_DHDR, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_dhdr),
+                                   mng_free_obj_general,
+                                   mng_process_ani_dhdr,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pDHDR = (mng_ani_dhdrp)pTemp;
+#else
+    MNG_ALLOC (pData, pDHDR, sizeof (mng_ani_dhdr));
+
+    pDHDR->sHeader.fCleanup = mng_free_ani_dhdr;
+    pDHDR->sHeader.fProcess = mng_process_ani_dhdr;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pDHDR);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pDHDR->iObjectid    = iObjectid;
+    pDHDR->iImagetype   = iImagetype;
+    pDHDR->iDeltatype   = iDeltatype;
+    pDHDR->iBlockwidth  = iBlockwidth;
+    pDHDR->iBlockheight = iBlockheight;
+    pDHDR->iBlockx      = iBlockx;
+    pDHDR->iBlocky      = iBlocky;
+#else
+    pDHDR->iObjectid    = ((mng_dhdrp)pChunk)->iObjectid;
+    pDHDR->iImagetype   = ((mng_dhdrp)pChunk)->iImagetype;
+    pDHDR->iDeltatype   = ((mng_dhdrp)pChunk)->iDeltatype;
+    pDHDR->iBlockwidth  = ((mng_dhdrp)pChunk)->iBlockwidth;
+    pDHDR->iBlockheight = ((mng_dhdrp)pChunk)->iBlockheight;
+    pDHDR->iBlockx      = ((mng_dhdrp)pChunk)->iBlockx;
+    pDHDR->iBlocky      = ((mng_dhdrp)pChunk)->iBlocky;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_dhdr (pData, iObjectid,
+                                       iImagetype, iDeltatype,
+                                       iBlockwidth, iBlockheight,
+                                       iBlockx, iBlocky);
+#else
+  iRetcode = mng_process_display_dhdr (pData,
+                                       ((mng_dhdrp)pChunk)->iObjectid,
+                                       ((mng_dhdrp)pChunk)->iImagetype,
+                                       ((mng_dhdrp)pChunk)->iDeltatype,
+                                       ((mng_dhdrp)pChunk)->iBlockwidth,
+                                       ((mng_dhdrp)pChunk)->iBlockheight,
+                                       ((mng_dhdrp)pChunk)->iBlockx,
+                                       ((mng_dhdrp)pChunk)->iBlocky);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iDHDRobjectid    = iObjectid;
+  pData->iDHDRimagetype   = iImagetype;
+  pData->iDHDRdeltatype   = iDeltatype;
+  pData->iDHDRblockwidth  = iBlockwidth;
+  pData->iDHDRblockheight = iBlockheight;
+  pData->iDHDRblockx      = iBlockx;
+  pData->iDHDRblocky      = iBlocky;
+#else
+  pData->iDHDRobjectid    = ((mng_dhdrp)pChunk)->iObjectid;
+  pData->iDHDRimagetype   = ((mng_dhdrp)pChunk)->iImagetype;
+  pData->iDHDRdeltatype   = ((mng_dhdrp)pChunk)->iDeltatype;
+  pData->iDHDRblockwidth  = ((mng_dhdrp)pChunk)->iBlockwidth;
+  pData->iDHDRblockheight = ((mng_dhdrp)pChunk)->iBlockheight;
+  pData->iDHDRblockx      = ((mng_dhdrp)pChunk)->iBlockx;
+  pData->iDHDRblocky      = ((mng_dhdrp)pChunk)->iBlocky;
+#endif
+
+  iRetcode = mng_process_display_dhdr (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_DHDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_dhdr (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_DHDR, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_dhdr));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_DHDR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_dhdr (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_dhdrp pDHDR = (mng_ani_dhdrp)pObject;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_DHDR, MNG_LC_START);
+#endif
+
+  pData->bHasDHDR = MNG_TRUE;          /* let everyone know we're inside a DHDR */
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_dhdr (pData, pDHDR->iObjectid,
+                                       pDHDR->iImagetype, pDHDR->iDeltatype,
+                                       pDHDR->iBlockwidth, pDHDR->iBlockheight,
+                                       pDHDR->iBlockx, pDHDR->iBlocky);
+#else
+  pData->iDHDRobjectid    = pDHDR->iObjectid;
+  pData->iDHDRimagetype   = pDHDR->iImagetype;
+  pData->iDHDRdeltatype   = pDHDR->iDeltatype;
+  pData->iDHDRblockwidth  = pDHDR->iBlockwidth;
+  pData->iDHDRblockheight = pDHDR->iBlockheight;
+  pData->iDHDRblockx      = pDHDR->iBlockx;
+  pData->iDHDRblocky      = pDHDR->iBlocky;
+
+  iRetcode = mng_process_display_dhdr (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_DHDR, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_prom (mng_datap pData,
+                                 mng_uint8 iBitdepth,
+                                 mng_uint8 iColortype,
+                                 mng_uint8 iFilltype)
+#else
+mng_retcode mng_create_ani_prom (mng_datap pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_promp pPROM=NULL;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PROM, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_prom),
+                                   mng_free_obj_general,
+                                   mng_process_ani_prom,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pPROM = (mng_ani_promp)pTemp;
+#else
+    MNG_ALLOC (pData, pPROM, sizeof (mng_ani_prom));
+
+    pPROM->sHeader.fCleanup = mng_free_ani_prom;
+    pPROM->sHeader.fProcess = mng_process_ani_prom;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pPROM);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pPROM->iBitdepth  = iBitdepth;
+    pPROM->iColortype = iColortype;
+    pPROM->iFilltype  = iFilltype;
+#else
+    pPROM->iBitdepth  = ((mng_promp)pChunk)->iSampledepth;
+    pPROM->iColortype = ((mng_promp)pChunk)->iColortype;
+    pPROM->iFilltype  = ((mng_promp)pChunk)->iFilltype;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_prom (pData, iBitdepth,
+                                       iColortype, iFilltype);
+#else
+  iRetcode = mng_process_display_prom (pData,
+                                       ((mng_promp)pChunk)->iSampledepth,
+                                       ((mng_promp)pChunk)->iColortype,
+                                       ((mng_promp)pChunk)->iFilltype);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iPROMbitdepth  = iBitdepth;
+  pData->iPROMcolortype = iColortype;
+  pData->iPROMfilltype  = iFilltype;
+#else
+  pData->iPROMbitdepth  = ((mng_promp)pChunk)->iSampledepth;
+  pData->iPROMcolortype = ((mng_promp)pChunk)->iColortype;
+  pData->iPROMfilltype  = ((mng_promp)pChunk)->iFilltype;
+#endif
+
+  iRetcode = mng_process_display_prom (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PROM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_prom (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PROM, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_prom));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PROM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_prom (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_promp pPROM = (mng_ani_promp)pObject;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PROM, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_prom (pData, pPROM->iBitdepth,
+                                       pPROM->iColortype, pPROM->iFilltype);
+#else
+  pData->iPROMbitdepth  = pPROM->iBitdepth;
+  pData->iPROMcolortype = pPROM->iColortype;
+  pData->iPROMfilltype  = pPROM->iFilltype;
+
+  iRetcode = mng_process_display_prom (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PROM, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_create_ani_ipng (mng_datap pData)
+{
+  mng_ani_ipngp pIPNG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_IPNG, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_ipng),
+                                               mng_free_obj_general,
+                                               mng_process_ani_ipng,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pIPNG = (mng_ani_ipngp)pTemp;
+#else
+    MNG_ALLOC (pData, pIPNG, sizeof (mng_ani_ipng));
+
+    pIPNG->sHeader.fCleanup = mng_free_ani_ipng;
+    pIPNG->sHeader.fProcess = mng_process_ani_ipng;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pIPNG);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_ipng (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_IPNG, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_ipng));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_ipng (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_IPNG, MNG_LC_START);
+#endif
+
+  iRetcode = mng_process_display_ipng (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_IPNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_create_ani_ijng (mng_datap pData)
+{
+  mng_ani_ijngp pIJNG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_IJNG, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_ani_ijng),
+                                               mng_free_obj_general,
+                                               mng_process_ani_ijng,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pIJNG = (mng_ani_ijngp)pTemp;
+#else
+    MNG_ALLOC (pData, pIJNG, sizeof (mng_ani_ijng));
+
+    pIJNG->sHeader.fCleanup = mng_free_ani_ijng;
+    pIJNG->sHeader.fProcess = mng_process_ani_ijng;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pIJNG);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_ijng (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_IJNG, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_ijng));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_ijng (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_IJNG, MNG_LC_START);
+#endif
+
+  iRetcode = mng_process_display_ijng (pData);
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_IJNG, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_create_ani_pplt (mng_datap      pData,
+                                 mng_uint8      iType,
+                                 mng_uint32     iCount,
+                                 mng_palette8ep paIndexentries,
+                                 mng_uint8p     paAlphaentries,
+                                 mng_uint8p     paUsedentries)
+{
+  mng_ani_ppltp pPPLT;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PPLT, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_pplt),
+                                   mng_free_obj_general,
+                                   mng_process_ani_pplt,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pPPLT = (mng_ani_ppltp)pTemp;
+#else
+    MNG_ALLOC (pData, pPPLT, sizeof (mng_ani_pplt));
+
+    pPPLT->sHeader.fCleanup = mng_free_ani_pplt;
+    pPPLT->sHeader.fProcess = mng_process_ani_pplt;
+#endif
+
+    pPPLT->iType            = iType;
+    pPPLT->iCount           = iCount;
+
+    MNG_COPY (pPPLT->aIndexentries, paIndexentries, sizeof (pPPLT->aIndexentries));
+    MNG_COPY (pPPLT->aAlphaentries, paAlphaentries, sizeof (pPPLT->aAlphaentries));
+    MNG_COPY (pPPLT->aUsedentries,  paUsedentries,  sizeof (pPPLT->aUsedentries ));
+
+    mng_add_ani_object (pData, (mng_object_headerp)pPPLT);
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_pplt (pData, iType, iCount,
+                                       paIndexentries, paAlphaentries, paUsedentries);
+#else
+  pData->iPPLTtype          = iType;
+  pData->iPPLTcount         = iCount;
+  pData->paPPLTindexentries = paIndexentries;
+  pData->paPPLTalphaentries = paAlphaentries;
+  pData->paPPLTusedentries  = paUsedentries;
+
+  iRetcode = mng_process_display_pplt (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PPLT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_pplt (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PPLT, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_pplt));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PPLT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_pplt (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_ppltp pPPLT = (mng_ani_ppltp)pObject;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PPLT, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_pplt (pData, pPPLT->iType, pPPLT->iCount,
+                                       pPPLT->aIndexentries, pPPLT->aAlphaentries,
+                                       pPPLT->aUsedentries);
+#else
+  pData->iPPLTtype          = pPPLT->iType;
+  pData->iPPLTcount         = pPPLT->iCount;
+  pData->paPPLTindexentries = &pPPLT->aIndexentries;
+  pData->paPPLTalphaentries = &pPPLT->aAlphaentries;
+  pData->paPPLTusedentries  = &pPPLT->aUsedentries;
+
+  iRetcode = mng_process_display_pplt (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PPLT, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_magn (mng_datap  pData,
+                                 mng_uint16 iFirstid,
+                                 mng_uint16 iLastid,
+                                 mng_uint8  iMethodX,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iMY,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint16 iMT,
+                                 mng_uint16 iMB,
+                                 mng_uint8  iMethodY)
+#else
+mng_retcode mng_create_ani_magn (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_magnp pMAGN=NULL;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_MAGN, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_magn),
+                                   mng_free_obj_general,
+                                   mng_process_ani_magn,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pMAGN = (mng_ani_magnp)pTemp;
+#else
+    MNG_ALLOC (pData, pMAGN, sizeof (mng_ani_magn));
+
+    pMAGN->sHeader.fCleanup = mng_free_ani_magn;
+    pMAGN->sHeader.fProcess = mng_process_ani_magn;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pMAGN);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pMAGN->iFirstid = iFirstid;
+    pMAGN->iLastid  = iLastid;
+    pMAGN->iMethodX = iMethodX;
+    pMAGN->iMX      = iMX;
+    pMAGN->iMY      = iMY;
+    pMAGN->iML      = iML;
+    pMAGN->iMR      = iMR;
+    pMAGN->iMT      = iMT;
+    pMAGN->iMB      = iMB;
+    pMAGN->iMethodY = iMethodY;
+#else
+    pMAGN->iFirstid = ((mng_magnp)pChunk)->iFirstid;
+    pMAGN->iLastid  = ((mng_magnp)pChunk)->iLastid;
+    pMAGN->iMethodX = ((mng_magnp)pChunk)->iMethodX;
+    pMAGN->iMX      = ((mng_magnp)pChunk)->iMX;
+    pMAGN->iMY      = ((mng_magnp)pChunk)->iMY;
+    pMAGN->iML      = ((mng_magnp)pChunk)->iML;
+    pMAGN->iMR      = ((mng_magnp)pChunk)->iMR;
+    pMAGN->iMT      = ((mng_magnp)pChunk)->iMT;
+    pMAGN->iMB      = ((mng_magnp)pChunk)->iMB;
+    pMAGN->iMethodY = ((mng_magnp)pChunk)->iMethodY;
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_magn (pData, pMAGN->iFirstid, pMAGN->iLastid,
+                                       pMAGN->iMethodX, pMAGN->iMX, pMAGN->iMY,
+                                       pMAGN->iML, pMAGN->iMR, pMAGN->iMT,
+                                       pMAGN->iMB, pMAGN->iMethodY);
+#else
+  iRetcode = mng_process_display_magn (pData,
+                                       ((mng_magnp)pChunk)->iFirstid,
+                                       ((mng_magnp)pChunk)->iLastid,
+                                       ((mng_magnp)pChunk)->iMethodX,
+                                       ((mng_magnp)pChunk)->iMX,
+                                       ((mng_magnp)pChunk)->iMY,
+                                       ((mng_magnp)pChunk)->iML,
+                                       ((mng_magnp)pChunk)->iMR,
+                                       ((mng_magnp)pChunk)->iMT,
+                                       ((mng_magnp)pChunk)->iMB,
+                                       ((mng_magnp)pChunk)->iMethodY);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iMAGNfirstid = iFirstid;
+  pData->iMAGNlastid  = iLastid;
+  pData->iMAGNmethodX = iMethodX;
+  pData->iMAGNmX      = iMX;
+  pData->iMAGNmY      = iMY;
+  pData->iMAGNmL      = iML;
+  pData->iMAGNmR      = iMR;
+  pData->iMAGNmT      = iMT;
+  pData->iMAGNmB      = iMB;
+  pData->iMAGNmethodY = iMethodY;
+#else
+  pData->iMAGNfirstid = ((mng_magnp)pChunk)->iFirstid;
+  pData->iMAGNlastid  = ((mng_magnp)pChunk)->iLastid;
+  pData->iMAGNmethodX = ((mng_magnp)pChunk)->iMethodX;
+  pData->iMAGNmX      = ((mng_magnp)pChunk)->iMX;
+  pData->iMAGNmY      = ((mng_magnp)pChunk)->iMY;
+  pData->iMAGNmL      = ((mng_magnp)pChunk)->iML;
+  pData->iMAGNmR      = ((mng_magnp)pChunk)->iMR;
+  pData->iMAGNmT      = ((mng_magnp)pChunk)->iMT;
+  pData->iMAGNmB      = ((mng_magnp)pChunk)->iMB;
+  pData->iMAGNmethodY = ((mng_magnp)pChunk)->iMethodY;
+#endif
+
+  iRetcode = mng_process_display_magn (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_MAGN, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+mng_retcode mng_free_ani_magn (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_MAGN, MNG_LC_START);
+#endif
+
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_magn));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_MAGN, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_magn (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_magnp pMAGN = (mng_ani_magnp)pObject;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_MAGN, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_magn (pData, pMAGN->iFirstid, pMAGN->iLastid,
+                                       pMAGN->iMethodX, pMAGN->iMX, pMAGN->iMY,
+                                       pMAGN->iML, pMAGN->iMR, pMAGN->iMT,
+                                       pMAGN->iMB, pMAGN->iMethodY);
+#else
+  pData->iMAGNfirstid = pMAGN->iFirstid;
+  pData->iMAGNlastid  = pMAGN->iLastid;
+  pData->iMAGNmethodX = pMAGN->iMethodX;
+  pData->iMAGNmX      = pMAGN->iMX;
+  pData->iMAGNmY      = pMAGN->iMY;
+  pData->iMAGNmL      = pMAGN->iML;
+  pData->iMAGNmR      = pMAGN->iMR;
+  pData->iMAGNmT      = pMAGN->iMT;
+  pData->iMAGNmB      = pMAGN->iMB;
+  pData->iMAGNmethodY = pMAGN->iMethodY;
+
+  iRetcode = mng_process_display_magn (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_MAGN, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_past (mng_datap  pData,
+                                 mng_uint16 iTargetid,
+                                 mng_uint8  iTargettype,
+                                 mng_int32  iTargetx,
+                                 mng_int32  iTargety,
+                                 mng_uint32 iCount,
+                                 mng_ptr    pSources)
+#else
+mng_retcode mng_create_ani_past (mng_datap  pData,
+                                 mng_chunkp pChunk)
+#endif
+{
+  mng_ani_pastp pPAST;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PAST, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_past),
+                                   mng_free_ani_past,
+                                   mng_process_ani_past,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pPAST = (mng_ani_pastp)pTemp;
+#else
+    MNG_ALLOC (pData, pPAST, sizeof (mng_ani_past));
+
+    pPAST->sHeader.fCleanup = mng_free_ani_past;
+    pPAST->sHeader.fProcess = mng_process_ani_past;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pPAST);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pPAST->iTargetid   = iTargetid;
+    pPAST->iTargettype = iTargettype;
+    pPAST->iTargetx    = iTargetx;
+    pPAST->iTargety    = iTargety;
+    pPAST->iCount      = iCount;
+
+    if (iCount)
+    {
+      MNG_ALLOC (pData, pPAST->pSources, (iCount * sizeof (mng_past_source)));
+      MNG_COPY (pPAST->pSources, pSources, (iCount * sizeof (mng_past_source)));
+    }
+#else
+    pPAST->iTargetid   = ((mng_pastp)pChunk)->iDestid;
+    pPAST->iTargettype = ((mng_pastp)pChunk)->iTargettype;
+    pPAST->iTargetx    = ((mng_pastp)pChunk)->iTargetx;
+    pPAST->iTargety    = ((mng_pastp)pChunk)->iTargety;
+    pPAST->iCount      = ((mng_pastp)pChunk)->iCount;
+
+    if (pPAST->iCount)
+    {
+      mng_size_t iSize = (mng_size_t)(pPAST->iCount * sizeof (mng_past_source));
+      MNG_ALLOC (pData, pPAST->pSources, iSize);
+      MNG_COPY (pPAST->pSources, ((mng_pastp)pChunk)->pSources, iSize);
+    }
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_past (pData, iTargetid, iTargettype,
+                                       iTargetx, iTargety,
+                                       iCount, pSources);
+#else
+  iRetcode = mng_process_display_past (pData,
+                                       ((mng_pastp)pChunk)->iDestid,
+                                       ((mng_pastp)pChunk)->iTargettype,
+                                       ((mng_pastp)pChunk)->iTargetx,
+                                       ((mng_pastp)pChunk)->iTargety,
+                                       ((mng_pastp)pChunk)->iCount,
+                                       ((mng_pastp)pChunk)->pSources);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iPASTtargetid   = iTargetid;
+  pData->iPASTtargettype = iTargettype;
+  pData->iPASTtargetx    = iTargetx;
+  pData->iPASTtargety    = iTargety;
+  pData->iPASTcount      = iCount;
+  pData->pPASTsources    = pSources;
+#else
+  pData->iPASTtargetid   = ((mng_pastp)pChunk)->iDestid;
+  pData->iPASTtargettype = ((mng_pastp)pChunk)->iTargettype;
+  pData->iPASTtargetx    = ((mng_pastp)pChunk)->iTargetx;
+  pData->iPASTtargety    = ((mng_pastp)pChunk)->iTargety;
+  pData->iPASTcount      = ((mng_pastp)pChunk)->iCount;
+  pData->pPASTsources    = ((mng_pastp)pChunk)->pSources;
+#endif
+
+  iRetcode = mng_process_display_past (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_PAST, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_free_ani_past (mng_datap   pData,
+                               mng_objectp pObject)
+{
+  mng_ani_pastp pPAST = (mng_ani_pastp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PAST, MNG_LC_START);
+#endif
+
+  if (pPAST->iCount)
+    MNG_FREEX (pData, pPAST->pSources, (pPAST->iCount * sizeof (mng_past_source)));
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_past));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_PAST, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_process_ani_past (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_pastp pPAST = (mng_ani_pastp)pObject;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PAST, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_past (pData, pPAST->iTargetid, pPAST->iTargettype,
+                                       pPAST->iTargetx, pPAST->iTargety,
+                                       pPAST->iCount, pPAST->pSources);
+#else
+  pData->iPASTtargetid   = pPAST->iTargetid;
+  pData->iPASTtargettype = pPAST->iTargettype;
+  pData->iPASTtargetx    = pPAST->iTargetx;
+  pData->iPASTtargety    = pPAST->iTargety;
+  pData->iPASTcount      = pPAST->iCount;
+  pData->pPASTsources    = pPAST->pSources;
+
+  iRetcode = mng_process_display_past (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_PAST, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ani_disc (mng_datap   pData,
+                                 mng_uint32  iCount,
+                                 mng_uint16p pIds)
+#else
+mng_retcode mng_create_ani_disc (mng_datap   pData,
+                                 mng_chunkp  pChunk)
+#endif
+{
+  mng_ani_discp pDISC;
+  mng_retcode   iRetcode;      
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_DISC, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr pTemp;
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_disc),
+                                   mng_free_ani_disc,
+                                   mng_process_ani_disc,
+                                   &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pDISC = (mng_ani_discp)pTemp;
+#else
+    MNG_ALLOC (pData, pDISC, sizeof (mng_ani_disc));
+
+    pDISC->sHeader.fCleanup = mng_free_ani_disc;
+    pDISC->sHeader.fProcess = mng_process_ani_disc;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pDISC);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pDISC->iCount = iCount;
+
+    if (iCount)
+    {
+      MNG_ALLOC (pData, pDISC->pIds, (iCount << 1));
+      MNG_COPY (pDISC->pIds, pIds, (iCount << 1));
+    }
+#else
+    pDISC->iCount = ((mng_discp)pChunk)->iCount;
+
+    if (pDISC->iCount)
+    {
+      mng_size_t iSize = (mng_size_t)(pDISC->iCount << 1);
+      MNG_ALLOC (pData, pDISC->pIds, iSize);
+      MNG_COPY (pDISC->pIds, ((mng_discp)pChunk)->pObjectids, iSize);
+    }
+#endif
+  }
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  iRetcode = mng_process_display_disc (pData, iCount, pIds);
+#else
+  iRetcode = mng_process_display_disc (pData,
+                                       ((mng_discp)pChunk)->iCount,
+                                       ((mng_discp)pChunk)->pObjectids);
+#endif
+#else
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pData->iDISCcount = iCount;
+  pData->pDISCids   = pIds;
+#else
+  pData->iDISCcount = ((mng_discp)pChunk)->iCount;
+  pData->pDISCids   = ((mng_discp)pChunk)->pObjectids;
+#endif
+
+  iRetcode = mng_process_display_disc (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANI_DISC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_ani_disc (mng_datap   pData,
+                               mng_objectp pObject)
+{
+  mng_ani_discp pDISC = (mng_ani_discp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_DISC, MNG_LC_START);
+#endif
+
+  if (pDISC->iCount)
+    MNG_FREEX (pData, pDISC->pIds, (pDISC->iCount << 1));
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pObject, sizeof (mng_ani_disc));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANI_DISC, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_disc (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  mng_ani_discp pDISC = (mng_ani_discp)pObject;
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_DISC, MNG_LC_START);
+#endif
+
+#ifndef MNG_OPTIMIZE_DISPLAYCALLS
+  iRetcode = mng_process_display_disc (pData, pDISC->iCount, pDISC->pIds);
+#else
+  pData->iDISCcount = pDISC->iCount;
+  pData->pDISCids   = pDISC->pIds;
+
+  iRetcode = mng_process_display_disc (pData);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANI_DISC, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+#endif
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_event (mng_datap  pData,
+                              mng_uint8  iEventtype,
+                              mng_uint8  iMasktype,
+                              mng_int32  iLeft,
+                              mng_int32  iRight,
+                              mng_int32  iTop,
+                              mng_int32  iBottom,
+                              mng_uint16 iObjectid,
+                              mng_uint8  iIndex,
+                              mng_uint32 iSegmentnamesize,
+                              mng_pchar  zSegmentname)
+#else
+mng_retcode mng_create_event (mng_datap  pData,
+                              mng_ptr    pEntry)
+#endif
+{
+  mng_eventp pEvent;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_EVENT, MNG_LC_START);
+#endif
+
+  if (pData->bCacheplayback)           /* caching playback info ? */
+  {
+    mng_object_headerp pLast;
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    mng_ptr     pTemp;
+    mng_retcode iRetcode = create_obj_general (pData, sizeof (mng_event),
+                                               mng_free_event,
+                                               mng_process_event,
+                                               &pTemp);
+    if (iRetcode)
+      return iRetcode;
+    pEvent = (mng_eventp)pTemp;
+#else
+    MNG_ALLOC (pData, pEvent, sizeof (mng_event));
+
+    pEvent->sHeader.fCleanup = mng_free_event;
+    pEvent->sHeader.fProcess = mng_process_event;
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    pEvent->iEventtype       = iEventtype;
+    pEvent->iMasktype        = iMasktype;
+    pEvent->iLeft            = iLeft;
+    pEvent->iRight           = iRight;
+    pEvent->iTop             = iTop;
+    pEvent->iBottom          = iBottom;
+    pEvent->iObjectid        = iObjectid;
+    pEvent->iIndex           = iIndex;
+    pEvent->iSegmentnamesize = iSegmentnamesize;
+
+    if (iSegmentnamesize)
+    {
+      MNG_ALLOC (pData, pEvent->zSegmentname, iSegmentnamesize+1);
+      MNG_COPY (pEvent->zSegmentname, zSegmentname, iSegmentnamesize);
+    }
+#else
+    pEvent->iEventtype       = ((mng_evnt_entryp)pEntry)->iEventtype;
+    pEvent->iMasktype        = ((mng_evnt_entryp)pEntry)->iMasktype;
+    pEvent->iLeft            = ((mng_evnt_entryp)pEntry)->iLeft;
+    pEvent->iRight           = ((mng_evnt_entryp)pEntry)->iRight;
+    pEvent->iTop             = ((mng_evnt_entryp)pEntry)->iTop;
+    pEvent->iBottom          = ((mng_evnt_entryp)pEntry)->iBottom;
+    pEvent->iObjectid        = ((mng_evnt_entryp)pEntry)->iObjectid;
+    pEvent->iIndex           = ((mng_evnt_entryp)pEntry)->iIndex;
+    pEvent->iSegmentnamesize = ((mng_evnt_entryp)pEntry)->iSegmentnamesize;
+
+    if (pEvent->iSegmentnamesize)
+    {
+      MNG_ALLOC (pData, pEvent->zSegmentname, pEvent->iSegmentnamesize+1);
+      MNG_COPY (pEvent->zSegmentname, ((mng_evnt_entryp)pEntry)->zSegmentname, pEvent->iSegmentnamesize);
+    }
+#endif
+                                       /* fixup the double-linked list */
+    pLast                    = (mng_object_headerp)pData->pLastevent;
+
+    if (pLast)                         /* link it as last in the chain */
+    {
+      pEvent->sHeader.pPrev  = pLast;
+      pLast->pNext           = pEvent;
+    }
+    else
+    {
+      pData->pFirstevent     = pEvent;
+    }
+
+    pData->pLastevent        = pEvent;
+    pData->bDynamic          = MNG_TRUE;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_EVENT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_event (mng_datap   pData,
+                            mng_objectp pObject)
+{
+  mng_eventp pEvent = (mng_eventp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_EVENT, MNG_LC_START);
+#endif
+
+  if (pEvent->iSegmentnamesize)
+    MNG_FREEX (pData, pEvent->zSegmentname, pEvent->iSegmentnamesize + 1);
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pEvent, sizeof (mng_event));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_EVENT, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_event (mng_datap   pData,
+                               mng_objectp pObject)
+{
+#ifndef MNG_SKIPCHUNK_SEEK
+  mng_eventp         pEvent  = (mng_eventp)pObject;
+  mng_object_headerp pAni;
+  mng_bool           bFound = MNG_FALSE;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_EVENT, MNG_LC_START);
+#endif
+
+#ifndef MNG_SKIPCHUNK_SEEK
+  if (!pEvent->pSEEK)                  /* need to find SEEK first ? */
+  {
+    pAni = (mng_object_headerp)pData->pFirstaniobj;
+
+    while ((pAni) && (!bFound))
+    {
+      if ((pAni->fCleanup == mng_free_ani_seek) &&
+          (strcmp(pEvent->zSegmentname, ((mng_ani_seekp)pAni)->zSegmentname) == 0))
+        bFound = MNG_TRUE;
+      else
+        pAni = (mng_object_headerp)pAni->pNext;
+    }
+
+    if (pAni)
+      pEvent->pSEEK = (mng_ani_seekp)pAni;
+  }
+
+  if (pEvent->pSEEK)                   /* anything to do ? */
+  {
+    pEvent->iLastx = pData->iEventx;
+    pEvent->iLasty = pData->iEventy;
+                                       /* let's start from this SEEK then */
+    pData->pCurraniobj   = (mng_objectp)pEvent->pSEEK;
+    pData->bRunningevent = MNG_TRUE;
+                                       /* wake-up the app ! */
+    if (!pData->fSettimer ((mng_handle)pData, 5))
+      MNG_ERROR (pData, MNG_APPTIMERERROR);
+
+  }
+  else
+    MNG_ERROR (pData, MNG_SEEKNOTFOUND);
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_EVENT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_SUPPORT_DYNAMICMNG */
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_mpng_obj (mng_datap  pData,
+                                 mng_uint32 iFramewidth,
+                                 mng_uint32 iFrameheight,
+                                 mng_uint16 iNumplays,
+                                 mng_uint16 iTickspersec,
+                                 mng_uint32 iFramessize,
+                                 mng_ptr    pFrames)
+#else
+mng_retcode mng_create_mpng_obj (mng_datap  pData,
+                                 mng_ptr    pEntry)
+#endif
+{
+  mng_mpng_objp pMPNG;
+  mng_ptr       pTemp;
+  mng_retcode   iRetcode;
+  mng_uint8p    pFrame;
+  mng_int32     iCnt, iMax;
+  mng_uint32    iX, iY, iWidth, iHeight;
+  mng_int32     iXoffset, iYoffset;
+  mng_uint16    iTicks;
+  mng_uint16    iDelay;
+  mng_bool      bNewframe;
+  mng_ani_loopp pLOOP;
+  mng_ani_endlp pENDL;
+  mng_ani_framp pFRAM;
+  mng_ani_movep pMOVE;
+  mng_ani_clipp pCLIP;
+  mng_ani_showp pSHOW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_MPNG_OBJ, MNG_LC_START);
+#endif
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+  iRetcode = create_obj_general (pData, sizeof (mng_mpng_obj), mng_free_mpng_obj,
+                                 mng_process_mpng_obj, &pTemp);
+  if (iRetcode)
+    return iRetcode;
+  pMPNG = (mng_mpng_objp)pTemp;
+#else
+  MNG_ALLOC (pData, pMPNG, sizeof (mng_mpng_obj));
+
+  pMPNG->sHeader.fCleanup = mng_free_mpng_obj;
+  pMPNG->sHeader.fProcess = mng_process_mpng_obj;
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pMPNG->iFramewidth  = iFramewidth;
+  pMPNG->iFrameheight = iFrameheight;
+  pMPNG->iNumplays    = iNumplays;
+  pMPNG->iTickspersec = iTickspersec;
+  pMPNG->iFramessize  = iFramessize;
+
+  if (iFramessize)
+  {
+    MNG_ALLOC (pData, pMPNG->pFrames, iFramessize);
+    MNG_COPY (pMPNG->pFrames, pFrames, iFramessize);
+  }
+#else
+  pMPNG->iFramewidth  = ((mng_mpngp)pEntry)->iFramewidth;
+  pMPNG->iFrameheight = ((mng_mpngp)pEntry)->iFrameheight;
+  pMPNG->iNumplays    = ((mng_mpngp)pEntry)->iNumplays;
+  pMPNG->iTickspersec = ((mng_mpngp)pEntry)->iTickspersec;
+  pMPNG->iFramessize  = ((mng_mpngp)pEntry)->iFramessize;
+
+  if (pMPNG->iFramessize)
+  {
+    MNG_ALLOC (pData, pMPNG->pFrames, pMPNG->iFramessize);
+    MNG_COPY (pMPNG->pFrames, ((mng_mpngp)pEntry)->pFrames, pMPNG->iFramessize);
+  }
+#endif
+
+  pData->pMPNG      = pMPNG;
+  pData->eImagetype = mng_it_mpng;
+
+  iRetcode = mng_process_display_mpng (pData);
+  if (iRetcode)
+    return iRetcode;
+
+  /* now let's create the MNG animation directives from this */
+
+  pFrame = (mng_uint8p)pMPNG->pFrames;
+  iMax   = pMPNG->iFramessize / 26;
+                                       /* set up MNG impersonation */
+  pData->iTicks      = pMPNG->iTickspersec;
+  pData->iLayercount = iMax;
+
+  if (pMPNG->iNumplays != 1)           /* create a LOOP/ENDL pair ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_loop),
+                                   mng_free_ani_loop, mng_process_ani_loop,
+                                   &((mng_ptr)pLOOP));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pLOOP, sizeof (mng_ani_loop));
+
+    pLOOP->sHeader.fCleanup = mng_free_ani_loop;
+    pLOOP->sHeader.fProcess = mng_process_ani_loop;
+#endif
+
+    pLOOP->iLevel = 1;
+    if (pMPNG->iNumplays)
+      pLOOP->iRepeatcount = pMPNG->iNumplays;
+    else
+      pLOOP->iRepeatcount = 0xFFFFFFFFl;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pLOOP);
+  }
+
+  bNewframe = MNG_TRUE;                /* create the frame display objects */
+
+  for (iCnt = 0; iCnt < iMax; iCnt++)
+  {
+    iX       = mng_get_uint32 (pFrame);
+    iY       = mng_get_uint32 (pFrame+4);
+    iWidth   = mng_get_uint32 (pFrame+8);
+    iHeight  = mng_get_uint32 (pFrame+12);
+    iXoffset = mng_get_int32  (pFrame+16);
+    iYoffset = mng_get_int32  (pFrame+20);
+    iTicks   = mng_get_uint16 (pFrame+24);
+
+    iDelay = iTicks;
+    if (!iDelay)
+    {
+      mng_uint8p pTemp = pFrame+26;
+      mng_int32  iTemp = iCnt+1;
+
+      while ((iTemp < iMax) && (!iDelay))
+      {
+        iDelay = mng_get_uint16 (pTemp+24);
+        pTemp += 26;
+        iTemp++;
+      }
+    }
+
+    if (bNewframe)
+    {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+      iRetcode = create_obj_general (pData, sizeof (mng_ani_fram),
+                                     mng_free_obj_general, mng_process_ani_fram,
+                                     &((mng_ptr)pFRAM));
+      if (iRetcode)
+        return iRetcode;
+#else
+      MNG_ALLOC (pData, pFRAM, sizeof (mng_ani_fram));
+
+      pFRAM->sHeader.fCleanup = mng_free_ani_fram;
+      pFRAM->sHeader.fProcess = mng_process_ani_fram;
+#endif
+
+      pFRAM->iFramemode   = 4;
+      pFRAM->iChangedelay = 1;
+      pFRAM->iDelay       = iDelay;
+
+      mng_add_ani_object (pData, (mng_object_headerp)pFRAM);
+    }
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_move),
+                                   mng_free_obj_general,
+                                   mng_process_ani_move,
+                                   &((mng_ptr)pMOVE));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pMOVE, sizeof (mng_ani_move));
+
+    pMOVE->sHeader.fCleanup = mng_free_ani_move;
+    pMOVE->sHeader.fProcess = mng_process_ani_move;
+#endif
+
+    pMOVE->iLocax   = iXoffset - (mng_int32)iX;
+    pMOVE->iLocay   = iYoffset - (mng_int32)iY;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pMOVE);
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_clip),
+                                   mng_free_obj_general,
+                                   mng_process_ani_clip,
+                                   &((mng_ptr)pCLIP));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pCLIP, sizeof (mng_ani_clip));
+
+    pCLIP->sHeader.fCleanup = mng_free_ani_clip;
+    pCLIP->sHeader.fProcess = mng_process_ani_clip;
+#endif
+
+    pCLIP->iClipl = iXoffset;
+    pCLIP->iClipr = iXoffset + (mng_int32)iWidth;
+    pCLIP->iClipt = iYoffset;
+    pCLIP->iClipb = iYoffset + (mng_int32)iHeight;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pCLIP);
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_show),
+                                   mng_free_obj_general, mng_process_ani_show,
+                                   &((mng_ptr)pSHOW));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pSHOW, sizeof (mng_ani_show));
+
+    pSHOW->sHeader.fCleanup = mng_free_ani_show;
+    pSHOW->sHeader.fProcess = mng_process_ani_show;
+#endif
+
+    mng_add_ani_object (pData, (mng_object_headerp)pSHOW);
+
+    bNewframe = (mng_bool)iTicks;
+    pFrame += 26;
+  }
+
+  if (pMPNG->iNumplays != 1)           /* create a LOOP/ENDL pair ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_endl),
+                                   mng_free_obj_general, mng_process_ani_endl,
+                                   &((mng_ptr)pENDL));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pENDL, sizeof (mng_ani_endl));
+
+    pENDL->sHeader.fCleanup = mng_free_ani_endl;
+    pENDL->sHeader.fProcess = mng_process_ani_endl;
+#endif
+
+    pENDL->iLevel = 1;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pENDL);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_MPNG_OBJ, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_mpng_obj (mng_datap   pData,
+                               mng_objectp pObject)
+{
+  mng_mpng_objp pMPNG = (mng_mpng_objp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MPNG_OBJ, MNG_LC_START);
+#endif
+
+  if (pMPNG->iFramessize)
+    MNG_FREEX (pData, pMPNG->pFrames, pMPNG->iFramessize);
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pMPNG, sizeof (mng_mpng_obj));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_MPNG_OBJ, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_mpng_obj (mng_datap   pData,
+                                  mng_objectp pObject)
+{
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_MPNG_PROPOSAL */
+
+/* ************************************************************************** */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ang_obj (mng_datap  pData,
+                                mng_uint32 iNumframes,
+                                mng_uint32 iTickspersec,
+                                mng_uint32 iNumplays,
+                                mng_uint32 iTilewidth,
+                                mng_uint32 iTileheight,
+                                mng_uint8  iInterlace,
+                                mng_uint8  iStillused)
+#else
+mng_retcode mng_create_ang_obj (mng_datap  pData,
+                                mng_ptr    pEntry)
+#endif
+{
+  mng_ang_objp  pANG;
+  mng_ptr       pTemp;
+  mng_retcode   iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANG_OBJ, MNG_LC_START);
+#endif
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+  iRetcode = create_obj_general (pData, sizeof (mng_ang_obj), mng_free_ang_obj,
+                                 mng_process_ang_obj, &pTemp);
+  if (iRetcode)
+    return iRetcode;
+  pANG = (mng_ang_objp)pTemp;
+#else
+  MNG_ALLOC (pData, pANG, sizeof (mng_ang_obj));
+
+  pANG->sHeader.fCleanup = mng_free_ang_obj;
+  pANG->sHeader.fProcess = mng_process_ang_obj;
+#endif
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  pANG->iNumframes   = iNumframes;
+  pANG->iTickspersec = iTickspersec;
+  pANG->iNumplays    = iNumplays;
+  pANG->iTilewidth   = iTilewidth;
+  pANG->iTileheight  = iTileheight;
+  pANG->iInterlace   = iInterlace;
+  pANG->iStillused   = iStillused;
+#else
+  pANG->iNumframes   = ((mng_ahdrp)pEntry)->iNumframes;
+  pANG->iTickspersec = ((mng_ahdrp)pEntry)->iTickspersec;
+  pANG->iNumplays    = ((mng_ahdrp)pEntry)->iNumplays;
+  pANG->iTilewidth   = ((mng_ahdrp)pEntry)->iTilewidth;
+  pANG->iTileheight  = ((mng_ahdrp)pEntry)->iTileheight;
+  pANG->iInterlace   = ((mng_ahdrp)pEntry)->iInterlace;
+  pANG->iStillused   = ((mng_ahdrp)pEntry)->iStillused;
+#endif
+
+  pData->pANG       = pANG;
+  pData->eImagetype = mng_it_ang;
+
+  iRetcode = mng_process_display_ang (pData);
+  if (iRetcode)
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CREATE_ANG_OBJ, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_ang_obj (mng_datap   pData,
+                              mng_objectp pObject)
+{
+  mng_ang_objp pANG = (mng_ang_objp)pObject;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANG_OBJ, MNG_LC_START);
+#endif
+
+  if (pANG->iTilessize)
+    MNG_FREEX (pData, pANG->pTiles, pANG->iTilessize);
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  MNG_FREEX (pData, pANG, sizeof (mng_ang_obj));
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FREE_ANG_OBJ, MNG_LC_END);
+#endif
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+  return MNG_NOERROR;
+#else
+  return mng_free_obj_general(pData, pObject);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ang_obj (mng_datap   pData,
+                                 mng_objectp pObject)
+{
+  mng_ang_objp  pANG  = (mng_ang_objp)pObject;
+  mng_uint8p    pTile = (mng_uint8p)pANG->pTiles;
+  mng_retcode   iRetcode;
+  mng_int32     iCnt, iMax;
+  mng_uint32    iTicks;
+  mng_int32     iXoffset, iYoffset;
+  mng_uint8     iSource;
+  mng_ani_loopp pLOOP;
+  mng_ani_endlp pENDL;
+  mng_ani_framp pFRAM;
+  mng_ani_movep pMOVE;
+  mng_ani_showp pSHOW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANG_OBJ, MNG_LC_START);
+#endif
+
+  /* let's create the MNG animation directives from this */
+
+  iMax = pANG->iNumframes;
+                                       /* set up MNG impersonation */
+  pData->iTicks      = pANG->iTickspersec;
+  pData->iLayercount = iMax;
+
+  if (pANG->iNumplays != 1)            /* create a LOOP/ENDL pair ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_loop),
+                                   mng_free_ani_loop, mng_process_ani_loop,
+                                   &((mng_ptr)pLOOP));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pLOOP, sizeof (mng_ani_loop));
+
+    pLOOP->sHeader.fCleanup = mng_free_ani_loop;
+    pLOOP->sHeader.fProcess = mng_process_ani_loop;
+#endif
+
+    pLOOP->iLevel = 1;
+    if (pANG->iNumplays)
+      pLOOP->iRepeatcount = pANG->iNumplays;
+    else
+      pLOOP->iRepeatcount = 0xFFFFFFFFl;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pLOOP);
+  }
+
+  for (iCnt = 0; iCnt < iMax; iCnt++)
+  {
+    iTicks   = mng_get_uint32 (pTile);
+    iXoffset = mng_get_int32  (pTile+4);
+    iYoffset = mng_get_int32  (pTile+8);
+    iSource  = *(pTile+12);
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_fram),
+                                   mng_free_obj_general, mng_process_ani_fram,
+                                   &((mng_ptr)pFRAM));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pFRAM, sizeof (mng_ani_fram));
+
+    pFRAM->sHeader.fCleanup = mng_free_ani_fram;
+    pFRAM->sHeader.fProcess = mng_process_ani_fram;
+#endif
+
+    pFRAM->iFramemode   = 4;
+    pFRAM->iChangedelay = 1;
+    pFRAM->iDelay       = iTicks;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pFRAM);
+
+    if (!iSource)
+    {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+      iRetcode = create_obj_general (pData, sizeof (mng_ani_move),
+                                     mng_free_obj_general,
+                                     mng_process_ani_move,
+                                     &((mng_ptr)pMOVE));
+      if (iRetcode)
+        return iRetcode;
+#else
+      MNG_ALLOC (pData, pMOVE, sizeof (mng_ani_move));
+
+      pMOVE->sHeader.fCleanup = mng_free_ani_move;
+      pMOVE->sHeader.fProcess = mng_process_ani_move;
+#endif
+
+      pMOVE->iFirstid = 1;
+      pMOVE->iLastid  = 1;
+      pMOVE->iLocax   = -iXoffset;
+      pMOVE->iLocay   = -iYoffset;
+
+      mng_add_ani_object (pData, (mng_object_headerp)pMOVE);
+    }
+
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_show),
+                                   mng_free_obj_general, mng_process_ani_show,
+                                   &((mng_ptr)pSHOW));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pSHOW, sizeof (mng_ani_show));
+
+    pSHOW->sHeader.fCleanup = mng_free_ani_show;
+    pSHOW->sHeader.fProcess = mng_process_ani_show;
+#endif
+
+    if (iSource)
+      pSHOW->iFirstid = 0;
+    else
+      pSHOW->iFirstid = 1;
+    pSHOW->iLastid    = pSHOW->iFirstid;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pSHOW);
+
+    pTile += sizeof(mng_adat_tile);
+  }
+
+  if (pANG->iNumplays != 1)            /* create a LOOP/ENDL pair ? */
+  {
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+    iRetcode = create_obj_general (pData, sizeof (mng_ani_endl),
+                                   mng_free_obj_general, mng_process_ani_endl,
+                                   &((mng_ptr)pENDL));
+    if (iRetcode)
+      return iRetcode;
+#else
+    MNG_ALLOC (pData, pENDL, sizeof (mng_ani_endl));
+
+    pENDL->sHeader.fCleanup = mng_free_ani_endl;
+    pENDL->sHeader.fProcess = mng_process_ani_endl;
+#endif
+
+    pENDL->iLevel = 1;
+
+    mng_add_ani_object (pData, (mng_object_headerp)pENDL);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_ANG_OBJ, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_ANG_PROPOSAL */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_object_prc.h b/src/3rdparty/libmng/libmng_object_prc.h
new file mode 100644
index 0000000..ffd20c8
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_object_prc.h
@@ -0,0 +1,690 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_object_prc.h       copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Object processing routines (definition)                    * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the internal object processing routines      * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added support for global color-chunks in animation       * */
+/* *             - added support for global PLTE,tRNS,bKGD in animation     * */
+/* *             - added SAVE & SEEK animation objects                      * */
+/* *             0.5.2 - 05/29/2000 - G.Juyn                                * */
+/* *             - changed ani_object create routines not to return the     * */
+/* *               created object (wasn't necessary)                        * */
+/* *             - added compression/filter/interlace fields to             * */
+/* *               object-buffer for delta-image processing                 * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - added support for PPLT chunk                             * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added routine to discard "invalid" objects               * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/13/2002 - G.Juyn                                * */
+/* *             - fixed read/write of MAGN chunk                           * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - added in-memory color-correction of abstract images      * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - fixed DISC support                                       * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added conditionals around Delta-PNG code                 * */
+/* *             - added SKIPCHUNK feature                                  * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - added more SKIPCHUNK conditionals                        * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_OBJCLEANUP                * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_object_prc_h_
+#define _libmng_object_prc_h_
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+
+/* ************************************************************************** */
+
+mng_retcode mng_drop_invalid_objects   (mng_datap      pData);
+
+/* ************************************************************************** */
+
+mng_retcode mng_create_imagedataobject (mng_datap      pData,
+                                        mng_bool       bConcrete,
+                                        mng_bool       bViewable,
+                                        mng_uint32     iWidth,
+                                        mng_uint32     iHeight,
+                                        mng_uint8      iBitdepth,
+                                        mng_uint8      iColortype,
+                                        mng_uint8      iCompression,
+                                        mng_uint8      iFilter,
+                                        mng_uint8      iInterlace,
+                                        mng_imagedatap *ppObject);
+
+mng_retcode mng_free_imagedataobject   (mng_datap      pData,
+                                        mng_imagedatap pImagedata);
+
+mng_retcode mng_clone_imagedataobject  (mng_datap      pData,
+                                        mng_bool       bConcrete,
+                                        mng_imagedatap pSource,
+                                        mng_imagedatap *ppClone);
+
+/* ************************************************************************** */
+
+mng_retcode mng_create_imageobject   (mng_datap  pData,
+                                      mng_uint16 iId,
+                                      mng_bool   bConcrete,
+                                      mng_bool   bVisible,
+                                      mng_bool   bViewable,
+                                      mng_uint32 iWidth,
+                                      mng_uint32 iHeight,
+                                      mng_uint8  iBitdepth,
+                                      mng_uint8  iColortype,
+                                      mng_uint8  iCompression,
+                                      mng_uint8  iFilter,
+                                      mng_uint8  iInterlace,
+                                      mng_int32  iPosx,
+                                      mng_int32  iPosy,
+                                      mng_bool   bClipped,
+                                      mng_int32  iClipl,
+                                      mng_int32  iClipr,
+                                      mng_int32  iClipt,
+                                      mng_int32  iClipb,
+                                      mng_imagep *ppObject);
+
+mng_retcode mng_free_imageobject     (mng_datap  pData,
+                                      mng_imagep pImage);
+
+mng_imagep  mng_find_imageobject     (mng_datap  pData,
+                                      mng_uint16 iId);
+
+mng_retcode mng_clone_imageobject    (mng_datap  pData,
+                                      mng_uint16 iId,
+                                      mng_bool   bPartial,
+                                      mng_bool   bVisible,
+                                      mng_bool   bAbstract,
+                                      mng_bool   bHasloca,
+                                      mng_uint8  iLocationtype,
+                                      mng_int32  iLocationx,
+                                      mng_int32  iLocationy,
+                                      mng_imagep pSource,
+                                      mng_imagep *ppClone);
+
+mng_retcode mng_renum_imageobject    (mng_datap  pData,
+                                      mng_imagep pSource,
+                                      mng_uint16 iId,
+                                      mng_bool   bVisible,
+                                      mng_bool   bAbstract,
+                                      mng_bool   bHasloca,
+                                      mng_uint8  iLocationtype,
+                                      mng_int32  iLocationx,
+                                      mng_int32  iLocationy);
+
+mng_retcode mng_reset_object_details (mng_datap  pData,
+                                      mng_imagep pImage,
+                                      mng_uint32 iWidth,
+                                      mng_uint32 iHeight,
+                                      mng_uint8  iBitdepth,
+                                      mng_uint8  iColortype,
+                                      mng_uint8  iCompression,
+                                      mng_uint8  iFilter,
+                                      mng_uint8  iInterlace,
+                                      mng_bool   bResetall);
+
+mng_retcode mng_promote_imageobject  (mng_datap  pData,
+                                      mng_imagep pImage,
+                                      mng_uint8  iBitdepth,
+                                      mng_uint8  iColortype,
+                                      mng_uint8  iFilltype);
+
+mng_retcode mng_magnify_imageobject  (mng_datap  pData,
+                                      mng_imagep pImage);
+
+mng_retcode mng_colorcorrect_object  (mng_datap  pData,
+                                      mng_imagep pImage);
+
+/* ************************************************************************** */
+
+mng_retcode mng_create_ani_image  (mng_datap      pData);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+
+mng_retcode mng_create_ani_plte   (mng_datap      pData,
+                                   mng_uint32     iEntrycount,
+                                   mng_palette8ep paEntries);
+
+mng_retcode mng_create_ani_trns   (mng_datap      pData,
+                                   mng_uint32     iRawlen,
+                                   mng_uint8p     pRawdata);
+
+mng_retcode mng_create_ani_gama   (mng_datap      pData,
+                                   mng_bool       bEmpty,
+                                   mng_uint32     iGamma);
+
+mng_retcode mng_create_ani_chrm   (mng_datap      pData,
+                                   mng_bool       bEmpty,
+                                   mng_uint32     iWhitepointx,
+                                   mng_uint32     iWhitepointy,
+                                   mng_uint32     iRedx,
+                                   mng_uint32     iRedy,
+                                   mng_uint32     iGreenx,
+                                   mng_uint32     iGreeny,
+                                   mng_uint32     iBluex,
+                                   mng_uint32     iBluey);
+
+mng_retcode mng_create_ani_srgb   (mng_datap      pData,
+                                   mng_bool       bEmpty,
+                                   mng_uint8      iRenderinginent);
+
+mng_retcode mng_create_ani_iccp   (mng_datap      pData,
+                                   mng_bool       bEmpty,
+                                   mng_uint32     iProfilesize,
+                                   mng_ptr        pProfile);
+
+mng_retcode mng_create_ani_bkgd   (mng_datap      pData,
+                                   mng_uint16     iRed,
+                                   mng_uint16     iGreen,
+                                   mng_uint16     iBlue);
+
+mng_retcode mng_create_ani_loop   (mng_datap      pData,
+                                   mng_uint8      iLevel,
+                                   mng_uint32     iRepeatcount,
+                                   mng_uint8      iTermcond,
+                                   mng_uint32     iItermin,
+                                   mng_uint32     iItermax,
+                                   mng_uint32     iCount,
+                                   mng_uint32p    pSignals);
+
+mng_retcode mng_create_ani_endl   (mng_datap      pData,
+                                   mng_uint8      iLevel);
+
+mng_retcode mng_create_ani_defi   (mng_datap      pData);
+
+mng_retcode mng_create_ani_basi   (mng_datap      pData,
+                                   mng_uint16     iRed,
+                                   mng_uint16     iGreen,
+                                   mng_uint16     iBlue,
+                                   mng_bool       bHasalpha,
+                                   mng_uint16     iAlpha,
+                                   mng_uint8      iViewable);
+
+mng_retcode mng_create_ani_clon   (mng_datap      pData,
+                                   mng_uint16     iSourceid,
+                                   mng_uint16     iCloneid,
+                                   mng_uint8      iClonetype,
+                                   mng_bool       bHasdonotshow,
+                                   mng_uint8      iDonotshow,
+                                   mng_uint8      iConcrete,
+                                   mng_bool       bHasloca,
+                                   mng_uint8      iLocatype,
+                                   mng_int32      iLocax,
+                                   mng_int32      iLocay);
+
+mng_retcode mng_create_ani_back   (mng_datap      pData,
+                                   mng_uint16     iRed,
+                                   mng_uint16     iGreen,
+                                   mng_uint16     iBlue,
+                                   mng_uint8      iMandatory,
+                                   mng_uint16     iImageid,
+                                   mng_uint8      iTile);
+
+mng_retcode mng_create_ani_fram   (mng_datap      pData,
+                                   mng_uint8      iFramemode,
+                                   mng_uint8      iChangedelay,
+                                   mng_uint32     iDelay,
+                                   mng_uint8      iChangetimeout,
+                                   mng_uint32     iTimeout,
+                                   mng_uint8      iChangeclipping,
+                                   mng_uint8      iCliptype,
+                                   mng_int32      iClipl,
+                                   mng_int32      iClipr,
+                                   mng_int32      iClipt,
+                                   mng_int32      iClipb);
+
+mng_retcode mng_create_ani_move   (mng_datap      pData,
+                                   mng_uint16     iFirstid,
+                                   mng_uint16     iLastid,
+                                   mng_uint8      iType,
+                                   mng_int32      iLocax,
+                                   mng_int32      iLocay);
+
+mng_retcode mng_create_ani_clip   (mng_datap      pData,
+                                   mng_uint16     iFirstid,
+                                   mng_uint16     iLastid,
+                                   mng_uint8      iType,
+                                   mng_int32      iClipl,
+                                   mng_int32      iClipr,
+                                   mng_int32      iClipt,
+                                   mng_int32      iClipb);
+
+mng_retcode mng_create_ani_show   (mng_datap      pData,
+                                   mng_uint16     iFirstid,
+                                   mng_uint16     iLastid,
+                                   mng_uint8      iMode);
+
+mng_retcode mng_create_ani_term   (mng_datap      pData,
+                                   mng_uint8      iTermaction,
+                                   mng_uint8      iIteraction,
+                                   mng_uint32     iDelay,
+                                   mng_uint32     iItermax);
+
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_create_ani_save   (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode mng_create_ani_seek   (mng_datap      pData,
+                                   mng_uint32     iSegmentnamesize,
+                                   mng_pchar      zSegmentname);
+#endif
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_create_ani_dhdr   (mng_datap      pData,
+                                   mng_uint16     iObjectid,
+                                   mng_uint8      iImagetype,
+                                   mng_uint8      iDeltatype,
+                                   mng_uint32     iBlockwidth,
+                                   mng_uint32     iBlockheight,
+                                   mng_uint32     iBlockx,
+                                   mng_uint32     iBlocky);
+
+mng_retcode mng_create_ani_prom   (mng_datap      pData,
+                                   mng_uint8      iBitdepth,
+                                   mng_uint8      iColortype,
+                                   mng_uint8      iFilltype);
+
+mng_retcode mng_create_ani_ipng   (mng_datap      pData);
+mng_retcode mng_create_ani_ijng   (mng_datap      pData);
+
+mng_retcode mng_create_ani_pplt   (mng_datap      pData,
+                                   mng_uint8      iType,
+                                   mng_uint32     iCount,
+                                   mng_palette8ep paIndexentries,
+                                   mng_uint8p     paAlphaentries,
+                                   mng_uint8p     paUsedentries);
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode mng_create_ani_magn   (mng_datap      pData,
+                                   mng_uint16     iFirstid,
+                                   mng_uint16     iLastid,
+                                   mng_uint8      iMethodX,
+                                   mng_uint16     iMX,
+                                   mng_uint16     iMY,
+                                   mng_uint16     iML,
+                                   mng_uint16     iMR,
+                                   mng_uint16     iMT,
+                                   mng_uint16     iMB,
+                                   mng_uint8      iMethodY);
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_create_ani_past   (mng_datap      pData,
+                                   mng_uint16     iTargetid,
+                                   mng_uint8      iTargettype,
+                                   mng_int32      iTargetx,
+                                   mng_int32      iTargety,
+                                   mng_uint32     iCount,
+                                   mng_ptr        pSources);
+#endif
+
+#ifndef MNG_SKIPCHUNK_DISC
+mng_retcode mng_create_ani_disc   (mng_datap      pData,
+                                   mng_uint32     iCount,
+                                   mng_uint16p    pIds);
+#endif
+
+#else /* MNG_OPTIMIZE_CHUNKREADER */
+
+mng_retcode mng_create_ani_plte   (mng_datap      pData);
+mng_retcode mng_create_ani_trns   (mng_datap      pData);
+mng_retcode mng_create_ani_gama   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_chrm   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_srgb   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_iccp   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_bkgd   (mng_datap      pData);
+mng_retcode mng_create_ani_loop   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_endl   (mng_datap      pData,
+                                   mng_uint8      iLevel);
+mng_retcode mng_create_ani_defi   (mng_datap      pData);
+mng_retcode mng_create_ani_basi   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_clon   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_back   (mng_datap      pData);
+mng_retcode mng_create_ani_fram   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_move   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_clip   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_show   (mng_datap      pData);
+mng_retcode mng_create_ani_term   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_create_ani_save   (mng_datap      pData);
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode mng_create_ani_seek   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+#endif
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_create_ani_dhdr   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_prom   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+mng_retcode mng_create_ani_ipng   (mng_datap      pData);
+mng_retcode mng_create_ani_ijng   (mng_datap      pData);
+
+mng_retcode mng_create_ani_pplt   (mng_datap      pData,
+                                   mng_uint8      iType,
+                                   mng_uint32     iCount,
+                                   mng_palette8ep paIndexentries,
+                                   mng_uint8p     paAlphaentries,
+                                   mng_uint8p     paUsedentries);
+#endif
+
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode mng_create_ani_magn   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_create_ani_past   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+#endif
+#ifndef MNG_SKIPCHUNK_DISC
+mng_retcode mng_create_ani_disc   (mng_datap      pData,
+                                   mng_chunkp     pChunk);
+#endif
+
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+/* ************************************************************************** */
+
+mng_retcode mng_free_ani_image    (mng_datap    pData,
+                                   mng_objectp  pObject);
+
+#ifndef MNG_OPTIMIZE_OBJCLEANUP
+
+mng_retcode mng_free_ani_plte     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_trns     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_gama     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#ifndef MNG_SKIPCHUNK_cHRM
+mng_retcode mng_free_ani_chrm     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_sRGB
+mng_retcode mng_free_ani_srgb     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+mng_retcode mng_free_ani_bkgd     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+mng_retcode mng_free_ani_endl     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+mng_retcode mng_free_ani_defi     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_basi     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_clon     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_back     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_fram     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_move     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_clip     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_show     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_term     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_free_ani_save     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_free_ani_dhdr     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_prom     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_ipng     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_ijng     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_free_ani_pplt     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_MAGN
+mng_retcode mng_free_ani_magn     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+
+#endif /* MNG_OPTIMIZE_OBJCLEANUP */
+
+
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_retcode mng_free_ani_iccp     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+mng_retcode mng_free_ani_loop     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_free_ani_seek     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_free_ani_past     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+mng_retcode mng_free_ani_disc     (mng_datap    pData,
+                                   mng_objectp  pObject);
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ani_image (mng_datap    pData,
+                                   mng_objectp  pObject);
+
+mng_retcode mng_process_ani_plte  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_trns  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_gama  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#ifndef MNG_SKIPCHUNK_cHRM
+mng_retcode mng_process_ani_chrm  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_sRGB
+mng_retcode mng_process_ani_srgb  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_retcode mng_process_ani_iccp  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+mng_retcode mng_process_ani_bkgd  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+mng_retcode mng_process_ani_loop  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_endl  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+mng_retcode mng_process_ani_defi  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_basi  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_clon  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_back  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_fram  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_move  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_clip  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_show  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_term  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#ifndef MNG_SKIPCHUNK_SAVE
+mng_retcode mng_process_ani_save  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+mng_retcode mng_process_ani_seek  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_process_ani_dhdr  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_prom  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_ipng  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_ijng  (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ani_pplt  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+mng_retcode mng_process_ani_magn  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_process_ani_past  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+mng_retcode mng_process_ani_disc  (mng_datap    pData,
+                                   mng_objectp  pObject);
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_event      (mng_datap    pData,
+                                   mng_uint8    iEventtype,
+                                   mng_uint8    iMasktype,
+                                   mng_int32    iLeft,
+                                   mng_int32    iRight,
+                                   mng_int32    iTop,
+                                   mng_int32    iBottom,
+                                   mng_uint16   iObjectid,
+                                   mng_uint8    iIndex,
+                                   mng_uint32   iSegmentnamesize,
+                                   mng_pchar    zSegmentname);
+#else
+mng_retcode mng_create_event      (mng_datap    pData,
+                                   mng_ptr      pEntry);
+#endif
+mng_retcode mng_free_event        (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_event     (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_mpng_obj   (mng_datap    pData,
+                                   mng_uint32   iFramewidth,
+                                   mng_uint32   iFrameheight,
+                                   mng_uint16   iNumplays,
+                                   mng_uint16   iTickspersec,
+                                   mng_uint32   iFramessize,
+                                   mng_ptr      pFrames);
+#else
+mng_retcode mng_create_mpng_obj   (mng_datap    pData,
+                                   mng_ptr      pEntry);
+#endif
+mng_retcode mng_free_mpng_obj     (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_mpng_obj  (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+mng_retcode mng_create_ang_obj    (mng_datap    pData,
+                                   mng_uint32   iNumframes,
+                                   mng_uint32   iTickspersec,
+                                   mng_uint32   iNumplays,
+                                   mng_uint32   iTilewidth,
+                                   mng_uint32   iTileheight,
+                                   mng_uint8    iInterlace,
+                                   mng_uint8    iStillused);
+#else
+mng_retcode mng_create_ang_obj    (mng_datap    pData,
+                                   mng_ptr      pEntry);
+#endif
+mng_retcode mng_free_ang_obj      (mng_datap    pData,
+                                   mng_objectp  pObject);
+mng_retcode mng_process_ang_obj   (mng_datap    pData,
+                                   mng_objectp  pObject);
+#endif
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+
+#endif /* _libmng_object_prc_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_objects.h b/src/3rdparty/libmng/libmng_objects.h
new file mode 100644
index 0000000..053e6b4
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_objects.h
@@ -0,0 +1,635 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_objects.h          copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Internal object structures (definition)                    * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the internal object structures               * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - changed inclusion to DISPLAY_PROCS                       * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added global color-chunks for animations                 * */
+/* *             - added global PLTE,tRNS,bKGD chunks for animation         * */
+/* *             - added SAVE & SEEK animation objects                      * */
+/* *             0.5.2 - 05/29/2000 - G.Juyn                                * */
+/* *             - added framenr/layernr/playtime to object header          * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added ani-objects for delta-image processing             * */
+/* *             - added compression/filter/interlace fields to             * */
+/* *               object-buffer for delta-image processing                 * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - changed definition of aTRNSentries                       * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - added definition for PPLT animation-processing           * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/10/2000 - G.Juyn                                * */
+/* *             - fixed DEFI behavior                                      * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for delta-JNG                              * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added valid-flag to stored objects for read() / display()* */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - added storage for pixel-/alpha-sampledepth for delta's   * */
+/* *                                                                        * */
+/* *             1.0.5 - 09/13/2002 - G.Juyn                                * */
+/* *             - fixed read/write of MAGN chunk                           * */
+/* *             1.0.5 - 09/15/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - added in-memory color-correction of abstract images      * */
+/* *             1.0.5 - 10/07/2002 - G.Juyn                                * */
+/* *             - fixed DISC support                                       * */
+/* *                                                                        * */
+/* *             1.0.6 - 10/07/2003 - G.R-P                                 * */
+/* *             - added SKIPCHUNK conditionals                             * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/24/2004 - G.R-P                                 * */
+/* *             - added more SKIPCHUNK conditionals                        * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_OBJCLEANUP                * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_objects_h_
+#define _libmng_objects_h_
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+
+/* ************************************************************************** */
+
+typedef mng_retcode (*mng_cleanupobject) (mng_datap    pData,
+                                          mng_objectp  pHeader);
+
+typedef mng_retcode (*mng_processobject) (mng_datap    pData,
+                                          mng_objectp  pHeader);
+
+/* ************************************************************************** */
+
+typedef struct {
+           mng_cleanupobject fCleanup;
+           mng_processobject fProcess;
+           mng_objectp       pNext;              /* for double-linked list */
+           mng_objectp       pPrev;
+           mng_uint32        iFramenr;
+           mng_uint32        iLayernr;
+           mng_uint32        iPlaytime;
+#ifdef MNG_OPTIMIZE_OBJCLEANUP
+           mng_size_t        iObjsize;                    
+#endif
+        } mng_object_header;
+typedef mng_object_header * mng_object_headerp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* MNG specification "object-buffer" */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint32        iRefcount;          /* reference counter */
+           mng_bool          bFrozen;            /* frozen flag */
+           mng_bool          bConcrete;          /* concrete flag */
+           mng_bool          bViewable;          /* viewable flag */
+           mng_uint32        iWidth;             /* image specifics */
+           mng_uint32        iHeight;
+           mng_uint8         iBitdepth;
+           mng_uint8         iColortype;
+           mng_uint8         iCompression;
+           mng_uint8         iFilter;
+           mng_uint8         iInterlace;
+
+           mng_bool          bCorrected;         /* indicates if an abstract image
+                                                    has already been color-corrected */
+           
+           mng_uint8         iAlphabitdepth;     /* used only for JNG images */
+           mng_uint8         iJHDRcompression;
+           mng_uint8         iJHDRinterlace;
+
+           mng_uint8         iPixelsampledepth;  /* used with delta-images */
+           mng_uint8         iAlphasampledepth;
+
+           mng_bool          bHasPLTE;           /* PLTE chunk present */
+           mng_bool          bHasTRNS;           /* tRNS chunk present */
+           mng_bool          bHasGAMA;           /* gAMA chunk present */
+           mng_bool          bHasCHRM;           /* cHRM chunk present */
+           mng_bool          bHasSRGB;           /* sRGB chunk present */
+           mng_bool          bHasICCP;           /* iCCP chunk present */
+           mng_bool          bHasBKGD;           /* bKGD chunk present */
+
+           mng_uint32        iPLTEcount;         /* PLTE fields */
+           mng_rgbpaltab     aPLTEentries;
+
+           mng_uint16        iTRNSgray;          /* tRNS fields */
+           mng_uint16        iTRNSred;
+           mng_uint16        iTRNSgreen;
+           mng_uint16        iTRNSblue;
+           mng_uint32        iTRNScount;
+           mng_uint8arr      aTRNSentries;
+
+           mng_uint32        iGamma;             /* gAMA fields */
+
+           mng_uint32        iWhitepointx;       /* cHRM fields */
+           mng_uint32        iWhitepointy;
+           mng_uint32        iPrimaryredx;
+           mng_uint32        iPrimaryredy;
+           mng_uint32        iPrimarygreenx;
+           mng_uint32        iPrimarygreeny;
+           mng_uint32        iPrimarybluex;
+           mng_uint32        iPrimarybluey;
+
+           mng_uint8         iRenderingintent;   /* sRGB fields */
+
+           mng_uint32        iProfilesize;       /* iCCP fields */
+           mng_ptr           pProfile;
+
+           mng_uint8         iBKGDindex;         /* bKGD fields */
+           mng_uint16        iBKGDgray;
+           mng_uint16        iBKGDred;
+           mng_uint16        iBKGDgreen;
+           mng_uint16        iBKGDblue;
+
+           mng_uint32        iSamplesize;        /* size of a sample */
+           mng_uint32        iRowsize;           /* size of a row of samples */
+           mng_uint32        iImgdatasize;       /* size of the sample data buffer */
+           mng_uint8p        pImgdata;           /* actual sample data buffer */
+
+         } mng_imagedata;
+typedef mng_imagedata * mng_imagedatap;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* MNG specification "object" */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iId;                /* object-id */
+           mng_bool          bFrozen;            /* frozen flag */
+           mng_bool          bVisible;           /* potential visibility flag */
+           mng_bool          bViewable;          /* viewable flag */
+           mng_bool          bValid;             /* marks invalid when only reading */
+           mng_int32         iPosx;              /* location fields */
+           mng_int32         iPosy;
+           mng_bool          bClipped;           /* clipping fields */
+           mng_int32         iClipl;
+           mng_int32         iClipr;
+           mng_int32         iClipt;
+           mng_int32         iClipb;
+#ifndef MNG_SKIPCHUNK_MAGN
+           mng_uint8         iMAGN_MethodX;      /* magnification (MAGN) */
+           mng_uint8         iMAGN_MethodY;
+           mng_uint16        iMAGN_MX;
+           mng_uint16        iMAGN_MY;
+           mng_uint16        iMAGN_ML;
+           mng_uint16        iMAGN_MR;
+           mng_uint16        iMAGN_MT;
+           mng_uint16        iMAGN_MB;
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+           mng_int32         iPastx;             /* target x/y from previous PAST */
+           mng_int32         iPasty;
+#endif
+           mng_imagedatap    pImgbuf;            /* the image-data buffer */
+        } mng_image;
+typedef mng_image * mng_imagep;
+
+/* ************************************************************************** */
+
+                                                 /* "on-the-fly" image (= object 0) */       
+typedef mng_image mng_ani_image;                 /* let's (ab)use the general "object" */
+typedef mng_ani_image * mng_ani_imagep;          /* that's actualy crucial, so don't change it! */
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* global PLTE object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint32        iEntrycount;
+           mng_rgbpaltab     aEntries;
+        } mng_ani_plte;
+typedef mng_ani_plte * mng_ani_pltep;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* global tRNS object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint32        iRawlen;
+           mng_uint8arr      aRawdata;
+        } mng_ani_trns;
+typedef mng_ani_trns * mng_ani_trnsp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* global gAMA object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_bool          bEmpty;
+           mng_uint32        iGamma;
+        } mng_ani_gama;
+typedef mng_ani_gama * mng_ani_gamap;
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_cHRM
+typedef struct {                                 /* global cHRM object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_bool          bEmpty;
+           mng_uint32        iWhitepointx;
+           mng_uint32        iWhitepointy;
+           mng_uint32        iRedx;
+           mng_uint32        iRedy;
+           mng_uint32        iGreenx;
+           mng_uint32        iGreeny;
+           mng_uint32        iBluex;
+           mng_uint32        iBluey;
+        } mng_ani_chrm;
+typedef mng_ani_chrm * mng_ani_chrmp;
+#endif
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* global sRGB object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_bool          bEmpty;
+           mng_uint8         iRenderingintent;
+        } mng_ani_srgb;
+typedef mng_ani_srgb * mng_ani_srgbp;
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_iCCP
+typedef struct {                                 /* global iCCP object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_bool          bEmpty;
+           mng_uint32        iProfilesize;
+           mng_ptr           pProfile;
+        } mng_ani_iccp;
+typedef mng_ani_iccp * mng_ani_iccpp;
+#endif
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* global bKGD object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iRed;
+           mng_uint16        iGreen;
+           mng_uint16        iBlue;
+        } mng_ani_bkgd;
+typedef mng_ani_bkgd * mng_ani_bkgdp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* LOOP object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint8         iLevel;
+           mng_uint32        iRepeatcount;
+           mng_uint8         iTermcond;
+           mng_uint32        iItermin;
+           mng_uint32        iItermax;
+           mng_uint32        iCount;
+           mng_uint32p       pSignals;
+
+           mng_uint32        iRunningcount;      /* running counter */
+        } mng_ani_loop;
+typedef mng_ani_loop * mng_ani_loopp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* ENDL object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint8         iLevel;
+
+           mng_ani_loopp     pLOOP;              /* matching LOOP */
+        } mng_ani_endl;
+typedef mng_ani_endl * mng_ani_endlp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* DEFI object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iId;                
+           mng_bool          bHasdonotshow;
+           mng_uint8         iDonotshow;
+           mng_bool          bHasconcrete;
+           mng_uint8         iConcrete;
+           mng_bool          bHasloca;           
+           mng_int32         iLocax;
+           mng_int32         iLocay;
+           mng_bool          bHasclip;
+           mng_int32         iClipl;
+           mng_int32         iClipr;
+           mng_int32         iClipt;
+           mng_int32         iClipb;
+        } mng_ani_defi;
+typedef mng_ani_defi * mng_ani_defip;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* BASI object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iRed;               
+           mng_uint16        iGreen;             
+           mng_uint16        iBlue;              
+           mng_bool          bHasalpha;             
+           mng_uint16        iAlpha;
+           mng_uint8         iViewable;
+        } mng_ani_basi;
+typedef mng_ani_basi * mng_ani_basip;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* CLON object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iCloneid;
+           mng_uint16        iSourceid;
+           mng_uint8         iClonetype;
+           mng_bool          bHasdonotshow;
+           mng_uint8         iDonotshow;
+           mng_uint8         iConcrete;
+           mng_bool          bHasloca;
+           mng_uint8         iLocatype;
+           mng_int32         iLocax;
+           mng_int32         iLocay;
+        } mng_ani_clon;
+typedef mng_ani_clon * mng_ani_clonp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* BACK object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iRed;
+           mng_uint16        iGreen;
+           mng_uint16        iBlue;
+           mng_uint8         iMandatory;
+           mng_uint16        iImageid;
+           mng_uint8         iTile;
+        } mng_ani_back;
+typedef mng_ani_back * mng_ani_backp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* FRAM object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint8         iFramemode;
+           mng_uint8         iChangedelay;
+           mng_uint32        iDelay;
+           mng_uint8         iChangetimeout;
+           mng_uint32        iTimeout;
+           mng_uint8         iChangeclipping;
+           mng_uint8         iCliptype;
+           mng_int32         iClipl;
+           mng_int32         iClipr;
+           mng_int32         iClipt;
+           mng_int32         iClipb;
+        } mng_ani_fram;
+typedef mng_ani_fram * mng_ani_framp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* MOVE object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iFirstid;           
+           mng_uint16        iLastid;            
+           mng_uint8         iType;              
+           mng_int32         iLocax;             
+           mng_int32         iLocay;
+        } mng_ani_move;
+typedef mng_ani_move * mng_ani_movep;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* CLIP object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iFirstid;           
+           mng_uint16        iLastid;            
+           mng_uint8         iType;              
+           mng_int32         iClipl;             
+           mng_int32         iClipr;             
+           mng_int32         iClipt;             
+           mng_int32         iClipb;
+        } mng_ani_clip;
+typedef mng_ani_clip * mng_ani_clipp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* SHOW object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iFirstid;           
+           mng_uint16        iLastid;            
+           mng_uint8         iMode;
+        } mng_ani_show;
+typedef mng_ani_show * mng_ani_showp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* TERM object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint8         iTermaction;        
+           mng_uint8         iIteraction;        
+           mng_uint32        iDelay;             
+           mng_uint32        iItermax;
+        } mng_ani_term;
+typedef mng_ani_term * mng_ani_termp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* SAVE object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+        } mng_ani_save;
+typedef mng_ani_save * mng_ani_savep;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* SEEK object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint32        iSegmentnamesize;
+           mng_pchar         zSegmentname;
+        } mng_ani_seek;
+typedef mng_ani_seek * mng_ani_seekp;
+
+/* ************************************************************************** */
+#ifndef MNG_NO_DELTA_PNG
+typedef struct {                                 /* DHDR object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iObjectid;
+           mng_uint8         iImagetype;
+           mng_uint8         iDeltatype;
+           mng_uint32        iBlockwidth;
+           mng_uint32        iBlockheight;
+           mng_uint32        iBlockx;
+           mng_uint32        iBlocky;
+        } mng_ani_dhdr;
+typedef mng_ani_dhdr * mng_ani_dhdrp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* PROM object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint8         iBitdepth;
+           mng_uint8         iColortype;
+           mng_uint8         iFilltype;
+        } mng_ani_prom;
+typedef mng_ani_prom * mng_ani_promp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* IPNG object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+        } mng_ani_ipng;
+typedef mng_ani_ipng * mng_ani_ipngp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* IJNG object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+        } mng_ani_ijng;
+typedef mng_ani_ijng * mng_ani_ijngp;
+
+/* ************************************************************************** */
+
+typedef struct {                                 /* PPLT object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint8         iType;
+           mng_uint32        iCount;
+           mng_rgbpaltab     aIndexentries;
+           mng_uint8arr      aAlphaentries;
+           mng_uint8arr      aUsedentries;
+        } mng_ani_pplt;
+typedef mng_ani_pplt * mng_ani_ppltp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+typedef struct {                                 /* MAGN object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iFirstid;
+           mng_uint16        iLastid;
+           mng_uint8         iMethodX;
+           mng_uint16        iMX;
+           mng_uint16        iMY;
+           mng_uint16        iML;
+           mng_uint16        iMR;
+           mng_uint16        iMT;
+           mng_uint16        iMB;
+           mng_uint8         iMethodY;
+        } mng_ani_magn;
+typedef mng_ani_magn * mng_ani_magnp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+typedef struct {                                 /* PAST object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint16        iTargetid;
+           mng_uint8         iTargettype;
+           mng_int32         iTargetx;
+           mng_int32         iTargety;
+           mng_uint32        iCount;
+           mng_ptr           pSources;
+        } mng_ani_past;
+typedef mng_ani_past * mng_ani_pastp;
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_DISC
+typedef struct {                                 /* DISC object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint32        iCount;
+           mng_uint16p       pIds;
+        } mng_ani_disc;
+typedef mng_ani_disc * mng_ani_discp;
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+typedef struct {                                 /* event object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint8         iEventtype;
+           mng_uint8         iMasktype;
+           mng_int32         iLeft;
+           mng_int32         iRight;
+           mng_int32         iTop;
+           mng_int32         iBottom;
+           mng_uint16        iObjectid;
+           mng_uint8         iIndex;
+           mng_uint32        iSegmentnamesize;
+           mng_pchar         zSegmentname;
+
+           mng_ani_seekp     pSEEK;              /* SEEK ani object */
+           mng_int32         iLastx;             /* last X/Y coordinates */
+           mng_int32         iLasty;
+        } mng_event;
+typedef mng_event * mng_eventp;
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+typedef struct {                                 /* mPNG object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint32        iFramewidth;
+           mng_uint32        iFrameheight;
+           mng_uint32        iNumplays;
+           mng_uint16        iTickspersec;
+           mng_uint32        iFramessize;
+           mng_ptr           pFrames;
+        } mng_mpng_obj;
+typedef mng_mpng_obj * mng_mpng_objp;
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+typedef struct {                                 /* ANG object */
+           mng_object_header sHeader;            /* default header (DO NOT REMOVE) */
+           mng_uint32        iNumframes;
+           mng_uint32        iTickspersec;
+           mng_uint32        iNumplays;
+           mng_uint32        iTilewidth;
+           mng_uint32        iTileheight;
+           mng_uint8         iInterlace;
+           mng_uint8         iStillused;
+           mng_uint32        iTilessize;
+           mng_ptr           pTiles;
+        } mng_ang_obj;
+typedef mng_ang_obj * mng_ang_objp;
+#endif
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+
+#endif /* _libmng_objects_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_pixels.c b/src/3rdparty/libmng/libmng_pixels.c
new file mode 100644
index 0000000..ce5637b
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_pixels.c
@@ -0,0 +1,24610 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_pixels.c           copyright (c) 2000-2005 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Pixel-row management routines (implementation)             * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the pixel-row management routines        * */
+/* *                                                                        * */
+/* *             the dual alpha-composing for RGBA/BGRA/etc output-canvas'  * */
+/* *             is based on the Note on Compositing chapter of the         * */
+/* *             DOH-3 draft, noted to me by Adam M. Costello               * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added callback error-reporting support                   * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/22/2000 - G.Juyn                                * */
+/* *             - added JNG support                                        * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - fixed minor bugs 16-bit pixel-handling                   * */
+/* *             - added delta-image row-processing routines                * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - fixed endian support (hopefully)                         * */
+/* *             0.5.2 - 06/03/2000 - G.Juyn                                * */
+/* *             - fixed makeup for Linux gcc compile                       * */
+/* *             0.5.2 - 06/05/2000 - G.Juyn                                * */
+/* *             - implemented app bkgd restore routines                    * */
+/* *             - implemented RGBA8, ARGB8, BGRA8 & ABGR8 display routines * */
+/* *             - added support for RGB8_A8 canvasstyle                    * */
+/* *             0.5.2 - 06/09/2000 - G.Juyn                                * */
+/* *             - fixed alpha-handling for alpha canvasstyles              * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - changed progressive-display processing                   * */
+/* *             0.5.3 - 06/17/2000 - G.Juyn                                * */
+/* *             - changed to support delta-images                          * */
+/* *             - optimized some store_xxx routines                        * */
+/* *             0.5.3 - 06/20/2000 - G.Juyn                                * */
+/* *             - fixed nasty bug with embedded PNG after delta-image      * */
+/* *             0.5.3 - 06/24/2000 - G.Juyn                                * */
+/* *             - fixed problem with 16-bit GA format                      * */
+/* *             0.5.3 - 06/25/2000 - G.Juyn                                * */
+/* *             - fixed problem with cheap transparency for 4-bit gray     * */
+/* *             - fixed display_xxxx routines for interlaced images        * */
+/* *             0.5.3 - 06/28/2000 - G.Juyn                                * */
+/* *             - fixed compiler-warning for non-initialized iB variable   * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/05/2000 - G.Juyn                                * */
+/* *             - fixed mandatory BACK color to be opaque                  * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - B110547 - fixed bug in interlace code                    * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/20/2000 - G.Juyn                                * */
+/* *             - fixed app-supplied background restore                    * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 09/30/2000 - G.Juyn                                * */
+/* *             - fixed MAGN rounding errors (thanks Matthias!)            * */
+/* *             0.9.3 - 10/10/2000 - G.Juyn                                * */
+/* *             - fixed alpha-blending for RGBA canvasstyle                * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - fixed alpha-blending for other alpha-canvasstyles        * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added optional support for bKGD for PNG images           * */
+/* *             - added support for JDAA                                   * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - fixed support for bKGD                                   * */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - implemented delayed delta-processing                     * */
+/* *             0.9.3 - 10/28/2000 - G.Juyn                                * */
+/* *             - fixed tRNS processing for gray-image < 8-bits            * */
+/* *                                                                        * */
+/* *             0.9.4 - 12/16/2000 - G.Juyn                                * */
+/* *             - fixed mixup of data- & function-pointers (thanks Dimitri)* */
+/* *             0.9.4 -  1/18/2001 - G.Juyn                                * */
+/* *             - removed "old" MAGN methods 3 & 4                         * */
+/* *             - added "new" MAGN methods 3, 4 & 5                        * */
+/* *             - removed test filter-methods 1 & 65                       * */
+/* *                                                                        * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn (code by G.Kelly)              * */
+/* *             - added BGRA8 canvas with premultiplied alpha              * */
+/* *             1.0.1 - 04/25/2001 - G.Juyn                                * */
+/* *             - moved mng_clear_cms to libmng_cms                        * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - added option to turn off progressive refresh             * */
+/* *                                                                        * */
+/* *             1.0.4 - 11/04/2001 - G.Juyn                                * */
+/* *             - fixed possible compile-problem in cleanup_rowproc        * */
+/* *             1.0.4 - 06/22/2002 - G.Juyn                                * */
+/* *             - B558212 - off by one error                               * */
+/* *             - MNG subimage alpha composite wrong for rgba8 images      * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/07/2002 - G.Juyn                                * */
+/* *             - added test-option for PNG filter method 193 (=no filter) * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             - completed delta-image support                            * */
+/* *             1.0.5 - 08/16/2002 - G.Juyn                                * */
+/* *             - completed MAGN support (16-bit functions)                * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/19/2002 - G.Juyn                                * */
+/* *             - optimized restore-background for bKGD cases              * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - finished support for BACK image & tiling                 * */
+/* *             1.0.5 - 09/22/2002 - G.Juyn                                * */
+/* *             - added bgrx8 canvas (filler byte)                         * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - added compose over/under routines for PAST processing    * */
+/* *             - added flip & tile routines for PAST processing           * */
+/* *                                                                        * */
+/* *             1.0.6 - 03/09/2003 - G.Juyn                                * */
+/* *             - hiding 12-bit JPEG stuff                                 * */
+/* *             1.0.6 - 05/11/2003 - Glenn RP                              * */
+/* *             - added size-optimization COMPOSE routine usage            * */
+/* *             1.0.6 - 05/11/2003 - G. Juyn                               * */
+/* *             - added conditionals around canvas update routines         * */
+/* *             1.0.6 - 05/25/2003 - Glenn RP                              * */
+/* *             - added size-optimization DIV255B8 routine usage           * */
+/* *             1.0.6 - 06/09/2003 - G. R-P                                * */
+/* *             - added conditionals around 8-bit magn routines            * */
+/* *             1.0.6 - 07/07/2003 - G. R-P                                * */
+/* *             - removed conditionals around 8-bit magn routines          * */
+/* *             - added MNG_NO_16BIT_SUPPORT and MNG_NO_DELTA_PNG          * */
+/* *               conditionals                                             * */
+/* *             - reversed many loops to use decrementing counter          * */
+/* *             - combined init functions                                  * */
+/* *             - converted some switches to array references              * */
+/* *             1.0.6 - 07/29/2003 - G.Juyn                                * */
+/* *             - fixed duplicate for-loop                                 * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added SKIPCHUNK conditionals around PAST chunk support   * */
+/* *             - fixed "FOOTPRINT_COMPOSEIV" typo (now "FOOTPRINT_DIV")   * */
+/* *             1.0.6 - 08/17/2003 - G.R-P                                 * */
+/* *             - added more conditionals around "promote" functions       * */
+/* *                                                                        * */
+/* *             1.0.7 - 11/27/2003 - R.A                                   * */
+/* *             - added CANVAS_RGB565 and CANVAS_BGR565                    * */
+/* *             1.0.7 - 12/06/2003 - R.A                                   * */
+/* *             - added CANVAS_RGBA565 and CANVAS_BGRA565                  * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *             1.0.7 - 03/08/2004 - G.R-P                                 * */
+/* *             - added more conditionals around 16-bit-supporting code    * */
+/* *             1.0.7 - 03/09/2004 - G.Juyn                                * */
+/* *             - fixed bug in promote_g8_g8 with 16bit support off        * */
+/* *             1.0.7 - 03/09/2004 - G.R-P                                 * */
+/* *             - more optimizations with 16bit support off                * */
+/* *             1.0.7 - 03/10/2004 - G.Juyn                                * */
+/* *             - fixed some warnings for 16bit optimizations              * */
+/* *             1.0.7 - 03/21/2004 - G.Juyn                                * */
+/* *             - fixed some 64-bit platform compiler warnings             * */
+/* *                                                                        * */
+/* *             1.0.8 - 06/20/2004 - G.Juyn                                * */
+/* *             - some speed optimizations (thanks to John Stiles)         * */
+/* *             1.0.8 - 08/01/2004 - G.Juyn                                * */
+/* *             - added support for 3+byte pixelsize for JPEG's            * */
+/* *                                                                        * */
+/* *             1.0.9 - 10/10/2004 - G.R-P.                                * */
+/* *             - added MNG_NO_1_2_4BIT_SUPPORT                            * */
+/* *             1.0.9 - 10/14/2004 - G.Juyn                                * */
+/* *             - added bgr565_a8 canvas-style (thanks to J. Elvander)     * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added LITTLEENDIAN/BIGENDIAN fixtures (thanks J.Stiles)  * */
+/* *             - fixed MNG_NO_1_2_4BIT_SUPPORT for TBBN1G04.PNG           * */
+/* *             1.0.9 - 12/31/2004 - G.R-P.                                * */
+/* *             - fixed warnings about C++ style (//) comments             * */
+/* *                                                                        * */
+/* *             1.0.10 - 07/06/2005 - G.R-P.                               * */
+/* *             - added MORE MNG_NO_1_2_4BIT_SUPPORT                       * */
+/* *             1.0.10 - 10/06/2005 - G.R-P.                               * */
+/* *             - alloc more memory for MNG_NO_1_2_4BIT_SUPPORT            * */
+/* *             1.0.10 - 12/07/2005 - G.R-P.                               * */
+/* *             - optimized footprint of 16bit support                     * */
+/* *             1.0.10 - 03/07/2006 - (thanks to W. Manthey)               * */
+/* *             - added CANVAS_RGB555 and CANVAS_BGR555                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_objects.h"
+#include "libmng_object_prc.h"
+#include "libmng_memory.h"
+#include "libmng_cms.h"
+#include "libmng_filter.h"
+#include "libmng_pixels.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_DISPLAY_PROCS
+
+/* TODO: magnification & canvas-positioning/-clipping */
+
+/* TODO: major optimization of pixel-loops by using assembler (?) */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Interlace tables                                                       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+MNG_LOCAL mng_uint32 const interlace_row      [7] = { 0, 0, 4, 0, 2, 0, 1 };
+MNG_LOCAL mng_uint32 const interlace_rowskip  [7] = { 8, 8, 8, 4, 4, 2, 2 };
+MNG_LOCAL mng_uint32 const interlace_col      [7] = { 0, 4, 0, 2, 0, 1, 0 };
+MNG_LOCAL mng_uint32 const interlace_colskip  [7] = { 8, 8, 4, 4, 2, 2, 1 };
+MNG_LOCAL mng_uint32 const interlace_roundoff [7] = { 7, 7, 3, 3, 1, 1, 0 };
+MNG_LOCAL mng_uint32 const interlace_divider  [7] = { 3, 3, 2, 2, 1, 1, 0 };
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Alpha composing macros                                                 * */
+/* * the code below is slightly modified from the libpng package            * */
+/* * the original was last optimized by Greg Roelofs & Mark Adler           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_COMPOSE8(RET,FG,ALPHA,BG) {                                    \
+       mng_uint16 iH = (mng_uint16)((mng_uint16)(FG) * (mng_uint16)(ALPHA) \
+                        + (mng_uint16)(BG)*(mng_uint16)(255 -              \
+                          (mng_uint16)(ALPHA)) + (mng_uint16)128);         \
+       (RET) = (mng_uint8)((iH + (iH >> 8)) >> 8); }
+
+#define MNG_COMPOSE16(RET,FG,ALPHA,BG) {                                   \
+       mng_uint32 iH = (mng_uint32)((mng_uint32)(FG) * (mng_uint32)(ALPHA) \
+                        + (mng_uint32)(BG)*(mng_uint32)(65535L -           \
+                          (mng_uint32)(ALPHA)) + (mng_uint32)32768L);      \
+       (RET) = (mng_uint16)((iH + (iH >> 16)) >> 16); }
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Alpha blending macros                                                  * */
+/* * this code is based on Adam Costello's "Note on Compositing" from the   * */
+/* * mng-list which gives the following formula:                            * */
+/* *                                                                        * */
+/* * top pixel       = (Rt, Gt, Bt, At)                                     * */
+/* * bottom pixel    = (Rb, Gb, Bb, Ab)                                     * */
+/* * composite pixel = (Rc, Gc, Bc, Ac)                                     * */
+/* *                                                                        * */
+/* * all values in the range 0..1                                           * */
+/* *                                                                        * */
+/* * Ac = 1 - (1 - At)(1 - Ab)                                              * */
+/* * s = At / Ac                                                            * */
+/* * t = (1 - At) Ab / Ac                                                   * */
+/* * Rc = s Rt + t Rb                                                       * */
+/* * Gc = s Gt + t Gb                                                       * */
+/* * Bc = s Bt + t Bb                                                       * */
+/* *                                                                        * */
+/* * (I just hope I coded it correctly in integer arithmetic...)            * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#define MNG_BLEND8(RT, GT, BT, AT, RB, GB, BB, AB, RC, GC, BC, AC) {         \
+       mng_uint32 S, T;                                                      \
+       (AC) = (mng_uint8)((mng_uint32)255 -                                  \
+                          ((((mng_uint32)255 - (mng_uint32)(AT)) *           \
+                            ((mng_uint32)255 - (mng_uint32)(AB))   ) >> 8)); \
+       S    = (mng_uint32)(((mng_uint32)(AT) << 8) /                         \
+                           (mng_uint32)(AC));                                \
+       T    = (mng_uint32)(((mng_uint32)255 - (mng_uint32)(AT)) *            \
+                            (mng_uint32)(AB) / (mng_uint32)(AC));            \
+       (RC) = (mng_uint8)((S * (mng_uint32)(RT) +                            \
+                           T * (mng_uint32)(RB) + (mng_uint32)127) >> 8);    \
+       (GC) = (mng_uint8)((S * (mng_uint32)(GT) +                            \
+                           T * (mng_uint32)(GB) + (mng_uint32)127) >> 8);    \
+       (BC) = (mng_uint8)((S * (mng_uint32)(BT) +                            \
+                           T * (mng_uint32)(BB) + (mng_uint32)127) >> 8); }
+
+#define MNG_BLEND16(RT, GT, BT, AT, RB, GB, BB, AB, RC, GC, BC, AC) {            \
+       mng_uint32 S, T;                                                          \
+       (AC) = (mng_uint16)((mng_uint32)65535 -                                   \
+                           ((((mng_uint32)65535 - (mng_uint32)(AT)) *            \
+                             ((mng_uint32)65535 - (mng_uint32)(AB))   ) >> 16)); \
+       S    = (mng_uint32)(((mng_uint32)(AT) << 16) /                            \
+                            (mng_uint32)(AC));                                   \
+       T    = (mng_uint32)(((mng_uint32)65535 - (mng_uint32)(AT)) *              \
+                            (mng_uint32)(AB) / (mng_uint32)(AC));                \
+       (RC) = (mng_uint16)((S * (mng_uint32)(RT) +                               \
+                            T * (mng_uint32)(RB) + (mng_uint32)32767) >> 16);    \
+       (GC) = (mng_uint16)((S * (mng_uint32)(GT) +                               \
+                            T * (mng_uint32)(GB) + (mng_uint32)32767) >> 16);    \
+       (BC) = (mng_uint16)((S * (mng_uint32)(BT) +                               \
+                            T * (mng_uint32)(BB) + (mng_uint32)32767) >> 16); }
+
+/* ************************************************************************** */
+
+/* note a good optimizing compiler will optimize this */
+#define DIV255B8(x) (mng_uint8)(((x) + 127) / 255)
+#define DIV255B16(x) (mng_uint16)(((x) + 32767) / 65535)
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Progressive display check - checks to see if progressive display is    * */
+/* * in order & indicates so                                                * */
+/* *                                                                        * */
+/* * The routine is called after a call to one of the display_xxx routines  * */
+/* * if appropriate                                                         * */
+/* *                                                                        * */
+/* * The refresh is warrented in the read_chunk routine (mng_read.c)        * */
+/* * and only during read&display processing, since there's not much point  * */
+/* * doing it from memory!                                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_display_progressive_check (mng_datap pData)
+{
+  if ((pData->bDoProgressive) &&       /* need progressive display? */
+      ((pData->eImagetype != mng_it_mng) || (pData->iDataheight > 300)) &&
+      (pData->iDestb - pData->iDestt > 50) && (!pData->pCurraniobj))
+  {
+    mng_int32 iC = pData->iRow + pData->iDestt - pData->iSourcet;
+
+    if (iC % 20 == 0)                  /* every 20th line */
+      pData->bNeedrefresh = MNG_TRUE;
+
+  }
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Display routines - convert rowdata (which is already color-corrected)  * */
+/* * to the output canvas, respecting the opacity information               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+MNG_LOCAL void check_update_region (mng_datap pData)
+{                                      /* determine actual canvas row */
+  mng_int32 iRow = pData->iRow + pData->iDestt - pData->iSourcet;
+                                       /* check for change in update-region */
+  if ((pData->iDestl < (mng_int32)pData->iUpdateleft) || (pData->iUpdateright == 0))
+    pData->iUpdateleft   = pData->iDestl;
+
+  if (pData->iDestr > (mng_int32)pData->iUpdateright)
+    pData->iUpdateright  = pData->iDestr;
+
+  if ((iRow < (mng_int32)pData->iUpdatetop) || (pData->iUpdatebottom == 0))
+    pData->iUpdatetop    = iRow;
+
+  if (iRow+1 > (mng_int32)pData->iUpdatebottom)
+    pData->iUpdatebottom = iRow+1;
+
+  return;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGB8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_rgb8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 3) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *(pDataline+4);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *(pDataline+2);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+4);
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+              iBGr16 = (mng_uint16)(*pScanline    );
+              iBGg16 = (mng_uint16)(*(pScanline+1));
+              iBGb16 = (mng_uint16)(*(pScanline+2));
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *pScanline     = (mng_uint8)(iFGr16 >> 8);
+              *(pScanline+1) = (mng_uint8)(iFGg16 >> 8);
+              *(pScanline+2) = (mng_uint8)(iFGb16 >> 8);
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+            }
+            else
+            {                          /* do alpha composing */
+              MNG_COMPOSE8 (*pScanline,     *pDataline,     iA8, *pScanline    );
+              MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iA8, *(pScanline+1));
+              MNG_COMPOSE8 (*(pScanline+2), *(pDataline+2), iA8, *(pScanline+2));
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_rgb8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGg16;
+  mng_uint8  iA8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 3) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+iBps);
+          *(pScanline+2) = *(pDataline+2*iBps);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4*iBps;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+4);
+            }
+            else
+            {                          /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                         /* scale background up */
+                iBGg16 = (mng_uint16)(*(pScanline+i));
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                         /* now compose */
+                MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+                                         /* and return the composed values */
+                *(pScanline+i) = (mng_uint8)(iFGg16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+            }
+            else
+            {                          /* do alpha composing */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+i), iA8, *(pScanline+i));
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_rgb8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 3) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *(pDataline+2);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+            }
+            else
+            {                          /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+i), iA8, *(pScanline+i));
+              }
+#else
+              MNG_COMPOSE8 (*pScanline,     *pDataline,     iA8, *pScanline    );
+              MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iA8, *(pScanline+1));
+              MNG_COMPOSE8 (*(pScanline+2), *(pDataline+2), iA8, *(pScanline+2));
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_RGB8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGBA8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_rgba8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *(pDataline+4);
+          *(pScanline+3) = *(pDataline+6);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *(pDataline+2);
+          *(pScanline+3) = *(pDataline+3);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+3));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+4);
+              *(pScanline+3) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGr16 = (mng_uint16)(*pScanline    );
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*(pScanline+2));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iFGr16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iFGg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iFGb16 >> 8);
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*pScanline    );
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*(pScanline+2));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCb16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+3);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+              *(pScanline+3) = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (*pScanline,     *pDataline,     iFGa8, *pScanline    );
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *(pDataline+2), iFGa8, *(pScanline+2));
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCr8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCb8;
+                *(pScanline+3) = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_rgba8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+iBps);
+          *(pScanline+2) = *(pDataline+2*iBps);
+          *(pScanline+3) = *(pDataline+3*iBps);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+3));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+4);
+              *(pScanline+3) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                       /* scale background up */
+                iBGg16 = (mng_uint16)(*(pScanline+i));
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                                       /* and return the composed values */
+                *(pScanline+i) = (mng_uint8)(iFGg16 >> 8);
+                                       /* alpha remains fully opaque !!! */
+              }
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*pScanline    );
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*(pScanline+2));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCb16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+3);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+              *(pScanline+3) = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+i), iFGa8, *(pScanline+i));
+              }
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCr8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCb8;
+                *(pScanline+3) = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_rgba8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *(pDataline+2);
+          *(pScanline+3) = *(pDataline+3);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+3);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+              *(pScanline+3) = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+i), iFGa8, *(pScanline+i));
+              }
+#else
+                MNG_COMPOSE8 (*pScanline,     *pDataline,     iFGa8, *pScanline    );
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *(pDataline+2), iFGa8, *(pScanline+2));
+#endif
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCr8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCb8;
+                *(pScanline+3) = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_RGBA8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGBA8_PM
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_rgba8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8_PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+		  if ((s = pDataline[6]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[2];
+		      pScanline[2] = pDataline[4];
+              pScanline[3] = 255;
+			}
+			else
+			{
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[2-i] = DIV255B8(s * pDataline[4-i-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[2]);
+              pScanline[2] = DIV255B8(s * pDataline[4]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+			}
+		  }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+#ifdef MNG_BIGENDIAN_SUPPORTED
+              *(mng_uint32*)pScanline = (*(mng_uint32*)pDataline) | 0x000000FF;
+#else
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[1];
+		      pScanline[2] = pDataline[2];
+              pScanline[3] = 255;
+#endif
+			}
+			else
+			{
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[2-i] = DIV255B8(s * pDataline[2-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1]);
+		      pScanline[2] = DIV255B8(s * pDataline[2]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[4];
+              pScanline[3] = 255;
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[2-i] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[2-i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[2] + t * pScanline[1]);
+			  pScanline[2] = DIV255B8(s * pDataline[4] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0) /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+#ifdef MNG_BIGENDIAN_SUPPORTED
+              *(mng_uint32*)pScanline = (*(mng_uint32*)pDataline) | 0x000000FF;
+#else
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = 255;
+#endif
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[2-i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[2-i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1] + t * pScanline[1]);
+			  pScanline[2] = DIV255B8(s * pDataline[2] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_rgba8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8_PM, MNG_LC_START);
+#endif
+                  
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+		  if ((s = pDataline[6]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[2];
+		      pScanline[2] = pDataline[4];
+              pScanline[3] = 255;
+			}
+			else
+			{
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[2-i] = DIV255B8(s * pDataline[4-i-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[2]);
+              pScanline[2] = DIV255B8(s * pDataline[4]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+			}
+		  }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+#ifdef MNG_BIGENDIAN_SUPPORTED
+              *(mng_uint32*)pScanline = (*(mng_uint32*)pDataline) | 0x000000FF;
+#else
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[1];
+		      pScanline[2] = pDataline[2];
+              pScanline[3] = 255;
+#endif
+			}
+			else
+			{
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[2-i] = DIV255B8(s * pDataline[2-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1]);
+		      pScanline[2] = DIV255B8(s * pDataline[2]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[4];
+              pScanline[3] = 255;
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[2-i] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[2-i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[2] + t * pScanline[1]);
+			  pScanline[2] = DIV255B8(s * pDataline[4] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0) /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+#ifdef MNG_BIGENDIAN_SUPPORTED
+              *(mng_uint32*)pScanline = (*(mng_uint32*)pDataline) | 0x000000FF;
+#else
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = 255;
+#endif
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[2-i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[2-i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1] + t * pScanline[1]);
+			  pScanline[2] = DIV255B8(s * pDataline[2] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_rgba8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8_PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+#ifdef MNG_BIGENDIAN_SUPPORTED
+              *(mng_uint32*)pScanline = (*(mng_uint32*)pDataline) | 0x000000FF;
+#else
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[1];
+		      pScanline[2] = pDataline[2];
+              pScanline[3] = 255;
+#endif
+			}
+			else
+			{
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[2-i] = DIV255B8(s * pDataline[2-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1]);
+		      pScanline[2] = DIV255B8(s * pDataline[2]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0) /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+#ifdef MNG_BIGENDIAN_SUPPORTED
+              *(mng_uint32*)pScanline = (*(mng_uint32*)pDataline) | 0x000000FF;
+#else
+              pScanline[0] = pDataline[0];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = 255;
+#endif
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[2-i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[2-i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[0] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1] + t * pScanline[1]);
+			  pScanline[2] = DIV255B8(s * pDataline[2] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_RGBA8_PM */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_ARGB8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_argb8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8, MNG_LC_START);
+#endif
+
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+6);
+          *(pScanline+1) = *pDataline;
+          *(pScanline+2) = *(pDataline+2);
+          *(pScanline+3) = *(pDataline+4);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+3);
+          *(pScanline+1) = *pDataline;
+          *(pScanline+2) = *(pDataline+1);
+          *(pScanline+3) = *(pDataline+2);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pScanline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *(pDataline+6);
+              *(pScanline+1) = *pDataline;
+              *(pScanline+2) = *(pDataline+2);
+              *(pScanline+3) = *(pDataline+4);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+1));
+                iBGg16 = (mng_uint16)(*(pScanline+2));
+                iBGb16 = (mng_uint16)(*(pScanline+3));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8)(iFGr16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iFGg16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iFGb16 >> 8);
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+1));
+                iBGg16 = (mng_uint16)(*(pScanline+2));
+                iBGb16 = (mng_uint16)(*(pScanline+3));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCa16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCb16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pScanline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+3);
+              *(pScanline+1) = *pDataline;
+              *(pScanline+2) = *(pDataline+1);
+              *(pScanline+3) = *(pDataline+2);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do simple alpha composing */
+                                       /* alpha itself remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+1), *(pScanline+2), *(pScanline+3), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCa8;
+                *(pScanline+1) = iCr8;
+                *(pScanline+2) = iCg8;
+                *(pScanline+3) = iCb8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_argb8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+3*iBps);
+          *(pScanline+1) = *pDataline;
+          *(pScanline+2) = *(pDataline+iBps);
+          *(pScanline+3) = *(pDataline+2*iBps);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pScanline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *(pDataline+6);
+              *(pScanline+1) = *pDataline;
+              *(pScanline+2) = *(pDataline+2);
+              *(pScanline+3) = *(pDataline+4);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                       /* scale background up */
+                iBGg16 = (mng_uint16)(*(pScanline+i+1));
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                                       /* and return the composed values */
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+i+1) = (mng_uint8)(iFGg16 >> 8);
+              }
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+1));
+                iBGg16 = (mng_uint16)(*(pScanline+2));
+                iBGb16 = (mng_uint16)(*(pScanline+3));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCa16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCb16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pScanline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+3);
+              *(pScanline+1) = *pDataline;
+              *(pScanline+2) = *(pDataline+1);
+              *(pScanline+3) = *(pDataline+2);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do simple alpha composing */
+                                       /* alpha itself remains fully opaque !!! */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i+1), *(pDataline+i), iFGa8, *(pScanline+i+1));
+              }
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+1), *(pScanline+2), *(pScanline+3), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCa8;
+                *(pScanline+1) = iCr8;
+                *(pScanline+2) = iCg8;
+                *(pScanline+3) = iCb8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_argb8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8, MNG_LC_START);
+#endif
+
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+3);
+          *(pScanline+1) = *pDataline;
+          *(pScanline+2) = *(pDataline+1);
+          *(pScanline+3) = *(pDataline+2);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pScanline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+3);
+              *(pScanline+1) = *pDataline;
+              *(pScanline+2) = *(pDataline+1);
+              *(pScanline+3) = *(pDataline+2);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do simple alpha composing */
+                                       /* alpha itself remains fully opaque !!! */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i+1), *(pDataline+i), iFGa8, *(pScanline+i+1));
+              }
+#else
+                MNG_COMPOSE8 (*(pScanline+1), *pDataline,     iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *(pDataline+1), iFGa8, *(pScanline+2));
+                MNG_COMPOSE8 (*(pScanline+3), *(pDataline+2), iFGa8, *(pScanline+3));
+#endif
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+1), *(pScanline+2), *(pScanline+3), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCa8;
+                *(pScanline+1) = iCr8;
+                *(pScanline+2) = iCg8;
+                *(pScanline+3) = iCb8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_ARGB8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_ARGB8_PM
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_argb8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8_PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+		  if ((s = pDataline[6]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[2];
+		      pScanline[3] = pDataline[4];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[4-i-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0]);
+              pScanline[2] = DIV255B8(s * pDataline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[4]);
+#endif
+			}
+		  }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[1];
+		      pScanline[3] = pDataline[2];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[2-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0]);
+              pScanline[2] = DIV255B8(s * pDataline[1]);
+		      pScanline[3] = DIV255B8(s * pDataline[2]);
+#endif
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = pDataline[4];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[3-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[2] + t * pScanline[2]);
+			  pScanline[3] = DIV255B8(s * pDataline[4] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[2];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[3-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[1] + t * pScanline[2]);
+			  pScanline[3] = DIV255B8(s * pDataline[2] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_argb8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8_PM, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+		  if ((s = pDataline[6]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[2];
+		      pScanline[3] = pDataline[4];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[4-i-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0]);
+              pScanline[2] = DIV255B8(s * pDataline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[4]);
+#endif
+			}
+		  }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[1];
+		      pScanline[3] = pDataline[2];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[2-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0]);
+              pScanline[2] = DIV255B8(s * pDataline[1]);
+		      pScanline[3] = DIV255B8(s * pDataline[2]);
+#endif
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = pDataline[4];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[3-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[2] + t * pScanline[2]);
+			  pScanline[3] = DIV255B8(s * pDataline[4] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[2];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[3-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[1] + t * pScanline[2]);
+			  pScanline[3] = DIV255B8(s * pDataline[2] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_argb8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8_PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[1];
+		      pScanline[3] = pDataline[2];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[2-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0]);
+              pScanline[2] = DIV255B8(s * pDataline[1]);
+		      pScanline[3] = DIV255B8(s * pDataline[2]);
+#endif
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[0];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[2];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[3-i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[3-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[0] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[1] + t * pScanline[2]);
+			  pScanline[3] = DIV255B8(s * pDataline[2] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ARGB8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_ARGB8_PM */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGB8_A8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_rgb8_a8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pAlphaline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8_A8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination rows */
+    pScanline  = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+    pAlphaline = (mng_uint8p)pData->fGetalphaline  (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+                                       /* adjust destination rows starting-point */
+    pScanline  = pScanline  + (pData->iCol * 3) + (pData->iDestl * 3);
+    pAlphaline = pAlphaline + pData->iCol + pData->iDestl;
+
+    pDataline  = pData->pRGBArow;      /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *(pDataline+4);
+          *pAlphaline    = *(pDataline+6);
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *(pDataline+2);
+          *pAlphaline    = *(pDataline+3);
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pAlphaline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+4);
+              *pAlphaline    = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGr16 = (mng_uint16)(*pScanline    );
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*(pScanline+2));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iFGr16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iFGg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iFGb16 >> 8);
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*pScanline    );
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*(pScanline+2));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCb16 >> 8);
+                *pAlphaline    = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pAlphaline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+              *pAlphaline    = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (*pScanline,     *pDataline,     iFGa8, *pScanline    );
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *(pDataline+2), iFGa8, *(pScanline+2));
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCr8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCb8;
+                *pAlphaline    = iCa8;
+              }
+            }
+          }
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_rgb8_a8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pAlphaline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8_A8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination rows */
+    pScanline  = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+    pAlphaline = (mng_uint8p)pData->fGetalphaline  (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+                                       /* adjust destination rows starting-point */
+    pScanline  = pScanline  + (pData->iCol * 3) + (pData->iDestl * 3);
+    pAlphaline = pAlphaline + pData->iCol + pData->iDestl;
+
+    pDataline  = pData->pRGBArow;      /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+iBps);
+          *(pScanline+2) = *(pDataline+2*iBps);
+          *pAlphaline    = *(pDataline+3*iBps);
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pAlphaline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+4);
+              *pAlphaline    = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                       /* scale background up */
+                iBGg16 = (mng_uint16)(*(pScanline+i));
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                                       /* and return the composed values */
+                *(pScanline+i) = (mng_uint8)(iFGg16 >> 8);
+                                       /* alpha remains fully opaque !!! */
+              }
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*pScanline    );
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*(pScanline+2));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCb16 >> 8);
+                *pAlphaline    = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pAlphaline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+              *pAlphaline    = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+i), iFGa8, *(pScanline+i));
+              }
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCr8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCb8;
+                *pAlphaline    = iCa8;
+              }
+            }
+          }
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_rgb8_a8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pAlphaline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8_A8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination rows */
+    pScanline  = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+    pAlphaline = (mng_uint8p)pData->fGetalphaline  (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+                                       /* adjust destination rows starting-point */
+    pScanline  = pScanline  + (pData->iCol * 3) + (pData->iDestl * 3);
+    pAlphaline = pAlphaline + pData->iCol + pData->iDestl;
+
+    pDataline  = pData->pRGBArow;      /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *pDataline;
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *(pDataline+2);
+          *pAlphaline    = *(pDataline+3);
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pAlphaline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *pDataline;
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *(pDataline+2);
+              *pAlphaline    = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+i), iFGa8, *(pScanline+i));
+              }
+#else
+                MNG_COMPOSE8 (*pScanline,     *pDataline,     iFGa8, *pScanline    );
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *(pDataline+2), iFGa8, *(pScanline+2));
+#endif
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCr8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCb8;
+                *pAlphaline    = iCa8;
+              }
+            }
+          }
+
+          pScanline  += (pData->iColinc * 3);
+          pAlphaline += pData->iColinc;
+          pDataline  += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB8_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_RGB8_A8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGR8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgr8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 3) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + (pData->iSourcel / pData->iColinc) * 8;
+    else
+      pDataline = pDataline + (pData->iSourcel / pData->iColinc) * 4;
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+4);
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *pDataline;
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+2);
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *pDataline;
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha value */
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *pScanline     = *(pDataline+4);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *pDataline;
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+              iBGr16 = (mng_uint16)(*(pScanline+2));
+              iBGg16 = (mng_uint16)(*(pScanline+1));
+              iBGb16 = (mng_uint16)(*pScanline    );
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *pScanline     = (mng_uint8)(iFGb16 >> 8);
+              *(pScanline+1) = (mng_uint8)(iFGg16 >> 8);
+              *(pScanline+2) = (mng_uint8)(iFGr16 >> 8);
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+            }
+            else
+            {                          /* do alpha composing */
+              MNG_COMPOSE8 (*pScanline,     *(pDataline+2), iA8, *pScanline    );
+              MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iA8, *(pScanline+1));
+              MNG_COMPOSE8 (*(pScanline+2), *pDataline,     iA8, *(pScanline+2));
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgr8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGg16;
+  mng_uint8  iA8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 3) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+2*iBps);
+          *(pScanline+1) = *(pDataline+iBps);
+          *(pScanline+2) = *pDataline;
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha value */
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *pScanline     = *(pDataline+4);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *pDataline;
+            }
+            else
+            {                          /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                       /* scale background up */
+              iBGg16 = (mng_uint16)(*(pScanline+2-i));
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+                                       /* and return the composed values */
+              *(pScanline+2-i) = (mng_uint8)(iFGg16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+            }
+            else
+            {                          /* do alpha composing */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+2-i), iA8, *(pScanline+i));
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgr8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 3) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + (pData->iSourcel / pData->iColinc) * 4;
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+2);
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *pDataline;
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+            }
+            else
+            {                          /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+2-i), iA8, *(pScanline+i));
+              }
+#else
+              MNG_COMPOSE8 (*pScanline,     *(pDataline+2), iA8, *pScanline    );
+              MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iA8, *(pScanline+1));
+              MNG_COMPOSE8 (*(pScanline+2), *pDataline,     iA8, *(pScanline+2));
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGR8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGRX8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgrx8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRX8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + (pData->iSourcel / pData->iColinc) * 8;
+    else
+      pDataline = pDataline + (pData->iSourcel / pData->iColinc) * 4;
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+4);
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = 0xFF;       /* filler byte */
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+2);
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = 0xFF;       /* filler byte */
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha value */
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *pScanline     = *(pDataline+4);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+              iBGr16 = (mng_uint16)(*(pScanline+2));
+              iBGg16 = (mng_uint16)(*(pScanline+1));
+              iBGb16 = (mng_uint16)(*pScanline    );
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *pScanline     = (mng_uint8)(iFGb16 >> 8);
+              *(pScanline+1) = (mng_uint8)(iFGg16 >> 8);
+              *(pScanline+2) = (mng_uint8)(iFGr16 >> 8);
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+            else
+            {                          /* do alpha composing */
+              MNG_COMPOSE8 (*pScanline,     *(pDataline+2), iA8, *pScanline    );
+              MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iA8, *(pScanline+1));
+              MNG_COMPOSE8 (*(pScanline+2), *pDataline,     iA8, *(pScanline+2));
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgrx8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGg16;
+  mng_uint8  iA8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRX8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+2*iBps);
+          *(pScanline+1) = *(pDataline+iBps);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = 0xFF;       /* filler byte */
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha value */
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *pScanline     = *(pDataline+4);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+            else
+            {                          /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                       /* scale background up */
+              iBGg16 = (mng_uint16)(*(pScanline+2-i));
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+                                       /* and return the composed values */
+              *(pScanline+2-i) = (mng_uint8)(iFGg16 >> 8);
+              }
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+            else
+            {                          /* do alpha composing */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+2-i), iA8, *(pScanline+i));
+              }
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgrx8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRX8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + (pData->iSourcel / pData->iColinc) * 4;
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+2);
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = 0xFF;       /* filler byte */
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+            else
+            {                          /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+              MNG_COMPOSE8 (*(pScanline+i), *(pDataline+2-i), iA8, *(pScanline+i));
+              }
+#else
+              MNG_COMPOSE8 (*pScanline,     *(pDataline+2), iA8, *pScanline    );
+              MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iA8, *(pScanline+1));
+              MNG_COMPOSE8 (*(pScanline+2), *pDataline,     iA8, *(pScanline+2));
+#endif
+              *(pScanline+3) = 0xFF;   /* filler byte */
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGRX8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGRA8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgra8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+4);
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = *(pDataline+6);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+2);
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = *(pDataline+3);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+3));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *(pDataline+4);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+2));
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*pScanline    );
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iFGb16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iFGg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iFGr16 >> 8);
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+2));
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*pScanline    );
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCb16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+3);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (*pScanline,     *(pDataline+2), iFGa8, *pScanline    );
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *pDataline,     iFGa8, *(pScanline+2));
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+2), *(pScanline+1), *pScanline,     iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCb8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCr8;
+                *(pScanline+3) = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgra8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+2*iBps);
+          *(pScanline+1) = *(pDataline+iBps);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = *(pDataline+3*iBps);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+3));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *(pDataline+4);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                       /* scale background up */
+                iBGg16 = (mng_uint16)(*(pScanline+2-i));
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                                       /* and return the composed values */
+                *(pScanline+2-i) = (mng_uint8)(iFGg16 >> 8);
+                                       /* alpha remains fully opaque !!! */
+              }
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+2));
+                iBGg16 = (mng_uint16)(*(pScanline+1));
+                iBGb16 = (mng_uint16)(*pScanline    );
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCb16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCr16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+3);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                MNG_COMPOSE8 (*(pScanline+i), *(pDataline+2-i), iFGa8, *(pScanline+i));
+                }
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+2), *(pScanline+1), *pScanline,     iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCb8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCr8;
+                *(pScanline+3) = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgra8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+2);
+          *(pScanline+1) = *(pDataline+1);
+          *(pScanline+2) = *pDataline;
+          *(pScanline+3) = *(pDataline+3);
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+3);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+2);
+              *(pScanline+1) = *(pDataline+1);
+              *(pScanline+2) = *pDataline;
+              *(pScanline+3) = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                MNG_COMPOSE8 (*(pScanline+i), *(pDataline+2-i), iFGa8, *(pScanline+i));
+                }
+#else
+                MNG_COMPOSE8 (*pScanline,     *(pDataline+2), iFGa8, *pScanline    );
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+1), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *pDataline,     iFGa8, *(pScanline+2));
+#endif
+                                       /* alpha remains fully opaque !!! */
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+2), *(pScanline+1), *pScanline,     iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCb8;
+                *(pScanline+1) = iCg8;
+                *(pScanline+2) = iCr8;
+                *(pScanline+3) = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGRA8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGRA8_PM
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgra8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          if ((s = pDataline[6]) == 0)
+            *(mng_uint32*) pScanline = 0; /* set all components = 0 */
+          else
+          {
+            if (s == 255)
+            {
+              pScanline[0] = pDataline[4];
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {
+              pScanline[0] = DIV255B8(s * pDataline[4]);
+              pScanline[1] = DIV255B8(s * pDataline[2]);
+              pScanline[2] = DIV255B8(s * pDataline[0]);
+              pScanline[3] = (mng_uint8)s;
+            }
+          }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+          if ((s = pDataline[3]) == 0)
+            *(mng_uint32*) pScanline = 0; /* set all components = 0 */
+          else
+          {
+            if (s == 255)
+            {
+              pScanline[0] = pDataline[2];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {
+              pScanline[0] = DIV255B8(s * pDataline[2]);
+              pScanline[1] = DIV255B8(s * pDataline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0]);
+              pScanline[3] = (mng_uint8)s;
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = pDataline[4];
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {                          /* now blend (premultiplied) */
+              t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[4] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[2] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = pDataline[2];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {                          /* now blend (premultiplied) */
+              t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[2] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgra8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8PM, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          if ((s = pDataline[6]) == 0)
+            *(mng_uint32*) pScanline = 0; /* set all components = 0 */
+          else
+          {
+            if (s == 255)
+            {
+              pScanline[0] = pDataline[4];
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[i] = DIV255B8(s * pDataline[4-i-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[4]);
+              pScanline[1] = DIV255B8(s * pDataline[2]);
+              pScanline[2] = DIV255B8(s * pDataline[0]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+            }
+          }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+          if ((s = pDataline[3]) == 0)
+            *(mng_uint32*) pScanline = 0; /* set all components = 0 */
+          else
+          {
+            if (s == 255)
+            {
+              pScanline[0] = pDataline[2];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[i] = DIV255B8(s * pDataline[2-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[2]);
+              pScanline[1] = DIV255B8(s * pDataline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = pDataline[4];
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {                          /* now blend (premultiplied) */
+              t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[4] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[2] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = pDataline[2];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {                          /* now blend (premultiplied) */
+              t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[2] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgra8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+          if ((s = pDataline[3]) == 0)
+            *(mng_uint32*) pScanline = 0; /* set all components = 0 */
+          else
+          {
+            if (s == 255)
+            {
+              pScanline[0] = pDataline[2];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                pScanline[i] = DIV255B8(s * pDataline[2-i]);
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[2]);
+              pScanline[1] = DIV255B8(s * pDataline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0]);
+#endif
+              pScanline[3] = (mng_uint8)s;
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = pDataline[2];
+              pScanline[1] = pDataline[1];
+              pScanline[2] = pDataline[0];
+              pScanline[3] = 255;
+            }
+            else
+            {                          /* now blend (premultiplied) */
+              t = 255 - s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[i]);
+                }
+              }
+#else
+              pScanline[0] = DIV255B8(s * pDataline[2] + t * pScanline[0]);
+              pScanline[1] = DIV255B8(s * pDataline[1] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[0] + t * pScanline[2]);
+#endif
+              pScanline[3] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[3])));
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA8PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGRA8_PM */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_ABGR8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_abgr8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+6);
+          *(pScanline+1) = *(pDataline+4);
+          *(pScanline+2) = *(pDataline+2);
+          *(pScanline+3) = *pDataline;
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+3);
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *(pDataline+1);
+          *(pScanline+3) = *pDataline;
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pScanline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *(pDataline+6);
+              *(pScanline+1) = *(pDataline+4);
+              *(pScanline+2) = *(pDataline+2);
+              *(pScanline+3) = *pDataline;
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+3));
+                iBGg16 = (mng_uint16)(*(pScanline+2));
+                iBGb16 = (mng_uint16)(*(pScanline+1));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                                       /* alpha itself remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8)(iFGb16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iFGg16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iFGr16 >> 8);
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+3));
+                iBGg16 = (mng_uint16)(*(pScanline+2));
+                iBGb16 = (mng_uint16)(*(pScanline+1));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCa16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCb16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCr16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pScanline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+3);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+1);
+              *(pScanline+3) = *pDataline;
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do simple alpha composing */
+                                       /* alpha itself remains fully opaque !!! */
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+2), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *(pDataline+1), iFGa8, *(pScanline+2));
+                MNG_COMPOSE8 (*(pScanline+3), *pDataline,     iFGa8, *(pScanline+3));
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+3), *(pScanline+2), *(pScanline+1), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCa8;
+                *(pScanline+1) = iCb8;
+                *(pScanline+2) = iCg8;
+                *(pScanline+3) = iCr8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_abgr8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGg16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *pScanline     = *(pDataline+3*iBps);
+          *(pScanline+1) = *(pDataline+2*iBps);
+          *(pScanline+2) = *(pDataline+iBps);
+          *(pScanline+3) = *pDataline;
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pScanline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *pScanline     = *(pDataline+6);
+              *(pScanline+1) = *(pDataline+4);
+              *(pScanline+2) = *(pDataline+2);
+              *(pScanline+3) = *pDataline;
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+              int i;
+              for (i=2; i >= 0; i--)
+              {
+                iFGg16 = mng_get_uint16 (pDataline+i+i);
+                                       /* scale background up */
+                iBGg16 = (mng_uint16)(*(pScanline+3-i));
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                                       /* now compose */
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                                       /* and return the composed values */
+                                       /* alpha itself remains fully opaque !!! */
+                *(pScanline+3-i) = (mng_uint8)(iFGg16 >> 8);
+              }
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)(*(pScanline+3));
+                iBGg16 = (mng_uint16)(*(pScanline+2));
+                iBGb16 = (mng_uint16)(*(pScanline+1));
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *pScanline     = (mng_uint8)(iCa16 >> 8);
+                *(pScanline+1) = (mng_uint8)(iCb16 >> 8);
+                *(pScanline+2) = (mng_uint8)(iCg16 >> 8);
+                *(pScanline+3) = (mng_uint8)(iCr16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pScanline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+3);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+1);
+              *(pScanline+3) = *pDataline;
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do simple alpha composing */
+                                       /* alpha itself remains fully opaque !!! */
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                MNG_COMPOSE8 (*(pScanline+i+1), *(pDataline+2-i), iFGa8, *(pScanline+i+1));
+                }
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+3), *(pScanline+2), *(pScanline+1), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCa8;
+                *(pScanline+1) = iCb8;
+                *(pScanline+2) = iCg8;
+                *(pScanline+3) = iCr8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_abgr8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *pScanline     = *(pDataline+3);
+          *(pScanline+1) = *(pDataline+2);
+          *(pScanline+2) = *(pDataline+1);
+          *(pScanline+3) = *pDataline;
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *pScanline;
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *pScanline     = *(pDataline+3);
+              *(pScanline+1) = *(pDataline+2);
+              *(pScanline+2) = *(pDataline+1);
+              *(pScanline+3) = *pDataline;
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do simple alpha composing */
+                                       /* alpha itself remains fully opaque !!! */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                MNG_COMPOSE8 (*(pScanline+i+1), *(pDataline+2-i), iFGa8, *(pScanline+i+1));
+                }
+#else
+                MNG_COMPOSE8 (*(pScanline+1), *(pDataline+2), iFGa8, *(pScanline+1));
+                MNG_COMPOSE8 (*(pScanline+2), *(pDataline+1), iFGa8, *(pScanline+2));
+                MNG_COMPOSE8 (*(pScanline+3), *pDataline,     iFGa8, *(pScanline+3));
+#endif
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline,     *(pDataline+1), *(pDataline+2), iFGa8,
+                            *(pScanline+3), *(pScanline+2), *(pScanline+1), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *pScanline     = iCa8;
+                *(pScanline+1) = iCb8;
+                *(pScanline+2) = iCg8;
+                *(pScanline+3) = iCr8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_ABGR8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_ABGR8_PM
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_abgr8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8_PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+		  if ((s = pDataline[6]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+		      pScanline[1] = pDataline[4];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = pDataline[0];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[4-i-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[4]);
+              pScanline[2] = DIV255B8(s * pDataline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[0]);
+#endif
+			}
+		  }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+		      pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[0];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[2-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[2]);
+              pScanline[2] = DIV255B8(s * pDataline[1]);
+		      pScanline[3] = DIV255B8(s * pDataline[0]);
+#endif
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[4];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = pDataline[0];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[i+1]);
+                }
+              }
+#else
+			  pScanline[1] = DIV255B8(s * pDataline[4] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[2] + t * pScanline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[0] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[0];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[i+1]);
+                }
+              }
+#else
+			  pScanline[1] = DIV255B8(s * pDataline[2] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[1] + t * pScanline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[0] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_abgr8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8_PM, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+		  if ((s = pDataline[6]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+		      pScanline[1] = pDataline[4];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = pDataline[0];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[4-i-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[4]);
+              pScanline[2] = DIV255B8(s * pDataline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[0]);
+#endif
+			}
+		  }
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+		      pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[0];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[2-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[2]);
+              pScanline[2] = DIV255B8(s * pDataline[1]);
+		      pScanline[3] = DIV255B8(s * pDataline[0]);
+#endif
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          if ((s = pDataline[6]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if (s == 255)
+            {                          /* plain copy it */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[4];
+              pScanline[2] = pDataline[2];
+              pScanline[3] = pDataline[0];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[4-i-i] + t *
+                     pScanline[i+1]);
+                }
+              }
+#else
+			  pScanline[1] = DIV255B8(s * pDataline[4] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[2] + t * pScanline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[0] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[0];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[i+1]);
+                }
+              }
+#else
+			  pScanline[1] = DIV255B8(s * pDataline[2] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[1] + t * pScanline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[0] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_abgr8_pm (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint32 s, t;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8_PM, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl << 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values and premultiply */
+		  if ((s = pDataline[3]) == 0)
+			*(mng_uint32*) pScanline = 0; /* set all components = 0 */
+		  else
+		  {
+			if (s == 255)
+			{
+              pScanline[0] = 255;
+		      pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[0];
+			}
+			else
+			{
+              pScanline[0] = (mng_uint8)s;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[2-i]);
+                }
+              }
+#else
+              pScanline[1] = DIV255B8(s * pDataline[2]);
+              pScanline[2] = DIV255B8(s * pDataline[1]);
+		      pScanline[3] = DIV255B8(s * pDataline[0]);
+#endif
+			}
+		  }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          if ((s = pDataline[3]) != 0)       /* any opacity at all ? */
+          {                            /* fully opaque ? */
+            if (s == 255)
+            {                          /* then simply copy the values */
+              pScanline[0] = 255;
+              pScanline[1] = pDataline[2];
+              pScanline[2] = pDataline[1];
+              pScanline[3] = pDataline[0];
+            }
+            else
+            {                          /* now blend (premultiplied) */
+			  t = 255 - s;
+              pScanline[0] = (mng_uint8)(255 - DIV255B8(t * (255 - pScanline[0])));
+#ifdef MNG_OPTIMIZE_FOOTPRINT_DIV
+              {
+                int i;
+                for (i=2; i >= 0; i--)
+                {
+                  pScanline[i+1] = DIV255B8(s * pDataline[2-i] + t *
+                     pScanline[i+1]);
+                }
+              }
+#else
+			  pScanline[1] = DIV255B8(s * pDataline[2] + t * pScanline[1]);
+              pScanline[2] = DIV255B8(s * pDataline[1] + t * pScanline[2]);
+              pScanline[3] = DIV255B8(s * pDataline[0] + t * pScanline[3]);
+#endif
+            }
+          }
+
+          pScanline += (pData->iColinc << 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_ABGR8_PM, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_ABGR8_PM */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGR565
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgr565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 ) | (   (*(pDataline+2)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline+4)) >>3) | (   (*(pDataline+2)&0xFC) << 3) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 )  |  ( (*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline+2) >>3 )  |  ( (*(pDataline+1)&0xFC ) << 3) );
+
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline))&0xF8 )  |  (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline+4)) >>3)  |  (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+
+              iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+              iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+              iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8) ( ( (iFGr16 >> 8)&0xF8 )  |  ( (mng_uint8)(iFGg16>>8) >> 5)      );
+              *pScanline     = (mng_uint8) ( ( (iFGb16>>11)       )  |  (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+              MNG_COMPOSE8 (iRed,     *pDataline,     iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  |   (iGreen>>5) );
+              *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ( (iGreen & 0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgr565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 ) |
+           (   (*(pDataline+iBps)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline+2*iBps)) >>3) |
+           (   (*(pDataline+iBps)&0xFC) << 3) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline))&0xF8 )  |  (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline+4)) >>3)  |  (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+
+              iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+              iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+              iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8) ( ( (iFGr16 >> 8)&0xF8 )  |  ( (mng_uint8)(iFGg16>>8) >> 5)      );
+              *pScanline     = (mng_uint8) ( ( (iFGb16>>11)       )  |  (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+              MNG_COMPOSE8 (iRed,     *pDataline,     iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  |   (iGreen>>5) );
+              *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ( (iGreen & 0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgr565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 )  |  ( (*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline+2) >>3 )  |  ( (*(pDataline+1)&0xFC ) << 3) );
+
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+              MNG_COMPOSE8 (iRed,     *pDataline,     iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  |   (iGreen>>5) );
+              *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ( (iGreen & 0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGR565 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGB565
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_rgb565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( ( *(pDataline+4)) & 0xF8)  |   (*(pDataline+2) >> 5  )       );
+          *pScanline     = (mng_uint8)( ( ( *(pDataline  )) >> 3  )  |  ((*(pDataline+2) & 0xFC) << 3) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2)) & 0xF8)  |   (*(pDataline+1) >> 5        ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline  )  >> 3  )  |  ((*(pDataline+1) & 0xFC) << 3) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( ( (*(pDataline+4)) & 0xF8)  |   (*(pDataline+2)>>5) );
+              *pScanline     = (mng_uint8)( ( (*(pDataline  )) >> 3  )  |  ((*(pDataline+2)&0xFC) << 3) );
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+
+			                           /* scale background up */
+              iBGr16 = (mng_uint8)(  *(pScanline+1) & 0xF8 );
+              iBGg16 = (mng_uint8)( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0) >> 3 ) );
+              iBGb16 = (mng_uint8)(  *(pScanline  ) << 3   );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8)( (mng_uint8)((iFGb16 >> 8) &0xF8) |   (   (mng_uint8)(iFGg16 >> 8) >> 5  )        );
+              *pScanline     = (mng_uint8)( (mng_uint8) (iFGr16 >>11)        |   ( ( (mng_uint8)(iFGg16 >> 8) & 0xFC) << 3)  );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2)) & 0xF8)  |  (  *(pDataline+1) >> 5         ) );
+              *pScanline     = (mng_uint8)( ( (*(pDataline  )) >> 3  )  |  ( (*(pDataline+1) & 0xFC) << 3 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)(   *(pScanline+1) & 0xF8);
+              iGreen = (mng_uint8)( ( *(pScanline+1) << 5  )  |  ( ( (*pScanline)&0xE0)>>3 ) );
+              iBlue  = (mng_uint8)(   *(pScanline  ) << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+2), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+0), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( iRed & 0xF8)  |  (  iGreen >> 5        ) );
+              *pScanline     = (mng_uint8)( (iBlue >> 3  )  |  ( (iGreen & 0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_rgb565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB565, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( ( *(pDataline+2*iBps)) & 0xF8)  |
+              (*(pDataline+iBps) >> 5  )       );
+          *pScanline     = (mng_uint8)( ( ( *(pDataline  )) >> 3  )  |
+             ((*(pDataline+iBps) & 0xFC) << 3) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( ( (*(pDataline+4)) & 0xF8)  |   (*(pDataline+2)>>5) );
+              *pScanline     = (mng_uint8)( ( (*(pDataline  )) >> 3  )  |  ((*(pDataline+2)&0xFC) << 3) );
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+
+			                           /* scale background up */
+              iBGr16 = (mng_uint8)(  *(pScanline+1) & 0xF8 );
+              iBGg16 = (mng_uint8)( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0) >> 3 ) );
+              iBGb16 = (mng_uint8)(  *(pScanline  ) << 3   );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8)( (mng_uint8)((iFGb16 >> 8) &0xF8) |   (   (mng_uint8)(iFGg16 >> 8) >> 5  )        );
+              *pScanline     = (mng_uint8)( (mng_uint8) (iFGr16 >>11)        |   ( ( (mng_uint8)(iFGg16 >> 8) & 0xFC) << 3)  );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2)) & 0xF8)  |  (  *(pDataline+1) >> 5         ) );
+              *pScanline     = (mng_uint8)( ( (*(pDataline  )) >> 3  )  |  ( (*(pDataline+1) & 0xFC) << 3 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)(   *(pScanline+1) & 0xF8);
+              iGreen = (mng_uint8)( ( *(pScanline+1) << 5  )  |  ( ( (*pScanline)&0xE0)>>3 ) );
+              iBlue  = (mng_uint8)(   *(pScanline  ) << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+2), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+0), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( iRed & 0xF8)  |  (  iGreen >> 5        ) );
+              *pScanline     = (mng_uint8)( (iBlue >> 3  )  |  ( (iGreen & 0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_rgb565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2)) & 0xF8)  |   (*(pDataline+1) >> 5        ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline  )  >> 3  )  |  ((*(pDataline+1) & 0xFC) << 3) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2)) & 0xF8)  |  (  *(pDataline+1) >> 5         ) );
+              *pScanline     = (mng_uint8)( ( (*(pDataline  )) >> 3  )  |  ( (*(pDataline+1) & 0xFC) << 3 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)(   *(pScanline+1) & 0xF8);
+              iGreen = (mng_uint8)( ( *(pScanline+1) << 5  )  |  ( ( (*pScanline)&0xE0)>>3 ) );
+              iBlue  = (mng_uint8)(   *(pScanline  ) << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+2), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+0), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( iRed & 0xF8)  |  (  iGreen >> 5        ) );
+              *pScanline     = (mng_uint8)( (iBlue >> 3  )  |  ( (iGreen & 0xFC) << 3) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_RGB565 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGRA565
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgra565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 ) | (   (*(pDataline+2)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline+4)) >>3) | (   (*(pDataline+2)&0xFC) << 3) );
+          *(pScanline+2) = *(pDataline+6);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 )  |  ( (*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline+2) >>3 )  |  ( (*(pDataline+1)&0xFC ) << 3) );
+          *(pScanline+2) = *(pDataline+3);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+2));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline))&0xF8 )  |  (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline+4)) >>3)  |  (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+			  *(pScanline+2) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iFGr16 >> 8)&0xF8 )  |  ( (mng_uint8)(iFGg16>>8) >> 5)      );
+                *pScanline     = (mng_uint8) ( ( (iFGb16>>11)       )  |  (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+              }
+              else
+              {                        /* scale background up */
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iCr16 >>  8) & 0xF8 )  |  ( (mng_uint8)(iCg16 >> 8) >> 5  )       );
+                *pScanline     = (mng_uint8) ( ( (iCb16 >> 11)        )  |  (((mng_uint8)(iCg16 >> 8) & 0xFC) << 3) );
+                *(pScanline+2) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+2);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+              *(pScanline+2) = *(pDataline+3);
+            }
+            else
+            {
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (iRed,   *pDataline,     iFGa8, iRed   );
+                MNG_COMPOSE8 (iGreen, *(pDataline+1), iFGa8, iGreen );
+                MNG_COMPOSE8 (iBlue,  *(pDataline+2), iFGa8, iBlue  );
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  |   (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ( (iGreen & 0xFC) << 3) );
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            iRed      , iGreen        , iBlue         , iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+
+
+                *pScanline     = (mng_uint8) ( ( iCb8 >>  3  )  | ( (iCg8 & 0xFC) << 3) );
+                *(pScanline+1) = (mng_uint8) ( ( iCr8  & 0xF8 )  |   (iCg8>>5) );
+				*(pScanline+2) = (mng_uint8) iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc *3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgra565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA565, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 ) |
+              (   (*(pDataline+iBps)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline+2*iBps)) >>3) |
+              (   (*(pDataline+iBps)&0xFC) << 3) );
+          *(pScanline+2) = *(pDataline+3*iBps);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+2));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline))&0xF8 )  |  (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline+4)) >>3)  |  (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+			  *(pScanline+2) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iFGr16 >> 8)&0xF8 )  |  ( (mng_uint8)(iFGg16>>8) >> 5)      );
+                *pScanline     = (mng_uint8) ( ( (iFGb16>>11)       )  |  (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+              }
+              else
+              {                        /* scale background up */
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iCr16 >>  8) & 0xF8 )  |  ( (mng_uint8)(iCg16 >> 8) >> 5  )       );
+                *pScanline     = (mng_uint8) ( ( (iCb16 >> 11)        )  |  (((mng_uint8)(iCg16 >> 8) & 0xFC) << 3) );
+                *(pScanline+2) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+2);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+              *(pScanline+2) = *(pDataline+3);
+            }
+            else
+            {
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (iRed,   *pDataline,     iFGa8, iRed   );
+                MNG_COMPOSE8 (iGreen, *(pDataline+1), iFGa8, iGreen );
+                MNG_COMPOSE8 (iBlue,  *(pDataline+2), iFGa8, iBlue  );
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  |   (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ( (iGreen & 0xFC) << 3) );
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            iRed      , iGreen        , iBlue         , iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+
+
+                *pScanline     = (mng_uint8) ( ( iCb8 >>  3  )  | ( (iCg8 & 0xFC) << 3) );
+                *(pScanline+1) = (mng_uint8) ( ( iCr8  & 0xF8 )  |   (iCg8>>5) );
+				*(pScanline+2) = (mng_uint8) iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc *3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgra565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 )  |  ( (*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline+2) >>3 )  |  ( (*(pDataline+1)&0xFC ) << 3) );
+          *(pScanline+2) = *(pDataline+3);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+2);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+              *(pScanline+2) = *(pDataline+3);
+            }
+            else
+            {
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (iRed,   *pDataline,     iFGa8, iRed   );
+                MNG_COMPOSE8 (iGreen, *(pDataline+1), iFGa8, iGreen );
+                MNG_COMPOSE8 (iBlue,  *(pDataline+2), iFGa8, iBlue  );
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  |   (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ( (iGreen & 0xFC) << 3) );
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            iRed      , iGreen        , iBlue         , iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+
+
+                *pScanline     = (mng_uint8) ( ( iCb8 >>  3  )  | ( (iCg8 & 0xFC) << 3) );
+                *(pScanline+1) = (mng_uint8) ( ( iCr8  & 0xF8 )  |   (iCg8>>5) );
+				*(pScanline+2) = (mng_uint8) iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc *3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGRA565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGRA565 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGBA565
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_rgba565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline+4))&0xF8 ) | (   (*(pDataline+2)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline)) >>3) | (   (*(pDataline+2)&0xFC) << 3) );
+          *(pScanline+2) = *(pDataline+6);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2))&0xF8 )  |  ( (*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline) >>3 )  |  ( (*(pDataline+1)&0xFC ) << 3) );
+          *(pScanline+2) = *(pDataline+3);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+2));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline+4))&0xF8 )  |  (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline)) >>3)  |  (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+			  *(pScanline+2) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGr16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGb16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iFGb16 >> 8)&0xF8 )  |  ( (mng_uint8)(iFGg16>>8) >> 5)      );
+                *pScanline     = (mng_uint8) ( ( (iFGr16>>11)       )  |  (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGb16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iCb16 >>  8) & 0xF8 )  |  ( (mng_uint8)(iCg16 >> 8) >> 5  )       );
+                *pScanline     = (mng_uint8) ( ( (iCr16 >> 11)        )  |  (((mng_uint8)(iCg16 >> 8) & 0xFC) << 3) );
+                *(pScanline+2) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+2);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline+2)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+              *(pScanline+2) = *(pDataline+3);
+            }
+            else
+            {
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iBlue   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iRed  = (mng_uint8) ( (*pScanline << 3) );
+
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (iRed,   *pDataline,     iFGa8, iRed   );
+                MNG_COMPOSE8 (iGreen, *(pDataline+1), iFGa8, iGreen );
+                MNG_COMPOSE8 (iBlue,  *(pDataline+2), iFGa8, iBlue  );
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8) ( ( iBlue  & 0xF8 )  |   (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iRed >>  3  )  | ( (iGreen & 0xFC) << 3) );
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            iRed      , iGreen        , iBlue         , iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+
+
+                *pScanline     = (mng_uint8) ( ( iCr8 >>  3  )  | ( (iCg8 & 0xFC) << 3) );
+                *(pScanline+1) = (mng_uint8) ( ( iCb8  & 0xF8 )  |   (iCg8>>5) );
+				*(pScanline+2) = (mng_uint8) iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc *3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_rgba565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint16 iFGa16, iBGa16, iCa16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint16 iCr16, iCg16, iCb16;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA565, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2*iBps))&0xF8 ) |
+             (   (*(pDataline+iBps)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline)) >>3) |
+             (   (*(pDataline+iBps)&0xFC) << 3) );
+          *(pScanline+2) = *(pDataline+3*iBps);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* get alpha values */
+          iFGa16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*(pScanline+2));
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iFGa16)                  /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+            {                          /* plain copy it */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline+4))&0xF8 )  |  (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline)) >>3)  |  (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+			  *(pScanline+2) = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                       /* scale background up */
+                iBGr16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGb16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+
+                                       /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iFGa16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iFGa16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iFGa16, iBGb16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iFGb16 >> 8)&0xF8 )  |  ( (mng_uint8)(iFGg16>>8) >> 5)      );
+                *pScanline     = (mng_uint8) ( ( (iFGr16>>11)       )  |  (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+              }
+              else
+              {                        /* scale background up */
+                iBGr16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  |  (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGb16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+				iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iFGa16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iCb16 >>  8) & 0xF8 )  |  ( (mng_uint8)(iCg16 >> 8) >> 5  )       );
+                *pScanline     = (mng_uint8) ( ( (iCr16 >> 11)        )  |  (((mng_uint8)(iCg16 >> 8) & 0xFC) << 3) );
+                *(pScanline+2) = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+2);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline+2)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+              *(pScanline+2) = *(pDataline+3);
+            }
+            else
+            {
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iBlue   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iRed  = (mng_uint8) ( (*pScanline << 3) );
+
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (iRed,   *pDataline,     iFGa8, iRed   );
+                MNG_COMPOSE8 (iGreen, *(pDataline+1), iFGa8, iGreen );
+                MNG_COMPOSE8 (iBlue,  *(pDataline+2), iFGa8, iBlue  );
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8) ( ( iBlue  & 0xF8 )  |   (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iRed >>  3  )  | ( (iGreen & 0xFC) << 3) );
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            iRed      , iGreen        , iBlue         , iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+
+
+                *pScanline     = (mng_uint8) ( ( iCr8 >>  3  )  | ( (iCg8 & 0xFC) << 3) );
+                *(pScanline+1) = (mng_uint8) ( ( iCb8  & 0xF8 )  |   (iCg8>>5) );
+				*(pScanline+2) = (mng_uint8) iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc *3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_rgba565 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iFGa8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA565, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol << 2) + (pData->iDestl * 3);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline+2))&0xF8 )  |  ( (*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline) >>3 )  |  ( (*(pDataline+1)&0xFC ) << 3) );
+          *(pScanline+2) = *(pDataline+3);
+
+          pScanline += (pData->iColinc * 3);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iFGa8 = *(pDataline+3);      /* get alpha values */
+          iBGa8 = *(pScanline+2);
+
+          if (iFGa8)                   /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline+2)) &0xF8 )  |   (*(pDataline+1) >>5 )       );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline))>>3) )  |  ((*(pDataline+1)&0xFC) << 3) );
+              *(pScanline+2) = *(pDataline+3);
+            }
+            else
+            {
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iBlue   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+              iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  ( ((*pScanline) & 0xE0)>>3 ) );
+              iRed  = (mng_uint8) ( (*pScanline << 3) );
+
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {                        /* do alpha composing */
+                MNG_COMPOSE8 (iRed,   *pDataline,     iFGa8, iRed   );
+                MNG_COMPOSE8 (iGreen, *(pDataline+1), iFGa8, iGreen );
+                MNG_COMPOSE8 (iBlue,  *(pDataline+2), iFGa8, iBlue  );
+                                       /* alpha remains fully opaque !!! */
+                *(pScanline+1) = (mng_uint8) ( ( iBlue  & 0xF8 )  |   (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iRed >>  3  )  | ( (iGreen & 0xFC) << 3) );
+              }
+              else
+              {                        /* now blend */
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iFGa8,
+                            iRed      , iGreen        , iBlue         , iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+
+
+                *pScanline     = (mng_uint8) ( ( iCr8 >>  3  )  | ( (iCg8 & 0xFC) << 3) );
+                *(pScanline+1) = (mng_uint8) ( ( iCb8  & 0xF8 )  |   (iCg8>>5) );
+				*(pScanline+2) = (mng_uint8) iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc *3);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGBA565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_RGBA565 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGR565_A8
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgr565_a8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pAlphaline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16, iBGa16;
+  mng_uint16 iCr16,  iCg16,  iCb16,  iCa16;
+  mng_uint8  iA8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565_A8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+    pAlphaline = (mng_uint8p)pData->fGetalphaline  (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+                                       /* adjust destination row
+starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pAlphaline = pAlphaline + pData->iCol + pData->iDestl;
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)       /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 ) | ((*(pDataline+2)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline+4)) >>3) | ((*(pDataline+2)&0xFC) << 3) );
+          *pAlphaline    = (mng_uint8)(*(pDataline+6));
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 )  |  ((*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline+2) >>3 )  |  ((*(pDataline+1)&0xFC ) << 3) );
+          *pAlphaline    = (mng_uint8)(*(pDataline+3));
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 4;
+        }
+      }
+    }
+    else /* Not fully opaque */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pAlphaline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if ((iA16 == 0xFFFF) || (iBGa16 == 0))       /* fully opaque or background fully transparent ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline))&0xF8 )  | (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline+4)) >>3)  | (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+              *pAlphaline    = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {
+                                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                         /* scale background up */
+
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  | (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                         /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                         /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iFGr16 >> 8)&0xF8 )  | ( (mng_uint8)(iFGg16>>8) >> 5)       );
+                *pScanline     = (mng_uint8) ( ( (iFGb16>>11)       )  | (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+                *pAlphaline    = (mng_uint8)(iA16>>8);
+              }
+              else /* background is not fully opaque */
+              {                         /* scale background up */
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  | (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iA16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iCr16 >> 8)&0xF8 )  | ( (mng_uint8)(iCg16>>8) >> 5)       );
+                *pScanline     = (mng_uint8) ( ( (iCb16>>11)       )  | (((mng_uint8)(iCg16>>8)&0xFC) << 3) );
+                *pAlphaline    = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+          iBGa8 = *pAlphaline;
+
+          if (iA8)                     /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iA8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  | (*(pDataline+1) >>5 )        );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  | ((*(pDataline+1)&0xFC) << 3) );
+              *pAlphaline    = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {
+                /* do alpha composing */
+                mng_uint8 iRed, iGreen, iBlue;
+
+                iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+                iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  (((*pScanline) & 0xE0)>>3 ) );
+                iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+                MNG_COMPOSE8 (iRed,     *pDataline,     iA8, iRed    );
+                MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+                MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+                *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  | (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ((iGreen & 0xFC) << 3) );
+                *pAlphaline    = iA8;
+              }
+              else /* background not fully opaque */
+              {
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iA8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( iCr8  & 0xF8 )  | (iCg8>>5) );
+                *pScanline     = (mng_uint8) ( ( iCb8 >>  3  )  | ((iCg8 & 0xFC) << 3) );
+                *pAlphaline    = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgr565_a8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pAlphaline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16, iBGa16;
+  mng_uint16 iCr16,  iCg16,  iCb16,  iCa16;
+  mng_uint8  iA8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+  mng_uint8  iBps;
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565_A8, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+    pAlphaline = (mng_uint8p)pData->fGetalphaline  (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+                                       /* adjust destination row
+starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pAlphaline = pAlphaline + pData->iCol + pData->iDestl;
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 ) |
+              ((*(pDataline+iBps)>>5)       ) );
+          *pScanline     = (mng_uint8)( ( (*(pDataline+2*iBps)) >>3) |
+              ((*(pDataline+iBps)&0xFC) << 3) );
+          *pAlphaline    = (mng_uint8)(*(pDataline+6));
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 8;
+        }
+    }
+    else /* Not fully opaque */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+          iBGa16 = (mng_uint16)(*pAlphaline);
+          iBGa16 = (mng_uint16)(iBGa16 << 8) | iBGa16;
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if ((iA16 == 0xFFFF) || (iBGa16 == 0))       /* fully opaque or background fully transparent ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( (*(pDataline))&0xF8 )  | (mng_uint8)( (*(pDataline+2)>>5  )     );
+              *pScanline     = (mng_uint8)( (*(pDataline+4)) >>3)  | (mng_uint8)( (*(pDataline+2)&0xFC) << 3);
+              *pAlphaline    = *(pDataline+6);
+            }
+            else
+            {
+              if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+              {
+                                        /* get the proper values */
+                iFGr16 = mng_get_uint16 (pDataline  );
+                iFGg16 = mng_get_uint16 (pDataline+2);
+                iFGb16 = mng_get_uint16 (pDataline+4);
+                                         /* scale background up */
+
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  | (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                         /* now compose */
+                MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+                MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+                MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                         /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iFGr16 >> 8)&0xF8 )  | ( (mng_uint8)(iFGg16>>8) >> 5)       );
+                *pScanline     = (mng_uint8) ( ( (iFGb16>>11)       )  | (((mng_uint8)(iFGg16>>8)&0xFC) << 3) );
+                *pAlphaline    = (mng_uint8)(iA16>>8);
+              }
+              else /* background is not fully opaque */
+              {                         /* scale background up */
+                iBGb16 = (mng_uint16)( (*(pScanline+1)) & 0xF8 );
+                iBGg16 = (mng_uint16)( (*(pScanline+1) << 5)  | (((*(pScanline  )) & 0xE0) >>3 ) );
+                iBGr16 = (mng_uint16)( (*(pScanline  )) << 3   );
+
+                iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+                iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+                iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* let's blend */
+                MNG_BLEND16 (mng_get_uint16 (pDataline  ),
+                             mng_get_uint16 (pDataline+2),
+                             mng_get_uint16 (pDataline+4), iA16,
+                             iBGr16, iBGg16, iBGb16, iBGa16,
+                             iCr16,  iCg16,  iCb16,  iCa16);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( (iCr16 >> 8)&0xF8 )  | ( (mng_uint8)(iCg16>>8) >> 5)       );
+                *pScanline     = (mng_uint8) ( ( (iCb16>>11)       )  | (((mng_uint8)(iCg16>>8)&0xFC) << 3) );
+                *pAlphaline    = (mng_uint8)(iCa16 >> 8);
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+          iBGa8 = *pAlphaline;
+
+          if (iA8)                     /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iA8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  | (*(pDataline+1) >>5 )        );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  | ((*(pDataline+1)&0xFC) << 3) );
+              *pAlphaline    = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {
+                /* do alpha composing */
+                mng_uint8 iRed, iGreen, iBlue;
+
+                iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+                iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  (((*pScanline) & 0xE0)>>3 ) );
+                iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+                MNG_COMPOSE8 (iRed,     *pDataline,     iA8, iRed    );
+                MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+                MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+                *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  | (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ((iGreen & 0xFC) << 3) );
+                *pAlphaline    = iA8;
+              }
+              else /* background not fully opaque */
+              {
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iA8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( iCr8  & 0xF8 )  | (iCg8>>5) );
+                *pScanline     = (mng_uint8) ( ( iCb8 >>  3  )  | ((iCg8 & 0xFC) << 3) );
+                *pAlphaline    = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgr565_a8 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pAlphaline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8, iBGa8, iCa8;
+  mng_uint8  iCr8, iCg8, iCb8;
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565_A8, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+    pAlphaline = (mng_uint8p)pData->fGetalphaline  (((mng_handle)pData),
+                                                    pData->iRow + pData->iDestt -
+                                                    pData->iSourcet);
+                                       /* adjust destination row
+starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pAlphaline = pAlphaline + pData->iCol + pData->iDestl;
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ( (*(pDataline))&0xF8 )  |  ((*(pDataline+1)>>5   )     ) );
+          *pScanline     = (mng_uint8)( (  *(pDataline+2) >>3 )  |  ((*(pDataline+1)&0xFC ) << 3) );
+          *pAlphaline    = (mng_uint8)(*(pDataline+3));
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 4;
+        }
+      }
+    }
+    else /* Not fully opaque */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+          iBGa8 = *pAlphaline;
+
+          if (iA8)                     /* any opacity at all ? */
+          {                            /* fully opaque or background fully transparent ? */
+            if ((iA8 == 0xFF) || (iBGa8 == 0))
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( (  (*(pDataline)) &0xF8 )  | (*(pDataline+1) >>5 )        );
+              *pScanline     = (mng_uint8)( ( ((*(pDataline+2))>>3) )  | ((*(pDataline+1)&0xFC) << 3) );
+              *pAlphaline    = *(pDataline+3);
+            }
+            else
+            {
+              if (iBGa8 == 0xFF)       /* background fully opaque ? */
+              {
+                /* do alpha composing */
+                mng_uint8 iRed, iGreen, iBlue;
+
+                iRed   = (mng_uint8) (  *(pScanline+1) & 0xF8 );
+                iGreen = (mng_uint8) ( (*(pScanline+1) << 5)  |  (((*pScanline) & 0xE0)>>3 ) );
+                iBlue  = (mng_uint8) ( (*pScanline << 3) );
+
+                MNG_COMPOSE8 (iRed,     *pDataline,     iA8, iRed    );
+                MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+                MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+                *(pScanline+1) = (mng_uint8) ( ( iRed  & 0xF8 )  | (iGreen>>5) );
+                *pScanline     = (mng_uint8) ( ( iBlue >>  3  )  | ((iGreen & 0xFC) << 3) );
+                *pAlphaline    = iA8;
+              }
+              else /* background not fully opaque */
+              {
+                MNG_BLEND8 (*pDataline, *(pDataline+1), *(pDataline+2), iA8,
+                            *pScanline, *(pScanline+1), *(pScanline+2), iBGa8,
+                            iCr8, iCg8, iCb8, iCa8);
+                                       /* and return the composed values */
+                *(pScanline+1) = (mng_uint8) ( ( iCr8  & 0xF8 )  | (iCg8>>5) );
+                *pScanline     = (mng_uint8) ( ( iCb8 >>  3  )  | ((iCg8 & 0xFC) << 3) );
+                *pAlphaline    = iCa8;
+              }
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pAlphaline += pData->iColinc;
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR565_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGR565_A8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGB555
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_rgb555 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB555, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline+4) & 0xF8) >> 1 ) |  (*(pDataline+2)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+2) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline+2) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline+4) & 0xF8) >> 1 ) |  (*(pDataline+2)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+2) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+
+			                           /* scale background up */
+              iBGr16 = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iBGg16 = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBGb16 = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8)( (mng_uint8)(((iFGb16 >> 8) & 0xF8) >> 1 ) | (   (mng_uint8)(iFGg16 >> 8)         >> 6 ) );
+              *pScanline     = (mng_uint8)( (mng_uint8) ((iFGr16 >>11)         >> 3 ) | ( ( (mng_uint8)(iFGg16 >> 8) & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline+2) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iGreen = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBlue  = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+2), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+0), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( (iRed & 0xF8) >> 1 )  |  (  iGreen         >> 6 ) );
+              *pScanline     = (mng_uint8)(   (iBlue        >> 3 )  |  ( (iGreen & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB555, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_rgb555 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB555, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline+2*iBps) & 0xF8) >> 1 ) |  (*(pDataline+iBps)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline       )         >> 3 ) | ((*(pDataline+iBps) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline+4) & 0xF8) >> 1 ) |  (*(pDataline+2)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+2) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+
+			                           /* scale background up */
+              iBGr16 = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iBGg16 = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBGb16 = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8)( (mng_uint8)(((iFGb16 >> 8) & 0xF8) >> 1 ) | (   (mng_uint8)(iFGg16 >> 8)         >> 6 ) );
+              *pScanline     = (mng_uint8)( (mng_uint8) ((iFGr16 >>11)         >> 3 ) | ( ( (mng_uint8)(iFGg16 >> 8) & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline+2) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iGreen = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBlue  = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+2), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+0), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( (iRed & 0xF8) >> 1 )  |  (  iGreen         >> 6 ) );
+              *pScanline     = (mng_uint8)(   (iBlue        >> 3 )  |  ( (iGreen & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB555, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_rgb555 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB555, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline+2) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline+2) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline  )         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iGreen = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBlue  = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+2), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+0), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( (iRed & 0xF8) >> 1 )  |  (  iGreen         >> 6 ) );
+              *pScanline     = (mng_uint8)(   (iBlue        >> 3 )  |  ( (iGreen & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_RGB555, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_RGB555 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGR555
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+mng_retcode mng_display_bgr555 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR555, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    if (pData->bIsRGBA16)              /* adjust source row starting-point */
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 3);
+    else
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+2)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline+4)         >> 3 ) | ((*(pDataline+2) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline+2)         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+2)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline+4)         >> 3 ) | ((*(pDataline+2) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+
+			                           /* scale background up */
+              iBGb16 = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iBGg16 = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBGr16 = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8)( (mng_uint8)(((iFGr16 >> 8) & 0xF8) >> 1 ) | (   (mng_uint8)(iFGg16 >> 8)         >> 6 ) );
+              *pScanline     = (mng_uint8)( (mng_uint8) ((iFGb16 >>11)         >> 3 ) | ( ( (mng_uint8)(iFGg16 >> 8) & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline+2)         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iGreen = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBlue  = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+0), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( (iRed & 0xF8) >> 1 )  |  (  iGreen         >> 6 ) );
+              *pScanline     = (mng_uint8)(   (iBlue        >> 3 )  |  ( (iGreen & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR555, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#else /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+mng_retcode mng_display_bgr555 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint16 iA16;
+  mng_uint16 iFGr16, iFGg16, iFGb16;
+  mng_uint16 iBGr16, iBGg16, iBGb16;
+  mng_uint8  iA8;
+  mng_uint8  iBps;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR555, MNG_LC_START);
+#endif
+
+  iBps=(mng_uint8)(pData->bIsRGBA16 ? 2:1);
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+    /* adjust source row starting-point */
+    pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << (iBps+1));
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* scale down by dropping the LSB */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline       ) & 0xF8) >> 1 ) |  (*(pDataline+iBps)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline+2*iBps)         >> 3 ) | ((*(pDataline+iBps) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4*iBps;
+        }
+    }
+    else
+    {
+      if (pData->bIsRGBA16)            /* 16-bit input row ? */
+      {
+
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA16 = mng_get_uint16 (pDataline+6);
+
+          if (iA16)                    /* any opacity at all ? */
+          {
+            if (iA16 == 0xFFFF)        /* fully opaque ? */
+            {                          /* scale down by dropping the LSB */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+2)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline+4)         >> 3 ) | ((*(pDataline+2) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* get the proper values */
+              iFGr16 = mng_get_uint16 (pDataline  );
+              iFGg16 = mng_get_uint16 (pDataline+2);
+              iFGb16 = mng_get_uint16 (pDataline+4);
+
+			                           /* scale background up */
+              iBGb16 = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iBGg16 = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBGr16 = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              iBGr16 = (mng_uint16)((mng_uint32)iBGr16 << 8) | iBGr16;
+              iBGg16 = (mng_uint16)((mng_uint32)iBGg16 << 8) | iBGg16;
+              iBGb16 = (mng_uint16)((mng_uint32)iBGb16 << 8) | iBGb16;
+                                       /* now compose */
+              MNG_COMPOSE16(iFGr16, iFGr16, iA16, iBGr16);
+              MNG_COMPOSE16(iFGg16, iFGg16, iA16, iBGg16);
+              MNG_COMPOSE16(iFGb16, iFGb16, iA16, iBGb16);
+                                       /* and return the composed values */
+              *(pScanline+1) = (mng_uint8)( (mng_uint8)(((iFGr16 >> 8) & 0xF8) >> 1 ) | (   (mng_uint8)(iFGg16 >> 8)         >> 6 ) );
+              *pScanline     = (mng_uint8)( (mng_uint8) ((iFGb16 >>11)         >> 3 ) | ( ( (mng_uint8)(iFGg16 >> 8) & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 8;
+        }
+      }
+      else
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline+2)         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iGreen = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBlue  = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+0), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( (iRed & 0xF8) >> 1 )  |  (  iGreen         >> 6 ) );
+              *pScanline     = (mng_uint8)(   (iBlue        >> 3 )  |  ( (iGreen & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR555, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_OPTIMIZE_FOOTPRINT_COMPOSE */
+#else /* MNG_NO_16BIT_SUPPORT */
+mng_retcode mng_display_bgr555 (mng_datap pData)
+{
+  mng_uint8p pScanline;
+  mng_uint8p pDataline;
+  mng_int32  iX;
+  mng_uint8  iA8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR555, MNG_LC_START);
+#endif
+                                       /* viewable row ? */
+  if ((pData->iRow >= pData->iSourcet) && (pData->iRow < pData->iSourceb))
+  {                                    /* address destination row */
+    pScanline = (mng_uint8p)pData->fGetcanvasline (((mng_handle)pData),
+                                                   pData->iRow + pData->iDestt -
+                                                   pData->iSourcet);
+                                       /* adjust destination row starting-point */
+    pScanline = pScanline + (pData->iCol * 2) + (pData->iDestl * 2);
+    pDataline = pData->pRGBArow;       /* address source row */
+
+      pDataline = pDataline + ((pData->iSourcel / pData->iColinc) << 2);
+
+    if (pData->bIsOpaque)              /* forget about transparency ? */
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {                              /* copy the values */
+          *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+          *pScanline     = (mng_uint8)( ( *(pDataline+2)         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+    else
+    {
+      {
+        for (iX = pData->iSourcel + pData->iCol; iX < pData->iSourcer;
+             iX += pData->iColinc)
+        {
+          iA8 = *(pDataline+3);        /* get alpha value */
+
+          if (iA8)                     /* any opacity at all ? */
+          {
+            if (iA8 == 0xFF)           /* fully opaque ? */
+            {                          /* then simply copy the values */
+              *(pScanline+1) = (mng_uint8)( ((*(pDataline  ) & 0xF8) >> 1 ) |  (*(pDataline+1)         >> 6 ) );
+              *pScanline     = (mng_uint8)( ( *(pDataline+2)         >> 3 ) | ((*(pDataline+1) & 0xF8) << 2 ) );
+            }
+            else
+            {                          /* do alpha composing */
+              mng_uint8 iRed, iGreen, iBlue;
+
+              iRed   = (mng_uint8)( (*(pScanline+1) & 0xF8) << 1 );
+              iGreen = (mng_uint8)( (*(pScanline+1)         << 6 )  |  ( ((*pScanline) & 0xE0) >> 2 ) );
+              iBlue  = (mng_uint8)(  *(pScanline  )         << 3 );
+
+              MNG_COMPOSE8 (iRed,     *(pDataline+0), iA8, iRed    );
+              MNG_COMPOSE8 (iGreen,   *(pDataline+1), iA8, iGreen  );
+              MNG_COMPOSE8 (iBlue,    *(pDataline+2), iA8, iBlue   );
+
+              *(pScanline+1) = (mng_uint8)( ( (iRed & 0xF8) >> 1 )  |  (  iGreen         >> 6 ) );
+              *pScanline     = (mng_uint8)(   (iBlue        >> 3 )  |  ( (iGreen & 0xF8) << 2 ) );
+            }
+          }
+
+          pScanline += (pData->iColinc * 2);
+          pDataline += 4;
+        }
+      }
+    }
+  }
+
+  check_update_region (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_BGR555, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_SKIPCANVAS_BGR555 */
+
+
+#ifndef MNG_SKIPCHUNK_BACK
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Background restore routines - restore the background with info from    * */
+/* * the BACK and/or bKGD chunk or the app's background canvas              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_restore_bkgd_backimage (mng_datap pData)
+{
+                                       /* save some stuff */
+  mng_uint8p  pRGBArow    = pData->pRGBArow;
+  mng_int32   iRow        = pData->iRow;
+  mng_int32   iRowsamples = pData->iRowsamples;
+
+  mng_retcode iRetcode;                /* work variables */
+  mng_uint8p  pTemp;
+  mng_uint8p  pWork       = pRGBArow;
+  mng_uint32  iX;
+  mng_int32   iZ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BACKIMAGE, MNG_LC_START);
+#endif
+                                       /* determine row to retrieve */
+  pData->iRow        = pData->iDestt + iRow + pData->iBackimgoffsy;
+
+  while (pData->iRow >= (mng_int32)pData->iBackimgheight)
+    pData->iRow -= (mng_int32)pData->iBackimgheight;
+                                       /* set width to that of background image */
+  pData->iRowsamples = pData->iBackimgwidth;
+                                       /* retrieve into alternate buffer ! */
+  pData->pRGBArow    = pData->pPrevrow;
+                                       /* get it then */
+  iRetcode = ((mng_retrieverow)pData->fRetrieverow) (pData);
+
+  if (iRetcode)                        /* on error; bail out */
+    return iRetcode;
+                                       /* we got the full row; but now need to
+                                          paste it into the proper location */
+  iX = pData->iDestl - pData->iBackimgoffsx;
+
+  while (iX >= pData->iBackimgwidth)
+    iX -= pData->iBackimgwidth;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+  if (pData->bIsRGBA16)                /* 16-bit buffer ? */
+  {
+    pTemp = pData->pPrevrow + (iX << 3);
+
+    for (iZ = (pData->iDestr - pData->iDestl); iZ > 0; iZ--)
+    {
+      MNG_COPY (pWork, pTemp, 8);
+
+      pWork += 8;
+      pTemp += 8;
+      iX++;
+                                       /* reached end of bkgd-image line ? */
+      if (iX >= pData->iBackimgwidth)
+      {
+        iX    = 0;
+        pTemp = pData->pPrevrow;
+      }
+    }
+  }
+  else
+#endif
+  {
+    pTemp = pData->pPrevrow + (iX << 2);
+
+    for (iZ = (pData->iDestr - pData->iDestl); iZ > 0; iZ--)
+    {
+      MNG_COPY (pWork, pTemp, 4);
+
+      pWork += 4;
+      pTemp += 4;
+      iX++;
+                                       /* reached end of bkgd-image line ? */
+      if (iX >= pData->iBackimgwidth)
+      {
+        iX    = 0;
+        pTemp = pData->pPrevrow;
+      }
+    }
+  }
+
+  pData->pRGBArow    = pRGBArow;       /* restore original values */
+  pData->iRow        = iRow;
+  pData->iRowsamples = iRowsamples;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BACKIMAGE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_restore_bkgd_backcolor (mng_datap pData)
+{
+  mng_int32   iX;
+  mng_uint32p pWork32 = (mng_uint32p)pData->pRGBArow;
+  mng_uint32  iWrite;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BACKCOLOR, MNG_LC_START);
+#endif
+
+#ifdef MNG_BIGENDIAN_SUPPORTED
+  /* fast way for big endian */
+  iWrite = (((mng_uint8)(pData->iBACKred   >> 8)) << 24) |
+		   (((mng_uint8)(pData->iBACKgreen >> 8)) << 16) |
+		   (((mng_uint8)(pData->iBACKblue  >> 8)) <<  8) |
+           ( 0xFF                                      );
+#elif defined(MNG_LITTLEENDIAN_SUPPORTED)
+  /* fast way for little endian */
+  iWrite = ( 0xFF                                 << 24) |
+           (((mng_uint8)(pData->iBACKblue  >> 8)) << 16) |
+		   (((mng_uint8)(pData->iBACKgreen >> 8)) <<  8) |
+		   (((mng_uint8)(pData->iBACKred   >> 8))      );
+#else
+  /* generic way, works on all platforms */
+  /* put the data in memory in the correct order */
+  {
+    mng_uint8 aBytes[4];
+    aBytes[0] = (mng_uint8)(pData->iBACKred   >> 8);
+    aBytes[1] = (mng_uint8)(pData->iBACKgreen >> 8);
+    aBytes[2] = (mng_uint8)(pData->iBACKblue  >> 8);
+    aBytes[3] = 0xFF;
+    /* load that data into a register */
+    iWrite = *(mng_uint32*) aBytes;
+  }
+#endif
+                                       /* ok; drop the background-color in there */
+  for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    *pWork32++ = iWrite;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BACKCOLOR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_bKGD
+mng_retcode mng_restore_bkgd_bkgd (mng_datap pData)
+{
+  mng_int32      iX;
+  mng_uint8p     pWork   = pData->pRGBArow;
+  mng_imagep     pImage  = (mng_imagep)pData->pCurrentobj;
+  mng_imagedatap pBuf    = pImage->pImgbuf;
+  mng_uint8      iRed    = 0;
+  mng_uint8      iGreen  = 0;
+  mng_uint8      iBlue   = 0;
+  mng_uint32p    pWork32 = (mng_uint32p)pWork;
+  mng_uint32     iWrite;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BKGD, MNG_LC_START);
+#endif
+
+  switch (pBuf->iColortype)
+  {
+    case 0 : ;                         /* gray types */
+    case 4 : {
+               mng_uint8 iGray;
+
+#ifndef MNG_NO_16BIT_SUPPORT
+               if (pBuf->iBitdepth > 8)
+                 iGray = (mng_uint8)(pBuf->iBKGDgray >> 8);
+               else
+#endif
+               {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+                 /* LBR scaling */
+                 mng_uint8 multiplier[]={0,255,85,0,17,0,0,0,1};
+                 iGray = (mng_uint8)(multiplier[pBuf->iBitdepth] * pBuf->iBKGDgray);
+#else
+                 iGray = (mng_uint8)pBuf->iBKGDgray;
+#endif
+               }
+
+               iRed   = iGray;
+               iGreen = iGray;
+               iBlue  = iGray;
+
+               break;
+             }
+
+    case 3 : {                         /* indexed type */
+               iRed   = pBuf->aPLTEentries [pBuf->iBKGDindex].iRed;
+               iGreen = pBuf->aPLTEentries [pBuf->iBKGDindex].iGreen;
+               iBlue  = pBuf->aPLTEentries [pBuf->iBKGDindex].iBlue;
+
+               break;
+             }
+
+    case 2 : ;                         /* rgb types */
+    case 6 : {
+#ifndef MNG_NO_16BIT_SUPPORT
+               if (pBuf->iBitdepth > 8)
+               {
+                 iRed   = (mng_uint8)(pBuf->iBKGDred   >> 8);
+                 iGreen = (mng_uint8)(pBuf->iBKGDgreen >> 8);
+                 iBlue  = (mng_uint8)(pBuf->iBKGDblue  >> 8);
+               }
+               else
+#endif
+               {
+                 iRed   = (mng_uint8)(pBuf->iBKGDred  );
+                 iGreen = (mng_uint8)(pBuf->iBKGDgreen);
+                 iBlue  = (mng_uint8)(pBuf->iBKGDblue );
+               }
+
+               break;
+             }
+  }
+
+#ifdef MNG_BIGENDIAN_SUPPORTED
+  /* fast way for big endian */
+  iWrite = (iRed   << 24) |
+		   (iGreen << 16) |
+		   (iBlue  <<  8);
+#elif defined(MNG_LITTLEENDIAN_SUPPORTED)
+  /* fast way for little endian */
+  iWrite = (iBlue  << 16) |
+		   (iGreen <<  8) |
+		   (iRed        );
+#else
+  /* generic way, works on all platforms */
+  /* put the data in memory in the correct order */
+  {
+    mng_uint8 aBytes[4];
+    aBytes[0] = (mng_uint8)(iRed);
+    aBytes[1] = (mng_uint8)(iGreen);
+    aBytes[2] = (mng_uint8)(iBlue);
+    aBytes[3] = 0x00;
+    /* load that data into a register */
+    iWrite = *(mng_uint32*) aBytes;
+  }
+#endif
+                                       /* ok; drop it in there */
+  for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    *pWork32++ = iWrite;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_restore_bkgd_bgcolor (mng_datap pData)
+{
+  mng_int32   iX;
+  mng_uint32p pWork32 = (mng_uint32p)pData->pRGBArow;
+  mng_uint32  iWrite;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGCOLOR, MNG_LC_START);
+#endif
+
+#ifdef MNG_BIGENDIAN_SUPPORTED
+  /* fast way for big endian */
+  iWrite = (((mng_uint8)(pData->iBGred   >> 8)) << 24) |
+		   (((mng_uint8)(pData->iBGgreen >> 8)) << 16) |
+		   (((mng_uint8)(pData->iBGblue  >> 8)) <<  8);
+#elif defined(MNG_LITTLEENDIAN_SUPPORTED)
+  /* fast way for little endian */
+  iWrite = (((mng_uint8)(pData->iBGblue  >> 8)) << 16) |
+		   (((mng_uint8)(pData->iBGgreen >> 8)) <<  8) |
+		   (((mng_uint8)(pData->iBGred   >> 8))      );
+#else
+  /* generic way, works on all platforms */
+  /* put the data in memory in the correct order */
+  {
+    mng_uint8 aBytes[4];
+    aBytes[0] = (mng_uint8)(pData->iBGred   >> 8);
+    aBytes[1] = (mng_uint8)(pData->iBGgreen >> 8);
+    aBytes[2] = (mng_uint8)(pData->iBGblue  >> 8);
+    aBytes[3] = 0x00;
+    /* load that data into a register */
+    iWrite = *(mng_uint32*) aBytes;
+  }
+#endif
+                                       /* ok; drop the background-color in there */
+  for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    *pWork32++ = iWrite;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGCOLOR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGB8
+mng_retcode mng_restore_bkgd_rgb8 (mng_datap pData)
+{
+  mng_int32  iX;
+  mng_uint8p pBkgd;
+  mng_uint8p pWork = pData->pRGBArow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_RGB8, MNG_LC_START);
+#endif
+
+  if (pData->fGetbkgdline)             /* can we access the background ? */
+  {                                    /* point to the right pixel then */
+    pBkgd = (mng_uint8p)pData->fGetbkgdline ((mng_handle)pData,
+                                             pData->iRow + pData->iDestt) +
+            (3 * pData->iDestl);
+
+    for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    {
+      *pWork     = *pBkgd;             /* ok; copy the pixel */
+      *(pWork+1) = *(pBkgd+1);
+      *(pWork+2) = *(pBkgd+2);
+      *(pWork+3) = 0x00;               /* transparant for alpha-canvasses */
+
+      pWork += 4;
+      pBkgd += 3;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SKIPCANVAS_RGB8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGR8
+mng_retcode mng_restore_bkgd_bgr8 (mng_datap pData)
+{
+  mng_int32  iX;
+  mng_uint8p pBkgd;
+  mng_uint8p pWork = pData->pRGBArow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGR8, MNG_LC_START);
+#endif
+
+  if (pData->fGetbkgdline)             /* can we access the background ? */
+  {                                    /* point to the right pixel then */
+    pBkgd = (mng_uint8p)pData->fGetbkgdline ((mng_handle)pData,
+                                             pData->iRow + pData->iDestt) +
+            (3 * pData->iDestl);
+
+    for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    {
+      *pWork     = *(pBkgd+2);         /* ok; copy the pixel */
+      *(pWork+1) = *(pBkgd+1);
+      *(pWork+2) = *pBkgd;
+      *(pWork+3) = 0x00;               /* transparant for alpha-canvasses */
+
+      pWork += 4;
+      pBkgd += 3;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGR8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SKIPCANVAS_BGR8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGRX8
+mng_retcode mng_restore_bkgd_bgrx8 (mng_datap pData)
+{
+  mng_int32  iX;
+  mng_uint8p pBkgd;
+  mng_uint8p pWork = pData->pRGBArow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGRX8, MNG_LC_START);
+#endif
+
+  if (pData->fGetbkgdline)             /* can we access the background ? */
+  {                                    /* point to the right pixel then */
+    pBkgd = (mng_uint8p)pData->fGetbkgdline ((mng_handle)pData,
+                                             pData->iRow + pData->iDestt) +
+            (3 * pData->iDestl);
+
+    for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    {
+      *pWork     = *(pBkgd+2);         /* ok; copy the pixel */
+      *(pWork+1) = *(pBkgd+1);
+      *(pWork+2) = *pBkgd;
+      *(pWork+3) = 0x00;               /* transparant for alpha-canvasses */
+
+      pWork += 4;
+      pBkgd += 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGRX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SKIPCANVAS_BGRX8 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_BGR565
+mng_retcode mng_restore_bkgd_bgr565 (mng_datap pData)
+{
+  mng_int32  iX;
+  mng_uint8p pBkgd;
+  mng_uint8p pWork = pData->pRGBArow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGR565, MNG_LC_START);
+#endif
+
+  if (pData->fGetbkgdline)             /* can we access the background ? */
+  {                                    /* point to the right pixel then */
+    pBkgd = (mng_uint8p)pData->fGetbkgdline ((mng_handle)pData,
+                                             pData->iRow + pData->iDestt) +
+            (3 * pData->iDestl);
+
+    for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    {
+      *pWork     = (mng_uint8)(  *(pBkgd+1) & 0xF8);             /* ok; copy the pixel */
+      *(pWork+1) = (mng_uint8)( (*(pBkgd+1) << 5 )  |  ( ((*pBkgd)&0xE0)>>3 ) );
+      *(pWork+2) = (mng_uint8)(  *(pBkgd) << 3 );
+      *(pWork+3) = 0x00;               /* transparant for alpha-canvasses */
+
+      pWork += 4;
+      pBkgd += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_BGR565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SKIPCANVAS_BGR565 */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGB565
+mng_retcode mng_restore_bkgd_rgb565 (mng_datap pData)
+{
+  mng_int32  iX;
+  mng_uint8p pBkgd;
+  mng_uint8p pWork = pData->pRGBArow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_RGB565, MNG_LC_START);
+#endif
+
+  if (pData->fGetbkgdline)             /* can we access the background ? */
+  {                                    /* point to the right pixel then */
+    pBkgd = (mng_uint8p)pData->fGetbkgdline ((mng_handle)pData,
+                                             pData->iRow + pData->iDestt) +
+            (3 * pData->iDestl);
+
+    for (iX = (pData->iSourcer - pData->iSourcel); iX > 0; iX--)
+    {
+      *pWork     = (mng_uint8)(  *(pBkgd)&0xF8);             /* ok; copy the pixel */
+      *(pWork+1) = (mng_uint8)( (*(pBkgd+1) << 5)  |  ( ((*pBkgd)&0xE0)>>3 ) );
+      *(pWork+2) = (mng_uint8)(  *(pBkgd+1) << 3);
+      *(pWork+3) = 0x00;               /* transparant for alpha-canvasses */
+
+      pWork += 4;
+      pBkgd += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RESTORE_RGB565, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SKIPCANVAS_RBB565 */
+
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row retrieval routines - retrieve processed & uncompressed row-data    * */
+/* * from the current "object"                                              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* TODO: a serious optimization is to retrieve only those pixels that will
+         actually be displayed; this would require changes in
+         the "display_image" routine (in mng_display.c) &
+         all the "retrieve_xxx" routines below &
+         the "display_xxx" routines above !!!!!
+         NOTE that "correct_xxx" routines would not require modification */
+
+mng_retcode mng_retrieve_g8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_G8, MNG_LC_START);
+#endif
+
+  pRGBArow = pData->pRGBArow;          /* temporary work pointers */
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+
+  if (pBuf->bHasTRNS)                  /* tRNS in buffer ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iG = *pWorkrow;                  /* get the gray-value */
+                                       /* is it transparent ? */
+      if ((mng_uint16)iG == pBuf->iTRNSgray)
+      {
+        *pRGBArow     = 0x00;          /* nuttin to display */
+        *(pRGBArow+1) = 0x00;
+        *(pRGBArow+2) = 0x00;
+        *(pRGBArow+3) = 0x00;
+      }
+      else
+      {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+        mng_uint8 multiplier[]={0,255,85,0,17,0,0,0,1};
+        iG = (mng_uint8)(iG * multiplier[pBuf->iBitdepth]);
+#endif
+
+        *pRGBArow     = iG;            /* put in intermediate row */
+        *(pRGBArow+1) = iG;
+        *(pRGBArow+2) = iG;
+        *(pRGBArow+3) = 0xFF;
+      }
+
+      pWorkrow++;                      /* next pixel */
+      pRGBArow += 4;
+    }
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+      mng_uint8 multiplier[]={0,255,85,0,17,0,0,0,1};   /* LBR scaling */
+      iG = (mng_uint8)(multiplier[pBuf->iBitdepth] * *pWorkrow);
+#else
+      iG = *pWorkrow;                  /* get the gray-value */
+#endif
+
+      *pRGBArow     = iG;              /* put in intermediate row */
+      *(pRGBArow+1) = iG;
+      *(pRGBArow+2) = iG;
+      *(pRGBArow+3) = 0xFF;
+
+      pWorkrow++;                      /* next pixel */
+      pRGBArow += 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_retrieve_g16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint16     iG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_G16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pRGBArow = pData->pRGBArow;
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+
+  if (pBuf->bHasTRNS)                  /* tRNS in buffer ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iG = mng_get_uint16 (pWorkrow);  /* get the gray-value */
+                                       /* is it transparent ? */
+      if (iG == pBuf->iTRNSgray)
+      {                                /* nuttin to display */
+        mng_put_uint16 (pRGBArow,   0x0000);
+        mng_put_uint16 (pRGBArow+2, 0x0000);
+        mng_put_uint16 (pRGBArow+4, 0x0000);
+        mng_put_uint16 (pRGBArow+6, 0x0000);
+      }
+      else
+      {                                /* put in intermediate row */
+        mng_put_uint16 (pRGBArow,   iG);
+        mng_put_uint16 (pRGBArow+2, iG);
+        mng_put_uint16 (pRGBArow+4, iG);
+        mng_put_uint16 (pRGBArow+6, 0xFFFF);
+      }
+
+      pWorkrow += 2;                   /* next pixel */
+      pRGBArow += 8;
+    }
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iG = mng_get_uint16 (pWorkrow);  /* get the gray-value */
+
+      mng_put_uint16 (pRGBArow,   iG); /* and put in intermediate row */
+      mng_put_uint16 (pRGBArow+2, iG);
+      mng_put_uint16 (pRGBArow+4, iG);
+      mng_put_uint16 (pRGBArow+6, 0xFFFF);
+
+      pWorkrow += 2;                  /* next pixel */
+      pRGBArow += 8;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_retrieve_rgb8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iR, iG, iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGB8, MNG_LC_START);
+#endif
+
+  pRGBArow = pData->pRGBArow;          /* temporary work pointers */
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+
+  if (pBuf->bHasTRNS)                  /* tRNS in buffer ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iR = *pWorkrow;                  /* get the rgb-values */
+      iG = *(pWorkrow+1);
+      iB = *(pWorkrow+2);
+                                       /* is it transparent ? */
+      if (((mng_uint16)iR == pBuf->iTRNSred  ) &&
+          ((mng_uint16)iG == pBuf->iTRNSgreen) &&
+          ((mng_uint16)iB == pBuf->iTRNSblue )    )
+      {
+        *pRGBArow     = 0x00;          /* nothing to display */
+        *(pRGBArow+1) = 0x00;
+        *(pRGBArow+2) = 0x00;
+        *(pRGBArow+3) = 0x00;
+      }
+      else
+      {
+        *pRGBArow     = iR;            /* put in intermediate row */
+        *(pRGBArow+1) = iG;
+        *(pRGBArow+2) = iB;
+        *(pRGBArow+3) = 0xFF;
+      }
+
+      pWorkrow += 3;                   /* next pixel */
+      pRGBArow += 4;
+    }
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pRGBArow     = *pWorkrow;       /* just copy the pixel */
+      *(pRGBArow+1) = *(pWorkrow+1);
+      *(pRGBArow+2) = *(pWorkrow+2);
+      *(pRGBArow+3) = 0xFF;
+
+      pWorkrow += 3;                   /* next pixel */
+      pRGBArow += 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_retrieve_rgb16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint16     iR, iG, iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGB16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pRGBArow = pData->pRGBArow;
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+
+  if (pBuf->bHasTRNS)                  /* tRNS in buffer ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iR = mng_get_uint16 (pWorkrow);  /* get the rgb-values */
+      iG = mng_get_uint16 (pWorkrow+2);
+      iB = mng_get_uint16 (pWorkrow+4);
+                                       /* is it transparent ? */
+      if ((iR == pBuf->iTRNSred  ) &&
+          (iG == pBuf->iTRNSgreen) &&
+          (iB == pBuf->iTRNSblue )    )
+      {                                /* nothing to display */
+        mng_put_uint16 (pRGBArow,   0x0000);
+        mng_put_uint16 (pRGBArow+2, 0x0000);
+        mng_put_uint16 (pRGBArow+4, 0x0000);
+        mng_put_uint16 (pRGBArow+6, 0x0000);
+      }
+      else
+      {                                /* put in intermediate row */
+        mng_put_uint16 (pRGBArow,   iR);
+        mng_put_uint16 (pRGBArow+2, iG);
+        mng_put_uint16 (pRGBArow+4, iB);
+        mng_put_uint16 (pRGBArow+6, 0xFFFF);
+      }
+
+      pWorkrow += 6;                   /* next pixel */
+      pRGBArow += 8;
+    }
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* just copy the pixel */
+      mng_put_uint16 (pRGBArow,   mng_get_uint16 (pWorkrow  ));
+      mng_put_uint16 (pRGBArow+2, mng_get_uint16 (pWorkrow+2));
+      mng_put_uint16 (pRGBArow+4, mng_get_uint16 (pWorkrow+4));
+      mng_put_uint16 (pRGBArow+6, 0xFFFF);
+
+      pWorkrow += 6;                   /* next pixel */
+      pRGBArow += 8;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_retrieve_idx8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_IDX8, MNG_LC_START);
+#endif
+
+  pRGBArow = pData->pRGBArow;          /* temporary work pointers */
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+
+  if (pBuf->bHasTRNS)                  /* tRNS in buffer ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iQ = *pWorkrow;                  /* get the index */
+                                       /* is it valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        *pRGBArow     = pBuf->aPLTEentries [iQ].iRed;
+        *(pRGBArow+1) = pBuf->aPLTEentries [iQ].iGreen;
+        *(pRGBArow+2) = pBuf->aPLTEentries [iQ].iBlue;
+                                       /* transparency for this index ? */
+        if ((mng_uint32)iQ < pBuf->iTRNScount)
+          *(pRGBArow+3) = pBuf->aTRNSentries [iQ];
+        else
+          *(pRGBArow+3) = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pWorkrow++;                      /* next pixel */
+      pRGBArow += 4;
+    }
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iQ = *pWorkrow;                  /* get the index */
+                                       /* is it valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        *pRGBArow     = pBuf->aPLTEentries [iQ].iRed;
+        *(pRGBArow+1) = pBuf->aPLTEentries [iQ].iGreen;
+        *(pRGBArow+2) = pBuf->aPLTEentries [iQ].iBlue;
+        *(pRGBArow+3) = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pWorkrow++;                      /* next pixel */
+      pRGBArow += 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_IDX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_retrieve_ga8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_GA8, MNG_LC_START);
+#endif
+
+  pRGBArow = pData->pRGBArow;          /* temporary work pointers */
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    iG = *pWorkrow;                    /* get the gray-value */
+    *pRGBArow     = iG;                /* put in intermediate row */
+    *(pRGBArow+1) = iG;
+    *(pRGBArow+2) = iG;
+    *(pRGBArow+3) = *(pWorkrow+1);
+
+    pWorkrow += 2;                     /* next pixel */
+    pRGBArow += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_GA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_retrieve_ga16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint16     iG;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_GA16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pRGBArow = pData->pRGBArow;
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    iG = mng_get_uint16 (pWorkrow);    /* get the gray-value */
+
+    mng_put_uint16 (pRGBArow,   iG);   /* and put in intermediate row */
+    mng_put_uint16 (pRGBArow+2, iG);
+    mng_put_uint16 (pRGBArow+4, iG);
+    mng_put_uint16 (pRGBArow+6, mng_get_uint16 (pWorkrow+2));
+
+    pWorkrow += 4;                     /* next pixel */
+    pRGBArow += 8;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_retrieve_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGBA8, MNG_LC_START);
+#endif
+
+  pRGBArow = pData->pRGBArow;          /* temporary work pointers */
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+                                       /* can't be easier than this ! */
+  MNG_COPY (pRGBArow, pWorkrow, pBuf->iRowsize);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_retrieve_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pRetrieveobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGBA16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pRGBArow = pData->pRGBArow;
+  pWorkrow = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize);
+                                       /* can't be easier than this ! */
+  MNG_COPY (pRGBArow, pWorkrow, pBuf->iRowsize);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RETRIEVE_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row storage routines - store processed & uncompressed row-data         * */
+/* * into the current "object"                                              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_g1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G1, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0x80;
+    }
+
+    if (iB & iM)                       /* is it white ? */
+      *pOutrow = 0x01;                 /* white */
+    else
+      *pOutrow = 0x00;                 /* black */
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    iM >>=  1;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_g2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G2, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xC0;
+      iS = 6;
+    }
+
+    iQ = (mng_uint8)((iB & iM) >> iS); /* get the gray level */
+    *pOutrow = iQ;                     /* put in object buffer */
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    iM >>=  2;
+    iS -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_g4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G4, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xF0;
+      iS = 4;
+    }
+
+    iQ = (mng_uint8)((iB & iM) >> iS); /* get the gray level */
+    *pOutrow = iQ;                     /* put in object buffer */
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    iM >>=  4;
+    iS -= 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_g8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* put in object buffer */
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_g16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {                                    /* copy into object buffer */
+    mng_put_uint16 (pOutrow, mng_get_uint16 (pWorkrow));
+
+    pOutrow  += (pData->iColinc << 1); /* next pixel */
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_rgb8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGB8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow     = *pWorkrow;          /* copy the RGB bytes */
+    *(pOutrow+1) = *(pWorkrow+1);
+    *(pOutrow+2) = *(pWorkrow+2);
+
+    pWorkrow += 3;                     /* next pixel */
+    pOutrow  += (pData->iColinc * 3);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_rgb16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGB16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    MNG_COPY (pOutrow, pWorkrow, 6);   /* copy the RGB bytes */
+
+    pWorkrow += 6;                     /* next pixel */
+    pOutrow  += (pData->iColinc * 6);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_idx1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX1, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0x80;
+    }
+
+    if (iB & iM)                       /* store the index */
+      *pOutrow = 0x01;
+    else
+      *pOutrow = 0x00;
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    iM >>=  1;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_idx2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX2, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xC0;
+      iS = 6;
+    }
+                                       /* store the index */
+    *pOutrow = (mng_uint8)((iB & iM) >> iS);
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    iM >>=  2;
+    iS -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_idx4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX4, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xF0;
+      iS = 4;
+    }
+                                       /* store the index */
+    *pOutrow = (mng_uint8)((iB & iM) >> iS);
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    iM >>=  4;
+    iS -= 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_idx8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* put in object buffer */
+
+    pOutrow += pData->iColinc;         /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_IDX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_ga8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_GA8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow     = *pWorkrow;          /* copy the GA bytes */
+    *(pOutrow+1) = *(pWorkrow+1);
+
+    pWorkrow += 2;                     /* next pixel */
+    pOutrow  += (pData->iColinc << 1);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_GA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_ga16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_GA16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    MNG_COPY (pOutrow, pWorkrow, 4);   /* copy the GA bytes */
+
+    pWorkrow += 4;                     /* next pixel */
+    pOutrow  += (pData->iColinc << 2);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGBA8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow     = *pWorkrow;          /* copy the RGBA bytes */
+    *(pOutrow+1) = *(pWorkrow+1);
+    *(pOutrow+2) = *(pWorkrow+2);
+    *(pOutrow+3) = *(pWorkrow+3);
+
+    pWorkrow += 4;                     /* next pixel */
+    pOutrow  += (pData->iColinc << 2);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGBA16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    MNG_COPY (pOutrow, pWorkrow, 8);   /* copy the RGBA bytes */
+
+    pWorkrow += 8;                     /* next pixel */
+    pOutrow  += (pData->iColinc << 3);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row storage routines (JPEG) - store processed & uncompressed row-data  * */
+/* * into the current "object"                                              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_g8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pJPEGrow;          /* temporary work pointers */
+  pOutrow  = pBuf->pImgdata + (pData->iJPEGrow * pBuf->iRowsize);
+                                       /* easy as pie ... */
+  MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8, MNG_LC_END);
+#endif
+
+  return mng_next_jpeg_row (pData);    /* we've got one more row of gray-samples */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_rgb8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+#if RGB_PIXELSIZE != 3
+  mng_int32      iX;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pJPEGrow;          /* temporary work pointers */
+  pOutrow  = pBuf->pImgdata + (pData->iJPEGrow * pBuf->iRowsize);
+
+#if RGB_PIXELSIZE == 3
+                                       /* easy as pie ... */
+  MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples * 3);
+#else
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow     = *pWorkrow;          /* copy pixel into object buffer */
+    *(pOutrow+1) = *(pWorkrow+1);
+    *(pOutrow+2) = *(pWorkrow+2);
+
+    pOutrow  += 3;                     /* next pixel */
+    pWorkrow += RGB_PIXELSIZE;
+  }
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8, MNG_LC_END);
+#endif
+
+  return mng_next_jpeg_row (pData);    /* we've got one more row of rgb-samples */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_ga8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_GA8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pJPEGrow;          /* temporary work pointers */
+  pOutrow  = pBuf->pImgdata + (pData->iJPEGrow * pBuf->iRowsize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* copy into object buffer */
+
+    pOutrow += 2;                      /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_GA8, MNG_LC_END);
+#endif
+
+  return mng_next_jpeg_row (pData);    /* we've got one more row of gray-samples */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGBA8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pJPEGrow;          /* temporary work pointers */
+  pOutrow  = pBuf->pImgdata + (pData->iJPEGrow * pBuf->iRowsize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow     = *pWorkrow;          /* copy pixel into object buffer */
+    *(pOutrow+1) = *(pWorkrow+1);
+    *(pOutrow+2) = *(pWorkrow+2);
+
+    pOutrow  += 4;                     /* next pixel */
+    pWorkrow += RGB_PIXELSIZE;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGBA8, MNG_LC_END);
+#endif
+
+  return mng_next_jpeg_row (pData);    /* we've got one more row of rgb-samples */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_g8_alpha (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_ALPHA, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pJPEGrow2;
+  pOutrow  = pBuf->pImgdata + (pData->iJPEGalpharow * pBuf->iRowsize) + 1;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* put in object buffer */
+
+    pOutrow += 2;                      /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_ALPHA, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_rgb8_alpha (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_ALPHA, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pJPEGrow2;
+  pOutrow  = pBuf->pImgdata + (pData->iJPEGalpharow * pBuf->iRowsize) + 3;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* put in object buffer */
+
+    pOutrow += 4;                      /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_ALPHA, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_jpeg_g8_a1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A1, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 1;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0x80;
+    }
+
+    if (iB & iM)                       /* is it opaque ? */
+      *pOutrow = 0xFF;                 /* opaque */
+    else
+      *pOutrow = 0x00;                 /* transparent */
+
+    pOutrow += 2;                      /* next pixel */
+    iM >>=  1;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A1, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_g8_a2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A2, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 1;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xC0;
+      iS = 6;
+    }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+    {
+      const mng_uint8  alpha_level[4] = { 0x00, 0x55, 0xAA, 0xFF};
+        *pOutrow = alpha_level[((iB & iM) >> iS)] ;
+    }
+#else
+    switch ((iB & iM) >> iS)           /* determine the alpha level */
+    {
+      case 0x03 : { *pOutrow = 0xFF; break; }
+      case 0x02 : { *pOutrow = 0xAA; break; }
+      case 0x01 : { *pOutrow = 0x55; break; }
+      default   : { *pOutrow = 0x00; }
+    }
+#endif
+
+    pOutrow += 2;                      /* next pixel */
+    iM >>=  2;
+    iS -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A2, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_g8_a4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A4, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 1;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xF0;
+      iS = 4;
+    }
+                                       /* get the alpha level */
+    iQ = (mng_uint8)((iB & iM) >> iS);
+    iQ = (mng_uint8)(iQ + (iQ << 4));  /* expand to 8-bit by replication */
+
+    *pOutrow = iQ;                     /* put in object buffer */
+
+    pOutrow += 2;                      /* next pixel */
+    iM >>=  4;
+    iS -= 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A4, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_g8_a8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 1;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* put in object buffer */
+
+    pOutrow += 2;                      /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A8, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_jpeg_g8_a16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 1;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* only high-order byte! */
+
+    pOutrow  += 2;                     /* next pixel */
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G8_A16, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_jpeg_rgb8_a1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A1, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 3;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0x80;
+    }
+
+    if (iB & iM)                       /* is it opaque ? */
+      *pOutrow = 0xFF;                 /* opaque */
+    else
+      *pOutrow = 0x00;                 /* transparent */
+
+    pOutrow += 4;                      /* next pixel */
+    iM >>=  1;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A1, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_rgb8_a2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A2, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 3;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xC0;
+      iS = 6;
+    }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+    {
+      const mng_uint8  alpha_level[4] = { 0x00, 0x55, 0xAA, 0xFF};
+      *pOutrow = alpha_level[((iB & iM) >> iS)] ;
+    }
+#else
+    switch ((iB & iM) >> iS)           /* determine the alpha level */
+    {
+      case 0x03 : { *pOutrow = 0xFF; break; }
+      case 0x02 : { *pOutrow = 0xAA; break; }
+      case 0x01 : { *pOutrow = 0x55; break; }
+      default   : { *pOutrow = 0x00; }
+    }
+#endif
+
+    pOutrow += 4;                      /* next pixel */
+    iM >>=  2;
+    iS -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A2, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_rgb8_a4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A4, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 3;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xF0;
+      iS = 4;
+    }
+                                       /* get the alpha level */
+    iQ = (mng_uint8)((iB & iM) >> iS);
+    iQ = (mng_uint8)(iQ + (iQ << 4));  /* expand to 8-bit by replication */
+
+    *pOutrow = iQ;                     /* put in object buffer */
+
+    pOutrow += 4;                      /* next pixel */
+    iM >>=  4;
+    iS -= 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A4, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_store_jpeg_rgb8_a8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 3;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* put in buffer */
+
+    pOutrow += 4;                      /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A8, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_jpeg_rgb8_a16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 3;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = *pWorkrow;              /* only high-order byte */
+
+    pOutrow  += 4;                     /* next pixel */
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_RGB8_A16, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_JPEG12
+mng_retcode mng_store_jpeg_g12_a1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A1, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 2;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0x80;
+    }
+
+    if (iB & iM)                       /* opaque ? */
+      mng_put_uint16 (pOutrow, 0xFFFF);/* opaque */
+    else
+      mng_put_uint16 (pOutrow, 0x0000);/* transparent */
+
+    pOutrow += 4;                      /* next pixel */
+    iM >>=  1;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A1, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif /* MNG_SUPPORT_JPEG12 */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_JPEG12
+mng_retcode mng_store_jpeg_g12_a2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A2, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 2;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xC0;
+      iS = 6;
+    }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+    {
+      const mng_uint16  gray_level[4] = { 0x0000, 0x5555, 0xAAAA, 0xFFFF};
+      mng_put_uint16 (pOutrow, gray_level[((iB & iM) >> iS)]) ;
+    }
+#else
+    switch ((iB & iM) >> iS)           /* determine the gray level */
+    {
+      case 0x03 : { mng_put_uint16 (pOutrow, 0xFFFF); break; }
+      case 0x02 : { mng_put_uint16 (pOutrow, 0xAAAA); break; }
+      case 0x01 : { mng_put_uint16 (pOutrow, 0x5555); break; }
+      default   : { mng_put_uint16 (pOutrow, 0x0000); }
+    }
+#endif
+
+    pOutrow += 4;                      /* next pixel */
+    iM >>=  2;
+    iS -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A2, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif /* MNG_SUPPORT_JPEG12 */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_JPEG12
+mng_retcode mng_store_jpeg_g12_a4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint16     iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A4, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 2;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    if (!iM)                           /* mask underflow ? */
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+      pWorkrow++;
+      iM = 0xF0;
+      iS = 4;
+    }
+                                       /* get the gray level */
+    iQ = (mng_uint16)((iB & iM) >> iS);
+    iQ = (mng_uint16)(iQ + (iQ << 4)); /* expand to 16-bit by replication */
+    iQ = (mng_uint16)(iQ + (iQ << 8));
+                                       /* put in object buffer */
+    mng_put_uint16 (pOutrow, iQ);
+
+    pOutrow += 4;                      /* next pixel */
+    iM >>=  4;
+    iS -= 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A4, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif /* MNG_SUPPORT_JPEG12 */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_JPEG12
+mng_retcode mng_store_jpeg_g12_a8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint16     iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 2;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    iW = (mng_uint16)(*pWorkrow);      /* get input byte */
+    iW = (mng_uint16)(iW + (iW << 8)); /* expand to 16-bit by replication */
+
+    mng_put_uint16 (pOutrow, iW);      /* put in object buffer */
+
+    pOutrow += 4;                      /* next pixel */
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A8, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif /* MNG_SUPPORT_JPEG12 */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_JPEG12
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_jpeg_g12_a16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 2;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {                                    /* copy it */
+    mng_put_uint16 (pOutrow, mng_get_uint16 (pWorkrow));
+
+    pOutrow  += 4;                     /* next pixel */
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_STORE_JPEG_G12_A16, MNG_LC_END);
+#endif
+                                       /* we've got one more row of alpha-samples */
+  return mng_next_jpeg_alpharow (pData);
+}
+#endif
+#endif /* MNG_SUPPORT_JPEG12 */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_JNG */
+
+#ifndef MNG_NO_DELTA_PNG
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - apply the processed & uncompressed row-data * */
+/* * onto the target "object"                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_delta_g1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G1, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0x80;
+      }
+
+      if (iB & iM)                     /* is it white ? */
+        *pOutrow = 0xFF;               /* white */
+      else
+        *pOutrow = 0x00;               /* black */
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  1;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0x80;
+      }
+
+      if (iB & iM)                     /* invert if it is white ? */
+        *pOutrow = (mng_uint8)(*pOutrow ^ 0xFF);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  1;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G1, MNG_LC_END);
+#endif
+
+  return mng_store_g1 (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_g2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+  const mng_uint8  level[4] = { 0x00, 0x55, 0xAA, 0xFF};
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G2, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+    *pOutrow = level[((iB & iM) >> iS)] ;
+#else
+    switch ((iB & iM) >> iS)           /* determine the alpha level */
+    {
+      case 0x03 : { *pOutrow = 0xFF; break; }
+      case 0x02 : { *pOutrow = 0xAA; break; }
+      case 0x01 : { *pOutrow = 0x55; break; }
+      default   : { *pOutrow = 0x00; }
+    }
+#endif
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+      *pOutrow = level[((*pOutrow >> 6) + ((iB & iM) >> iS)) & 0x03] ;
+#else
+      switch (((*pOutrow >> 6) + ((iB & iM) >> iS)) & 0x03)
+      {
+        case 0x03 : { *pOutrow = 0xFF; break; }
+        case 0x02 : { *pOutrow = 0xAA; break; }
+        case 0x01 : { *pOutrow = 0x55; break; }
+        default   : { *pOutrow = 0x00; }
+      }
+#endif
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G2, MNG_LC_END);
+#endif
+
+  return mng_store_g2 (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_g4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G4, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* get the gray level */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+                                       /* expand to 8-bit by replication */
+      iQ = (mng_uint8)(iQ + (iQ << 4));
+
+      *pOutrow = iQ;                   /* put in object buffer */
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* get the gray level */
+      iQ = (mng_uint8)(((*pOutrow >> 4) + ((iB & iM) >> iS)) & 0x0F);
+                                       /* expand to 8-bit by replication */
+      iQ = (mng_uint8)(iQ + (iQ << 4));
+
+      *pOutrow = iQ;                   /* put in object buffer */
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G4, MNG_LC_END);
+#endif
+
+  return mng_store_g4 (pData);
+}
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_g8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = *pWorkrow;            /* put in object buffer */
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      pWorkrow++;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      *pOutrow = (mng_uint8)(*pOutrow + *pWorkrow);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G8, MNG_LC_END);
+#endif
+
+  return mng_store_g8 (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_g16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = *pWorkrow;        /* put in object buffer */
+      *(pOutrow+1) = *(pWorkrow+1);
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 1);
+      pWorkrow += 2;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      mng_put_uint16 (pOutrow, (mng_uint16)(mng_get_uint16 (pOutrow ) +
+                                            mng_get_uint16 (pWorkrow)   ));
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 1);
+      pWorkrow += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G16, MNG_LC_END);
+#endif
+
+  return mng_store_g16 (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_rgb8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = *pWorkrow;        /* put in object buffer */
+      *(pOutrow+1) = *(pWorkrow+1);
+      *(pOutrow+2) = *(pWorkrow+2);
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc * 3);
+      pWorkrow += 3;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      *pOutrow     = (mng_uint8)(*pOutrow     + *pWorkrow    );
+      *(pOutrow+1) = (mng_uint8)(*(pOutrow+1) + *(pWorkrow+1));
+      *(pOutrow+2) = (mng_uint8)(*(pOutrow+2) + *(pWorkrow+2));
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc * 3);
+      pWorkrow += 3;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB8, MNG_LC_END);
+#endif
+
+  return mng_store_rgb8 (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgb16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = *pWorkrow;        /* put in object buffer */
+      *(pOutrow+1) = *(pWorkrow+1);
+      *(pOutrow+2) = *(pWorkrow+2);
+      *(pOutrow+3) = *(pWorkrow+3);
+      *(pOutrow+4) = *(pWorkrow+4);
+      *(pOutrow+5) = *(pWorkrow+5);
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc * 6);
+      pWorkrow += 6;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      mng_put_uint16 (pOutrow,   (mng_uint16)(mng_get_uint16 (pOutrow   ) +
+                                              mng_get_uint16 (pWorkrow  )   ));
+      mng_put_uint16 (pOutrow+2, (mng_uint16)(mng_get_uint16 (pOutrow+2 ) +
+                                              mng_get_uint16 (pWorkrow+2)   ));
+      mng_put_uint16 (pOutrow+4, (mng_uint16)(mng_get_uint16 (pOutrow+4 ) +
+                                              mng_get_uint16 (pWorkrow+4)   ));
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc * 6);
+      pWorkrow += 6;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB16, MNG_LC_END);
+#endif
+
+  return mng_store_rgb16 (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_delta_idx1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX1, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0x80;
+      }
+
+      if (iB & iM)                     /* put the right index value */
+        *pOutrow = 1;
+      else
+        *pOutrow = 0;
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  1;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0x80;
+      }
+
+      if (iB & iM)                     /* invert if it is non-zero index */
+        *pOutrow = (mng_uint8)(*pOutrow ^ 0x01);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  1;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX1, MNG_LC_END);
+#endif
+
+  return mng_store_idx1 (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_idx2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX2, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+                                       /* put the index */
+      *pOutrow = (mng_uint8)((iB & iM) >> iS);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+                                       /* calculate the index */
+      *pOutrow = (mng_uint8)((*pOutrow + ((iB & iM) >> iS)) & 0x03);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX2, MNG_LC_END);
+#endif
+
+  return mng_store_idx2 (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_idx4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX4, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* put the index */
+      *pOutrow = (mng_uint8)((iB & iM) >> iS);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* calculate the index */
+      *pOutrow = (mng_uint8)((*pOutrow + ((iB & iM) >> iS)) & 0x0F);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX4, MNG_LC_END);
+#endif
+
+  return mng_store_idx4 (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_idx8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = *pWorkrow;            /* put in object buffer */
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      pWorkrow++;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      *pOutrow = (mng_uint8)(*pOutrow + *pWorkrow);
+
+      pOutrow += pData->iColinc;       /* next pixel */
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_IDX8, MNG_LC_END);
+#endif
+
+  return mng_store_idx8 (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_ga8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = *pWorkrow;        /* put in object buffer */
+      *(pOutrow+1) = *(pWorkrow+1);
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 1);
+      pWorkrow += 2;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      *pOutrow     = (mng_uint8)(*pOutrow     + *pWorkrow    );
+      *(pOutrow+1) = (mng_uint8)(*(pOutrow+1) + *(pWorkrow+1));
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 1);
+      pWorkrow += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8, MNG_LC_END);
+#endif
+
+  return mng_store_ga8 (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_ga16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = *pWorkrow;        /* put in object buffer */
+      *(pOutrow+1) = *(pWorkrow+1);
+      *(pOutrow+2) = *(pWorkrow+2);
+      *(pOutrow+3) = *(pWorkrow+3);
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 2);
+      pWorkrow += 4;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      mng_put_uint16 (pOutrow,   (mng_uint16)(mng_get_uint16 (pOutrow   ) +
+                                              mng_get_uint16 (pWorkrow  )   ));
+      mng_put_uint16 (pOutrow+2, (mng_uint16)(mng_get_uint16 (pOutrow+2 ) +
+                                              mng_get_uint16 (pWorkrow+2)   ));
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 2);
+      pWorkrow += 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16, MNG_LC_END);
+#endif
+
+  return mng_store_ga16 (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = *pWorkrow;        /* put in object buffer */
+      *(pOutrow+1) = *(pWorkrow+1);
+      *(pOutrow+2) = *(pWorkrow+2);
+      *(pOutrow+3) = *(pWorkrow+3);
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 2);
+      pWorkrow += 4;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      *pOutrow     = (mng_uint8)(*pOutrow     + *pWorkrow    );
+      *(pOutrow+1) = (mng_uint8)(*(pOutrow+1) + *(pWorkrow+1));
+      *(pOutrow+2) = (mng_uint8)(*(pOutrow+2) + *(pWorkrow+2));
+      *(pOutrow+3) = (mng_uint8)(*(pOutrow+3) + *(pWorkrow+3));
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 2);
+      pWorkrow += 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8, MNG_LC_END);
+#endif
+
+  return mng_store_rgba8 (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pDeltaImage)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pOutrow  = pBuf->pImgdata + (pData->iRow         * pBuf->iRowsize   ) +
+                              (pData->iDeltaBlocky * pBuf->iRowsize   ) +
+                              (pData->iCol         * pBuf->iSamplesize) +
+                              (pData->iDeltaBlockx * pBuf->iSamplesize);
+                                       /* pixel replace ? */
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      MNG_COPY (pOutrow, pWorkrow, 8); /* put in object buffer */
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 3);
+      pWorkrow += 8;
+    }
+  }
+  else
+  {                                    /* pixel add ! */
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* add to object buffer */
+      mng_put_uint16 (pOutrow,   (mng_uint16)(mng_get_uint16 (pOutrow   ) +
+                                              mng_get_uint16 (pWorkrow  )   ));
+      mng_put_uint16 (pOutrow+2, (mng_uint16)(mng_get_uint16 (pOutrow+2 ) +
+                                              mng_get_uint16 (pWorkrow+2)   ));
+      mng_put_uint16 (pOutrow+4, (mng_uint16)(mng_get_uint16 (pOutrow+4 ) +
+                                              mng_get_uint16 (pWorkrow+4)   ));
+      mng_put_uint16 (pOutrow+6, (mng_uint16)(mng_get_uint16 (pOutrow+6 ) +
+                                              mng_get_uint16 (pWorkrow+6)   ));
+                                       /* next pixel */
+      pOutrow  += (pData->iColinc << 3);
+      pWorkrow += 8;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16, MNG_LC_END);
+#endif
+
+  return mng_store_rgba16 (pData);
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - apply the source row onto the target        * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_delta_g1_g1 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G1_G1, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples);
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0x01);
+
+      pOutrow++;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G1_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_g2_g2 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G2_G2, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples);
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0x03);
+
+      pOutrow++;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G2_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_g4_g4 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G4_G4, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples);
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0x0F);
+
+      pOutrow++;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G4_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_g8_g8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G8_G8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples);
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0xFF);
+
+      pOutrow++;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G8_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_g16_g16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G16_G16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, (pData->iRowsamples << 1));
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow, (mng_uint16)((mng_get_uint16 (pOutrow) +
+                                             mng_get_uint16 (pWorkrow)) & 0xFFFF));
+
+      pOutrow  += 2;
+      pWorkrow += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_G16_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_rgb8_rgb8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB8_RGB8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples * 3);
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples*3; iX > 0; iX--)
+#else
+    for (iX = 0; iX < (pData->iRowsamples * 3); iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0xFF);
+
+      pOutrow++;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB8_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgb16_rgb16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB16_RGB16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, (pData->iRowsamples * 6));
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow,   (mng_uint16)((mng_get_uint16 (pOutrow  ) +
+                                               mng_get_uint16 (pWorkrow  )) & 0xFFFF));
+      mng_put_uint16 (pOutrow+2, (mng_uint16)((mng_get_uint16 (pOutrow+2) +
+                                               mng_get_uint16 (pWorkrow+2)) & 0xFFFF));
+      mng_put_uint16 (pOutrow+4, (mng_uint16)((mng_get_uint16 (pOutrow+4) +
+                                               mng_get_uint16 (pWorkrow+4)) & 0xFFFF));
+
+      pOutrow  += 6;
+      pWorkrow += 6;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGB16_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_delta_ga8_ga8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8_GA8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples << 1);
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = (pData->iRowsamples<<1); iX > 0; iX--)
+#else
+    for (iX = 0; iX < (pData->iRowsamples << 1); iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0xFF);
+
+      pOutrow++;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8_GA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_ga8_g8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8_G8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = *pWorkrow;
+
+      pOutrow += 2;
+      pWorkrow++;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0xFF);
+
+      pOutrow += 2;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_ga8_a8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8_A8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 1;
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = *pWorkrow;
+
+      pOutrow += 2;
+      pWorkrow++;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0xFF);
+
+      pOutrow += 2;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA8_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_ga16_ga16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16_GA16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, (pData->iRowsamples << 2));
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow,   (mng_uint16)((mng_get_uint16 (pOutrow  ) +
+                                               mng_get_uint16 (pWorkrow  )) & 0xFFFF));
+      mng_put_uint16 (pOutrow+2, (mng_uint16)((mng_get_uint16 (pOutrow+2) +
+                                               mng_get_uint16 (pWorkrow+2)) & 0xFFFF));
+
+      pOutrow  += 4;
+      pWorkrow += 4;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_ga16_g16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16_G16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow, mng_get_uint16 (pWorkrow));
+
+      pOutrow  += 4;
+      pWorkrow += 2;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow, (mng_uint16)((mng_get_uint16 (pOutrow) +
+                                             mng_get_uint16 (pWorkrow)) & 0xFFFF));
+
+      pOutrow  += 4;
+      pWorkrow += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_ga16_a16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16_A16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow+2, mng_get_uint16 (pWorkrow));
+
+      pOutrow  += 4;
+      pWorkrow += 2;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow+2, (mng_uint16)((mng_get_uint16 (pOutrow+2) +
+                                               mng_get_uint16 (pWorkrow)) & 0xFFFF));
+
+      pOutrow  += 4;
+      pWorkrow += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_GA16_A16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_rgba8_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8_RGBA8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, pData->iRowsamples << 2);
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = (pData->iRowsamples << 2); iX > 0; iX--)
+#else
+    for (iX = 0; iX < (pData->iRowsamples << 2); iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0xFF);
+
+      pOutrow++;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_retcode mng_delta_rgba8_rgb8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8_RGB8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = *pWorkrow;
+      *(pOutrow+1) = *(pWorkrow+1);
+      *(pOutrow+2) = *(pWorkrow+2);
+
+      pOutrow  += 4;
+      pWorkrow += 3;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow     = (mng_uint8)(((mng_uint16)*pOutrow     +
+                                  (mng_uint16)*pWorkrow    ) & 0xFF);
+      *(pOutrow+1) = (mng_uint8)(((mng_uint16)*(pOutrow+1) +
+                                  (mng_uint16)*(pWorkrow+1)) & 0xFF);
+      *(pOutrow+2) = (mng_uint8)(((mng_uint16)*(pOutrow+2) +
+                                  (mng_uint16)*(pWorkrow+2)) & 0xFF);
+
+      pOutrow  += 4;
+      pWorkrow += 3;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_delta_rgba8_a8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8_A8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize) + 3;
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = *pWorkrow;
+
+      pOutrow += 4;
+      pWorkrow++;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pOutrow = (mng_uint8)(((mng_uint16)*pOutrow +
+                              (mng_uint16)*pWorkrow) & 0xFF);
+
+      pOutrow += 4;
+      pWorkrow++;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA8_A8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgba16_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16_RGBA16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if ((pData->iDeltatype == MNG_DELTATYPE_REPLACE          ) ||
+      (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELREPLACE)    )
+  {
+    MNG_COPY (pOutrow, pWorkrow, (pData->iRowsamples << 3));
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKPIXELADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow,   (mng_uint16)((mng_get_uint16 (pOutrow  ) +
+                                               mng_get_uint16 (pWorkrow  )) & 0xFFFF));
+      mng_put_uint16 (pOutrow+2, (mng_uint16)((mng_get_uint16 (pOutrow+2) +
+                                               mng_get_uint16 (pWorkrow+2)) & 0xFFFF));
+      mng_put_uint16 (pOutrow+4, (mng_uint16)((mng_get_uint16 (pOutrow+4) +
+                                               mng_get_uint16 (pWorkrow+4)) & 0xFFFF));
+      mng_put_uint16 (pOutrow+6, (mng_uint16)((mng_get_uint16 (pOutrow+6) +
+                                               mng_get_uint16 (pWorkrow+6)) & 0xFFFF));
+
+      pOutrow  += 8;
+      pWorkrow += 8;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgba16_rgb16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16_RGB16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow,   mng_get_uint16 (pWorkrow  ));
+      mng_put_uint16 (pOutrow+2, mng_get_uint16 (pWorkrow+2));
+      mng_put_uint16 (pOutrow+4, mng_get_uint16 (pWorkrow+4));
+
+      pOutrow  += 8;
+      pWorkrow += 6;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKCOLORADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow,   (mng_uint16)((mng_get_uint16 (pOutrow  ) +
+                                               mng_get_uint16 (pWorkrow  )) & 0xFFFF));
+      mng_put_uint16 (pOutrow+2, (mng_uint16)((mng_get_uint16 (pOutrow+2) +
+                                               mng_get_uint16 (pWorkrow+2)) & 0xFFFF));
+      mng_put_uint16 (pOutrow+4, (mng_uint16)((mng_get_uint16 (pOutrow+4) +
+                                               mng_get_uint16 (pWorkrow+4)) & 0xFFFF));
+
+      pOutrow  += 8;
+      pWorkrow += 6;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgba16_a16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16_A16, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAREPLACE)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow+6, mng_get_uint16 (pWorkrow));
+
+      pOutrow  += 8;
+      pWorkrow += 2;
+    }
+  }
+  else
+  if (pData->iDeltatype == MNG_DELTATYPE_BLOCKALPHAADD)
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      mng_put_uint16 (pOutrow+6, (mng_uint16)((mng_get_uint16 (pOutrow+6) +
+                                               mng_get_uint16 (pWorkrow)) & 0xFFFF));
+
+      pOutrow  += 8;
+      pWorkrow += 2;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DELTA_RGBA16_A16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - scale the delta to bitdepth of target       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_scale_g1_g2 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G2, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow << 1);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g1_g4 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G4, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow << 3);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g1_g8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow << 7);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_g1_g16 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G16, MNG_LC_START);
+#endif
+
+  pWorkrow = pWorkrow + (pData->iRowsamples - 1);
+  pOutrow  = pOutrow  + ((pData->iRowsamples - 1) << 1);
+/*  pWorkrow = (mng_uint8p)((mng_uint32)pWorkrow + pData->iRowsamples - 1); */
+/*  pOutrow  = (mng_uint8p)((mng_uint32)pOutrow  + ((pData->iRowsamples - 1) << 1)); */
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pOutrow+1) = 0;
+    *pOutrow     = (mng_uint8)(*pWorkrow << 7);
+
+    pWorkrow--;
+    pOutrow -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G1_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g2_g4 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G4, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow << 2);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g2_g8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow << 6);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_g2_g16 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G16, MNG_LC_START);
+#endif
+
+  pWorkrow = pWorkrow + (pData->iRowsamples - 1);
+  pOutrow  = pOutrow  + ((pData->iRowsamples - 1) << 1);
+/*  pWorkrow = (mng_uint8p)((mng_uint32)pWorkrow + pData->iRowsamples - 1); */
+/*  pOutrow  = (mng_uint8p)((mng_uint32)pOutrow  + ((pData->iRowsamples - 1) << 1)); */
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pOutrow+1) = 0;
+    *pOutrow     = (mng_uint8)(*pWorkrow << 6);
+
+    pWorkrow--;
+    pOutrow -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g4_g8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow << 4);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_g4_g16 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G16, MNG_LC_START);
+#endif
+
+  pWorkrow = pWorkrow + (pData->iRowsamples - 1);
+  pOutrow  = pOutrow  + ((pData->iRowsamples - 1) << 1);
+/*  pWorkrow = (mng_uint8p)((mng_uint32)pWorkrow + pData->iRowsamples - 1); */
+/*  pOutrow  = (mng_uint8p)((mng_uint32)pOutrow  + ((pData->iRowsamples - 1) << 1)); */
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pOutrow+1) = 0;
+    *pOutrow     = (mng_uint8)(*pWorkrow << 4);
+
+    pWorkrow--;
+    pOutrow -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_g8_g16 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G16, MNG_LC_START);
+#endif
+
+  pWorkrow = pWorkrow + (pData->iRowsamples - 1);
+  pOutrow  = pOutrow  + ((pData->iRowsamples - 1) << 1);
+/*  pWorkrow = (mng_uint8p)((mng_uint32)pWorkrow + pData->iRowsamples - 1); */
+/*  pOutrow  = (mng_uint8p)((mng_uint32)pOutrow  + ((pData->iRowsamples - 1) << 1)); */
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pOutrow+1) = 0;
+    *pOutrow     = *pWorkrow;
+
+    pWorkrow--;
+    pOutrow -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_ga8_ga16 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_GA8_GA16, MNG_LC_START);
+#endif
+
+  pWorkrow = pWorkrow + ((pData->iRowsamples - 1) << 1);
+  pOutrow  = pOutrow  + ((pData->iRowsamples - 1) << 2);
+/*  pWorkrow = (mng_uint8p)((mng_uint32)pWorkrow + ((pData->iRowsamples - 1) << 1)); */
+/*  pOutrow  = (mng_uint8p)((mng_uint32)pOutrow  + ((pData->iRowsamples - 1) << 2)); */
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pOutrow+3) = 0;
+    *(pOutrow+2) = *(pWorkrow+1);
+    *(pOutrow+1) = 0;
+    *pOutrow     = *pWorkrow;
+
+    pWorkrow -= 2;
+    pOutrow  -= 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_GA8_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_rgb8_rgb16 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGB8_RGB16, MNG_LC_START);
+#endif
+
+  pWorkrow = pWorkrow + (3 * (pData->iRowsamples - 1));
+  pOutrow  = pOutrow  + (6 * (pData->iRowsamples - 1));
+/*  pWorkrow = (mng_uint8p)((mng_uint32)pWorkrow + 3 * (pData->iRowsamples - 1)); */
+/*  pOutrow  = (mng_uint8p)((mng_uint32)pOutrow  + 6 * (pData->iRowsamples - 1)); */
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pOutrow+5) = 0;
+    *(pOutrow+4) = *(pWorkrow+2);
+    *(pOutrow+3) = 0;
+    *(pOutrow+2) = *(pWorkrow+1);
+    *(pOutrow+1) = 0;
+    *pOutrow     = *pWorkrow;
+
+    pWorkrow -= 3;
+    pOutrow  -= 6;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGB8_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_rgba8_rgba16 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGBA8_RGBA16, MNG_LC_START);
+#endif
+
+  pWorkrow = pWorkrow + ((pData->iRowsamples - 1) << 2);
+  pOutrow  = pOutrow  + ((pData->iRowsamples - 1) << 3);
+/*  pWorkrow = (mng_uint8p)((mng_uint32)pWorkrow + ((pData->iRowsamples - 1) << 2)); */
+/*  pOutrow  = (mng_uint8p)((mng_uint32)pOutrow  + ((pData->iRowsamples - 1) << 3)); */
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *(pOutrow+7) = 0;
+    *(pOutrow+6) = *(pWorkrow+3);
+    *(pOutrow+5) = 0;
+    *(pOutrow+4) = *(pWorkrow+2);
+    *(pOutrow+3) = 0;
+    *(pOutrow+2) = *(pWorkrow+1);
+    *(pOutrow+1) = 0;
+    *pOutrow     = *pWorkrow;
+
+    pWorkrow -= 4;
+    pOutrow  -= 8;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGBA8_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_scale_g2_g1 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G1, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow >> 1);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G2_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g4_g1 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G1, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow >> 3);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g8_g1 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G1, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow >> 7);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_g16_g1 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G1, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 15);
+    pOutrow++;
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g4_g2 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G2, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow >> 2);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G4_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g8_g2 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G2, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow >> 6);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_g16_g2 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G2, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 14);
+    pOutrow++;
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g8_g4 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G4, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pWorkrow = (mng_uint8)(*pWorkrow >> 4);
+    pWorkrow++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G8_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_scale_g16_g4 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G4, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 12);
+    pOutrow++;
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_g16_g8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_G16_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_ga16_ga8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_GA16_GA8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_GA16_GA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_rgb16_rgb8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGB16_RGB8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGB16_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_scale_rgba16_rgba8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow = pData->pRGBArow;
+  mng_uint8p pOutrow  = pData->pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGBA16_RGBA8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+    *pOutrow = (mng_uint8)(mng_get_uint16 (pWorkrow) >> 8);
+    pOutrow++;
+    pWorkrow += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_SCALE_RGBA16_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image bit routines - promote bit_depth                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_uint8 mng_promote_replicate_1_2 (mng_uint8 iB)
+{
+  return (mng_uint8)((iB << 1) | iB);
+}
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_replicate_1_4 (mng_uint8 iB)
+{
+  iB = (mng_uint8)((iB << 1) + iB);
+  return (mng_uint8)((iB << 2) + iB);
+}
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_replicate_1_8 (mng_uint8 iB)
+{
+  iB = (mng_uint8)((iB << 1) + iB);
+  iB = (mng_uint8)((iB << 2) + iB);
+  return (mng_uint8)((iB << 4) + iB);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_replicate_1_16 (mng_uint8 iB)
+{
+  iB = (mng_uint8)((iB << 1) + iB);
+  iB = (mng_uint8)((iB << 2) + iB);
+  iB = (mng_uint8)((iB << 4) + iB);
+  return (mng_uint16)(((mng_uint16)iB << 8) + (mng_uint16)iB);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_replicate_2_4 (mng_uint8 iB)
+{
+  return (mng_uint8)((iB << 2) + iB);
+}
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_replicate_2_8 (mng_uint8 iB)
+{
+  iB = (mng_uint8)((iB << 2) + iB);
+  return (mng_uint8)((iB << 4) + iB);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_replicate_2_16 (mng_uint8 iB)
+{
+  iB = (mng_uint8)((iB << 2) + iB);
+  iB = (mng_uint8)((iB << 4) + iB);
+  return (mng_uint16)(((mng_uint16)iB << 8) + (mng_uint16)iB);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_replicate_4_8 (mng_uint8 iB)
+{
+  return (mng_uint8)((iB << 4) + iB);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_replicate_4_16 (mng_uint8 iB)
+{
+  iB = (mng_uint8)((iB << 4) + iB);
+  return (mng_uint16)(((mng_uint16)iB << 8) + (mng_uint16)iB);
+}
+#endif
+#endif /* NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_replicate_8_16 (mng_uint8 iB)
+{
+  return (mng_uint16)(((mng_uint16)iB << 8) + (mng_uint16)iB);
+}
+#endif
+
+/* ************************************************************************** */
+
+#if !defined(MNG_NO_DELTA_PNG)
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_uint8 mng_promote_zerofill_1_2 (mng_uint8 iB)
+{
+  return (mng_uint8)(iB << 1);
+}
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_zerofill_1_4 (mng_uint8 iB)
+{
+  return (mng_uint8)(iB << 3);
+}
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_zerofill_1_8 (mng_uint8 iB)
+{
+  return (mng_uint8)(iB << 7);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_zerofill_1_16 (mng_uint8 iB)
+{
+  return (mng_uint16)((mng_uint16)iB << 15);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_zerofill_2_4 (mng_uint8 iB)
+{
+  return (mng_uint8)(iB << 2);
+}
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_zerofill_2_8 (mng_uint8 iB)
+{
+  return (mng_uint8)(iB << 6);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_zerofill_2_16 (mng_uint8 iB)
+{
+  return (mng_uint16)((mng_uint16)iB << 14);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_uint8 mng_promote_zerofill_4_8 (mng_uint8 iB)
+{
+  return (mng_uint8)(iB << 4);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_zerofill_4_16 (mng_uint8 iB)
+{
+  return (mng_uint16)((mng_uint16)iB << 12);
+}
+#endif
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16 mng_promote_zerofill_8_16 (mng_uint8 iB)
+{
+  return (mng_uint16)((mng_uint16)iB << 8);
+}
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - promote color_type                          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if !defined(MNG_NO_DELTA_PNG) || !defined(MNG_SKIPCHUNK_PAST) || !defined(MNG_SKIPCHUNK_MAGN)
+mng_retcode mng_promote_g8_g8 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint8  iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_G8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+    if (pData->fPromBitdepth)      /* bitdepth promoted ? */
+      iB = ((mng_bitdepth_8)pData->fPromBitdepth) (iB);
+    *pDstline = iB;
+
+    pSrcline++;
+    pDstline++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_g16 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint16 iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_G16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iW = ((mng_bitdepth_16)pData->fPromBitdepth) (*pSrcline);
+
+    *pDstline     = (mng_uint8)(iW >> 8);
+    *(pDstline+1) = (mng_uint8)(iW && 0xFF);
+
+    pSrcline++;
+    pDstline += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_g16_g16 (mng_datap pData)
+{
+  mng_uint16p pSrcline = (mng_uint16p)pData->pPromSrc;
+  mng_uint16p pDstline = (mng_uint16p)pData->pPromDst;
+  mng_uint32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_G16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    *pDstline = *pSrcline;
+    pSrcline++;
+    pDstline++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_g8_ga8 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_GA8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || ((mng_uint16)iB != pBuf->iTRNSgray))
+      *(pDstline+1) = 0xFF;
+
+    if (pData->fPromBitdepth)      /* bitdepth promoted ? */
+      iB = ((mng_bitdepth_8)pData->fPromBitdepth) (iB);
+
+    *pDstline = iB;
+
+    pSrcline++;
+    pDstline += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_GA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_ga16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iB;
+  mng_uint16     iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_GA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || ((mng_uint16)iB != pBuf->iTRNSgray))
+    {
+      *(pDstline+2) = 0xFF;
+      *(pDstline+3) = 0xFF;
+    }
+
+    iW = ((mng_bitdepth_16)pData->fPromBitdepth) (iB);
+
+    *pDstline     = (mng_uint8)(iW >> 8);
+    *(pDstline+1) = (mng_uint8)(iW && 0xFF);
+
+    pSrcline++;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g16_ga16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint16p    pSrcline = (mng_uint16p)pData->pPromSrc;
+  mng_uint16p    pDstline = (mng_uint16p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint16     iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_GA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iW = *pSrcline;
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || ((mng_uint16)iW != pBuf->iTRNSgray))
+      *(pDstline+1) = 0xFFFF;
+
+    *pDstline = iW;
+
+    pSrcline++;
+    pDstline += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_g8_rgb8 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint8  iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGB8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+
+    if (pData->fPromBitdepth)      /* bitdepth promoted ? */
+      iB = ((mng_bitdepth_8)pData->fPromBitdepth) (iB);
+
+    *pDstline     = iB;
+    *(pDstline+1) = iB;
+    *(pDstline+2) = iB;
+
+    pSrcline++;
+    pDstline += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_rgb16 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint8  iB;
+  mng_uint16 iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGB16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+    iW = ((mng_bitdepth_16)pData->fPromBitdepth) (iB);
+
+    iB            = (mng_uint8)(iW >> 8);
+    *pDstline     = iB;
+    *(pDstline+2) = iB;
+    *(pDstline+4) = iB;
+    iB            = (mng_uint8)(iW && 0xFF);
+    *(pDstline+1) = iB;
+    *(pDstline+3) = iB;
+    *(pDstline+5) = iB;
+
+    pSrcline++;
+    pDstline += 6;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g16_rgb16 (mng_datap pData)
+{
+  mng_uint16p pSrcline = (mng_uint16p)pData->pPromSrc;
+  mng_uint16p pDstline = (mng_uint16p)pData->pPromDst;
+  mng_uint32  iX;
+  mng_uint16  iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_RGB16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iW = *pSrcline;
+
+    *pDstline     = iW;
+    *(pDstline+1) = iW;
+    *(pDstline+2) = iW;
+
+    pSrcline++;
+    pDstline += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_g8_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGBA8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || ((mng_uint16)iB != pBuf->iTRNSgray))
+      *(pDstline+3) = 0xFF;
+
+    if (pData->fPromBitdepth)      /* bitdepth promoted ? */
+      iB = ((mng_bitdepth_8)pData->fPromBitdepth) (iB);
+
+    *pDstline     = iB;
+    *(pDstline+1) = iB;
+    *(pDstline+2) = iB;
+
+    pSrcline++;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iB;
+  mng_uint16     iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || ((mng_uint16)iB != pBuf->iTRNSgray))
+    {
+      *(pDstline+6) = 0xFF;
+      *(pDstline+7) = 0xFF;
+    }
+
+    iW            = ((mng_bitdepth_16)pData->fPromBitdepth) (iB);
+
+    iB            = (mng_uint8)(iW >> 8);
+    *pDstline     = iB;
+    *(pDstline+2) = iB;
+    *(pDstline+4) = iB;
+    iB            = (mng_uint8)(iW && 0xFF);
+    *(pDstline+1) = iB;
+    *(pDstline+3) = iB;
+    *(pDstline+5) = iB;;
+
+    pSrcline++;
+    pDstline += 8;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G8_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g16_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint16p    pSrcline = (mng_uint16p)pData->pPromSrc;
+  mng_uint16p    pDstline = (mng_uint16p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint16     iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iW = *pSrcline;
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || (iW != pBuf->iTRNSgray))
+      *(pDstline+3) = 0xFFFF;
+
+    *pDstline     = iW;
+    *(pDstline+1) = iW;
+    *(pDstline+2) = iW;
+
+    pSrcline++;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_G16_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_ga8_ga16 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint16 iW;
+  mng_uint16 iA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA8_GA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iW = ((mng_bitdepth_16)pData->fPromBitdepth) (*pSrcline);
+    iA = ((mng_bitdepth_16)pData->fPromBitdepth) (*(pSrcline+1));
+
+    *pDstline     = (mng_uint8)(iW >> 8);
+    *(pDstline+1) = (mng_uint8)(iW && 0xFF);
+    *(pDstline+2) = (mng_uint8)(iA >> 8);
+    *(pDstline+3) = (mng_uint8)(iA && 0xFF);
+
+    pSrcline += 2;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA8_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_ga8_rgba8 (mng_datap pData)
+{
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iB;
+  mng_uint8      iA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA8_RGBA8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+    iA = *(pSrcline+1);
+
+    *pDstline     = iB;
+    *(pDstline+1) = iB;
+    *(pDstline+2) = iB;
+    *(pDstline+3) = iA;
+
+    pSrcline += 2;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA8_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_ga8_rgba16 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint8  iB;
+  mng_uint16 iW;
+  mng_uint16 iA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA8_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iW = ((mng_bitdepth_16)pData->fPromBitdepth) (*pSrcline);
+    iA = ((mng_bitdepth_16)pData->fPromBitdepth) (*(pSrcline+1));
+
+    iB            = (mng_uint8)(iW >> 8);
+    *pDstline     = iB;
+    *(pDstline+2) = iB;
+    *(pDstline+4) = iB;
+    iB            = (mng_uint8)(iW && 0xFF);
+    *(pDstline+1) = iB;
+    *(pDstline+3) = iB;
+    *(pDstline+5) = iB;
+    *(pDstline+6) = (mng_uint8)(iA >> 8);
+    *(pDstline+7) = (mng_uint8)(iA && 0xFF);
+
+    pSrcline += 2;
+    pDstline += 8;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA8_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_ga16_rgba16 (mng_datap pData)
+{
+  mng_uint16p pSrcline = (mng_uint16p)pData->pPromSrc;
+  mng_uint16p pDstline = (mng_uint16p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint16 iW;
+  mng_uint16 iA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA16_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iW = *pSrcline;
+    iA = *(pSrcline+1);
+
+    *pDstline     = iW;
+    *(pDstline+1) = iW;
+    *(pDstline+2) = iW;
+    *(pDstline+3) = iA;
+
+    pSrcline += 2;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_GA16_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_rgb8_rgb16 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint16 iR;
+  mng_uint16 iG;
+  mng_uint16 iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB8_RGB16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iR            = ((mng_bitdepth_16)pData->fPromBitdepth) (*pSrcline);
+    iG            = ((mng_bitdepth_16)pData->fPromBitdepth) (*(pSrcline+1));
+    iB            = ((mng_bitdepth_16)pData->fPromBitdepth) (*(pSrcline+2));
+
+    *pDstline     = (mng_uint8)(iR >> 8);
+    *(pDstline+1) = (mng_uint8)(iR && 0xFF);
+    *(pDstline+2) = (mng_uint8)(iG >> 8);
+    *(pDstline+3) = (mng_uint8)(iG && 0xFF);
+    *(pDstline+4) = (mng_uint8)(iB >> 8);
+    *(pDstline+5) = (mng_uint8)(iB && 0xFF);
+
+    pSrcline += 3;
+    pDstline += 6;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB8_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_rgb8_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iR;
+  mng_uint8      iG;
+  mng_uint8      iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB8_RGBA8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iR = *pSrcline;
+    iG = *(pSrcline+1);
+    iB = *(pSrcline+2);
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || ((mng_uint16)iR != pBuf->iTRNSred) ||
+        ((mng_uint16)iG != pBuf->iTRNSgreen) || ((mng_uint16)iB != pBuf->iTRNSblue))
+      *(pDstline+3) = 0xFF;
+
+    *pDstline     = iR;
+    *(pDstline+1) = iG;
+    *(pDstline+2) = iB;
+
+    pSrcline += 3;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB8_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_rgb8_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iR;
+  mng_uint8      iG;
+  mng_uint8      iB;
+  mng_uint16     iRw;
+  mng_uint16     iGw;
+  mng_uint16     iBw;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB8_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iR = *pSrcline;
+    iG = *(pSrcline+1);
+    iB = *(pSrcline+2);
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || ((mng_uint16)iR != pBuf->iTRNSred) ||
+        ((mng_uint16)iG != pBuf->iTRNSgreen) || ((mng_uint16)iB != pBuf->iTRNSblue))
+    {
+      *(pDstline+6) = 0xFF;
+      *(pDstline+7) = 0xFF;
+    }
+
+    iRw           = ((mng_bitdepth_16)pData->fPromBitdepth) (iR);
+    iGw           = ((mng_bitdepth_16)pData->fPromBitdepth) (iG);
+    iBw           = ((mng_bitdepth_16)pData->fPromBitdepth) (iB);
+
+    *pDstline     = (mng_uint8)(iRw >> 8);
+    *(pDstline+1) = (mng_uint8)(iRw && 0xFF);
+    *(pDstline+2) = (mng_uint8)(iGw >> 8);
+    *(pDstline+3) = (mng_uint8)(iGw && 0xFF);
+    *(pDstline+4) = (mng_uint8)(iBw >> 8);
+    *(pDstline+5) = (mng_uint8)(iBw && 0xFF);
+
+    pSrcline += 3;
+    pDstline += 8;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB8_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_rgb16_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint16p    pSrcline = (mng_uint16p)pData->pPromSrc;
+  mng_uint16p    pDstline = (mng_uint16p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint16     iR;
+  mng_uint16     iG;
+  mng_uint16     iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB16_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iR = *pSrcline;
+    iG = *(pSrcline+1);
+    iB = *(pSrcline+2);
+                                   /* no cheap transparency ? */
+    if ((!pBuf->bHasTRNS) || (iR != pBuf->iTRNSred) ||
+        (iG != pBuf->iTRNSgreen) || (iB != pBuf->iTRNSblue))
+      *(pDstline+3) = 0xFFFF;
+
+    *pDstline     = iR;
+    *(pDstline+1) = iG;
+    *(pDstline+2) = iB;
+
+    pSrcline += 3;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGB16_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_idx8_rgb8 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGB8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+
+    if ((mng_uint32)iB < pBuf->iPLTEcount)
+    {
+      *pDstline     = pBuf->aPLTEentries [iB].iRed;
+      *(pDstline+1) = pBuf->aPLTEentries [iB].iGreen;
+      *(pDstline+2) = pBuf->aPLTEentries [iB].iBlue;
+    }
+
+    pSrcline++;
+    pDstline += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_idx8_rgb16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iN;
+  mng_uint16     iR;
+  mng_uint16     iG;
+  mng_uint16     iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGB16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iN = *pSrcline;
+
+    if ((mng_uint32)iN < pBuf->iPLTEcount)
+    {
+      iR              = ((mng_bitdepth_16)pData->fPromBitdepth) (pBuf->aPLTEentries [iN].iRed);
+      iG              = ((mng_bitdepth_16)pData->fPromBitdepth) (pBuf->aPLTEentries [iN].iGreen);
+      iB              = ((mng_bitdepth_16)pData->fPromBitdepth) (pBuf->aPLTEentries [iN].iBlue);
+      *pDstline       = (mng_uint8)(iR >> 8);
+      *(pDstline+1)   = (mng_uint8)(iR && 0xFF);
+      *(pDstline+2)   = (mng_uint8)(iG >> 8);
+      *(pDstline+3)   = (mng_uint8)(iG && 0xFF);
+      *(pDstline+4)   = (mng_uint8)(iB >> 8);
+      *(pDstline+5)   = (mng_uint8)(iB && 0xFF);
+    }
+
+    pSrcline++;
+    pDstline += 6;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_idx8_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGBA8, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iB = *pSrcline;
+
+    if ((mng_uint32)iB < pBuf->iPLTEcount)
+    {
+      *pDstline       = pBuf->aPLTEentries [iB].iRed;
+      *(pDstline+1)   = pBuf->aPLTEentries [iB].iGreen;
+      *(pDstline+2)   = pBuf->aPLTEentries [iB].iBlue;
+
+      if ((pBuf->bHasTRNS) && ((mng_uint32)iB < pBuf->iTRNScount))
+        *(pDstline+3) = pBuf->aTRNSentries [iB];
+      else
+        *(pDstline+3) = 0xFF;
+    }
+
+    pSrcline++;
+    pDstline += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_idx8_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf     = (mng_imagedatap)pData->pPromBuf;
+  mng_uint8p     pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p     pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32     iX;
+  mng_uint8      iN;
+  mng_uint16     iR;
+  mng_uint16     iG;
+  mng_uint16     iB;
+  mng_uint16     iA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iN = *pSrcline;
+
+    if ((mng_uint32)iN < pBuf->iPLTEcount)
+    {
+      iR            = ((mng_bitdepth_16)pData->fPromBitdepth) (pBuf->aPLTEentries [iN].iRed);
+      iG            = ((mng_bitdepth_16)pData->fPromBitdepth) (pBuf->aPLTEentries [iN].iGreen);
+      iB            = ((mng_bitdepth_16)pData->fPromBitdepth) (pBuf->aPLTEentries [iN].iBlue);
+
+      if ((pBuf->bHasTRNS) && ((mng_uint32)iN < pBuf->iTRNScount))
+        iA          = ((mng_bitdepth_16)pData->fPromBitdepth) (pBuf->aTRNSentries [iN]);
+      else
+        iA          = 0xFFFF;
+
+      *pDstline     = (mng_uint8)(iR >> 8);
+      *(pDstline+1) = (mng_uint8)(iR && 0xFF);
+      *(pDstline+2) = (mng_uint8)(iG >> 8);
+      *(pDstline+3) = (mng_uint8)(iG && 0xFF);
+      *(pDstline+4) = (mng_uint8)(iB >> 8);
+      *(pDstline+5) = (mng_uint8)(iB && 0xFF);
+      *(pDstline+6) = (mng_uint8)(iA >> 8);
+      *(pDstline+7) = (mng_uint8)(iA && 0xFF);
+    }
+
+    pSrcline++;
+    pDstline += 8;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_IDX8_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_promote_rgba8_rgba16 (mng_datap pData)
+{
+  mng_uint8p pSrcline = (mng_uint8p)pData->pPromSrc;
+  mng_uint8p pDstline = (mng_uint8p)pData->pPromDst;
+  mng_uint32 iX;
+  mng_uint16 iR;
+  mng_uint16 iG;
+  mng_uint16 iB;
+  mng_uint16 iA;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGBA8_RGBA16, MNG_LC_START);
+#endif
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iPromWidth; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iPromWidth; iX++)
+#endif
+  {
+    iR            = ((mng_bitdepth_16)pData->fPromBitdepth) (*pSrcline);
+    iG            = ((mng_bitdepth_16)pData->fPromBitdepth) (*(pSrcline+1));
+    iB            = ((mng_bitdepth_16)pData->fPromBitdepth) (*(pSrcline+2));
+    iA            = ((mng_bitdepth_16)pData->fPromBitdepth) (*(pSrcline+3));
+
+    *pDstline     = (mng_uint8)(iR >> 8);
+    *(pDstline+1) = (mng_uint8)(iR && 0xFF);
+    *(pDstline+2) = (mng_uint8)(iG >> 8);
+    *(pDstline+3) = (mng_uint8)(iG && 0xFF);
+    *(pDstline+4) = (mng_uint8)(iB >> 8);
+    *(pDstline+5) = (mng_uint8)(iB && 0xFF);
+    *(pDstline+6) = (mng_uint8)(iA >> 8);
+    *(pDstline+7) = (mng_uint8)(iA && 0xFF);
+
+    pSrcline += 4;
+    pDstline += 8;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROMOTE_RGBA8_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* !defined(MNG_NO_DELTA_PNG) || !defined(MNG_SKIPCHUNK_PAST) || !defined(MNG_SKIPCHUNK_MAGN) */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row processing routines - convert uncompressed data from zlib to       * */
+/* * managable row-data which serves as input to the color-management       * */
+/* * routines                                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_process_g1 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G1, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+    if (pBuf->iTRNSgray)               /* white transparent ? */
+    {
+#ifdef MNG_DECREMENT_LOOPS
+      for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+      for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+      {
+        if (!iM)                       /* mask underflow ? */
+        {
+          iB = *pWorkrow;              /* get next input-byte */
+          pWorkrow++;
+          iM = 0x80;
+        }
+
+        if (iB & iM)                   /* is it white ? */
+                                       /* transparent ! */
+          mng_put_uint32 (pRGBArow, 0x00000000);
+        else                           /* opaque black */
+          mng_put_uint32 (pRGBArow, 0x000000FF);
+
+        pRGBArow += 4;                 /* next pixel */
+        iM >>=  1;
+      }
+    }
+    else                               /* black transparent */
+    {
+#ifdef MNG_DECREMENT_LOOPS
+      for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+      for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+      {
+        if (!iM)                       /* mask underflow ? */
+        {
+          iB = *pWorkrow;              /* get next input-byte */
+          pWorkrow++;
+          iM = 0x80;
+        }
+
+        if (iB & iM)                   /* is it white ? */
+                                       /* opaque white */
+          mng_put_uint32 (pRGBArow, 0xFFFFFFFF);
+        else                           /* transparent */
+          mng_put_uint32 (pRGBArow, 0x00000000);
+
+        pRGBArow += 4;                 /* next pixel */
+        iM >>=  1;
+      }
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else                                 /* no transparency */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0x80;
+      }
+
+      if (iB & iM)                     /* is it white ? */
+                                       /* opaque white */
+        mng_put_uint32 (pRGBArow, 0xFFFFFFFF);
+      else                             /* opaque black */
+        mng_put_uint32 (pRGBArow, 0x000000FF);
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  1;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_g2 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+  const mng_uint32  level[4] = { 0x000000FF, 0x555555FF,
+          0xAAAAAAFF, 0xFFFFFFFF};
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G2, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+                                       /* determine gray level */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+
+      if (iQ == pBuf->iTRNSgray)       /* transparent ? */
+        mng_put_uint32 (pRGBArow, 0x00000000);
+      else
+      {
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+        mng_put_uint32 (pRGBArow, level[iQ]);
+#else
+        switch (iQ)                    /* determine the gray level */
+        {
+          case 0x03 : { mng_put_uint32 (pRGBArow, 0xFFFFFFFF); break; }
+          case 0x02 : { mng_put_uint32 (pRGBArow, 0xAAAAAAFF); break; }
+          case 0x01 : { mng_put_uint32 (pRGBArow, 0x555555FF); break; }
+          default   : { mng_put_uint32 (pRGBArow, 0x000000FF); }
+        }
+#endif
+      }
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_SWITCH
+      mng_put_uint32 (pRGBArow, level[((iB & iM) >> iS)] );
+#else
+      switch ((iB & iM) >> iS)         /* determine the gray level */
+      {
+        case 0x03 : { mng_put_uint32 (pRGBArow, 0xFFFFFFFF); break; }
+        case 0x02 : { mng_put_uint32 (pRGBArow, 0xAAAAAAFF); break; }
+        case 0x01 : { mng_put_uint32 (pRGBArow, 0x555555FF); break; }
+        default   : { mng_put_uint32 (pRGBArow, 0x000000FF); }
+      }
+#endif
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_g4 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G4, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* get the gray level */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+
+      if (iQ == pBuf->iTRNSgray)       /* transparent ? */
+      {
+        *pRGBArow     = 0;             /* put in intermediate row */
+        *(pRGBArow+1) = 0;
+        *(pRGBArow+2) = 0;
+        *(pRGBArow+3) = 0;
+      }
+      else
+      {                                /* expand to 8-bit by replication */
+        iQ = (mng_uint8)(iQ + (iQ << 4));
+
+        *pRGBArow     = iQ;            /* put in intermediate row */
+        *(pRGBArow+1) = iQ;
+        *(pRGBArow+2) = iQ;
+        *(pRGBArow+3) = 0xFF;
+      }
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* get the gray level */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+      iQ = (mng_uint8)(iQ + (iQ << 4));/* expand to 8-bit by replication */
+
+      *pRGBArow     = iQ;              /* put in intermediate row */
+      *(pRGBArow+1) = iQ;
+      *(pRGBArow+2) = iQ;
+      *(pRGBArow+3) = 0xFF;
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_g8 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G8, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+
+      if (iB == pBuf->iTRNSgray)       /* transparent ? */
+      {
+        *pRGBArow     = 0;             /* put in intermediate row */
+        *(pRGBArow+1) = 0;
+        *(pRGBArow+2) = 0;
+        *(pRGBArow+3) = 0;
+      }
+      else
+      {
+        *pRGBArow     = iB;            /* put in intermediate row */
+        *(pRGBArow+1) = iB;
+        *(pRGBArow+2) = iB;
+        *(pRGBArow+3) = 0xFF;
+      }
+
+      pRGBArow += 4;                   /* next pixel */
+      pWorkrow++;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iB = *pWorkrow;                  /* get next input-byte */
+
+      *pRGBArow     = iB;              /* put in intermediate row */
+      *(pRGBArow+1) = iB;
+      *(pRGBArow+2) = iB;
+      *(pRGBArow+3) = 0xFF;
+
+      pRGBArow += 4;                   /* next pixel */
+      pWorkrow++;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_process_g16 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint16     iW;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G16, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iW = mng_get_uint16 (pWorkrow);  /* get input */
+
+      if (iW == pBuf->iTRNSgray)       /* transparent ? */
+      {                                /* put in intermediate row */
+        mng_put_uint16 (pRGBArow,   0);
+        mng_put_uint16 (pRGBArow+2, 0);
+        mng_put_uint16 (pRGBArow+4, 0);
+        mng_put_uint16 (pRGBArow+6, 0);
+      }
+      else
+      {                                /* put in intermediate row */
+        mng_put_uint16 (pRGBArow,   iW);
+        mng_put_uint16 (pRGBArow+2, iW);
+        mng_put_uint16 (pRGBArow+4, iW);
+        mng_put_uint16 (pRGBArow+6, 0xFFFF);
+      }
+
+      pRGBArow += 8;                   /* next pixel */
+      pWorkrow += 2;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iW = mng_get_uint16 (pWorkrow);  /* get input */
+
+      mng_put_uint16 (pRGBArow,   iW); /* and put in intermediate row */
+      mng_put_uint16 (pRGBArow+2, iW);
+      mng_put_uint16 (pRGBArow+4, iW);
+      mng_put_uint16 (pRGBArow+6, 0xFFFF);
+
+      pRGBArow += 8;                   /* next pixel */
+      pWorkrow += 2;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_G16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_rgb8 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iR, iG, iB;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGB8, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iR = *pWorkrow;                  /* get the RGB values */
+      iG = *(pWorkrow+1);
+      iB = *(pWorkrow+2);
+                                       /* transparent ? */
+      if ((iR == pBuf->iTRNSred) && (iG == pBuf->iTRNSgreen) &&
+          (iB == pBuf->iTRNSblue))
+      {
+        *pRGBArow     = 0;             /* this pixel is transparent ! */
+        *(pRGBArow+1) = 0;
+        *(pRGBArow+2) = 0;
+        *(pRGBArow+3) = 0;
+      }
+      else
+      {
+        *pRGBArow     = iR;            /* copy the RGB values */
+        *(pRGBArow+1) = iG;
+        *(pRGBArow+2) = iB;
+        *(pRGBArow+3) = 0xFF;          /* this one isn't transparent */
+      }
+
+      pWorkrow += 3;                   /* next pixel */
+      pRGBArow += 4;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      *pRGBArow     = *pWorkrow;       /* copy the RGB bytes */
+      *(pRGBArow+1) = *(pWorkrow+1);
+      *(pRGBArow+2) = *(pWorkrow+2);
+      *(pRGBArow+3) = 0xFF;            /* no alpha; so always fully opaque */
+
+      pWorkrow += 3;                   /* next pixel */
+      pRGBArow += 4;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGB8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_process_rgb16 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint16     iR, iG, iB;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGB16, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iR = mng_get_uint16 (pWorkrow);  /* get the RGB values */
+      iG = mng_get_uint16 (pWorkrow+2);
+      iB = mng_get_uint16 (pWorkrow+4);
+                                       /* transparent ? */
+      if ((iR == pBuf->iTRNSred) && (iG == pBuf->iTRNSgreen) &&
+          (iB == pBuf->iTRNSblue))
+      {                                /* transparent then */
+        mng_put_uint16 (pRGBArow,   0);
+        mng_put_uint16 (pRGBArow+2, 0);
+        mng_put_uint16 (pRGBArow+4, 0);
+        mng_put_uint16 (pRGBArow+6, 0);
+      }
+      else
+      {                                /* put in intermediate row */
+        mng_put_uint16 (pRGBArow,   iR);
+        mng_put_uint16 (pRGBArow+2, iG);
+        mng_put_uint16 (pRGBArow+4, iB);
+        mng_put_uint16 (pRGBArow+6, 0xFFFF);
+      }
+
+      pWorkrow += 6;                   /* next pixel */
+      pRGBArow += 8;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {                                  /* copy the RGB values */
+      mng_put_uint16 (pRGBArow,   mng_get_uint16 (pWorkrow  ));
+      mng_put_uint16 (pRGBArow+2, mng_get_uint16 (pWorkrow+2));
+      mng_put_uint16 (pRGBArow+4, mng_get_uint16 (pWorkrow+4));
+      mng_put_uint16 (pRGBArow+6, 0xFFFF);
+
+      pWorkrow += 6;                   /* next pixel */
+      pRGBArow += 8;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGB16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_process_idx1 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX1, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0x80;
+        iS = 7;
+      }
+                                       /* get the index */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        *pRGBArow     = pBuf->aPLTEentries [iQ].iRed;
+        *(pRGBArow+1) = pBuf->aPLTEentries [iQ].iGreen;
+        *(pRGBArow+2) = pBuf->aPLTEentries [iQ].iBlue;
+                                       /* transparency for this index ? */
+        if ((mng_uint32)iQ < pBuf->iTRNScount)
+          *(pRGBArow+3) = pBuf->aTRNSentries [iQ];
+        else
+          *(pRGBArow+3) = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  1;
+      iS -= 1;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0x80;
+        iS = 7;
+      }
+                                       /* get the index */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        *pRGBArow     = pBuf->aPLTEentries [iQ].iRed;
+        *(pRGBArow+1) = pBuf->aPLTEentries [iQ].iGreen;
+        *(pRGBArow+2) = pBuf->aPLTEentries [iQ].iBlue;
+        *(pRGBArow+3) = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  1;
+      iS -= 1;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_idx2 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX2, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+                                       /* get the index */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        *pRGBArow     = pBuf->aPLTEentries [iQ].iRed;
+        *(pRGBArow+1) = pBuf->aPLTEentries [iQ].iGreen;
+        *(pRGBArow+2) = pBuf->aPLTEentries [iQ].iBlue;
+                                       /* transparency for this index ? */
+        if ((mng_uint32)iQ < pBuf->iTRNScount)
+          *(pRGBArow+3) = pBuf->aTRNSentries [iQ];
+        else
+          *(pRGBArow+3) = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = *pWorkrow;                /* get next input-byte */
+        pWorkrow++;
+        iM = 0xC0;
+        iS = 6;
+      }
+                                       /* get the index */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        *pRGBArow     = pBuf->aPLTEentries [iQ].iRed;
+        *(pRGBArow+1) = pBuf->aPLTEentries [iQ].iGreen;
+        *(pRGBArow+2) = pBuf->aPLTEentries [iQ].iBlue;
+        *(pRGBArow+3) = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  2;
+      iS -= 2;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_idx4 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iB;
+  mng_uint8      iM;
+  mng_uint32     iS;
+  mng_uint8      iQ;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX4, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+  iM       = 0;                        /* start at pixel 0 */
+  iB       = 0;
+  iS       = 0;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = pWorkrow [0];             /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* get the index */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        pRGBArow [0] = pBuf->aPLTEentries [iQ].iRed;
+        pRGBArow [1] = pBuf->aPLTEentries [iQ].iGreen;
+        pRGBArow [2] = pBuf->aPLTEentries [iQ].iBlue;
+                                       /* transparency for this index ? */
+        if ((mng_uint32)iQ < pBuf->iTRNScount)
+          pRGBArow [3] = pBuf->aTRNSentries [iQ];
+        else
+          pRGBArow [3] = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      if (!iM)                         /* mask underflow ? */
+      {
+        iB = pWorkrow [0];             /* get next input-byte */
+        pWorkrow++;
+        iM = 0xF0;
+        iS = 4;
+      }
+                                       /* get the index */
+      iQ = (mng_uint8)((iB & iM) >> iS);
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        pRGBArow [0] = pBuf->aPLTEentries [iQ].iRed;
+        pRGBArow [1] = pBuf->aPLTEentries [iQ].iGreen;
+        pRGBArow [2] = pBuf->aPLTEentries [iQ].iBlue;
+        pRGBArow [3] = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      iM >>=  4;
+      iS -= 4;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_idx8 (mng_datap pData)
+{
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pRGBArow;
+  mng_int32      iX;
+  mng_uint8      iQ;
+  mng_imagedatap pBuf = (mng_imagedatap)pData->pStorebuf;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX8, MNG_LC_START);
+#endif
+
+  if (!pBuf)                           /* no object? then use obj 0 */
+    pBuf = ((mng_imagep)pData->pObjzero)->pImgbuf;
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+
+  if (pBuf->bHasTRNS)                  /* tRNS encountered ? */
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iQ = *pWorkrow;                  /* get input byte */
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        pRGBArow [0] = pBuf->aPLTEentries [iQ].iRed;
+        pRGBArow [1] = pBuf->aPLTEentries [iQ].iGreen;
+        pRGBArow [2] = pBuf->aPLTEentries [iQ].iBlue;
+                                       /* transparency for this index ? */
+        if ((mng_uint32)iQ < pBuf->iTRNScount)
+          pRGBArow [3] = pBuf->aTRNSentries [iQ];
+        else
+          pRGBArow [3] = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      pWorkrow++;
+    }
+
+    pData->bIsOpaque = MNG_FALSE;      /* it's not fully opaque */
+  }
+  else
+  {
+#ifdef MNG_DECREMENT_LOOPS
+    for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+    for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+    {
+      iQ = *pWorkrow;                  /* get input byte */
+                                       /* index valid ? */
+      if ((mng_uint32)iQ < pBuf->iPLTEcount)
+      {                                /* put in intermediate row */
+        pRGBArow [0] = pBuf->aPLTEentries [iQ].iRed;
+        pRGBArow [1] = pBuf->aPLTEentries [iQ].iGreen;
+        pRGBArow [2] = pBuf->aPLTEentries [iQ].iBlue;
+        pRGBArow [3] = 0xFF;
+      }
+      else
+        MNG_ERROR (pData, MNG_PLTEINDEXERROR);
+
+      pRGBArow += 4;                   /* next pixel */
+      pWorkrow++;
+    }
+
+    pData->bIsOpaque = MNG_TRUE;       /* it's fully opaque */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_IDX8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_ga8 (mng_datap pData)
+{
+  mng_uint8p pWorkrow;
+  mng_uint8p pRGBArow;
+  mng_int32  iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_GA8, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    *pRGBArow     = *pWorkrow;         /* copy the gray value */
+    *(pRGBArow+1) = *pWorkrow;
+    *(pRGBArow+2) = *pWorkrow;
+    *(pRGBArow+3) = *(pWorkrow+1);     /* copy the alpha value */
+
+    pWorkrow += 2;                     /* next pixel */
+    pRGBArow += 4;
+  }
+
+  pData->bIsOpaque = MNG_FALSE;        /* it's definitely not fully opaque */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_GA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_process_ga16 (mng_datap pData)
+{
+  mng_uint8p  pWorkrow;
+  mng_uint8p  pRGBArow;
+  mng_int32  iX;
+  mng_uint16 iW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_GA16, MNG_LC_START);
+#endif
+                                       /* temporary work pointers */
+  pWorkrow = pData->pWorkrow + pData->iPixelofs;
+  pRGBArow = pData->pRGBArow;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    iW = mng_get_uint16 (pWorkrow);    /* copy the gray value */
+    mng_put_uint16 (pRGBArow,   iW);
+    mng_put_uint16 (pRGBArow+2, iW);
+    mng_put_uint16 (pRGBArow+4, iW);
+                                       /* copy the alpha value */
+    mng_put_uint16 (pRGBArow+6, mng_get_uint16 (pWorkrow+2));
+
+    pWorkrow += 4;                     /* next pixel */
+    pRGBArow += 8;
+  }
+
+  pData->bIsOpaque = MNG_FALSE;        /* it's definitely not fully opaque */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_GA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_rgba8 (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGBA8, MNG_LC_START);
+#endif
+                                       /* this is the easiest transform */
+  MNG_COPY (pData->pRGBArow, pData->pWorkrow + pData->iPixelofs, pData->iRowsize);
+
+  pData->bIsOpaque = MNG_FALSE;        /* it's definitely not fully opaque */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_process_rgba16 (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGBA16, MNG_LC_START);
+#endif
+                                       /* this is the easiest transform */
+  MNG_COPY (pData->pRGBArow, pData->pWorkrow + pData->iPixelofs, pData->iRowsize);
+
+  pData->bIsOpaque = MNG_FALSE;        /* it's definitely not fully opaque */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row processing initialization routines - set up the variables needed   * */
+/* * to process uncompressed row-data                                       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_FOOTPRINT_INIT
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_g1_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G1_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g1;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g1;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g1;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g1;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 7;
+  pData->iSamplediv  = 3;
+  pData->iRowsize    = (pData->iRowsamples + 7) >> 3;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G1_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_g1_i      (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G1_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g1;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g1;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g1;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g1;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 7;
+  pData->iSamplediv  = 3;
+  pData->iRowsize    = ((pData->iRowsamples + 7) >> 3);
+  pData->iRowmax     = ((pData->iDatawidth + 7) >> 3) + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G1_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_g2_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G2_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g2;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g2;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g2;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g2;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 3;
+  pData->iSamplediv  = 2;
+  pData->iRowsize    = (pData->iRowsamples + 3) >> 2;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G2_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_g2_i      (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G2_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g2;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g2;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g2;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g2;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 3;
+  pData->iSamplediv  = 2;
+  pData->iRowsize    = ((pData->iRowsamples + 3) >> 2);
+  pData->iRowmax     = ((pData->iDatawidth + 3) >> 2) + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G2_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_g4_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G4_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g4;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g4;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g4;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g4;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 1;
+  pData->iSamplediv  = 1;
+  pData->iRowsize    = (pData->iRowsamples + 1) >> 1;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G4_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_g4_i      (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G4_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g4;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g4;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g4;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g4;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 1;
+  pData->iSamplediv  = 1;
+  pData->iRowsize    = ((pData->iRowsamples + 1) >> 1);
+  pData->iRowmax     = ((pData->iDatawidth + 1) >> 1) + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G4_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_g8_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G8_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g8;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G8_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_g8_i      (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G8_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g8;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples;
+  pData->iRowmax     = pData->iDatawidth + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G8_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_g16_ni    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G16_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g16;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 2;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 1;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 2;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G16_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_g16_i     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G16_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_g16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_g16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_g16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g16;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 2;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 1;
+  pData->iRowmax     = (pData->iDatawidth << 1) + pData->iPixelofs;
+  pData->iFilterbpp  = 2;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_G16_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_rgb8_ni   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB8_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgb8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgb8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgb8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgb8;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 3;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples * 3;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 3;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB8_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_rgb8_i    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB8_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgb8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgb8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgb8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgb8;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 3;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples * 3;
+  pData->iRowmax     = (pData->iDatawidth * 3) + pData->iPixelofs;
+  pData->iFilterbpp  = 3;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB8_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_rgb16_ni  (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB16_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgb16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgb16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgb16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgb16;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 6;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples * 6;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 6;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB16_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_rgb16_i   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB16_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgb16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgb16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgb16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgb16;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 6;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples * 6;
+  pData->iRowmax     = (pData->iDatawidth * 6) + pData->iPixelofs;
+  pData->iFilterbpp  = 6;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGB16_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_idx1_ni   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX1_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx1;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx1;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx1;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx1;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 7;
+  pData->iSamplediv  = 3;
+  pData->iRowsize    = (pData->iRowsamples + 7) >> 3;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX1_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_idx1_i    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX1_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx1;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx1;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx1;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx1;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 7;
+  pData->iSamplediv  = 3;
+  pData->iRowsize    = (pData->iRowsamples + 7) >> 3;
+  pData->iRowmax     = ((pData->iDatawidth + 7) >> 3) + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX1_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_idx2_ni   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX2_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx2;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx2;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx2;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx2;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 3;
+  pData->iSamplediv  = 2;
+  pData->iRowsize    = (pData->iRowsamples + 3) >> 2;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX2_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_idx2_i    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX2_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx2;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx2;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx2;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx2;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 3;
+  pData->iSamplediv  = 2;
+  pData->iRowsize    = (pData->iRowsamples + 3) >> 2;
+  pData->iRowmax     = ((pData->iDatawidth + 3) >> 2) + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX2_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_idx4_ni   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX4_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx4;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx4;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx4;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx4;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 1;
+  pData->iSamplediv  = 1;
+  pData->iRowsize    = (pData->iRowsamples + 1) >> 1;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX4_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_idx4_i    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX4_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx4;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx4;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx4;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx4;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 1;
+  pData->iSamplediv  = 1;
+  pData->iRowsize    = (pData->iRowsamples + 1) >> 1;
+  pData->iRowmax     = ((pData->iDatawidth + 1) >> 1) + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX4_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_idx8_ni   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX8_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx8;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX8_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_idx8_i    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX8_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_idx8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_idx8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_idx8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_idx8;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples;
+  pData->iRowmax     = pData->iDatawidth + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_IDX8_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_ga8_ni    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA8_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_ga8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_ga8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_ga8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_ga8;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 2;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 1;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 2;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA8_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_ga8_i     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA8_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_ga8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_ga8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_ga8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_ga8;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 2;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 1;
+  pData->iRowmax     = (pData->iDatawidth << 1) + pData->iPixelofs;
+  pData->iFilterbpp  = 2;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA8_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_ga16_ni   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA16_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_ga16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_ga16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_ga16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_ga16;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 4;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 2;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 4;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA16_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_ga16_i    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA16_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_ga16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_ga16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_ga16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_ga16;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 4;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 2;
+  pData->iRowmax     = (pData->iDatawidth << 2) + pData->iPixelofs;
+  pData->iFilterbpp  = 4;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_GA16_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_rgba8_ni  (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA8_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgba8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgba8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgba8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgba8;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 4;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 2;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 4;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA8_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+/* ************************************************************************** */
+
+mng_retcode mng_init_rgba8_i   (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA8_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgba8;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgba8;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgba8;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgba8;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; is 1..7 in specifications */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 4;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 2;
+  pData->iRowmax     = (pData->iDatawidth << 2) + pData->iPixelofs;
+  pData->iFilterbpp  = 4;
+  pData->bIsRGBA16   = MNG_FALSE;      /* intermediate row is 8-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA8_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_rgba16_ni (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA16_NI, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgba16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgba16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgba16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgba16;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 8;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 3;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 8;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA16_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_rgba16_i  (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA16_I, MNG_LC_START);
+#endif
+
+  if (pData->fDisplayrow)
+    pData->fProcessrow = (mng_fptr)mng_process_rgba16;
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {                                    /* immediate delta ? */
+#ifndef MNG_NO_DELTA_PNG
+    if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+      pData->fStorerow = (mng_fptr)mng_delta_rgba16;
+    else
+#endif
+      pData->fStorerow = (mng_fptr)mng_store_rgba16;
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_rgba16;
+#endif
+
+  pData->iPass       = 0;              /* from 0..6; (1..7 in specification) */
+  pData->iRow        = interlace_row     [0];
+  pData->iRowinc     = interlace_rowskip [0];
+  pData->iCol        = interlace_col     [0];
+  pData->iColinc     = interlace_colskip [0];
+  pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >> interlace_divider [0];
+  pData->iSamplemul  = 8;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 3;
+  pData->iRowmax     = (pData->iDatawidth << 3) + pData->iPixelofs;
+  pData->iFilterbpp  = 8;
+  pData->bIsRGBA16   = MNG_TRUE;       /* intermediate row is 16-bit deep */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_RGBA16_I, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row processing initialization routines (JPEG) - set up the variables   * */
+/* * needed to process uncompressed row-data                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_jpeg_a1_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A1_NI, MNG_LC_START);
+#endif
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {
+    if (pData->iJHDRimgbitdepth == 8)
+    {
+      switch (pData->iJHDRcolortype)
+      {
+        case 12 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a1;   break; }
+        case 14 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a1; break; }
+      }
+    }
+
+    /* TODO: bitdepth 12 & 20 */
+
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g1;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 7;
+  pData->iSamplediv  = 3;
+  pData->iRowsize    = (pData->iRowsamples + 7) >> 3;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A1_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_jpeg_a2_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A2_NI, MNG_LC_START);
+#endif
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {
+    if (pData->iJHDRimgbitdepth == 8)
+    {
+      switch (pData->iJHDRcolortype)
+      {
+        case 12 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a2;   break; }
+        case 14 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a2; break; }
+      }
+    }
+
+    /* TODO: bitdepth 12 & 20 */
+
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g2;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 3;
+  pData->iSamplediv  = 2;
+  pData->iRowsize    = (pData->iRowsamples + 3) >> 2;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A2_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_jpeg_a4_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A4_NI, MNG_LC_START);
+#endif
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {
+    if (pData->iJHDRimgbitdepth == 8)
+    {
+      switch (pData->iJHDRcolortype)
+      {
+        case 12 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a4;   break; }
+        case 14 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a4; break; }
+      }
+    }
+
+    /* TODO: bitdepth 12 & 20 */
+
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g4;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 1;
+  pData->iSamplediv  = 1;
+  pData->iRowsize    = (pData->iRowsamples + 1) >> 1;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A4_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_init_jpeg_a8_ni     (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A8_NI, MNG_LC_START);
+#endif
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {
+    if (pData->iJHDRimgbitdepth == 8)
+    {
+      switch (pData->iJHDRcolortype)
+      {
+        case 12 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a8;   break; }
+        case 14 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a8; break; }
+      }
+    }
+
+    /* TODO: bitdepth 12 & 20 */
+
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g8;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 1;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 1;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A8_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_jpeg_a16_ni    (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A16_NI, MNG_LC_START);
+#endif
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {
+    if (pData->iJHDRimgbitdepth == 8)
+    {
+      switch (pData->iJHDRcolortype)
+      {
+        case 12 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a16;   break; }
+        case 14 : { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a16; break; }
+      }
+    }
+
+    /* TODO: bitdepth 12 & 20 */
+
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+    pData->fDifferrow  = (mng_fptr)mng_differ_g16;
+#endif
+
+  pData->iPass       = -1;
+  pData->iRow        = 0;
+  pData->iRowinc     = 1;
+  pData->iCol        = 0;
+  pData->iColinc     = 1;
+  pData->iRowsamples = pData->iDatawidth;
+  pData->iSamplemul  = 2;
+  pData->iSampleofs  = 0;
+  pData->iSamplediv  = 0;
+  pData->iRowsize    = pData->iRowsamples << 1;
+  pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+  pData->iFilterbpp  = 2;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_JPEG_A16_NI, MNG_LC_END);
+#endif
+
+  return mng_init_rowproc (pData);
+}
+#endif
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_JNG */
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Generic row processing initialization & cleanup routines               * */
+/* * - initialize the buffers used by the row processing routines           * */
+/* * - cleanup the buffers used by the row processing routines              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_init_rowproc (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ROWPROC, MNG_LC_START);
+#endif
+
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+  if (pData->ePng_imgtype != png_none)
+  {
+  if (pData->fDisplayrow)
+    switch (pData->ePng_imgtype)
+    {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_g1:
+      pData->fProcessrow = (mng_fptr)mng_process_g1;
+      break;
+    case png_g2:
+      pData->fProcessrow = (mng_fptr)mng_process_g2;
+      break;
+    case png_g4:
+      pData->fProcessrow = (mng_fptr)mng_process_g4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_g8:
+      pData->fProcessrow = (mng_fptr)mng_process_g8;
+      break;
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_idx1:
+      pData->fProcessrow = (mng_fptr)mng_process_idx1;
+      break;
+    case png_idx2:
+      pData->fProcessrow = (mng_fptr)mng_process_idx2;
+      break;
+    case png_idx4:
+      pData->fProcessrow = (mng_fptr)mng_process_idx4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_idx8:
+      pData->fProcessrow = (mng_fptr)mng_process_idx8;
+      break;
+    case png_ga8:
+      pData->fProcessrow = (mng_fptr)mng_process_ga8;
+      break;
+    case png_rgb8:
+      pData->fProcessrow = (mng_fptr)mng_process_rgb8;
+      break;
+    case png_rgba8:
+      pData->fProcessrow = (mng_fptr)mng_process_rgba8;
+      break;
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_g16:
+      pData->fProcessrow = (mng_fptr)mng_process_g16;
+      break;
+    case png_ga16:
+      pData->fProcessrow = (mng_fptr)mng_process_ga16;
+      break;
+    case png_rgb16:
+      pData->fProcessrow = (mng_fptr)mng_process_rgb16;
+      break;
+    case png_rgba16:
+      pData->fProcessrow = (mng_fptr)mng_process_rgba16;
+      break;
+#endif
+    default:
+      break;
+    }
+
+  if (pData->pStoreobj)                /* store in object too ? */
+  {
+#ifndef MNG_NO_DELTA_PNG
+  if ((pData->bHasDHDR) && (pData->bDeltaimmediate))
+    switch (pData->ePng_imgtype)
+    {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_g1:
+      pData->fStorerow = (mng_fptr)mng_delta_g1;
+      break;
+    case png_g2:
+      pData->fStorerow = (mng_fptr)mng_delta_g2;
+      break;
+    case png_g4:
+      pData->fStorerow = (mng_fptr)mng_delta_g4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_g8:
+      pData->fStorerow = (mng_fptr)mng_delta_g8;
+      break;
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_idx1:
+      pData->fStorerow = (mng_fptr)mng_delta_idx1;
+      break;
+    case png_idx2:
+      pData->fStorerow = (mng_fptr)mng_delta_idx2;
+      break;
+    case png_idx4:
+      pData->fStorerow = (mng_fptr)mng_delta_idx4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_idx8:
+      pData->fStorerow = (mng_fptr)mng_delta_idx8;
+      break;
+    case png_ga8:
+      pData->fStorerow = (mng_fptr)mng_delta_ga8;
+      break;
+    case png_rgb8:
+      pData->fStorerow = (mng_fptr)mng_delta_rgb8;
+      break;
+    case png_rgba8:
+      pData->fStorerow = (mng_fptr)mng_delta_rgba8;
+      break;
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_g16:
+      pData->fStorerow = (mng_fptr)mng_delta_g16;
+      break;
+    case png_ga16:
+      pData->fStorerow = (mng_fptr)mng_delta_ga16;
+      break;
+    case png_rgb16:
+      pData->fStorerow = (mng_fptr)mng_delta_rgb16;
+      break;
+    case png_rgba16:
+      pData->fStorerow = (mng_fptr)mng_delta_rgba16;
+      break;
+#endif
+    default:
+      break;
+    }
+  else
+#endif  /* MNG_NO_DELTA_PNG */
+    switch (pData->ePng_imgtype)
+    {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_g1:
+      pData->fStorerow = (mng_fptr)mng_store_g1;
+      break;
+    case png_g2:
+      pData->fStorerow = (mng_fptr)mng_store_g2;
+      break;
+    case png_g4:
+      pData->fStorerow = (mng_fptr)mng_store_g4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_g8:
+      pData->fStorerow = (mng_fptr)mng_store_g8;
+      break;
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_idx1:
+      pData->fStorerow = (mng_fptr)mng_store_idx1;
+      break;
+    case png_idx2:
+      pData->fStorerow = (mng_fptr)mng_store_idx2;
+      break;
+    case png_idx4:
+      pData->fStorerow = (mng_fptr)mng_store_idx4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_idx8:
+      pData->fStorerow = (mng_fptr)mng_store_idx8;
+      break;
+    case png_ga8:
+      pData->fStorerow = (mng_fptr)mng_store_ga8;
+      break;
+    case png_rgb8:
+      pData->fStorerow = (mng_fptr)mng_store_rgb8;
+      break;
+    case png_rgba8:
+      pData->fStorerow = (mng_fptr)mng_store_rgba8;
+      break;
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_g16:
+      pData->fStorerow = (mng_fptr)mng_store_g16;
+      break;
+    case png_ga16:
+      pData->fStorerow = (mng_fptr)mng_store_ga16;
+      break;
+    case png_rgb16:
+      pData->fStorerow = (mng_fptr)mng_store_rgb16;
+      break;
+    case png_rgba16:
+      pData->fStorerow = (mng_fptr)mng_store_rgba16;
+      break;
+#endif
+
+#ifdef MNG_INCLUDE_JNG
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_jpeg_a1:
+/*  if (pData->iJHDRimgbitdepth == 8) */
+      {
+        switch (pData->iJHDRcolortype)
+        {
+        case 12 :
+          { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a1;   break; }
+        case 14 :
+          { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a1; break; }
+        }
+      }
+      /* TODO: bitdepth 12 & 20 */
+      break;
+    case png_jpeg_a2:
+/*  if (pData->iJHDRimgbitdepth == 8) */
+      {
+        switch (pData->iJHDRcolortype)
+        {
+          case 12 :
+            { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a2;   break; }
+          case 14 :
+            { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a2; break; }
+        }
+      }
+      break;
+      /* TODO: bitdepth 12 & 20 */
+    case png_jpeg_a4:
+/*  if (pData->iJHDRimgbitdepth == 8) */
+      {
+        switch (pData->iJHDRcolortype)
+        {
+          case 12 :
+           { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a4;   break; }
+          case 14 :
+           { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a4; break; }
+        }
+      }
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+      /* TODO: bitdepth 12 & 20 */
+    case png_jpeg_a8:
+/*  if (pData->iJHDRimgbitdepth == 8) */
+      {
+        switch (pData->iJHDRcolortype)
+        {
+          case 12 :
+            { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a8;   break; }
+          case 14 :
+            { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a8; break; }
+        }
+      }
+      break;
+      /* TODO: bitdepth 12 & 20 */
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_jpeg_a16:
+/*  if (pData->iJHDRimgbitdepth == 8) */
+      {
+        switch (pData->iJHDRcolortype)
+        {
+          case 12 :
+            { pData->fStorerow = (mng_fptr)mng_store_jpeg_g8_a16;   break; }
+          case 14 :
+            { pData->fStorerow = (mng_fptr)mng_store_jpeg_rgb8_a16; break; }
+        }
+      }
+      break;
+      /* TODO: bitdepth 12 & 20 */
+#endif
+#endif /* MNG_INCLUDE_JNG */
+    default:
+      break;
+    }
+  }
+
+#ifdef FILTER192                       /* leveling & differing ? */
+  if (pData->iFilter == MNG_FILTER_DIFFERING)
+  switch (pData->ePng_imgtype)
+  {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_g1:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a1:
+#endif
+      pData->fDifferrow  = (mng_fptr)mng_differ_g1;
+      break;
+    case png_g2:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a2:
+#endif
+      pData->fDifferrow  = (mng_fptr)mng_differ_g2;
+      break;
+    case png_g4:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a4:
+#endif
+      pData->fDifferrow  = (mng_fptr)mng_differ_g4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_g8:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a8:
+#endif
+      pData->fDifferrow  = (mng_fptr)mng_differ_g8;
+      break;
+    case png_rgb8:
+      pData->fDifferrow  = (mng_fptr)mng_differ_rgb8;
+      break;
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_idx1:
+      pData->fDifferrow  = (mng_fptr)mng_differ_idx1;
+      break;
+    case png_idx2:
+      pData->fDifferrow  = (mng_fptr)mng_differ_idx2;
+      break;
+    case png_idx4:
+      pData->fDifferrow  = (mng_fptr)mng_differ_idx4;
+      break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_idx8:
+      pData->fDifferrow  = (mng_fptr)mng_differ_idx8;
+      break;
+    case png_ga8:
+      pData->fDifferrow  = (mng_fptr)mng_differ_ga8;
+      break;
+    case png_rgb8:
+      pData->fDifferrow  = (mng_fptr)mng_differ_rgb8;
+      break;
+    case png_rgba8:
+      pData->fDifferrow  = (mng_fptr)mng_differ_rgba8;
+      break;
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_g16:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a16:
+#endif
+      pData->fDifferrow  = (mng_fptr)mng_differ_g16;
+      break;
+    case png_ga16:
+      pData->fDifferrow  = (mng_fptr)mng_differ_ga16;
+      break;
+    case png_rgb16:
+      pData->fDifferrow  = (mng_fptr)mng_differ_rgb16;
+      break;
+    case png_rgba16:
+      pData->fDifferrow  = (mng_fptr)mng_differ_rgba16;
+      break;
+#endif
+    default:
+      break;
+  }
+#endif
+
+  switch (pData->ePng_imgtype)
+  {
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+    case png_g1:
+    case png_idx1:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a1:
+#endif
+        pData->iSamplemul  = 1;
+        pData->iSampleofs  = 7;
+        pData->iSamplediv  = 3;
+        pData->iFilterbpp  = 1;
+        break;
+    case png_g2:
+    case png_idx2:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a2:
+#endif
+        pData->iSamplemul  = 1;
+        pData->iSampleofs  = 3;
+        pData->iSamplediv  = 2;
+        pData->iFilterbpp  = 1;
+        break;
+    case png_g4:
+    case png_idx4:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a4:
+#endif
+        pData->iSamplemul  = 1;
+        pData->iSampleofs  = 1;
+        pData->iSamplediv  = 1;
+        pData->iFilterbpp  = 1;
+        break;
+#endif /* MNG_NO_1_2_4BIT_SUPPORT */
+    case png_g8:
+    case png_idx8:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a8:
+#endif
+        pData->iSamplemul  = 1;
+        pData->iSampleofs  = 0;
+        pData->iSamplediv  = 0;
+        pData->iFilterbpp  = 1;
+        break;
+    case png_ga8:
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_g16:
+#ifdef MNG_INCLUDE_JNG
+    case png_jpeg_a16:
+#endif
+#endif
+        pData->iSamplemul  = 2;
+        pData->iSampleofs  = 0;
+        pData->iSamplediv  = 0;
+        pData->iFilterbpp  = 2;
+        break;
+    case png_rgb8:
+        pData->iSamplemul  = 3;
+        pData->iSampleofs  = 0;
+        pData->iSamplediv  = 0;
+        pData->iFilterbpp  = 3;
+        break;
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_ga16:
+#endif
+    case png_rgba8:
+        pData->iSamplemul  = 4;
+        pData->iSampleofs  = 0;
+        pData->iSamplediv  = 0;
+        pData->iFilterbpp  = 4;
+        break;
+#ifndef MNG_NO_16BIT_SUPPORT
+    case png_rgb16:
+        pData->iSamplemul  = 6;
+        pData->iSampleofs  = 0;
+        pData->iSamplediv  = 0;
+        pData->iFilterbpp  = 6;
+        break;
+    case png_rgba16:
+        pData->iSamplemul  = 8;
+        pData->iSampleofs  = 0;
+        pData->iSamplediv  = 0;
+        pData->iFilterbpp  = 8;
+        break;
+#endif
+    default:
+        break;
+  }
+
+  if (pData->iInterlace)               /* noninterlaced */
+  {
+    pData->iPass       = 0;      /* from 0..6; (1..7 in specification) */
+    pData->iRow        = interlace_row     [0];
+    pData->iRowinc     = interlace_rowskip [0];
+    pData->iCol        = interlace_col     [0];
+    pData->iColinc     = interlace_colskip [0];
+    pData->iRowsamples = (pData->iDatawidth + interlace_roundoff [0]) >>
+       interlace_divider [0];
+    pData->iRowmax     = ((pData->iDatawidth * pData->iSamplemul +
+       pData->iSampleofs) >> pData->iSamplediv) + pData->iPixelofs;
+  }
+  else                                 /* interlaced */
+  {
+    pData->iPass       = -1;
+    pData->iRow        = 0;
+    pData->iRowinc     = 1;
+    pData->iCol        = 0;
+    pData->iColinc     = 1;
+    pData->iRowsamples = pData->iDatawidth;
+  }
+  if (pData->iSamplediv > 0)
+     pData->iRowsize    = (pData->iRowsamples + pData->iSampleofs) >>
+         pData->iSamplediv;
+  else
+     pData->iRowsize    = (pData->iRowsamples * pData->iSamplemul);
+
+  if (!pData->iInterlace)               /* noninterlaced */
+     pData->iRowmax     = pData->iRowsize + pData->iPixelofs;
+
+#ifdef MNG_NO_16BIT_SUPPORT
+  pData->bIsRGBA16 = MNG_FALSE;
+#else
+  switch (pData->ePng_imgtype)
+  {
+    case png_g16:
+    case png_ga16:
+    case png_rgb16:
+    case png_rgba16:
+       pData->bIsRGBA16 = MNG_TRUE;
+       break;
+    default:
+       pData->bIsRGBA16 = MNG_FALSE;
+       break;
+  }
+#endif
+
+  }
+#endif /* MNG_OPTIMIZE_FOOTPRINT_INIT */
+
+  if (pData->pStoreobj)                /* storage object selected ? */
+  {
+    pData->pStorebuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+                                       /* and so it becomes viewable ! */
+    ((mng_imagep)pData->pStoreobj)->bViewable     = MNG_TRUE;
+    ((mng_imagedatap)pData->pStorebuf)->bViewable = MNG_TRUE;
+  }
+
+  /* allocate the buffers; the individual init routines have already
+     calculated the required maximum size; except in the case of a JNG
+     without alpha!!! */
+  if (pData->iRowmax)
+  {
+#if defined(MNG_NO_16BIT_SUPPORT) || defined (MNG_NO_1_2_4BIT_SUPPORT)
+    mng_uint8 iRowadd = 0;
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+    if (pData->iPNGdepth < 8)
+       iRowadd=(pData->iPNGdepth*pData->iRowmax+7)/8;
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+    if (pData->iPNGdepth > 8)
+       iRowadd=pData->iRowmax;
+#endif
+    MNG_ALLOC (pData, pData->pWorkrow, pData->iRowmax+iRowadd);
+    MNG_ALLOC (pData, pData->pPrevrow, pData->iRowmax+iRowadd);
+#else
+    MNG_ALLOC (pData, pData->pWorkrow, pData->iRowmax);
+    MNG_ALLOC (pData, pData->pPrevrow, pData->iRowmax);
+#endif
+  }
+
+  /* allocate an RGBA16 row for intermediate processing */
+  MNG_ALLOC (pData, pData->pRGBArow, (pData->iDatawidth << 3));
+
+#ifndef MNG_NO_CMS
+  if (pData->fDisplayrow)              /* display "on-the-fly" ? */
+  {
+#if defined(MNG_FULL_CMS)              /* determine color-management initialization */
+    mng_retcode iRetcode = mng_init_full_cms   (pData, MNG_TRUE, MNG_TRUE, MNG_FALSE);
+#elif defined(MNG_GAMMA_ONLY)
+    mng_retcode iRetcode = mng_init_gamma_only (pData, MNG_TRUE, MNG_TRUE, MNG_FALSE);
+#elif defined(MNG_APP_CMS)
+    mng_retcode iRetcode = mng_init_app_cms    (pData, MNG_TRUE, MNG_TRUE, MNG_FALSE);
+#endif
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* !MNG_NO_CMS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_INIT_ROWPROC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_next_row (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_ROW, MNG_LC_START);
+#endif
+
+  pData->iRow += pData->iRowinc;       /* increase the row counter */
+
+  if (pData->iPass >= 0)               /* interlaced ? */
+  {
+    while ((pData->iPass < 7) &&       /* went 'outside' the image ? */
+           ((pData->iRow >= (mng_int32)pData->iDataheight) ||
+            (pData->iCol >= (mng_int32)pData->iDatawidth )    ))
+    {
+      pData->iPass++;                  /* next pass ! */
+
+      if (pData->iPass < 7)            /* there's only 7 passes ! */
+      {
+        pData->iRow        = interlace_row     [pData->iPass];
+        pData->iRowinc     = interlace_rowskip [pData->iPass];
+        pData->iCol        = interlace_col     [pData->iPass];
+        pData->iColinc     = interlace_colskip [pData->iPass];
+        pData->iRowsamples = (pData->iDatawidth - pData->iCol + interlace_roundoff [pData->iPass])
+                                 >> interlace_divider [pData->iPass];
+
+        if (pData->iSamplemul > 1)     /* recalculate row dimension */
+          pData->iRowsize  = pData->iRowsamples * pData->iSamplemul;
+        else
+        if (pData->iSamplediv > 0)
+          pData->iRowsize  = (pData->iRowsamples + pData->iSampleofs) >> pData->iSamplediv;
+        else
+          pData->iRowsize  = pData->iRowsamples;
+
+      }
+
+      if ((pData->iPass < 7) &&        /* reset previous row to zeroes ? */
+          (pData->iRow  < (mng_int32)pData->iDataheight) &&
+          (pData->iCol  < (mng_int32)pData->iDatawidth )    )
+      {                                /* making sure the filters will work properly! */
+        mng_int32  iX;
+        mng_uint8p pTemp = pData->pPrevrow;
+
+#ifdef MNG_NO_16BIT_SUPPORT
+#ifdef MNG_DECREMENT_LOOPS
+        for (iX = pData->iPNGmult*pData->iRowsize; iX > 0; iX--)
+#else
+        for (iX = 0; iX < pData->iPNGmult*pData->iRowsize; iX++)
+#endif
+#else
+#ifdef MNG_DECREMENT_LOOPS
+        for (iX = pData->iRowsize; iX > 0; iX--)
+#else
+        for (iX = 0; iX < pData->iRowsize; iX++)
+#endif
+#endif
+        {
+          *pTemp = 0;
+          pTemp++;
+        }
+      }
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_ROW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_cleanup_rowproc (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLEANUP_ROWPROC, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_LCMS                /* cleanup cms profile/transform */
+  {
+    mng_retcode iRetcode = mng_clear_cms (pData);
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif /* MNG_INCLUDE_LCMS */
+
+  if (pData->pRGBArow)                 /* cleanup buffer for intermediate row */
+    MNG_FREEX (pData, pData->pRGBArow, (pData->iDatawidth << 3));
+  if (pData->pPrevrow)                 /* cleanup buffer for previous row */
+    MNG_FREEX (pData, pData->pPrevrow, pData->iRowmax);
+  if (pData->pWorkrow)                 /* cleanup buffer for working row */
+    MNG_FREEX (pData, pData->pWorkrow, pData->iRowmax);
+
+  pData->pWorkrow = MNG_NULL;          /* propogate uninitialized buffers */
+  pData->pPrevrow = MNG_NULL;
+  pData->pRGBArow = MNG_NULL;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_CLEANUP_ROWPROC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* woohiii */
+}
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Generic row processing routines for JNG                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+/* ************************************************************************** */
+
+mng_retcode mng_display_jpeg_rows (mng_datap pData)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_JPEG_ROWS, MNG_LC_START);
+#endif
+                                       /* any completed rows ? */
+  if ((pData->iJPEGrow      > pData->iJPEGdisprow) &&
+      (pData->iJPEGalpharow > pData->iJPEGdisprow)    )
+  {
+    mng_uint32 iX, iMax;
+    mng_uint32 iSaverow = pData->iRow; /* save alpha decompression row-count */
+                                       /* determine the highest complete(!) row */
+    if (pData->iJPEGrow > pData->iJPEGalpharow)
+      iMax = pData->iJPEGalpharow;
+    else
+      iMax = pData->iJPEGrow;
+                                       /* display the rows */
+    for (iX = pData->iJPEGdisprow; iX < iMax; iX++)
+    {
+      pData->iRow = iX;                /* make sure we all know which row to handle */
+                                       /* makeup an intermediate row from the buffer */
+      iRetcode = ((mng_retrieverow)pData->fRetrieverow) (pData);
+                                       /* color-correct it if necessary */
+      if ((!iRetcode) && (pData->fCorrectrow))
+        iRetcode = ((mng_correctrow)pData->fCorrectrow) (pData);
+
+      if (!iRetcode)                   /* and display it */
+      {
+        iRetcode = ((mng_displayrow)pData->fDisplayrow) (pData);
+
+        if (!iRetcode)                 /* check progressive display refresh */
+          iRetcode = mng_display_progressive_check (pData);
+      }
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+
+    pData->iJPEGdisprow = iMax;        /* keep track of the last displayed row */
+    pData->iRow         = iSaverow;    /* restore alpha decompression row-count */
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DISPLAY_JPEG_ROWS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_next_jpeg_alpharow (mng_datap pData)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_JPEG_ALPHAROW, MNG_LC_START);
+#endif
+
+  pData->iJPEGalpharow++;              /* count the row */
+
+  if (pData->fDisplayrow)              /* display "on-the-fly" ? */
+  {                                    /* try to display what you can */
+    iRetcode = mng_display_jpeg_rows (pData);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_JPEG_ALPHAROW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_next_jpeg_row (mng_datap pData)
+{
+  mng_retcode iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_JPEG_ROW, MNG_LC_START);
+#endif
+
+  pData->iJPEGrow++;                   /* increase the row-counter */
+
+  if (pData->fDisplayrow)              /* display "on-the-fly" ? */
+  {                                    /* has alpha channel ? */
+    if ((pData->iJHDRcolortype == MNG_COLORTYPE_JPEGGRAYA ) ||
+        (pData->iJHDRcolortype == MNG_COLORTYPE_JPEGCOLORA)    )
+    {                                  /* try to display what you can */
+      iRetcode = mng_display_jpeg_rows (pData);
+    }
+    else
+    {                                  /* make sure we all know which row to handle */
+      pData->iRow = pData->iJPEGrow - 1;
+                                       /* makeup an intermediate row from the buffer */
+      iRetcode = ((mng_retrieverow)pData->fRetrieverow) (pData);
+                                       /* color-correct it if necessary */
+      if ((!iRetcode) && (pData->fCorrectrow))
+        iRetcode = ((mng_correctrow)pData->fCorrectrow) (pData);
+
+      if (!iRetcode)                   /* and display it */
+      {
+        iRetcode = ((mng_displayrow)pData->fDisplayrow) (pData);
+
+        if (!iRetcode)                 /* check progressive display refresh */
+          iRetcode = mng_display_progressive_check (pData);
+      }
+    }
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+
+                                       /* surpassed last filled row ? */
+  if (pData->iJPEGrow > pData->iJPEGrgbrow)
+    pData->iJPEGrgbrow = pData->iJPEGrow;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_NEXT_JPEG_ROW, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_MAGN
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_g8_x1 (mng_datap  pData,
+                               mng_uint16 iMX,
+                               mng_uint16 iML,
+                               mng_uint16 iMR,
+                               mng_uint32 iWidth,
+                               mng_uint8p pSrcline,
+                               mng_uint8p pDstline)
+{
+  mng_uint32 iX, iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+    }
+
+    pTempsrc1++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_g8_x2 (mng_datap  pData,
+                               mng_uint16 iMX,
+                               mng_uint16 iML,
+                               mng_uint16 iMR,
+                               mng_uint32 iWidth,
+                               mng_uint8p pSrcline,
+                               mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 1;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {                                /* is it same as first ? */
+        if (*pTempsrc1 == *pTempsrc2)
+        {
+          for (iS = 1; iS < iM; iS++)  /* then just repeat the first */
+          {
+            *pTempdst = *pTempsrc1;
+            pTempdst++;
+          }
+        }
+        else
+        {
+          for (iS = 1; iS < iM; iS++)  /* calculate the distances */
+          {
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+            pTempdst++;
+          }
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_g8_x3 (mng_datap  pData,
+                               mng_uint16 iMX,
+                               mng_uint16 iML,
+                               mng_uint16 iMR,
+                               mng_uint32 iWidth,
+                               mng_uint8p pSrcline,
+                               mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 1;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {                                /* is it same as first ? */
+        if (*pTempsrc1 == *pTempsrc2)
+        {
+          for (iS = 1; iS < iM; iS++)  /* then just repeat the first */
+          {
+            *pTempdst = *pTempsrc1;
+            pTempdst++;
+          }
+        }
+        else
+        {
+          iH = (iM+1) / 2;             /* calculate halfway point */
+
+          for (iS = 1; iS < iH; iS++)  /* replicate first half */
+          {
+            *pTempdst = *pTempsrc1;
+            pTempdst++;
+          }
+
+          for (iS = iH; iS < iM; iS++) /* replicate second half */
+          {
+            *pTempdst = *pTempsrc2;
+            pTempdst++;
+          }
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb8_x1 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32 iX, iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+1);
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+2);
+      pTempdst++;
+    }
+
+    pTempsrc1 += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb8_x2 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 3;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+1)) -
+                                                 (mng_int32)(*(pTempsrc1+1)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+1))         );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+2)) -
+                                                 (mng_int32)(*(pTempsrc1+2)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+2))         );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb8_x3 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 3;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* replicate first half */
+        {
+          *pTempdst     = *pTempsrc1;
+          *(pTempdst+1) = *(pTempsrc1+1);
+          *(pTempdst+2) = *(pTempsrc1+2);
+
+          pTempdst += 3;
+        }
+
+        for (iS = iH; iS < iM; iS++)    /* replicate second half */
+        {
+          *pTempdst     = *pTempsrc2;
+          *(pTempdst+1) = *(pTempsrc2+1);
+          *(pTempdst+2) = *(pTempsrc2+2);
+
+          pTempdst += 3;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_ga8_x1 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX, iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+1);
+      pTempdst++;
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_x2 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+1)) -
+                                                 (mng_int32)(*(pTempsrc1+1)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+1))         );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_x3 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* replicate first half */
+        {
+          *pTempdst     = *pTempsrc1;
+          *(pTempdst+1) = *(pTempsrc1+1);
+
+          pTempdst += 2;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* replicate second half */
+        {
+          *pTempdst     = *pTempsrc2;
+          *(pTempdst+1) = *(pTempsrc2+1);
+
+          pTempdst += 2;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_x4 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+
+          pTempdst++;
+
+          *pTempdst = *(pTempsrc1+1);  /* replicate alpha from left */
+
+          pTempdst++;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+
+          pTempdst++;
+
+          *pTempdst = *(pTempsrc2+1);  /* replicate alpha from right */
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_x5 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          *pTempdst = *pTempsrc1;      /* replicate gray from left */
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);/* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+1))     -
+                                                 (mng_int32)(*(pTempsrc1+1))     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+1))             );
+
+          pTempdst++;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          *pTempdst = *pTempsrc2;      /* replicate gray from right */
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);/* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+1))     -
+                                                 (mng_int32)(*(pTempsrc1+1))     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+1))             );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_X5, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+#endif /* MNG_OPTIMIZE_FOOTPRINT_MAGN */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_x1 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX, iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+1);
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+2);
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+3);
+      pTempdst++;
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_x2 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+1)) -
+                                                 (mng_int32)(*(pTempsrc1+1)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+1))         );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+2)) -
+                                                 (mng_int32)(*(pTempsrc1+2)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+2))         );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+3) == *(pTempsrc2+3))
+            *pTempdst = *(pTempsrc1+3);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+3)) -
+                                                 (mng_int32)(*(pTempsrc1+3)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+3))         );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_x3 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* replicate first half */
+        {
+          *pTempdst     = *pTempsrc1;
+          *(pTempdst+1) = *(pTempsrc1+1);
+          *(pTempdst+2) = *(pTempsrc1+2);
+          *(pTempdst+3) = *(pTempsrc1+3);
+
+          pTempdst += 4;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* replicate second half */
+        {
+          *pTempdst     = *pTempsrc2;
+          *(pTempdst+1) = *(pTempsrc2+1);
+          *(pTempdst+2) = *(pTempsrc2+2);
+          *(pTempdst+3) = *(pTempsrc2+3);
+
+          pTempdst += 4;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_x4 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+1)) -
+                                                 (mng_int32)(*(pTempsrc1+1)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+1))         );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+2)) -
+                                                 (mng_int32)(*(pTempsrc1+2)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+2))         );
+
+          pTempdst++;
+                                       /* replicate alpha from left */
+          *pTempdst     = *(pTempsrc1+3);
+
+          pTempdst++;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*pTempsrc2)     -
+                                                 (mng_int32)(*pTempsrc1)     ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*pTempsrc1)             );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+1)) -
+                                                 (mng_int32)(*(pTempsrc1+1)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+1))         );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            *pTempdst = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+2)) -
+                                                 (mng_int32)(*(pTempsrc1+2)) ) + iM) /
+                                     (iM * 2)) + (mng_int32)(*(pTempsrc1+2))         );
+
+          pTempdst++;
+                                       /* replicate alpha from right */
+          *pTempdst     = *(pTempsrc2+3);
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_x5 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_int32  iS, iM, iH;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline;                /* initialize pixel-loop */
+  pTempdst  = pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          *pTempdst     = *pTempsrc1;  /* replicate color from left */
+          *(pTempdst+1) = *(pTempsrc1+1);
+          *(pTempdst+2) = *(pTempsrc1+2);
+
+          if (*(pTempsrc1+3) == *(pTempsrc2+3))
+            *(pTempdst+3) = *(pTempsrc1+3);
+          else
+            *(pTempdst+3) = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+3)) -
+                                                   (mng_int32)(*(pTempsrc1+3)) ) + iM) /
+                                       (iM * 2)) + (mng_int32)(*(pTempsrc1+3))         );
+
+          pTempdst += 4;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          *pTempdst     = *pTempsrc2;  /* replicate color from right */
+          *(pTempdst+1) = *(pTempsrc2+1);
+          *(pTempdst+2) = *(pTempsrc2+2);
+
+          if (*(pTempsrc1+3) == *(pTempsrc2+3))
+            *(pTempdst+3) = *(pTempsrc1+3);
+          else
+            *(pTempdst+3) = (mng_uint8)(((2 * iS * ( (mng_int32)(*(pTempsrc2+3)) -
+                                                   (mng_int32)(*(pTempsrc1+3)) ) + iM) /
+                                       (iM * 2)) + (mng_int32)(*(pTempsrc1+3))         );
+
+          pTempdst += 4;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_X4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_g8_y1 (mng_datap  pData,
+                               mng_int32  iS,
+                               mng_int32  iM,
+                               mng_uint32 iWidth,
+                               mng_uint8p pSrcline1,
+                               mng_uint8p pSrcline2,
+                               mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, iWidth);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+mng_retcode mng_magnify_g8_y2 (mng_datap  pData,
+                               mng_int32  iS,
+                               mng_int32  iM,
+                               mng_uint32 iWidth,
+                               mng_uint8p pSrcline1,
+                               mng_uint8p pSrcline2,
+                               mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_g8_y3 (mng_datap  pData,
+                               mng_int32  iS,
+                               mng_int32  iM,
+                               mng_uint32 iWidth,
+                               mng_uint8p pSrcline1,
+                               mng_uint8p pSrcline2,
+                               mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, iWidth)
+    else
+      MNG_COPY (pDstline, pSrcline2, iWidth);
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, iWidth);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G8_Y3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb8_y1 (mng_datap  pData,
+                                 mng_int32  iS,
+                                 mng_int32  iM,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline1,
+                                 mng_uint8p pSrcline2,
+                                 mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, iWidth * 3);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb8_y2 (mng_datap  pData,
+                                 mng_int32  iS,
+                                 mng_int32  iM,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline1,
+                                 mng_uint8p pSrcline2,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth * 3);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb8_y3 (mng_datap  pData,
+                                 mng_int32  iS,
+                                 mng_int32  iM,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline1,
+                                 mng_uint8p pSrcline2,
+                                 mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, iWidth * 3)
+    else
+      MNG_COPY (pDstline, pSrcline2, iWidth * 3);
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, iWidth * 3);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB8_Y3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_ga8_y1 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, iWidth << 1);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_y2 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth << 1);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_y3 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, iWidth << 1)
+    else
+      MNG_COPY (pDstline, pSrcline2, iWidth << 1);
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, iWidth << 1);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_y4 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2 += 2;
+
+        *pTempdst++ = *pTempsrc1++;    /* replicate alpha from top */
+      }
+    }
+    else
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1 += 2;
+        pTempsrc2++;
+
+        *pTempdst++ = *pTempsrc2++;    /* replicate alpha from bottom */
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth << 1);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga8_y5 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst = *pTempsrc1;        /* replicate gray from top */
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+    else
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst = *pTempsrc2;        /* replicate gray from bottom */
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth << 1);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA8_Y5, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+#endif /* MNG_OPTIMIZE_FOOTPRINT_MAGN */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_y1 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, iWidth << 2);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_y2 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                               (mng_int32)(*pTempsrc1) ) + iM) /
+                                   (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth << 2);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_y3 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, iWidth << 2)
+    else
+      MNG_COPY (pDstline, pSrcline2, iWidth << 2);
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, iWidth << 2);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_y4 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2 += 2;
+
+        *pTempdst++ = *pTempsrc1++;    /* replicate alpha from top */
+      }
+    }
+    else
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1 += 2;
+        pTempsrc2++;
+
+        *pTempdst++ = *pTempsrc2++;    /* replicate alpha from bottom */
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth << 2);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba8_y5 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32 iX;
+  mng_uint8p pTempsrc1;
+  mng_uint8p pTempsrc2;
+  mng_uint8p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = pSrcline1;               /* initialize pixel-loop */
+  pTempsrc2 = pSrcline2;
+  pTempdst  = pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst++ = *pTempsrc1++;    /* replicate color from top */
+        *pTempdst++ = *pTempsrc1++;
+        *pTempdst++ = *pTempsrc1++;
+
+        pTempsrc2 += 3;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+    else
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst++ = *pTempsrc2++;    /* replicate color from bottom */
+        *pTempdst++ = *pTempsrc2++;
+        *pTempdst++ = *pTempsrc2++;
+
+        pTempsrc1 += 3;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          *pTempdst = (mng_uint8)( ( (2 * iS * ( (mng_int32)(*pTempsrc2) -
+                                                 (mng_int32)(*pTempsrc1) ) + iM) /
+                                     (iM * 2) ) + (mng_int32)(*pTempsrc1) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth << 2);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA8_Y5, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_g16_x1 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32  iX, iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+    }
+
+    pTempsrc1++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_g16_x2 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 1;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {                                /* is it same as first ? */
+        if (*pTempsrc1 == *pTempsrc2)
+        {
+          for (iS = 1; iS < iM; iS++)  /* then just repeat the first */
+          {
+            *pTempdst = *pTempsrc1;
+            pTempdst++;
+          }
+        }
+        else
+        {
+          for (iS = 1; iS < iM; iS++)  /* calculate the distances */
+          {
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2))   -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))          ));
+            pTempdst++;
+          }
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_g16_x3 (mng_datap  pData,
+                                mng_uint16 iMX,
+                                mng_uint16 iML,
+                                mng_uint16 iMR,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline,
+                                mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 1;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {                                /* is it same as first ? */
+        if (*pTempsrc1 == *pTempsrc2)
+        {
+          for (iS = 1; iS < iM; iS++)  /* then just repeat the first */
+          {
+            *pTempdst = *pTempsrc1;
+            pTempdst++;
+          }
+        }
+        else
+        {
+          iH = (iM+1) / 2;             /* calculate halfway point */
+
+          for (iS = 1; iS < iH; iS++)  /* replicate first half */
+          {
+            *pTempdst = *pTempsrc1;
+            pTempdst++;
+          }
+
+          for (iS = iH; iS < iM; iS++) /* replicate second half */
+          {
+            *pTempdst = *pTempsrc2;
+            pTempdst++;
+          }
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1++;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb16_x1 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32  iX, iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+1);
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+2);
+      pTempdst++;
+    }
+
+    pTempsrc1 += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb16_x2 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 3;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+1))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1)))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+2))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2)))         ) );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb16_x3 (mng_datap  pData,
+                                  mng_uint16 iMX,
+                                  mng_uint16 iML,
+                                  mng_uint16 iMR,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 3;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* replicate first half */
+        {
+          *pTempdst     = *pTempsrc1;
+          *(pTempdst+1) = *(pTempsrc1+1);
+          *(pTempdst+2) = *(pTempsrc1+2);
+
+          pTempdst += 3;
+        }
+
+        for (iS = iH; iS < iM; iS++)    /* replicate second half */
+        {
+          *pTempdst     = *pTempsrc2;
+          *(pTempdst+1) = *(pTempsrc2+1);
+          *(pTempdst+2) = *(pTempsrc2+2);
+
+          pTempdst += 3;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 3;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_ga16_x1 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX, iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p) pSrcline;  /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+1);
+      pTempdst++;
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_x2 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+1))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1)))         ) );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_x3 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* replicate first half */
+        {
+          *pTempdst     = *pTempsrc1;
+          *(pTempdst+1) = *(pTempsrc1+1);
+
+          pTempdst += 2;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* replicate second half */
+        {
+          *pTempdst     = *pTempsrc2;
+          *(pTempdst+1) = *(pTempsrc2+1);
+
+          pTempdst += 2;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_x4 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+          pTempdst++;
+
+          *pTempdst = *(pTempsrc1+1);  /* replicate alpha from left */
+
+          pTempdst++;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+          pTempdst++;
+
+          *pTempdst = *(pTempsrc2+1);  /* replicate alpha from right */
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_x5 (mng_datap  pData,
+                                 mng_uint16 iMX,
+                                 mng_uint16 iML,
+                                 mng_uint16 iMR,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 2;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          *pTempdst = *pTempsrc1;      /* replicate gray from left */
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);/* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+1))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1)))         ) );
+
+          pTempdst++;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          *pTempdst = *pTempsrc2;      /* replicate gray from right */
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);/* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+1))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1)))         ) );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_X5, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_x1 (mng_datap  pData,
+                                   mng_uint16 iMX,
+                                   mng_uint16 iML,
+                                   mng_uint16 iMR,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX, iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X1, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+      iM = iML;
+    else
+    if (iX == (iWidth - 1))            /* last interval ? */
+      iM = iMR;
+    else
+      iM = iMX;
+
+    for (iS = 1; iS < iM; iS++)        /* fill interval */
+    {
+      *pTempdst = *pTempsrc1;          /* copy original source pixel */
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+1);
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+2);
+      pTempdst++;
+      *pTempdst = *(pTempsrc1+3);
+      pTempdst++;
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_x2 (mng_datap  pData,
+                                   mng_uint16 iMX,
+                                   mng_uint16 iML,
+                                   mng_uint16 iMR,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+1))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1)))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+2))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2)))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+3) == *(pTempsrc2+3))
+            *pTempdst = *(pTempsrc1+3);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+3))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+3))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+3)))         ) );
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_x3 (mng_datap  pData,
+                                   mng_uint16 iMX,
+                                   mng_uint16 iML,
+                                   mng_uint16 iMR,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X3, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* replicate first half */
+        {
+          *pTempdst     = *pTempsrc1;
+          *(pTempdst+1) = *(pTempsrc1+1);
+          *(pTempdst+2) = *(pTempsrc1+2);
+          *(pTempdst+3) = *(pTempsrc1+3);
+
+          pTempdst += 4;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* replicate second half */
+        {
+          *pTempdst     = *pTempsrc2;
+          *(pTempdst+1) = *(pTempsrc2+1);
+          *(pTempdst+2) = *(pTempsrc2+2);
+          *(pTempdst+3) = *(pTempsrc2+3);
+
+          pTempdst += 4;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_x4 (mng_datap  pData,
+                                   mng_uint16 iMX,
+                                   mng_uint16 iML,
+                                   mng_uint16 iMR,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+1))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1)))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+2))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2)))         ) );
+
+          pTempdst++;
+                                       /* replicate alpha from left */
+          *pTempdst     = *(pTempsrc1+3);
+
+          pTempdst++;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          if (*pTempsrc1 == *pTempsrc2)
+            *pTempdst = *pTempsrc1;    /* just repeat the first */
+          else                         /* calculate the distance */
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+1) == *(pTempsrc2+1))
+            *pTempdst = *(pTempsrc1+1);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+1))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+1)))         ) );
+
+          pTempdst++;
+
+          if (*(pTempsrc1+2) == *(pTempsrc2+2))
+            *pTempdst = *(pTempsrc1+2);
+          else
+            mng_put_uint16 ((mng_uint8p)pTempdst,
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+2))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+2)))         ) );
+
+          pTempdst++;
+                                       /* replicate alpha from right */
+          *pTempdst     = *(pTempsrc2+3);
+
+          pTempdst++;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_x5 (mng_datap  pData,
+                                   mng_uint16 iMX,
+                                   mng_uint16 iML,
+                                   mng_uint16 iMR,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_int32   iS, iM, iH;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline;   /* initialize pixel-loop */
+  pTempdst  = (mng_uint16p)pDstline;
+
+  for (iX = 0; iX < iWidth; iX++)
+  {
+    pTempsrc2 = pTempsrc1 + 4;
+
+    *pTempdst = *pTempsrc1;            /* copy original source pixel */
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+1);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+2);
+    pTempdst++;
+    *pTempdst = *(pTempsrc1+3);
+    pTempdst++;
+
+    if (iX == 0)                       /* first interval ? */
+    {
+      if (iWidth == 1)                 /* single pixel ? */
+        pTempsrc2 = MNG_NULL;
+
+      iM = (mng_int32)iML;
+    }
+    else
+    if (iX == (iWidth - 2))            /* last interval ? */
+      iM = (mng_int32)iMR;
+    else
+      iM = (mng_int32)iMX;
+                                       /* fill interval ? */
+    if ((iX < iWidth - 1) || (iWidth == 1))
+    {
+      if (pTempsrc2)                   /* do we have the second pixel ? */
+      {
+        iH = (iM+1) / 2;               /* calculate halfway point */
+
+        for (iS = 1; iS < iH; iS++)    /* first half */
+        {
+          *pTempdst     = *pTempsrc1;  /* replicate color from left */
+          *(pTempdst+1) = *(pTempsrc1+1);
+          *(pTempdst+2) = *(pTempsrc1+2);
+
+          if (*(pTempsrc1+3) == *(pTempsrc2+3))
+            *(pTempdst+3) = *(pTempsrc1+3);
+          else
+            mng_put_uint16 ((mng_uint8p)(pTempdst+3),
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+3))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+3))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+3)))         ) );
+
+          pTempdst += 4;
+        }
+
+        for (iS = iH; iS < iM; iS++)   /* second half */
+        {
+          *pTempdst     = *pTempsrc2;  /* replicate color from right */
+          *(pTempdst+1) = *(pTempsrc2+1);
+          *(pTempdst+2) = *(pTempsrc2+2);
+
+          if (*(pTempsrc1+3) == *(pTempsrc2+3))
+            *(pTempdst+3) = *(pTempsrc1+3);
+          else
+            mng_put_uint16 ((mng_uint8p)(pTempdst+3),
+                            (mng_uint16)(((2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc2+3))) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+3))) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)(pTempsrc1+3)))         ) );
+
+          pTempdst += 4;
+        }
+      }
+      else
+      {
+        for (iS = 1; iS < iM; iS++)
+        {
+          *pTempdst = *pTempsrc1;      /* repeat first source pixel */
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+1);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+2);
+          pTempdst++;
+          *pTempdst = *(pTempsrc1+3);
+          pTempdst++;
+        }
+      }
+    }
+
+    pTempsrc1 += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_X4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_g16_y1 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, (iWidth << 1));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_g16_y2 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, (iWidth << 1));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_g16_y3 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, (iWidth << 1))
+    else
+      MNG_COPY (pDstline, pSrcline2, (iWidth << 1));
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, (iWidth << 1));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_G16_Y3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb16_y1 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, iWidth * 6);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb16_y2 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, iWidth * 6);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgb16_y3 (mng_datap  pData,
+                                  mng_int32  iS,
+                                  mng_int32  iM,
+                                  mng_uint32 iWidth,
+                                  mng_uint8p pSrcline1,
+                                  mng_uint8p pSrcline2,
+                                  mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, iWidth * 6)
+    else
+      MNG_COPY (pDstline, pSrcline2, iWidth * 6);
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, iWidth * 6);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGB16_Y3, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_GRAY_SUPPORT
+mng_retcode mng_magnify_ga16_y1 (mng_datap  pData,
+                                 mng_int32  iS,
+                                 mng_int32  iM,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline1,
+                                 mng_uint8p pSrcline2,
+                                 mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, (iWidth << 2));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_y2 (mng_datap  pData,
+                                 mng_int32  iS,
+                                 mng_int32  iM,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline1,
+                                 mng_uint8p pSrcline2,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, (iWidth << 2));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_y3 (mng_datap  pData,
+                                mng_int32  iS,
+                                mng_int32  iM,
+                                mng_uint32 iWidth,
+                                mng_uint8p pSrcline1,
+                                mng_uint8p pSrcline2,
+                                mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, (iWidth << 2))
+    else
+      MNG_COPY (pDstline, pSrcline2, (iWidth << 2));
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, (iWidth << 2));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_y4 (mng_datap  pData,
+                                 mng_int32  iS,
+                                 mng_int32  iM,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline1,
+                                 mng_uint8p pSrcline2,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2 += 2;
+
+        *pTempdst++ = *pTempsrc1++;    /* replicate alpha from top */
+      }
+    }
+    else
+    {
+       for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1 += 2;
+        pTempsrc2++;
+
+        *pTempdst++ = *pTempsrc2++;    /* replicate alpha from bottom */
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, (iWidth << 2));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_ga16_y5 (mng_datap  pData,
+                                 mng_int32  iS,
+                                 mng_int32  iM,
+                                 mng_uint32 iWidth,
+                                 mng_uint8p pSrcline1,
+                                 mng_uint8p pSrcline2,
+                                 mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst = *pTempsrc1;        /* replicate gray from top */
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+    else
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst = *pTempsrc2;        /* replicate gray from bottom */
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, (iWidth << 2));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_GA16_Y5, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_GRAY_SUPPORT */
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_y1 (mng_datap  pData,
+                                   mng_int32  iS,
+                                   mng_int32  iM,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline1,
+                                   mng_uint8p pSrcline2,
+                                   mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y1, MNG_LC_START);
+#endif
+
+  MNG_COPY (pDstline, pSrcline1, (iWidth << 3));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y1, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_y2 (mng_datap  pData,
+                                   mng_int32  iS,
+                                   mng_int32  iM,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline1,
+                                   mng_uint8p pSrcline2,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y2, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    for (iX = 0; iX < iWidth; iX++)
+    {                                  /* calculate the distances */
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+
+      if (*pTempsrc1 == *pTempsrc2)
+        *pTempdst = *pTempsrc1;
+      else
+        mng_put_uint16 ((mng_uint8p)pTempdst,
+                        (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                    (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                        (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+      pTempdst++;
+      pTempsrc1++;
+      pTempsrc2++;
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, (iWidth << 3));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_y3 (mng_datap  pData,
+                                   mng_int32  iS,
+                                   mng_int32  iM,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline1,
+                                   mng_uint8p pSrcline2,
+                                   mng_uint8p pDstline)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y3, MNG_LC_START);
+#endif
+
+  if (pSrcline2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+      MNG_COPY (pDstline, pSrcline1, (iWidth << 3))
+    else
+      MNG_COPY (pDstline, pSrcline2, (iWidth << 3));
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pDstline, pSrcline1, (iWidth << 3));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_y4 (mng_datap  pData,
+                                   mng_int32  iS,
+                                   mng_int32  iM,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline1,
+                                   mng_uint8p pSrcline2,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y4, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2 += 2;
+
+        *pTempdst++ = *pTempsrc1++;    /* replicate alpha from top */
+      }
+    }
+    else
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {                                /* calculate the distances */
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+
+        if (*pTempsrc1 == *pTempsrc2)
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1 += 2;
+        pTempsrc2++;
+
+        *pTempdst++ = *pTempsrc2++;    /* replicate alpha from bottom */
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, (iWidth << 3));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y4, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_magnify_rgba16_y5 (mng_datap  pData,
+                                   mng_int32  iS,
+                                   mng_int32  iM,
+                                   mng_uint32 iWidth,
+                                   mng_uint8p pSrcline1,
+                                   mng_uint8p pSrcline2,
+                                   mng_uint8p pDstline)
+{
+  mng_uint32  iX;
+  mng_uint16p pTempsrc1;
+  mng_uint16p pTempsrc2;
+  mng_uint16p pTempdst;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y5, MNG_LC_START);
+#endif
+
+  pTempsrc1 = (mng_uint16p)pSrcline1;  /* initialize pixel-loop */
+  pTempsrc2 = (mng_uint16p)pSrcline2;
+  pTempdst  = (mng_uint16p)pDstline;
+
+  if (pTempsrc2)                       /* do we have a second line ? */
+  {
+    if (iS < (iM+1) / 2)               /* top half ? */
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst++ = *pTempsrc1++;    /* replicate color from top */
+        *pTempdst++ = *pTempsrc1++;
+        *pTempdst++ = *pTempsrc1++;
+
+        pTempsrc2 += 3;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+    else
+    {
+      for (iX = 0; iX < iWidth; iX++)
+      {
+        *pTempdst++ = *pTempsrc2++;    /* replicate color from bottom */
+        *pTempdst++ = *pTempsrc2++;
+        *pTempdst++ = *pTempsrc2++;
+
+        pTempsrc1 += 3;
+
+        if (*pTempsrc1 == *pTempsrc2)  /* calculate the distances */
+          *pTempdst = *pTempsrc1;
+        else
+          mng_put_uint16 ((mng_uint8p)pTempdst,
+                          (mng_uint16)( ( (2 * iS * ( (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc2)) -
+                                                      (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1)) ) + iM) /
+                                          (iM * 2)) + (mng_int32)(mng_get_uint16 ((mng_uint8p)pTempsrc1))         ) );
+
+        pTempdst++;
+        pTempsrc1++;
+        pTempsrc2++;
+      }
+    }
+  }
+  else
+  {                                    /* just repeat the entire line */
+    MNG_COPY (pTempdst, pTempsrc1, (iWidth << 3));
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_MAGNIFY_RGBA16_Y5, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_NO_16BIT_SUPPORT */
+#endif /* MNG_OPTIMIZE_FOOTPRINT_MAGN */
+#endif /* MNG_SKIPCHUNK_MAGN */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * PAST composition routines - compose over/under with a target object    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_composeover_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iFGa8, iBGa8;
+  mng_uint8      iCr8, iCg8, iCb8, iCa8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEOVER_RGBA8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    iFGa8 = *(pWorkrow+3);       /* get alpha values */
+    iBGa8 = *(pOutrow+3);
+
+    if (iFGa8)                   /* any opacity at all ? */
+    {                            /* fully opaque or background fully transparent ? */
+      if ((iFGa8 == 0xFF) || (iBGa8 == 0))
+      {                          /* then simply copy the values */
+        *pOutrow     = *pWorkrow;
+        *(pOutrow+1) = *(pWorkrow+1);
+        *(pOutrow+2) = *(pWorkrow+2);
+        *(pOutrow+3) = iFGa8;
+      }
+      else
+      {
+        if (iBGa8 == 0xFF)       /* background fully opaque ? */
+        {                        /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+          int i;
+          for (i=2; i >= 0; i--)
+          {
+          MNG_COMPOSE8 (*(pOutrow+i), *(pWorkrow+i), iFGa8, *(pOutrow+i));
+          }
+#else
+          MNG_COMPOSE8 (*pOutrow,     *pWorkrow,     iFGa8, *pOutrow    );
+          MNG_COMPOSE8 (*(pOutrow+1), *(pWorkrow+1), iFGa8, *(pOutrow+1));
+          MNG_COMPOSE8 (*(pOutrow+2), *(pWorkrow+2), iFGa8, *(pOutrow+2));
+#endif
+                                 /* alpha remains fully opaque !!! */
+        }
+        else
+        {                        /* here we'll have to blend */
+          MNG_BLEND8 (*pWorkrow, *(pWorkrow+1), *(pWorkrow+2), iFGa8,
+                      *pOutrow, *(pOutrow+1), *(pOutrow+2), iBGa8,
+                      iCr8, iCg8, iCb8, iCa8);
+                                 /* and return the composed values */
+          *pOutrow     = iCr8;
+          *(pOutrow+1) = iCg8;
+          *(pOutrow+2) = iCb8;
+          *(pOutrow+3) = iCa8;
+        }
+      }
+    }
+
+    pOutrow  += 4;
+    pWorkrow += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEOVER_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_composeover_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint16p    pWorkrow;
+  mng_uint16p    pOutrow;
+  mng_int32      iX;
+  mng_uint16     iFGa16, iFGr16, iFGg16, iFGb16;
+  mng_uint16     iBGa16, iBGr16, iBGg16, iBGb16;
+  mng_uint16     iCr16, iCg16, iCb16, iCa16;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEOVER_RGBA16, MNG_LC_START);
+#endif
+
+  pWorkrow = (mng_uint16p)pData->pRGBArow;
+  pOutrow  = (mng_uint16p)(pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                                            (pData->iCol * pBuf->iSamplesize));
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {                              /* get alpha values */
+    iFGa16 = mng_get_uint16 ((mng_uint8p)(pWorkrow+3));
+    iBGa16 = mng_get_uint16 ((mng_uint8p)(pOutrow+3));
+
+    if (iFGa16)                  /* any opacity at all ? */
+    {                            /* fully opaque or background fully transparent ? */
+      if ((iFGa16 == 0xFFFF) || (iBGa16 == 0))
+      {                          /* then simply copy the values */
+        *pOutrow     = *pWorkrow;
+        *(pOutrow+1) = *(pWorkrow+1);
+        *(pOutrow+2) = *(pWorkrow+2);
+        *(pOutrow+3) = *(pWorkrow+3);
+      }
+      else
+      {                          /* get color values */
+        iFGr16 = mng_get_uint16 ((mng_uint8p)pWorkrow);
+        iFGg16 = mng_get_uint16 ((mng_uint8p)(pWorkrow+1));
+        iFGb16 = mng_get_uint16 ((mng_uint8p)(pWorkrow+2));
+        iBGr16 = mng_get_uint16 ((mng_uint8p)pOutrow);
+        iBGg16 = mng_get_uint16 ((mng_uint8p)(pOutrow+1));
+        iBGb16 = mng_get_uint16 ((mng_uint8p)(pOutrow+2));
+
+        if (iBGa16 == 0xFFFF)    /* background fully opaque ? */
+        {                        /* do alpha composing */
+          MNG_COMPOSE16 (iFGr16, iFGr16, iFGa16, iBGr16);
+          MNG_COMPOSE16 (iFGg16, iFGg16, iFGa16, iBGg16);
+          MNG_COMPOSE16 (iFGb16, iFGb16, iFGa16, iBGb16);
+
+          mng_put_uint16 ((mng_uint8p)pOutrow,     iFGr16);
+          mng_put_uint16 ((mng_uint8p)(pOutrow+1), iFGg16);
+          mng_put_uint16 ((mng_uint8p)(pOutrow+2), iFGb16);
+                                 /* alpha remains fully opaque !!! */
+        }
+        else
+        {                        /* here we'll have to blend */
+          MNG_BLEND16 (iFGr16, iFGg16, iFGb16, iFGa16,
+                       iBGr16, iBGg16, iBGb16, iBGa16,
+                       iCr16,  iCg16,  iCb16,  iCa16);
+                                 /* and return the composed values */
+          mng_put_uint16 ((mng_uint8p)pOutrow,     iCr16);
+          mng_put_uint16 ((mng_uint8p)(pOutrow+1), iCg16);
+          mng_put_uint16 ((mng_uint8p)(pOutrow+2), iCb16);
+          mng_put_uint16 ((mng_uint8p)(pOutrow+3), iCa16);
+        }
+      }
+    }
+
+    pOutrow  += 4;
+    pWorkrow += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEOVER_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_composeunder_rgba8 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint8p     pWorkrow;
+  mng_uint8p     pOutrow;
+  mng_int32      iX;
+  mng_uint8      iFGa8, iBGa8;
+  mng_uint8      iCr8, iCg8, iCb8, iCa8;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEUNDER_RGBA8, MNG_LC_START);
+#endif
+
+  pWorkrow = pData->pRGBArow;
+  pOutrow  = pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                              (pData->iCol * pBuf->iSamplesize);
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {
+    iFGa8 = *(pOutrow+3);        /* get alpha values */
+    iBGa8 = *(pWorkrow+3);
+                                 /* anything to do at all ? */
+    if ((iBGa8) && (iFGa8 != 0xFF))
+    {
+      if (iBGa8 == 0xFF)         /* background fully opaque ? */
+      {                          /* do alpha composing */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_COMPOSE
+        int i;
+        for (i=2; i >= 0; i--)
+        {
+        MNG_COMPOSE8 (*(pOutrow+i), *(pOutrow+i), iFGa8, *(pWorkrow+i));
+        }
+#else
+        MNG_COMPOSE8 (*pOutrow,     *pOutrow,     iFGa8, *pWorkrow    );
+        MNG_COMPOSE8 (*(pOutrow+1), *(pOutrow+1), iFGa8, *(pWorkrow+1));
+        MNG_COMPOSE8 (*(pOutrow+2), *(pOutrow+2), iFGa8, *(pWorkrow+2));
+#endif
+        *(pOutrow+3) = 0xFF;     /* alpha becomes fully opaque !!! */
+      }
+      else
+      {                          /* here we'll have to blend */
+        MNG_BLEND8 (*pOutrow, *(pOutrow+1), *(pOutrow+2), iFGa8,
+                    *pWorkrow, *(pWorkrow+1), *(pWorkrow+2), iBGa8,
+                    iCr8, iCg8, iCb8, iCa8);
+                                 /* and return the composed values */
+        *pOutrow     = iCr8;
+        *(pOutrow+1) = iCg8;
+        *(pOutrow+2) = iCb8;
+        *(pOutrow+3) = iCa8;
+      }
+    }
+
+    pOutrow  += 4;
+    pWorkrow += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEUNDER_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_composeunder_rgba16 (mng_datap pData)
+{
+  mng_imagedatap pBuf = ((mng_imagep)pData->pStoreobj)->pImgbuf;
+  mng_uint16p    pWorkrow;
+  mng_uint16p    pOutrow;
+  mng_int32      iX;
+  mng_uint16     iFGa16, iFGr16, iFGg16, iFGb16;
+  mng_uint16     iBGa16, iBGr16, iBGg16, iBGb16;
+  mng_uint16     iCr16, iCg16, iCb16, iCa16;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEUNDER_RGBA16, MNG_LC_START);
+#endif
+
+  pWorkrow = (mng_uint16p)pData->pRGBArow;
+  pOutrow  = (mng_uint16p)(pBuf->pImgdata + (pData->iRow * pBuf->iRowsize   ) +
+                                            (pData->iCol * pBuf->iSamplesize));
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {                              /* get alpha values */
+    iFGa16 = mng_get_uint16 ((mng_uint8p)(pOutrow+3));
+    iBGa16 = mng_get_uint16 ((mng_uint8p)(pWorkrow+3));
+                                 /* anything to do at all ? */
+    if ((iBGa16) && (iFGa16 != 0xFFFF))
+    {
+      iFGr16 = mng_get_uint16 ((mng_uint8p)pOutrow);
+      iFGg16 = mng_get_uint16 ((mng_uint8p)(pOutrow+1));
+      iFGb16 = mng_get_uint16 ((mng_uint8p)(pOutrow+2));
+      iBGr16 = mng_get_uint16 ((mng_uint8p)pWorkrow);
+      iBGg16 = mng_get_uint16 ((mng_uint8p)(pWorkrow+1));
+      iBGb16 = mng_get_uint16 ((mng_uint8p)(pWorkrow+2));
+
+      if (iBGa16 == 0xFFFF)      /* background fully opaque ? */
+      {                          /* do alpha composing */
+        MNG_COMPOSE16 (iFGr16, iFGr16, iFGa16, iBGr16);
+        MNG_COMPOSE16 (iFGg16, iFGg16, iFGa16, iBGg16);
+        MNG_COMPOSE16 (iFGb16, iFGb16, iFGa16, iBGb16);
+
+        mng_put_uint16 ((mng_uint8p)pOutrow,     iFGr16);
+        mng_put_uint16 ((mng_uint8p)(pOutrow+1), iFGg16);
+        mng_put_uint16 ((mng_uint8p)(pOutrow+2), iFGb16);
+        *(pOutrow+3) = 0xFFFF;   /* alpha becomes fully opaque !!! */
+      }
+      else
+      {                          /* here we'll have to blend */
+        MNG_BLEND16 (iFGr16, iFGg16, iFGb16, iFGa16,
+                     iBGr16, iBGg16, iBGb16, iBGa16,
+                     iCr16,  iCg16,  iCb16,  iCa16);
+                                 /* and return the composed values */
+        mng_put_uint16 ((mng_uint8p)pOutrow,     iCr16);
+        mng_put_uint16 ((mng_uint8p)(pOutrow+1), iCg16);
+        mng_put_uint16 ((mng_uint8p)(pOutrow+2), iCb16);
+        mng_put_uint16 ((mng_uint8p)(pOutrow+3), iCa16);
+      }
+    }
+
+    pOutrow  += 4;
+    pWorkrow += 4;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_COMPOSEUNDER_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * PAST flip & tile routines - flip or tile a row of pixels               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_flip_rgba8 (mng_datap pData)
+{
+  mng_uint32p pWorkrow;
+  mng_uint32p pOutrow;
+  mng_int32   iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FLIP_RGBA8, MNG_LC_START);
+#endif
+                                       /* setup temp pointers */
+  pWorkrow        = (mng_uint32p)pData->pRGBArow + pData->iRowsamples - 1;
+  pOutrow         = (mng_uint32p)pData->pWorkrow;
+                                       /* swap original buffers */
+  pData->pWorkrow = pData->pRGBArow;
+  pData->pRGBArow = (mng_uint8p)pOutrow;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {                                    /* let's flip */
+    *pOutrow = *pWorkrow;
+    pOutrow++;
+    pWorkrow--;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FLIP_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_flip_rgba16 (mng_datap pData)
+{
+  mng_uint32p pWorkrow;
+  mng_uint32p pOutrow;
+  mng_int32   iX;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FLIP_RGBA16, MNG_LC_START);
+#endif
+                                       /* setup temp pointers */
+  pWorkrow        = (mng_uint32p)pData->pRGBArow + ((pData->iRowsamples - 1) << 1);
+  pOutrow         = (mng_uint32p)pData->pWorkrow;
+                                       /* swap original buffers */
+  pData->pWorkrow = pData->pRGBArow;
+  pData->pRGBArow = (mng_uint8p)pOutrow;
+
+#ifdef MNG_DECREMENT_LOOPS
+  for (iX = pData->iRowsamples; iX > 0; iX--)
+#else
+  for (iX = 0; iX < pData->iRowsamples; iX++)
+#endif
+  {                                    /* let's flip */
+    *pOutrow       = *pWorkrow;
+    *(pOutrow + 1) = *(pWorkrow + 1);
+
+    pOutrow  += 2;
+    pWorkrow -= 2;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_FLIP_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode mng_tile_rgba8 (mng_datap pData)
+{
+  mng_uint32p pWorkrow;
+  mng_uint32p pOutrow;
+  mng_int32   iX;
+  mng_uint32  iZ, iMax;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_TILE_RGBA8, MNG_LC_START);
+#endif
+
+  iZ              = pData->iSourcel;   /* indent ? */
+                                       /* what's our source-length */
+  iMax            = ((mng_imagep)pData->pRetrieveobj)->pImgbuf->iWidth;
+                                       /* setup temp pointers */
+  pWorkrow        = (mng_uint32p)pData->pRGBArow + iZ;
+  pOutrow         = (mng_uint32p)pData->pWorkrow;
+                                       /* swap original buffers */
+  pData->pWorkrow = pData->pRGBArow;
+  pData->pRGBArow = (mng_uint8p)pOutrow;
+
+  for (iX = pData->iDestl; iX < pData->iDestr; iX++)
+  {                                    /* tiiiile */
+    *pOutrow = *pWorkrow;
+
+    pWorkrow++;
+    pOutrow++;
+    iZ++;
+
+    if (iZ >= iMax)                    /* end of source ? */
+    {
+      iZ       = 0;
+      pWorkrow = (mng_uint32p)pData->pWorkrow;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_TILE_RGBA8, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_tile_rgba16 (mng_datap pData)
+{
+  mng_uint32p pWorkrow;
+  mng_uint32p pOutrow;
+  mng_int32   iX;
+  mng_uint32  iZ, iMax;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_TILE_RGBA16, MNG_LC_START);
+#endif
+
+  iZ              = pData->iSourcel;   /* indent ? */
+                                       /* what's our source-length */
+  iMax            = ((mng_imagep)pData->pRetrieveobj)->pImgbuf->iWidth;
+                                       /* setup temp pointers */
+  pWorkrow        = (mng_uint32p)pData->pRGBArow + (iZ << 1);
+  pOutrow         = (mng_uint32p)pData->pWorkrow;
+                                       /* swap original buffers */
+  pData->pWorkrow = pData->pRGBArow;
+  pData->pRGBArow = (mng_uint8p)pOutrow;
+
+  for (iX = pData->iDestl; iX < pData->iDestr; iX++)
+  {                                    /* tiiiile */
+    *pOutrow       = *pWorkrow;
+    *(pOutrow + 1) = *(pWorkrow + 1);
+
+    pWorkrow += 2;
+    pOutrow  += 2;
+    iZ++;
+
+    if (iZ >= iMax)                    /* end of source ? */
+    {
+      iZ       = 0;
+      pWorkrow = (mng_uint32p)pData->pWorkrow;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_TILE_RGBA16, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SKIPCHUNK_PAST */
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_DISPLAY_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_pixels.h b/src/3rdparty/libmng/libmng_pixels.h
new file mode 100644
index 0000000..5a0281e
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_pixels.h
@@ -0,0 +1,1147 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_pixels.h           copyright (c) 2000-2006 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Pixel-row management routines (definition)                 * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the pixel-row management routines            * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/22/2000 - G.Juyn                                * */
+/* *             - added some JNG definitions                               * */
+/* *             - added delta-image row-processing routines                * */
+/* *             0.5.2 - 06/05/2000 - G.Juyn                                * */
+/* *             - added support for RGB8_A8 canvasstyle                    * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - changed progressive-display processing                   * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN support                                       * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added optional support for bKGD for PNG images           * */
+/* *             - added support for JDAA                                   * */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - implemented delayed delta-processing                     * */
+/* *                                                                        * */
+/* *             0.9.4 -  1/18/2001 - G.Juyn                                * */
+/* *             - added "new" MAGN methods 3, 4 & 5                        * */
+/* *                                                                        * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn (code by G.Kelly)              * */
+/* *             - added BGRA8 canvas with premultiplied alpha              * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             - completed delta-image support                            * */
+/* *             1.0.5 - 08/16/2002 - G.Juyn                                * */
+/* *             - completed MAGN support (16-bit functions)                * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/22/2002 - G.Juyn                                * */
+/* *             - added bgrx8 canvas (filler byte)                         * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - added compose over/under routines for PAST processing    * */
+/* *             - added flip & tile routines for PAST processing           * */
+/* *                                                                        * */
+/* *             1.0.6 - 03/09/2003 - G.Juyn                                * */
+/* *             - hiding 12-bit JPEG stuff                                 * */
+/* *             1.0.6 - 05/11/2003 - G. Juyn                               * */
+/* *             - added conditionals around canvas update routines         * */
+/* *             1.0.6 - 06/09/2003 - G. R-P                                * */
+/* *             - added conditionals around 8-bit magn routines            * */
+/* *             1.0.6 - 07/07/2003 - G. R-P                                * */
+/* *             - removed conditionals around 8-bit magn routines          * */
+/* *             - added conditionals around 16-bit and delta-PNG           * */
+/* *               supporting code                                          * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added SKIPCHUNK conditionals around PAST chunk support   * */
+/* *             1.0.6 - 08/18/2003 - G.R-P                                 * */
+/* *             - added conditionals around 1, 2, and 4-bit prototypes     * */
+/* *                                                                        * */
+/* *             1.0.7 - 11/27/2003 - R.A                                   * */
+/* *             - added CANVAS_RGB565 and CANVAS_BGR565                    * */
+/* *             1.0.7 - 12/06/2003 - R.A                                   * */
+/* *             - added CANVAS_RGBA565 and CANVAS_BGRA565                  * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *                                                                        * */
+/* *             1.0.9 - 10/10/2004 - G.R-P.                                * */
+/* *             - added MNG_NO_1_2_4BIT_SUPPORT                            * */
+/* *             1.0.9 - 10/14/2004 - G.Juyn                                * */
+/* *             - added bgr565_a8 canvas-style (thanks to J. Elvander)     * */
+/* *                                                                        * */
+/* *             1.0.10 - 03/07/2006 - (thanks to W. Manthey)               * */
+/* *             - added CANVAS_RGB555 and CANVAS_BGR555                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_pixels_h_
+#define _libmng_pixels_h_
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Progressive display check - checks to see if progressive display is    * */
+/* * in order & indicates so                                                * */
+/* *                                                                        * */
+/* * The routine is called after a call to one of the display_xxx routines  * */
+/* * if appropriate                                                         * */
+/* *                                                                        * */
+/* * The refresh is warrented in the read_chunk routine (mng_read.c)        * */
+/* * and only during read&display processing, since there's not much point  * */
+/* * doing it from memory!                                                  * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_display_progressive_check (mng_datap pData);
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Display routines - convert rowdata (which is already color-corrected)  * */
+/* * to the output canvas, respecting any transparency information          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCANVAS_RGB8
+mng_retcode mng_display_rgb8           (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA8
+mng_retcode mng_display_rgba8          (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA8_PM
+mng_retcode mng_display_rgba8_pm       (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_ARGB8
+mng_retcode mng_display_argb8          (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_ARGB8_PM
+mng_retcode mng_display_argb8_pm       (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_RGB8_A8
+mng_retcode mng_display_rgb8_a8        (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGR8
+mng_retcode mng_display_bgr8           (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGRX8
+mng_retcode mng_display_bgrx8          (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA8
+mng_retcode mng_display_bgra8          (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA8_PM
+mng_retcode mng_display_bgra8_pm       (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_ABGR8
+mng_retcode mng_display_abgr8          (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_ABGR8_PM
+mng_retcode mng_display_abgr8_pm       (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_RGB565
+mng_retcode mng_display_rgb565         (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA565
+mng_retcode mng_display_rgba565        (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565
+mng_retcode mng_display_bgr565         (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA565
+mng_retcode mng_display_bgra565        (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565_A8
+mng_retcode mng_display_bgr565_a8      (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_RGB555
+mng_retcode mng_display_rgb555         (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGR555
+mng_retcode mng_display_bgr555         (mng_datap  pData);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Background restore routines - restore the background with info from    * */
+/* * the BACK and/or bKGD chunk and/or the app's background canvas          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_restore_bkgd_backimage (mng_datap  pData);
+mng_retcode mng_restore_bkgd_backcolor (mng_datap  pData);
+mng_retcode mng_restore_bkgd_bkgd      (mng_datap  pData);
+mng_retcode mng_restore_bkgd_bgcolor   (mng_datap  pData);
+#ifndef MNG_SKIPCANVAS_RGB8
+mng_retcode mng_restore_bkgd_rgb8      (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGR8
+mng_retcode mng_restore_bkgd_bgr8      (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGRX8
+mng_retcode mng_restore_bkgd_bgrx8     (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_RGB565
+mng_retcode mng_restore_bkgd_rgb565    (mng_datap  pData);
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565
+mng_retcode mng_restore_bkgd_bgr565    (mng_datap  pData);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row retrieval routines - retrieve processed & uncompressed row-data    * */
+/* * from the current "object"                                              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_retrieve_g8            (mng_datap  pData);
+mng_retcode mng_retrieve_rgb8          (mng_datap  pData);
+mng_retcode mng_retrieve_idx8          (mng_datap  pData);
+mng_retcode mng_retrieve_ga8           (mng_datap  pData);
+mng_retcode mng_retrieve_rgba8         (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_retrieve_g16           (mng_datap  pData);
+mng_retcode mng_retrieve_ga16          (mng_datap  pData);
+mng_retcode mng_retrieve_rgb16         (mng_datap  pData);
+mng_retcode mng_retrieve_rgba16        (mng_datap  pData);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row storage routines - store processed & uncompressed row-data         * */
+/* * into the current "object"                                              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_g1               (mng_datap  pData);
+mng_retcode mng_store_g2               (mng_datap  pData);
+mng_retcode mng_store_g4               (mng_datap  pData);
+mng_retcode mng_store_idx1             (mng_datap  pData);
+mng_retcode mng_store_idx2             (mng_datap  pData);
+mng_retcode mng_store_idx4             (mng_datap  pData);
+#endif
+mng_retcode mng_store_idx8             (mng_datap  pData);
+mng_retcode mng_store_rgb8             (mng_datap  pData);
+mng_retcode mng_store_g8               (mng_datap  pData);
+mng_retcode mng_store_ga8              (mng_datap  pData);
+mng_retcode mng_store_rgba8            (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_g16              (mng_datap  pData);
+mng_retcode mng_store_ga16             (mng_datap  pData);
+mng_retcode mng_store_rgb16            (mng_datap  pData);
+mng_retcode mng_store_rgba16           (mng_datap  pData);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row storage routines (JPEG) - store processed & uncompressed row-data  * */
+/* * into the current "object"                                              * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_store_jpeg_g8          (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgb8        (mng_datap  pData);
+mng_retcode mng_store_jpeg_ga8         (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgba8       (mng_datap  pData);
+
+#ifdef MNG_SUPPORT_JPEG12
+mng_retcode mng_store_jpeg_g12         (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgb12       (mng_datap  pData);
+mng_retcode mng_store_jpeg_ga12        (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgba12      (mng_datap  pData);
+#endif
+
+mng_retcode mng_store_jpeg_g8_alpha    (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgb8_alpha  (mng_datap  pData);
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_jpeg_g8_a1       (mng_datap  pData);
+mng_retcode mng_store_jpeg_g8_a2       (mng_datap  pData);
+mng_retcode mng_store_jpeg_g8_a4       (mng_datap  pData);
+#endif
+mng_retcode mng_store_jpeg_g8_a8       (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_jpeg_g8_a16      (mng_datap  pData);
+#endif
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_jpeg_rgb8_a1     (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgb8_a2     (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgb8_a4     (mng_datap  pData);
+#endif
+mng_retcode mng_store_jpeg_rgb8_a8     (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_jpeg_rgb8_a16    (mng_datap  pData);
+#endif
+
+#ifdef MNG_SUPPORT_JPEG12
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_jpeg_g12_a1      (mng_datap  pData);
+mng_retcode mng_store_jpeg_g12_a2      (mng_datap  pData);
+mng_retcode mng_store_jpeg_g12_a4      (mng_datap  pData);
+#endif
+mng_retcode mng_store_jpeg_g12_a8      (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_jpeg_g12_a16     (mng_datap  pData);
+#endif
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_store_jpeg_rgb12_a1    (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgb12_a2    (mng_datap  pData);
+mng_retcode mng_store_jpeg_rgb12_a4    (mng_datap  pData);
+#endif
+mng_retcode mng_store_jpeg_rgb12_a8    (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_store_jpeg_rgb12_a16   (mng_datap  pData);
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - apply the processed & uncompressed row-data * */
+/* * onto the target "object"                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_delta_g1               (mng_datap  pData);
+mng_retcode mng_delta_g2               (mng_datap  pData);
+mng_retcode mng_delta_g4               (mng_datap  pData);
+#endif
+mng_retcode mng_delta_g8               (mng_datap  pData);
+mng_retcode mng_delta_g16              (mng_datap  pData);
+mng_retcode mng_delta_rgb8             (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgb16            (mng_datap  pData);
+#endif
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_delta_idx1             (mng_datap  pData);
+mng_retcode mng_delta_idx2             (mng_datap  pData);
+mng_retcode mng_delta_idx4             (mng_datap  pData);
+#endif
+mng_retcode mng_delta_idx8             (mng_datap  pData);
+mng_retcode mng_delta_ga8              (mng_datap  pData);
+mng_retcode mng_delta_rgba8            (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_ga16             (mng_datap  pData);
+mng_retcode mng_delta_rgba16           (mng_datap  pData);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - apply the source row onto the target        * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_delta_g1_g1            (mng_datap  pData);
+mng_retcode mng_delta_g2_g2            (mng_datap  pData);
+mng_retcode mng_delta_g4_g4            (mng_datap  pData);
+#endif
+mng_retcode mng_delta_g8_g8            (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_g16_g16          (mng_datap  pData);
+#endif
+mng_retcode mng_delta_ga8_ga8          (mng_datap  pData);
+mng_retcode mng_delta_ga8_g8           (mng_datap  pData);
+mng_retcode mng_delta_ga8_a8           (mng_datap  pData);
+mng_retcode mng_delta_rgba8_rgb8       (mng_datap  pData);
+mng_retcode mng_delta_rgba8_a8         (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_ga16_ga16        (mng_datap  pData);
+mng_retcode mng_delta_ga16_g16         (mng_datap  pData);
+mng_retcode mng_delta_ga16_a16         (mng_datap  pData);
+mng_retcode mng_delta_rgba16_a16       (mng_datap  pData);
+mng_retcode mng_delta_rgba16_rgb16     (mng_datap  pData);
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+mng_retcode mng_delta_rgb8_rgb8        (mng_datap  pData); /* Used for PAST */
+mng_retcode mng_delta_rgba8_rgba8      (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_delta_rgb16_rgb16      (mng_datap  pData);
+mng_retcode mng_delta_rgba16_rgba16    (mng_datap  pData);
+#endif
+
+#ifndef MNG_NO_DELTA_PNG
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - scale the delta to bitdepth of target       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_scale_g1_g2            (mng_datap  pData);
+mng_retcode mng_scale_g1_g4            (mng_datap  pData);
+mng_retcode mng_scale_g1_g8            (mng_datap  pData);
+mng_retcode mng_scale_g2_g4            (mng_datap  pData);
+mng_retcode mng_scale_g2_g8            (mng_datap  pData);
+mng_retcode mng_scale_g4_g8            (mng_datap  pData);
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_scale_g1_g16           (mng_datap  pData);
+mng_retcode mng_scale_g2_g16           (mng_datap  pData);
+mng_retcode mng_scale_g4_g16           (mng_datap  pData);
+#endif
+mng_retcode mng_scale_g8_g16           (mng_datap  pData);
+mng_retcode mng_scale_ga8_ga16         (mng_datap  pData);
+mng_retcode mng_scale_rgb8_rgb16       (mng_datap  pData);
+mng_retcode mng_scale_rgba8_rgba16     (mng_datap  pData);
+#endif
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_scale_g2_g1            (mng_datap  pData);
+mng_retcode mng_scale_g4_g1            (mng_datap  pData);
+mng_retcode mng_scale_g8_g1            (mng_datap  pData);
+mng_retcode mng_scale_g4_g2            (mng_datap  pData);
+mng_retcode mng_scale_g8_g2            (mng_datap  pData);
+mng_retcode mng_scale_g8_g4            (mng_datap  pData);
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_scale_g16_g1           (mng_datap  pData);
+mng_retcode mng_scale_g16_g2           (mng_datap  pData);
+mng_retcode mng_scale_g16_g4           (mng_datap  pData);
+#endif
+mng_retcode mng_scale_g16_g8           (mng_datap  pData);
+mng_retcode mng_scale_ga16_ga8         (mng_datap  pData);
+mng_retcode mng_scale_rgb16_rgb8       (mng_datap  pData);
+mng_retcode mng_scale_rgba16_rgba8     (mng_datap  pData);
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image bit routines - promote bit_depth                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_uint8   mng_promote_replicate_1_2  (mng_uint8  iB);
+mng_uint8   mng_promote_replicate_1_4  (mng_uint8  iB);
+mng_uint8   mng_promote_replicate_1_8  (mng_uint8  iB);
+mng_uint8   mng_promote_replicate_2_4  (mng_uint8  iB);
+mng_uint8   mng_promote_replicate_2_8  (mng_uint8  iB);
+mng_uint8   mng_promote_replicate_4_8  (mng_uint8  iB);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16  mng_promote_replicate_1_16 (mng_uint8  iB);
+mng_uint16  mng_promote_replicate_2_16 (mng_uint8  iB);
+mng_uint16  mng_promote_replicate_4_16 (mng_uint8  iB);
+mng_uint16  mng_promote_replicate_8_16 (mng_uint8  iB);
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DELTA_PNG
+mng_uint8   mng_promote_zerofill_1_2   (mng_uint8  iB);
+mng_uint8   mng_promote_zerofill_1_4   (mng_uint8  iB);
+mng_uint8   mng_promote_zerofill_1_8   (mng_uint8  iB);
+mng_uint8   mng_promote_zerofill_2_4   (mng_uint8  iB);
+mng_uint8   mng_promote_zerofill_2_8   (mng_uint8  iB);
+mng_uint8   mng_promote_zerofill_4_8   (mng_uint8  iB);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_uint16  mng_promote_zerofill_1_16  (mng_uint8  iB);
+mng_uint16  mng_promote_zerofill_2_16  (mng_uint8  iB);
+mng_uint16  mng_promote_zerofill_4_16  (mng_uint8  iB);
+mng_uint16  mng_promote_zerofill_8_16  (mng_uint8  iB);
+#endif
+#endif /* MNG_NO_DELTA_PNG */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Delta-image row routines - promote color_type                          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_promote_g8_g8          (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_g16         (mng_datap  pData);
+mng_retcode mng_promote_g16_g16        (mng_datap  pData);
+#endif
+
+mng_retcode mng_promote_g8_ga8         (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_ga16        (mng_datap  pData);
+mng_retcode mng_promote_g16_ga16       (mng_datap  pData);
+#endif
+
+mng_retcode mng_promote_g8_rgb8        (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_rgb16       (mng_datap  pData);
+mng_retcode mng_promote_g16_rgb16      (mng_datap  pData);
+#endif
+
+mng_retcode mng_promote_g8_rgba8       (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_g8_rgba16      (mng_datap  pData);
+mng_retcode mng_promote_g16_rgba16     (mng_datap  pData);
+
+mng_retcode mng_promote_ga8_ga16       (mng_datap  pData);
+#endif
+
+mng_retcode mng_promote_ga8_rgba8      (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_ga8_rgba16     (mng_datap  pData);
+mng_retcode mng_promote_ga16_rgba16    (mng_datap  pData);
+#endif
+
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_rgb8_rgb16     (mng_datap  pData);
+#endif
+
+mng_retcode mng_promote_rgb8_rgba8     (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_rgb8_rgba16    (mng_datap  pData);
+mng_retcode mng_promote_rgb16_rgba16   (mng_datap  pData);
+#endif
+
+mng_retcode mng_promote_idx8_rgb8      (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_idx8_rgb16     (mng_datap  pData);
+#endif
+
+mng_retcode mng_promote_idx8_rgba8     (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_promote_idx8_rgba16    (mng_datap  pData);
+
+mng_retcode mng_promote_rgba8_rgba16   (mng_datap  pData);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row processing routines - convert uncompressed data from zlib to       * */
+/* * managable row-data which serves as input to the color-management       * */
+/* * routines                                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_process_g1             (mng_datap  pData);
+mng_retcode mng_process_g2             (mng_datap  pData);
+mng_retcode mng_process_g4             (mng_datap  pData);
+#endif
+mng_retcode mng_process_g8             (mng_datap  pData);
+mng_retcode mng_process_rgb8           (mng_datap  pData);
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_process_idx1           (mng_datap  pData);
+mng_retcode mng_process_idx2           (mng_datap  pData);
+mng_retcode mng_process_idx4           (mng_datap  pData);
+#endif
+mng_retcode mng_process_idx8           (mng_datap  pData);
+mng_retcode mng_process_ga8            (mng_datap  pData);
+mng_retcode mng_process_rgba8          (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_process_g16            (mng_datap  pData);
+mng_retcode mng_process_ga16           (mng_datap  pData);
+mng_retcode mng_process_rgb16          (mng_datap  pData);
+mng_retcode mng_process_rgba16         (mng_datap  pData);
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row processing initialization routines - set up the variables needed   * */
+/* * to process uncompressed row-data                                       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_FOOTPRINT_INIT
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_g1_i              (mng_datap  pData);
+mng_retcode mng_init_g2_i              (mng_datap  pData);
+mng_retcode mng_init_g4_i              (mng_datap  pData);
+#endif
+mng_retcode mng_init_g8_i              (mng_datap  pData);
+mng_retcode mng_init_rgb8_i            (mng_datap  pData);
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_idx1_i            (mng_datap  pData);
+mng_retcode mng_init_idx2_i            (mng_datap  pData);
+mng_retcode mng_init_idx4_i            (mng_datap  pData);
+#endif
+mng_retcode mng_init_idx8_i            (mng_datap  pData);
+mng_retcode mng_init_ga8_i             (mng_datap  pData);
+mng_retcode mng_init_rgba8_i           (mng_datap  pData);
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_g1_ni             (mng_datap  pData);
+mng_retcode mng_init_g2_ni             (mng_datap  pData);
+mng_retcode mng_init_g4_ni             (mng_datap  pData);
+#endif
+mng_retcode mng_init_g8_ni             (mng_datap  pData);
+mng_retcode mng_init_rgb8_ni           (mng_datap  pData);
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_idx1_ni           (mng_datap  pData);
+mng_retcode mng_init_idx2_ni           (mng_datap  pData);
+mng_retcode mng_init_idx4_ni           (mng_datap  pData);
+#endif
+mng_retcode mng_init_idx8_ni           (mng_datap  pData);
+mng_retcode mng_init_ga8_ni            (mng_datap  pData);
+mng_retcode mng_init_rgba8_ni          (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_g16_i             (mng_datap  pData);
+mng_retcode mng_init_rgb16_i           (mng_datap  pData);
+mng_retcode mng_init_ga16_i            (mng_datap  pData);
+mng_retcode mng_init_rgba16_i          (mng_datap  pData);
+mng_retcode mng_init_g16_ni            (mng_datap  pData);
+mng_retcode mng_init_rgb16_ni          (mng_datap  pData);
+mng_retcode mng_init_ga16_ni           (mng_datap  pData);
+mng_retcode mng_init_rgba16_ni         (mng_datap  pData);
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Row processing initialization routines (JPEG) - set up the variables   * */
+/* * needed to process uncompressed row-data                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_FOOTPRINT_INIT
+#ifdef MNG_INCLUDE_JNG
+#ifndef MNG_NO_1_2_4BIT_SUPPORT
+mng_retcode mng_init_jpeg_a1_ni        (mng_datap  pData);
+mng_retcode mng_init_jpeg_a2_ni        (mng_datap  pData);
+mng_retcode mng_init_jpeg_a4_ni        (mng_datap  pData);
+#endif
+mng_retcode mng_init_jpeg_a8_ni        (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_init_jpeg_a16_ni       (mng_datap  pData);
+#endif
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * General row processing routines                                        * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_init_rowproc           (mng_datap  pData);
+mng_retcode mng_next_row               (mng_datap  pData);
+#ifdef MNG_INCLUDE_JNG
+mng_retcode mng_next_jpeg_alpharow     (mng_datap  pData);
+mng_retcode mng_next_jpeg_row          (mng_datap  pData);
+#endif
+mng_retcode mng_cleanup_rowproc        (mng_datap  pData);
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Magnification row routines - apply magnification transforms            * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+mng_retcode mng_magnify_g8_x1          (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g8_x2          (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g8_x3          (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb8_x1        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb8_x2        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb8_x3        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_x1         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_x2         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_x3         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_x4         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_x5         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+#endif
+mng_retcode mng_magnify_rgba8_x1       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_x2       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_x3       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_x4       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_x5       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+mng_retcode mng_magnify_g8_y1          (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g8_y2          (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g8_y3          (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb8_y1        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb8_y2        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb8_y3        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_y1         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_y2         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_y3         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_y4         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga8_y5         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+#endif
+mng_retcode mng_magnify_rgba8_y1       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_y2       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_y3       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_y4       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba8_y5       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+
+/* ************************************************************************** */
+#ifndef MNG_NO_16BIT_SUPPORT
+#ifndef MNG_OPTIMIZE_FOOTPRINT_MAGN
+mng_retcode mng_magnify_g16_x1         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g16_x2         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g16_x3         (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb16_x1       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb16_x2       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb16_x3       (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_x1        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_x2        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_x3        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_x4        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_x5        (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_x1      (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_x2      (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_x3      (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_x4      (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_x5      (mng_datap  pData,
+                                        mng_uint16 iMX,
+                                        mng_uint16 iML,
+                                        mng_uint16 iMR,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline,
+                                        mng_uint8p pDstline);
+
+mng_retcode mng_magnify_g16_y1         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g16_y2         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_g16_y3         (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb16_y1       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb16_y2       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgb16_y3       (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_y1        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_y2        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_y3        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_y4        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_ga16_y5        (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_y1      (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_y2      (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_y3      (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_y4      (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+mng_retcode mng_magnify_rgba16_y5      (mng_datap  pData,
+                                        mng_int32  iS,
+                                        mng_int32  iM,
+                                        mng_uint32 iWidth,
+                                        mng_uint8p pSrcline1,
+                                        mng_uint8p pSrcline2,
+                                        mng_uint8p pDstline);
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * PAST composition routines - compose over/under with a target object    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode mng_composeover_rgba8      (mng_datap  pData);
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_composeunder_rgba8     (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_composeover_rgba16     (mng_datap  pData);
+mng_retcode mng_composeunder_rgba16    (mng_datap  pData);
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * PAST flip & tile routines - flip or tile a row of pixels               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef MNG_SKIPCHUNK_PAST
+mng_retcode mng_flip_rgba8             (mng_datap  pData);
+mng_retcode mng_tile_rgba8             (mng_datap  pData);
+#ifndef MNG_NO_16BIT_SUPPORT
+mng_retcode mng_flip_rgba16            (mng_datap  pData);
+mng_retcode mng_tile_rgba16            (mng_datap  pData);
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#endif /* _libmng_pixels_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_prop_xs.c b/src/3rdparty/libmng/libmng_prop_xs.c
new file mode 100644
index 0000000..3849d51
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_prop_xs.c
@@ -0,0 +1,2799 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_prop_xs.c          copyright (c) 2000-2006 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : property get/set interface (implementation)                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the property get/set functions           * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - fixed calling convention                                 * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added set_outputprofile2 & set_srgbprofile2              * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - changed inclusion of cms-routines                        * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added support for get/set default zlib/IJG parms         * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - fixed up punctuation (contribution by Tim Rowley)        * */
+/* *             0.5.2 - 06/05/2000 - G.Juyn                                * */
+/* *             - added support for RGB8_A8 canvasstyle                    * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added get/set for speedtype to facilitate testing        * */
+/* *             - added get for imagelevel during processtext callback     * */
+/* *             0.5.3 - 06/26/2000 - G.Juyn                                * */
+/* *             - changed userdata variable to mng_ptr                     * */
+/* *             0.5.3 - 06/29/2000 - G.Juyn                                * */
+/* *             - fixed incompatible return-types                          * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - added get routines for internal display variables        * */
+/* *             - added get/set routines for suspensionmode variable       * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added get/set routines for sectionbreak variable         * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - added status_xxxx functions                              * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 10/10/2000 - G.Juyn                                * */
+/* *             - added support for alpha-depth prediction                 * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added functions to retrieve PNG/JNG specific header-info * */
+/* *             0.9.3 - 10/20/2000 - G.Juyn                                * */
+/* *             - added get/set for bKGD preference setting                * */
+/* *             0.9.3 - 10/21/2000 - G.Juyn                                * */
+/* *             - added get function for interlace/progressive display     * */
+/* *                                                                        * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn (code by G.Kelly)              * */
+/* *             - added BGRA8 canvas with premultiplied alpha              * */
+/* *             1.0.1 - 05/02/2001 - G.Juyn                                * */
+/* *             - added "default" sRGB generation (Thanks Marti!)          * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - added option to turn off progressive refresh             * */
+/* *                                                                        * */
+/* *             1.0.3 - 08/06/2001 - G.Juyn                                * */
+/* *             - added get function for last processed BACK chunk         * */
+/* *                                                                        * */
+/* *             1.0.4 - 06/22/2002 - G.Juyn                                * */
+/* *             - B495442 - invalid returnvalue in mng_get_suspensionmode  * */
+/* *                                                                        * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/22/2002 - G.Juyn                                * */
+/* *             - added bgrx8 canvas (filler byte)                         * */
+/* *             1.0.5 - 11/07/2002 - G.Juyn                                * */
+/* *             - added support to get totals after mng_read()             * */
+/* *                                                                        * */
+/* *             1.0.6 - 05/11/2003 - G. Juyn                               * */
+/* *             - added conditionals around canvas update routines         * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added conditionals around some JNG-supporting code       * */
+/* *             1.0.6 - 07/11/2003 - G.R-P                                 * */
+/* *             - added conditionals zlib and jpeg property accessors      * */
+/* *             1.0.6 - 07/14/2003 - G.R-P                                 * */
+/* *             - added conditionals around various unused functions       * */
+/* *                                                                        * */
+/* *             1.0.7 - 11/27/2003 - R.A                                   * */
+/* *             - added CANVAS_RGB565 and CANVAS_BGR565                    * */
+/* *             1.0.7 - 12/06/2003 - R.A                                   * */
+/* *             - added CANVAS_RGBA565 and CANVAS_BGRA565                  * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *             1.0.7 - 03/07/2004 - G.R-P.                                * */
+/* *             - put gamma, cms-related functions inside #ifdef           * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/02/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/18/2004 - G.R-P.                                * */
+/* *             - added some MNG_SUPPORT_WRITE conditionals                * */
+/* *             1.0.9 - 10/03/2004 - G.Juyn                                * */
+/* *             - added function to retrieve current FRAM delay            * */
+/* *             1.0.9 - 10/14/2004 - G.Juyn                                * */
+/* *             - added bgr565_a8 canvas-style (thanks to J. Elvander)     * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* *             1.0.10 - 03/07/2006 - (thanks to W. Manthey)               * */
+/* *             - added CANVAS_RGB555 and CANVAS_BGR555                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_objects.h"
+#include "libmng_memory.h"
+#include "libmng_cms.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Property set functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_userdata (mng_handle hHandle,
+                                       mng_ptr    pUserdata)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_USERDATA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->pUserdata = pUserdata;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_USERDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_canvasstyle (mng_handle hHandle,
+                                          mng_uint32 iStyle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_CANVASSTYLE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  switch (iStyle)
+  {
+#ifndef MNG_SKIPCANVAS_RGB8
+    case MNG_CANVAS_RGB8    : break;
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA8
+    case MNG_CANVAS_RGBA8   : break;
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA8_PM
+    case MNG_CANVAS_RGBA8_PM: break;
+#endif
+#ifndef MNG_SKIPCANVAS_ARGB8
+    case MNG_CANVAS_ARGB8   : break;
+#endif
+#ifndef MNG_SKIPCANVAS_ARGB8_PM
+    case MNG_CANVAS_ARGB8_PM: break;
+#endif
+#ifndef MNG_SKIPCANVAS_RGB8_A8
+    case MNG_CANVAS_RGB8_A8 : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGR8
+    case MNG_CANVAS_BGR8    : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGRX8
+    case MNG_CANVAS_BGRX8   : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA8
+    case MNG_CANVAS_BGRA8   : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA8_PM
+    case MNG_CANVAS_BGRA8_PM: break;
+#endif
+#ifndef MNG_SKIPCANVAS_ABGR8
+    case MNG_CANVAS_ABGR8   : break;
+#endif
+#ifndef MNG_SKIPCANVAS_ABGR8_PM
+    case MNG_CANVAS_ABGR8_PM: break;
+#endif
+#ifndef MNG_SKIPCANVAS_RGB565
+    case MNG_CANVAS_RGB565  : break;
+#endif
+#ifndef MNG_SKIPCANVAS_RGBA565
+    case MNG_CANVAS_RGBA565 : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565
+    case MNG_CANVAS_BGR565  : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGRA565
+    case MNG_CANVAS_BGRA565 : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565_A8
+    case MNG_CANVAS_BGR565_A8 : break;
+#endif
+#ifndef MNG_SKIPCANVAS_RGB555
+    case MNG_CANVAS_RGB555  : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGR555
+    case MNG_CANVAS_BGR555  : break;
+#endif
+/*    case MNG_CANVAS_RGB16   : break; */
+/*    case MNG_CANVAS_RGBA16  : break; */
+/*    case MNG_CANVAS_ARGB16  : break; */
+/*    case MNG_CANVAS_BGR16   : break; */
+/*    case MNG_CANVAS_BGRA16  : break; */
+/*    case MNG_CANVAS_ABGR16  : break; */
+/*    case MNG_CANVAS_INDEX8  : break; */
+/*    case MNG_CANVAS_INDEXA8 : break; */
+/*    case MNG_CANVAS_AINDEX8 : break; */
+/*    case MNG_CANVAS_GRAY8   : break; */
+/*    case MNG_CANVAS_GRAY16  : break; */
+/*    case MNG_CANVAS_GRAYA8  : break; */
+/*    case MNG_CANVAS_GRAYA16 : break; */
+/*    case MNG_CANVAS_AGRAY8  : break; */
+/*    case MNG_CANVAS_AGRAY16 : break; */
+/*    case MNG_CANVAS_DX15    : break; */
+/*    case MNG_CANVAS_DX16    : break; */
+    default                 : { MNG_ERROR (((mng_datap)hHandle), MNG_INVALIDCNVSTYLE) };
+  }
+
+  ((mng_datap)hHandle)->iCanvasstyle = iStyle;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_CANVASSTYLE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_bkgdstyle (mng_handle hHandle,
+                                        mng_uint32 iStyle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_BKGDSTYLE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  switch (iStyle)                      /* alpha-modes not supported */
+  {
+#ifndef MNG_SKIPCANVAS_RGB8
+    case MNG_CANVAS_RGB8    : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGR8
+    case MNG_CANVAS_BGR8    : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGRX8
+    case MNG_CANVAS_BGRX8   : break;
+#endif
+#ifndef MNG_SKIPCANVAS_RGB565
+    case MNG_CANVAS_RGB565  : break;
+#endif
+#ifndef MNG_SKIPCANVAS_BGR565
+    case MNG_CANVAS_BGR565  : break;
+#endif
+/*    case MNG_CANVAS_RGB16   : break; */
+/*    case MNG_CANVAS_BGR16   : break; */
+/*    case MNG_CANVAS_INDEX8  : break; */
+/*    case MNG_CANVAS_GRAY8   : break; */
+/*    case MNG_CANVAS_GRAY16  : break; */
+/*    case MNG_CANVAS_DX15    : break; */
+/*    case MNG_CANVAS_DX16    : break; */
+    default                 : MNG_ERROR (((mng_datap)hHandle), MNG_INVALIDCNVSTYLE);
+  }
+
+  ((mng_datap)hHandle)->iBkgdstyle = iStyle;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_BKGDSTYLE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_bgcolor (mng_handle hHandle,
+                                      mng_uint16 iRed,
+                                      mng_uint16 iGreen,
+                                      mng_uint16 iBlue)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_BGCOLOR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iBGred   = iRed;
+  ((mng_datap)hHandle)->iBGgreen = iGreen;
+  ((mng_datap)hHandle)->iBGblue  = iBlue;
+  ((mng_datap)hHandle)->bUseBKGD = MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_BGCOLOR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_usebkgd (mng_handle hHandle,
+                                      mng_bool   bUseBKGD)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_USEBKGD, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->bUseBKGD = bUseBKGD;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_USEBKGD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_storechunks (mng_handle hHandle,
+                                          mng_bool   bStorechunks)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_STORECHUNKS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->bStorechunks = bStorechunks;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_STORECHUNKS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_sectionbreaks (mng_handle hHandle,
+                                            mng_bool   bSectionbreaks)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SECTIONBREAKS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->bSectionbreaks = bSectionbreaks;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SECTIONBREAKS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_cacheplayback (mng_handle hHandle,
+                                            mng_bool   bCacheplayback)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_CACHEPLAYBACK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  if (((mng_datap)hHandle)->bHasheader)
+    MNG_ERROR (((mng_datap)hHandle), MNG_FUNCTIONINVALID);
+
+  ((mng_datap)hHandle)->bCacheplayback = bCacheplayback;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_CACHEPLAYBACK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_doprogressive (mng_handle hHandle,
+                                            mng_bool   bDoProgressive)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DOPROGRESSIVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  ((mng_datap)hHandle)->bDoProgressive = bDoProgressive;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DOPROGRESSIVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_crcmode (mng_handle hHandle,
+                                      mng_uint32 iCrcmode)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_CRCMODE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  ((mng_datap)hHandle)->iCrcmode = iCrcmode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_CRCMODE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_set_srgb (mng_handle hHandle,
+                                   mng_bool   bIssRGB)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGB, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->bIssRGB = bIssRGB;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_retcode MNG_DECL mng_set_outputprofile (mng_handle hHandle,
+                                            mng_pchar  zFilename)
+{
+#ifdef MNG_INCLUDE_LCMS
+  mng_datap pData;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_OUTPUTPROFILE, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_LCMS
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;          /* address the structure */
+
+  if (pData->hProf2)                   /* previously defined ? */
+    mnglcms_freeprofile (pData->hProf2);
+                                       /* allocate new CMS profile handle */
+  pData->hProf2 = mnglcms_createfileprofile (zFilename);
+
+  if (!pData->hProf2)                  /* handle error ? */
+    MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+#endif /* MNG_INCLUDE_LCMS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_OUTPUTPROFILE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_SKIPCHUNK_iCCP
+mng_retcode MNG_DECL mng_set_outputprofile2 (mng_handle hHandle,
+                                             mng_uint32 iProfilesize,
+                                             mng_ptr    pProfile)
+{
+#ifdef MNG_INCLUDE_LCMS
+  mng_datap pData;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_OUTPUTPROFILE2, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_LCMS
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;          /* address the structure */
+
+  if (pData->hProf2)                   /* previously defined ? */
+    mnglcms_freeprofile (pData->hProf2);
+                                       /* allocate new CMS profile handle */
+  pData->hProf2 = mnglcms_creatememprofile (iProfilesize, pProfile);
+
+  if (!pData->hProf2)                  /* handle error ? */
+    MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+#endif /* MNG_INCLUDE_LCMS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_OUTPUTPROFILE2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_outputsrgb (mng_handle hHandle)
+{
+#ifdef MNG_INCLUDE_LCMS
+  mng_datap pData;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_OUTPUTSRGB, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_LCMS
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;          /* address the structure */
+
+  if (pData->hProf2)                   /* previously defined ? */
+    mnglcms_freeprofile (pData->hProf2);
+                                       /* allocate new CMS profile handle */
+  pData->hProf2 = mnglcms_createsrgbprofile ();
+
+  if (!pData->hProf2)                  /* handle error ? */
+    MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+#endif /* MNG_INCLUDE_LCMS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_OUTPUTSRGB, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_set_srgbprofile (mng_handle hHandle,
+                                          mng_pchar  zFilename)
+{
+#ifdef MNG_INCLUDE_LCMS
+  mng_datap pData;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGBPROFILE2, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_LCMS
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;          /* address the structure */
+
+  if (pData->hProf3)                   /* previously defined ? */
+    mnglcms_freeprofile (pData->hProf3);
+                                       /* allocate new CMS profile handle */
+  pData->hProf3 = mnglcms_createfileprofile (zFilename);
+
+  if (!pData->hProf3)                  /* handle error ? */
+    MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+#endif /* MNG_INCLUDE_LCMS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGBPROFILE2, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_set_srgbprofile2 (mng_handle hHandle,
+                                           mng_uint32 iProfilesize,
+                                           mng_ptr    pProfile)
+{
+#ifdef MNG_INCLUDE_LCMS
+  mng_datap pData;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGBPROFILE, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_LCMS
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;          /* address the structure */
+
+  if (pData->hProf3)                   /* previously defined ? */
+    mnglcms_freeprofile (pData->hProf3);
+                                       /* allocate new CMS profile handle */
+  pData->hProf3 = mnglcms_creatememprofile (iProfilesize, pProfile);
+
+  if (!pData->hProf3)                  /* handle error ? */
+    MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+#endif /* MNG_INCLUDE_LCMS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGBPROFILE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_srgbimplicit (mng_handle hHandle)
+{
+#ifdef MNG_INCLUDE_LCMS
+  mng_datap pData;
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGBIMPLICIT, MNG_LC_START);
+#endif
+
+#ifdef MNG_INCLUDE_LCMS
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;          /* address the structure */
+
+  if (pData->hProf3)                   /* previously defined ? */
+    mnglcms_freeprofile (pData->hProf3);
+                                       /* allocate new CMS profile handle */
+  pData->hProf3 = mnglcms_createsrgbprofile ();
+
+  if (!pData->hProf3)                  /* handle error ? */
+    MNG_ERRORL (pData, MNG_LCMS_NOHANDLE);
+#endif /* MNG_INCLUDE_LCMS */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SRGBIMPLICIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_retcode MNG_DECL mng_set_viewgamma (mng_handle hHandle,
+                                        mng_float  dGamma)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_VIEWGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->dViewgamma = dGamma;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_VIEWGAMMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_displaygamma (mng_handle hHandle,
+                                           mng_float  dGamma)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DISPLAYGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->dDisplaygamma = dGamma;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DISPLAYGAMMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_dfltimggamma (mng_handle hHandle,
+                                           mng_float  dGamma)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DFLTIMGGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->dDfltimggamma = dGamma;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DFLTIMGGAMMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_retcode MNG_DECL mng_set_viewgammaint (mng_handle hHandle,
+                                           mng_uint32 iGamma)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_VIEWGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->dViewgamma = (mng_float)iGamma / 100000;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_VIEWGAMMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_displaygammaint (mng_handle hHandle,
+                                              mng_uint32 iGamma)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DISPLAYGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->dDisplaygamma = (mng_float)iGamma / 100000;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DISPLAYGAMMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DFLT_INFO
+mng_retcode MNG_DECL mng_set_dfltimggammaint (mng_handle hHandle,
+                                              mng_uint32 iGamma)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DFLTIMGGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->dDfltimggamma = (mng_float)iGamma / 100000;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_DFLTIMGGAMMA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIP_MAXCANVAS
+mng_retcode MNG_DECL mng_set_maxcanvaswidth (mng_handle hHandle,
+                                             mng_uint32 iMaxwidth)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_MAXCANVASWIDTH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iMaxwidth = iMaxwidth;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_MAXCANVASWIDTH, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_maxcanvasheight (mng_handle hHandle,
+                                              mng_uint32 iMaxheight)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_MAXCANVASHEIGHT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iMaxheight = iMaxheight;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_MAXCANVASHEIGHT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_set_maxcanvassize (mng_handle hHandle,
+                                            mng_uint32 iMaxwidth,
+                                            mng_uint32 iMaxheight)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_MAXCANVASSIZE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iMaxwidth  = iMaxwidth;
+  ((mng_datap)hHandle)->iMaxheight = iMaxheight;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_MAXCANVASSIZE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_zlib_level (mng_handle hHandle,
+                                         mng_int32  iZlevel)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_LEVEL, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iZlevel = iZlevel;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_LEVEL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_zlib_method (mng_handle hHandle,
+                                          mng_int32  iZmethod)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_METHOD, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iZmethod = iZmethod;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_METHOD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_zlib_windowbits (mng_handle hHandle,
+                                              mng_int32  iZwindowbits)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_WINDOWBITS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iZwindowbits = iZwindowbits;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_WINDOWBITS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_zlib_memlevel (mng_handle hHandle,
+                                            mng_int32  iZmemlevel)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_MEMLEVEL, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iZmemlevel = iZmemlevel;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_MEMLEVEL, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_zlib_strategy (mng_handle hHandle,
+                                            mng_int32  iZstrategy)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_STRATEGY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iZstrategy = iZstrategy;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_STRATEGY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_zlib_maxidat (mng_handle hHandle,
+                                           mng_uint32 iMaxIDAT)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_MAXIDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iMaxIDAT = iMaxIDAT;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_ZLIB_MAXIDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_jpeg_dctmethod (mng_handle        hHandle,
+                                             mngjpeg_dctmethod eJPEGdctmethod)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_DCTMETHOD, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->eJPEGdctmethod = eJPEGdctmethod;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_DCTMETHOD, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_jpeg_quality (mng_handle hHandle,
+                                           mng_int32  iJPEGquality)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_QUALITY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iJPEGquality = iJPEGquality;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_QUALITY, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_jpeg_smoothing (mng_handle hHandle,
+                                             mng_int32  iJPEGsmoothing)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_SMOOTHING, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iJPEGsmoothing = iJPEGsmoothing;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_SMOOTHING, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_jpeg_progressive (mng_handle hHandle,
+                                               mng_bool   bJPEGprogressive)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_PROGRESSIVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->bJPEGcompressprogr = bJPEGprogressive;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_PROGRESSIVE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_jpeg_optimized (mng_handle hHandle,
+                                             mng_bool   bJPEGoptimized)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_OPTIMIZED, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->bJPEGcompressopt = bJPEGoptimized;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_OPTIMIZED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+#ifdef MNG_SUPPORT_WRITE
+mng_retcode MNG_DECL mng_set_jpeg_maxjdat (mng_handle hHandle,
+                                           mng_uint32 iMaxJDAT)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_MAXJDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iMaxJDAT = iMaxJDAT;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_JPEG_MAXJDAT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_WRITE */
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_retcode MNG_DECL mng_set_suspensionmode (mng_handle hHandle,
+                                             mng_bool   bSuspensionmode)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SUSPENSIONMODE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  if (((mng_datap)hHandle)->bReading)  /* we must NOT be reading !!! */
+    MNG_ERROR ((mng_datap)hHandle, MNG_FUNCTIONINVALID);
+
+  ((mng_datap)hHandle)->bSuspensionmode = bSuspensionmode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SUSPENSIONMODE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_set_speed (mng_handle    hHandle,
+                                    mng_speedtype iSpeed)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SPEED, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  ((mng_datap)hHandle)->iSpeed = iSpeed;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_SET_SPEED, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* *  Property get functions                                                * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+mng_ptr MNG_DECL mng_get_userdata (mng_handle hHandle)
+{                            /* no tracing in here to prevent recursive calls */
+  MNG_VALIDHANDLEX (hHandle)
+  return ((mng_datap)hHandle)->pUserdata;
+}
+
+/* ************************************************************************** */
+
+mng_imgtype MNG_DECL mng_get_sigtype (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SIGTYPE, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_it_unknown;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SIGTYPE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->eSigtype;
+}
+
+/* ************************************************************************** */
+
+mng_imgtype MNG_DECL mng_get_imagetype (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGETYPE, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_it_unknown;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGETYPE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->eImagetype;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_imagewidth (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGEWIDTH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGEWIDTH, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iWidth;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_imageheight (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGEWIDTH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGEHEIGHT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iHeight;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_ticks (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TICKS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TICKS, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iTicks;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_framecount (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_FRAMECOUNT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_FRAMECOUNT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iFramecount;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_layercount (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_LAYERCOUNT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_LAYERCOUNT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iLayercount;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_playtime (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_PLAYTIME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_PLAYTIME, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iPlaytime;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_simplicity (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SIMPLICITY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SIMPLICITY, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iSimplicity;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_bitdepth (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_BITDEPTH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+  if (((mng_datap)hHandle)->eImagetype == mng_it_png)
+    iRslt = ((mng_datap)hHandle)->iBitdepth;
+  else
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRimgbitdepth;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_BITDEPTH, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_colortype (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_COLORTYPE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+  if (((mng_datap)hHandle)->eImagetype == mng_it_png)
+    iRslt = ((mng_datap)hHandle)->iColortype;
+  else
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRcolortype;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_COLORTYPE, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_compression (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_COMPRESSION, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+  if (((mng_datap)hHandle)->eImagetype == mng_it_png)
+    iRslt = ((mng_datap)hHandle)->iCompression;
+  else
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRimgcompression;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_COMPRESSION, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_filter (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_FILTER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+  if (((mng_datap)hHandle)->eImagetype == mng_it_png)
+    iRslt = ((mng_datap)hHandle)->iFilter;
+  else
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_FILTER, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_interlace (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_INTERLACE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+  if (((mng_datap)hHandle)->eImagetype == mng_it_png)
+    iRslt = ((mng_datap)hHandle)->iInterlace;
+  else
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRimginterlace;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_INTERLACE, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_alphabitdepth (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHABITDEPTH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRalphabitdepth;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHABITDEPTH, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_uint8 MNG_DECL mng_get_refreshpass (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+  mng_datap pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_REFRESHPASS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+  pData = (mng_datap)hHandle;
+                                       /* for PNG we know the exact pass */
+  if ((pData->eImagetype == mng_it_png) && (pData->iPass >= 0))
+    iRslt = pData->iPass;
+#ifdef MNG_INCLUDE_JNG
+  else                                 /* for JNG we'll fake it... */
+  if ((pData->eImagetype == mng_it_jng) &&
+      (pData->bJPEGhasheader) && (pData->bJPEGdecostarted) &&
+      (pData->bJPEGprogressive))
+  {
+    if (pData->pJPEGdinfo->input_scan_number <= 1)
+      iRslt = 0;                       /* first pass (I think...) */
+    else
+    if (jpeg_input_complete (pData->pJPEGdinfo))
+      iRslt = 7;                       /* input complete; aka final pass */
+    else
+      iRslt = 3;                       /* anything between 0 and 7 will do */
+
+  }
+#endif
+  else
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_REFRESHPASS, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+mng_uint8 MNG_DECL mng_get_alphacompression (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHACOMPRESSION, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRalphacompression;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHACOMPRESSION, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_alphafilter (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHAFILTER, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRalphafilter;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHAFILTER, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_alphainterlace (mng_handle hHandle)
+{
+  mng_uint8 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHAINTERLACE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_INCLUDE_JNG
+  if (((mng_datap)hHandle)->eImagetype == mng_it_jng)
+    iRslt = ((mng_datap)hHandle)->iJHDRalphainterlace;
+  else
+#endif
+    iRslt = 0;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHAINTERLACE, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+
+/* ************************************************************************** */
+
+mng_uint8 MNG_DECL mng_get_alphadepth (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHADEPTH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ALPHADEPTH, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iAlphadepth;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_canvasstyle (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CANVASSTYLE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CANVASSTYLE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iCanvasstyle;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_bkgdstyle (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_BKGDSTYLE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_BKGDSTYLE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iBkgdstyle;
+}
+
+/* ************************************************************************** */
+
+mng_retcode MNG_DECL mng_get_bgcolor (mng_handle  hHandle,
+                                      mng_uint16* iRed,
+                                      mng_uint16* iGreen,
+                                      mng_uint16* iBlue)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GET_BGCOLOR, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+  *iRed   = ((mng_datap)hHandle)->iBGred;
+  *iGreen = ((mng_datap)hHandle)->iBGgreen;
+  *iBlue  = ((mng_datap)hHandle)->iBGblue;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (((mng_datap)hHandle), MNG_FN_GET_BGCOLOR, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_bool MNG_DECL mng_get_usebkgd (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_USEBKGD, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_USEBKGD, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bUseBKGD;
+}
+
+/* ************************************************************************** */
+
+mng_bool MNG_DECL mng_get_storechunks (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_STORECHUNKS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_STORECHUNKS, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bStorechunks;
+}
+
+/* ************************************************************************** */
+
+mng_bool MNG_DECL mng_get_sectionbreaks (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_SECTIONBREAKS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_SECTIONBREAKS, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bSectionbreaks;
+}
+
+/* ************************************************************************** */
+
+mng_bool MNG_DECL mng_get_cacheplayback (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_CACHEPLAYBACK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_CACHEPLAYBACK, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bCacheplayback;
+}
+
+/* ************************************************************************** */
+
+mng_bool MNG_DECL mng_get_doprogressive (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_DOPROGRESSIVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_DOPROGRESSIVE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bDoProgressive;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_crcmode (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_CRCMODE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_CRCMODE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iCrcmode;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_bool MNG_DECL mng_get_srgb (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_SRGB, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEB (((mng_datap)hHandle), MNG_FN_GET_SRGB, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bIssRGB;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_float MNG_DECL mng_get_viewgamma (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_VIEWGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_VIEWGAMMA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->dViewgamma;
+}
+#endif
+
+/* ************************************************************************** */
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_float MNG_DECL mng_get_displaygamma (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DISPLAYGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DISPLAYGAMMA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->dDisplaygamma;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DFLT_INFO
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_float MNG_DECL mng_get_dfltimggamma (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DFLTIMGGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DFLTIMGGAMMA, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->dDfltimggamma;
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_uint32 MNG_DECL mng_get_viewgammaint (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_VIEWGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_VIEWGAMMA, MNG_LC_END);
+#endif
+
+  return (mng_uint32)(((mng_datap)hHandle)->dViewgamma * 100000);
+}
+#endif
+
+/* ************************************************************************** */
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_uint32 MNG_DECL mng_get_displaygammaint (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DISPLAYGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DISPLAYGAMMA, MNG_LC_END);
+#endif
+
+  return (mng_uint32)(((mng_datap)hHandle)->dDisplaygamma * 100000);
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_NO_DFLT_INFO
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+mng_uint32 MNG_DECL mng_get_dfltimggammaint (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DFLTIMGGAMMA, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_DFLTIMGGAMMA, MNG_LC_END);
+#endif
+
+  return (mng_uint32)(((mng_datap)hHandle)->dDfltimggamma * 100000);
+}
+#endif
+#endif
+
+/* ************************************************************************** */
+
+#ifndef MNG_SKIP_MAXCANVAS
+mng_uint32 MNG_DECL mng_get_maxcanvaswidth (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_MAXCANVASWIDTH, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_MAXCANVASWIDTH, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iMaxwidth;
+}
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_maxcanvasheight (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_MAXCANVASHEIGHT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_MAXCANVASHEIGHT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iMaxheight;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+mng_int32 MNG_DECL mng_get_zlib_level (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_LEVEL, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_LEVEL, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iZlevel;
+}
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+mng_int32 MNG_DECL mng_get_zlib_method (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_METHOD, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_METHOD, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iZmethod;
+}
+
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+mng_int32 MNG_DECL mng_get_zlib_windowbits (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_WINDOWBITS, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_WINDOWBITS, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iZwindowbits;
+}
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+mng_int32 MNG_DECL mng_get_zlib_memlevel (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_MEMLEVEL, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_MEMLEVEL, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iZmemlevel;
+}
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+mng_int32 MNG_DECL mng_get_zlib_strategy (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_STRATEGY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_STRATEGY, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iZstrategy;
+}
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+#ifdef MNG_ACCESS_ZLIB
+mng_uint32 MNG_DECL mng_get_zlib_maxidat (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_MAXIDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_ZLIB_MAXIDAT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iMaxIDAT;
+}
+#endif /* MNG_ACCESS_ZLIB */
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+mngjpeg_dctmethod MNG_DECL mng_get_jpeg_dctmethod (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_DCTMETHOD, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return JDCT_ISLOW;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_DCTMETHOD, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->eJPEGdctmethod;
+}
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+mng_int32 MNG_DECL mng_get_jpeg_quality (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_QUALITY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_QUALITY, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iJPEGquality;
+}
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+mng_int32 MNG_DECL mng_get_jpeg_smoothing (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_SMOOTHING, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_SMOOTHING, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iJPEGsmoothing;
+}
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+mng_bool MNG_DECL mng_get_jpeg_progressive (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_PROGRESSIVE, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_PROGRESSIVE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bJPEGcompressprogr;
+}
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+mng_bool MNG_DECL mng_get_jpeg_optimized (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_OPTIMIZED, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_OPTIMIZED, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bJPEGcompressopt;
+}
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+#ifdef MNG_ACCESS_JPEG
+mng_uint32 MNG_DECL mng_get_jpeg_maxjdat (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_MAXJDAT, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_JPEG_MAXJDAT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iMaxJDAT;
+}
+#endif /* MNG_ACCESS_JPEG */
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_bool MNG_DECL mng_get_suspensionmode (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SUSPENSIONMODE, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SUSPENSIONMODE, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bSuspensionmode;
+}
+#endif /* MNG_SUPPORT_READ */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_speedtype MNG_DECL mng_get_speed (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SPEED, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_SPEED, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iSpeed;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+mng_uint32 MNG_DECL mng_get_imagelevel (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGELEVEL, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLEX (hHandle)
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_IMAGELEVEL, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iImagelevel;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_get_lastbackchunk (mng_handle  hHandle,
+                                            mng_uint16* iRed,
+                                            mng_uint16* iGreen,
+                                            mng_uint16* iBlue,
+                                            mng_uint8*  iMandatory)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_LASTBACKCHUNK, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  if (((mng_datap)hHandle)->eImagetype != mng_it_mng)
+    MNG_ERROR (((mng_datap)hHandle), MNG_FUNCTIONINVALID);
+
+  *iRed       = ((mng_datap)hHandle)->iBACKred;
+  *iGreen     = ((mng_datap)hHandle)->iBACKgreen;
+  *iBlue      = ((mng_datap)hHandle)->iBACKblue;
+  *iMandatory = ((mng_datap)hHandle)->iBACKmandatory;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_LASTBACKCHUNK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode MNG_DECL mng_get_lastseekname (mng_handle hHandle,
+                                           mng_pchar  zSegmentname)
+{
+  mng_datap pData;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_LASTSEEKNAME, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;
+                                       /* only allowed for MNG ! */
+  if (pData->eImagetype != mng_it_mng)
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  if (pData->pLastseek)                /* is there a last SEEK ? */
+  {
+    mng_ani_seekp pSEEK = (mng_ani_seekp)pData->pLastseek;
+
+    if (pSEEK->iSegmentnamesize)       /* copy the name if there is one */
+      MNG_COPY (zSegmentname, pSEEK->zSegmentname, pSEEK->iSegmentnamesize);
+
+    *(((mng_uint8p)zSegmentname) + pSEEK->iSegmentnamesize) = 0;
+  }
+  else
+  {                                    /* return an empty string */
+    *((mng_uint8p)zSegmentname) = 0;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_LASTSEEKNAME, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_uint32 MNG_DECL mng_get_currframdelay (mng_handle hHandle)
+{
+  mng_datap  pData;
+  mng_uint32 iRslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRFRAMDELAY, MNG_LC_START);
+#endif
+
+  MNG_VALIDHANDLE (hHandle)
+
+  pData = (mng_datap)hHandle;
+                                       /* only allowed for MNG ! */
+  if (pData->eImagetype != mng_it_mng)
+    MNG_ERROR (pData, MNG_FUNCTIONINVALID);
+
+  iRslt = pData->iFramedelay;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRFRAMDELAY, MNG_LC_END);
+#endif
+
+  return iRslt;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_uint32 MNG_DECL mng_get_starttime (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_STARTTIME, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_STARTTIME, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iStarttime;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_uint32 MNG_DECL mng_get_runtime (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_RUNTIME, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_RUNTIME, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iRuntime;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_CURRENT_INFO
+mng_uint32 MNG_DECL mng_get_currentframe (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRENTFRAME, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRENTFRAME, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iFrameseq;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_CURRENT_INFO
+mng_uint32 MNG_DECL mng_get_currentlayer (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRENTLAYER, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRENTLAYER, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iLayerseq;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_CURRENT_INFO
+mng_uint32 MNG_DECL mng_get_currentplaytime (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRENTPLAYTIME, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_CURRENTPLAYTIME, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iFrametime;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_CURRENT_INFO
+mng_uint32 MNG_DECL mng_get_totalframes (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TOTALFRAMES, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TOTALFRAMES, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iTotalframes;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_CURRENT_INFO
+mng_uint32 MNG_DECL mng_get_totallayers (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TOTALLAYERS, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TOTALLAYERS, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iTotallayers;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+#ifndef MNG_NO_CURRENT_INFO
+mng_uint32 MNG_DECL mng_get_totalplaytime (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TOTALPLAYTIME, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return mng_st_normal;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_GET_TOTALPLAYTIME, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->iTotalplaytime;
+}
+#endif
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+mng_bool MNG_DECL mng_status_error (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_ERROR, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_ERROR, MNG_LC_END);
+#endif
+
+  return (mng_bool)((mng_datap)hHandle)->iErrorcode;
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_bool MNG_DECL mng_status_reading (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_READING, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_READING, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bReading;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_READ
+mng_bool MNG_DECL mng_status_suspendbreak (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_SUSPENDBREAK, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_SUSPENDBREAK, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bSuspended;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_WRITE
+mng_bool MNG_DECL mng_status_creating (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_CREATING, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_CREATING, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bCreating;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_WRITE
+mng_bool MNG_DECL mng_status_writing (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_WRITING, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_WRITING, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bWriting;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_bool MNG_DECL mng_status_displaying (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_DISPLAYING, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_DISPLAYING, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bDisplaying;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_bool MNG_DECL mng_status_running (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_RUNNING, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_RUNNING, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bRunning;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_bool MNG_DECL mng_status_timerbreak (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_TIMERBREAK, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_TIMERBREAK, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bTimerset;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+mng_bool MNG_DECL mng_status_dynamic (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_DYNAMIC, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_DYNAMIC, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bDynamic;
+}
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DYNAMICMNG
+mng_bool MNG_DECL mng_status_runningevent (mng_handle hHandle)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_RUNNINGEVENT, MNG_LC_START);
+#endif
+
+  if ((hHandle == 0) || (((mng_datap)hHandle)->iMagic != MNG_MAGIC))
+    return MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACEX (((mng_datap)hHandle), MNG_FN_STATUS_RUNNINGEVENT, MNG_LC_END);
+#endif
+
+  return ((mng_datap)hHandle)->bRunningevent;
+}
+#endif
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_read.c b/src/3rdparty/libmng/libmng_read.c
new file mode 100644
index 0000000..c922e19
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_read.c
@@ -0,0 +1,1369 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_read.c             copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Read logic (implementation)                                * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the high-level read logic                * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - added callback error-reporting support                   * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/19/2000 - G.Juyn                                * */
+/* *             - cleaned up some code regarding mixed support             * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - added support for JNG                                    * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - fixed up punctuation (contribution by Tim Rowley)        * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - changed progressive-display processing                   * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - changed read-processing for improved I/O-suspension      * */
+/* *             0.9.1 - 07/14/2000 - G.Juyn                                * */
+/* *             - changed EOF processing behavior                          * */
+/* *             0.9.1 - 07/14/2000 - G.Juyn                                * */
+/* *             - changed default readbuffer size from 1024 to 4200        * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/27/2000 - G.Juyn                                * */
+/* *             - B110320 - fixed GCC warning about mix-sized pointer math * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - B110546 - fixed for improperly returning UNEXPECTEDEOF   * */
+/* *             0.9.2 - 08/04/2000 - G.Juyn                                * */
+/* *             - B111096 - fixed large-buffer read-suspension             * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - removed test-MaGN                                        * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added support for JDAA                                   * */
+/* *                                                                        * */
+/* *             0.9.5 - 01/23/2001 - G.Juyn                                * */
+/* *             - fixed timing-problem with switching framing_modes        * */
+/* *                                                                        * */
+/* *             1.0.4 - 06/22/2002 - G.Juyn                                * */
+/* *             - B495443 - incorrect suspend check in read_databuffer     * */
+/* *                                                                        * */
+/* *             1.0.5 - 07/04/2002 - G.Juyn                                * */
+/* *             - added errorcode for extreme chunk-sizes                  * */
+/* *             1.0.5 - 07/08/2002 - G.Juyn                                * */
+/* *             - B578572 - removed eMNGma hack (thanks Dimitri!)          * */
+/* *             1.0.5 - 07/16/2002 - G.Juyn                                * */
+/* *             - B581625 - large chunks fail with suspension reads        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             - added HLAPI function to copy chunks                      * */
+/* *             1.0.5 - 09/16/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *                                                                        * */
+/* *             1.0.6 - 05/25/2003 - G.R-P                                 * */
+/* *             - added MNG_SKIPCHUNK_cHNK footprint optimizations         * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added MNG_NO_DELTA_PNG reduction                         * */
+/* *             - skip additional code when MNG_INCLUDE_JNG is not enabled * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *             1.0.6 - 08/17/2003 - G.R-P                                 * */
+/* *             - added conditionals around non-VLC chunk support          * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/08/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *             1.0.8 - 04/11/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *             1.0.8 - 07/06/2004 - G.R-P                                 * */
+/* *             - defend against using undefined closestream function      * */
+/* *             1.0.8 - 07/28/2004 - G.R-P                                 * */
+/* *             - added check for extreme chunk-lengths                    * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/16/2004 - G.Juyn                                * */
+/* *             - fixed chunk pushing mechanism                            * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKINITFREE             * */
+/* *             1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKASSIGN               * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKREADER               * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *             1.0.9 - 12/31/2004 - G.R-P                                 * */
+/* *             - removed stray characters from #ifdef directive           * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_objects.h"
+#include "libmng_object_prc.h"
+#include "libmng_chunks.h"
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+#include "libmng_chunk_descr.h"
+#endif
+#include "libmng_chunk_prc.h"
+#include "libmng_chunk_io.h"
+#include "libmng_display.h"
+#include "libmng_read.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_READ_PROCS
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_eof (mng_datap pData)
+{
+  if (!pData->bEOF)                    /* haven't closed the stream yet ? */
+  {
+    pData->bEOF = MNG_TRUE;            /* now we do! */
+
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+    if (pData->fClosestream && !pData->fClosestream ((mng_handle)pData))
+    {
+      MNG_ERROR (pData, MNG_APPIOERROR);
+    }
+#endif
+  }
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_release_pushdata (mng_datap pData)
+{
+  mng_pushdatap pFirst  = pData->pFirstpushdata;
+  mng_pushdatap pNext   = pFirst->pNext;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RELEASE_PUSHDATA, MNG_LC_START);
+#endif
+
+  pData->pFirstpushdata = pNext;       /* next becomes the first */
+
+  if (!pNext)                          /* no next? => no last! */
+    pData->pLastpushdata = MNG_NULL;
+                                       /* buffer owned and release callback defined? */
+  if ((pFirst->bOwned) && (pData->fReleasedata))
+    pData->fReleasedata ((mng_handle)pData, pFirst->pData, pFirst->iLength);
+  else                                 /* otherwise use internal free mechanism */
+    MNG_FREEX (pData, pFirst->pData, pFirst->iLength);
+                                       /* and free it */
+  MNG_FREEX (pData, pFirst, sizeof(mng_pushdata));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RELEASE_PUSHDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_release_pushchunk (mng_datap pData)
+{
+  mng_pushdatap pFirst  = pData->pFirstpushchunk;
+  mng_pushdatap pNext   = pFirst->pNext;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RELEASE_PUSHCHUNK, MNG_LC_START);
+#endif
+
+  pData->pFirstpushchunk = pNext;      /* next becomes the first */
+
+  if (!pNext)                          /* no next? => no last! */
+    pData->pLastpushchunk = MNG_NULL;
+                                       /* buffer owned and release callback defined? */
+  if ((pFirst->bOwned) && (pData->fReleasedata))
+    pData->fReleasedata ((mng_handle)pData, pFirst->pData, pFirst->iLength);
+  else                                 /* otherwise use internal free mechanism */
+    MNG_FREEX (pData, pFirst->pData, pFirst->iLength);
+                                       /* and free it */
+  MNG_FREEX (pData, pFirst, sizeof(mng_pushdata));
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_RELEASE_PUSHCHUNK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode read_data (mng_datap    pData,
+                                 mng_uint8p   pBuf,
+                                 mng_uint32   iSize,
+                                 mng_uint32 * iRead)
+{
+  mng_retcode   iRetcode;
+  mng_uint32    iTempsize = iSize;
+  mng_uint8p    pTempbuf  = pBuf;
+  mng_pushdatap pPush     = pData->pFirstpushdata;
+  mng_uint32    iPushsize = 0;
+  *iRead                  = 0;         /* nothing yet */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DATA, MNG_LC_START);
+#endif
+
+  while (pPush)                        /* calculate size of pushed data */
+  {
+    iPushsize += pPush->iRemaining;
+    pPush      = pPush->pNext;
+  }
+
+  if (iTempsize <= iPushsize)          /* got enough push data? */
+  {
+    while (iTempsize)
+    {
+      pPush = pData->pFirstpushdata;
+                                       /* enough data remaining in this buffer? */
+      if (pPush->iRemaining <= iTempsize)
+      {                                /* no: then copy what we've got */
+        MNG_COPY (pTempbuf, pPush->pDatanext, pPush->iRemaining);
+                                       /* move pointers & lengths */
+        pTempbuf  += pPush->iRemaining;
+        *iRead    += pPush->iRemaining;
+        iTempsize -= pPush->iRemaining;
+                                       /* release the depleted buffer */
+        iRetcode = mng_release_pushdata (pData);
+        if (iRetcode)
+          return iRetcode;
+      }
+      else
+      {                                /* copy the needed bytes */
+        MNG_COPY (pTempbuf, pPush->pDatanext, iTempsize);
+                                       /* move pointers & lengths */
+        pPush->iRemaining -= iTempsize;
+        pPush->pDatanext  += iTempsize;
+        pTempbuf          += iTempsize;
+        *iRead            += iTempsize;
+        iTempsize         = 0;         /* all done!!! */
+      }
+    }
+  }
+  else
+  {
+    mng_uint32 iTempread = 0;
+                                       /* get it from the app then */
+    if (!pData->fReaddata (((mng_handle)pData), pTempbuf, iTempsize, &iTempread))
+      MNG_ERROR (pData, MNG_APPIOERROR);
+
+    *iRead += iTempread;
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode read_databuffer (mng_datap    pData,
+                                       mng_uint8p   pBuf,
+                                       mng_uint8p * pBufnext,
+                                       mng_uint32   iSize,
+                                       mng_uint32 * iRead)
+{
+  mng_retcode iRetcode;
+  
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DATABUFFER, MNG_LC_START);
+#endif
+
+  if (pData->bSuspensionmode)
+  {
+    mng_uint8p pTemp;
+    mng_uint32 iTemp;
+
+    *iRead = 0;                        /* let's be negative about the outcome */
+
+    if (!pData->pSuspendbuf)           /* need to create a suspension buffer ? */
+    {
+      pData->iSuspendbufsize = MNG_SUSPENDBUFFERSIZE;
+                                       /* so, create it */
+      MNG_ALLOC (pData, pData->pSuspendbuf, pData->iSuspendbufsize);
+
+      pData->iSuspendbufleft = 0;      /* make sure to fill it first time */
+      pData->pSuspendbufnext = pData->pSuspendbuf;
+    }
+                                       /* more than our buffer can hold ? */
+    if (iSize > pData->iSuspendbufsize)
+    {
+      mng_uint32 iRemain;
+
+      if (!*pBufnext)                  /* first time ? */
+      {
+        if (pData->iSuspendbufleft)    /* do we have some data left ? */
+        {                              /* then copy it */
+          MNG_COPY (pBuf, pData->pSuspendbufnext, pData->iSuspendbufleft);
+                                       /* fixup variables */
+          *pBufnext              = pBuf + pData->iSuspendbufleft;
+          pData->pSuspendbufnext = pData->pSuspendbuf;
+          pData->iSuspendbufleft = 0;
+        }
+        else
+        {
+          *pBufnext              = pBuf;
+        }
+      }
+                                       /* calculate how much to get */
+      iRemain = iSize - (mng_uint32)(*pBufnext - pBuf);
+                                       /* let's go get it */
+      iRetcode = read_data (pData, *pBufnext, iRemain, &iTemp);
+      if (iRetcode)
+        return iRetcode;
+                                       /* first read after suspension return 0 means EOF */
+      if ((pData->iSuspendpoint) && (iTemp == 0))
+      {                                /* that makes it final */
+        mng_retcode iRetcode = mng_process_eof (pData);
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+                                       /* indicate the source is depleted */
+        *iRead = iSize - iRemain + iTemp;
+      }
+      else
+      {
+        if (iTemp < iRemain)           /* suspension required ? */
+        {
+          *pBufnext         = *pBufnext + iTemp;
+          pData->bSuspended = MNG_TRUE;
+        }
+        else
+        {
+          *iRead = iSize;              /* got it all now ! */
+        }
+      }
+    }
+    else
+    {                                  /* need to read some more ? */
+      while ((!pData->bSuspended) && (!pData->bEOF) && (iSize > pData->iSuspendbufleft))
+      {                                /* not enough space left in buffer ? */
+        if (pData->iSuspendbufsize - pData->iSuspendbufleft -
+            (mng_uint32)(pData->pSuspendbufnext - pData->pSuspendbuf) <
+                                                          MNG_SUSPENDREQUESTSIZE)
+        {
+          if (pData->iSuspendbufleft)  /* then lets shift (if there's anything left) */
+            MNG_COPY (pData->pSuspendbuf, pData->pSuspendbufnext, pData->iSuspendbufleft);
+                                       /* adjust running pointer */
+          pData->pSuspendbufnext = pData->pSuspendbuf;
+        }
+                                       /* still not enough room ? */
+        if (pData->iSuspendbufsize - pData->iSuspendbufleft < MNG_SUSPENDREQUESTSIZE)
+          MNG_ERROR (pData, MNG_INTERNALERROR);
+                                       /* now read some more data */
+        pTemp = pData->pSuspendbufnext + pData->iSuspendbufleft;
+
+        iRetcode = read_data (pData, pTemp, MNG_SUSPENDREQUESTSIZE, &iTemp);
+        if (iRetcode)
+          return iRetcode;
+                                       /* adjust fill-counter */
+        pData->iSuspendbufleft += iTemp;
+                                       /* first read after suspension returning 0 means EOF */
+        if ((pData->iSuspendpoint) && (iTemp == 0))
+        {                              /* that makes it final */
+          mng_retcode iRetcode = mng_process_eof (pData);
+          if (iRetcode)                /* on error bail out */
+            return iRetcode;
+
+          if (pData->iSuspendbufleft)  /* return the leftover scraps */
+            MNG_COPY (pBuf, pData->pSuspendbufnext, pData->iSuspendbufleft);
+                                       /* and indicate so */
+          *iRead = pData->iSuspendbufleft;
+          pData->pSuspendbufnext = pData->pSuspendbuf;
+          pData->iSuspendbufleft = 0;
+        }
+        else
+        {                              /* suspension required ? */
+          if ((iSize > pData->iSuspendbufleft) && (iTemp < MNG_SUSPENDREQUESTSIZE))
+            pData->bSuspended = MNG_TRUE;
+
+        }
+
+        pData->iSuspendpoint = 0;      /* reset it here in case we loop back */
+      }
+
+      if ((!pData->bSuspended) && (!pData->bEOF))
+      {                                /* return the data ! */
+        MNG_COPY (pBuf, pData->pSuspendbufnext, iSize);
+
+        *iRead = iSize;                /* returned it all */
+                                       /* adjust suspension-buffer variables */
+        pData->pSuspendbufnext += iSize;
+        pData->iSuspendbufleft -= iSize;
+      }
+    }
+  }
+  else
+  {
+    iRetcode = read_data (pData, (mng_ptr)pBuf, iSize, iRead);
+    if (iRetcode)
+      return iRetcode;
+    if (*iRead == 0)                   /* suspension required ? */
+      pData->bSuspended = MNG_TRUE;
+  }
+
+  pData->iSuspendpoint = 0;            /* safely reset it here ! */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_DATABUFFER, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode process_raw_chunk (mng_datap  pData,
+                                         mng_uint8p pBuf,
+                                         mng_uint32 iBuflen)
+{
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  /* the table-idea & binary search code was adapted from
+     libpng 1.1.0 (pngread.c) */
+  /* NOTE1: the table must remain sorted by chunkname, otherwise the binary
+     search will break !!! (ps. watch upper-/lower-case chunknames !!) */
+  /* NOTE2: the layout must remain equal to the header part of all the
+     chunk-structures (yes, that means even the pNext and pPrev fields;
+     it's wasting a bit of space, but hey, the code is a lot easier) */
+
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+  mng_chunk_header mng_chunk_unknown = {MNG_UINT_HUH, mng_init_general, mng_free_unknown,
+                                        mng_read_unknown, mng_write_unknown, mng_assign_unknown, 0, 0, sizeof(mng_unknown_chunk)};
+#else
+  mng_chunk_header mng_chunk_unknown = {MNG_UINT_HUH, mng_init_unknown, mng_free_unknown,
+                                        mng_read_unknown, mng_write_unknown, mng_assign_unknown, 0, 0};
+#endif
+
+#ifdef MNG_OPTIMIZE_CHUNKINITFREE
+
+  mng_chunk_header mng_chunk_table [] =
+  {
+#ifndef MNG_SKIPCHUNK_BACK
+    {MNG_UINT_BACK, mng_init_general, mng_free_general, mng_read_back, mng_write_back, mng_assign_general, 0, 0, sizeof(mng_back)},
+#endif
+#ifndef MNG_SKIPCHUNK_BASI
+    {MNG_UINT_BASI, mng_init_general, mng_free_general, mng_read_basi, mng_write_basi, mng_assign_general, 0, 0, sizeof(mng_basi)},
+#endif
+#ifndef MNG_SKIPCHUNK_CLIP
+    {MNG_UINT_CLIP, mng_init_general, mng_free_general, mng_read_clip, mng_write_clip, mng_assign_general, 0, 0, sizeof(mng_clip)},
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+    {MNG_UINT_CLON, mng_init_general, mng_free_general, mng_read_clon, mng_write_clon, mng_assign_general, 0, 0, sizeof(mng_clon)},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+    {MNG_UINT_DBYK, mng_init_general, mng_free_dbyk,    mng_read_dbyk, mng_write_dbyk, mng_assign_dbyk,    0, 0, sizeof(mng_dbyk)},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_DEFI
+    {MNG_UINT_DEFI, mng_init_general, mng_free_general, mng_read_defi, mng_write_defi, mng_assign_general, 0, 0, sizeof(mng_defi)},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_UINT_DHDR, mng_init_general, mng_free_general, mng_read_dhdr, mng_write_dhdr, mng_assign_general, 0, 0, sizeof(mng_dhdr)},
+#endif
+#ifndef MNG_SKIPCHUNK_DISC
+    {MNG_UINT_DISC, mng_init_general, mng_free_disc,    mng_read_disc, mng_write_disc, mng_assign_disc,    0, 0, sizeof(mng_disc)},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DROP
+    {MNG_UINT_DROP, mng_init_general, mng_free_drop,    mng_read_drop, mng_write_drop, mng_assign_drop,    0, 0, sizeof(mng_drop)},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+    {MNG_UINT_ENDL, mng_init_general, mng_free_general, mng_read_endl, mng_write_endl, mng_assign_general, 0, 0, sizeof(mng_endl)},
+#endif
+#ifndef MNG_SKIPCHUNK_FRAM
+    {MNG_UINT_FRAM, mng_init_general, mng_free_fram,    mng_read_fram, mng_write_fram, mng_assign_fram,    0, 0, sizeof(mng_fram)},
+#endif
+    {MNG_UINT_IDAT, mng_init_general, mng_free_idat,    mng_read_idat, mng_write_idat, mng_assign_idat,    0, 0, sizeof(mng_idat)},  /* 12-th element! */
+    {MNG_UINT_IEND, mng_init_general, mng_free_general, mng_read_iend, mng_write_iend, mng_assign_general, 0, 0, sizeof(mng_iend)},
+    {MNG_UINT_IHDR, mng_init_general, mng_free_general, mng_read_ihdr, mng_write_ihdr, mng_assign_general, 0, 0, sizeof(mng_ihdr)},
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+    {MNG_UINT_IJNG, mng_init_general, mng_free_general, mng_read_ijng, mng_write_ijng, mng_assign_general, 0, 0, sizeof(mng_ijng)},
+#endif
+    {MNG_UINT_IPNG, mng_init_general, mng_free_general, mng_read_ipng, mng_write_ipng, mng_assign_general, 0, 0, sizeof(mng_ipng)},
+#endif
+#ifdef MNG_INCLUDE_JNG
+    {MNG_UINT_JDAA, mng_init_general, mng_free_jdaa,    mng_read_jdaa, mng_write_jdaa, mng_assign_jdaa,    0, 0, sizeof(mng_jdaa)},
+    {MNG_UINT_JDAT, mng_init_general, mng_free_jdat,    mng_read_jdat, mng_write_jdat, mng_assign_jdat,    0, 0, sizeof(mng_jdat)},
+    {MNG_UINT_JHDR, mng_init_general, mng_free_general, mng_read_jhdr, mng_write_jhdr, mng_assign_general, 0, 0, sizeof(mng_jhdr)},
+    {MNG_UINT_JSEP, mng_init_general, mng_free_general, mng_read_jsep, mng_write_jsep, mng_assign_general, 0, 0, sizeof(mng_jsep)},
+    {MNG_UINT_JdAA, mng_init_general, mng_free_jdaa,    mng_read_jdaa, mng_write_jdaa, mng_assign_jdaa,    0, 0, sizeof(mng_jdaa)},
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+    {MNG_UINT_LOOP, mng_init_general, mng_free_loop,    mng_read_loop, mng_write_loop, mng_assign_loop,    0, 0, sizeof(mng_loop)},
+#endif
+#ifndef MNG_SKIPCHUNK_MAGN
+    {MNG_UINT_MAGN, mng_init_general, mng_free_general, mng_read_magn, mng_write_magn, mng_assign_general, 0, 0, sizeof(mng_magn)},
+#endif
+    {MNG_UINT_MEND, mng_init_general, mng_free_general, mng_read_mend, mng_write_mend, mng_assign_general, 0, 0, sizeof(mng_mend)},
+    {MNG_UINT_MHDR, mng_init_general, mng_free_general, mng_read_mhdr, mng_write_mhdr, mng_assign_general, 0, 0, sizeof(mng_mhdr)},
+#ifndef MNG_SKIPCHUNK_MOVE
+    {MNG_UINT_MOVE, mng_init_general, mng_free_general, mng_read_move, mng_write_move, mng_assign_general, 0, 0, sizeof(mng_move)},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+    {MNG_UINT_ORDR, mng_init_general, mng_free_ordr,    mng_read_ordr, mng_write_ordr, mng_assign_ordr,    0, 0, sizeof(mng_ordr)},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_UINT_PAST, mng_init_general, mng_free_past,    mng_read_past, mng_write_past, mng_assign_past,    0, 0, sizeof(mng_past)},
+#endif
+    {MNG_UINT_PLTE, mng_init_general, mng_free_general, mng_read_plte, mng_write_plte, mng_assign_general, 0, 0, sizeof(mng_plte)},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_UINT_PPLT, mng_init_general, mng_free_general, mng_read_pplt, mng_write_pplt, mng_assign_general, 0, 0, sizeof(mng_pplt)},
+    {MNG_UINT_PROM, mng_init_general, mng_free_general, mng_read_prom, mng_write_prom, mng_assign_general, 0, 0, sizeof(mng_prom)},
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+    {MNG_UINT_SAVE, mng_init_general, mng_free_save,    mng_read_save, mng_write_save, mng_assign_save,    0, 0, sizeof(mng_save)},
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+    {MNG_UINT_SEEK, mng_init_general, mng_free_seek,    mng_read_seek, mng_write_seek, mng_assign_seek,    0, 0, sizeof(mng_seek)},
+#endif
+#ifndef MNG_SKIPCHUNK_SHOW
+    {MNG_UINT_SHOW, mng_init_general, mng_free_general, mng_read_show, mng_write_show, mng_assign_general, 0, 0, sizeof(mng_show)},
+#endif
+#ifndef MNG_SKIPCHUNK_TERM
+    {MNG_UINT_TERM, mng_init_general, mng_free_general, mng_read_term, mng_write_term, mng_assign_general, 0, 0, sizeof(mng_term)},
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+    {MNG_UINT_bKGD, mng_init_general, mng_free_general, mng_read_bkgd, mng_write_bkgd, mng_assign_general, 0, 0, sizeof(mng_bkgd)},
+#endif
+#ifndef MNG_SKIPCHUNK_cHRM
+    {MNG_UINT_cHRM, mng_init_general, mng_free_general, mng_read_chrm, mng_write_chrm, mng_assign_general, 0, 0, sizeof(mng_chrm)},
+#endif
+#ifndef MNG_SKIPCHUNK_eXPI
+    {MNG_UINT_eXPI, mng_init_general, mng_free_expi,    mng_read_expi, mng_write_expi, mng_assign_expi,    0, 0, sizeof(mng_expi)},
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_UINT_evNT, mng_init_general, mng_free_evnt,    mng_read_evnt, mng_write_evnt, mng_assign_evnt,    0, 0, sizeof(mng_evnt)},
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+    {MNG_UINT_fPRI, mng_init_general, mng_free_general, mng_read_fpri, mng_write_fpri, mng_assign_general, 0, 0, sizeof(mng_fpri)},
+#endif
+#ifndef MNG_SKIPCHUNK_gAMA
+    {MNG_UINT_gAMA, mng_init_general, mng_free_general, mng_read_gama, mng_write_gama, mng_assign_general, 0, 0, sizeof(mng_gama)},
+#endif
+#ifndef MNG_SKIPCHUNK_hIST
+    {MNG_UINT_hIST, mng_init_general, mng_free_general, mng_read_hist, mng_write_hist, mng_assign_general, 0, 0, sizeof(mng_hist)},
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+    {MNG_UINT_iCCP, mng_init_general, mng_free_iccp,    mng_read_iccp, mng_write_iccp, mng_assign_iccp,    0, 0, sizeof(mng_iccp)},
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+    {MNG_UINT_iTXt, mng_init_general, mng_free_itxt,    mng_read_itxt, mng_write_itxt, mng_assign_itxt,    0, 0, sizeof(mng_itxt)},
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_UINT_mpNG, mng_init_general, mng_free_mpng,    mng_read_mpng, mng_write_mpng, mng_assign_mpng,    0, 0, sizeof(mng_mpng)},
+#endif
+#ifndef MNG_SKIPCHUNK_nEED
+    {MNG_UINT_nEED, mng_init_general, mng_free_need,    mng_read_need, mng_write_need, mng_assign_need,    0, 0, sizeof(mng_need)},
+#endif
+/* TODO:     {MNG_UINT_oFFs, 0, 0, 0, 0, 0, 0},  */
+/* TODO:     {MNG_UINT_pCAL, 0, 0, 0, 0, 0, 0},  */
+#ifndef MNG_SKIPCHUNK_pHYg
+    {MNG_UINT_pHYg, mng_init_general, mng_free_general, mng_read_phyg, mng_write_phyg, mng_assign_general, 0, 0, sizeof(mng_phyg)},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+    {MNG_UINT_pHYs, mng_init_general, mng_free_general, mng_read_phys, mng_write_phys, mng_assign_general, 0, 0, sizeof(mng_phys)},
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+    {MNG_UINT_sBIT, mng_init_general, mng_free_general, mng_read_sbit, mng_write_sbit, mng_assign_general, 0, 0, sizeof(mng_sbit)},
+#endif
+/* TODO:     {MNG_UINT_sCAL, 0, 0, 0, 0, 0, 0},  */
+#ifndef MNG_SKIPCHUNK_sPLT
+    {MNG_UINT_sPLT, mng_init_general, mng_free_splt,    mng_read_splt, mng_write_splt, mng_assign_splt,    0, 0, sizeof(mng_splt)},
+#endif
+    {MNG_UINT_sRGB, mng_init_general, mng_free_general, mng_read_srgb, mng_write_srgb, mng_assign_general, 0, 0, sizeof(mng_srgb)},
+#ifndef MNG_SKIPCHUNK_tEXt
+    {MNG_UINT_tEXt, mng_init_general, mng_free_text,    mng_read_text, mng_write_text, mng_assign_text,    0, 0, sizeof(mng_text)},
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+    {MNG_UINT_tIME, mng_init_general, mng_free_general, mng_read_time, mng_write_time, mng_assign_general, 0, 0, sizeof(mng_time)},
+#endif
+    {MNG_UINT_tRNS, mng_init_general, mng_free_general, mng_read_trns, mng_write_trns, mng_assign_general, 0, 0, sizeof(mng_trns)},
+#ifndef MNG_SKIPCHUNK_zTXt
+    {MNG_UINT_zTXt, mng_init_general, mng_free_ztxt,    mng_read_ztxt, mng_write_ztxt, mng_assign_ztxt,    0, 0, sizeof(mng_ztxt)},
+#endif
+  };
+
+#else                        /* MNG_OPTIMIZE_CHUNKINITFREE */
+
+  mng_chunk_header mng_chunk_table [] =
+  {
+#ifndef MNG_SKIPCHUNK_BACK
+    {MNG_UINT_BACK, mng_init_back, mng_free_back, mng_read_back, mng_write_back, mng_assign_back, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_BASI
+    {MNG_UINT_BASI, mng_init_basi, mng_free_basi, mng_read_basi, mng_write_basi, mng_assign_basi, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_CLIP
+    {MNG_UINT_CLIP, mng_init_clip, mng_free_clip, mng_read_clip, mng_write_clip, mng_assign_clip, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+    {MNG_UINT_CLON, mng_init_clon, mng_free_clon, mng_read_clon, mng_write_clon, mng_assign_clon, 0, 0},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DBYK
+    {MNG_UINT_DBYK, mng_init_dbyk, mng_free_dbyk, mng_read_dbyk, mng_write_dbyk, mng_assign_dbyk, 0, 0},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_DEFI
+    {MNG_UINT_DEFI, mng_init_defi, mng_free_defi, mng_read_defi, mng_write_defi, mng_assign_defi, 0, 0},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_UINT_DHDR, mng_init_dhdr, mng_free_dhdr, mng_read_dhdr, mng_write_dhdr, mng_assign_dhdr, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_DISC
+    {MNG_UINT_DISC, mng_init_disc, mng_free_disc, mng_read_disc, mng_write_disc, mng_assign_disc, 0, 0},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_DROP
+    {MNG_UINT_DROP, mng_init_drop, mng_free_drop, mng_read_drop, mng_write_drop, mng_assign_drop, 0, 0},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+    {MNG_UINT_ENDL, mng_init_endl, mng_free_endl, mng_read_endl, mng_write_endl, mng_assign_endl, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_FRAM
+    {MNG_UINT_FRAM, mng_init_fram, mng_free_fram, mng_read_fram, mng_write_fram, mng_assign_fram, 0, 0},
+#endif
+    {MNG_UINT_IDAT, mng_init_idat, mng_free_idat, mng_read_idat, mng_write_idat, mng_assign_idat, 0, 0},  /* 12-th element! */
+    {MNG_UINT_IEND, mng_init_iend, mng_free_iend, mng_read_iend, mng_write_iend, mng_assign_iend, 0, 0},
+    {MNG_UINT_IHDR, mng_init_ihdr, mng_free_ihdr, mng_read_ihdr, mng_write_ihdr, mng_assign_ihdr, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+#ifdef MNG_INCLUDE_JNG
+    {MNG_UINT_IJNG, mng_init_ijng, mng_free_ijng, mng_read_ijng, mng_write_ijng, mng_assign_ijng, 0, 0},
+#endif
+    {MNG_UINT_IPNG, mng_init_ipng, mng_free_ipng, mng_read_ipng, mng_write_ipng, mng_assign_ipng, 0, 0},
+#endif
+#ifdef MNG_INCLUDE_JNG
+    {MNG_UINT_JDAA, mng_init_jdaa, mng_free_jdaa, mng_read_jdaa, mng_write_jdaa, mng_assign_jdaa, 0, 0},
+    {MNG_UINT_JDAT, mng_init_jdat, mng_free_jdat, mng_read_jdat, mng_write_jdat, mng_assign_jdat, 0, 0},
+    {MNG_UINT_JHDR, mng_init_jhdr, mng_free_jhdr, mng_read_jhdr, mng_write_jhdr, mng_assign_jhdr, 0, 0},
+    {MNG_UINT_JSEP, mng_init_jsep, mng_free_jsep, mng_read_jsep, mng_write_jsep, mng_assign_jsep, 0, 0},
+    {MNG_UINT_JdAA, mng_init_jdaa, mng_free_jdaa, mng_read_jdaa, mng_write_jdaa, mng_assign_jdaa, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_LOOP
+    {MNG_UINT_LOOP, mng_init_loop, mng_free_loop, mng_read_loop, mng_write_loop, mng_assign_loop, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_MAGN
+    {MNG_UINT_MAGN, mng_init_magn, mng_free_magn, mng_read_magn, mng_write_magn, mng_assign_magn, 0, 0},
+#endif
+    {MNG_UINT_MEND, mng_init_mend, mng_free_mend, mng_read_mend, mng_write_mend, mng_assign_mend, 0, 0},
+    {MNG_UINT_MHDR, mng_init_mhdr, mng_free_mhdr, mng_read_mhdr, mng_write_mhdr, mng_assign_mhdr, 0, 0},
+#ifndef MNG_SKIPCHUNK_MOVE
+    {MNG_UINT_MOVE, mng_init_move, mng_free_move, mng_read_move, mng_write_move, mng_assign_move, 0, 0},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+#ifndef MNG_SKIPCHUNK_ORDR
+    {MNG_UINT_ORDR, mng_init_ordr, mng_free_ordr, mng_read_ordr, mng_write_ordr, mng_assign_ordr, 0, 0},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_UINT_PAST, mng_init_past, mng_free_past, mng_read_past, mng_write_past, mng_assign_past, 0, 0},
+#endif
+    {MNG_UINT_PLTE, mng_init_plte, mng_free_plte, mng_read_plte, mng_write_plte, mng_assign_plte, 0, 0},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_UINT_PPLT, mng_init_pplt, mng_free_pplt, mng_read_pplt, mng_write_pplt, mng_assign_pplt, 0, 0},
+    {MNG_UINT_PROM, mng_init_prom, mng_free_prom, mng_read_prom, mng_write_prom, mng_assign_prom, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+    {MNG_UINT_SAVE, mng_init_save, mng_free_save, mng_read_save, mng_write_save, mng_assign_save, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+    {MNG_UINT_SEEK, mng_init_seek, mng_free_seek, mng_read_seek, mng_write_seek, mng_assign_seek, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_SHOW
+    {MNG_UINT_SHOW, mng_init_show, mng_free_show, mng_read_show, mng_write_show, mng_assign_show, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_TERM
+    {MNG_UINT_TERM, mng_init_term, mng_free_term, mng_read_term, mng_write_term, mng_assign_term, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+    {MNG_UINT_bKGD, mng_init_bkgd, mng_free_bkgd, mng_read_bkgd, mng_write_bkgd, mng_assign_bkgd, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_cHRM
+    {MNG_UINT_cHRM, mng_init_chrm, mng_free_chrm, mng_read_chrm, mng_write_chrm, mng_assign_chrm, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_eXPI
+    {MNG_UINT_eXPI, mng_init_expi, mng_free_expi, mng_read_expi, mng_write_expi, mng_assign_expi, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_UINT_evNT, mng_init_evnt, mng_free_evnt, mng_read_evnt, mng_write_evnt, mng_assign_evnt, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+    {MNG_UINT_fPRI, mng_init_fpri, mng_free_fpri, mng_read_fpri, mng_write_fpri, mng_assign_fpri, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_gAMA
+    {MNG_UINT_gAMA, mng_init_gama, mng_free_gama, mng_read_gama, mng_write_gama, mng_assign_gama, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_hIST
+    {MNG_UINT_hIST, mng_init_hist, mng_free_hist, mng_read_hist, mng_write_hist, mng_assign_hist, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+    {MNG_UINT_iCCP, mng_init_iccp, mng_free_iccp, mng_read_iccp, mng_write_iccp, mng_assign_iccp, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+    {MNG_UINT_iTXt, mng_init_itxt, mng_free_itxt, mng_read_itxt, mng_write_itxt, mng_assign_itxt, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_nEED
+    {MNG_UINT_nEED, mng_init_need, mng_free_need, mng_read_need, mng_write_need, mng_assign_need, 0, 0},
+#endif
+/* TODO:     {MNG_UINT_oFFs, 0, 0, 0, 0, 0, 0},  */
+/* TODO:     {MNG_UINT_pCAL, 0, 0, 0, 0, 0, 0},  */
+#ifndef MNG_SKIPCHUNK_pHYg
+    {MNG_UINT_pHYg, mng_init_phyg, mng_free_phyg, mng_read_phyg, mng_write_phyg, mng_assign_phyg, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+    {MNG_UINT_pHYs, mng_init_phys, mng_free_phys, mng_read_phys, mng_write_phys, mng_assign_phys, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+    {MNG_UINT_sBIT, mng_init_sbit, mng_free_sbit, mng_read_sbit, mng_write_sbit, mng_assign_sbit, 0, 0},
+#endif
+/* TODO:     {MNG_UINT_sCAL, 0, 0, 0, 0, 0, 0},  */
+#ifndef MNG_SKIPCHUNK_sPLT
+    {MNG_UINT_sPLT, mng_init_splt, mng_free_splt, mng_read_splt, mng_write_splt, mng_assign_splt, 0, 0},
+#endif
+    {MNG_UINT_sRGB, mng_init_srgb, mng_free_srgb, mng_read_srgb, mng_write_srgb, mng_assign_srgb, 0, 0},
+#ifndef MNG_SKIPCHUNK_tEXt
+    {MNG_UINT_tEXt, mng_init_text, mng_free_text, mng_read_text, mng_write_text, mng_assign_text, 0, 0},
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+    {MNG_UINT_tIME, mng_init_time, mng_free_time, mng_read_time, mng_write_time, mng_assign_time, 0, 0},
+#endif
+    {MNG_UINT_tRNS, mng_init_trns, mng_free_trns, mng_read_trns, mng_write_trns, mng_assign_trns, 0, 0},
+#ifndef MNG_SKIPCHUNK_zTXt
+    {MNG_UINT_zTXt, mng_init_ztxt, mng_free_ztxt, mng_read_ztxt, mng_write_ztxt, mng_assign_ztxt, 0, 0},
+#endif
+  };
+
+#endif                       /* MNG_OPTIMIZE_CHUNKINITFREE */
+
+                                       /* binary search variables */
+  mng_int32         iTop, iLower, iUpper, iMiddle;
+  mng_chunk_headerp pEntry;            /* pointer to found entry */
+#else
+  mng_chunk_header  sEntry;            /* temp chunk-header */
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+  mng_chunkid       iChunkname;        /* the chunk's tag */
+  mng_chunkp        pChunk;            /* chunk structure (if #define MNG_STORE_CHUNKS) */
+  mng_retcode       iRetcode;          /* temporary error-code */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RAW_CHUNK, MNG_LC_START);
+#endif
+                                       /* reset timer indicator on read-cycle */
+  if ((pData->bReading) && (!pData->bDisplaying))
+    pData->bTimerset = MNG_FALSE;
+                                       /* get the chunkname */
+  iChunkname = (mng_chunkid)(mng_get_uint32 (pBuf));
+
+  pBuf += sizeof (mng_chunkid);        /* adjust the buffer */
+  iBuflen -= sizeof (mng_chunkid);
+  pChunk = 0;
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+                                       /* determine max index of table */
+  iTop = (sizeof (mng_chunk_table) / sizeof (mng_chunk_table [0])) - 1;
+
+  /* binary search; with 54 chunks, worst-case is 7 comparisons */
+  iLower  = 0;
+#ifndef MNG_NO_DELTA_PNG
+  iMiddle = 11;                        /* start with the IDAT entry */
+#else
+  iMiddle = 8;
+#endif
+  iUpper  = iTop;
+  pEntry  = 0;                         /* no goods yet! */
+
+  do                                   /* the binary search itself */
+    {
+      if (mng_chunk_table [iMiddle].iChunkname < iChunkname)
+        iLower = iMiddle + 1;
+      else if (mng_chunk_table [iMiddle].iChunkname > iChunkname)
+        iUpper = iMiddle - 1;
+      else
+      {
+        pEntry = &mng_chunk_table [iMiddle];
+        break;
+      }
+
+      iMiddle = (iLower + iUpper) >> 1;
+    }
+  while (iLower <= iUpper);
+
+  if (!pEntry)                         /* unknown chunk ? */
+    pEntry = &mng_chunk_unknown;       /* make it so! */
+
+#else /* MNG_OPTIMIZE_CHUNKREADER */
+
+  mng_get_chunkheader (iChunkname, &sEntry);
+
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+
+  pData->iChunkname = iChunkname;      /* keep track of where we are */
+  pData->iChunkseq++;
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+  if (pEntry->fRead)                   /* read-callback available ? */
+  {
+    iRetcode = pEntry->fRead (pData, pEntry, iBuflen, (mng_ptr)pBuf, &pChunk);
+
+    if (!iRetcode)                     /* everything oke ? */
+    {                                  /* remember unknown chunk's id */
+      if ((pChunk) && (pEntry->iChunkname == MNG_UINT_HUH))
+        ((mng_chunk_headerp)pChunk)->iChunkname = iChunkname;
+    }
+  }
+#else /* MNG_OPTIMIZE_CHUNKREADER */
+  if (sEntry.fRead)                    /* read-callback available ? */
+  {
+    iRetcode = sEntry.fRead (pData, &sEntry, iBuflen, (mng_ptr)pBuf, &pChunk);
+
+#ifndef MNG_OPTIMIZE_CHUNKREADER
+    if (!iRetcode)                     /* everything oke ? */
+    {                                  /* remember unknown chunk's id */
+      if ((pChunk) && (sEntry.iChunkname == MNG_UINT_HUH))
+        ((mng_chunk_headerp)pChunk)->iChunkname = iChunkname;
+    }
+#endif
+  }
+#endif /* MNG_OPTIMIZE_CHUNKREADER */
+  else
+    iRetcode = MNG_NOERROR;
+
+  if (pChunk)                          /* store this chunk ? */
+    mng_add_chunk (pData, pChunk);     /* do it */
+
+#ifdef MNG_INCLUDE_JNG                 /* implicit EOF ? */
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR) && (!pData->bHasJHDR))
+#else
+  if ((!pData->bHasMHDR) && (!pData->bHasIHDR))
+#endif
+    iRetcode = mng_process_eof (pData);/* then do some EOF processing */
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_PROCESS_RAW_CHUNK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode check_chunk_crc (mng_datap  pData,
+                                       mng_uint8p pBuf,
+                                       mng_uint32 iBuflen)
+{
+  mng_uint32  iCrc;                    /* calculated CRC */
+  mng_bool    bDiscard = MNG_FALSE;
+  mng_retcode iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CHUNK_CRC, MNG_LC_START);
+#endif
+
+  if (pData->iCrcmode & MNG_CRC_INPUT) /* crc included ? */
+  {
+    mng_bool bCritical = (mng_bool)((*pBuf & 0x20) == 0);
+    mng_uint32 iL = iBuflen - (mng_uint32)(sizeof (iCrc));
+
+    if (((bCritical ) && (pData->iCrcmode & MNG_CRC_CRITICAL )) ||
+        ((!bCritical) && (pData->iCrcmode & MNG_CRC_ANCILLARY)))
+    {                                  /* calculate the crc */
+      iCrc = mng_crc (pData, pBuf, iL);
+                                       /* and check it */
+      if (!(iCrc == mng_get_uint32 (pBuf + iL)))
+      {
+        mng_bool bWarning = MNG_FALSE;
+        mng_bool bError   = MNG_FALSE;
+
+        if (bCritical)
+        {
+          switch (pData->iCrcmode & MNG_CRC_CRITICAL)
+          {
+            case MNG_CRC_CRITICAL_WARNING  : { bWarning = MNG_TRUE; break; }
+            case MNG_CRC_CRITICAL_ERROR    : { bError   = MNG_TRUE; break; }
+          }
+        }
+        else
+        {
+          switch (pData->iCrcmode & MNG_CRC_ANCILLARY)
+          {
+            case MNG_CRC_ANCILLARY_DISCARD : { bDiscard = MNG_TRUE; break; }
+            case MNG_CRC_ANCILLARY_WARNING : { bWarning = MNG_TRUE; break; }
+            case MNG_CRC_ANCILLARY_ERROR   : { bError   = MNG_TRUE; break; }
+          }
+        }
+
+        if (bWarning)
+          MNG_WARNING (pData, MNG_INVALIDCRC);
+        if (bError)
+          MNG_ERROR (pData, MNG_INVALIDCRC);
+      }
+    }
+
+    if (!bDiscard)                     /* still processing ? */
+      iRetcode = process_raw_chunk (pData, pBuf, iL);
+  }
+  else
+  {                                    /* no crc => straight onto processing */
+    iRetcode = process_raw_chunk (pData, pBuf, iBuflen);
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CHUNK_CRC, MNG_LC_END);
+#endif
+
+  return iRetcode;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode read_chunk (mng_datap  pData)
+{
+  mng_uint32  iBufmax   = pData->iReadbufsize;
+  mng_uint8p  pBuf      = pData->pReadbuf;
+  mng_uint32  iBuflen   = 0;           /* number of bytes requested */
+  mng_uint32  iRead     = 0;           /* number of bytes read */
+  mng_retcode iRetcode  = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CHUNK, MNG_LC_START);
+#endif
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (pData->pCurraniobj)              /* processing an animation object ? */
+  {
+    do                                 /* process it then */
+    {
+      iRetcode = ((mng_object_headerp)pData->pCurraniobj)->fProcess (pData, pData->pCurraniobj);
+                                       /* refresh needed ? */
+/*      if ((!iRetcode) && (!pData->bTimerset) && (pData->bNeedrefresh))
+        iRetcode = display_progressive_refresh (pData, 1); */
+                                       /* can we advance to next object ? */
+      if ((!iRetcode) && (pData->pCurraniobj) &&
+          (!pData->bTimerset) && (!pData->bSectionwait))
+      {                                /* reset timer indicator on read-cycle */
+        if ((pData->bReading) && (!pData->bDisplaying))
+          pData->bTimerset = MNG_FALSE;
+
+        pData->pCurraniobj = ((mng_object_headerp)pData->pCurraniobj)->pNext;
+                                       /* TERM processing to be done ? */
+        if ((!pData->pCurraniobj) && (pData->bHasTERM) && (!pData->bHasMHDR))
+          iRetcode = mng_process_display_mend (pData);
+      }
+    }                                  /* until error or a break or no more objects */
+    while ((!iRetcode) && (pData->pCurraniobj) &&
+           (!pData->bTimerset) && (!pData->bSectionwait) && (!pData->bFreezing));
+  }
+  else
+  {
+    if (pData->iBreakpoint)            /* do we need to finish something first ? */
+    {
+      switch (pData->iBreakpoint)      /* return to broken display routine */
+      {
+#ifndef MNG_SKIPCHUNK_FRAM
+        case  1 : { iRetcode = mng_process_display_fram2 (pData); break; }
+#endif
+        case  2 : { iRetcode = mng_process_display_ihdr  (pData); break; }
+#ifndef MNG_SKIPCHUNK_SHOW
+        case  3 : ;                     /* same as 4 !!! */
+        case  4 : { iRetcode = mng_process_display_show  (pData); break; }
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+        case  5 : { iRetcode = mng_process_display_clon2 (pData); break; }
+#endif
+#ifdef MNG_INCLUDE_JNG
+        case  7 : { iRetcode = mng_process_display_jhdr  (pData); break; }
+#endif
+        case  6 : ;                     /* same as 8 !!! */
+        case  8 : { iRetcode = mng_process_display_iend  (pData); break; }
+#ifndef MNG_SKIPCHUNK_MAGN
+        case  9 : { iRetcode = mng_process_display_magn2 (pData); break; }
+#endif
+        case 10 : { iRetcode = mng_process_display_mend2 (pData); break; }
+#ifndef MNG_SKIPCHUNK_PAST
+        case 11 : { iRetcode = mng_process_display_past2 (pData); break; }
+#endif
+      }
+    }
+  }
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#endif /* MNG_SUPPORT_DISPLAY */
+                                       /* can we continue processing now, or do we */
+                                       /* need to wait for the timer to finish (again) ? */
+#ifdef MNG_SUPPORT_DISPLAY
+  if ((!pData->bTimerset) && (!pData->bSectionwait) && (!pData->bEOF))
+#else
+  if (!pData->bEOF)
+#endif
+  {
+#ifdef MNG_SUPPORT_DISPLAY
+                                       /* freezing in progress ? */
+    if ((pData->bFreezing) && (pData->iSuspendpoint == 0))
+      pData->bRunning = MNG_FALSE;     /* then this is the right moment to do it */
+#endif
+
+    if (pData->iSuspendpoint <= 2)
+    {
+      iBuflen  = sizeof (mng_uint32);  /* read length */
+      iRetcode = read_databuffer (pData, pBuf, &pData->pReadbufnext, iBuflen, &iRead);
+
+      if (iRetcode)                    /* bail on errors */
+        return iRetcode;
+
+      if (pData->bSuspended)           /* suspended ? */
+        pData->iSuspendpoint = 2;
+      else                             /* save the length */
+      {
+        pData->iChunklen = mng_get_uint32 (pBuf);
+        if (pData->iChunklen > 0x7ffffff)
+           return MNG_INVALIDLENGTH;
+      }
+
+    }
+
+    if (!pData->bSuspended)            /* still going ? */
+    {                                  /* previously suspended or not eof ? */
+      if ((pData->iSuspendpoint > 2) || (iRead == iBuflen))
+      {                                /* determine length chunkname + data (+ crc) */
+        if (pData->iCrcmode & MNG_CRC_INPUT)
+          iBuflen = pData->iChunklen + (mng_uint32)(sizeof (mng_chunkid) + sizeof (mng_uint32));
+        else
+          iBuflen = pData->iChunklen + (mng_uint32)(sizeof (mng_chunkid));
+
+                                       /* do we have enough data in the current push buffer ? */
+        if ((pData->pFirstpushdata) && (iBuflen <= pData->pFirstpushdata->iRemaining))
+        {
+          mng_pushdatap pPush  = pData->pFirstpushdata;
+          pBuf                 = pPush->pDatanext;
+          pPush->pDatanext    += iBuflen;
+          pPush->iRemaining   -= iBuflen;
+          pData->iSuspendpoint = 0;    /* safely reset this here ! */
+
+          iRetcode = check_chunk_crc (pData, pBuf, iBuflen);
+          if (iRetcode)
+            return iRetcode;
+
+          if (!pPush->iRemaining)      /* buffer depleted? then release it */
+            iRetcode = mng_release_pushdata (pData);
+        }
+        else
+        {
+          if (iBuflen < iBufmax)       /* does it fit in default buffer ? */
+          {                            /* note that we don't use the full size
+                                          so there's always a zero-byte at the
+                                          very end !!! */
+            iRetcode = read_databuffer (pData, pBuf, &pData->pReadbufnext, iBuflen, &iRead);
+            if (iRetcode)              /* bail on errors */
+              return iRetcode;
+
+            if (pData->bSuspended)     /* suspended ? */
+              pData->iSuspendpoint = 3;
+            else
+            {
+              if (iRead != iBuflen)    /* did we get all the data ? */
+                MNG_ERROR (pData, MNG_UNEXPECTEDEOF);
+              iRetcode = check_chunk_crc (pData, pBuf, iBuflen);
+            }
+          }
+          else
+          {
+            if (iBuflen > 16777216)    /* is the length incredible? */
+              MNG_ERROR (pData, MNG_IMPROBABLELENGTH);
+
+            if (!pData->iSuspendpoint) /* create additional large buffer ? */
+            {                          /* again reserve space for the last zero-byte */
+              pData->iLargebufsize = iBuflen + 1;
+              pData->pLargebufnext = MNG_NULL;
+              MNG_ALLOC (pData, pData->pLargebuf, pData->iLargebufsize);
+            }
+
+            iRetcode = read_databuffer (pData, pData->pLargebuf, &pData->pLargebufnext, iBuflen, &iRead);
+            if (iRetcode)
+              return iRetcode;
+
+            if (pData->bSuspended)     /* suspended ? */
+              pData->iSuspendpoint = 4;
+            else
+            {
+              if (iRead != iBuflen)    /* did we get all the data ? */
+                MNG_ERROR (pData, MNG_UNEXPECTEDEOF);
+              iRetcode = check_chunk_crc (pData, pData->pLargebuf, iBuflen);
+                                       /* cleanup additional large buffer */
+              MNG_FREE (pData, pData->pLargebuf, pData->iLargebufsize);
+            }
+          }
+        }
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+
+      }
+      else
+      {                                /* that's final */
+        iRetcode = mng_process_eof (pData);
+
+        if (iRetcode)                  /* on error bail out */
+          return iRetcode;
+
+        if ((iRead != 0) ||            /* did we get an unexpected eof ? */
+#ifdef MNG_INCLUDE_JNG
+            (pData->bHasIHDR || pData->bHasMHDR || pData->bHasJHDR))
+#else
+            (pData->bHasIHDR || pData->bHasMHDR))
+#endif
+          MNG_ERROR (pData, MNG_UNEXPECTEDEOF);
+      } 
+    }
+  }
+
+#ifdef MNG_SUPPORT_DISPLAY             /* refresh needed ? */
+  if ((!pData->bTimerset) && (!pData->bSuspended) && (pData->bNeedrefresh))
+  {
+    iRetcode = mng_display_progressive_refresh (pData, 1);
+
+    if (iRetcode)                      /* on error bail out */
+      return iRetcode;
+  }
+#endif
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_CHUNK, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+MNG_LOCAL mng_retcode process_pushedchunk (mng_datap pData)
+{
+  mng_pushdatap pPush;
+  mng_retcode   iRetcode = MNG_NOERROR;
+
+#ifdef MNG_SUPPORT_DISPLAY
+  if (pData->pCurraniobj)              /* processing an animation object ? */
+  {
+    do                                 /* process it then */
+    {
+      iRetcode = ((mng_object_headerp)pData->pCurraniobj)->fProcess (pData, pData->pCurraniobj);
+                                       /* refresh needed ? */
+/*      if ((!iRetcode) && (!pData->bTimerset) && (pData->bNeedrefresh))
+        iRetcode = display_progressive_refresh (pData, 1); */
+                                       /* can we advance to next object ? */
+      if ((!iRetcode) && (pData->pCurraniobj) &&
+          (!pData->bTimerset) && (!pData->bSectionwait))
+      {                                /* reset timer indicator on read-cycle */
+        if ((pData->bReading) && (!pData->bDisplaying))
+          pData->bTimerset = MNG_FALSE;
+
+        pData->pCurraniobj = ((mng_object_headerp)pData->pCurraniobj)->pNext;
+                                       /* TERM processing to be done ? */
+        if ((!pData->pCurraniobj) && (pData->bHasTERM) && (!pData->bHasMHDR))
+          iRetcode = mng_process_display_mend (pData);
+      }
+    }                                  /* until error or a break or no more objects */
+    while ((!iRetcode) && (pData->pCurraniobj) &&
+           (!pData->bTimerset) && (!pData->bSectionwait) && (!pData->bFreezing));
+  }
+  else
+  {
+    if (pData->iBreakpoint)            /* do we need to finish something first ? */
+    {
+      switch (pData->iBreakpoint)      /* return to broken display routine */
+      {
+#ifndef MNG_SKIPCHUNK_FRAM
+        case  1 : { iRetcode = mng_process_display_fram2 (pData); break; }
+#endif
+        case  2 : { iRetcode = mng_process_display_ihdr  (pData); break; }
+#ifndef MNG_SKIPCHUNK_SHOW
+        case  3 : ;                     /* same as 4 !!! */
+        case  4 : { iRetcode = mng_process_display_show  (pData); break; }
+#endif
+#ifndef MNG_SKIPCHUNK_CLON
+        case  5 : { iRetcode = mng_process_display_clon2 (pData); break; }
+#endif
+#ifdef MNG_INCLUDE_JNG
+        case  7 : { iRetcode = mng_process_display_jhdr  (pData); break; }
+#endif
+        case  6 : ;                     /* same as 8 !!! */
+        case  8 : { iRetcode = mng_process_display_iend  (pData); break; }
+#ifndef MNG_SKIPCHUNK_MAGN
+        case  9 : { iRetcode = mng_process_display_magn2 (pData); break; }
+#endif
+        case 10 : { iRetcode = mng_process_display_mend2 (pData); break; }
+#ifndef MNG_SKIPCHUNK_PAST
+        case 11 : { iRetcode = mng_process_display_past2 (pData); break; }
+#endif
+      }
+    }
+  }
+
+  if (iRetcode)                        /* on error bail out */
+    return iRetcode;
+
+#endif /* MNG_SUPPORT_DISPLAY */
+                                       /* can we continue processing now, or do we */
+                                       /* need to wait for the timer to finish (again) ? */
+#ifdef MNG_SUPPORT_DISPLAY
+  if ((!pData->bTimerset) && (!pData->bSectionwait) && (!pData->bEOF))
+#else
+  if (!pData->bEOF)
+#endif
+  {
+    pData->iSuspendpoint = 0;            /* safely reset it here ! */
+    pPush = pData->pFirstpushchunk;
+
+    iRetcode = process_raw_chunk (pData, pPush->pData, pPush->iLength);
+    if (iRetcode)
+      return iRetcode;
+
+#ifdef MNG_SUPPORT_DISPLAY             /* refresh needed ? */
+    if ((!pData->bTimerset) && (!pData->bSuspended) && (pData->bNeedrefresh))
+    {
+      iRetcode = mng_display_progressive_refresh (pData, 1);
+      if (iRetcode)                      /* on error bail out */
+        return iRetcode;
+    }
+#endif
+  }
+
+  return mng_release_pushchunk (pData);
+}
+
+/* ************************************************************************** */
+
+mng_retcode mng_read_graphic (mng_datap pData)
+{
+  mng_uint32  iBuflen;                 /* number of bytes requested */
+  mng_uint32  iRead;                   /* number of bytes read */
+  mng_retcode iRetcode;                /* temporary error-code */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_GRAPHIC, MNG_LC_START);
+#endif
+
+  if (!pData->pReadbuf)                /* buffer allocated ? */
+  {
+    pData->iReadbufsize = 4200;        /* allocate a default read buffer */
+    MNG_ALLOC (pData, pData->pReadbuf, pData->iReadbufsize);
+  }
+                                       /* haven't processed the signature ? */
+  if ((!pData->bHavesig) || (pData->iSuspendpoint == 1))
+  {
+    iBuflen = 2 * sizeof (mng_uint32); /* read signature */
+
+    iRetcode = read_databuffer (pData, pData->pReadbuf, &pData->pReadbufnext, iBuflen, &iRead);
+
+    if (iRetcode)
+      return iRetcode;
+
+    if (pData->bSuspended)             /* input suspension ? */
+      pData->iSuspendpoint = 1;
+    else
+    {
+      if (iRead != iBuflen)            /* full signature received ? */
+        MNG_ERROR (pData, MNG_UNEXPECTEDEOF);
+                                       /* is it a valid signature ? */
+      if (mng_get_uint32 (pData->pReadbuf) == PNG_SIG)
+        pData->eSigtype = mng_it_png;
+      else
+#ifdef MNG_INCLUDE_JNG
+      if (mng_get_uint32 (pData->pReadbuf) == JNG_SIG)
+        pData->eSigtype = mng_it_jng;
+      else
+#endif
+      if (mng_get_uint32 (pData->pReadbuf) == MNG_SIG)
+        pData->eSigtype = mng_it_mng;
+      else
+        MNG_ERROR (pData, MNG_INVALIDSIG);
+                                       /* all of it ? */
+      if (mng_get_uint32 (pData->pReadbuf+4) != POST_SIG)
+        MNG_ERROR (pData, MNG_INVALIDSIG);
+
+      pData->bHavesig = MNG_TRUE;
+    }
+  }
+
+  if (!pData->bSuspended)              /* still going ? */
+  {
+    do
+    {                                  /* reset timer during mng_read() ? */
+      if ((pData->bReading) && (!pData->bDisplaying))
+        pData->bTimerset = MNG_FALSE;
+
+      if (pData->pFirstpushchunk)      /* chunks pushed ? */
+        iRetcode = process_pushedchunk (pData); /* process the pushed chunk */
+      else
+        iRetcode = read_chunk (pData); /* read & process a chunk */
+
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+#ifdef MNG_SUPPORT_DISPLAY             /* until EOF or a break-request */
+    while (((!pData->bEOF) || (pData->pCurraniobj)) &&
+           (!pData->bSuspended) && (!pData->bSectionwait) &&
+           ((!pData->bTimerset) || ((pData->bReading) && (!pData->bDisplaying))));
+#else
+    while ((!pData->bEOF) && (!pData->bSuspended));
+#endif
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_READ_GRAPHIC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_READ_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_read.h b/src/3rdparty/libmng/libmng_read.h
new file mode 100644
index 0000000..119cc3e
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_read.h
@@ -0,0 +1,53 @@
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_read.h             copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.8                                                      * */
+/* *                                                                        * */
+/* * purpose   : Read management (definition)                               * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the read management routines                 * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 10/18/2000 - G.Juyn                                * */
+/* *             - added closestream() processing for mng_cleanup()         * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/12/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_read_h_
+#define _libmng_read_h_
+
+/* ************************************************************************** */
+
+mng_retcode mng_process_eof       (mng_datap pData);
+
+mng_retcode mng_release_pushdata  (mng_datap pData);
+
+mng_retcode mng_release_pushchunk (mng_datap pData);
+
+mng_retcode mng_read_graphic      (mng_datap pData);
+
+/* ************************************************************************** */
+
+#endif /* _libmng_read_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_trace.c b/src/3rdparty/libmng/libmng_trace.c
new file mode 100644
index 0000000..a6a2cab
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_trace.c
@@ -0,0 +1,1683 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_trace.c            copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Trace functions (implementation)                           * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the trace functions                      * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - added callback error-reporting support                   * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - added trace telltale reporting                           * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added tracestrings for global animation color-chunks     * */
+/* *             - added tracestrings for get/set of default ZLIB/IJG parms * */
+/* *             - added tracestrings for global PLTE,tRNS,bKGD             * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added tracestrings for image-object promotion            * */
+/* *             - added tracestrings for delta-image processing            * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - added tracestrings for getalphaline callback             * */
+/* *             0.5.2 - 06/05/2000 - G.Juyn                                * */
+/* *             - added tracestring for RGB8_A8 canvasstyle                * */
+/* *             0.5.2 - 06/06/2000 - G.Juyn                                * */
+/* *             - added tracestring for mng_read_resume HLAPI function     * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added tracestrings for get/set speedtype                 * */
+/* *             - added tracestring for get imagelevel                     * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - added tracestring for delta-image processing             * */
+/* *             - added tracestrings for PPLT chunk processing             * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/07/2000 - G.Juyn                                * */
+/* *             - added tracecodes for special display processing          * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - added tracestring for get/set suspensionmode             * */
+/* *             - added tracestrings for get/set display variables         * */
+/* *             - added tracecode for read_databuffer (I/O-suspension)     * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added tracestrings for SAVE/SEEK callbacks               * */
+/* *             - added tracestrings for get/set sectionbreaks             * */
+/* *             - added tracestring for special error routine              * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - added tracestring for updatemngheader                    * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - added tracestrings for status_xxxxx functions            * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *             - added tracestring for updatemngsimplicity                * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 10/10/2000 - G.Juyn                                * */
+/* *             - added support for alpha-depth prediction                 * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - added JDAA chunk                                         * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added functions to retrieve PNG/JNG specific header-info * */
+/* *             - added optional support for bKGD for PNG images           * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *             - added routine to discard "invalid" objects               * */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - implemented delayed delta-processing                     * */
+/* *             0.9.3 - 10/20/2000 - G.Juyn                                * */
+/* *             - added get/set for bKGD preference setting                * */
+/* *             0.9.3 - 10/21/2000 - G.Juyn                                * */
+/* *             - added get function for interlace/progressive display     * */
+/* *                                                                        * */
+/* *             0.9.4 -  1/18/2001 - G.Juyn                                * */
+/* *             - added "new" MAGN methods 3, 4 & 5                        * */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn (code by G.Kelly)              * */
+/* *             - added BGRA8 canvas with premultiplied alpha              * */
+/* *             1.0.1 - 05/02/2001 - G.Juyn                                * */
+/* *             - added "default" sRGB generation (Thanks Marti!)          * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *             - added processterm callback                               * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - added option to turn off progressive refresh             * */
+/* *                                                                        * */
+/* *             1.0.3 - 08/06/2001 - G.Juyn                                * */
+/* *             - added get function for last processed BACK chunk         * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             - completed delta-image support                            * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             - added HLAPI function to copy chunks                      * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 09/22/2002 - G.Juyn                                * */
+/* *             - added bgrx8 canvas (filler byte)                         * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - added in-memory color-correction of abstract images      * */
+/* *             - added compose over/under routines for PAST processing    * */
+/* *             - added flip & tile routines for PAST processing           * */
+/* *             1.0.5 - 10/09/2002 - G.Juyn                                * */
+/* *             - fixed trace-constants for PAST chunk                     * */
+/* *             1.0.5 - 11/07/2002 - G.Juyn                                * */
+/* *             - added support to get totals after mng_read()             * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added conditionals around JNG and Delta-PNG code         * */
+/* *             1.0.6 - 07/14/2003 - G.R-P                                 * */
+/* *             - added conditionals around various unused functions       * */
+/* *             1.0.6 - 07/29/2003 - G.R-P                                 * */
+/* *             - added conditionals around PAST chunk support             * */
+/* *                                                                        * */
+/* *             1.0.7 - 11/27/2003 - R.A                                   * */
+/* *             - added CANVAS_RGB565 and CANVAS_BGR565                    * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *             1.0.7 - 03/07/2004 - G. Randers-Pehrson                    * */
+/* *             - put gamma, cms-related declarations inside #ifdef        * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/02/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *             1.0.8 - 04/11/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *                                                                        * */
+/* *             1.0.9 - 10/03/2004 - G.Juyn                                * */
+/* *             - added function to retrieve current FRAM delay            * */
+/* *             1.0.9 - 10/14/2004 - G.Juyn                                * */
+/* *             - added bgr565_a8 canvas-style (thanks to J. Elvander)     * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 07/06/2007 - G.R-P bugfix by Lucas Quintana       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_TRACE_PROCS
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_TRACE_STRINGS
+MNG_LOCAL mng_trace_entry const trace_table [] =
+  {
+    {MNG_FN_INITIALIZE,                "initialize"},
+    {MNG_FN_RESET,                     "reset"},
+    {MNG_FN_CLEANUP,                   "cleanup"},
+    {MNG_FN_READ,                      "read"},
+    {MNG_FN_WRITE,                     "write"},
+    {MNG_FN_CREATE,                    "create"},
+    {MNG_FN_READDISPLAY,               "readdisplay"},
+    {MNG_FN_DISPLAY,                   "display"},
+    {MNG_FN_DISPLAY_RESUME,            "display_resume"},
+    {MNG_FN_DISPLAY_FREEZE,            "display_freeze"},
+    {MNG_FN_DISPLAY_RESET,             "display_reset"},
+#ifndef MNG_NO_DISPLAY_GO_SUPPORTED
+    {MNG_FN_DISPLAY_GOFRAME,           "display_goframe"},
+    {MNG_FN_DISPLAY_GOLAYER,           "display_golayer"},
+    {MNG_FN_DISPLAY_GOTIME,            "display_gotime"},
+#endif
+    {MNG_FN_GETLASTERROR,              "getlasterror"},
+    {MNG_FN_READ_RESUME,               "read_resume"},
+    {MNG_FN_TRAPEVENT,                 "trapevent"},
+    {MNG_FN_READ_PUSHDATA,             "read_pushdata"},
+    {MNG_FN_READ_PUSHSIG,              "read_pushsig"},
+    {MNG_FN_READ_PUSHCHUNK,            "read_pushchunk"},
+
+    {MNG_FN_SETCB_MEMALLOC,            "setcb_memalloc"},
+    {MNG_FN_SETCB_MEMFREE,             "setcb_memfree"},
+    {MNG_FN_SETCB_READDATA,            "setcb_readdata"},
+    {MNG_FN_SETCB_WRITEDATA,           "setcb_writedata"},
+    {MNG_FN_SETCB_ERRORPROC,           "setcb_errorproc"},
+    {MNG_FN_SETCB_TRACEPROC,           "setcb_traceproc"},
+    {MNG_FN_SETCB_PROCESSHEADER,       "setcb_processheader"},
+    {MNG_FN_SETCB_PROCESSTEXT,         "setcb_processtext"},
+    {MNG_FN_SETCB_GETCANVASLINE,       "setcb_getcanvasline"},
+    {MNG_FN_SETCB_GETBKGDLINE,         "setcb_getbkgdline"},
+    {MNG_FN_SETCB_REFRESH,             "setcb_refresh"},
+    {MNG_FN_SETCB_GETTICKCOUNT,        "setcb_gettickcount"},
+    {MNG_FN_SETCB_SETTIMER,            "setcb_settimer"},
+    {MNG_FN_SETCB_PROCESSGAMMA,        "setcb_processgamma"},
+    {MNG_FN_SETCB_PROCESSCHROMA,       "setcb_processchroma"},
+    {MNG_FN_SETCB_PROCESSSRGB,         "setcb_processsrgb"},
+    {MNG_FN_SETCB_PROCESSICCP,         "setcb_processiccp"},
+    {MNG_FN_SETCB_PROCESSAROW,         "setcb_processarow"},
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+    {MNG_FN_SETCB_OPENSTREAM,          "setcb_openstream"},
+    {MNG_FN_SETCB_CLOSESTREAM,         "setcb_closestream"},
+#endif
+    {MNG_FN_SETCB_GETALPHALINE,        "setcb_getalphaline"},
+    {MNG_FN_SETCB_PROCESSSAVE,         "setcb_processsave"},
+    {MNG_FN_SETCB_PROCESSSEEK,         "setcb_processseek"},
+    {MNG_FN_SETCB_PROCESSNEED,         "setcb_processneed"},
+    {MNG_FN_SETCB_PROCESSUNKNOWN,      "setcb_processunknown"},
+    {MNG_FN_SETCB_PROCESSMEND,         "setcb_processmend"},
+    {MNG_FN_SETCB_PROCESSTERM,         "setcb_processterm"},
+    {MNG_FN_SETCB_RELEASEDATA,         "setcb_releasedata"},
+
+    {MNG_FN_GETCB_MEMALLOC,            "getcb_memalloc"},
+    {MNG_FN_GETCB_MEMFREE,             "getcb_memfree"},
+    {MNG_FN_GETCB_READDATA,            "getcb_readdata,"},
+    {MNG_FN_GETCB_WRITEDATA,           "getcb_writedata"},
+    {MNG_FN_GETCB_ERRORPROC,           "getcb_errorproc"},
+    {MNG_FN_GETCB_TRACEPROC,           "getcb_traceproc"},
+    {MNG_FN_GETCB_PROCESSHEADER,       "getcb_processheader"},
+    {MNG_FN_GETCB_PROCESSTEXT,         "getcb_processtext"},
+    {MNG_FN_GETCB_GETCANVASLINE,       "getcb_getcanvasline"},
+    {MNG_FN_GETCB_GETBKGDLINE,         "getcb_getbkgdline"},
+    {MNG_FN_GETCB_REFRESH,             "getcb_refresh"},
+    {MNG_FN_GETCB_GETTICKCOUNT,        "getcb_gettickcount"},
+    {MNG_FN_GETCB_SETTIMER,            "getcb_settimer"},
+    {MNG_FN_GETCB_PROCESSGAMMA,        "getcb_processgamma"},
+    {MNG_FN_GETCB_PROCESSCHROMA,       "getcb_processchroma"},
+    {MNG_FN_GETCB_PROCESSSRGB,         "getcb_processsrgb"},
+    {MNG_FN_GETCB_PROCESSICCP,         "getcb_processiccp"},
+    {MNG_FN_GETCB_PROCESSAROW,         "getcb_processarow"},
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+    {MNG_FN_GETCB_OPENSTREAM,          "getcb_openstream"},
+    {MNG_FN_GETCB_CLOSESTREAM,         "getcb_closestream"},
+#endif
+    {MNG_FN_GETCB_GETALPHALINE,        "getcb_getalphaline"},
+    {MNG_FN_GETCB_PROCESSSAVE,         "getcb_processsave"},
+    {MNG_FN_GETCB_PROCESSSEEK,         "getcb_processseek"},
+    {MNG_FN_GETCB_PROCESSNEED,         "getcb_processneed"},
+    {MNG_FN_GETCB_PROCESSUNKNOWN,      "getcb_processunknown"},
+    {MNG_FN_GETCB_PROCESSMEND,         "getcb_processmend"},
+    {MNG_FN_GETCB_PROCESSTERM,         "getcb_processterm"},
+    {MNG_FN_GETCB_RELEASEDATA,         "getcb_releasedata"},
+
+    {MNG_FN_SET_USERDATA,              "set_userdata"},
+    {MNG_FN_SET_CANVASSTYLE,           "set_canvasstyle"},
+    {MNG_FN_SET_BKGDSTYLE,             "set_bkgdstyle"},
+    {MNG_FN_SET_BGCOLOR,               "set_bgcolor"},
+    {MNG_FN_SET_STORECHUNKS,           "set_storechunks"},
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+    {MNG_FN_SET_VIEWGAMMA,             "set_viewgamma"},
+#ifndef MNG_NO_DFLT_INFO
+    {MNG_FN_SET_DISPLAYGAMMA,          "set_displaygamma"},
+#endif
+    {MNG_FN_SET_DFLTIMGGAMMA,          "set_dfltimggamma"},
+#endif
+    {MNG_FN_SET_SRGB,                  "set_srgb"},
+    {MNG_FN_SET_OUTPUTPROFILE,         "set_outputprofile"},
+    {MNG_FN_SET_SRGBPROFILE,           "set_srgbprofile"},
+#ifndef MNG_SKIP_MAXCANVAS
+    {MNG_FN_SET_MAXCANVASWIDTH,        "set_maxcanvaswidth"},
+    {MNG_FN_SET_MAXCANVASHEIGHT,       "set_maxcanvasheight"},
+    {MNG_FN_SET_MAXCANVASSIZE,         "set_maxcanvassize"},
+#endif
+#ifndef MNG_NO_ACCESS_ZLIB
+    {MNG_FN_SET_ZLIB_LEVEL,            "set_zlib_level"},
+    {MNG_FN_SET_ZLIB_METHOD,           "set_zlib_method"},
+    {MNG_FN_SET_ZLIB_WINDOWBITS,       "set_zlib_windowbits"},
+    {MNG_FN_SET_ZLIB_MEMLEVEL,         "set_zlib_memlevel"},
+    {MNG_FN_SET_ZLIB_STRATEGY,         "set_zlib_strategy"},
+    {MNG_FN_SET_ZLIB_MAXIDAT,          "set_zlib_maxidat"},
+#endif
+#ifndef MNG_NO_ACCESS_JPEG
+    {MNG_FN_SET_JPEG_DCTMETHOD,        "set_jpeg_dctmethod"},
+    {MNG_FN_SET_JPEG_QUALITY,          "set_jpeg_quality"},
+    {MNG_FN_SET_JPEG_SMOOTHING,        "set_jpeg_smoothing"},
+    {MNG_FN_SET_JPEG_PROGRESSIVE,      "set_jpeg_progressive"},
+    {MNG_FN_SET_JPEG_OPTIMIZED,        "set_jpeg_optimized"},
+    {MNG_FN_SET_JPEG_MAXJDAT,          "set_jpeg_maxjdat"},
+#endif
+    {MNG_FN_SET_SPEED,                 "set_speed"},
+    {MNG_FN_SET_SUSPENSIONMODE,        "set_suspensionmode"},
+    {MNG_FN_SET_SECTIONBREAKS,         "set_sectionbreaks"},
+    {MNG_FN_SET_USEBKGD,               "set_usebkgd"},
+    {MNG_FN_SET_OUTPUTPROFILE2,        "set_outputprofile2"},
+    {MNG_FN_SET_SRGBPROFILE2,          "set_srgbprofile2"},
+    {MNG_FN_SET_OUTPUTSRGB,            "set_outputsrgb"},
+    {MNG_FN_SET_SRGBIMPLICIT,          "set_srgbimplicit"},
+    {MNG_FN_SET_CACHEPLAYBACK,         "set_cacheplayback"},
+    {MNG_FN_SET_DOPROGRESSIVE,         "set_doprogressive"},
+    {MNG_FN_SET_CRCMODE,               "set_crcmode"},
+
+    {MNG_FN_GET_USERDATA,              "get_userdata"},
+    {MNG_FN_GET_SIGTYPE,               "get_sigtype"},
+    {MNG_FN_GET_IMAGETYPE,             "get_imagetype"},
+    {MNG_FN_GET_IMAGEWIDTH,            "get_imagewidth"},
+    {MNG_FN_GET_IMAGEHEIGHT,           "get_imageheight"},
+    {MNG_FN_GET_TICKS,                 "get_ticks"},
+    {MNG_FN_GET_FRAMECOUNT,            "get_framecount"},
+    {MNG_FN_GET_LAYERCOUNT,            "get_layercount"},
+    {MNG_FN_GET_PLAYTIME,              "get_playtime"},
+    {MNG_FN_GET_SIMPLICITY,            "get_simplicity"},
+    {MNG_FN_GET_CANVASSTYLE,           "get_canvasstyle"},
+    {MNG_FN_GET_BKGDSTYLE,             "get_bkgdstyle"},
+    {MNG_FN_GET_BGCOLOR,               "get_bgcolor"},
+    {MNG_FN_GET_STORECHUNKS,           "get_storechunks"},
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+    {MNG_FN_GET_VIEWGAMMA,             "get_viewgamma"},
+    {MNG_FN_GET_DISPLAYGAMMA,          "get_displaygamma"},
+#ifndef MNG_NO_DFLT_INFO
+    {MNG_FN_GET_DFLTIMGGAMMA,          "get_dfltimggamma"},
+#endif
+#endif
+    {MNG_FN_GET_SRGB,                  "get_srgb"},
+#ifndef MNG_SKIP_MAXCANVAS
+    {MNG_FN_GET_MAXCANVASWIDTH,        "get_maxcanvaswidth"},
+    {MNG_FN_GET_MAXCANVASHEIGHT,       "get_maxcanvasheight"},
+#endif
+#ifndef MNG_NO_ACCESS_ZLIB
+    {MNG_FN_GET_ZLIB_LEVEL,            "get_zlib_level"},
+    {MNG_FN_GET_ZLIB_METHOD,           "get_zlib_method"},
+    {MNG_FN_GET_ZLIB_WINDOWBITS,       "get_zlib_windowbits"},
+    {MNG_FN_GET_ZLIB_MEMLEVEL,         "get_zlib_memlevel"},
+    {MNG_FN_GET_ZLIB_STRATEGY,         "get_zlib_strategy"},
+    {MNG_FN_GET_ZLIB_MAXIDAT,          "get_zlib_maxidat"},
+#endif
+#ifndef MNG_NO_ACCESS_JPEG
+    {MNG_FN_GET_JPEG_DCTMETHOD,        "get_jpeg_dctmethod"},
+    {MNG_FN_GET_JPEG_QUALITY,          "get_jpeg_quality"},
+    {MNG_FN_GET_JPEG_SMOOTHING,        "get_jpeg_smoothing"},
+    {MNG_FN_GET_JPEG_PROGRESSIVE,      "get_jpeg_progressive"},
+    {MNG_FN_GET_JPEG_OPTIMIZED,        "get_jpeg_optimized"},
+    {MNG_FN_GET_JPEG_MAXJDAT,          "get_jpeg_maxjdat"},
+#endif
+    {MNG_FN_GET_SPEED,                 "get_speed"},
+    {MNG_FN_GET_IMAGELEVEL,            "get_imagelevel"},
+    {MNG_FN_GET_SUSPENSIONMODE,        "get_speed"},
+    {MNG_FN_GET_STARTTIME,             "get_starttime"},
+    {MNG_FN_GET_RUNTIME,               "get_runtime"},
+#ifndef MNG_NO_CURRENT_INFO
+    {MNG_FN_GET_CURRENTFRAME,          "get_currentframe"},
+    {MNG_FN_GET_CURRENTLAYER,          "get_currentlayer"},
+    {MNG_FN_GET_CURRENTPLAYTIME,       "get_currentplaytime"},
+#endif
+    {MNG_FN_GET_SECTIONBREAKS,         "get_sectionbreaks"},
+    {MNG_FN_GET_ALPHADEPTH,            "get_alphadepth"},
+    {MNG_FN_GET_BITDEPTH,              "get_bitdepth"},
+    {MNG_FN_GET_COLORTYPE,             "get_colortype"},
+    {MNG_FN_GET_COMPRESSION,           "get_compression"},
+    {MNG_FN_GET_FILTER,                "get_filter"},
+    {MNG_FN_GET_INTERLACE,             "get_interlace"},
+    {MNG_FN_GET_ALPHABITDEPTH,         "get_alphabitdepth"},
+    {MNG_FN_GET_ALPHACOMPRESSION,      "get_alphacompression"},
+    {MNG_FN_GET_ALPHAFILTER,           "get_alphafilter"},
+    {MNG_FN_GET_ALPHAINTERLACE,        "get_alphainterlace"},
+    {MNG_FN_GET_USEBKGD,               "get_usebkgd"},
+    {MNG_FN_GET_REFRESHPASS,           "get_refreshpass"},
+    {MNG_FN_GET_CACHEPLAYBACK,         "get_cacheplayback"},
+    {MNG_FN_GET_DOPROGRESSIVE,         "get_doprogressive"},
+    {MNG_FN_GET_LASTBACKCHUNK,         "get_lastbackchunk"},
+    {MNG_FN_GET_LASTSEEKNAME,          "get_lastseekname"},
+#ifndef MNG_NO_CURRENT_INFO
+    {MNG_FN_GET_TOTALFRAMES,           "get_totalframes"},
+    {MNG_FN_GET_TOTALLAYERS,           "get_totallayers"},
+    {MNG_FN_GET_TOTALPLAYTIME,         "get_totalplaytime"},
+#endif
+    {MNG_FN_GET_CRCMODE,               "get_crcmode"},
+    {MNG_FN_GET_CURRFRAMDELAY,         "get_currframdelay"},
+
+    {MNG_FN_STATUS_ERROR,              "status_error"},
+    {MNG_FN_STATUS_READING,            "status_reading"},
+    {MNG_FN_STATUS_SUSPENDBREAK,       "status_suspendbreak"},
+    {MNG_FN_STATUS_CREATING,           "status_creating"},
+    {MNG_FN_STATUS_WRITING,            "status_writing"},
+    {MNG_FN_STATUS_DISPLAYING,         "status_displaying"},
+    {MNG_FN_STATUS_RUNNING,            "status_running"},
+    {MNG_FN_STATUS_TIMERBREAK,         "status_timerbreak"},
+    {MNG_FN_STATUS_DYNAMIC,            "status_dynamic"},
+    {MNG_FN_STATUS_RUNNINGEVENT,       "status_runningevent"},
+
+    {MNG_FN_ITERATE_CHUNKS,            "iterate_chunks"},
+    {MNG_FN_COPY_CHUNK,                "copy_chunk"},
+
+    {MNG_FN_GETCHUNK_IHDR,             "getchunk_ihdr"},
+    {MNG_FN_GETCHUNK_PLTE,             "getchunk_plte"},
+    {MNG_FN_GETCHUNK_IDAT,             "getchunk_idat"},
+    {MNG_FN_GETCHUNK_IEND,             "getchunk_iend"},
+    {MNG_FN_GETCHUNK_TRNS,             "getchunk_trns"},
+#ifndef MNG_SKIPCHUNK_gAMA
+    {MNG_FN_GETCHUNK_GAMA,             "getchunk_gama"},
+#endif
+#ifndef MNG_SKIPCHUNK_cHRM
+    {MNG_FN_GETCHUNK_CHRM,             "getchunk_chrm"},
+#endif
+#ifndef MNG_SKIPCHUNK_sRGB
+    {MNG_FN_GETCHUNK_SRGB,             "getchunk_srgb"},
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+    {MNG_FN_GETCHUNK_ICCP,             "getchunk_iccp"},
+#endif
+#ifndef MNG_SKIPCHUNK_tEXt
+    {MNG_FN_GETCHUNK_TEXT,             "getchunk_text"},
+#endif
+#ifndef MNG_SKIPCHUNK_zTXt
+    {MNG_FN_GETCHUNK_ZTXT,             "getchunk_ztxt"},
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+    {MNG_FN_GETCHUNK_ITXT,             "getchunk_itxt"},
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+    {MNG_FN_GETCHUNK_BKGD,             "getchunk_bkgd"},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+    {MNG_FN_GETCHUNK_PHYS,             "getchunk_phys"},
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+    {MNG_FN_GETCHUNK_SBIT,             "getchunk_sbit"},
+#endif
+#ifndef MNG_SKIPCHUNK_sPLT
+    {MNG_FN_GETCHUNK_SPLT,             "getchunk_splt"},
+#endif
+#ifndef MNG_SKIPCHUNK_hIST
+    {MNG_FN_GETCHUNK_HIST,             "getchunk_hist"},
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+    {MNG_FN_GETCHUNK_TIME,             "getchunk_time"},
+#endif
+    {MNG_FN_GETCHUNK_MHDR,             "getchunk_mhdr"},
+    {MNG_FN_GETCHUNK_MEND,             "getchunk_mend"},
+#ifndef MNG_SKIPCHUNK_LOOP
+    {MNG_FN_GETCHUNK_LOOP,             "getchunk_loop"},
+    {MNG_FN_GETCHUNK_ENDL,             "getchunk_endl"},
+#endif
+    {MNG_FN_GETCHUNK_DEFI,             "getchunk_defi"},
+#ifndef MNG_SKIPCHUNK_BASI
+    {MNG_FN_GETCHUNK_BASI,             "getchunk_basi"},
+#endif
+    {MNG_FN_GETCHUNK_CLON,             "getchunk_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_GETCHUNK_PAST,             "getchunk_past"},
+#endif
+    {MNG_FN_GETCHUNK_DISC,             "getchunk_disc"},
+    {MNG_FN_GETCHUNK_BACK,             "getchunk_back"},
+    {MNG_FN_GETCHUNK_FRAM,             "getchunk_fram"},
+    {MNG_FN_GETCHUNK_MOVE,             "getchunk_move"},
+    {MNG_FN_GETCHUNK_CLIP,             "getchunk_clip"},
+    {MNG_FN_GETCHUNK_SHOW,             "getchunk_show"},
+    {MNG_FN_GETCHUNK_TERM,             "getchunk_term"},
+#ifndef MNG_SKIPCHUNK_SAVE
+    {MNG_FN_GETCHUNK_SAVE,             "getchunk_save"},
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+    {MNG_FN_GETCHUNK_SEEK,             "getchunk_seek"},
+#endif
+#ifndef MNG_SKIPCHUNK_eXPI
+    {MNG_FN_GETCHUNK_EXPI,             "getchunk_expi"},
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+    {MNG_FN_GETCHUNK_FPRI,             "getchunk_fpri"},
+#endif
+#ifndef MNG_SKIPCHUNK_nEED
+    {MNG_FN_GETCHUNK_NEED,             "getchunk_need"},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYg
+    {MNG_FN_GETCHUNK_PHYG,             "getchunk_phyg"},
+#endif
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_GETCHUNK_JHDR,             "getchunk_jhdr"},
+    {MNG_FN_GETCHUNK_JDAT,             "getchunk_jdat"},
+    {MNG_FN_GETCHUNK_JSEP,             "getchunk_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_GETCHUNK_DHDR,             "getchunk_dhdr"},
+    {MNG_FN_GETCHUNK_PROM,             "getchunk_prom"},
+    {MNG_FN_GETCHUNK_IPNG,             "getchunk_ipng"},
+    {MNG_FN_GETCHUNK_PPLT,             "getchunk_pplt"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_GETCHUNK_IJNG,             "getchunk_ijng"},
+#endif
+#ifndef MNG_SKIPCHUNK_DROP
+    {MNG_FN_GETCHUNK_DROP,             "getchunk_drop"},
+#endif
+#ifndef MNG_SKIPCHUNK_DBYK
+    {MNG_FN_GETCHUNK_DBYK,             "getchunk_dbyk"},
+#endif
+#ifndef MNG_SKIPCHUNK_ORDR
+    {MNG_FN_GETCHUNK_ORDR,             "getchunk_ordr"},
+#endif
+#endif
+    {MNG_FN_GETCHUNK_UNKNOWN,          "getchunk_unknown"},
+    {MNG_FN_GETCHUNK_MAGN,             "getchunk_magn"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_GETCHUNK_JDAA,             "getchunk_jdaa"},
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_FN_GETCHUNK_EVNT,             "getchunk_evnt"},
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_GETCHUNK_MPNG,             "getchunk_mpng"},
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_GETCHUNK_PAST_SRC,         "getchunk_past_src"},
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+    {MNG_FN_GETCHUNK_SAVE_ENTRY,       "getchunk_save_entry"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_GETCHUNK_PPLT_ENTRY,       "getchunk_pplt_entry"},
+    {MNG_FN_GETCHUNK_ORDR_ENTRY,       "getchunk_ordr_entry"},
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_FN_GETCHUNK_EVNT_ENTRY,       "getchunk_evnt_entry"},
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_GETCHUNK_MPNG_FRAME,       "getchunk_mpng_frame"},
+#endif
+
+    {MNG_FN_PUTCHUNK_IHDR,             "putchunk_ihdr"},
+    {MNG_FN_PUTCHUNK_PLTE,             "putchunk_plte"},
+    {MNG_FN_PUTCHUNK_IDAT,             "putchunk_idat"},
+    {MNG_FN_PUTCHUNK_IEND,             "putchunk_iend"},
+    {MNG_FN_PUTCHUNK_TRNS,             "putchunk_trns"},
+#ifndef MNG_SKIPCHUNK_gAMA
+    {MNG_FN_PUTCHUNK_GAMA,             "putchunk_gama"},
+#endif
+#ifndef MNG_SKIPCHUNK_cHRM
+    {MNG_FN_PUTCHUNK_CHRM,             "putchunk_chrm"},
+#endif
+#ifndef MNG_SKIPCHUNK_sRGB
+    {MNG_FN_PUTCHUNK_SRGB,             "putchunk_srgb"},
+#endif
+#ifndef MNG_SKIPCHUNK_iCCP
+    {MNG_FN_PUTCHUNK_ICCP,             "putchunk_iccp"},
+#endif
+#ifndef MNG_SKIPCHUNK_tEXt
+    {MNG_FN_PUTCHUNK_TEXT,             "putchunk_text"},
+#endif
+#ifndef MNG_SKIPCHUNK_zTXt
+    {MNG_FN_PUTCHUNK_ZTXT,             "putchunk_ztxt"},
+#endif
+#ifndef MNG_SKIPCHUNK_iTXt
+    {MNG_FN_PUTCHUNK_ITXT,             "putchunk_itxt"},
+#endif
+#ifndef MNG_SKIPCHUNK_bKGD
+    {MNG_FN_PUTCHUNK_BKGD,             "putchunk_bkgd"},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYs
+    {MNG_FN_PUTCHUNK_PHYS,             "putchunk_phys"},
+#endif
+#ifndef MNG_SKIPCHUNK_sBIT
+    {MNG_FN_PUTCHUNK_SBIT,             "putchunk_sbit"},
+#endif
+#ifndef MNG_SKIPCHUNK_sPLT
+    {MNG_FN_PUTCHUNK_SPLT,             "putchunk_splt"},
+#endif
+#ifndef MNG_SKIPCHUNK_hIST
+    {MNG_FN_PUTCHUNK_HIST,             "putchunk_hist"},
+#endif
+#ifndef MNG_SKIPCHUNK_tIME
+    {MNG_FN_PUTCHUNK_TIME,             "putchunk_time"},
+#endif
+    {MNG_FN_PUTCHUNK_MHDR,             "putchunk_mhdr"},
+    {MNG_FN_PUTCHUNK_MEND,             "putchunk_mend"},
+    {MNG_FN_PUTCHUNK_LOOP,             "putchunk_loop"},
+    {MNG_FN_PUTCHUNK_ENDL,             "putchunk_endl"},
+    {MNG_FN_PUTCHUNK_DEFI,             "putchunk_defi"},
+    {MNG_FN_PUTCHUNK_BASI,             "putchunk_basi"},
+    {MNG_FN_PUTCHUNK_CLON,             "putchunk_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_PUTCHUNK_PAST,             "putchunk_past"},
+#endif
+    {MNG_FN_PUTCHUNK_DISC,             "putchunk_disc"},
+    {MNG_FN_PUTCHUNK_BACK,             "putchunk_back"},
+    {MNG_FN_PUTCHUNK_FRAM,             "putchunk_fram"},
+    {MNG_FN_PUTCHUNK_MOVE,             "putchunk_move"},
+    {MNG_FN_PUTCHUNK_CLIP,             "putchunk_clip"},
+    {MNG_FN_PUTCHUNK_SHOW,             "putchunk_show"},
+    {MNG_FN_PUTCHUNK_TERM,             "putchunk_term"},
+#ifndef MNG_SKIPCHUNK_SAVE
+    {MNG_FN_PUTCHUNK_SAVE,             "putchunk_save"},
+#endif
+#ifndef MNG_SKIPCHUNK_SEEK
+    {MNG_FN_PUTCHUNK_SEEK,             "putchunk_seek"},
+#endif
+#ifndef MNG_SKIPCHUNK_eXPI
+    {MNG_FN_PUTCHUNK_EXPI,             "putchunk_expi"},
+#endif
+#ifndef MNG_SKIPCHUNK_fPRI
+    {MNG_FN_PUTCHUNK_FPRI,             "putchunk_fpri"},
+#endif
+#ifndef MNG_SKIPCHUNK_nEED
+    {MNG_FN_PUTCHUNK_NEED,             "putchunk_need"},
+#endif
+#ifndef MNG_SKIPCHUNK_pHYg
+    {MNG_FN_PUTCHUNK_PHYG,             "putchunk_phyg"},
+#endif
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_PUTCHUNK_JHDR,             "putchunk_jhdr"},
+    {MNG_FN_PUTCHUNK_JDAT,             "putchunk_jdat"},
+    {MNG_FN_PUTCHUNK_JSEP,             "putchunk_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_PUTCHUNK_DHDR,             "putchunk_dhdr"},
+    {MNG_FN_PUTCHUNK_PROM,             "putchunk_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_PUTCHUNK_IPNG,             "putchunk_ipng"},
+#endif
+    {MNG_FN_PUTCHUNK_PPLT,             "putchunk_pplt"},
+    {MNG_FN_PUTCHUNK_IJNG,             "putchunk_ijng"},
+#ifndef MNG_SKIPCHUNK_DROP
+    {MNG_FN_PUTCHUNK_DROP,             "putchunk_drop"},
+#endif
+#ifndef MNG_SKIPCHUNK_DBYK
+    {MNG_FN_PUTCHUNK_DBYK,             "putchunk_dbyk"},
+#endif
+#ifndef MNG_SKIPCHUNK_ORDR
+    {MNG_FN_PUTCHUNK_ORDR,             "putchunk_ordr"},
+#endif
+#endif
+    {MNG_FN_PUTCHUNK_UNKNOWN,          "putchunk_unknown"},
+    {MNG_FN_PUTCHUNK_MAGN,             "putchunk_magn"},
+    {MNG_FN_PUTCHUNK_JDAA,             "putchunk_jdaa"},
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_FN_PUTCHUNK_EVNT,             "putchunk_evnt"},
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_PUTCHUNK_MPNG,             "putchunk_mpng"},
+#endif
+
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_PUTCHUNK_PAST_SRC,         "putchunk_past_src"},
+#endif
+#ifndef MNG_SKIPCHUNK_SAVE
+    {MNG_FN_PUTCHUNK_SAVE_ENTRY,       "putchunk_save_entry"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_PUTCHUNK_PPLT_ENTRY,       "putchunk_pplt_entry"},
+#ifndef MNG_SKIPCHUNK_ORDR
+    {MNG_FN_PUTCHUNK_ORDR_ENTRY,       "putchunk_ordr_entry"},
+#endif
+#endif
+#ifndef MNG_SKIPCHUNK_evNT
+    {MNG_FN_PUTCHUNK_EVNT_ENTRY,       "putchunk_evnt_entry"},
+#endif
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_PUTCHUNK_MPNG_FRAME,       "putchunk_mpng_frame"},
+#endif
+
+    {MNG_FN_GETIMGDATA_SEQ,            "getimgdata_seq"},
+    {MNG_FN_GETIMGDATA_CHUNKSEQ,       "getimgdata_chunkseq"},
+    {MNG_FN_GETIMGDATA_CHUNK,          "getimgdata_chunk"},
+
+    {MNG_FN_PUTIMGDATA_IHDR,           "putimgdata_ihdr"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_PUTIMGDATA_JHDR,           "putimgdata_jhdr"},
+    {MNG_FN_PUTIMGDATA_BASI,           "putimgdata_basi"},
+    {MNG_FN_PUTIMGDATA_DHDR,           "putimgdata_dhdr"},
+#endif
+
+    {MNG_FN_UPDATEMNGHEADER,           "updatemngheader"},
+    {MNG_FN_UPDATEMNGSIMPLICITY,       "updatemngsimplicity"},
+
+    {MNG_FN_PROCESS_RAW_CHUNK,         "process_raw_chunk"},
+    {MNG_FN_READ_GRAPHIC,              "read_graphic"},
+    {MNG_FN_DROP_CHUNKS,               "drop_chunks"},
+    {MNG_FN_PROCESS_ERROR,             "process_error"},
+    {MNG_FN_CLEAR_CMS,                 "clear_cms"},
+    {MNG_FN_DROP_OBJECTS,              "drop_objects"},
+    {MNG_FN_READ_CHUNK,                "read_chunk"},
+    {MNG_FN_LOAD_BKGDLAYER,            "load_bkgdlayer"},
+    {MNG_FN_NEXT_FRAME,                "next_frame"},
+    {MNG_FN_NEXT_LAYER,                "next_layer"},
+    {MNG_FN_INTERFRAME_DELAY,          "interframe_delay"},
+    {MNG_FN_DISPLAY_IMAGE,             "display_image"},
+    {MNG_FN_DROP_IMGOBJECTS,           "drop_imgobjects"},
+    {MNG_FN_DROP_ANIOBJECTS,           "drop_aniobjects"},
+    {MNG_FN_INFLATE_BUFFER,            "inflate_buffer"},
+    {MNG_FN_DEFLATE_BUFFER,            "deflate_buffer"},
+    {MNG_FN_WRITE_RAW_CHUNK,           "write_raw_chunk"},
+    {MNG_FN_WRITE_GRAPHIC,             "write_graphic"},
+    {MNG_FN_SAVE_STATE,                "save_state"},
+    {MNG_FN_RESTORE_STATE,             "restore_state"},
+    {MNG_FN_DROP_SAVEDATA,             "drop_savedata"},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_EXECUTE_DELTA_IMAGE,       "execute_delta_image"},
+#endif
+    {MNG_FN_PROCESS_DISPLAY,           "process_display"},
+    {MNG_FN_CLEAR_CANVAS,              "clear_canvas"},
+    {MNG_FN_READ_DATABUFFER,           "read_databuffer"},
+    {MNG_FN_STORE_ERROR,               "store_error"},
+    {MNG_FN_DROP_INVALID_OBJECTS,      "drop_invalid_objects"},
+    {MNG_FN_RELEASE_PUSHDATA,          "release_pushdata"},
+    {MNG_FN_READ_DATA,                 "read_data"},
+    {MNG_FN_READ_CHUNK_CRC,            "read_chunk_crc"},
+    {MNG_FN_RELEASE_PUSHCHUNK,         "release_pushchunk"},
+
+    {MNG_FN_DISPLAY_RGB8,              "display_rgb8"},
+    {MNG_FN_DISPLAY_RGBA8,             "display_rgba8"},
+    {MNG_FN_DISPLAY_ARGB8,             "display_argb8"},
+    {MNG_FN_DISPLAY_BGR8,              "display_bgr8"},
+    {MNG_FN_DISPLAY_BGRA8,             "display_bgra8"},
+    {MNG_FN_DISPLAY_ABGR8,             "display_abgr8"},
+    {MNG_FN_DISPLAY_RGB16,             "display_rgb16"},
+    {MNG_FN_DISPLAY_RGBA16,            "display_rgba16"},
+    {MNG_FN_DISPLAY_ARGB16,            "display_argb16"},
+    {MNG_FN_DISPLAY_BGR16,             "display_bgr16"},
+    {MNG_FN_DISPLAY_BGRA16,            "display_bgra16"},
+    {MNG_FN_DISPLAY_ABGR16,            "display_abgr16"},
+    {MNG_FN_DISPLAY_INDEX8,            "display_index8"},
+    {MNG_FN_DISPLAY_INDEXA8,           "display_indexa8"},
+    {MNG_FN_DISPLAY_AINDEX8,           "display_aindex8"},
+    {MNG_FN_DISPLAY_GRAY8,             "display_gray8"},
+    {MNG_FN_DISPLAY_GRAY16,            "display_gray16"},
+    {MNG_FN_DISPLAY_GRAYA8,            "display_graya8"},
+    {MNG_FN_DISPLAY_GRAYA16,           "display_graya16"},
+    {MNG_FN_DISPLAY_AGRAY8,            "display_agray8"},
+    {MNG_FN_DISPLAY_AGRAY16,           "display_agray16"},
+    {MNG_FN_DISPLAY_DX15,              "display_dx15"},
+    {MNG_FN_DISPLAY_DX16,              "display_dx16"},
+    {MNG_FN_DISPLAY_RGB8_A8,           "display_rgb8_a8"},
+    {MNG_FN_DISPLAY_BGRA8PM,           "display_bgra8_pm"},
+    {MNG_FN_DISPLAY_BGRX8,             "display_bgrx8"},
+    {MNG_FN_DISPLAY_RGB565,            "display_rgb565"},
+    {MNG_FN_DISPLAY_RGBA565,           "display_rgba565"},
+    {MNG_FN_DISPLAY_BGR565,            "display_bgr565"},
+    {MNG_FN_DISPLAY_BGRA565,           "display_bgra565"},
+    {MNG_FN_DISPLAY_RGBA8_PM,          "display_rgba8_pm"},
+    {MNG_FN_DISPLAY_ARGB8_PM,          "display_argb8_pm"},
+    {MNG_FN_DISPLAY_ABGR8_PM,          "display_abgr8_pm"},
+    {MNG_FN_DISPLAY_BGR565_A8,         "display_bgr565_a8"},
+
+    {MNG_FN_INIT_FULL_CMS,             "init_full_cms"},
+    {MNG_FN_CORRECT_FULL_CMS,          "correct_full_cms"},
+    {MNG_FN_INIT_GAMMA_ONLY,           "init_gamma_only"},
+    {MNG_FN_CORRECT_GAMMA_ONLY,        "correct_gamma_only"},
+    {MNG_FN_CORRECT_APP_CMS,           "correct_app_cms"},
+    {MNG_FN_INIT_FULL_CMS_OBJ,         "init_full_cms_obj"},
+    {MNG_FN_INIT_GAMMA_ONLY_OBJ,       "init_gamma_only_obj"},
+    {MNG_FN_INIT_APP_CMS,              "init_app_cms"},
+    {MNG_FN_INIT_APP_CMS_OBJ,          "init_app_cms_obj"},
+
+    {MNG_FN_PROCESS_G1,                "process_g1"},
+    {MNG_FN_PROCESS_G2,                "process_g2"},
+    {MNG_FN_PROCESS_G4,                "process_g4"},
+    {MNG_FN_PROCESS_G8,                "process_g8"},
+    {MNG_FN_PROCESS_G16,               "process_g16"},
+    {MNG_FN_PROCESS_RGB8,              "process_rgb8"},
+    {MNG_FN_PROCESS_RGB16,             "process_rgb16"},
+    {MNG_FN_PROCESS_IDX1,              "process_idx1"},
+    {MNG_FN_PROCESS_IDX2,              "process_idx2"},
+    {MNG_FN_PROCESS_IDX4,              "process_idx4"},
+    {MNG_FN_PROCESS_IDX8,              "process_idx8"},
+    {MNG_FN_PROCESS_GA8,               "process_ga8"},
+    {MNG_FN_PROCESS_GA16,              "process_ga16"},
+    {MNG_FN_PROCESS_RGBA8,             "process_rgba8"},
+    {MNG_FN_PROCESS_RGBA16,            "process_rgba16"},
+
+    {MNG_FN_INIT_G1_I,                 "init_g1_i"},
+    {MNG_FN_INIT_G2_I,                 "init_g2_i"},
+    {MNG_FN_INIT_G4_I,                 "init_g4_i"},
+    {MNG_FN_INIT_G8_I,                 "init_g8_i"},
+    {MNG_FN_INIT_G16_I,                "init_g16_i"},
+    {MNG_FN_INIT_RGB8_I,               "init_rgb8_i"},
+    {MNG_FN_INIT_RGB16_I,              "init_rgb16_i"},
+    {MNG_FN_INIT_IDX1_I,               "init_idx1_i"},
+    {MNG_FN_INIT_IDX2_I,               "init_idx2_i"},
+    {MNG_FN_INIT_IDX4_I,               "init_idx4_i"},
+    {MNG_FN_INIT_IDX8_I,               "init_idx8_i"},
+    {MNG_FN_INIT_GA8_I,                "init_ga8_i"},
+    {MNG_FN_INIT_GA16_I,               "init_ga16_i"},
+    {MNG_FN_INIT_RGBA8_I,              "init_rgba8_i"},
+    {MNG_FN_INIT_RGBA16_I,             "init_rgba16_i"},
+#ifndef MNG_OPTIMIZE_FOOTPRINT_INIT
+    {MNG_FN_INIT_G1_NI,                "init_g1_ni"},
+    {MNG_FN_INIT_G2_NI,                "init_g2_ni"},
+    {MNG_FN_INIT_G4_NI,                "init_g4_ni"},
+    {MNG_FN_INIT_G8_NI,                "init_g8_ni"},
+    {MNG_FN_INIT_G16_NI,               "init_g16_ni"},
+    {MNG_FN_INIT_RGB8_NI,              "init_rgb8_ni"},
+    {MNG_FN_INIT_RGB16_NI,             "init_rgb16_ni"},
+    {MNG_FN_INIT_IDX1_NI,              "init_idx1_ni"},
+    {MNG_FN_INIT_IDX2_NI,              "init_idx2_ni"},
+    {MNG_FN_INIT_IDX4_NI,              "init_idx4_ni"},
+    {MNG_FN_INIT_IDX8_NI,              "init_idx8_ni"},
+    {MNG_FN_INIT_GA8_NI,               "init_ga8_ni"},
+    {MNG_FN_INIT_GA16_NI,              "init_ga16_ni"},
+    {MNG_FN_INIT_RGBA8_NI,             "init_rgba8_ni"},
+    {MNG_FN_INIT_RGBA16_NI,            "init_rgba16_ni"},
+#endif
+
+    {MNG_FN_INIT_ROWPROC,              "init_rowproc"},
+    {MNG_FN_NEXT_ROW,                  "next_row"},
+    {MNG_FN_CLEANUP_ROWPROC,           "cleanup_rowproc"},
+
+    {MNG_FN_FILTER_A_ROW,              "filter_a_row"},
+    {MNG_FN_FILTER_SUB,                "filter_sub"},
+    {MNG_FN_FILTER_UP,                 "filter_up"},
+    {MNG_FN_FILTER_AVERAGE,            "filter_average"},
+    {MNG_FN_FILTER_PAETH,              "filter_paeth"},
+
+    {MNG_FN_INIT_ROWDIFFERING,         "init_rowdiffering"},
+    {MNG_FN_DIFFER_G1,                 "differ_g1"},
+    {MNG_FN_DIFFER_G2,                 "differ_g2"},
+    {MNG_FN_DIFFER_G4,                 "differ_g4"},
+    {MNG_FN_DIFFER_G8,                 "differ_g8"},
+    {MNG_FN_DIFFER_G16,                "differ_g16"},
+    {MNG_FN_DIFFER_RGB8,               "differ_rgb8"},
+    {MNG_FN_DIFFER_RGB16,              "differ_rgb16"},
+    {MNG_FN_DIFFER_IDX1,               "differ_idx1"},
+    {MNG_FN_DIFFER_IDX2,               "differ_idx2"},
+    {MNG_FN_DIFFER_IDX4,               "differ_idx4"},
+    {MNG_FN_DIFFER_IDX8,               "differ_idx8"},
+    {MNG_FN_DIFFER_GA8,                "differ_ga8"},
+    {MNG_FN_DIFFER_GA16,               "differ_ga16"},
+    {MNG_FN_DIFFER_RGBA8,              "differ_rgba8"},
+    {MNG_FN_DIFFER_RGBA16,             "differ_rgba16"},
+
+    {MNG_FN_CREATE_IMGDATAOBJECT,      "create_imgdataobject"},
+    {MNG_FN_FREE_IMGDATAOBJECT,        "free_imgdataobject"},
+    {MNG_FN_CLONE_IMGDATAOBJECT,       "clone_imgdataobject"},
+    {MNG_FN_CREATE_IMGOBJECT,          "create_imgobject"},
+    {MNG_FN_FREE_IMGOBJECT,            "free_imgobject"},
+    {MNG_FN_FIND_IMGOBJECT,            "find_imgobject"},
+    {MNG_FN_CLONE_IMGOBJECT,           "clone_imgobject"},
+    {MNG_FN_RESET_OBJECTDETAILS,       "reset_objectdetails"},
+    {MNG_FN_RENUM_IMGOBJECT,           "renum_imgobject"},
+    {MNG_FN_PROMOTE_IMGOBJECT,         "promote_imgobject"},
+    {MNG_FN_MAGNIFY_IMGOBJECT,         "magnify_imgobject"},
+    {MNG_FN_COLORCORRECT_OBJECT,       "colorcorrect_object"},
+
+    {MNG_FN_STORE_G1,                  "store_g1"},
+    {MNG_FN_STORE_G2,                  "store_g2"},
+    {MNG_FN_STORE_G4,                  "store_g4"},
+    {MNG_FN_STORE_G8,                  "store_g8"},
+    {MNG_FN_STORE_G16,                 "store_g16"},
+    {MNG_FN_STORE_RGB8,                "store_rgb8"},
+    {MNG_FN_STORE_RGB16,               "store_rgb16"},
+    {MNG_FN_STORE_IDX1,                "store_idx1"},
+    {MNG_FN_STORE_IDX2,                "store_idx2"},
+    {MNG_FN_STORE_IDX4,                "store_idx4"},
+    {MNG_FN_STORE_IDX8,                "store_idx8"},
+    {MNG_FN_STORE_GA8,                 "store_ga8"},
+    {MNG_FN_STORE_GA16,                "store_ga16"},
+    {MNG_FN_STORE_RGBA8,               "store_rgba8"},
+    {MNG_FN_STORE_RGBA16,              "store_rgba16"},
+
+    {MNG_FN_RETRIEVE_G8,               "retrieve_g8"},
+    {MNG_FN_RETRIEVE_G16,              "retrieve_g16"},
+    {MNG_FN_RETRIEVE_RGB8,             "retrieve_rgb8"},
+    {MNG_FN_RETRIEVE_RGB16,            "retrieve_rgb16"},
+    {MNG_FN_RETRIEVE_IDX8,             "retrieve_idx8"},
+    {MNG_FN_RETRIEVE_GA8,              "retrieve_ga8"},
+    {MNG_FN_RETRIEVE_GA16,             "retrieve_ga16"},
+    {MNG_FN_RETRIEVE_RGBA8,            "retrieve_rgba8"},
+    {MNG_FN_RETRIEVE_RGBA16,           "retrieve_rgba16"},
+
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_DELTA_G1,                  "delta_g1"},
+    {MNG_FN_DELTA_G2,                  "delta_g2"},
+    {MNG_FN_DELTA_G4,                  "delta_g4"},
+    {MNG_FN_DELTA_G8,                  "delta_g8"},
+    {MNG_FN_DELTA_G16,                 "delta_g16"},
+    {MNG_FN_DELTA_RGB8,                "delta_rgb8"},
+    {MNG_FN_DELTA_RGB16,               "delta_rgb16"},
+    {MNG_FN_DELTA_IDX1,                "delta_idx1"},
+    {MNG_FN_DELTA_IDX2,                "delta_idx2"},
+    {MNG_FN_DELTA_IDX4,                "delta_idx4"},
+    {MNG_FN_DELTA_IDX8,                "delta_idx8"},
+    {MNG_FN_DELTA_GA8,                 "delta_ga8"},
+    {MNG_FN_DELTA_GA16,                "delta_ga16"},
+    {MNG_FN_DELTA_RGBA8,               "delta_rgba8"},
+    {MNG_FN_DELTA_RGBA16,              "delta_rgba16"},
+#endif
+
+    {MNG_FN_CREATE_ANI_LOOP,           "create_ani_loop"},
+    {MNG_FN_CREATE_ANI_ENDL,           "create_ani_endl"},
+    {MNG_FN_CREATE_ANI_DEFI,           "create_ani_defi"},
+    {MNG_FN_CREATE_ANI_BASI,           "create_ani_basi"},
+    {MNG_FN_CREATE_ANI_CLON,           "create_ani_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_CREATE_ANI_PAST,           "create_ani_past"},
+#endif
+    {MNG_FN_CREATE_ANI_DISC,           "create_ani_disc"},
+    {MNG_FN_CREATE_ANI_BACK,           "create_ani_back"},
+    {MNG_FN_CREATE_ANI_FRAM,           "create_ani_fram"},
+    {MNG_FN_CREATE_ANI_MOVE,           "create_ani_move"},
+    {MNG_FN_CREATE_ANI_CLIP,           "create_ani_clip"},
+    {MNG_FN_CREATE_ANI_SHOW,           "create_ani_show"},
+    {MNG_FN_CREATE_ANI_TERM,           "create_ani_term"},
+    {MNG_FN_CREATE_ANI_SAVE,           "create_ani_save"},
+    {MNG_FN_CREATE_ANI_SEEK,           "create_ani_seek"},
+    {MNG_FN_CREATE_ANI_GAMA,           "create_ani_gama"},
+    {MNG_FN_CREATE_ANI_CHRM,           "create_ani_chrm"},
+    {MNG_FN_CREATE_ANI_SRGB,           "create_ani_srgb"},
+    {MNG_FN_CREATE_ANI_ICCP,           "create_ani_iccp"},
+    {MNG_FN_CREATE_ANI_PLTE,           "create_ani_plte"},
+    {MNG_FN_CREATE_ANI_TRNS,           "create_ani_trns"},
+    {MNG_FN_CREATE_ANI_BKGD,           "create_ani_bkgd"},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_CREATE_ANI_DHDR,           "create_ani_dhdr"},
+    {MNG_FN_CREATE_ANI_PROM,           "create_ani_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_CREATE_ANI_IPNG,           "create_ani_ipng"},
+#endif
+    {MNG_FN_CREATE_ANI_IJNG,           "create_ani_ijng"},
+    {MNG_FN_CREATE_ANI_PPLT,           "create_ani_pplt"},
+#endif
+    {MNG_FN_CREATE_ANI_MAGN,           "create_ani_magn"},
+
+    {MNG_FN_CREATE_ANI_IMAGE,          "create_ani_image"},
+    {MNG_FN_CREATE_EVENT,              "create_event"},
+
+    {MNG_FN_FREE_ANI_LOOP,             "free_ani_loop"},
+    {MNG_FN_FREE_ANI_ENDL,             "free_ani_endl"},
+    {MNG_FN_FREE_ANI_DEFI,             "free_ani_defi"},
+    {MNG_FN_FREE_ANI_BASI,             "free_ani_basi"},
+    {MNG_FN_FREE_ANI_CLON,             "free_ani_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_FREE_ANI_PAST,             "free_ani_past"},
+#endif
+    {MNG_FN_FREE_ANI_DISC,             "free_ani_disc"},
+    {MNG_FN_FREE_ANI_BACK,             "free_ani_back"},
+    {MNG_FN_FREE_ANI_FRAM,             "free_ani_fram"},
+    {MNG_FN_FREE_ANI_MOVE,             "free_ani_move"},
+    {MNG_FN_FREE_ANI_CLIP,             "free_ani_clip"},
+    {MNG_FN_FREE_ANI_SHOW,             "free_ani_show"},
+    {MNG_FN_FREE_ANI_TERM,             "free_ani_term"},
+    {MNG_FN_FREE_ANI_SAVE,             "free_ani_save"},
+    {MNG_FN_FREE_ANI_SEEK,             "free_ani_seek"},
+    {MNG_FN_FREE_ANI_GAMA,             "free_ani_gama"},
+    {MNG_FN_FREE_ANI_CHRM,             "free_ani_chrm"},
+    {MNG_FN_FREE_ANI_SRGB,             "free_ani_srgb"},
+    {MNG_FN_FREE_ANI_ICCP,             "free_ani_iccp"},
+    {MNG_FN_FREE_ANI_PLTE,             "free_ani_plte"},
+    {MNG_FN_FREE_ANI_TRNS,             "free_ani_trns"},
+    {MNG_FN_FREE_ANI_BKGD,             "free_ani_bkgd"},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_FREE_ANI_DHDR,             "free_ani_dhdr"},
+    {MNG_FN_FREE_ANI_PROM,             "free_ani_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_FREE_ANI_IPNG,             "free_ani_ipng"},
+#endif
+    {MNG_FN_FREE_ANI_IJNG,             "free_ani_ijng"},
+    {MNG_FN_FREE_ANI_PPLT,             "free_ani_pplt"},
+#endif
+    {MNG_FN_FREE_ANI_MAGN,             "free_ani_magn"},
+
+    {MNG_FN_FREE_ANI_IMAGE,            "free_ani_image"},
+    {MNG_FN_FREE_EVENT,                "free_event"},
+
+    {MNG_FN_PROCESS_ANI_LOOP,          "process_ani_loop"},
+    {MNG_FN_PROCESS_ANI_ENDL,          "process_ani_endl"},
+    {MNG_FN_PROCESS_ANI_DEFI,          "process_ani_defi"},
+    {MNG_FN_PROCESS_ANI_BASI,          "process_ani_basi"},
+    {MNG_FN_PROCESS_ANI_CLON,          "process_ani_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_PROCESS_ANI_PAST,          "process_ani_past"},
+#endif
+    {MNG_FN_PROCESS_ANI_DISC,          "process_ani_disc"},
+    {MNG_FN_PROCESS_ANI_BACK,          "process_ani_back"},
+    {MNG_FN_PROCESS_ANI_FRAM,          "process_ani_fram"},
+    {MNG_FN_PROCESS_ANI_MOVE,          "process_ani_move"},
+    {MNG_FN_PROCESS_ANI_CLIP,          "process_ani_clip"},
+    {MNG_FN_PROCESS_ANI_SHOW,          "process_ani_show"},
+    {MNG_FN_PROCESS_ANI_TERM,          "process_ani_term"},
+    {MNG_FN_PROCESS_ANI_SAVE,          "process_ani_save"},
+    {MNG_FN_PROCESS_ANI_SEEK,          "process_ani_seek"},
+    {MNG_FN_PROCESS_ANI_GAMA,          "process_ani_gama"},
+    {MNG_FN_PROCESS_ANI_CHRM,          "process_ani_chrm"},
+    {MNG_FN_PROCESS_ANI_SRGB,          "process_ani_srgb"},
+    {MNG_FN_PROCESS_ANI_ICCP,          "process_ani_iccp"},
+    {MNG_FN_PROCESS_ANI_PLTE,          "process_ani_plte"},
+    {MNG_FN_PROCESS_ANI_TRNS,          "process_ani_trns"},
+    {MNG_FN_PROCESS_ANI_BKGD,          "process_ani_bkgd"},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_PROCESS_ANI_DHDR,          "process_ani_dhdr"},
+    {MNG_FN_PROCESS_ANI_PROM,          "process_ani_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_PROCESS_ANI_IPNG,          "process_ani_ipng"},
+#endif
+    {MNG_FN_PROCESS_ANI_IJNG,          "process_ani_ijng"},
+    {MNG_FN_PROCESS_ANI_PPLT,          "process_ani_pplt"},
+#endif
+    {MNG_FN_PROCESS_ANI_MAGN,          "process_ani_magn"},
+
+    {MNG_FN_PROCESS_ANI_IMAGE,         "process_ani_image"},
+    {MNG_FN_PROCESS_EVENT,             "process_event"},
+
+    {MNG_FN_RESTORE_BACKIMAGE,         "restore_backimage"},
+    {MNG_FN_RESTORE_BACKCOLOR,         "restore_backcolor"},
+    {MNG_FN_RESTORE_BGCOLOR,           "restore_bgcolor"},
+    {MNG_FN_RESTORE_RGB8,              "restore_rgb8"},
+    {MNG_FN_RESTORE_BGR8,              "restore_bgr8"},
+    {MNG_FN_RESTORE_BKGD,              "restore_bkgd"},
+    {MNG_FN_RESTORE_BGRX8,             "restore_bgrx8"},
+    {MNG_FN_RESTORE_RGB565,            "restore_rgb565"},
+
+    {MNG_FN_INIT_IHDR,                 "init_ihdr"},
+    {MNG_FN_INIT_PLTE,                 "init_plte"},
+    {MNG_FN_INIT_IDAT,                 "init_idat"},
+    {MNG_FN_INIT_IEND,                 "init_iend"},
+    {MNG_FN_INIT_TRNS,                 "init_trns"},
+    {MNG_FN_INIT_GAMA,                 "init_gama"},
+    {MNG_FN_INIT_CHRM,                 "init_chrm"},
+    {MNG_FN_INIT_SRGB,                 "init_srgb"},
+    {MNG_FN_INIT_ICCP,                 "init_iccp"},
+    {MNG_FN_INIT_TEXT,                 "init_text"},
+    {MNG_FN_INIT_ZTXT,                 "init_ztxt"},
+    {MNG_FN_INIT_ITXT,                 "init_itxt"},
+    {MNG_FN_INIT_BKGD,                 "init_bkgd"},
+    {MNG_FN_INIT_PHYS,                 "init_phys"},
+    {MNG_FN_INIT_SBIT,                 "init_sbit"},
+    {MNG_FN_INIT_SPLT,                 "init_splt"},
+    {MNG_FN_INIT_HIST,                 "init_hist"},
+    {MNG_FN_INIT_TIME,                 "init_time"},
+    {MNG_FN_INIT_MHDR,                 "init_mhdr"},
+    {MNG_FN_INIT_MEND,                 "init_mend"},
+    {MNG_FN_INIT_LOOP,                 "init_loop"},
+    {MNG_FN_INIT_ENDL,                 "init_endl"},
+    {MNG_FN_INIT_DEFI,                 "init_defi"},
+    {MNG_FN_INIT_BASI,                 "init_basi"},
+    {MNG_FN_INIT_CLON,                 "init_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_INIT_PAST,                 "init_past"},
+#endif
+    {MNG_FN_INIT_DISC,                 "init_disc"},
+    {MNG_FN_INIT_BACK,                 "init_back"},
+    {MNG_FN_INIT_FRAM,                 "init_fram"},
+    {MNG_FN_INIT_MOVE,                 "init_move"},
+    {MNG_FN_INIT_CLIP,                 "init_clip"},
+    {MNG_FN_INIT_SHOW,                 "init_show"},
+    {MNG_FN_INIT_TERM,                 "init_term"},
+    {MNG_FN_INIT_SAVE,                 "init_save"},
+    {MNG_FN_INIT_SEEK,                 "init_seek"},
+    {MNG_FN_INIT_EXPI,                 "init_expi"},
+    {MNG_FN_INIT_FPRI,                 "init_fpri"},
+    {MNG_FN_INIT_NEED,                 "init_need"},
+    {MNG_FN_INIT_PHYG,                 "init_phyg"},
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_INIT_JHDR,                 "init_jhdr"},
+    {MNG_FN_INIT_JDAT,                 "init_jdat"},
+    {MNG_FN_INIT_JSEP,                 "init_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_INIT_DHDR,                 "init_dhdr"},
+    {MNG_FN_INIT_PROM,                 "init_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_INIT_IPNG,                 "init_ipng"},
+#endif
+    {MNG_FN_INIT_PPLT,                 "init_pplt"},
+    {MNG_FN_INIT_IJNG,                 "init_ijng"},
+    {MNG_FN_INIT_DROP,                 "init_drop"},
+    {MNG_FN_INIT_DBYK,                 "init_dbyk"},
+    {MNG_FN_INIT_ORDR,                 "init_ordr"},
+#endif
+    {MNG_FN_INIT_UNKNOWN,              "init_unknown"},
+    {MNG_FN_INIT_MAGN,                 "init_magn"},
+    {MNG_FN_INIT_JDAA,                 "init_jdaa"},
+    {MNG_FN_INIT_EVNT,                 "init_evnt"},
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_INIT_MPNG,                 "init_mpng"},
+#endif
+
+    {MNG_FN_ASSIGN_IHDR,               "assign_ihdr"},
+    {MNG_FN_ASSIGN_PLTE,               "assign_plte"},
+    {MNG_FN_ASSIGN_IDAT,               "assign_idat"},
+    {MNG_FN_ASSIGN_IEND,               "assign_iend"},
+    {MNG_FN_ASSIGN_TRNS,               "assign_trns"},
+    {MNG_FN_ASSIGN_GAMA,               "assign_gama"},
+    {MNG_FN_ASSIGN_CHRM,               "assign_chrm"},
+    {MNG_FN_ASSIGN_SRGB,               "assign_srgb"},
+    {MNG_FN_ASSIGN_ICCP,               "assign_iccp"},
+    {MNG_FN_ASSIGN_TEXT,               "assign_text"},
+    {MNG_FN_ASSIGN_ZTXT,               "assign_ztxt"},
+    {MNG_FN_ASSIGN_ITXT,               "assign_itxt"},
+    {MNG_FN_ASSIGN_BKGD,               "assign_bkgd"},
+    {MNG_FN_ASSIGN_PHYS,               "assign_phys"},
+    {MNG_FN_ASSIGN_SBIT,               "assign_sbit"},
+    {MNG_FN_ASSIGN_SPLT,               "assign_splt"},
+    {MNG_FN_ASSIGN_HIST,               "assign_hist"},
+    {MNG_FN_ASSIGN_TIME,               "assign_time"},
+    {MNG_FN_ASSIGN_MHDR,               "assign_mhdr"},
+    {MNG_FN_ASSIGN_MEND,               "assign_mend"},
+    {MNG_FN_ASSIGN_LOOP,               "assign_loop"},
+    {MNG_FN_ASSIGN_ENDL,               "assign_endl"},
+    {MNG_FN_ASSIGN_DEFI,               "assign_defi"},
+    {MNG_FN_ASSIGN_BASI,               "assign_basi"},
+    {MNG_FN_ASSIGN_CLON,               "assign_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_ASSIGN_PAST,               "assign_past"},
+#endif
+    {MNG_FN_ASSIGN_DISC,               "assign_disc"},
+    {MNG_FN_ASSIGN_BACK,               "assign_back"},
+    {MNG_FN_ASSIGN_FRAM,               "assign_fram"},
+    {MNG_FN_ASSIGN_MOVE,               "assign_move"},
+    {MNG_FN_ASSIGN_CLIP,               "assign_clip"},
+    {MNG_FN_ASSIGN_SHOW,               "assign_show"},
+    {MNG_FN_ASSIGN_TERM,               "assign_term"},
+    {MNG_FN_ASSIGN_SAVE,               "assign_save"},
+    {MNG_FN_ASSIGN_SEEK,               "assign_seek"},
+    {MNG_FN_ASSIGN_EXPI,               "assign_expi"},
+    {MNG_FN_ASSIGN_FPRI,               "assign_fpri"},
+    {MNG_FN_ASSIGN_NEED,               "assign_need"},
+    {MNG_FN_ASSIGN_PHYG,               "assign_phyg"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_ASSIGN_JHDR,               "assign_jhdr"},
+    {MNG_FN_ASSIGN_JDAT,               "assign_jdat"},
+    {MNG_FN_ASSIGN_JSEP,               "assign_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_ASSIGN_DHDR,               "assign_dhdr"},
+    {MNG_FN_ASSIGN_PROM,               "assign_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_ASSIGN_IPNG,               "assign_ipng"},
+#endif
+    {MNG_FN_ASSIGN_PPLT,               "assign_pplt"},
+    {MNG_FN_ASSIGN_IJNG,               "assign_ijng"},
+    {MNG_FN_ASSIGN_DROP,               "assign_drop"},
+    {MNG_FN_ASSIGN_DBYK,               "assign_dbyk"},
+    {MNG_FN_ASSIGN_ORDR,               "assign_ordr"},
+#endif
+    {MNG_FN_ASSIGN_UNKNOWN,            "assign_unknown"},
+    {MNG_FN_ASSIGN_MAGN,               "assign_magn"},
+    {MNG_FN_ASSIGN_JDAA,               "assign_jdaa"},
+    {MNG_FN_ASSIGN_EVNT,               "assign_evnt"},
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_ASSIGN_MPNG,               "assign_mpng"},
+#endif
+
+    {MNG_FN_FREE_IHDR,                 "free_ihdr"},
+    {MNG_FN_FREE_PLTE,                 "free_plte"},
+    {MNG_FN_FREE_IDAT,                 "free_idat"},
+    {MNG_FN_FREE_IEND,                 "free_iend"},
+    {MNG_FN_FREE_TRNS,                 "free_trns"},
+    {MNG_FN_FREE_GAMA,                 "free_gama"},
+    {MNG_FN_FREE_CHRM,                 "free_chrm"},
+    {MNG_FN_FREE_SRGB,                 "free_srgb"},
+    {MNG_FN_FREE_ICCP,                 "free_iccp"},
+    {MNG_FN_FREE_TEXT,                 "free_text"},
+    {MNG_FN_FREE_ZTXT,                 "free_ztxt"},
+    {MNG_FN_FREE_ITXT,                 "free_itxt"},
+    {MNG_FN_FREE_BKGD,                 "free_bkgd"},
+    {MNG_FN_FREE_PHYS,                 "free_phys"},
+    {MNG_FN_FREE_SBIT,                 "free_sbit"},
+    {MNG_FN_FREE_SPLT,                 "free_splt"},
+    {MNG_FN_FREE_HIST,                 "free_hist"},
+    {MNG_FN_FREE_TIME,                 "free_time"},
+    {MNG_FN_FREE_MHDR,                 "free_mhdr"},
+    {MNG_FN_FREE_MEND,                 "free_mend"},
+    {MNG_FN_FREE_LOOP,                 "free_loop"},
+    {MNG_FN_FREE_ENDL,                 "free_endl"},
+    {MNG_FN_FREE_DEFI,                 "free_defi"},
+    {MNG_FN_FREE_BASI,                 "free_basi"},
+    {MNG_FN_FREE_CLON,                 "free_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_FREE_PAST,                 "free_past"},
+#endif
+    {MNG_FN_FREE_DISC,                 "free_disc"},
+    {MNG_FN_FREE_BACK,                 "free_back"},
+    {MNG_FN_FREE_FRAM,                 "free_fram"},
+    {MNG_FN_FREE_MOVE,                 "free_move"},
+    {MNG_FN_FREE_CLIP,                 "free_clip"},
+    {MNG_FN_FREE_SHOW,                 "free_show"},
+    {MNG_FN_FREE_TERM,                 "free_term"},
+    {MNG_FN_FREE_SAVE,                 "free_save"},
+    {MNG_FN_FREE_SEEK,                 "free_seek"},
+    {MNG_FN_FREE_EXPI,                 "free_expi"},
+    {MNG_FN_FREE_FPRI,                 "free_fpri"},
+    {MNG_FN_FREE_NEED,                 "free_need"},
+    {MNG_FN_FREE_PHYG,                 "free_phyg"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_FREE_JHDR,                 "free_jhdr"},
+    {MNG_FN_FREE_JDAT,                 "free_jdat"},
+    {MNG_FN_FREE_JSEP,                 "free_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_FREE_DHDR,                 "free_dhdr"},
+    {MNG_FN_FREE_PROM,                 "free_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_FREE_IPNG,                 "free_ipng"},
+#endif
+    {MNG_FN_FREE_PPLT,                 "free_pplt"},
+    {MNG_FN_FREE_IJNG,                 "free_ijng"},
+    {MNG_FN_FREE_DROP,                 "free_drop"},
+    {MNG_FN_FREE_DBYK,                 "free_dbyk"},
+    {MNG_FN_FREE_ORDR,                 "free_ordr"},
+#endif
+    {MNG_FN_FREE_UNKNOWN,              "free_unknown"},
+    {MNG_FN_FREE_MAGN,                 "free_magn"},
+    {MNG_FN_FREE_JDAA,                 "free_jdaa"},
+    {MNG_FN_FREE_EVNT,                 "free_evnt"},
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_FREE_MPNG,                 "free_mpng"},
+#endif
+
+    {MNG_FN_READ_IHDR,                 "read_ihdr"},
+    {MNG_FN_READ_PLTE,                 "read_plte"},
+    {MNG_FN_READ_IDAT,                 "read_idat"},
+    {MNG_FN_READ_IEND,                 "read_iend"},
+    {MNG_FN_READ_TRNS,                 "read_trns"},
+    {MNG_FN_READ_GAMA,                 "read_gama"},
+    {MNG_FN_READ_CHRM,                 "read_chrm"},
+    {MNG_FN_READ_SRGB,                 "read_srgb"},
+    {MNG_FN_READ_ICCP,                 "read_iccp"},
+    {MNG_FN_READ_TEXT,                 "read_text"},
+    {MNG_FN_READ_ZTXT,                 "read_ztxt"},
+    {MNG_FN_READ_ITXT,                 "read_itxt"},
+    {MNG_FN_READ_BKGD,                 "read_bkgd"},
+    {MNG_FN_READ_PHYS,                 "read_phys"},
+    {MNG_FN_READ_SBIT,                 "read_sbit"},
+    {MNG_FN_READ_SPLT,                 "read_splt"},
+    {MNG_FN_READ_HIST,                 "read_hist"},
+    {MNG_FN_READ_TIME,                 "read_time"},
+    {MNG_FN_READ_MHDR,                 "read_mhdr"},
+    {MNG_FN_READ_MEND,                 "read_mend"},
+    {MNG_FN_READ_LOOP,                 "read_loop"},
+    {MNG_FN_READ_ENDL,                 "read_endl"},
+    {MNG_FN_READ_DEFI,                 "read_defi"},
+    {MNG_FN_READ_BASI,                 "read_basi"},
+    {MNG_FN_READ_CLON,                 "read_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_READ_PAST,                 "read_past"},
+#endif
+    {MNG_FN_READ_DISC,                 "read_disc"},
+    {MNG_FN_READ_BACK,                 "read_back"},
+    {MNG_FN_READ_FRAM,                 "read_fram"},
+    {MNG_FN_READ_MOVE,                 "read_move"},
+    {MNG_FN_READ_CLIP,                 "read_clip"},
+    {MNG_FN_READ_SHOW,                 "read_show"},
+    {MNG_FN_READ_TERM,                 "read_term"},
+    {MNG_FN_READ_SAVE,                 "read_save"},
+    {MNG_FN_READ_SEEK,                 "read_seek"},
+    {MNG_FN_READ_EXPI,                 "read_expi"},
+    {MNG_FN_READ_FPRI,                 "read_fpri"},
+    {MNG_FN_READ_NEED,                 "read_need"},
+    {MNG_FN_READ_PHYG,                 "read_phyg"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_READ_JHDR,                 "read_jhdr"},
+    {MNG_FN_READ_JDAT,                 "read_jdat"},
+    {MNG_FN_READ_JSEP,                 "read_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_READ_DHDR,                 "read_dhdr"},
+    {MNG_FN_READ_PROM,                 "read_prom"},
+    {MNG_FN_READ_IPNG,                 "read_ipng"},
+    {MNG_FN_READ_PPLT,                 "read_pplt"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_READ_IJNG,                 "read_ijng"},
+#endif
+    {MNG_FN_READ_DROP,                 "read_drop"},
+    {MNG_FN_READ_DBYK,                 "read_dbyk"},
+    {MNG_FN_READ_ORDR,                 "read_ordr"},
+#endif
+    {MNG_FN_READ_UNKNOWN,              "read_unknown"},
+    {MNG_FN_READ_MAGN,                 "read_magn"},
+    {MNG_FN_READ_JDAA,                 "read_jdaa"},
+    {MNG_FN_READ_EVNT,                 "read_evnt"},
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_READ_MPNG,                 "read_mpng"},
+#endif
+
+    {MNG_FN_WRITE_IHDR,                "write_ihdr"},
+    {MNG_FN_WRITE_PLTE,                "write_plte"},
+    {MNG_FN_WRITE_IDAT,                "write_idat"},
+    {MNG_FN_WRITE_IEND,                "write_iend"},
+    {MNG_FN_WRITE_TRNS,                "write_trns"},
+    {MNG_FN_WRITE_GAMA,                "write_gama"},
+    {MNG_FN_WRITE_CHRM,                "write_chrm"},
+    {MNG_FN_WRITE_SRGB,                "write_srgb"},
+    {MNG_FN_WRITE_ICCP,                "write_iccp"},
+    {MNG_FN_WRITE_TEXT,                "write_text"},
+    {MNG_FN_WRITE_ZTXT,                "write_ztxt"},
+    {MNG_FN_WRITE_ITXT,                "write_itxt"},
+    {MNG_FN_WRITE_BKGD,                "write_bkgd"},
+    {MNG_FN_WRITE_PHYS,                "write_phys"},
+    {MNG_FN_WRITE_SBIT,                "write_sbit"},
+    {MNG_FN_WRITE_SPLT,                "write_splt"},
+    {MNG_FN_WRITE_HIST,                "write_hist"},
+    {MNG_FN_WRITE_TIME,                "write_time"},
+    {MNG_FN_WRITE_MHDR,                "write_mhdr"},
+    {MNG_FN_WRITE_MEND,                "write_mend"},
+    {MNG_FN_WRITE_LOOP,                "write_loop"},
+    {MNG_FN_WRITE_ENDL,                "write_endl"},
+    {MNG_FN_WRITE_DEFI,                "write_defi"},
+    {MNG_FN_WRITE_BASI,                "write_basi"},
+    {MNG_FN_WRITE_CLON,                "write_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_WRITE_PAST,                "write_past"},
+#endif
+    {MNG_FN_WRITE_DISC,                "write_disc"},
+    {MNG_FN_WRITE_BACK,                "write_back"},
+    {MNG_FN_WRITE_FRAM,                "write_fram"},
+    {MNG_FN_WRITE_MOVE,                "write_move"},
+    {MNG_FN_WRITE_CLIP,                "write_clip"},
+    {MNG_FN_WRITE_SHOW,                "write_show"},
+    {MNG_FN_WRITE_TERM,                "write_term"},
+    {MNG_FN_WRITE_SAVE,                "write_save"},
+    {MNG_FN_WRITE_SEEK,                "write_seek"},
+    {MNG_FN_WRITE_EXPI,                "write_expi"},
+    {MNG_FN_WRITE_FPRI,                "write_fpri"},
+    {MNG_FN_WRITE_NEED,                "write_need"},
+    {MNG_FN_WRITE_PHYG,                "write_phyg"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_WRITE_JHDR,                "write_jhdr"},
+    {MNG_FN_WRITE_JDAT,                "write_jdat"},
+    {MNG_FN_WRITE_JSEP,                "write_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_WRITE_DHDR,                "write_dhdr"},
+    {MNG_FN_WRITE_PROM,                "write_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_WRITE_IPNG,                "write_ipng"},
+#endif
+    {MNG_FN_WRITE_PPLT,                "write_pplt"},
+    {MNG_FN_WRITE_IJNG,                "write_ijng"},
+    {MNG_FN_WRITE_DROP,                "write_drop"},
+    {MNG_FN_WRITE_DBYK,                "write_dbyk"},
+    {MNG_FN_WRITE_ORDR,                "write_ordr"},
+#endif
+    {MNG_FN_WRITE_UNKNOWN,             "write_unknown"},
+    {MNG_FN_WRITE_MAGN,                "write_magn"},
+    {MNG_FN_WRITE_JDAA,                "write_jdaa"},
+    {MNG_FN_WRITE_EVNT,                "write_evnt"},
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+    {MNG_FN_WRITE_MPNG,                "write_mpng"},
+#endif
+
+    {MNG_FN_ZLIB_INITIALIZE,           "zlib_initialize"},
+    {MNG_FN_ZLIB_CLEANUP,              "zlib_cleanup"},
+    {MNG_FN_ZLIB_INFLATEINIT,          "zlib_inflateinit"},
+    {MNG_FN_ZLIB_INFLATEROWS,          "zlib_inflaterows"},
+    {MNG_FN_ZLIB_INFLATEDATA,          "zlib_inflatedata"},
+    {MNG_FN_ZLIB_INFLATEFREE,          "zlib_inflatefree"},
+    {MNG_FN_ZLIB_DEFLATEINIT,          "zlib_deflateinit"},
+    {MNG_FN_ZLIB_DEFLATEROWS,          "zlib_deflaterows"},
+    {MNG_FN_ZLIB_DEFLATEDATA,          "zlib_deflatedata"},
+    {MNG_FN_ZLIB_DEFLATEFREE,          "zlib_deflatefree"},
+
+    {MNG_FN_PROCESS_DISPLAY_IHDR,      "process_display_ihdr"},
+    {MNG_FN_PROCESS_DISPLAY_PLTE,      "process_display_plte"},
+    {MNG_FN_PROCESS_DISPLAY_IDAT,      "process_display_idat"},
+    {MNG_FN_PROCESS_DISPLAY_IEND,      "process_display_iend"},
+    {MNG_FN_PROCESS_DISPLAY_TRNS,      "process_display_trns"},
+    {MNG_FN_PROCESS_DISPLAY_GAMA,      "process_display_gama"},
+    {MNG_FN_PROCESS_DISPLAY_CHRM,      "process_display_chrm"},
+    {MNG_FN_PROCESS_DISPLAY_SRGB,      "process_display_srgb"},
+    {MNG_FN_PROCESS_DISPLAY_ICCP,      "process_display_iccp"},
+    {MNG_FN_PROCESS_DISPLAY_BKGD,      "process_display_bkgd"},
+    {MNG_FN_PROCESS_DISPLAY_PHYS,      "process_display_phys"},
+    {MNG_FN_PROCESS_DISPLAY_SBIT,      "process_display_sbit"},
+    {MNG_FN_PROCESS_DISPLAY_SPLT,      "process_display_splt"},
+    {MNG_FN_PROCESS_DISPLAY_HIST,      "process_display_hist"},
+    {MNG_FN_PROCESS_DISPLAY_MHDR,      "process_display_mhdr"},
+    {MNG_FN_PROCESS_DISPLAY_MEND,      "process_display_mend"},
+    {MNG_FN_PROCESS_DISPLAY_LOOP,      "process_display_loop"},
+    {MNG_FN_PROCESS_DISPLAY_ENDL,      "process_display_endl"},
+    {MNG_FN_PROCESS_DISPLAY_DEFI,      "process_display_defi"},
+    {MNG_FN_PROCESS_DISPLAY_BASI,      "process_display_basi"},
+    {MNG_FN_PROCESS_DISPLAY_CLON,      "process_display_clon"},
+#ifndef MNG_SKIPCHUNK_PAST
+    {MNG_FN_PROCESS_DISPLAY_PAST,      "process_display_past"},
+#endif
+    {MNG_FN_PROCESS_DISPLAY_DISC,      "process_display_disc"},
+    {MNG_FN_PROCESS_DISPLAY_BACK,      "process_display_back"},
+    {MNG_FN_PROCESS_DISPLAY_FRAM,      "process_display_fram"},
+    {MNG_FN_PROCESS_DISPLAY_MOVE,      "process_display_move"},
+    {MNG_FN_PROCESS_DISPLAY_CLIP,      "process_display_clip"},
+    {MNG_FN_PROCESS_DISPLAY_SHOW,      "process_display_show"},
+    {MNG_FN_PROCESS_DISPLAY_TERM,      "process_display_term"},
+    {MNG_FN_PROCESS_DISPLAY_SAVE,      "process_display_save"},
+    {MNG_FN_PROCESS_DISPLAY_SEEK,      "process_display_seek"},
+    {MNG_FN_PROCESS_DISPLAY_EXPI,      "process_display_expi"},
+    {MNG_FN_PROCESS_DISPLAY_FPRI,      "process_display_fpri"},
+    {MNG_FN_PROCESS_DISPLAY_NEED,      "process_display_need"},
+    {MNG_FN_PROCESS_DISPLAY_PHYG,      "process_display_phyg"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_PROCESS_DISPLAY_JHDR,      "process_display_jhdr"},
+    {MNG_FN_PROCESS_DISPLAY_JDAT,      "process_display_jdat"},
+    {MNG_FN_PROCESS_DISPLAY_JSEP,      "process_display_jsep"},
+#endif
+#ifndef MNG_NO_DELTA_PNG
+    {MNG_FN_PROCESS_DISPLAY_DHDR,      "process_display_dhdr"},
+    {MNG_FN_PROCESS_DISPLAY_PROM,      "process_display_prom"},
+#ifdef MNG_INCLUDE_JNG
+    {MNG_FN_PROCESS_DISPLAY_IPNG,      "process_display_ipng"},
+#endif
+    {MNG_FN_PROCESS_DISPLAY_PPLT,      "process_display_pplt"},
+    {MNG_FN_PROCESS_DISPLAY_IJNG,      "process_display_ijng"},
+    {MNG_FN_PROCESS_DISPLAY_DROP,      "process_display_drop"},
+    {MNG_FN_PROCESS_DISPLAY_DBYK,      "process_display_dbyk"},
+    {MNG_FN_PROCESS_DISPLAY_ORDR,      "process_display_ordr"},
+#endif
+    {MNG_FN_PROCESS_DISPLAY_MAGN,      "process_display_magn"},
+    {MNG_FN_PROCESS_DISPLAY_JDAA,      "process_display_jdaa"},
+
+    {MNG_FN_JPEG_INITIALIZE,           "jpeg_initialize"},
+    {MNG_FN_JPEG_CLEANUP,              "jpeg_cleanup"},
+    {MNG_FN_JPEG_DECOMPRESSINIT,       "jpeg_decompressinit"},
+    {MNG_FN_JPEG_DECOMPRESSDATA,       "jpeg_decompressdata"},
+    {MNG_FN_JPEG_DECOMPRESSFREE,       "jpeg_decompressfree"},
+
+    {MNG_FN_STORE_JPEG_G8,             "store_jpeg_g8"},
+    {MNG_FN_STORE_JPEG_RGB8,           "store_jpeg_rgb8"},
+    {MNG_FN_STORE_JPEG_G12,            "store_jpeg_g12"},
+    {MNG_FN_STORE_JPEG_RGB12,          "store_jpeg_rgb12"},
+    {MNG_FN_STORE_JPEG_GA8,            "store_jpeg_ga8"},
+    {MNG_FN_STORE_JPEG_RGBA8,          "store_jpeg_rgba8"},
+    {MNG_FN_STORE_JPEG_GA12,           "store_jpeg_ga12"},
+    {MNG_FN_STORE_JPEG_RGBA12,         "store_jpeg_rgba12"},
+    {MNG_FN_STORE_JPEG_G8_ALPHA,       "store_jpeg_g8_alpha"},
+    {MNG_FN_STORE_JPEG_RGB8_ALPHA,     "store_jpeg_rgb8_alpha"},
+
+    {MNG_FN_INIT_JPEG_A1_NI,           "init_jpeg_a1_ni"},
+    {MNG_FN_INIT_JPEG_A2_NI,           "init_jpeg_a2_ni"},
+    {MNG_FN_INIT_JPEG_A4_NI,           "init_jpeg_a4_ni"},
+    {MNG_FN_INIT_JPEG_A8_NI,           "init_jpeg_a8_ni"},
+    {MNG_FN_INIT_JPEG_A16_NI,          "init_jpeg_a16_ni"},
+
+    {MNG_FN_STORE_JPEG_G8_A1,          "store_jpeg_g8_a1"},
+    {MNG_FN_STORE_JPEG_G8_A2,          "store_jpeg_g8_a2"},
+    {MNG_FN_STORE_JPEG_G8_A4,          "store_jpeg_g8_a4"},
+    {MNG_FN_STORE_JPEG_G8_A8,          "store_jpeg_g8_a8"},
+    {MNG_FN_STORE_JPEG_G8_A16,         "store_jpeg_g8_a16"},
+
+    {MNG_FN_STORE_JPEG_RGB8_A1,        "store_jpeg_rgb8_a1"},
+    {MNG_FN_STORE_JPEG_RGB8_A2,        "store_jpeg_rgb8_a2"},
+    {MNG_FN_STORE_JPEG_RGB8_A4,        "store_jpeg_rgb8_a4"},
+    {MNG_FN_STORE_JPEG_RGB8_A8,        "store_jpeg_rgb8_a8"},
+    {MNG_FN_STORE_JPEG_RGB8_A16,       "store_jpeg_rgb8_a16"},
+
+    {MNG_FN_STORE_JPEG_G12_A1,         "store_jpeg_g12_a1"},
+    {MNG_FN_STORE_JPEG_G12_A2,         "store_jpeg_g12_a2"},
+    {MNG_FN_STORE_JPEG_G12_A4,         "store_jpeg_g12_a4"},
+    {MNG_FN_STORE_JPEG_G12_A8,         "store_jpeg_g12_a8"},
+    {MNG_FN_STORE_JPEG_G12_A16,        "store_jpeg_g12_a16"},
+
+    {MNG_FN_STORE_JPEG_RGB12_A1,       "store_jpeg_rgb12_a1"},
+    {MNG_FN_STORE_JPEG_RGB12_A2,       "store_jpeg_rgb12_a2"},
+    {MNG_FN_STORE_JPEG_RGB12_A4,       "store_jpeg_rgb12_a4"},
+    {MNG_FN_STORE_JPEG_RGB12_A8,       "store_jpeg_rgb12_a8"},
+    {MNG_FN_STORE_JPEG_RGB12_A16,      "store_jpeg_rgb12_a16"},
+
+    {MNG_FN_NEXT_JPEG_ALPHAROW,        "next_jpeg_alpharow"},
+    {MNG_FN_NEXT_JPEG_ROW,             "next_jpeg_row"},
+    {MNG_FN_DISPLAY_JPEG_ROWS,         "display_jpeg_rows"},
+
+    {MNG_FN_MAGNIFY_G8_X1,             "magnify_g8_x1"},
+    {MNG_FN_MAGNIFY_G8_X2,             "magnify_g8_x2"},
+    {MNG_FN_MAGNIFY_RGB8_X1,           "magnify_rgb8_x1"},
+    {MNG_FN_MAGNIFY_RGB8_X2,           "magnify_rgb8_x2"},
+    {MNG_FN_MAGNIFY_GA8_X1,            "magnify_ga8_x1"},
+    {MNG_FN_MAGNIFY_GA8_X2,            "magnify_ga8_x2"},
+    {MNG_FN_MAGNIFY_GA8_X3,            "magnify_ga8_x3"},
+    {MNG_FN_MAGNIFY_GA8_X4,            "magnify_ga8_x4"},
+    {MNG_FN_MAGNIFY_RGBA8_X1,          "magnify_rgba8_x1"},
+    {MNG_FN_MAGNIFY_RGBA8_X2,          "magnify_rgba8_x2"},
+    {MNG_FN_MAGNIFY_RGBA8_X3,          "magnify_rgba8_x3"},
+    {MNG_FN_MAGNIFY_RGBA8_X4,          "magnify_rgba8_x4"},
+    {MNG_FN_MAGNIFY_G8_X3,             "magnify_g8_x3"},
+    {MNG_FN_MAGNIFY_RGB8_X3,           "magnify_rgb8_x3"},
+    {MNG_FN_MAGNIFY_GA8_X5,            "magnify_ga8_x5"},
+    {MNG_FN_MAGNIFY_RGBA8_X5,          "magnify_rgba8_x5"},
+
+    {MNG_FN_MAGNIFY_G8_Y1,             "magnify_g8_y1"},
+    {MNG_FN_MAGNIFY_G8_Y2,             "magnify_g8_y2"},
+    {MNG_FN_MAGNIFY_RGB8_Y1,           "magnify_rgb8_y1"},
+    {MNG_FN_MAGNIFY_RGB8_Y2,           "magnify_rgb8_y2"},
+    {MNG_FN_MAGNIFY_GA8_Y1,            "magnify_ga8_y1"},
+    {MNG_FN_MAGNIFY_GA8_Y2,            "magnify_ga8_y2"},
+    {MNG_FN_MAGNIFY_GA8_Y3,            "magnify_ga8_y3"},
+    {MNG_FN_MAGNIFY_GA8_Y4,            "magnify_ga8_y4"},
+    {MNG_FN_MAGNIFY_RGBA8_Y1,          "magnify_rgba8_y1"},
+    {MNG_FN_MAGNIFY_RGBA8_Y2,          "magnify_rgba8_y2"},
+    {MNG_FN_MAGNIFY_RGBA8_Y3,          "magnify_rgba8_y3"},
+    {MNG_FN_MAGNIFY_RGBA8_Y4,          "magnify_rgba8_y4"},
+    {MNG_FN_MAGNIFY_G8_Y3,             "magnify_g8_y3"},
+    {MNG_FN_MAGNIFY_RGB8_Y3,           "magnify_rgb8_y3"},
+    {MNG_FN_MAGNIFY_GA8_Y5,            "magnify_ga8_y5"},
+    {MNG_FN_MAGNIFY_RGBA8_Y5,          "magnify_rgba8_y5"},
+
+    {MNG_FN_MAGNIFY_G8_X1,             "magnify_g8_x1"},
+    {MNG_FN_MAGNIFY_G8_X2,             "magnify_g8_x2"},
+    {MNG_FN_MAGNIFY_RGB8_X1,           "magnify_rgb8_x1"},
+    {MNG_FN_MAGNIFY_RGB8_X2,           "magnify_rgb8_x2"},
+    {MNG_FN_MAGNIFY_GA8_X1,            "magnify_ga8_x1"},
+    {MNG_FN_MAGNIFY_GA8_X2,            "magnify_ga8_x2"},
+    {MNG_FN_MAGNIFY_GA8_X3,            "magnify_ga8_x3"},
+    {MNG_FN_MAGNIFY_GA8_X4,            "magnify_ga8_x4"},
+    {MNG_FN_MAGNIFY_RGBA8_X1,          "magnify_rgba8_x1"},
+    {MNG_FN_MAGNIFY_RGBA8_X2,          "magnify_rgba8_x2"},
+    {MNG_FN_MAGNIFY_RGBA8_X3,          "magnify_rgba8_x3"},
+    {MNG_FN_MAGNIFY_RGBA8_X4,          "magnify_rgba8_x4"},
+    {MNG_FN_MAGNIFY_G8_X3,             "magnify_g8_x3"},
+    {MNG_FN_MAGNIFY_RGB8_X3,           "magnify_rgb8_x3"},
+    {MNG_FN_MAGNIFY_GA8_X5,            "magnify_ga8_x5"},
+    {MNG_FN_MAGNIFY_RGBA8_X5,          "magnify_rgba8_x5"},
+
+    {MNG_FN_MAGNIFY_G8_Y1,             "magnify_g8_y1"},
+    {MNG_FN_MAGNIFY_G8_Y2,             "magnify_g8_y2"},
+    {MNG_FN_MAGNIFY_RGB8_Y1,           "magnify_rgb8_y1"},
+    {MNG_FN_MAGNIFY_RGB8_Y2,           "magnify_rgb8_y2"},
+    {MNG_FN_MAGNIFY_GA8_Y1,            "magnify_ga8_y1"},
+    {MNG_FN_MAGNIFY_GA8_Y2,            "magnify_ga8_y2"},
+    {MNG_FN_MAGNIFY_GA8_Y3,            "magnify_ga8_y3"},
+    {MNG_FN_MAGNIFY_GA8_Y4,            "magnify_ga8_y4"},
+    {MNG_FN_MAGNIFY_RGBA8_Y1,          "magnify_rgba8_y1"},
+    {MNG_FN_MAGNIFY_RGBA8_Y2,          "magnify_rgba8_y2"},
+    {MNG_FN_MAGNIFY_RGBA8_Y3,          "magnify_rgba8_y3"},
+    {MNG_FN_MAGNIFY_RGBA8_Y4,          "magnify_rgba8_y4"},
+    {MNG_FN_MAGNIFY_G8_Y3,             "magnify_g8_y3"},
+    {MNG_FN_MAGNIFY_RGB8_Y3,           "magnify_rgb8_y3"},
+    {MNG_FN_MAGNIFY_GA8_Y5,            "magnify_ga8_y5"},
+    {MNG_FN_MAGNIFY_RGBA8_Y5,          "magnify_rgba8_y5"},
+
+    {MNG_FN_DELTA_G1_G1,               "delta_g1_g1"},
+    {MNG_FN_DELTA_G2_G2,               "delta_g2_g2"},
+    {MNG_FN_DELTA_G4_G4,               "delta_g4_g4"},
+    {MNG_FN_DELTA_G8_G8,               "delta_g8_g8"},
+    {MNG_FN_DELTA_G16_G16,             "delta_g16_g16"},
+    {MNG_FN_DELTA_RGB8_RGB8,           "delta_rgb8_rgb8"},
+    {MNG_FN_DELTA_RGB16_RGB16,         "delta_rgb16_rgb16"},
+    {MNG_FN_DELTA_GA8_GA8,             "delta_ga8_ga8"},
+    {MNG_FN_DELTA_GA8_G8,              "delta_ga8_g8"},
+    {MNG_FN_DELTA_GA8_A8,              "delta_ga8_a8"},
+    {MNG_FN_DELTA_GA16_GA16,           "delta_ga16_ga16"},
+    {MNG_FN_DELTA_GA16_G16,            "delta_ga16_g16"},
+    {MNG_FN_DELTA_GA16_A16,            "delta_ga16_a16"},
+    {MNG_FN_DELTA_RGBA8_RGBA8,         "delta_rgba8_rgba8"},
+    {MNG_FN_DELTA_RGBA8_RGB8,          "delta_rgba8_rgb8"},
+    {MNG_FN_DELTA_RGBA8_A8,            "delta_rgba8_a8"},
+    {MNG_FN_DELTA_RGBA16_RGBA16,       "delta_rgba16_rgba16"},
+    {MNG_FN_DELTA_RGBA16_RGB16,        "delta_rgba16_rgb16"},
+    {MNG_FN_DELTA_RGBA16_A16,          "delta_rgba16_a16"},
+
+    {MNG_FN_PROMOTE_G8_G8,             "promote_g8_g8"},
+    {MNG_FN_PROMOTE_G8_G16,            "promote_g8_g16"},
+    {MNG_FN_PROMOTE_G16_G16,           "promote_g8_g16"},
+    {MNG_FN_PROMOTE_G8_GA8,            "promote_g8_ga8"},
+    {MNG_FN_PROMOTE_G8_GA16,           "promote_g8_ga16"},
+    {MNG_FN_PROMOTE_G16_GA16,          "promote_g16_ga16"},
+    {MNG_FN_PROMOTE_G8_RGB8,           "promote_g8_rgb8"},
+    {MNG_FN_PROMOTE_G8_RGB16,          "promote_g8_rgb16"},
+    {MNG_FN_PROMOTE_G16_RGB16,         "promote_g16_rgb16"},
+    {MNG_FN_PROMOTE_G8_RGBA8,          "promote_g8_rgba8"},
+    {MNG_FN_PROMOTE_G8_RGBA16,         "promote_g8_rgba16"},
+    {MNG_FN_PROMOTE_G16_RGBA16,        "promote_g16_rgba16"},
+    {MNG_FN_PROMOTE_GA8_GA16,          "promote_ga8_ga16"},
+    {MNG_FN_PROMOTE_GA8_RGBA8,         "promote_ga8_rgba8"},
+    {MNG_FN_PROMOTE_GA8_RGBA16,        "promote_ga8_rgba16"},
+    {MNG_FN_PROMOTE_GA16_RGBA16,       "promote_ga16_rgba16"},
+    {MNG_FN_PROMOTE_RGB8_RGB16,        "promote_rgb8_rgb16"},
+    {MNG_FN_PROMOTE_RGB8_RGBA8,        "promote_rgb8_rgba8"},
+    {MNG_FN_PROMOTE_RGB8_RGBA16,       "promote_rgb8_rgba16"},
+    {MNG_FN_PROMOTE_RGB16_RGBA16,      "promote_rgb16_rgba16"},
+    {MNG_FN_PROMOTE_RGBA8_RGBA16,      "promote_rgba8_rgba16"},
+    {MNG_FN_PROMOTE_IDX8_RGB8,         "promote_idx8_rgb8"},
+    {MNG_FN_PROMOTE_IDX8_RGB16,        "promote_idx8_rgb16"},
+    {MNG_FN_PROMOTE_IDX8_RGBA8,        "promote_idx8_rgba8"},
+    {MNG_FN_PROMOTE_IDX8_RGBA16,       "promote_idx8_rgba16"},
+
+    {MNG_FN_SCALE_G1_G2,               "scale_g1_g2"},
+    {MNG_FN_SCALE_G1_G4,               "scale_g1_g4"},
+    {MNG_FN_SCALE_G1_G8,               "scale_g1_g8"},
+    {MNG_FN_SCALE_G1_G16,              "scale_g1_g16"},
+    {MNG_FN_SCALE_G2_G4,               "scale_g2_g4"},
+    {MNG_FN_SCALE_G2_G8,               "scale_g2_g8"},
+    {MNG_FN_SCALE_G2_G16,              "scale_g2_g16"},
+    {MNG_FN_SCALE_G4_G8,               "scale_g4_g8"},
+    {MNG_FN_SCALE_G4_G16,              "scale_g4_g16"},
+    {MNG_FN_SCALE_G8_G16,              "scale_g8_g16"},
+    {MNG_FN_SCALE_GA8_GA16,            "scale_ga8_ga16"},
+    {MNG_FN_SCALE_RGB8_RGB16,          "scale_rgb8_rgb16"},
+    {MNG_FN_SCALE_RGBA8_RGBA16,        "scale_rgba8_rgba16"},
+
+    {MNG_FN_SCALE_G2_G1,               "scale_g2_g1"},
+    {MNG_FN_SCALE_G4_G1,               "scale_g4_g1"},
+    {MNG_FN_SCALE_G8_G1,               "scale_g8_g1"},
+    {MNG_FN_SCALE_G16_G1,              "scale_g16_g1"},
+    {MNG_FN_SCALE_G4_G2,               "scale_g4_g2"},
+    {MNG_FN_SCALE_G8_G2,               "scale_g8_g2"},
+    {MNG_FN_SCALE_G16_G2,              "scale_g16_g2"},
+    {MNG_FN_SCALE_G8_G4,               "scale_g8_g4"},
+    {MNG_FN_SCALE_G16_G4,              "scale_g16_g4"},
+    {MNG_FN_SCALE_G16_G8,              "scale_g16_g8"},
+    {MNG_FN_SCALE_GA16_GA8,            "scale_ga16_ga8"},
+    {MNG_FN_SCALE_RGB16_RGB8,          "scale_rgb16_rgb8"},
+    {MNG_FN_SCALE_RGBA16_RGBA8,        "scale_rgba16_rgba8"},
+
+    {MNG_FN_COMPOSEOVER_RGBA8,         "composeover_rgba8"},
+    {MNG_FN_COMPOSEOVER_RGBA16,        "composeover_rgba16"},
+    {MNG_FN_COMPOSEUNDER_RGBA8,        "composeunder_rgba8"},
+    {MNG_FN_COMPOSEUNDER_RGBA16,       "composeunder_rgba16"},
+
+    {MNG_FN_FLIP_RGBA8,                "flip_rgba8"},
+    {MNG_FN_FLIP_RGBA16,               "flip_rgba16"},
+    {MNG_FN_TILE_RGBA8,                "tile_rgba8"},
+    {MNG_FN_TILE_RGBA16,               "tile_rgba16"}
+
+  };
+#endif /* MNG_INCLUDE_TRACE_STINGS */
+
+/* ************************************************************************** */
+
+mng_retcode mng_trace (mng_datap  pData,
+                       mng_uint32 iFunction,
+                       mng_uint32 iLocation)
+{
+  mng_pchar zName = 0;                 /* bufferptr for tracestring */
+
+  if ((pData == 0) || (pData->iMagic != MNG_MAGIC))
+    return MNG_INVALIDHANDLE;          /* no good if the handle is corrupt */
+
+  if (pData->fTraceproc)               /* report back to user ? */
+  {
+#ifdef MNG_INCLUDE_TRACE_STRINGS
+    {                                  /* binary search variables */
+      mng_int32        iTop, iLower, iUpper, iMiddle;
+      mng_trace_entryp pEntry;         /* pointer to found entry */
+                                       /* determine max index of table */
+      iTop = (sizeof (trace_table) / sizeof (trace_table [0])) - 1;
+
+      iLower  = 0;                     /* initialize binary search */
+      iMiddle = iTop >> 1;             /* start in the middle */
+      iUpper  = iTop;
+      pEntry  = 0;                     /* no goods yet! */
+
+      do                               /* the binary search itself */
+        {
+          if (trace_table [iMiddle].iFunction < iFunction)
+            iLower = iMiddle + 1;
+          else if (trace_table [iMiddle].iFunction > iFunction)
+            iUpper = iMiddle - 1;
+          else
+          {
+            pEntry = &trace_table [iMiddle];
+            break;
+          };
+
+          iMiddle = (iLower + iUpper) >> 1;
+        }
+      while (iLower <= iUpper);
+
+      if (pEntry)                      /* found it ? */
+        zName = pEntry->zTracetext;
+
+    }
+#endif
+                                       /* oke, now tell */
+    if (!pData->fTraceproc (((mng_handle)pData), iFunction, iLocation, zName))
+      return MNG_APPTRACEABORT;
+
+  }
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_TRACE_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_trace.h b/src/3rdparty/libmng/libmng_trace.h
new file mode 100644
index 0000000..0c749d9
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_trace.h
@@ -0,0 +1,1474 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_trace.h            copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : Trace functions (definition)                               * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the trace functions                          * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - added chunk-access function trace-codes                  * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *             0.5.1 - 05/13/2000 - G.Juyn                                * */
+/* *             - added save_state & restore_state trace-codes             * */
+/* *             0.5.1 - 05/15/2000 - G.Juyn                                * */
+/* *             - added getimgdata & putimgdata trace-codes                * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - added JNG tracecodes                                     * */
+/* *             0.5.2 - 05/23/2000 - G.Juyn                                * */
+/* *             - added trace-table entry definition                       * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added tracecodes for global animation color-chunks       * */
+/* *             - added tracecodes for get/set of default ZLIB/IJG parms   * */
+/* *             - added tracecodes for global PLTE,tRNS,bKGD               * */
+/* *             0.5.2 - 05/30/2000 - G.Juyn                                * */
+/* *             - added tracecodes for image-object promotion              * */
+/* *             - added tracecodes for delta-image processing              * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - added tracecodes for getalphaline callback               * */
+/* *             0.5.2 - 06/05/2000 - G.Juyn                                * */
+/* *             - added tracecode for RGB8_A8 canvasstyle                  * */
+/* *             0.5.2 - 06/06/2000 - G.Juyn                                * */
+/* *             - added tracecode for mng_read_resume HLAPI function       * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/06/2000 - G.Juyn                                * */
+/* *             - added tracecodes for tracing JPEG progression            * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added tracecodes for get/set speedtype                   * */
+/* *             - added tracecodes for get imagelevel                      * */
+/* *             0.5.3 - 06/22/2000 - G.Juyn                                * */
+/* *             - added tracecode for delta-image processing               * */
+/* *             - added tracecodes for PPLT chunk processing               * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/07/2000 - G.Juyn                                * */
+/* *             - added tracecodes for special display processing          * */
+/* *             0.9.1 - 07/08/2000 - G.Juyn                                * */
+/* *             - added tracecode for get/set suspensionmode               * */
+/* *             - added tracecodes for get/set display variables           * */
+/* *             - added tracecode for read_databuffer (I/O-suspension)     * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added tracecodes for SAVE/SEEK callbacks                 * */
+/* *             - added tracecodes for get/set sectionbreaks               * */
+/* *             - added tracecode for special error routine                * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - added tracecode for updatemngheader                      * */
+/* *                                                                        * */
+/* *             0.9.2 - 07/31/2000 - G.Juyn                                * */
+/* *             - added tracecodes for status_xxxxx functions              * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *             - added tracecode for updatemngsimplicity                  * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/26/2000 - G.Juyn                                * */
+/* *             - added MAGN chunk                                         * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *             0.9.3 - 10/10/2000 - G.Juyn                                * */
+/* *             - added support for alpha-depth prediction                 * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - added JDAA chunk                                         * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/16/2000 - G.Juyn                                * */
+/* *             - added functions to retrieve PNG/JNG specific header-info * */
+/* *             - added optional support for bKGD for PNG images           * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *             - added routine to discard "invalid" objects               * */
+/* *             0.9.3 - 10/19/2000 - G.Juyn                                * */
+/* *             - implemented delayed delta-processing                     * */
+/* *             0.9.3 - 10/20/2000 - G.Juyn                                * */
+/* *             - added get/set for bKGD preference setting                * */
+/* *             0.9.3 - 10/21/2000 - G.Juyn                                * */
+/* *             - added get function for interlace/progressive display     * */
+/* *                                                                        * */
+/* *             0.9.4 -  1/18/2001 - G.Juyn                                * */
+/* *             - added "new" MAGN methods 3, 4 & 5                        * */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *             1.0.1 - 04/21/2001 - G.Juyn (code by G.Kelly)              * */
+/* *             - added BGRA8 canvas with premultiplied alpha              * */
+/* *             1.0.1 - 05/02/2001 - G.Juyn                                * */
+/* *             - added "default" sRGB generation (Thanks Marti!)          * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added optimization option for MNG-video playback         * */
+/* *             - added processterm callback                               * */
+/* *             1.0.2 - 06/25/2001 - G.Juyn                                * */
+/* *             - added option to turn off progressive refresh             * */
+/* *                                                                        * */
+/* *             1.0.3 - 08/06/2001 - G.Juyn                                * */
+/* *             - added get function for last processed BACK chunk         * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/15/2002 - G.Juyn                                * */
+/* *             - completed PROM support                                   * */
+/* *             - completed delta-image support                            * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             - added HLAPI function to copy chunks                      * */
+/* *             1.0.5 - 09/14/2002 - G.Juyn                                * */
+/* *             - added event handling for dynamic MNG                     * */
+/* *             1.0.5 - 09/20/2002 - G.Juyn                                * */
+/* *             - added support for PAST                                   * */
+/* *             1.0.5 - 09/22/2002 - G.Juyn                                * */
+/* *             - added bgrx8 canvas (filler byte)                         * */
+/* *             1.0.5 - 09/23/2002 - G.Juyn                                * */
+/* *             - added in-memory color-correction of abstract images      * */
+/* *             - added compose over/under routines for PAST processing    * */
+/* *             - added flip & tile routines for PAST processing           * */
+/* *             1.0.5 - 10/09/2002 - G.Juyn                                * */
+/* *             - fixed trace-constants for PAST chunk                     * */
+/* *             1.0.5 - 11/07/2002 - G.Juyn                                * */
+/* *             - added support to get totals after mng_read()             * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/14/2003 - G.Randers-Pehrson                     * */
+/* *             - added conditionals around rarely used features           * */
+/* *                                                                        * */
+/* *             1.0.7 - 11/27/2003 - R.A                                   * */
+/* *             - added CANVAS_RGB565 and CANVAS_BGR565                    * */
+/* *             1.0.7 - 01/25/2004 - J.S                                   * */
+/* *             - added premultiplied alpha canvas' for RGBA, ARGB, ABGR   * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/02/2004 - G.Juyn                                * */
+/* *             - added CRC existence & checking flags                     * */
+/* *             1.0.8 - 04/11/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *                                                                        * */
+/* *             1.0.9 - 10/03/2004 - G.Juyn                                * */
+/* *             - added function to retrieve current FRAM delay            * */
+/* *             1.0.9 - 10/14/2004 - G.Juyn                                * */
+/* *             - added bgr565_a8 canvas-style (thanks to J. Elvander)     * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 07/06/2007 - G.R-P bugfix by Lucas Quintana       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_trace_h_
+#define _libmng_trace_h_
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_TRACE_PROCS
+
+/* ************************************************************************** */
+
+/* TODO: add a trace-mask so certain functions can be excluded */
+
+mng_retcode mng_trace (mng_datap  pData,
+                       mng_uint32 iFunction,
+                       mng_uint32 iLocation);
+
+/* ************************************************************************** */
+
+#define MNG_TRACE(D,F,L)  { mng_retcode iR = mng_trace (D,F,L); \
+                            if (iR) return iR; }
+
+#define MNG_TRACEB(D,F,L) { if (mng_trace (D,F,L)) return MNG_FALSE; }
+
+#define MNG_TRACEX(D,F,L) { if (mng_trace (D,F,L)) return 0; }
+
+/* ************************************************************************** */
+
+#define MNG_LC_START                    1
+#define MNG_LC_END                      2
+#define MNG_LC_INITIALIZE               3
+#define MNG_LC_CLEANUP                  4
+
+/* ************************************************************************** */
+
+#define MNG_LC_JPEG_CREATE_DECOMPRESS   101
+#define MNG_LC_JPEG_READ_HEADER         102
+#define MNG_LC_JPEG_START_DECOMPRESS    103
+#define MNG_LC_JPEG_START_OUTPUT        104
+#define MNG_LC_JPEG_READ_SCANLINES      105
+#define MNG_LC_JPEG_FINISH_OUTPUT       106
+#define MNG_LC_JPEG_FINISH_DECOMPRESS   107
+#define MNG_LC_JPEG_DESTROY_DECOMPRESS  108
+
+/* ************************************************************************** */
+
+#define MNG_FN_INITIALIZE               1
+#define MNG_FN_RESET                    2
+#define MNG_FN_CLEANUP                  3
+#define MNG_FN_READ                     4
+#define MNG_FN_WRITE                    5
+#define MNG_FN_CREATE                   6
+#define MNG_FN_READDISPLAY              7
+#define MNG_FN_DISPLAY                  8
+#define MNG_FN_DISPLAY_RESUME           9
+#define MNG_FN_DISPLAY_FREEZE          10
+#define MNG_FN_DISPLAY_RESET           11
+#ifndef MNG_NO_DISPLAY_GO_SUPPORTED
+#define MNG_FN_DISPLAY_GOFRAME         12
+#define MNG_FN_DISPLAY_GOLAYER         13
+#define MNG_FN_DISPLAY_GOTIME          14
+#endif
+#define MNG_FN_GETLASTERROR            15
+#define MNG_FN_READ_RESUME             16
+#define MNG_FN_TRAPEVENT               17
+#define MNG_FN_READ_PUSHDATA           18
+#define MNG_FN_READ_PUSHSIG            19
+#define MNG_FN_READ_PUSHCHUNK          20
+
+#define MNG_FN_SETCB_MEMALLOC         101
+#define MNG_FN_SETCB_MEMFREE          102
+#define MNG_FN_SETCB_READDATA         103
+#define MNG_FN_SETCB_WRITEDATA        104
+#define MNG_FN_SETCB_ERRORPROC        105
+#define MNG_FN_SETCB_TRACEPROC        106
+#define MNG_FN_SETCB_PROCESSHEADER    107
+#define MNG_FN_SETCB_PROCESSTEXT      108
+#define MNG_FN_SETCB_GETCANVASLINE    109
+#define MNG_FN_SETCB_GETBKGDLINE      110
+#define MNG_FN_SETCB_REFRESH          111
+#define MNG_FN_SETCB_GETTICKCOUNT     112
+#define MNG_FN_SETCB_SETTIMER         113
+#define MNG_FN_SETCB_PROCESSGAMMA     114
+#define MNG_FN_SETCB_PROCESSCHROMA    115
+#define MNG_FN_SETCB_PROCESSSRGB      116
+#define MNG_FN_SETCB_PROCESSICCP      117
+#define MNG_FN_SETCB_PROCESSAROW      118
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+#define MNG_FN_SETCB_OPENSTREAM       119
+#define MNG_FN_SETCB_CLOSESTREAM      120
+#endif
+#define MNG_FN_SETCB_GETALPHALINE     121
+#define MNG_FN_SETCB_PROCESSSAVE      122
+#define MNG_FN_SETCB_PROCESSSEEK      123
+#define MNG_FN_SETCB_PROCESSNEED      124
+#define MNG_FN_SETCB_PROCESSUNKNOWN   125
+#define MNG_FN_SETCB_PROCESSMEND      126
+#define MNG_FN_SETCB_PROCESSTERM      127
+#define MNG_FN_SETCB_RELEASEDATA      128
+
+#define MNG_FN_GETCB_MEMALLOC         201
+#define MNG_FN_GETCB_MEMFREE          202
+#define MNG_FN_GETCB_READDATA         203
+#define MNG_FN_GETCB_WRITEDATA        204
+#define MNG_FN_GETCB_ERRORPROC        205
+#define MNG_FN_GETCB_TRACEPROC        206
+#define MNG_FN_GETCB_PROCESSHEADER    207
+#define MNG_FN_GETCB_PROCESSTEXT      208
+#define MNG_FN_GETCB_GETCANVASLINE    209
+#define MNG_FN_GETCB_GETBKGDLINE      210
+#define MNG_FN_GETCB_REFRESH          211
+#define MNG_FN_GETCB_GETTICKCOUNT     212
+#define MNG_FN_GETCB_SETTIMER         213
+#define MNG_FN_GETCB_PROCESSGAMMA     214
+#define MNG_FN_GETCB_PROCESSCHROMA    215
+#define MNG_FN_GETCB_PROCESSSRGB      216
+#define MNG_FN_GETCB_PROCESSICCP      217
+#define MNG_FN_GETCB_PROCESSAROW      218
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+#define MNG_FN_GETCB_OPENSTREAM       219
+#define MNG_FN_GETCB_CLOSESTREAM      220
+#endif
+#define MNG_FN_GETCB_GETALPHALINE     221
+#define MNG_FN_GETCB_PROCESSSAVE      222
+#define MNG_FN_GETCB_PROCESSSEEK      223
+#define MNG_FN_GETCB_PROCESSNEED      224
+#define MNG_FN_GETCB_PROCESSUNKNOWN   225
+#define MNG_FN_GETCB_PROCESSMEND      226
+#define MNG_FN_GETCB_PROCESSTERM      227
+#define MNG_FN_GETCB_RELEASEDATA      228
+
+#define MNG_FN_SET_USERDATA           301
+#define MNG_FN_SET_CANVASSTYLE        302
+#define MNG_FN_SET_BKGDSTYLE          303
+#define MNG_FN_SET_BGCOLOR            304
+#define MNG_FN_SET_STORECHUNKS        305
+#define MNG_FN_SET_VIEWGAMMA          306
+#define MNG_FN_SET_DISPLAYGAMMA       307
+#define MNG_FN_SET_DFLTIMGGAMMA       308
+#define MNG_FN_SET_SRGB               309
+#define MNG_FN_SET_OUTPUTPROFILE      310
+#define MNG_FN_SET_SRGBPROFILE        311
+#define MNG_FN_SET_MAXCANVASWIDTH     312
+#define MNG_FN_SET_MAXCANVASHEIGHT    313
+#define MNG_FN_SET_MAXCANVASSIZE      314
+#define MNG_FN_SET_ZLIB_LEVEL         315
+#define MNG_FN_SET_ZLIB_METHOD        316
+#define MNG_FN_SET_ZLIB_WINDOWBITS    317
+#define MNG_FN_SET_ZLIB_MEMLEVEL      318
+#define MNG_FN_SET_ZLIB_STRATEGY      319
+#define MNG_FN_SET_ZLIB_MAXIDAT       320
+#define MNG_FN_SET_JPEG_DCTMETHOD     321
+#define MNG_FN_SET_JPEG_QUALITY       322
+#define MNG_FN_SET_JPEG_SMOOTHING     323
+#define MNG_FN_SET_JPEG_PROGRESSIVE   324
+#define MNG_FN_SET_JPEG_OPTIMIZED     325
+#define MNG_FN_SET_JPEG_MAXJDAT       326
+#define MNG_FN_SET_SPEED              327
+#define MNG_FN_SET_SUSPENSIONMODE     328
+#define MNG_FN_SET_SECTIONBREAKS      329
+#define MNG_FN_SET_USEBKGD            330
+#define MNG_FN_SET_OUTPUTPROFILE2     331
+#define MNG_FN_SET_SRGBPROFILE2       332
+#define MNG_FN_SET_OUTPUTSRGB         333
+#define MNG_FN_SET_SRGBIMPLICIT       334
+#define MNG_FN_SET_CACHEPLAYBACK      335
+#define MNG_FN_SET_DOPROGRESSIVE      336
+#define MNG_FN_SET_CRCMODE            337
+
+#define MNG_FN_GET_USERDATA           401
+#define MNG_FN_GET_SIGTYPE            402
+#define MNG_FN_GET_IMAGETYPE          403
+#define MNG_FN_GET_IMAGEWIDTH         404
+#define MNG_FN_GET_IMAGEHEIGHT        405
+#define MNG_FN_GET_TICKS              406
+#define MNG_FN_GET_FRAMECOUNT         407
+#define MNG_FN_GET_LAYERCOUNT         408
+#define MNG_FN_GET_PLAYTIME           409
+#define MNG_FN_GET_SIMPLICITY         410
+#define MNG_FN_GET_CANVASSTYLE        411
+#define MNG_FN_GET_BKGDSTYLE          412
+#define MNG_FN_GET_BGCOLOR            413
+#define MNG_FN_GET_STORECHUNKS        414
+#define MNG_FN_GET_VIEWGAMMA          415
+#define MNG_FN_GET_DISPLAYGAMMA       416
+#define MNG_FN_GET_DFLTIMGGAMMA       417
+#define MNG_FN_GET_SRGB               418
+#define MNG_FN_GET_MAXCANVASWIDTH     419
+#define MNG_FN_GET_MAXCANVASHEIGHT    420
+#define MNG_FN_GET_ZLIB_LEVEL         421
+#define MNG_FN_GET_ZLIB_METHOD        422
+#define MNG_FN_GET_ZLIB_WINDOWBITS    423
+#define MNG_FN_GET_ZLIB_MEMLEVEL      424
+#define MNG_FN_GET_ZLIB_STRATEGY      425
+#define MNG_FN_GET_ZLIB_MAXIDAT       426
+#define MNG_FN_GET_JPEG_DCTMETHOD     427
+#define MNG_FN_GET_JPEG_QUALITY       428
+#define MNG_FN_GET_JPEG_SMOOTHING     429
+#define MNG_FN_GET_JPEG_PROGRESSIVE   430
+#define MNG_FN_GET_JPEG_OPTIMIZED     431
+#define MNG_FN_GET_JPEG_MAXJDAT       432
+#define MNG_FN_GET_SPEED              433
+#define MNG_FN_GET_IMAGELEVEL         434
+#define MNG_FN_GET_SUSPENSIONMODE     435
+#define MNG_FN_GET_STARTTIME          436
+#define MNG_FN_GET_RUNTIME            437
+#define MNG_FN_GET_CURRENTFRAME       438
+#define MNG_FN_GET_CURRENTLAYER       439
+#define MNG_FN_GET_CURRENTPLAYTIME    440
+#define MNG_FN_GET_SECTIONBREAKS      441
+#define MNG_FN_GET_ALPHADEPTH         442
+#define MNG_FN_GET_BITDEPTH           443
+#define MNG_FN_GET_COLORTYPE          444
+#define MNG_FN_GET_COMPRESSION        445
+#define MNG_FN_GET_FILTER             446
+#define MNG_FN_GET_INTERLACE          447
+#define MNG_FN_GET_ALPHABITDEPTH      448
+#define MNG_FN_GET_ALPHACOMPRESSION   449
+#define MNG_FN_GET_ALPHAFILTER        450
+#define MNG_FN_GET_ALPHAINTERLACE     451
+#define MNG_FN_GET_USEBKGD            452
+#define MNG_FN_GET_REFRESHPASS        453
+#define MNG_FN_GET_CACHEPLAYBACK      454
+#define MNG_FN_GET_DOPROGRESSIVE      455
+#define MNG_FN_GET_LASTBACKCHUNK      456
+#define MNG_FN_GET_LASTSEEKNAME       457
+#define MNG_FN_GET_TOTALFRAMES        458
+#define MNG_FN_GET_TOTALLAYERS        459
+#define MNG_FN_GET_TOTALPLAYTIME      460
+#define MNG_FN_GET_CRCMODE            461
+#define MNG_FN_GET_CURRFRAMDELAY      462
+
+#define MNG_FN_STATUS_ERROR           481
+#define MNG_FN_STATUS_READING         482
+#define MNG_FN_STATUS_SUSPENDBREAK    483
+#define MNG_FN_STATUS_CREATING        484
+#define MNG_FN_STATUS_WRITING         485
+#define MNG_FN_STATUS_DISPLAYING      486
+#define MNG_FN_STATUS_RUNNING         487
+#define MNG_FN_STATUS_TIMERBREAK      488
+#define MNG_FN_STATUS_DYNAMIC         489
+#define MNG_FN_STATUS_RUNNINGEVENT    490
+
+/* ************************************************************************** */
+
+#define MNG_FN_ITERATE_CHUNKS         601
+#define MNG_FN_COPY_CHUNK             602
+
+#define MNG_FN_GETCHUNK_IHDR          701
+#define MNG_FN_GETCHUNK_PLTE          702
+#define MNG_FN_GETCHUNK_IDAT          703
+#define MNG_FN_GETCHUNK_IEND          704
+#define MNG_FN_GETCHUNK_TRNS          705
+#define MNG_FN_GETCHUNK_GAMA          706
+#define MNG_FN_GETCHUNK_CHRM          707
+#define MNG_FN_GETCHUNK_SRGB          708
+#define MNG_FN_GETCHUNK_ICCP          709
+#define MNG_FN_GETCHUNK_TEXT          710
+#define MNG_FN_GETCHUNK_ZTXT          711
+#define MNG_FN_GETCHUNK_ITXT          712
+#define MNG_FN_GETCHUNK_BKGD          713
+#define MNG_FN_GETCHUNK_PHYS          714
+#define MNG_FN_GETCHUNK_SBIT          715
+#define MNG_FN_GETCHUNK_SPLT          716
+#define MNG_FN_GETCHUNK_HIST          717
+#define MNG_FN_GETCHUNK_TIME          718
+#define MNG_FN_GETCHUNK_MHDR          719
+#define MNG_FN_GETCHUNK_MEND          720
+#define MNG_FN_GETCHUNK_LOOP          721
+#define MNG_FN_GETCHUNK_ENDL          722
+#define MNG_FN_GETCHUNK_DEFI          723
+#define MNG_FN_GETCHUNK_BASI          724
+#define MNG_FN_GETCHUNK_CLON          725
+#define MNG_FN_GETCHUNK_PAST          726
+#define MNG_FN_GETCHUNK_DISC          727
+#define MNG_FN_GETCHUNK_BACK          728
+#define MNG_FN_GETCHUNK_FRAM          729
+#define MNG_FN_GETCHUNK_MOVE          730
+#define MNG_FN_GETCHUNK_CLIP          731
+#define MNG_FN_GETCHUNK_SHOW          732
+#define MNG_FN_GETCHUNK_TERM          733
+#define MNG_FN_GETCHUNK_SAVE          734
+#define MNG_FN_GETCHUNK_SEEK          735
+#define MNG_FN_GETCHUNK_EXPI          736
+#define MNG_FN_GETCHUNK_FPRI          737
+#define MNG_FN_GETCHUNK_NEED          738
+#define MNG_FN_GETCHUNK_PHYG          739
+#define MNG_FN_GETCHUNK_JHDR          740
+#define MNG_FN_GETCHUNK_JDAT          741
+#define MNG_FN_GETCHUNK_JSEP          742
+#define MNG_FN_GETCHUNK_DHDR          743
+#define MNG_FN_GETCHUNK_PROM          744
+#define MNG_FN_GETCHUNK_IPNG          745
+#define MNG_FN_GETCHUNK_PPLT          746
+#define MNG_FN_GETCHUNK_IJNG          747
+#define MNG_FN_GETCHUNK_DROP          748
+#define MNG_FN_GETCHUNK_DBYK          749
+#define MNG_FN_GETCHUNK_ORDR          750
+#define MNG_FN_GETCHUNK_UNKNOWN       751
+#define MNG_FN_GETCHUNK_MAGN          752
+#define MNG_FN_GETCHUNK_JDAA          753
+#define MNG_FN_GETCHUNK_EVNT          754
+#define MNG_FN_GETCHUNK_MPNG          755
+
+#define MNG_FN_GETCHUNK_PAST_SRC      781
+#define MNG_FN_GETCHUNK_SAVE_ENTRY    782
+#define MNG_FN_GETCHUNK_PPLT_ENTRY    783
+#define MNG_FN_GETCHUNK_ORDR_ENTRY    784
+#define MNG_FN_GETCHUNK_EVNT_ENTRY    785
+#define MNG_FN_GETCHUNK_MPNG_FRAME    786
+
+#define MNG_FN_PUTCHUNK_IHDR          801
+#define MNG_FN_PUTCHUNK_PLTE          802
+#define MNG_FN_PUTCHUNK_IDAT          803
+#define MNG_FN_PUTCHUNK_IEND          804
+#define MNG_FN_PUTCHUNK_TRNS          805
+#define MNG_FN_PUTCHUNK_GAMA          806
+#define MNG_FN_PUTCHUNK_CHRM          807
+#define MNG_FN_PUTCHUNK_SRGB          808
+#define MNG_FN_PUTCHUNK_ICCP          809
+#define MNG_FN_PUTCHUNK_TEXT          810
+#define MNG_FN_PUTCHUNK_ZTXT          811
+#define MNG_FN_PUTCHUNK_ITXT          812
+#define MNG_FN_PUTCHUNK_BKGD          813
+#define MNG_FN_PUTCHUNK_PHYS          814
+#define MNG_FN_PUTCHUNK_SBIT          815
+#define MNG_FN_PUTCHUNK_SPLT          816
+#define MNG_FN_PUTCHUNK_HIST          817
+#define MNG_FN_PUTCHUNK_TIME          818
+#define MNG_FN_PUTCHUNK_MHDR          819
+#define MNG_FN_PUTCHUNK_MEND          820
+#define MNG_FN_PUTCHUNK_LOOP          821
+#define MNG_FN_PUTCHUNK_ENDL          822
+#define MNG_FN_PUTCHUNK_DEFI          823
+#define MNG_FN_PUTCHUNK_BASI          824
+#define MNG_FN_PUTCHUNK_CLON          825
+#define MNG_FN_PUTCHUNK_PAST          826
+#define MNG_FN_PUTCHUNK_DISC          827
+#define MNG_FN_PUTCHUNK_BACK          828
+#define MNG_FN_PUTCHUNK_FRAM          829
+#define MNG_FN_PUTCHUNK_MOVE          830
+#define MNG_FN_PUTCHUNK_CLIP          831
+#define MNG_FN_PUTCHUNK_SHOW          832
+#define MNG_FN_PUTCHUNK_TERM          833
+#define MNG_FN_PUTCHUNK_SAVE          834
+#define MNG_FN_PUTCHUNK_SEEK          835
+#define MNG_FN_PUTCHUNK_EXPI          836
+#define MNG_FN_PUTCHUNK_FPRI          837
+#define MNG_FN_PUTCHUNK_NEED          838
+#define MNG_FN_PUTCHUNK_PHYG          839
+#define MNG_FN_PUTCHUNK_JHDR          840
+#define MNG_FN_PUTCHUNK_JDAT          841
+#define MNG_FN_PUTCHUNK_JSEP          842
+#define MNG_FN_PUTCHUNK_DHDR          843
+#define MNG_FN_PUTCHUNK_PROM          844
+#define MNG_FN_PUTCHUNK_IPNG          845
+#define MNG_FN_PUTCHUNK_PPLT          846
+#define MNG_FN_PUTCHUNK_IJNG          847
+#define MNG_FN_PUTCHUNK_DROP          848
+#define MNG_FN_PUTCHUNK_DBYK          849
+#define MNG_FN_PUTCHUNK_ORDR          850
+#define MNG_FN_PUTCHUNK_UNKNOWN       851
+#define MNG_FN_PUTCHUNK_MAGN          852
+#define MNG_FN_PUTCHUNK_JDAA          853
+#define MNG_FN_PUTCHUNK_EVNT          854
+#define MNG_FN_PUTCHUNK_MPNG          855
+
+#define MNG_FN_PUTCHUNK_PAST_SRC      881
+#define MNG_FN_PUTCHUNK_SAVE_ENTRY    882
+#define MNG_FN_PUTCHUNK_PPLT_ENTRY    883
+#define MNG_FN_PUTCHUNK_ORDR_ENTRY    884
+#define MNG_FN_PUTCHUNK_EVNT_ENTRY    885
+#define MNG_FN_PUTCHUNK_MPNG_FRAME    886
+
+/* ************************************************************************** */
+
+#define MNG_FN_GETIMGDATA_SEQ         901
+#define MNG_FN_GETIMGDATA_CHUNKSEQ    902
+#define MNG_FN_GETIMGDATA_CHUNK       903
+
+#define MNG_FN_PUTIMGDATA_IHDR        951
+#define MNG_FN_PUTIMGDATA_JHDR        952
+#define MNG_FN_PUTIMGDATA_BASI        953
+#define MNG_FN_PUTIMGDATA_DHDR        954
+
+#define MNG_FN_UPDATEMNGHEADER        981
+#define MNG_FN_UPDATEMNGSIMPLICITY    982
+
+/* ************************************************************************** */
+
+#define MNG_FN_PROCESS_RAW_CHUNK     1001
+#define MNG_FN_READ_GRAPHIC          1002
+#define MNG_FN_DROP_CHUNKS           1003
+#define MNG_FN_PROCESS_ERROR         1004
+#define MNG_FN_CLEAR_CMS             1005
+#define MNG_FN_DROP_OBJECTS          1006
+#define MNG_FN_READ_CHUNK            1007
+#define MNG_FN_LOAD_BKGDLAYER        1008
+#define MNG_FN_NEXT_FRAME            1009
+#define MNG_FN_NEXT_LAYER            1010
+#define MNG_FN_INTERFRAME_DELAY      1011
+#define MNG_FN_DISPLAY_IMAGE         1012
+#define MNG_FN_DROP_IMGOBJECTS       1013
+#define MNG_FN_DROP_ANIOBJECTS       1014
+#define MNG_FN_INFLATE_BUFFER        1015
+#define MNG_FN_DEFLATE_BUFFER        1016
+#define MNG_FN_WRITE_RAW_CHUNK       1017
+#define MNG_FN_WRITE_GRAPHIC         1018
+#define MNG_FN_SAVE_STATE            1019
+#define MNG_FN_RESTORE_STATE         1020
+#define MNG_FN_DROP_SAVEDATA         1021
+#define MNG_FN_EXECUTE_DELTA_IMAGE   1022
+#define MNG_FN_PROCESS_DISPLAY       1023
+#define MNG_FN_CLEAR_CANVAS          1024
+#define MNG_FN_READ_DATABUFFER       1025
+#define MNG_FN_STORE_ERROR           1026
+#define MNG_FN_DROP_INVALID_OBJECTS  1027
+#define MNG_FN_RELEASE_PUSHDATA      1028
+#define MNG_FN_READ_DATA             1029
+#define MNG_FN_READ_CHUNK_CRC        1030
+#define MNG_FN_RELEASE_PUSHCHUNK     1031
+
+/* ************************************************************************** */
+
+#define MNG_FN_DISPLAY_RGB8          1101
+#define MNG_FN_DISPLAY_RGBA8         1102
+#define MNG_FN_DISPLAY_ARGB8         1103
+#define MNG_FN_DISPLAY_BGR8          1104
+#define MNG_FN_DISPLAY_BGRA8         1105
+#define MNG_FN_DISPLAY_ABGR8         1106
+#define MNG_FN_DISPLAY_RGB16         1107
+#define MNG_FN_DISPLAY_RGBA16        1108
+#define MNG_FN_DISPLAY_ARGB16        1109
+#define MNG_FN_DISPLAY_BGR16         1110
+#define MNG_FN_DISPLAY_BGRA16        1111
+#define MNG_FN_DISPLAY_ABGR16        1112
+#define MNG_FN_DISPLAY_INDEX8        1113
+#define MNG_FN_DISPLAY_INDEXA8       1114
+#define MNG_FN_DISPLAY_AINDEX8       1115
+#define MNG_FN_DISPLAY_GRAY8         1116
+#define MNG_FN_DISPLAY_GRAY16        1117
+#define MNG_FN_DISPLAY_GRAYA8        1118
+#define MNG_FN_DISPLAY_GRAYA16       1119
+#define MNG_FN_DISPLAY_AGRAY8        1120
+#define MNG_FN_DISPLAY_AGRAY16       1121
+#define MNG_FN_DISPLAY_DX15          1122
+#define MNG_FN_DISPLAY_DX16          1123
+#define MNG_FN_DISPLAY_RGB8_A8       1124
+#define MNG_FN_DISPLAY_BGRA8PM       1125
+#define MNG_FN_DISPLAY_BGRX8         1126
+#define MNG_FN_DISPLAY_RGB565        1127
+#define MNG_FN_DISPLAY_RGBA565       1128
+#define MNG_FN_DISPLAY_BGR565        1129
+#define MNG_FN_DISPLAY_BGRA565       1130
+#define MNG_FN_DISPLAY_RGBA8_PM      1131
+#define MNG_FN_DISPLAY_ARGB8_PM      1132
+#define MNG_FN_DISPLAY_ABGR8_PM      1133
+#define MNG_FN_DISPLAY_BGR565_A8     1134
+#define MNG_FN_DISPLAY_RGB555        1135
+#define MNG_FN_DISPLAY_BGR555        1136
+
+/* ************************************************************************** */
+
+#define MNG_FN_INIT_FULL_CMS         1201
+#define MNG_FN_CORRECT_FULL_CMS      1202
+#define MNG_FN_INIT_GAMMA_ONLY       1204
+#define MNG_FN_CORRECT_GAMMA_ONLY    1205
+#define MNG_FN_CORRECT_APP_CMS       1206
+#define MNG_FN_INIT_FULL_CMS_OBJ     1207
+#define MNG_FN_INIT_GAMMA_ONLY_OBJ   1208
+#define MNG_FN_INIT_APP_CMS          1209
+#define MNG_FN_INIT_APP_CMS_OBJ      1210
+
+/* ************************************************************************** */
+
+#define MNG_FN_PROCESS_G1            1301
+#define MNG_FN_PROCESS_G2            1302
+#define MNG_FN_PROCESS_G4            1303
+#define MNG_FN_PROCESS_G8            1304
+#define MNG_FN_PROCESS_G16           1305
+#define MNG_FN_PROCESS_RGB8          1306
+#define MNG_FN_PROCESS_RGB16         1307
+#define MNG_FN_PROCESS_IDX1          1308
+#define MNG_FN_PROCESS_IDX2          1309
+#define MNG_FN_PROCESS_IDX4          1310
+#define MNG_FN_PROCESS_IDX8          1311
+#define MNG_FN_PROCESS_GA8           1312
+#define MNG_FN_PROCESS_GA16          1313
+#define MNG_FN_PROCESS_RGBA8         1314
+#define MNG_FN_PROCESS_RGBA16        1315
+
+/* ************************************************************************** */
+
+#define MNG_FN_INIT_G1_NI            1401
+#define MNG_FN_INIT_G1_I             1402
+#define MNG_FN_INIT_G2_NI            1403
+#define MNG_FN_INIT_G2_I             1404
+#define MNG_FN_INIT_G4_NI            1405
+#define MNG_FN_INIT_G4_I             1406
+#define MNG_FN_INIT_G8_NI            1407
+#define MNG_FN_INIT_G8_I             1408
+#define MNG_FN_INIT_G16_NI           1409
+#define MNG_FN_INIT_G16_I            1410
+#define MNG_FN_INIT_RGB8_NI          1411
+#define MNG_FN_INIT_RGB8_I           1412
+#define MNG_FN_INIT_RGB16_NI         1413
+#define MNG_FN_INIT_RGB16_I          1414
+#define MNG_FN_INIT_IDX1_NI          1415
+#define MNG_FN_INIT_IDX1_I           1416
+#define MNG_FN_INIT_IDX2_NI          1417
+#define MNG_FN_INIT_IDX2_I           1418
+#define MNG_FN_INIT_IDX4_NI          1419
+#define MNG_FN_INIT_IDX4_I           1420
+#define MNG_FN_INIT_IDX8_NI          1421
+#define MNG_FN_INIT_IDX8_I           1422
+#define MNG_FN_INIT_GA8_NI           1423
+#define MNG_FN_INIT_GA8_I            1424
+#define MNG_FN_INIT_GA16_NI          1425
+#define MNG_FN_INIT_GA16_I           1426
+#define MNG_FN_INIT_RGBA8_NI         1427
+#define MNG_FN_INIT_RGBA8_I          1428
+#define MNG_FN_INIT_RGBA16_NI        1429
+#define MNG_FN_INIT_RGBA16_I         1430
+
+#define MNG_FN_INIT_ROWPROC          1497
+#define MNG_FN_NEXT_ROW              1498
+#define MNG_FN_CLEANUP_ROWPROC       1499
+
+/* ************************************************************************** */
+
+#define MNG_FN_FILTER_A_ROW          1501
+#define MNG_FN_FILTER_SUB            1502
+#define MNG_FN_FILTER_UP             1503
+#define MNG_FN_FILTER_AVERAGE        1504
+#define MNG_FN_FILTER_PAETH          1505
+
+#define MNG_FN_INIT_ROWDIFFERING     1551
+#define MNG_FN_DIFFER_G1             1552
+#define MNG_FN_DIFFER_G2             1553
+#define MNG_FN_DIFFER_G4             1554
+#define MNG_FN_DIFFER_G8             1555
+#define MNG_FN_DIFFER_G16            1556
+#define MNG_FN_DIFFER_RGB8           1557
+#define MNG_FN_DIFFER_RGB16          1558
+#define MNG_FN_DIFFER_IDX1           1559
+#define MNG_FN_DIFFER_IDX2           1560
+#define MNG_FN_DIFFER_IDX4           1561
+#define MNG_FN_DIFFER_IDX8           1562
+#define MNG_FN_DIFFER_GA8            1563
+#define MNG_FN_DIFFER_GA16           1564
+#define MNG_FN_DIFFER_RGBA8          1565
+#define MNG_FN_DIFFER_RGBA16         1566
+
+/* ************************************************************************** */
+
+#define MNG_FN_CREATE_IMGDATAOBJECT  1601
+#define MNG_FN_FREE_IMGDATAOBJECT    1602
+#define MNG_FN_CLONE_IMGDATAOBJECT   1603
+#define MNG_FN_CREATE_IMGOBJECT      1604
+#define MNG_FN_FREE_IMGOBJECT        1605
+#define MNG_FN_FIND_IMGOBJECT        1606
+#define MNG_FN_CLONE_IMGOBJECT       1607
+#define MNG_FN_RESET_OBJECTDETAILS   1608
+#define MNG_FN_RENUM_IMGOBJECT       1609
+#define MNG_FN_PROMOTE_IMGOBJECT     1610
+#define MNG_FN_MAGNIFY_IMGOBJECT     1611
+#define MNG_FN_COLORCORRECT_OBJECT   1612
+
+/* ************************************************************************** */
+
+#define MNG_FN_STORE_G1              1701
+#define MNG_FN_STORE_G2              1702
+#define MNG_FN_STORE_G4              1703
+#define MNG_FN_STORE_G8              1704
+#define MNG_FN_STORE_G16             1705
+#define MNG_FN_STORE_RGB8            1706
+#define MNG_FN_STORE_RGB16           1707
+#define MNG_FN_STORE_IDX1            1708
+#define MNG_FN_STORE_IDX2            1709
+#define MNG_FN_STORE_IDX4            1710
+#define MNG_FN_STORE_IDX8            1711
+#define MNG_FN_STORE_GA8             1712
+#define MNG_FN_STORE_GA16            1713
+#define MNG_FN_STORE_RGBA8           1714
+#define MNG_FN_STORE_RGBA16          1715
+
+#define MNG_FN_RETRIEVE_G8           1751
+#define MNG_FN_RETRIEVE_G16          1752
+#define MNG_FN_RETRIEVE_RGB8         1753
+#define MNG_FN_RETRIEVE_RGB16        1754
+#define MNG_FN_RETRIEVE_IDX8         1755
+#define MNG_FN_RETRIEVE_GA8          1756
+#define MNG_FN_RETRIEVE_GA16         1757
+#define MNG_FN_RETRIEVE_RGBA8        1758
+#define MNG_FN_RETRIEVE_RGBA16       1759
+
+#define MNG_FN_DELTA_G1              1771
+#define MNG_FN_DELTA_G2              1772
+#define MNG_FN_DELTA_G4              1773
+#define MNG_FN_DELTA_G8              1774
+#define MNG_FN_DELTA_G16             1775
+#define MNG_FN_DELTA_RGB8            1776
+#define MNG_FN_DELTA_RGB16           1777
+#define MNG_FN_DELTA_IDX1            1778
+#define MNG_FN_DELTA_IDX2            1779
+#define MNG_FN_DELTA_IDX4            1780
+#define MNG_FN_DELTA_IDX8            1781
+#define MNG_FN_DELTA_GA8             1782
+#define MNG_FN_DELTA_GA16            1783
+#define MNG_FN_DELTA_RGBA8           1784
+#define MNG_FN_DELTA_RGBA16          1785
+
+/* ************************************************************************** */
+
+#define MNG_FN_CREATE_ANI_LOOP       1801
+#define MNG_FN_CREATE_ANI_ENDL       1802
+#define MNG_FN_CREATE_ANI_DEFI       1803
+#define MNG_FN_CREATE_ANI_BASI       1804
+#define MNG_FN_CREATE_ANI_CLON       1805
+#define MNG_FN_CREATE_ANI_PAST       1806
+#define MNG_FN_CREATE_ANI_DISC       1807
+#define MNG_FN_CREATE_ANI_BACK       1808
+#define MNG_FN_CREATE_ANI_FRAM       1809
+#define MNG_FN_CREATE_ANI_MOVE       1810
+#define MNG_FN_CREATE_ANI_CLIP       1811
+#define MNG_FN_CREATE_ANI_SHOW       1812
+#define MNG_FN_CREATE_ANI_TERM       1813
+#define MNG_FN_CREATE_ANI_SAVE       1814
+#define MNG_FN_CREATE_ANI_SEEK       1815
+#define MNG_FN_CREATE_ANI_GAMA       1816
+#define MNG_FN_CREATE_ANI_CHRM       1817
+#define MNG_FN_CREATE_ANI_SRGB       1818
+#define MNG_FN_CREATE_ANI_ICCP       1819
+#define MNG_FN_CREATE_ANI_PLTE       1820
+#define MNG_FN_CREATE_ANI_TRNS       1821
+#define MNG_FN_CREATE_ANI_BKGD       1822
+#define MNG_FN_CREATE_ANI_DHDR       1823
+#define MNG_FN_CREATE_ANI_PROM       1824
+#define MNG_FN_CREATE_ANI_IPNG       1825
+#define MNG_FN_CREATE_ANI_IJNG       1826
+#define MNG_FN_CREATE_ANI_PPLT       1827
+#define MNG_FN_CREATE_ANI_MAGN       1828
+
+#define MNG_FN_CREATE_ANI_IMAGE      1891
+#define MNG_FN_CREATE_EVENT          1892
+
+/* ************************************************************************** */
+
+#define MNG_FN_FREE_ANI_LOOP         1901
+#define MNG_FN_FREE_ANI_ENDL         1902
+#define MNG_FN_FREE_ANI_DEFI         1903
+#define MNG_FN_FREE_ANI_BASI         1904
+#define MNG_FN_FREE_ANI_CLON         1905
+#define MNG_FN_FREE_ANI_PAST         1906
+#define MNG_FN_FREE_ANI_DISC         1907
+#define MNG_FN_FREE_ANI_BACK         1908
+#define MNG_FN_FREE_ANI_FRAM         1909
+#define MNG_FN_FREE_ANI_MOVE         1910
+#define MNG_FN_FREE_ANI_CLIP         1911
+#define MNG_FN_FREE_ANI_SHOW         1912
+#define MNG_FN_FREE_ANI_TERM         1913
+#define MNG_FN_FREE_ANI_SAVE         1914
+#define MNG_FN_FREE_ANI_SEEK         1915
+#define MNG_FN_FREE_ANI_GAMA         1916
+#define MNG_FN_FREE_ANI_CHRM         1917
+#define MNG_FN_FREE_ANI_SRGB         1918
+#define MNG_FN_FREE_ANI_ICCP         1919
+#define MNG_FN_FREE_ANI_PLTE         1920
+#define MNG_FN_FREE_ANI_TRNS         1921
+#define MNG_FN_FREE_ANI_BKGD         1922
+#define MNG_FN_FREE_ANI_DHDR         1923
+#define MNG_FN_FREE_ANI_PROM         1924
+#define MNG_FN_FREE_ANI_IPNG         1925
+#define MNG_FN_FREE_ANI_IJNG         1926
+#define MNG_FN_FREE_ANI_PPLT         1927
+#define MNG_FN_FREE_ANI_MAGN         1928
+
+#define MNG_FN_FREE_ANI_IMAGE        1991
+#define MNG_FN_FREE_EVENT            1992
+
+/* ************************************************************************** */
+
+#define MNG_FN_PROCESS_ANI_LOOP      2001
+#define MNG_FN_PROCESS_ANI_ENDL      2002
+#define MNG_FN_PROCESS_ANI_DEFI      2003
+#define MNG_FN_PROCESS_ANI_BASI      2004
+#define MNG_FN_PROCESS_ANI_CLON      2005
+#define MNG_FN_PROCESS_ANI_PAST      2006
+#define MNG_FN_PROCESS_ANI_DISC      2007
+#define MNG_FN_PROCESS_ANI_BACK      2008
+#define MNG_FN_PROCESS_ANI_FRAM      2009
+#define MNG_FN_PROCESS_ANI_MOVE      2010
+#define MNG_FN_PROCESS_ANI_CLIP      2011
+#define MNG_FN_PROCESS_ANI_SHOW      2012
+#define MNG_FN_PROCESS_ANI_TERM      2013
+#define MNG_FN_PROCESS_ANI_SAVE      2014
+#define MNG_FN_PROCESS_ANI_SEEK      2015
+#define MNG_FN_PROCESS_ANI_GAMA      2016
+#define MNG_FN_PROCESS_ANI_CHRM      2017
+#define MNG_FN_PROCESS_ANI_SRGB      2018
+#define MNG_FN_PROCESS_ANI_ICCP      2019
+#define MNG_FN_PROCESS_ANI_PLTE      2020
+#define MNG_FN_PROCESS_ANI_TRNS      2021
+#define MNG_FN_PROCESS_ANI_BKGD      2022
+#define MNG_FN_PROCESS_ANI_DHDR      2023
+#define MNG_FN_PROCESS_ANI_PROM      2024
+#define MNG_FN_PROCESS_ANI_IPNG      2025
+#define MNG_FN_PROCESS_ANI_IJNG      2026
+#define MNG_FN_PROCESS_ANI_PPLT      2027
+#define MNG_FN_PROCESS_ANI_MAGN      2028
+
+#define MNG_FN_PROCESS_ANI_IMAGE     2091
+#define MNG_FN_PROCESS_EVENT         2092
+
+/* ************************************************************************** */
+
+#define MNG_FN_RESTORE_BACKIMAGE     2101
+#define MNG_FN_RESTORE_BACKCOLOR     2102
+#define MNG_FN_RESTORE_BGCOLOR       2103
+#define MNG_FN_RESTORE_RGB8          2104
+#define MNG_FN_RESTORE_BGR8          2105
+#define MNG_FN_RESTORE_BKGD          2106
+#define MNG_FN_RESTORE_BGRX8         2107
+#define MNG_FN_RESTORE_RGB565        2108
+#define MNG_FN_RESTORE_BGR565        2109
+
+/* ************************************************************************** */
+
+#define MNG_FN_INIT_IHDR             2201
+#define MNG_FN_INIT_PLTE             2202
+#define MNG_FN_INIT_IDAT             2203
+#define MNG_FN_INIT_IEND             2204
+#define MNG_FN_INIT_TRNS             2205
+#define MNG_FN_INIT_GAMA             2206
+#define MNG_FN_INIT_CHRM             2207
+#define MNG_FN_INIT_SRGB             2208
+#define MNG_FN_INIT_ICCP             2209
+#define MNG_FN_INIT_TEXT             2210
+#define MNG_FN_INIT_ZTXT             2211
+#define MNG_FN_INIT_ITXT             2212
+#define MNG_FN_INIT_BKGD             2213
+#define MNG_FN_INIT_PHYS             2214
+#define MNG_FN_INIT_SBIT             2215
+#define MNG_FN_INIT_SPLT             2216
+#define MNG_FN_INIT_HIST             2217
+#define MNG_FN_INIT_TIME             2218
+#define MNG_FN_INIT_MHDR             2219
+#define MNG_FN_INIT_MEND             2220
+#define MNG_FN_INIT_LOOP             2221
+#define MNG_FN_INIT_ENDL             2222
+#define MNG_FN_INIT_DEFI             2223
+#define MNG_FN_INIT_BASI             2224
+#define MNG_FN_INIT_CLON             2225
+#define MNG_FN_INIT_PAST             2226
+#define MNG_FN_INIT_DISC             2227
+#define MNG_FN_INIT_BACK             2228
+#define MNG_FN_INIT_FRAM             2229
+#define MNG_FN_INIT_MOVE             2230
+#define MNG_FN_INIT_CLIP             2231
+#define MNG_FN_INIT_SHOW             2232
+#define MNG_FN_INIT_TERM             2233
+#define MNG_FN_INIT_SAVE             2234
+#define MNG_FN_INIT_SEEK             2235
+#define MNG_FN_INIT_EXPI             2236
+#define MNG_FN_INIT_FPRI             2237
+#define MNG_FN_INIT_NEED             2238
+#define MNG_FN_INIT_PHYG             2239
+#define MNG_FN_INIT_JHDR             2240
+#define MNG_FN_INIT_JDAT             2241
+#define MNG_FN_INIT_JSEP             2242
+#define MNG_FN_INIT_DHDR             2243
+#define MNG_FN_INIT_PROM             2244
+#define MNG_FN_INIT_IPNG             2245
+#define MNG_FN_INIT_PPLT             2246
+#define MNG_FN_INIT_IJNG             2247
+#define MNG_FN_INIT_DROP             2248
+#define MNG_FN_INIT_DBYK             2249
+#define MNG_FN_INIT_ORDR             2250
+#define MNG_FN_INIT_UNKNOWN          2251
+#define MNG_FN_INIT_MAGN             2252
+#define MNG_FN_INIT_JDAA             2253
+#define MNG_FN_INIT_EVNT             2254
+#define MNG_FN_INIT_MPNG             2255
+
+/* ************************************************************************** */
+
+#define MNG_FN_ASSIGN_IHDR           2301
+#define MNG_FN_ASSIGN_PLTE           2302
+#define MNG_FN_ASSIGN_IDAT           2303
+#define MNG_FN_ASSIGN_IEND           2304
+#define MNG_FN_ASSIGN_TRNS           2305
+#define MNG_FN_ASSIGN_GAMA           2306
+#define MNG_FN_ASSIGN_CHRM           2307
+#define MNG_FN_ASSIGN_SRGB           2308
+#define MNG_FN_ASSIGN_ICCP           2309
+#define MNG_FN_ASSIGN_TEXT           2310
+#define MNG_FN_ASSIGN_ZTXT           2311
+#define MNG_FN_ASSIGN_ITXT           2312
+#define MNG_FN_ASSIGN_BKGD           2313
+#define MNG_FN_ASSIGN_PHYS           2314
+#define MNG_FN_ASSIGN_SBIT           2315
+#define MNG_FN_ASSIGN_SPLT           2316
+#define MNG_FN_ASSIGN_HIST           2317
+#define MNG_FN_ASSIGN_TIME           2318
+#define MNG_FN_ASSIGN_MHDR           2319
+#define MNG_FN_ASSIGN_MEND           2320
+#define MNG_FN_ASSIGN_LOOP           2321
+#define MNG_FN_ASSIGN_ENDL           2322
+#define MNG_FN_ASSIGN_DEFI           2323
+#define MNG_FN_ASSIGN_BASI           2324
+#define MNG_FN_ASSIGN_CLON           2325
+#define MNG_FN_ASSIGN_PAST           2326
+#define MNG_FN_ASSIGN_DISC           2327
+#define MNG_FN_ASSIGN_BACK           2328
+#define MNG_FN_ASSIGN_FRAM           2329
+#define MNG_FN_ASSIGN_MOVE           2330
+#define MNG_FN_ASSIGN_CLIP           2331
+#define MNG_FN_ASSIGN_SHOW           2332
+#define MNG_FN_ASSIGN_TERM           2333
+#define MNG_FN_ASSIGN_SAVE           2334
+#define MNG_FN_ASSIGN_SEEK           2335
+#define MNG_FN_ASSIGN_EXPI           2336
+#define MNG_FN_ASSIGN_FPRI           2337
+#define MNG_FN_ASSIGN_NEED           2338
+#define MNG_FN_ASSIGN_PHYG           2339
+#define MNG_FN_ASSIGN_JHDR           2340
+#define MNG_FN_ASSIGN_JDAT           2341
+#define MNG_FN_ASSIGN_JSEP           2342
+#define MNG_FN_ASSIGN_DHDR           2343
+#define MNG_FN_ASSIGN_PROM           2344
+#define MNG_FN_ASSIGN_IPNG           2345
+#define MNG_FN_ASSIGN_PPLT           2346
+#define MNG_FN_ASSIGN_IJNG           2347
+#define MNG_FN_ASSIGN_DROP           2348
+#define MNG_FN_ASSIGN_DBYK           2349
+#define MNG_FN_ASSIGN_ORDR           2350
+#define MNG_FN_ASSIGN_UNKNOWN        2351
+#define MNG_FN_ASSIGN_MAGN           2352
+#define MNG_FN_ASSIGN_JDAA           2353
+#define MNG_FN_ASSIGN_EVNT           2354
+#define MNG_FN_ASSIGN_MPNG           2355
+
+/* ************************************************************************** */
+
+#define MNG_FN_FREE_IHDR             2401
+#define MNG_FN_FREE_PLTE             2402
+#define MNG_FN_FREE_IDAT             2403
+#define MNG_FN_FREE_IEND             2404
+#define MNG_FN_FREE_TRNS             2405
+#define MNG_FN_FREE_GAMA             2406
+#define MNG_FN_FREE_CHRM             2407
+#define MNG_FN_FREE_SRGB             2408
+#define MNG_FN_FREE_ICCP             2409
+#define MNG_FN_FREE_TEXT             2410
+#define MNG_FN_FREE_ZTXT             2411
+#define MNG_FN_FREE_ITXT             2412
+#define MNG_FN_FREE_BKGD             2413
+#define MNG_FN_FREE_PHYS             2414
+#define MNG_FN_FREE_SBIT             2415
+#define MNG_FN_FREE_SPLT             2416
+#define MNG_FN_FREE_HIST             2417
+#define MNG_FN_FREE_TIME             2418
+#define MNG_FN_FREE_MHDR             2419
+#define MNG_FN_FREE_MEND             2420
+#define MNG_FN_FREE_LOOP             2421
+#define MNG_FN_FREE_ENDL             2422
+#define MNG_FN_FREE_DEFI             2423
+#define MNG_FN_FREE_BASI             2424
+#define MNG_FN_FREE_CLON             2425
+#define MNG_FN_FREE_PAST             2426
+#define MNG_FN_FREE_DISC             2427
+#define MNG_FN_FREE_BACK             2428
+#define MNG_FN_FREE_FRAM             2429
+#define MNG_FN_FREE_MOVE             2430
+#define MNG_FN_FREE_CLIP             2431
+#define MNG_FN_FREE_SHOW             2432
+#define MNG_FN_FREE_TERM             2433
+#define MNG_FN_FREE_SAVE             2434
+#define MNG_FN_FREE_SEEK             2435
+#define MNG_FN_FREE_EXPI             2436
+#define MNG_FN_FREE_FPRI             2437
+#define MNG_FN_FREE_NEED             2438
+#define MNG_FN_FREE_PHYG             2439
+#define MNG_FN_FREE_JHDR             2440
+#define MNG_FN_FREE_JDAT             2441
+#define MNG_FN_FREE_JSEP             2442
+#define MNG_FN_FREE_DHDR             2443
+#define MNG_FN_FREE_PROM             2444
+#define MNG_FN_FREE_IPNG             2445
+#define MNG_FN_FREE_PPLT             2446
+#define MNG_FN_FREE_IJNG             2447
+#define MNG_FN_FREE_DROP             2448
+#define MNG_FN_FREE_DBYK             2449
+#define MNG_FN_FREE_ORDR             2450
+#define MNG_FN_FREE_UNKNOWN          2451
+#define MNG_FN_FREE_MAGN             2452
+#define MNG_FN_FREE_JDAA             2453
+#define MNG_FN_FREE_EVNT             2454
+#define MNG_FN_FREE_MPNG             2455
+
+/* ************************************************************************** */
+
+#define MNG_FN_READ_IHDR             2601
+#define MNG_FN_READ_PLTE             2602
+#define MNG_FN_READ_IDAT             2603
+#define MNG_FN_READ_IEND             2604
+#define MNG_FN_READ_TRNS             2605
+#define MNG_FN_READ_GAMA             2606
+#define MNG_FN_READ_CHRM             2607
+#define MNG_FN_READ_SRGB             2608
+#define MNG_FN_READ_ICCP             2609
+#define MNG_FN_READ_TEXT             2610
+#define MNG_FN_READ_ZTXT             2611
+#define MNG_FN_READ_ITXT             2612
+#define MNG_FN_READ_BKGD             2613
+#define MNG_FN_READ_PHYS             2614
+#define MNG_FN_READ_SBIT             2615
+#define MNG_FN_READ_SPLT             2616
+#define MNG_FN_READ_HIST             2617
+#define MNG_FN_READ_TIME             2618
+#define MNG_FN_READ_MHDR             2619
+#define MNG_FN_READ_MEND             2620
+#define MNG_FN_READ_LOOP             2621
+#define MNG_FN_READ_ENDL             2622
+#define MNG_FN_READ_DEFI             2623
+#define MNG_FN_READ_BASI             2624
+#define MNG_FN_READ_CLON             2625
+#define MNG_FN_READ_PAST             2626
+#define MNG_FN_READ_DISC             2627
+#define MNG_FN_READ_BACK             2628
+#define MNG_FN_READ_FRAM             2629
+#define MNG_FN_READ_MOVE             2630
+#define MNG_FN_READ_CLIP             2631
+#define MNG_FN_READ_SHOW             2632
+#define MNG_FN_READ_TERM             2633
+#define MNG_FN_READ_SAVE             2634
+#define MNG_FN_READ_SEEK             2635
+#define MNG_FN_READ_EXPI             2636
+#define MNG_FN_READ_FPRI             2637
+#define MNG_FN_READ_NEED             2638
+#define MNG_FN_READ_PHYG             2639
+#define MNG_FN_READ_JHDR             2640
+#define MNG_FN_READ_JDAT             2641
+#define MNG_FN_READ_JSEP             2642
+#define MNG_FN_READ_DHDR             2643
+#define MNG_FN_READ_PROM             2644
+#define MNG_FN_READ_IPNG             2645
+#define MNG_FN_READ_PPLT             2646
+#define MNG_FN_READ_IJNG             2647
+#define MNG_FN_READ_DROP             2648
+#define MNG_FN_READ_DBYK             2649
+#define MNG_FN_READ_ORDR             2650
+#define MNG_FN_READ_UNKNOWN          2651
+#define MNG_FN_READ_MAGN             2652
+#define MNG_FN_READ_JDAA             2653
+#define MNG_FN_READ_EVNT             2654
+#define MNG_FN_READ_MPNG             2655
+
+/* ************************************************************************** */
+
+#define MNG_FN_WRITE_IHDR            2801
+#define MNG_FN_WRITE_PLTE            2802
+#define MNG_FN_WRITE_IDAT            2803
+#define MNG_FN_WRITE_IEND            2804
+#define MNG_FN_WRITE_TRNS            2805
+#define MNG_FN_WRITE_GAMA            2806
+#define MNG_FN_WRITE_CHRM            2807
+#define MNG_FN_WRITE_SRGB            2808
+#define MNG_FN_WRITE_ICCP            2809
+#define MNG_FN_WRITE_TEXT            2810
+#define MNG_FN_WRITE_ZTXT            2811
+#define MNG_FN_WRITE_ITXT            2812
+#define MNG_FN_WRITE_BKGD            2813
+#define MNG_FN_WRITE_PHYS            2814
+#define MNG_FN_WRITE_SBIT            2815
+#define MNG_FN_WRITE_SPLT            2816
+#define MNG_FN_WRITE_HIST            2817
+#define MNG_FN_WRITE_TIME            2818
+#define MNG_FN_WRITE_MHDR            2819
+#define MNG_FN_WRITE_MEND            2820
+#define MNG_FN_WRITE_LOOP            2821
+#define MNG_FN_WRITE_ENDL            2822
+#define MNG_FN_WRITE_DEFI            2823
+#define MNG_FN_WRITE_BASI            2824
+#define MNG_FN_WRITE_CLON            2825
+#define MNG_FN_WRITE_PAST            2826
+#define MNG_FN_WRITE_DISC            2827
+#define MNG_FN_WRITE_BACK            2828
+#define MNG_FN_WRITE_FRAM            2829
+#define MNG_FN_WRITE_MOVE            2830
+#define MNG_FN_WRITE_CLIP            2831
+#define MNG_FN_WRITE_SHOW            2832
+#define MNG_FN_WRITE_TERM            2833
+#define MNG_FN_WRITE_SAVE            2834
+#define MNG_FN_WRITE_SEEK            2835
+#define MNG_FN_WRITE_EXPI            2836
+#define MNG_FN_WRITE_FPRI            2837
+#define MNG_FN_WRITE_NEED            2838
+#define MNG_FN_WRITE_PHYG            2839
+#define MNG_FN_WRITE_JHDR            2840
+#define MNG_FN_WRITE_JDAT            2841
+#define MNG_FN_WRITE_JSEP            2842
+#define MNG_FN_WRITE_DHDR            2843
+#define MNG_FN_WRITE_PROM            2844
+#define MNG_FN_WRITE_IPNG            2845
+#define MNG_FN_WRITE_PPLT            2846
+#define MNG_FN_WRITE_IJNG            2847
+#define MNG_FN_WRITE_DROP            2848
+#define MNG_FN_WRITE_DBYK            2849
+#define MNG_FN_WRITE_ORDR            2850
+#define MNG_FN_WRITE_UNKNOWN         2851
+#define MNG_FN_WRITE_MAGN            2852
+#define MNG_FN_WRITE_JDAA            2853
+#define MNG_FN_WRITE_EVNT            2854
+#define MNG_FN_WRITE_MPNG            2855
+
+/* ************************************************************************** */
+
+#define MNG_FN_ZLIB_INITIALIZE       3001
+#define MNG_FN_ZLIB_CLEANUP          3002
+#define MNG_FN_ZLIB_INFLATEINIT      3003
+#define MNG_FN_ZLIB_INFLATEROWS      3004
+#define MNG_FN_ZLIB_INFLATEDATA      3005
+#define MNG_FN_ZLIB_INFLATEFREE      3006
+#define MNG_FN_ZLIB_DEFLATEINIT      3007
+#define MNG_FN_ZLIB_DEFLATEROWS      3008
+#define MNG_FN_ZLIB_DEFLATEDATA      3009
+#define MNG_FN_ZLIB_DEFLATEFREE      3010
+
+/* ************************************************************************** */
+
+#define MNG_FN_PROCESS_DISPLAY_IHDR  3201
+#define MNG_FN_PROCESS_DISPLAY_PLTE  3202
+#define MNG_FN_PROCESS_DISPLAY_IDAT  3203
+#define MNG_FN_PROCESS_DISPLAY_IEND  3204
+#define MNG_FN_PROCESS_DISPLAY_TRNS  3205
+#define MNG_FN_PROCESS_DISPLAY_GAMA  3206
+#define MNG_FN_PROCESS_DISPLAY_CHRM  3207
+#define MNG_FN_PROCESS_DISPLAY_SRGB  3208
+#define MNG_FN_PROCESS_DISPLAY_ICCP  3209
+#define MNG_FN_PROCESS_DISPLAY_BKGD  3210
+#define MNG_FN_PROCESS_DISPLAY_PHYS  3211
+#define MNG_FN_PROCESS_DISPLAY_SBIT  3212
+#define MNG_FN_PROCESS_DISPLAY_SPLT  3213
+#define MNG_FN_PROCESS_DISPLAY_HIST  3214
+#define MNG_FN_PROCESS_DISPLAY_MHDR  3215
+#define MNG_FN_PROCESS_DISPLAY_MEND  3216
+#define MNG_FN_PROCESS_DISPLAY_LOOP  3217
+#define MNG_FN_PROCESS_DISPLAY_ENDL  3218
+#define MNG_FN_PROCESS_DISPLAY_DEFI  3219
+#define MNG_FN_PROCESS_DISPLAY_BASI  3220
+#define MNG_FN_PROCESS_DISPLAY_CLON  3221
+#define MNG_FN_PROCESS_DISPLAY_PAST  3222
+#define MNG_FN_PROCESS_DISPLAY_DISC  3223
+#define MNG_FN_PROCESS_DISPLAY_BACK  3224
+#define MNG_FN_PROCESS_DISPLAY_FRAM  3225
+#define MNG_FN_PROCESS_DISPLAY_MOVE  3226
+#define MNG_FN_PROCESS_DISPLAY_CLIP  3227
+#define MNG_FN_PROCESS_DISPLAY_SHOW  3228
+#define MNG_FN_PROCESS_DISPLAY_TERM  3229
+#define MNG_FN_PROCESS_DISPLAY_SAVE  3230
+#define MNG_FN_PROCESS_DISPLAY_SEEK  3231
+#define MNG_FN_PROCESS_DISPLAY_EXPI  3232
+#define MNG_FN_PROCESS_DISPLAY_FPRI  3233
+#define MNG_FN_PROCESS_DISPLAY_NEED  3234
+#define MNG_FN_PROCESS_DISPLAY_PHYG  3235
+#define MNG_FN_PROCESS_DISPLAY_JHDR  3236
+#define MNG_FN_PROCESS_DISPLAY_JDAT  3237
+#define MNG_FN_PROCESS_DISPLAY_JSEP  3238
+#define MNG_FN_PROCESS_DISPLAY_DHDR  3239
+#define MNG_FN_PROCESS_DISPLAY_PROM  3240
+#define MNG_FN_PROCESS_DISPLAY_IPNG  3241
+#define MNG_FN_PROCESS_DISPLAY_PPLT  3242
+#define MNG_FN_PROCESS_DISPLAY_IJNG  3243
+#define MNG_FN_PROCESS_DISPLAY_DROP  3244
+#define MNG_FN_PROCESS_DISPLAY_DBYK  3245
+#define MNG_FN_PROCESS_DISPLAY_ORDR  3246
+#define MNG_FN_PROCESS_DISPLAY_MAGN  3247
+#define MNG_FN_PROCESS_DISPLAY_JDAA  3248
+
+/* ************************************************************************** */
+
+#define MNG_FN_JPEG_INITIALIZE       3401
+#define MNG_FN_JPEG_CLEANUP          3402
+#define MNG_FN_JPEG_DECOMPRESSINIT   3403
+#define MNG_FN_JPEG_DECOMPRESSDATA   3404
+#define MNG_FN_JPEG_DECOMPRESSFREE   3405
+
+#define MNG_FN_STORE_JPEG_G8         3501
+#define MNG_FN_STORE_JPEG_RGB8       3502
+#define MNG_FN_STORE_JPEG_G12        3503
+#define MNG_FN_STORE_JPEG_RGB12      3504
+#define MNG_FN_STORE_JPEG_GA8        3505
+#define MNG_FN_STORE_JPEG_RGBA8      3506
+#define MNG_FN_STORE_JPEG_GA12       3507
+#define MNG_FN_STORE_JPEG_RGBA12     3508
+#define MNG_FN_STORE_JPEG_G8_ALPHA   3509
+#define MNG_FN_STORE_JPEG_RGB8_ALPHA 3510
+
+#define MNG_FN_INIT_JPEG_A1_NI       3511
+#define MNG_FN_INIT_JPEG_A2_NI       3512
+#define MNG_FN_INIT_JPEG_A4_NI       3513
+#define MNG_FN_INIT_JPEG_A8_NI       3514
+#define MNG_FN_INIT_JPEG_A16_NI      3515
+
+#define MNG_FN_STORE_JPEG_G8_A1      3521
+#define MNG_FN_STORE_JPEG_G8_A2      3522
+#define MNG_FN_STORE_JPEG_G8_A4      3523
+#define MNG_FN_STORE_JPEG_G8_A8      3524
+#define MNG_FN_STORE_JPEG_G8_A16     3525
+
+#define MNG_FN_STORE_JPEG_RGB8_A1    3531
+#define MNG_FN_STORE_JPEG_RGB8_A2    3532
+#define MNG_FN_STORE_JPEG_RGB8_A4    3533
+#define MNG_FN_STORE_JPEG_RGB8_A8    3534
+#define MNG_FN_STORE_JPEG_RGB8_A16   3535
+
+#define MNG_FN_STORE_JPEG_G12_A1     3541
+#define MNG_FN_STORE_JPEG_G12_A2     3542
+#define MNG_FN_STORE_JPEG_G12_A4     3543
+#define MNG_FN_STORE_JPEG_G12_A8     3544
+#define MNG_FN_STORE_JPEG_G12_A16    3545
+
+#define MNG_FN_STORE_JPEG_RGB12_A1   3551
+#define MNG_FN_STORE_JPEG_RGB12_A2   3552
+#define MNG_FN_STORE_JPEG_RGB12_A4   3553
+#define MNG_FN_STORE_JPEG_RGB12_A8   3554
+#define MNG_FN_STORE_JPEG_RGB12_A16  3555
+
+#define MNG_FN_NEXT_JPEG_ALPHAROW    3591
+#define MNG_FN_NEXT_JPEG_ROW         3592
+#define MNG_FN_DISPLAY_JPEG_ROWS     3593
+
+/* ************************************************************************** */
+
+#define MNG_FN_MAGNIFY_G8_X1         3701
+#define MNG_FN_MAGNIFY_G8_X2         3702
+#define MNG_FN_MAGNIFY_RGB8_X1       3703
+#define MNG_FN_MAGNIFY_RGB8_X2       3704
+#define MNG_FN_MAGNIFY_GA8_X1        3705
+#define MNG_FN_MAGNIFY_GA8_X2        3706
+#define MNG_FN_MAGNIFY_GA8_X3        3707
+#define MNG_FN_MAGNIFY_GA8_X4        3708
+#define MNG_FN_MAGNIFY_RGBA8_X1      3709
+#define MNG_FN_MAGNIFY_RGBA8_X2      3710
+#define MNG_FN_MAGNIFY_RGBA8_X3      3711
+#define MNG_FN_MAGNIFY_RGBA8_X4      3712
+#define MNG_FN_MAGNIFY_G8_X3         3713
+#define MNG_FN_MAGNIFY_RGB8_X3       3714
+#define MNG_FN_MAGNIFY_GA8_X5        3715
+#define MNG_FN_MAGNIFY_RGBA8_X5      3716
+
+#define MNG_FN_MAGNIFY_G16_X1        3725
+#define MNG_FN_MAGNIFY_G16_X2        3726
+#define MNG_FN_MAGNIFY_RGB16_X1      3727
+#define MNG_FN_MAGNIFY_RGB16_X2      3728
+#define MNG_FN_MAGNIFY_GA16_X1       3729
+#define MNG_FN_MAGNIFY_GA16_X2       3730
+#define MNG_FN_MAGNIFY_GA16_X3       3731
+#define MNG_FN_MAGNIFY_GA16_X4       3732
+#define MNG_FN_MAGNIFY_RGBA16_X1     3733
+#define MNG_FN_MAGNIFY_RGBA16_X2     3734
+#define MNG_FN_MAGNIFY_RGBA16_X3     3735
+#define MNG_FN_MAGNIFY_RGBA16_X4     3736
+#define MNG_FN_MAGNIFY_G16_X3        3737
+#define MNG_FN_MAGNIFY_RGB16_X3      3738
+#define MNG_FN_MAGNIFY_GA16_X5       3739
+#define MNG_FN_MAGNIFY_RGBA16_X5     3740
+
+#define MNG_FN_MAGNIFY_G8_Y1         3751
+#define MNG_FN_MAGNIFY_G8_Y2         3752
+#define MNG_FN_MAGNIFY_RGB8_Y1       3753
+#define MNG_FN_MAGNIFY_RGB8_Y2       3754
+#define MNG_FN_MAGNIFY_GA8_Y1        3755
+#define MNG_FN_MAGNIFY_GA8_Y2        3756
+#define MNG_FN_MAGNIFY_GA8_Y3        3757
+#define MNG_FN_MAGNIFY_GA8_Y4        3758
+#define MNG_FN_MAGNIFY_RGBA8_Y1      3759
+#define MNG_FN_MAGNIFY_RGBA8_Y2      3760
+#define MNG_FN_MAGNIFY_RGBA8_Y3      3761
+#define MNG_FN_MAGNIFY_RGBA8_Y4      3762
+#define MNG_FN_MAGNIFY_G8_Y3         3763
+#define MNG_FN_MAGNIFY_RGB8_Y3       3764
+#define MNG_FN_MAGNIFY_GA8_Y5        3765
+#define MNG_FN_MAGNIFY_RGBA8_Y5      3766
+
+#define MNG_FN_MAGNIFY_G16_Y1        3775
+#define MNG_FN_MAGNIFY_G16_Y2        3776
+#define MNG_FN_MAGNIFY_RGB16_Y1      3777
+#define MNG_FN_MAGNIFY_RGB16_Y2      3778
+#define MNG_FN_MAGNIFY_GA16_Y1       3779
+#define MNG_FN_MAGNIFY_GA16_Y2       3780
+#define MNG_FN_MAGNIFY_GA16_Y3       3781
+#define MNG_FN_MAGNIFY_GA16_Y4       3782
+#define MNG_FN_MAGNIFY_RGBA16_Y1     3783
+#define MNG_FN_MAGNIFY_RGBA16_Y2     3784
+#define MNG_FN_MAGNIFY_RGBA16_Y3     3785
+#define MNG_FN_MAGNIFY_RGBA16_Y4     3786
+#define MNG_FN_MAGNIFY_G16_Y3        3787
+#define MNG_FN_MAGNIFY_RGB16_Y3      3788
+#define MNG_FN_MAGNIFY_GA16_Y5       3789
+#define MNG_FN_MAGNIFY_RGBA16_Y5     3790
+
+/* ************************************************************************** */
+
+#define MNG_FN_DELTA_G1_G1           3801
+#define MNG_FN_DELTA_G2_G2           3802
+#define MNG_FN_DELTA_G4_G4           3803
+#define MNG_FN_DELTA_G8_G8           3804
+#define MNG_FN_DELTA_G16_G16         3805
+#define MNG_FN_DELTA_RGB8_RGB8       3806
+#define MNG_FN_DELTA_RGB16_RGB16     3807
+#define MNG_FN_DELTA_GA8_GA8         3808
+#define MNG_FN_DELTA_GA8_G8          3809
+#define MNG_FN_DELTA_GA8_A8          3810
+#define MNG_FN_DELTA_GA16_GA16       3811
+#define MNG_FN_DELTA_GA16_G16        3812
+#define MNG_FN_DELTA_GA16_A16        3813
+#define MNG_FN_DELTA_RGBA8_RGBA8     3814
+#define MNG_FN_DELTA_RGBA8_RGB8      3815
+#define MNG_FN_DELTA_RGBA8_A8        3816
+#define MNG_FN_DELTA_RGBA16_RGBA16   3817
+#define MNG_FN_DELTA_RGBA16_RGB16    3818
+#define MNG_FN_DELTA_RGBA16_A16      3819
+
+#define MNG_FN_PROMOTE_G8_G8         3901
+#define MNG_FN_PROMOTE_G8_G16        3902
+#define MNG_FN_PROMOTE_G16_G16       3903
+#define MNG_FN_PROMOTE_G8_GA8        3904
+#define MNG_FN_PROMOTE_G8_GA16       3905
+#define MNG_FN_PROMOTE_G16_GA16      3906
+#define MNG_FN_PROMOTE_G8_RGB8       3907
+#define MNG_FN_PROMOTE_G8_RGB16      3908
+#define MNG_FN_PROMOTE_G16_RGB16     3909
+#define MNG_FN_PROMOTE_G8_RGBA8      3910
+#define MNG_FN_PROMOTE_G8_RGBA16     3911
+#define MNG_FN_PROMOTE_G16_RGBA16    3912
+#define MNG_FN_PROMOTE_GA8_GA16      3913
+#define MNG_FN_PROMOTE_GA8_RGBA8     3914
+#define MNG_FN_PROMOTE_GA8_RGBA16    3915
+#define MNG_FN_PROMOTE_GA16_RGBA16   3916
+#define MNG_FN_PROMOTE_RGB8_RGB16    3917
+#define MNG_FN_PROMOTE_RGB8_RGBA8    3918
+#define MNG_FN_PROMOTE_RGB8_RGBA16   3919
+#define MNG_FN_PROMOTE_RGB16_RGBA16  3920
+#define MNG_FN_PROMOTE_RGBA8_RGBA16  3921
+#define MNG_FN_PROMOTE_IDX8_RGB8     3922
+#define MNG_FN_PROMOTE_IDX8_RGB16    3923
+#define MNG_FN_PROMOTE_IDX8_RGBA8    3924
+#define MNG_FN_PROMOTE_IDX8_RGBA16   3925
+
+#define MNG_FN_SCALE_G1_G2           4001
+#define MNG_FN_SCALE_G1_G4           4002
+#define MNG_FN_SCALE_G1_G8           4003
+#define MNG_FN_SCALE_G1_G16          4004
+#define MNG_FN_SCALE_G2_G4           4005
+#define MNG_FN_SCALE_G2_G8           4006
+#define MNG_FN_SCALE_G2_G16          4007
+#define MNG_FN_SCALE_G4_G8           4008
+#define MNG_FN_SCALE_G4_G16          4009
+#define MNG_FN_SCALE_G8_G16          4010
+#define MNG_FN_SCALE_GA8_GA16        4011
+#define MNG_FN_SCALE_RGB8_RGB16      4012
+#define MNG_FN_SCALE_RGBA8_RGBA16    4013
+
+#define MNG_FN_SCALE_G2_G1           4021
+#define MNG_FN_SCALE_G4_G1           4022
+#define MNG_FN_SCALE_G8_G1           4023
+#define MNG_FN_SCALE_G16_G1          4024
+#define MNG_FN_SCALE_G4_G2           4025
+#define MNG_FN_SCALE_G8_G2           4026
+#define MNG_FN_SCALE_G16_G2          4027
+#define MNG_FN_SCALE_G8_G4           4028
+#define MNG_FN_SCALE_G16_G4          4029
+#define MNG_FN_SCALE_G16_G8          4030
+#define MNG_FN_SCALE_GA16_GA8        4031
+#define MNG_FN_SCALE_RGB16_RGB8      4032
+#define MNG_FN_SCALE_RGBA16_RGBA8    4033
+
+#define MNG_FN_COMPOSEOVER_RGBA8     4501
+#define MNG_FN_COMPOSEOVER_RGBA16    4502
+#define MNG_FN_COMPOSEUNDER_RGBA8    4503
+#define MNG_FN_COMPOSEUNDER_RGBA16   4504
+
+#define MNG_FN_FLIP_RGBA8            4521
+#define MNG_FN_FLIP_RGBA16           4522
+#define MNG_FN_TILE_RGBA8            4523
+#define MNG_FN_TILE_RGBA16           4524
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Trace string-table entry                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef struct {
+                 mng_uint32 iFunction;
+                 mng_pchar  zTracetext;
+               } mng_trace_entry;
+typedef mng_trace_entry const * mng_trace_entryp;
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_TRACE_PROCS */
+
+/* ************************************************************************** */
+
+#endif /* _libmng_trace_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_types.h b/src/3rdparty/libmng/libmng_types.h
new file mode 100644
index 0000000..81fb29f
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_types.h
@@ -0,0 +1,574 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_types.h            copyright (c) 2000-2007 G.Juyn   * */
+/* * version   : 1.0.10                                                     * */
+/* *                                                                        * */
+/* * purpose   : type specifications                                        * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Specification of the types used by the library             * */
+/* *             Creates platform-independant structure                     * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/06/2000 - G.Juyn                                * */
+/* *             - added iteratechunk callback definition                   * */
+/* *             0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - improved definitions for DLL support                     * */
+/* *             - added 8-bit palette definition                           * */
+/* *             - added general array definitions                          * */
+/* *             - added MNG_NULL definition                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - changed most callback prototypes to allow the app        * */
+/* *               to report errors during callback processing              * */
+/* *             0.5.1 - 05/16/2000 - G.Juyn                                * */
+/* *             - moved standard header includes into this file            * */
+/* *               (stdlib/mem for mem-mngmt & math for fp gamma-calc)      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/18/2000 - G.Juyn                                * */
+/* *             - B003 - fixed problem with <mem.h> being proprietary      * */
+/* *               to Borland platform                                      * */
+/* *             - added helper definitions for JNG (IJG-based)             * */
+/* *             - fixed support for IJGSRC6B                               * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - added default IJG compression parameters and such        * */
+/* *             0.5.2 - 05/31/2000 - G.Juyn                                * */
+/* *             - fixed inclusion for memcpy (contributed by Tim Rowley)   * */
+/* *             - added mng_int32p (contributed by Tim Rowley)             * */
+/* *             0.5.2 - 06/02/2000 - G.Juyn                                * */
+/* *             - removed SWAP_ENDIAN reference (contributed by Tim Rowley)* */
+/* *             - added getalphaline callback for RGB8_A8 canvasstyle      * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/21/2000 - G.Juyn                                * */
+/* *             - added speedtype to facilitate testing                    * */
+/* *             0.5.3 - 06/27/2000 - G.Juyn                                * */
+/* *             - added typedef for mng_size_t                             * */
+/* *             - changed size parameter for memory callbacks to           * */
+/* *               mng_size_t                                               * */
+/* *             0.5.3 - 06/28/2000 - G.Juyn                                * */
+/* *             - changed definition of 32-bit ints (64-bit platforms)     * */
+/* *             - changed definition of mng_handle (64-bit platforms)      * */
+/* *             0.5.3 - 06/29/2000 - G.Juyn                                * */
+/* *             - changed definition of mng_handle (again)                 * */
+/* *             - swapped refresh parameters                               * */
+/* *             - added inclusion of stdlib.h for abs()                    * */
+/* *                                                                        * */
+/* *             0.9.0 - 06/30/2000 - G.Juyn                                * */
+/* *             - changed refresh parameters to 'x,y,width,height'         * */
+/* *             0.9.1 - 07/10/2000 - G.Juyn                                * */
+/* *             - added suspendbuffer constants                            * */
+/* *             0.9.1 - 07/15/2000 - G.Juyn                                * */
+/* *             - added callbacks for SAVE/SEEK processing                 * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/07/2000 - G.Juyn                                * */
+/* *             - B111300 - fixup for improved portability                 * */
+/* *             0.9.3 - 08/12/2000 - G.Juyn                                * */
+/* *             - added workaround for faulty PhotoShop iCCP chunk         * */
+/* *             0.9.3 - 09/11/2000 - G.Juyn                                * */
+/* *             - added export of zlib functions from windows dll          * */
+/* *             - fixed inclusion parameters once again to make those      * */
+/* *               external libs work together                              * */
+/* *             - re-fixed fixed inclusion parameters                      * */
+/* *               (these freeking libraries make me mad)                   * */
+/* *             0.9.3 - 10/11/2000 - G.Juyn                                * */
+/* *             - added support for nEED                                   * */
+/* *             0.9.3 - 10/17/2000 - G.Juyn                                * */
+/* *             - added callback to process non-critical unknown chunks    * */
+/* *                                                                        * */
+/* *             0.9.4 - 11/20/2000 - R.Giles                               * */
+/* *             - fixed inclusion of lcms header for non-windows platforms * */
+/* *             0.9.4 - 12/12/2000 - G.Juyn                                * */
+/* *             - changed callback convention for MSVC (Thanks Chad)       * */
+/* *             0.9.4 - 12/16/2000 - G.Juyn                                * */
+/* *             - fixed mixup of data- & function-pointers (thanks Dimitri)* */
+/* *                                                                        * */
+/* *             1.0.1 - 02/08/2001 - G.Juyn                                * */
+/* *             - added MEND processing callback                           * */
+/* *                                                                        * */
+/* *             1.0.2 - 06/23/2001 - G.Juyn                                * */
+/* *             - added processterm callback                               * */
+/* *                                                                        * */
+/* *             1.0.3 - 08/06/2001 - G.Juyn                                * */
+/* *             - changed inclusion of lcms.h for Linux platforms          * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* *             1.0.6 - 04/11/2003 - G.Juyn                                * */
+/* *             - B719420 - fixed several MNG_APP_CMS problems             * */
+/* *             1.0.6 - 06/15/2003 - R.Giles                               * */
+/* *             - lcms.h inclusion is generally no longer prefixed         * */
+/* *             1.0.6 - 07/07/2003 - G. R-P.                               * */
+/* *             - added png_imgtypes enumeration                           * */
+/* *                                                                        * */
+/* *             1.0.7 - 03/10/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *                                                                        * */
+/* *             1.0.8 - 04/11/2004 - G.Juyn                                * */
+/* *             - added data-push mechanisms for specialized decoders      * */
+/* *             1.0.8 - 08/01/2004 - G.Juyn                                * */
+/* *             - added support for 3+byte pixelsize for JPEG's            * */
+/* *                                                                        * */
+/* *             1.0.9 - 12/05/2004 - G.Juyn                                * */
+/* *             - inclusion of zlib/lcms/ijgsrc6b with <> instead of ""    * */
+/* *             1.0.9 - 12/06/2004 - G.Juyn                                * */
+/* *             - added conditional MNG_OPTIMIZE_CHUNKREADER               * */
+/* *                                                                        * */
+/* *             1.0.10 - 04/08/2007 - G.Juyn                               * */
+/* *             - added support for mPNG proposal                          * */
+/* *             1.0.10 - 04/12/2007 - G.Juyn                               * */
+/* *             - added support for ANG proposal                           * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifndef _libmng_types_h_
+#define _libmng_types_h_
+
+/* ************************************************************************** */
+
+#ifdef __BORLANDC__
+#pragma option -AT                     /* turn off strict ANSI-C for the moment */
+#endif
+
+#ifndef WIN32
+#if defined(_WIN32) || defined(__WIN32__) || defined(_Windows) || defined(_WINDOWS)
+#define WIN32                          /* gather them into a single define */
+#endif
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Here's where the external & standard libs are embedded                 * */
+/* *                                                                        * */
+/* * (it can be a bit of a pain in the lower-back to get them to work       * */
+/* *  together)                                                             * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#ifdef WIN32                           /* only include needed stuff */
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif
+#endif
+
+#ifdef MNG_USE_DLL
+#ifdef MNG_SKIP_ZLIB
+#undef MNG_INCLUDE_ZLIB
+#endif
+#ifdef MNG_SKIP_LCMS
+#undef MNG_INCLUDE_LCMS
+#endif
+#ifdef MNG_SKIP_IJG6B
+#undef MNG_INCLUDE_IJG6B
+#endif
+#endif
+
+#ifdef MNG_INCLUDE_ZLIB                /* zlib by Mark Adler & Jean-loup Gailly */
+#include <zlib.h>
+#endif
+
+#ifdef MNG_INCLUDE_LCMS                /* little cms by Marti Maria Saguer */
+#ifndef ZLIB_DLL
+#undef FAR
+#endif
+#include <lcms.h>
+#endif /* MNG_INCLUDE_LCMS */
+
+#ifdef MNG_INCLUDE_IJG6B               /* IJG's jpgsrc6b */
+#include <stdio.h>
+#ifdef MNG_USE_SETJMP
+#include <setjmp.h>                    /* needed for error-recovery (blergh) */
+#else
+#ifdef WIN32
+#define USE_WINDOWS_MESSAGEBOX         /* display a messagebox under Windoze */
+#endif
+#endif /* MNG_USE_SETJMP */
+#ifdef FAR
+#undef FAR                             /* possibly defined by zlib or lcms */
+#endif
+#define JPEG_INTERNAL_OPTIONS          /* for RGB_PIXELSIZE */
+#include <jpeglib.h>                   /* all that for JPEG support  :-) */
+#endif /* MNG_INCLUDE_IJG6B */
+
+#if defined(MNG_INTERNAL_MEMMNGMT) || defined(MNG_INCLUDE_FILTERS)
+#include <stdlib.h>                    /* "calloc" & "free" & "abs" */
+#endif
+
+#include <limits.h>                    /* get proper integer widths */
+
+#ifdef WIN32
+#if defined __BORLANDC__
+#include <mem.h>                       /* defines "memcpy" for BCB */
+#else
+#include <memory.h>                    /* defines "memcpy" for other win32 platforms */
+#endif
+#include <string.h>                    /* "strncmp" + "strcmp" */
+#else /* WIN32 */
+#ifdef BSD
+#include <strings.h>                   /* defines "memcpy", etc for BSD (?) */
+#else
+#include <string.h>                    /* defines "memcpy", etc for all others (???) */
+#endif
+#endif /* WIN32 */
+
+#if defined(MNG_FULL_CMS) || defined(MNG_GAMMA_ONLY) || defined(MNG_APP_CMS)
+#include <math.h>                      /* fp gamma-calculation */
+#endif
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Platform-dependant stuff                                               * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+/* TODO: this may require some elaboration for other platforms;
+   only works with BCB for now */
+
+#ifndef MNG_DLL
+#if defined(MNG_BUILD_DLL) || defined(MNG_USE_DLL)
+#define MNG_DLL
+#endif
+#endif
+
+#define MNG_LOCAL static
+
+#if defined(MNG_DLL) && defined(WIN32) /* setup DLL calling conventions */ 
+#define MNG_DECL __stdcall
+#if defined(MNG_BUILD_DLL)
+#define MNG_EXT __declspec(dllexport)
+#elif defined(MNG_USE_DLL)
+#define MNG_EXT __declspec(dllimport)
+#else
+#define MNG_EXT
+#endif
+#ifdef MNG_STRICT_ANSI
+#undef MNG_STRICT_ANSI                 /* can't do strict-ANSI with this DLL-stuff */
+#endif
+#else
+#define MNG_DECL                       /* dummies for non-DLL */
+#define MNG_EXT
+#endif /* MNG_DLL && WIN32 */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* now force ANSI-C from here on */
+#endif
+
+/* ************************************************************************** */
+
+#if USHRT_MAX == 0xffffffffU                     /* get the proper 32-bit width !!! */
+typedef unsigned short   mng_uint32;
+typedef signed   short   mng_int32;
+#elif UINT_MAX == 0xffffffffU
+typedef unsigned int     mng_uint32;
+typedef signed   int     mng_int32;
+#elif ULONG_MAX == 0xffffffffU
+typedef unsigned long    mng_uint32;
+typedef signed   long    mng_int32;
+#else
+#error "Sorry, I can't find any 32-bit integers on this platform."
+#endif
+
+typedef signed   short   mng_int16;              /* other basic integers */
+typedef unsigned short   mng_uint16;
+typedef signed   char    mng_int8;
+typedef unsigned char    mng_uint8;
+
+typedef double           mng_float;              /* basic float */
+
+typedef size_t           mng_size_t;             /* size field for memory allocation */
+
+typedef char *           mng_pchar;              /* string */
+typedef void *           mng_ptr;                /* generic pointer */
+typedef void             (*mng_fptr) (void);     /* generic function pointer */
+
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * Platform-independant from here                                         * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+typedef mng_uint32 *     mng_uint32p;            /* pointer to unsigned longs */
+typedef mng_int32 *      mng_int32p;             /* pointer to longs */
+typedef mng_uint16 *     mng_uint16p;            /* pointer to unsigned words */
+typedef mng_uint8 *      mng_uint8p;             /* pointer to unsigned bytes */
+
+typedef mng_int8         mng_bool;               /* booleans */
+
+struct mng_data_struct;
+typedef struct mng_data_struct * mng_handle;     /* generic handle */
+
+typedef mng_int32        mng_retcode;            /* generic return code */
+typedef mng_int32        mng_chunkid;            /* 4-byte chunkname identifier */
+typedef mng_ptr          mng_chunkp;             /* pointer to a chunk-structure */
+typedef mng_ptr          mng_objectp;            /* pointer to an object-structure */
+
+typedef mng_chunkid *    mng_chunkidp;           /* pointer to chunkid */
+
+typedef struct {                                 /* 8-bit palette element */
+          mng_uint8 iRed;
+          mng_uint8 iGreen;
+          mng_uint8 iBlue;
+        } mng_palette8e;
+typedef mng_palette8e   mng_palette8[256];       /* 8-bit palette */
+typedef mng_palette8e * mng_palette8ep;
+
+typedef mng_uint8       mng_uint8arr[256];       /* generic arrays */
+typedef mng_uint8       mng_uint8arr4[4];
+typedef mng_uint16      mng_uint16arr[256];
+typedef mng_uint32      mng_uint32arr2[2];
+
+/* ************************************************************************** */
+
+#define MNG_FALSE 0
+#define MNG_TRUE  1
+#define MNG_NULL  0
+
+#define MNG_SUSPENDBUFFERSIZE  32768
+#define MNG_SUSPENDREQUESTSIZE  1024
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+
+/* size of temporary zlib buffer for deflate processing */
+#define MNG_ZLIB_MAXBUF     8192
+
+/* default zlib compression parameters for deflateinit2 */
+#define MNG_ZLIB_LEVEL      9                    /* level */
+#define MNG_ZLIB_METHOD     Z_DEFLATED           /* method */
+#define MNG_ZLIB_WINDOWBITS 15                   /* window size */
+#define MNG_ZLIB_MEMLEVEL   9                    /* memory level */
+#define MNG_ZLIB_STRATEGY   Z_DEFAULT_STRATEGY   /* strategy */
+
+#define MNG_MAX_IDAT_SIZE   4096                 /* maximum size of IDAT data */
+
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_JNG
+
+#ifdef MNG_INCLUDE_IJG6B                         /* IJG helper defs */
+typedef struct jpeg_compress_struct   mngjpeg_comp;
+typedef struct jpeg_decompress_struct mngjpeg_decomp;
+typedef struct jpeg_error_mgr         mngjpeg_error;
+typedef struct jpeg_source_mgr        mngjpeg_source;
+
+typedef mngjpeg_comp   * mngjpeg_compp;
+typedef mngjpeg_decomp * mngjpeg_decompp;
+typedef mngjpeg_error  * mngjpeg_errorp;
+typedef mngjpeg_source * mngjpeg_sourcep;
+
+typedef J_DCT_METHOD     mngjpeg_dctmethod;
+
+/* default IJG parameters for compression */
+#define MNG_JPEG_DCT         JDCT_DEFAULT        /* DCT algorithm (JDCT_ISLOW) */
+#define MNG_JPEG_QUALITY     100                 /* quality 0..100; 100=best */
+#define MNG_JPEG_SMOOTHING   0                   /* default no smoothing */
+#define MNG_JPEG_PROGRESSIVE MNG_FALSE           /* default is just baseline */
+#define MNG_JPEG_OPTIMIZED   MNG_FALSE           /* default is not optimized */
+#endif /* MNG_INCLUDE_IJG6B */
+
+#define MNG_JPEG_MAXBUF      65500               /* max size of temp JPEG buffer */
+#define MNG_MAX_JDAT_SIZE    4096                /* maximum size of JDAT data */
+
+#endif /* MNG_INCLUDE_JNG */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_LCMS
+typedef cmsHPROFILE         mng_cmsprof;         /* little CMS helper defs */
+typedef cmsHTRANSFORM       mng_cmstrans;
+typedef cmsCIExyY           mng_CIExyY;
+typedef cmsCIExyYTRIPLE     mng_CIExyYTRIPLE;
+typedef LPGAMMATABLE        mng_gammatabp;
+#endif /* MNG_INCLUDE_LCMS */
+
+/* ************************************************************************** */
+
+                                       /* enumeration of known graphics types */
+enum mng_imgtypes {mng_it_unknown, mng_it_png, mng_it_mng, mng_it_jng
+#ifdef MNG_INCLUDE_MPNG_PROPOSAL
+     ,mng_it_mpng
+#endif     
+#ifdef MNG_INCLUDE_ANG_PROPOSAL
+     ,mng_it_ang
+#endif
+     };
+typedef enum mng_imgtypes mng_imgtype;
+
+                                       /* enumeration of animation speed-types */
+enum mng_speedtypes {mng_st_normal, mng_st_fast, mng_st_slow, mng_st_slowest};
+typedef enum mng_speedtypes mng_speedtype;
+
+#ifdef MNG_OPTIMIZE_CHUNKREADER
+                                       /* enumeration object-creation indicators */
+enum mng_createobjtypes {mng_create_none, mng_create_always, mng_create_ifglobal};
+typedef enum mng_createobjtypes mng_createobjtype;
+#endif
+
+/* ************************************************************************** */
+
+/* enumeration of PNG image types */
+#ifdef MNG_OPTIMIZE_FOOTPRINT_INIT
+enum png_imgtypes
+  {
+    png_g1,
+    png_g2,
+    png_g4,
+    png_g8,
+    png_rgb8,
+    png_idx1,
+    png_idx2,
+    png_idx4,
+    png_idx8,
+    png_ga8,
+    png_rgba8,
+#ifdef MNG_INCLUDE_JNG
+    png_jpeg_a1,
+    png_jpeg_a2,
+    png_jpeg_a4,
+    png_jpeg_a8,
+#endif
+#ifndef MNG_NO_16BIT_SUPPORT
+    png_g16,
+    png_ga16,
+    png_rgb16,
+    png_rgba16,
+#ifdef MNG_INCLUDE_JNG
+    png_jpeg_a16,
+#endif
+#endif
+    png_none
+  };
+    
+typedef enum png_imgtypes png_imgtype;
+#endif
+/* ************************************************************************** */
+
+                                       /* memory management callbacks */
+typedef mng_ptr    (MNG_DECL *mng_memalloc)      (mng_size_t  iLen);
+typedef void       (MNG_DECL *mng_memfree)       (mng_ptr     iPtr,
+                                                  mng_size_t  iLen);
+
+typedef void       (MNG_DECL *mng_releasedata)   (mng_ptr     pUserdata,
+                                                  mng_ptr     pData,
+                                                  mng_size_t  iLength);
+
+                                       /* I/O management callbacks */
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+typedef mng_bool   (MNG_DECL *mng_openstream)    (mng_handle  hHandle);
+typedef mng_bool   (MNG_DECL *mng_closestream)   (mng_handle  hHandle);
+#endif
+typedef mng_bool   (MNG_DECL *mng_readdata)      (mng_handle  hHandle,
+                                                  mng_ptr     pBuf,
+                                                  mng_uint32  iBuflen,
+                                                  mng_uint32p pRead);
+typedef mng_bool   (MNG_DECL *mng_writedata)     (mng_handle  hHandle,
+                                                  mng_ptr     pBuf,
+                                                  mng_uint32  iBuflen,
+                                                  mng_uint32p pWritten);
+
+                                       /* error & trace processing callbacks */
+typedef mng_bool   (MNG_DECL *mng_errorproc)     (mng_handle  hHandle,
+                                                  mng_int32   iErrorcode,
+                                                  mng_int8    iSeverity,
+                                                  mng_chunkid iChunkname,
+                                                  mng_uint32  iChunkseq,
+                                                  mng_int32   iExtra1,
+                                                  mng_int32   iExtra2,
+                                                  mng_pchar   zErrortext);
+typedef mng_bool   (MNG_DECL *mng_traceproc)     (mng_handle  hHandle,
+                                                  mng_int32   iFuncnr,
+                                                  mng_int32   iFuncseq,
+                                                  mng_pchar   zFuncname);
+
+                                       /* read processing callbacks */
+typedef mng_bool   (MNG_DECL *mng_processheader) (mng_handle  hHandle,
+                                                  mng_uint32  iWidth,
+                                                  mng_uint32  iHeight);
+typedef mng_bool   (MNG_DECL *mng_processtext)   (mng_handle  hHandle,
+                                                  mng_uint8   iType,
+                                                  mng_pchar   zKeyword,
+                                                  mng_pchar   zText,
+                                                  mng_pchar   zLanguage,
+                                                  mng_pchar   zTranslation);
+typedef mng_bool   (MNG_DECL *mng_processsave)   (mng_handle  hHandle);
+typedef mng_bool   (MNG_DECL *mng_processseek)   (mng_handle  hHandle,
+                                                  mng_pchar   zName);
+typedef mng_bool   (MNG_DECL *mng_processneed)   (mng_handle  hHandle,
+                                                  mng_pchar   zKeyword);
+typedef mng_bool   (MNG_DECL *mng_processmend)   (mng_handle  hHandle,
+                                                  mng_uint32  iIterationsdone,
+                                                  mng_uint32  iIterationsleft);
+typedef mng_bool   (MNG_DECL *mng_processunknown) (mng_handle  hHandle,
+                                                   mng_chunkid iChunkid,
+                                                   mng_uint32  iRawlen,
+                                                   mng_ptr     pRawdata);
+typedef mng_bool   (MNG_DECL *mng_processterm)   (mng_handle  hHandle,
+                                                  mng_uint8   iTermaction,
+                                                  mng_uint8   iIteraction,
+                                                  mng_uint32  iDelay,
+                                                  mng_uint32  iItermax);
+
+                                       /* display processing callbacks */
+typedef mng_ptr    (MNG_DECL *mng_getcanvasline) (mng_handle  hHandle,
+                                                  mng_uint32  iLinenr);
+typedef mng_ptr    (MNG_DECL *mng_getbkgdline)   (mng_handle  hHandle,
+                                                  mng_uint32  iLinenr);
+typedef mng_ptr    (MNG_DECL *mng_getalphaline)  (mng_handle  hHandle,
+                                                  mng_uint32  iLinenr);
+typedef mng_bool   (MNG_DECL *mng_refresh)       (mng_handle  hHandle,
+                                                  mng_uint32  iX,
+                                                  mng_uint32  iY,
+                                                  mng_uint32  iWidth,
+                                                  mng_uint32  iHeight);
+
+                                       /* timer management callbacks */
+typedef mng_uint32 (MNG_DECL *mng_gettickcount)  (mng_handle  hHandle);
+typedef mng_bool   (MNG_DECL *mng_settimer)      (mng_handle  hHandle,
+                                                  mng_uint32  iMsecs);
+
+                                       /* color management callbacks */
+typedef mng_bool   (MNG_DECL *mng_processgamma)  (mng_handle  hHandle,
+                                                  mng_uint32  iGamma);
+typedef mng_bool   (MNG_DECL *mng_processchroma) (mng_handle  hHandle,
+                                                  mng_uint32  iWhitepointx,
+                                                  mng_uint32  iWhitepointy,
+                                                  mng_uint32  iRedx,
+                                                  mng_uint32  iRedy,
+                                                  mng_uint32  iGreenx,
+                                                  mng_uint32  iGreeny,
+                                                  mng_uint32  iBluex,
+                                                  mng_uint32  iBluey);
+typedef mng_bool   (MNG_DECL *mng_processsrgb)   (mng_handle  hHandle,
+                                                  mng_uint8   iRenderingintent);
+typedef mng_bool   (MNG_DECL *mng_processiccp)   (mng_handle  hHandle,
+                                                  mng_uint32  iProfilesize,
+                                                  mng_ptr     pProfile);
+typedef mng_bool   (MNG_DECL *mng_processarow)   (mng_handle  hHandle,
+                                                  mng_uint32  iRowsamples,
+                                                  mng_bool    bIsRGBA16,
+                                                  mng_ptr     pRow);
+
+                                       /* chunk access callback(s) */
+typedef mng_bool   (MNG_DECL *mng_iteratechunk)  (mng_handle  hHandle,
+                                                  mng_handle  hChunk,
+                                                  mng_chunkid iChunkid,
+                                                  mng_uint32  iChunkseq);
+
+/* ************************************************************************** */
+
+#endif /* _libmng_types_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_write.c b/src/3rdparty/libmng/libmng_write.c
new file mode 100644
index 0000000..79ff544
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_write.c
@@ -0,0 +1,198 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_write.c            copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : Write management (implementation)                          * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the write management routines            * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *             0.5.1 - 05/16/2000 - G.Juyn                                * */
+/* *             - moved the actual write_graphic functionality from        * */
+/* *               mng_hlapi to its appropriate function here               * */
+/* *                                                                        * */
+/* *             0.9.1 - 07/19/2000 - G.Juyn                                * */
+/* *             - fixed writing of signature                               * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* *             1.0.8 - 07/06/2004 - G.R-P                                 * */
+/* *             - added conditionals around openstream/closestream         * */
+/* *             - defend against using undefined Open/Closestream function * */
+/* *             1.0.8 - 08/02/2004 - G.Juyn                                * */
+/* *             - added conditional to allow easier writing of large MNG's * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/25/2004 - G.Juyn                                * */
+/* *             - replaced MNG_TWEAK_LARGE_FILES with permanent solution   * */
+/* *             1.0.9 - 12/20/2004 - G.Juyn                                * */
+/* *             - cleaned up macro-invocations (thanks to D. Airlie)       * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_chunks.h"
+#include "libmng_chunk_io.h"
+#include "libmng_write.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#if defined(MNG_SUPPORT_READ) || defined(MNG_SUPPORT_WRITE)
+mng_retcode mng_drop_chunks (mng_datap pData)
+{
+  mng_chunkp       pChunk;
+  mng_chunkp       pNext;
+  mng_cleanupchunk fCleanup;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_CHUNKS, MNG_LC_START);
+#endif
+
+  pChunk = pData->pFirstchunk;         /* and get first stored chunk (if any) */
+
+  while (pChunk)                       /* more chunks to discard ? */
+  {
+    pNext = ((mng_chunk_headerp)pChunk)->pNext;
+                                       /* call appropriate cleanup */
+    fCleanup = ((mng_chunk_headerp)pChunk)->fCleanup;
+    fCleanup (pData, pChunk);
+
+    pChunk = pNext;                    /* neeeext */
+  }
+
+  pData->pFirstchunk = MNG_NULL;
+  pData->pLastchunk  = MNG_NULL;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_DROP_CHUNKS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_READ || MNG_SUPPORT_WRITE */
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_WRITE_PROCS
+
+/* ************************************************************************** */
+
+mng_retcode mng_write_graphic (mng_datap pData)
+{
+  mng_chunkp  pChunk;
+  mng_retcode iRetcode;
+  mng_uint32  iWritten;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_GRAPHIC, MNG_LC_START);
+#endif
+
+  pChunk = pData->pFirstchunk;         /* we'll start with the first, thank you */
+
+  if (pChunk)                          /* is there anything to write ? */
+  {                                    /* open the file */
+    if (!pData->bWriting)
+    {
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+      if (pData->fOpenstream && !pData->fOpenstream ((mng_handle)pData))
+        MNG_ERROR (pData, MNG_APPIOERROR);
+#endif
+      {
+        pData->bWriting      = MNG_TRUE; /* indicate writing */
+        pData->iWritebufsize = 32768;    /* get a temporary write buffer */
+                                       /* reserve 12 bytes for length, chunkname & crc */
+        MNG_ALLOC (pData, pData->pWritebuf, pData->iWritebufsize+12);
+
+                                       /* write the signature */
+        if (((mng_chunk_headerp)pChunk)->iChunkname == MNG_UINT_IHDR)
+          mng_put_uint32 (pData->pWritebuf, PNG_SIG);
+        else
+        if (((mng_chunk_headerp)pChunk)->iChunkname == MNG_UINT_JHDR)
+          mng_put_uint32 (pData->pWritebuf, JNG_SIG);
+        else
+          mng_put_uint32 (pData->pWritebuf, MNG_SIG);
+
+        mng_put_uint32 (pData->pWritebuf+4, POST_SIG);
+
+        if (!pData->fWritedata ((mng_handle)pData, pData->pWritebuf, 8, &iWritten))
+        {
+          MNG_FREE (pData, pData->pWritebuf, pData->iWritebufsize+12);
+          MNG_ERROR (pData, MNG_APPIOERROR);
+        }
+
+        if (iWritten != 8)             /* disk full ? */
+        {
+          MNG_FREE (pData, pData->pWritebuf, pData->iWritebufsize+12);
+          MNG_ERROR (pData, MNG_OUTPUTERROR);
+        }
+      }
+    }
+
+    while (pChunk)                     /* so long as there's something to write */
+    {                                  /* let's call its output routine */
+      iRetcode = ((mng_chunk_headerp)pChunk)->fWrite (pData, pChunk);
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+                                       /* neeeext */
+      pChunk = ((mng_chunk_headerp)pChunk)->pNext;
+    }
+
+    if (!pData->bCreating)
+    {                                  /* free the temporary buffer */
+      MNG_FREE (pData, pData->pWritebuf, pData->iWritebufsize+12);
+
+      pData->bWriting = MNG_FALSE;     /* done writing */
+                                       /* close the stream now */
+#ifndef MNG_NO_OPEN_CLOSE_STREAM
+      if (pData->fClosestream && !pData->fClosestream ((mng_handle)pData))
+        MNG_ERROR (pData, MNG_APPIOERROR);
+#endif
+
+    } else {
+                                       /* cleanup the written chunks */
+      iRetcode = mng_drop_chunks (pData);
+      if (iRetcode)                    /* on error bail out */
+        return iRetcode;
+    }
+  }
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_WRITE_GRAPHIC, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_WRITE_PROCS */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
+
diff --git a/src/3rdparty/libmng/libmng_write.h b/src/3rdparty/libmng/libmng_write.h
new file mode 100644
index 0000000..df058fb
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_write.h
@@ -0,0 +1,49 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_write.h            copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : Write management (definition)                              * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the write management routines                * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *                                                                        * */
+/* *             1.0.9 - 09/25/2004 - G.Juyn                                * */
+/* *             - replaced MNG_TWEAK_LARGE_FILES with permanent solution   * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_write_h_
+#define _libmng_write_h_
+
+/* ************************************************************************** */
+
+mng_retcode mng_drop_chunks   (mng_datap pData);
+
+mng_retcode mng_write_graphic (mng_datap pData);
+
+/* ************************************************************************** */
+
+#endif /* _libmng_write_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/libmng_zlib.c b/src/3rdparty/libmng/libmng_zlib.c
new file mode 100644
index 0000000..7d102e1
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_zlib.c
@@ -0,0 +1,607 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_zlib.c             copyright (c) 2000-2004 G.Juyn   * */
+/* * version   : 1.0.9                                                      * */
+/* *                                                                        * */
+/* * purpose   : ZLIB library interface (implementation)                    * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : implementation of the ZLIB library interface               * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *             0.5.1 - 05/11/2000 - G.Juyn                                * */
+/* *             - filled the deflatedata routine                           * */
+/* *             0.5.1 - 05/12/2000 - G.Juyn                                * */
+/* *             - changed trace to macro for callback error-reporting      * */
+/* *                                                                        * */
+/* *             0.5.2 - 05/20/2000 - G.Juyn                                * */
+/* *             - fixed for JNG alpha handling                             * */
+/* *             0.5.2 - 05/24/2000 - G.Juyn                                * */
+/* *             - moved init of default zlib parms from here to            * */
+/* *               "mng_hlapi.c"                                            * */
+/* *                                                                        * */
+/* *             0.5.3 - 06/16/2000 - G.Juyn                                * */
+/* *             - changed progressive-display processing                   * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* *             0.9.3 - 08/08/2000 - G.Juyn                                * */
+/* *             - fixed compiler-warnings from Mozilla                     * */
+/* *             0.9.3 - 09/07/2000 - G.Juyn                                * */
+/* *             - added support for new filter_types                       * */
+/* *                                                                        * */
+/* *             1.0.5 - 08/07/2002 - G.Juyn                                * */
+/* *             - added test-option for PNG filter method 193 (=no filter) * */
+/* *             1.0.5 - 08/19/2002 - G.Juyn                                * */
+/* *             - B597134 - libmng pollutes the linker namespace           * */
+/* *             1.0.5 - 09/19/2002 - G.Juyn                                * */
+/* *             - added warning for too much IDAT data                     * */
+/* *                                                                        * */
+/* *             1.0.6 - 07/07/2003 - G.R-P                                 * */
+/* *             - added MNG_NO_16BIT_SUPPORT support                       * */
+/* *                                                                        * */
+/* *             1.0.9 - 10/09/2004 - G.R-P                                 * */
+/* *             - added MNG_NO_1_2_4BIT_SUPPORT support                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#include "libmng.h"
+#include "libmng_data.h"
+#include "libmng_error.h"
+#include "libmng_trace.h"
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+#include "libmng_memory.h"
+#include "libmng_pixels.h"
+#include "libmng_filter.h"
+#include "libmng_zlib.h"
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+/* ************************************************************************** */
+
+#ifdef MNG_INCLUDE_ZLIB
+
+/* ************************************************************************** */
+
+voidpf mngzlib_alloc (voidpf pData,
+                      uInt   iCount,
+                      uInt   iSize)
+{
+  voidpf pPtr;                         /* temporary space */
+
+#ifdef MNG_INTERNAL_MEMMNGMT
+  pPtr = calloc (iCount, iSize);       /* local allocation */
+#else
+  if (((mng_datap)pData)->fMemalloc)   /* callback function set ? */
+    pPtr = ((mng_datap)pData)->fMemalloc (iCount * iSize);
+  else
+    pPtr = Z_NULL;                     /* can't allocate! */
+#endif
+
+  return pPtr;                         /* return the result */
+}
+
+/* ************************************************************************** */
+
+void mngzlib_free (voidpf pData,
+                   voidpf pAddress)
+{
+#ifdef MNG_INTERNAL_MEMMNGMT
+  free (pAddress);                     /* free locally */
+#else
+  if (((mng_datap)pData)->fMemfree)    /* callback set? */
+    ((mng_datap)pData)->fMemfree (pAddress, 1);
+#endif
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_initialize (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INITIALIZE, MNG_LC_START);
+#endif
+
+#ifdef MNG_INTERNAL_MEMMNGMT
+  pData->sZlib.zalloc = Z_NULL;        /* let zlib figure out memory management */
+  pData->sZlib.zfree  = Z_NULL;
+  pData->sZlib.opaque = Z_NULL;
+#else                                  /* use user-provided callbacks */
+  pData->sZlib.zalloc = mngzlib_alloc;
+  pData->sZlib.zfree  = mngzlib_free;
+  pData->sZlib.opaque = (voidpf)pData;
+#endif
+
+  pData->bInflating   = MNG_FALSE;     /* not performing any action yet */
+  pData->bDeflating   = MNG_FALSE;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INITIALIZE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_cleanup (mng_datap pData)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_CLEANUP, MNG_LC_START);
+#endif
+
+  if (pData->bInflating)               /* force zlib cleanup */
+    mngzlib_inflatefree (pData);
+  if (pData->bDeflating)
+    mngzlib_deflatefree (pData);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_CLEANUP, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_inflateinit (mng_datap pData)
+{
+  int iZrslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEINIT, MNG_LC_START);
+#endif
+                                       /* initialize zlib structures and such */
+  iZrslt = inflateInit (&pData->sZlib);
+
+  if (iZrslt != Z_OK)                  /* on error bail out */
+    MNG_ERRORZ (pData, (mng_uint32)iZrslt);
+
+  pData->bInflating      = MNG_TRUE;   /* really inflating something now */
+  pData->sZlib.next_out  = 0;          /* force JIT initialization */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEINIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+#ifdef MNG_SUPPORT_DISPLAY
+mng_retcode mngzlib_inflaterows (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata)
+{
+  int         iZrslt;
+  mng_retcode iRslt;
+  mng_ptr     pSwap;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEROWS, MNG_LC_START);
+#endif
+
+  pData->sZlib.next_in   = pIndata;    /* let zlib know where to get stuff */
+  pData->sZlib.avail_in  = (uInt)iInlen;
+
+  if (pData->sZlib.next_out == 0)      /* initialize output variables ? */
+  {                                    /* let zlib know where to store stuff */
+    pData->sZlib.next_out  = pData->pWorkrow;
+    pData->sZlib.avail_out = (uInt)(pData->iRowsize + pData->iPixelofs);
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+    if (pData->iPNGdepth < 8)
+       pData->sZlib.avail_out = (uInt)((pData->iPNGdepth*pData->iRowsize + 7)/8
+           + pData->iPixelofs);
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+    if (pData->iPNGdepth > 8)
+       pData->sZlib.avail_out = (uInt)(2*pData->iRowsize + pData->iPixelofs);
+#endif
+  }
+
+  do
+  {                                    /* now inflate a row */
+    iZrslt = inflate (&pData->sZlib, Z_SYNC_FLUSH);
+                                       /* produced a full row ? */
+    if (((iZrslt == Z_OK) || (iZrslt == Z_STREAM_END)) &&
+        (pData->sZlib.avail_out == 0))
+    {                                  /* image not completed yet ? */
+      if (pData->iRow < (mng_int32)pData->iDataheight)
+      {
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+        if (pData->iPNGdepth == 1)
+        {
+          /* Inflate Workrow to 8-bit */
+          mng_int32  iX;
+          mng_uint8p pSrc = pData->pWorkrow+1;
+          mng_uint8p pDest = pSrc + pData->iRowsize - (pData->iRowsize+7)/8;
+
+          for (iX = ((pData->iRowsize+7)/8) ; iX > 0 ; iX--)
+             *pDest++ = *pSrc++;
+
+          pDest = pData->pWorkrow+1;
+          pSrc = pDest + pData->iRowsize - (pData->iRowsize+7)/8;
+          for (iX = pData->iRowsize; ;)
+          {
+            *pDest++ = (((*pSrc)>>7)&1);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>6)&1);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>5)&1);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>4)&1);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>3)&1);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>2)&1);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>1)&1);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)   )&1);
+            if (iX-- <= 0)
+              break;
+            pSrc++;
+          }
+        }
+        else if (pData->iPNGdepth == 2)
+        {
+          /* Inflate Workrow to 8-bit */
+          mng_int32  iX;
+          mng_uint8p pSrc = pData->pWorkrow+1;
+          mng_uint8p pDest = pSrc + pData->iRowsize - (2*pData->iRowsize+7)/8;
+
+          for (iX = ((2*pData->iRowsize+7)/8) ; iX > 0 ; iX--)
+             *pDest++ = *pSrc++;
+
+          pDest = pData->pWorkrow+1;
+          pSrc = pDest + pData->iRowsize - (2*pData->iRowsize+7)/8;
+          for (iX = pData->iRowsize; ;)
+          {
+            *pDest++ = (((*pSrc)>>6)&3);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>4)&3);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)>>2)&3);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)   )&3);
+            if (iX-- <= 0)
+              break;
+            pSrc++;
+          }
+        }
+        else if (pData->iPNGdepth == 4)
+        {
+          /* Inflate Workrow to 8-bit */
+          mng_int32  iX;
+          mng_uint8p pSrc = pData->pWorkrow+1;
+          mng_uint8p pDest = pSrc + pData->iRowsize - (4*pData->iRowsize+7)/8;
+
+          for (iX = ((4*pData->iRowsize+7)/8) ; iX > 0 ; iX--)
+             *pDest++ = *pSrc++;
+
+          pDest = pData->pWorkrow+1;
+          pSrc = pDest + pData->iRowsize - (4*pData->iRowsize+7)/8;
+          for (iX = pData->iRowsize; ;)
+          {
+            *pDest++ = (((*pSrc)>>4)&0x0f);
+            if (iX-- <= 0)
+              break;
+            *pDest++ = (((*pSrc)   )&0x0f);
+            if (iX-- <= 0)
+              break;
+            pSrc++;
+          }
+        }
+        if (pData->iPNGdepth < 8 && pData->iColortype == 0)
+        {
+          /* Expand samples to 8-bit by LBR */
+          mng_int32  iX;
+          mng_uint8p pSrc = pData->pWorkrow+1;
+          mng_uint8 multiplier[]={0,255,85,0,17,0,0,0,1};
+
+          for (iX = pData->iRowsize; iX > 0; iX--)
+              *pSrc++ *= multiplier[pData->iPNGdepth];
+        }
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+        if (pData->iPNGdepth > 8)
+        {
+          /* Reduce Workrow to 8-bit */
+          mng_int32  iX;
+          mng_uint8p pSrc = pData->pWorkrow+1;
+          mng_uint8p pDest = pSrc;
+
+          for (iX = pData->iRowsize; iX > 0; iX--)
+          {
+            *pDest = *pSrc;
+            pDest++;
+            pSrc+=2;
+          }
+        }
+#endif
+
+#ifdef FILTER192                       /* has leveling info ? */
+        if (pData->iFilterofs == MNG_FILTER_DIFFERING)
+          iRslt = init_rowdiffering (pData);
+        else
+#endif
+          iRslt = MNG_NOERROR;
+                                       /* filter the row if necessary */
+        if ((!iRslt) && (pData->iFilterofs < pData->iPixelofs  ) &&
+                        (*(pData->pWorkrow + pData->iFilterofs))    )
+          iRslt = mng_filter_a_row (pData);
+        else
+          iRslt = MNG_NOERROR;
+                                       /* additional leveling/differing ? */
+        if ((!iRslt) && (pData->fDifferrow))
+        {
+          iRslt = ((mng_differrow)pData->fDifferrow) (pData);
+
+          pSwap           = pData->pWorkrow;
+          pData->pWorkrow = pData->pPrevrow;
+          pData->pPrevrow = pSwap;     /* make sure we're processing the right data */
+        }
+
+        if (!iRslt)
+        {
+#ifdef MNG_INCLUDE_JNG
+          if (pData->bHasJHDR)         /* is JNG alpha-channel ? */
+          {                            /* just store in object ? */
+            if ((!iRslt) && (pData->fStorerow))
+              iRslt = ((mng_storerow)pData->fStorerow)     (pData);
+          }
+          else
+#endif /* MNG_INCLUDE_JNG */
+          {                            /* process this row */
+            if ((!iRslt) && (pData->fProcessrow))
+              iRslt = ((mng_processrow)pData->fProcessrow) (pData);
+                                       /* store in object ? */
+            if ((!iRslt) && (pData->fStorerow))
+              iRslt = ((mng_storerow)pData->fStorerow)     (pData);
+                                       /* color correction ? */
+            if ((!iRslt) && (pData->fCorrectrow))
+              iRslt = ((mng_correctrow)pData->fCorrectrow) (pData);
+                                       /* slap onto canvas ? */
+            if ((!iRslt) && (pData->fDisplayrow))
+            {
+              iRslt = ((mng_displayrow)pData->fDisplayrow) (pData);
+
+              if (!iRslt)              /* check progressive display refresh */
+                iRslt = mng_display_progressive_check (pData);
+
+            }
+          }
+        }
+
+        if (iRslt)                     /* on error bail out */
+          MNG_ERROR (pData, iRslt);
+
+        if (!pData->fDifferrow)        /* swap row-pointers */
+        {
+          pSwap           = pData->pWorkrow;
+          pData->pWorkrow = pData->pPrevrow;
+          pData->pPrevrow = pSwap;     /* so prev points to the processed row! */
+        }
+
+        iRslt = mng_next_row (pData);  /* adjust variables for next row */
+
+        if (iRslt)                     /* on error bail out */
+          MNG_ERROR (pData, iRslt);
+      }
+                                       /* let zlib know where to store next output */
+      pData->sZlib.next_out  = pData->pWorkrow;
+      pData->sZlib.avail_out = (uInt)(pData->iRowsize + pData->iPixelofs);
+#ifdef MNG_NO_1_2_4BIT_SUPPORT
+    if (pData->iPNGdepth < 8)
+       pData->sZlib.avail_out = (uInt)((pData->iPNGdepth*pData->iRowsize + 7)/8
+           + pData->iPixelofs);
+#endif
+#ifdef MNG_NO_16BIT_SUPPORT
+      if (pData->iPNGdepth > 8)
+        pData->sZlib.avail_out = (uInt)(2*pData->iRowsize + pData->iPixelofs);
+#endif
+    }
+  }                                    /* until some error or EOI
+                                          or all pixels received */
+  while ( (iZrslt == Z_OK) && (pData->sZlib.avail_in > 0)      &&
+          ( (pData->iRow < (mng_int32)pData->iDataheight) ||
+            ( (pData->iPass >= 0) && (pData->iPass < 7) )    )    );
+                                       /* on error bail out */
+  if ((iZrslt != Z_OK) && (iZrslt != Z_STREAM_END))
+    MNG_ERRORZ (pData, (mng_uint32)iZrslt);
+                                       /* too much data ? */
+  if ((iZrslt == Z_OK) && (pData->sZlib.avail_in > 0))
+    MNG_WARNING (pData, MNG_TOOMUCHIDAT);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEROWS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+#endif /* MNG_SUPPORT_DISPLAY */
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_inflatedata (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata)
+{
+  int iZrslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEDATA, MNG_LC_START);
+#endif
+                                       /* let zlib know where to get stuff */
+  pData->sZlib.next_in   = pIndata;
+  pData->sZlib.avail_in  = (uInt)iInlen;
+                                       /* now inflate the data in one go! */
+  iZrslt = inflate (&pData->sZlib, Z_FINISH);
+                                       /* not enough room in output-buffer ? */
+  if ((iZrslt == Z_BUF_ERROR) || (pData->sZlib.avail_in > 0))
+    return MNG_BUFOVERFLOW;
+                                       /* on error bail out */
+  if ((iZrslt != Z_OK) && (iZrslt != Z_STREAM_END))
+    MNG_ERRORZ (pData, (mng_uint32)iZrslt);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_inflatefree (mng_datap pData)
+{
+  int iZrslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEFREE, MNG_LC_START);
+#endif
+
+  pData->bInflating = MNG_FALSE;       /* stopped it */
+
+  iZrslt = inflateEnd (&pData->sZlib); /* let zlib cleanup its own stuff */
+
+  if (iZrslt != Z_OK)                  /* on error bail out */
+    MNG_ERRORZ (pData, (mng_uint32)iZrslt);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_INFLATEFREE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_deflateinit (mng_datap pData)
+{
+  int iZrslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEINIT, MNG_LC_START);
+#endif
+                                       /* initialize zlib structures and such */
+  iZrslt = deflateInit2 (&pData->sZlib, pData->iZlevel, pData->iZmethod,
+                         pData->iZwindowbits, pData->iZmemlevel,
+                         pData->iZstrategy);
+
+  if (iZrslt != Z_OK)                  /* on error bail out */
+    MNG_ERRORZ (pData, (mng_uint32)iZrslt);
+
+  pData->bDeflating = MNG_TRUE;        /* really deflating something now */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEINIT, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_deflaterows (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata)
+{
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEROWS, MNG_LC_START);
+#endif
+
+
+
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEROWS, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_deflatedata (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata)
+{
+  int iZrslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEDATA, MNG_LC_START);
+#endif
+
+  pData->sZlib.next_in  = pIndata;     /* let zlib know where to get stuff */
+  pData->sZlib.avail_in = (uInt)iInlen;
+                                       /* now deflate the data in one go! */
+  iZrslt = deflate (&pData->sZlib, Z_FINISH);
+                                       /* not enough room in output-buffer ? */
+  if ((iZrslt == Z_BUF_ERROR) || (pData->sZlib.avail_in > 0))
+    return MNG_BUFOVERFLOW;
+                                       /* on error bail out */
+  if ((iZrslt != Z_OK) && (iZrslt != Z_STREAM_END))
+    MNG_ERRORZ (pData, (mng_uint32)iZrslt);
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEDATA, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;
+}
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_deflatefree (mng_datap pData)
+{
+  int iZrslt;
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEFREE, MNG_LC_START);
+#endif
+
+  iZrslt = deflateEnd (&pData->sZlib); /* let zlib cleanup its own stuff */
+
+  if (iZrslt != Z_OK)                  /* on error bail out */
+    MNG_ERRORZ (pData, (mng_uint32)iZrslt);
+
+  pData->bDeflating = MNG_FALSE;       /* stopped it */
+
+#ifdef MNG_SUPPORT_TRACE
+  MNG_TRACE (pData, MNG_FN_ZLIB_DEFLATEFREE, MNG_LC_END);
+#endif
+
+  return MNG_NOERROR;                  /* done */
+}
+
+/* ************************************************************************** */
+
+#endif /* MNG_INCLUDE_ZLIB */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
+
diff --git a/src/3rdparty/libmng/libmng_zlib.h b/src/3rdparty/libmng/libmng_zlib.h
new file mode 100644
index 0000000..cfc3918
--- /dev/null
+++ b/src/3rdparty/libmng/libmng_zlib.h
@@ -0,0 +1,60 @@
+/* ************************************************************************** */
+/* *             For conditions of distribution and use,                    * */
+/* *                see copyright notice in libmng.h                        * */
+/* ************************************************************************** */
+/* *                                                                        * */
+/* * project   : libmng                                                     * */
+/* * file      : libmng_zlib.h             copyright (c) 2000-2002 G.Juyn   * */
+/* * version   : 1.0.0                                                      * */
+/* *                                                                        * */
+/* * purpose   : ZLIB package interface (definition)                        * */
+/* *                                                                        * */
+/* * author    : G.Juyn                                                     * */
+/* *                                                                        * */
+/* * comment   : Definition of the ZLIB package interface                   * */
+/* *                                                                        * */
+/* * changes   : 0.5.1 - 05/08/2000 - G.Juyn                                * */
+/* *             - changed strict-ANSI stuff                                * */
+/* *                                                                        * */
+/* *             0.9.2 - 08/05/2000 - G.Juyn                                * */
+/* *             - changed file-prefixes                                    * */
+/* *                                                                        * */
+/* ************************************************************************** */
+
+#if defined(__BORLANDC__) && defined(MNG_STRICT_ANSI)
+#pragma option -A                      /* force ANSI-C */
+#endif
+
+#ifndef _libmng_zlib_h_
+#define _libmng_zlib_h_
+
+/* ************************************************************************** */
+
+mng_retcode mngzlib_initialize  (mng_datap pData);
+mng_retcode mngzlib_cleanup     (mng_datap pData);
+
+mng_retcode mngzlib_inflateinit (mng_datap pData);
+mng_retcode mngzlib_inflaterows (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata);
+mng_retcode mngzlib_inflatedata (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata);
+mng_retcode mngzlib_inflatefree (mng_datap pData);
+
+mng_retcode mngzlib_deflateinit (mng_datap pData);
+mng_retcode mngzlib_deflaterows (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata);
+mng_retcode mngzlib_deflatedata (mng_datap  pData,
+                                 mng_uint32 iInlen,
+                                 mng_uint8p pIndata);
+mng_retcode mngzlib_deflatefree (mng_datap pData);
+
+/* ************************************************************************** */
+
+#endif /* _libmng_zlib_h_ */
+
+/* ************************************************************************** */
+/* * end of file                                                            * */
+/* ************************************************************************** */
diff --git a/src/3rdparty/libmng/makefiles/Makefile.am b/src/3rdparty/libmng/makefiles/Makefile.am
new file mode 100644
index 0000000..b53523e
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/Makefile.am
@@ -0,0 +1,29 @@
+## Process this file with automake to produce Makefile.in
+
+AUTOMAKE_OPTIONS = 1.3 foreign no-dependencies
+
+# include the app subdirectories in the distribution
+EXTRA_DIST = makefiles doc contrib
+
+
+# libmng release @VERSION@
+libmng_la_LDFLAGS = -version-info 1:0:0
+
+lib_LTLIBRARIES = libmng.la
+
+include_HEADERS = libmng.h libmng_conf.h libmng_types.h
+noinst_HEADERS = libmng_chunk_io.h libmng_chunk_prc.h libmng_chunks.h \
+	libmng_cms.h libmng_data.h libmng_display.h libmng_dither.h \
+	libmng_error.h libmng_filter.h libmng_jpeg.h libmng_memory.h \
+	libmng_object_prc.h libmng_objects.h libmng_pixels.h \
+	libmng_read.h libmng_trace.h libmng_write.h libmng_zlib.h
+
+libmng_la_SOURCES = libmng_callback_xs.c libmng_chunk_io.c \
+	libmng_chunk_prc.c libmng_chunk_xs.c libmng_cms.c \
+	libmng_display.c libmng_dither.c libmng_error.c \
+	libmng_filter.c libmng_hlapi.c libmng_jpeg.c \
+	libmng_object_prc.c libmng_pixels.c libmng_prop_xs.c \
+	libmng_read.c libmng_trace.c libmng_write.c libmng_zlib.c 
+
+man_MANS = doc/man/libmng.3 doc/man/jng.5 doc/man/mng.5
+
diff --git a/src/3rdparty/libmng/makefiles/README b/src/3rdparty/libmng/makefiles/README
new file mode 100644
index 0000000..63faaaf
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/README
@@ -0,0 +1,27 @@
+For conditions of distribution and use, see copyright notice in libmng.h
+or the file LICENSE in the top-level directory of the source distribution.
+
+This directory hosts the makefiles for a number of supported platforms.
+
+If you're using a system with POSIX shell capabilities, you can use the
+'configure' script in the top-level directory, or generate it by running
+'autogen.sh' if you have the necessary tools installed.
+
+Otherwise, copy the module for your environment (or the closest thing)
+into the libmng source-directory and change it to your needs. If you
+create a new file for a platform not on the list send it to me (gerard @
+libmng.com) and I'll be happy to include it in the next release!
+
+
+Current files:
+
+makefile.bcb3 - Borland C++ Builder
+makefile.vcwin32 - Microsoft Visual C++
+makefile.unix - generic Unix
+makefile.linux - Linux ELF (builds shared library)
+makefile.dj - DJGPP
+makefile.mingw - builds a static library for mingw32
+makefile.mingwdll - builds a dynamic library for mingw32
+makefile.irix - builds a static library for SGI/IRIX (6.5.21)
+
+Makefile.am, configure.in and acinclude.m4 (if present) - automake/autoconf source
diff --git a/src/3rdparty/libmng/makefiles/configure.in b/src/3rdparty/libmng/makefiles/configure.in
new file mode 100644
index 0000000..e7cb75c
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/configure.in
@@ -0,0 +1,193 @@
+dnl Process this file with autoconf to produce a configure script.
+
+AC_INIT
+AC_CONFIG_SRCDIR([libmng.h])
+AC_PREREQ(2.52)
+
+dnl this call will define PACKAGE and VERSION
+dnl please use this as the primary reference for the version number
+AM_INIT_AUTOMAKE(libmng, 1.0.9)
+
+dnl pass the version string on the the makefiles
+AC_SUBST(PACKAGE)
+AC_SUBST(VERSION)
+
+dnl Checks for programs.
+AC_PROG_CC
+AC_ISC_POSIX
+AM_C_PROTOTYPES
+if test "x$U" != "x"; then
+  AC_MSG_ERROR(Compiler not ANSI compliant)
+fi
+AM_PROG_LIBTOOL
+AC_PROG_INSTALL
+
+dnl support for files >2GB
+AC_SYS_LARGEFILE
+
+dnl Check for required header files
+AC_HEADER_STDC
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+
+dnl need pow and fabs
+AC_CHECK_FUNC(pow, , AC_CHECK_LIB(m, pow, LIBS="$LIBS -lm"))
+
+
+dnl what functionality we want to add (read, write, display).
+dnl all on by default. see libmng_conf.h for full descriptions
+
+dnl not building a standard shared object?
+AC_ARG_ENABLE(buildso,
+[  --disable-buildso       disable building standard shared object])
+if test "x$enable_buildso" != "xno"; then
+  AC_DEFINE(MNG_BUILD_SO)
+fi
+
+dnl we only support the full mng spec for now (no LC or VLC)
+AC_DEFINE(MNG_SUPPORT_FULL)
+
+dnl remove support in library to read images?
+AC_ARG_ENABLE(read,
+[  --disable-read          remove read support from library])
+if test "x$enable_read" != "xno"; then
+  AC_DEFINE(MNG_SUPPORT_READ)
+fi
+
+dnl remove support in library to write images?
+AC_ARG_ENABLE(write,
+[  --disable-write         remove write support from library])
+if test "x$enable_write" != "xno"; then
+  AC_DEFINE(MNG_SUPPORT_WRITE)
+fi
+
+dnl remove support in library to display images?
+AC_ARG_ENABLE(display,
+[  --disable-display       remove display support from library])
+if test "x$enable_display" != "xno"; then
+  AC_DEFINE(MNG_SUPPORT_DISPLAY)
+fi
+
+dnl remove support for 'dynamic' MNG?
+AC_ARG_ENABLE(dynamic,
+[  --disable-dynamic       remove dynamic MNG support from library])
+if test "x$enable_dynamic" != "xno"; then
+  AC_DEFINE(MNG_SUPPORT_DYNAMICMNG)
+fi
+
+dnl remove support in library to access chunks?
+AC_ARG_ENABLE(chunks,
+[  --disable-chunks        remove support for chunk access])
+if test "x$enable_chunks" != "xno"; then
+  AC_DEFINE(MNG_ACCESS_CHUNKS)
+fi
+
+dnl disable support for accessing chunks that have been previously read?
+AC_ARG_ENABLE(storechunks,
+[  --disable-storechunks   remove support for access of previous chunks])
+if test "x$enable_storechunks" != "xno"; then
+  AC_DEFINE(MNG_STORE_CHUNKS)
+fi
+
+dnl enable support for debug tracing callbacks and messages?
+AC_ARG_ENABLE(trace,
+[  --enable-trace          include support for debug tracing callbacks],[
+if test "x$enable_trace" = "xyes"; then
+  AC_DEFINE(MNG_SUPPORT_TRACE)
+  AC_DEFINE(MNG_TRACE_TELLTALE)
+fi
+])
+
+dnl verbose error text
+dnl this should always be on
+AC_DEFINE(MNG_ERROR_TELLTALE)
+
+
+dnl libz is required.
+AC_ARG_WITH(zlib,
+[  --with-zlib[=DIR]       use zlib include/library files in DIR],[
+  if test -d "$withval"; then
+    CPPFLAGS="$CPPFLAGS -I$withval/include"
+    LDFLAGS="$LDFLAGS -L$withval/lib"
+  fi
+])
+AC_CHECK_HEADER(zlib.h,
+    AC_CHECK_LIB(z, gzread, , AC_MSG_ERROR(zlib library not found)),
+    AC_MSG_ERROR(zlib header not found)
+)
+
+dnl check for jpeg library
+AC_ARG_WITH(jpeg,
+[  --with-jpeg[=DIR]       use jpeg include/library files in DIR],
+[with_jpeg=$withval],[with_jpeg=_auto])
+
+  if test "x$with_jpeg" != "xno" -a "x$with_jpeg" != "xyes" -a \
+	"x$with_jpeg" != "x_auto"; then
+    # Save in case test with directory specified fails
+    _cppflags=${CPPFLAGS}
+    _ldflags=${LDFLAGS}
+    _restore=1
+
+    CPPFLAGS="${CPPFLAGS} -I$withval/include"
+    LDFLAGS="${LDFLAGS} -L$withval/lib"
+  else
+    _restore=0
+  fi
+
+  if test "x$with_jpeg" != "xno"; then
+    AC_CHECK_HEADER(jpeglib.h,
+      AC_CHECK_LIB(jpeg, jpeg_read_header, [
+	LIBS="$LIBS -ljpeg"
+	AC_DEFINE(HAVE_LIBJPEG)
+	_restore=0
+      ],
+    	AC_MSG_WARN(jpeg library not found)),
+      AC_MSG_WARN(jpeg header not found)
+    )
+  fi
+
+  test $_restore -eq 1 && CPPFLAGS=$_cppflags LDFLAGS=$_ldflags
+
+dnl check for lcms library
+AC_ARG_WITH(lcms,
+[  --with-lcms[=DIR]       use lcms include/library files in DIR],
+[with_lcms=$withval],[with_lcms=_auto])
+
+  if test "x$with_lcms" != "xno" -a "x$with_lcms" != "xyes" -a \
+	"x$with_lcms" != "x_auto"; then
+    # Save in case test with directory specified fails
+    _cppflags=$CPPFLAGS
+    _ldflags=$LDFLAGS
+    _restore=1
+
+    CPPFLAGS="$CPPFLAGS -I$withval/include"
+    LDFLAGS="$LDFLAGS -L$withval/lib"
+  else
+    _restore=0
+  fi
+
+  if test "x$with_lcms" != "xno"; then
+    AC_CHECK_HEADER(lcms.h, [
+      have_lcms=yes
+      AC_CHECK_LIB(lcms, cmsCreateRGBProfile, [
+        LIBS="$LIBS -llcms"
+        AC_DEFINE(HAVE_LIBLCMS)
+        dnl for now this implies MNG_INCLUDE_LCMS in the headers:
+        AC_DEFINE(MNG_FULL_CMS)
+	_restore=0
+	have_lcms=yes
+      ],[
+	have_lcms=no
+      ])
+    ])
+    dnl give feedback only if the user asked specifically for lcms
+    if test "x$with_lcms" != "x_auto" -a "x$have_lcms" != "xyes"; then
+      AC_MSG_WARN([lcms not found... disabling CMS support])
+    fi
+  fi
+
+  test $_restore -eq 1 && CPPFLAGS=$_cppflags LDFLAGS=$_ldflags
+
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
diff --git a/src/3rdparty/libmng/makefiles/makefile.bcb3 b/src/3rdparty/libmng/makefiles/makefile.bcb3
new file mode 100644
index 0000000..3ddcb2d
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.bcb3
@@ -0,0 +1,108 @@
+#
+# For conditions of distribution and use, see copyright notice in libmng.h
+#
+# makefile for libmng - THE MNG library
+# this makefile is suitable for Borland C++ Builder.
+# it works (at least) with Borland C++ Builder v3
+
+# Configuration options are now in mng_conf.h
+# this option forces dll compatibility
+MNGOPT = -DMNG_BUILD_DLL
+
+# The name of your C compiler:
+CC= bcc32
+
+# compiler options:
+CFLAGS= -WD -O2 -Hc -w-par -k -y -v -vi -c -tWD \
+	-wuse -wucp -wstv -wstu -wsig -wpin -wnod -wnak -wdef -wcln -wbbf -wasm -wamp \
+	-wamb -Tkh30000 -ff -5 -I.;..\zlib;..\jpgsrc6b;..\lcms\include $(MNGOPT)
+
+# source files
+SOURCES= libmng_hlapi.c libmng_callback_xs.c libmng_prop_xs.c libmng_chunk_xs.c \
+	libmng_chunk_descr.c libmng_read.c libmng_write.c libmng_display.c \
+	libmng_object_prc.c libmng_chunk_prc.c libmng_chunk_io.c libmng_error.c \
+    libmng_trace.c libmng_pixels.c libmng_filter.c libmng_dither.c \
+    libmng_zlib.c libmng_jpeg.c libmng_cms.c
+
+# object files
+OBJECTS= libmng_hlapi.obj libmng_callback_xs.obj libmng_prop_xs.obj libmng_chunk_xs.obj \
+	libmng_chunk_descr.obj libmng_read.obj libmng_write.obj libmng_display.obj \
+	libmng_object_prc.obj libmng_chunk_prc.obj libmng_chunk_io.obj libmng_error.obj \
+    libmng_trace.obj libmng_pixels.obj libmng_filter.obj libmng_dither.obj \
+    libmng_zlib.obj libmng_jpeg.obj libmng_cms.obj
+
+# type dependancies
+.c.obj:
+	$(CC) $(CFLAGS) -c{ $<}
+
+# make options
+all: libmng.lib
+
+clean:
+	- del *.obj
+	- del libmng.lib
+
+# file dependancies
+libmng.lib: $(OBJECTS)
+	- del libmng.lib
+	tlib libmng.lib /E /C @&&|
++libmng_hlapi.obj +libmng_callback_xs.obj +libmng_prop_xs.obj +libmng_chunk_xs.obj &
++libmng_read.obj +libmng_write.obj +libmng_display.obj &
++libmng_object_prc.obj +libmng_chunk_prc.obj +libmng_chunk_io.obj +libmng_error.obj &
++libmng_trace.obj +libmng_pixels.obj +libmng_filter.obj +libmng_dither.obj &
++libmng_zlib.obj +libmng_jpeg.obj +libmng_cms.obj
+|
+
+libmng_hlapi.obj: libmng_hlapi.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_memory.h libmng_error.h libmng_trace.h libmng_read.h \
+        libmng_write.h libmng_display.h libmng_zlib.h libmng_cms.h libmng_zlib.h
+libmng_callback_xs.obj: libmng_callback_xs.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_prop_xs.obj: libmng_prop_xs.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_cms.h
+libmng_chunk_xs.obj: libmng_chunk_xs.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_error.h libmng_trace.h
+libmng_read.obj: libmng_read.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_chunk_prc.h libmng_chunk_io.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_read.h libmng_display.h
+libmng_write.obj: libmng_write.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_write.h
+libmng_display.obj: libmng_display.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+	libmng_error.h libmng_trace.h libmng_zlib.h libmng_cms.h \
+        libmng_pixels.h libmng_display.h
+libmng_object_prc.obj: libmng_object_prc.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_display.h libmng_pixels.h
+libmng_chunk_descr.obj: libmng_chunk_descr.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h
+libmng_chunk_prc.obj: libmng_chunk_prc.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h
+libmng_chunk_io.obj: libmng_chunk_io.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h libmng_chunks.h \
+        libmng_chunk_io.h libmng_chunk_prc libmng_memory.h libmng_error.h \
+        libmng_trace.h libmng_display.h libmng_zlib.h libmng_pixels.h
+libmng_error.obj: libmng_error.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_trace.obj: libmng_trace.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_pixels.obj: libmng_pixels.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_memory.h libmng_error.h libmng_trace.h \
+        libmng_cms.h libmng_filter.h libmng_pixels.h
+libmng_filter.obj: libmng_filter.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_filter.h
+libmng_dither.obj: libmng_dither.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_dither.h
+libmng_zlib.obj: libmng_zlib.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h \
+        libmng_filter.h libmng_zlib.h
+libmng_jpeg.obj: libmng_jpeg.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h \
+        libmng_pixels.h libmng_jpeg.h
+libmng_cms.obj: libmng_cms.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_error.h libmng_trace.h libmng_cms.h
+
diff --git a/src/3rdparty/libmng/makefiles/makefile.dj b/src/3rdparty/libmng/makefiles/makefile.dj
new file mode 100644
index 0000000..2cef088
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.dj
@@ -0,0 +1,155 @@
+#
+# For conditions of distribution and use, see copyright notice in libmng.h
+#
+# makefile for libmng - THE MNG library
+# This makefile have been tested on DJGPP v2
+# (Based on makefile.linux since both are GNU compilers)
+#
+# By Silvio Fonseca - gissi@sti.com.br
+
+#compiler
+CC=gcc
+
+#default build options
+OPTIONS=
+
+#DJGPP directory
+prefix=C:/DJGPP
+installprefix=C:\DJGPP
+
+#ZLIB Library and includes
+ZLIBLIB=$(prefix)/lib
+#ZLIBLIB=../zlib
+ZLIBINC=$(prefix)/include
+#ZLIBINC=../zlib
+
+#Jpeg library and includes
+JPEGLIB=$(prefix)/lib
+#JPEGLIB=../jpgsrc
+JPEGINC=$(prefix)/include
+#JPEGINC=../jpgsrc
+
+#Lcms library and includes
+LCMSLIB=$(prefix)/lib
+#LCMSLIB=../lcms
+LCMSINC=$(prefix)/include
+#LCMSINC=../lcms
+
+ALIGN=
+# for i386:
+#ALIGN=-malign-loops=2 -malign-functions=2
+
+WARNMORE=-Wwrite-strings -Wpointer-arith -Wshadow \
+	-Wmissing-declarations -Wtraditional -Wcast-align \
+	-Wstrict-prototypes -Wmissing-prototypes #-Wconversion
+
+CFLAGS=-I$(ZLIBINC) -I$(JPEGINC) -I$(LCMSINC) -Wall -O3 -funroll-loops \
+	$(OPTIONS) $(ALIGN) # $(WARNMORE) -g
+LDFLAGS=-L. -Wl,-rpath,. \
+	-L$(ZLIBLIB) -Wl,-rpath,$(ZLIBLIB) \
+	-L$(JPEGLIB) -Wl,-rpath,$(JPEGLIB) \
+	-L$(LCMSLIB) -Wl,-rpath,$(LCMSLIB) \
+	-lmng -lz -ljpeg -llcms -lm
+INCPATH=$(prefix)/include
+LIBPATH=$(prefix)/lib
+
+OBJS = \
+	libmng_callback_xs.o \
+	libmng_chunk_io.o \
+	libmng_chunk_descr.o \
+	libmng_chunk_prc.o \
+	libmng_chunk_xs.o \
+	libmng_cms.o \
+	libmng_display.o \
+	libmng_dither.o \
+	libmng_error.o \
+	libmng_filter.o \
+	libmng_hlapi.o \
+	libmng_jpeg.o \
+	libmng_object_prc.o \
+	libmng_pixels.o \
+	libmng_prop_xs.o \
+	libmng_read.o \
+	libmng_trace.o \
+	libmng_write.o \
+	libmng_zlib.o
+
+OBJSDLL = $(OBJS:.0=.pic.o)
+
+.SUFFIXES:      .c .o .pic.o
+
+.c.pic.o:
+	$(CC) -c $(CFLAGS) -fPIC -o $@ $*.c
+
+all: libmng.a
+
+libmng.a: $(OBJS)
+	ar rc $@ $(OBJS)
+	ranlib $@
+
+install: libmng.a
+	-@md $(installprefix)\include $(installprefix)\lib
+	copy libmng.h $(installprefix)\include
+	copy libmng_conf.h $(installprefix)\include
+	copy libmng_types.h $(installprefix)\include
+	copy libmng.a $(installprefix)\lib
+
+clean:
+	del *.o
+	del libmng.a
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+libmng_hlapi.o libmng_hlapi.pic.o: libmng_hlapi.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_memory.h libmng_error.h libmng_trace.h libmng_read.h \
+        libmng_write.h libmng_display.h libmng_zlib.h libmng_cms.h libmng_zlib.h
+libmng_callback_xs.o libmng_callback_xs.pic.o: libmng_callback_xs.c libmng.h \
+        libmng_conf.h libmng_types.h libmng_data.h libmng_error.h libmng_trace.h
+libmng_prop_xs.o libmng_prop_xs.pic.o: libmng_prop_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_error.h libmng_trace.h libmng_cms.h
+libmng_chunk_xs.o libmng_chunk_xs.pic.o: libmng_chunk_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h \
+        libmng_error.h libmng_trace.h
+libmng_read.o libmng_read.pic.o: libmng_read.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_chunk_prc.h libmng_chunk_io.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_read.h libmng_display.h
+libmng_write.o libmng_write.pic.o: libmng_write.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_write.h
+libmng_display.o libmng_display.pic.o: libmng_display.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+	libmng_error.h libmng_trace.h libmng_zlib.h libmng_cms.h libmng_pixels.h \
+        libmng_display.h
+libmng_object_prc.o libmng_object_prc.pic.o: libmng_object_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_display.h libmng_pixels.h
+libmng_chunk_descr.o libmng_chunk_descr.pic.o: libmng_chunk_descr.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_descr.h \
+        libmng_chunk_prc.h libmng_memory.h libmng_error.h libmng_trace.h
+libmng_chunk_prc.o libmng_chunk_prc.pic.o: libmng_chunk_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h
+libmng_chunk_io.o libmng_chunk_io.pic.o: libmng_chunk_io.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h \
+        libmng_chunks.h libmng_chunk_io.h libmng_chunk_prc.h libmng_memory.h libmng_error.h \
+        libmng_trace.h libmng_display.h libmng_zlib.h libmng_pixels.h
+libmng_error.o libmng_error.pic.o: libmng_error.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_trace.o libmng_trace.pic.o: libmng_trace.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_pixels.o libmng_pixels.pic.o: libmng_pixels.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_memory.h libmng_error.h libmng_trace.h \
+        libmng_cms.h libmng_filter.h libmng_pixels.h
+libmng_filter.o libmng_filter.pic.o: libmng_filter.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_filter.h
+libmng_dither.o libmng_dither.pic.o: libmng_dither.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_dither.h
+libmng_zlib.o libmng_zlib.pic.o: libmng_zlib.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h \
+        libmng_filter.h libmng_zlib.h
+libmng_jpeg.o libmng_jpeg.pic.o: libmng_jpeg.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h libmng_jpeg.h
+libmng_cms.o libmng_cms.pic.o: libmng_cms.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_error.h libmng_trace.h libmng_cms.h
+
diff --git a/src/3rdparty/libmng/makefiles/makefile.linux b/src/3rdparty/libmng/makefiles/makefile.linux
new file mode 100644
index 0000000..e06a829
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.linux
@@ -0,0 +1,180 @@
+#
+# For conditions of distribution and use, see copyright notice in libmng.h
+#
+# makefile for libmng - THE MNG library
+# this makefile is suitable for Linux ELF with gcc
+#
+# (this file is heavily copied from makefile.linux in the libpng package)
+
+# compiler
+CC=gcc
+
+# default build options (this forces shared library compatibility!!)
+#OPTIONS = -DMNG_BUILD_SO
+OPTIONS = -DMNG_BUILD_SO -DMNG_FULL_CMS
+
+# where "make install" puts libmng.a,libmng.so*,libmng.h,libmng_conf.h,libmng_types.h
+prefix=/usr/local
+
+# Where the zlib library and include files are located
+#ZLIBLIB=../zlib
+#ZLIBINC=../zlib
+ZLIBLIB=/usr/local/lib
+ZLIBINC=/usr/local/include
+
+# Where the jpeg library and include files are located
+#JPEGLIB=../jpgsrc
+#JPEGINC=../jpgsrc
+JPEGLIB=/usr/local/lib
+JPEGINC=/usr/local/include
+
+# Where the lcms library and include files are located
+#LCMSLIB=../lcms/lib
+#LCMSINC=../lcms/source
+LCMSLIB=/usr/local/lib
+LCMSINC=/usr/local/include
+
+ALIGN=
+# for i386:
+#ALIGN=-malign-loops=2 -malign-functions=2
+
+WARNMORE=-Wwrite-strings -Wpointer-arith -Wshadow \
+	-Wmissing-declarations -Wtraditional -Wcast-align \
+	-Wstrict-prototypes -Wmissing-prototypes #-Wconversion
+
+# for pgcc version 2.95.1, -O3 is buggy; don't use it.
+
+CFLAGS=-I$(ZLIBINC) -I$(JPEGINC) -I$(LCMSINC) -Wall -O3 -funroll-loops \
+	$(OPTIONS) $(ALIGN) # $(WARNMORE) -g
+LDFLAGS=-L. -Wl,-rpath,. \
+	-L$(ZLIBLIB) -Wl,-rpath,$(ZLIBLIB) \
+	-L$(JPEGLIB) -Wl,-rpath,$(JPEGLIB) \
+	-L$(LCMSLIB) -Wl,-rpath,$(LCMSLIB) \
+	-lmng -lz -ljpeg -llcms -lm
+
+RANLIB=ranlib
+#RANLIB=echo
+
+# current version numbers
+MNGMAJ = 1
+MNGMIN = 1.0.9
+MNGVER = $(MNGMAJ).$(MNGMIN)
+
+INCPATH=$(prefix)/include
+LIBPATH=$(prefix)/lib
+
+OBJS = \
+	libmng_callback_xs.o \
+	libmng_chunk_io.o \
+	libmng_chunk_descr.o \
+	libmng_chunk_prc.o \
+	libmng_chunk_xs.o \
+	libmng_cms.o \
+	libmng_display.o \
+	libmng_dither.o \
+	libmng_error.o \
+	libmng_filter.o \
+	libmng_hlapi.o \
+	libmng_jpeg.o \
+	libmng_object_prc.o \
+	libmng_pixels.o \
+	libmng_prop_xs.o \
+	libmng_read.o \
+	libmng_trace.o \
+	libmng_write.o \
+	libmng_zlib.o
+
+OBJSDLL = $(OBJS:.0=.pic.o)
+
+.SUFFIXES:      .c .o .pic.o
+
+.c.pic.o:
+	$(CC) -c $(CFLAGS) -fPIC -o $@ $*.c
+
+all: libmng.a libmng.so
+
+libmng.a: $(OBJS)
+	ar rc $@ $(OBJS)
+	$(RANLIB) $@
+
+libmng.so: libmng.so.$(MNGMAJ)
+	ln -sf libmng.so.$(MNGMAJ) libmng.so
+
+libmng.so.$(MNGMAJ): libmng.so.$(MNGVER)
+	ln -sf libmng.so.$(MNGVER) libmng.so.$(MNGMAJ)
+
+libmng.so.$(MNGVER): $(OBJSDLL)
+#	$(CC) -shared -Wl,-soname,libmng.so.$(MNGMAJ) -o libmng.so.$(MNGVER) \
+#	$(OBJSDLL) -L$(ZLIBLIB) -L$(JPEGLIB) -L$(LCMSLIB) -lz -lm -lc
+	$(CC) -shared -Wl,-soname,libmng.so.$(MNGMAJ) -o libmng.so.$(MNGVER) \
+	$(OBJSDLL) -L$(ZLIBLIB) -L$(JPEGLIB) -ljpeg -L$(LCMSLIB) -llcms \
+    -lz -lm -lc
+
+install: libmng.a libmng.so.$(MNGVER)
+	-@mkdir $(INCPATH) $(LIBPATH)
+	cp libmng.h libmng_conf.h libmng_types.h $(INCPATH)
+	chmod 644 $(INCPATH)/libmng.h $(INCPATH)/libmng_conf.h $(INCPATH)/libmng_types.h
+	cp libmng.a libmng.so.$(MNGVER) $(LIBPATH)
+	chmod 755 $(LIBPATH)/libmng.so.$(MNGVER)
+	-@/bin/rm -f $(LIBPATH)/libmng.so.$(MNGMAJ) $(LIBPATH)/libmng.so
+	(cd $(LIBPATH); ln -sf libmng.so.$(MNGVER) libmng.so.$(MNGMAJ); \
+	 ln -sf libmng.so.$(MNGMAJ) libmng.so)
+
+clean:
+	/bin/rm -f *.o libmng.a libmng.so*
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+libmng_hlapi.o libmng_hlapi.pic.o: libmng_hlapi.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_memory.h libmng_error.h libmng_trace.h libmng_read.h \
+        libmng_write.h libmng_display.h libmng_zlib.h libmng_cms.h libmng_zlib.h
+libmng_callback_xs.o libmng_callback_xs.pic.o: libmng_callback_xs.c libmng.h \
+        libmng_conf.h libmng_types.h libmng_data.h libmng_error.h libmng_trace.h
+libmng_prop_xs.o libmng_prop_xs.pic.o: libmng_prop_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_error.h libmng_trace.h libmng_cms.h
+libmng_chunk_xs.o libmng_chunk_xs.pic.o: libmng_chunk_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h \
+        libmng_error.h libmng_trace.h
+libmng_read.o libmng_read.pic.o: libmng_read.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_chunk_prc.h libmng_chunk_io.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_read.h libmng_display.h
+libmng_write.o libmng_write.pic.o: libmng_write.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_write.h
+libmng_display.o libmng_display.pic.o: libmng_display.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+	libmng_error.h libmng_trace.h libmng_zlib.h libmng_cms.h libmng_pixels.h \
+        libmng_display.h
+libmng_object_prc.o libmng_object_prc.pic.o: libmng_object_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_display.h libmng_pixels.h
+libmng_chunk_descr.o libmng_chunk_descr.pic.o: libmng_chunk_descr.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_descr.h libmng_memory.h \
+        libmng_chunk_prc.h libmng_error.h libmng_trace.h
+libmng_chunk_prc.o libmng_chunk_prc.pic.o: libmng_chunk_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h
+libmng_chunk_io.o libmng_chunk_io.pic.o: libmng_chunk_io.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h \
+        libmng_chunks.h libmng_chunk_io.h libmng_chunk_prc.h libmng_memory.h libmng_error.h \
+        libmng_trace.h libmng_display.h libmng_zlib.h libmng_pixels.h
+libmng_error.o libmng_error.pic.o: libmng_error.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_trace.o libmng_trace.pic.o: libmng_trace.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_pixels.o libmng_pixels.pic.o: libmng_pixels.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_memory.h libmng_error.h libmng_trace.h \
+        libmng_cms.h libmng_filter.h libmng_pixels.h
+libmng_filter.o libmng_filter.pic.o: libmng_filter.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_filter.h
+libmng_dither.o libmng_dither.pic.o: libmng_dither.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_dither.h
+libmng_zlib.o libmng_zlib.pic.o: libmng_zlib.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h \
+        libmng_filter.h libmng_zlib.h
+libmng_jpeg.o libmng_jpeg.pic.o: libmng_jpeg.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h libmng_jpeg.h
+libmng_cms.o libmng_cms.pic.o: libmng_cms.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_error.h libmng_trace.h libmng_cms.h
+
diff --git a/src/3rdparty/libmng/makefiles/makefile.mingw b/src/3rdparty/libmng/makefiles/makefile.mingw
new file mode 100644
index 0000000..703ae30
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.mingw
@@ -0,0 +1,164 @@
+#
+# For conditions of distribution and use, see copyright notice in libmng.h
+#
+# makefile for libmng - THE MNG library
+# this makefile is for MinGW32, it have been tested with gcc 2.95.3, 
+# binutils 2.11.90 and mingw-runtime 1.0
+#
+# By Benoit Blanchon - benoit.blanchon@laposte.net
+#
+# Note : this makefile builds a static library; although it's seems to be
+# possible to build working DLL and import lib, I didn't manage do to it.
+# If you do, please let me know.
+
+# outputs
+LIBMNG_A   = libmng.a
+INSTALL_PREFIX = C:/MinGW/
+# maybe you sould replace with anti-slashes
+
+# default build options
+OPTIONS = -DMNG_NO_CMS -DMNG_ACCESS_CHUNKS -DMNG_STORE_CHUNKS
+
+# Where the zlib library and include files are located
+ZLIBLIB=-lz
+#ZLIBLIB=-L../zlib -lz
+#ZLIBINC=-I../zlib
+
+# Where the jpeg library and include files are located
+JPEGLIB=-ljpeg
+#JPEGLIB=-L../jpgsrc -ljpeg
+#JPEGINC=-I../jpgsrc
+
+# Where the lcms library and include files are located
+#LCMSLIB=-llcms
+#LCMSLIB=-L../lcms/lib -llcms
+#LCMSINC=-I../lcms/source
+
+# file deletion command
+RM=rm -f 
+#RM=del
+
+# directory creation command
+MKDIR=mkdir -p
+
+# file copy command
+COPY=cp
+#COPY=copy
+
+# compiler
+CC=gcc
+
+ALIGN=
+# for i386:
+#ALIGN=-malign-loops=2 -malign-functions=2
+
+CFLAGS=$(ZLIBINC) $(JPEGINC) $(LCMSINC) -Wall -O3 -funroll-loops $(OPTIONS) $(ALIGN)
+LDFLAGS=-L. -lmng $(ZLIBLIB) $(JPEGLIB) $(LCMSLIB) -lm
+
+# library (.a) file creation command
+AR= ar rc
+# second step in .a creation (use "touch" if not needed)
+AR2= ranlib
+
+INCPATH=$(prefix)/include
+LIBPATH=$(prefix)/lib
+
+OBJS = \
+	libmng_callback_xs.o \
+	libmng_chunk_io.o \
+	libmng_chunk_descr.o \
+	libmng_chunk_prc.o \
+	libmng_chunk_xs.o \
+	libmng_cms.o \
+	libmng_display.o \
+	libmng_dither.o \
+	libmng_error.o \
+	libmng_filter.o \
+	libmng_hlapi.o \
+	libmng_jpeg.o \
+	libmng_object_prc.o \
+	libmng_pixels.o \
+	libmng_prop_xs.o \
+	libmng_read.o \
+	libmng_trace.o \
+	libmng_write.o \
+	libmng_zlib.o
+
+.SUFFIXES: .c .o
+
+.c.o:
+	$(CC) -c $(CFLAGS) -o $@ $*.c
+
+all: $(LIBMNG_A)
+
+$(LIBMNG_A) : $(OBJS)
+	$(RM) $@
+	$(AR) $@ $(OBJS)
+	$(AR2) $@
+
+install : $(LIBMNG_A)
+	$(MKDIR)                 $(INSTALL_PREFIX)include	
+	$(COPY)  libmng.h        $(INSTALL_PREFIX)include
+	$(COPY)  libmng_conf.h   $(INSTALL_PREFIX)include
+	$(COPY)  libmng_types.h  $(INSTALL_PREFIX)include
+	$(MKDIR)                 $(INSTALL_PREFIX)lib
+	$(COPY)  $(LIBMNG_A)     $(INSTALL_PREFIX)lib
+
+clean:
+	$(RM) *.o
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+libmng_hlapi.o : libmng_hlapi.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_memory.h libmng_error.h libmng_trace.h libmng_read.h \
+        libmng_write.h libmng_display.h libmng_zlib.h libmng_cms.h libmng_zlib.h
+libmng_callback_xs.o : libmng_callback_xs.c libmng.h \
+        libmng_conf.h libmng_types.h libmng_data.h libmng_error.h libmng_trace.h
+libmng_prop_xs.o : libmng_prop_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_error.h libmng_trace.h libmng_cms.h
+libmng_chunk_xs.o : libmng_chunk_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h \
+        libmng_error.h libmng_trace.h
+libmng_read.o : libmng_read.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_chunk_prc.h libmng_chunk_io.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_read.h libmng_display.h
+libmng_write.o : libmng_write.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_write.h
+libmng_display.o : libmng_display.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+	libmng_error.h libmng_trace.h libmng_zlib.h libmng_cms.h libmng_pixels.h \
+        libmng_display.h
+libmng_object_prc.o : libmng_object_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_display.h libmng_pixels.h
+libmng_chunk_descr.o : libmng_chunk_descr.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_descr.h \
+        libmng_chunk_prc.h libmng_memory.h libmng_error.h libmng_trace.h
+libmng_chunk_prc.o : libmng_chunk_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h
+libmng_chunk_io.o : libmng_chunk_io.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h \
+        libmng_chunks.h libmng_chunk_io.h libmng_chunk_prc.h libmng_memory.h libmng_error.h \
+        libmng_trace.h libmng_display.h libmng_zlib.h libmng_pixels.h
+libmng_error.o : libmng_error.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_trace.o : libmng_trace.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_pixels.o : libmng_pixels.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_memory.h libmng_error.h libmng_trace.h \
+        libmng_cms.h libmng_filter.h libmng_pixels.h
+libmng_filter.o : libmng_filter.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_filter.h
+libmng_dither.o : libmng_dither.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_dither.h
+libmng_zlib.o : libmng_zlib.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h \
+        libmng_filter.h libmng_zlib.h
+libmng_jpeg.o : libmng_jpeg.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h libmng_jpeg.h
+libmng_cms.o : libmng_cms.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_error.h libmng_trace.h libmng_cms.h
+
diff --git a/src/3rdparty/libmng/makefiles/makefile.mingwdll b/src/3rdparty/libmng/makefiles/makefile.mingwdll
new file mode 100644
index 0000000..2837218
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.mingwdll
@@ -0,0 +1,158 @@
+#
+# For conditions of distribution and use, see copyright notice in libmng.h
+#
+# makefile for libmng - THE MNG library
+# this makefile is for MinGW32, it has been tested with gcc 3.1, 
+# binutils 2.12.90 and mingw-runtime 2.0
+#
+# By Benoit Blanchon - benoit.blanchon@laposte.net
+# DLL mods by F. Richter <frichter@gmx.li>
+#
+
+# outputs
+LIBMNG_A   = libmng.a
+LIBMNG_DLL   = libmng.1.dll
+INSTALL_PREFIX = C:/MinGW/
+# maybe you sould replace with anti-slashes
+
+# default build options
+OPTIONS = -DMNG_BUILD_DLL -DMNG_ACCESS_CHUNKS -DMNG_STORE_CHUNKS
+
+# Where the zlib library and include files are located
+ZLIBLIB=-lz
+#ZLIBLIB=-L../zlib -lz
+#ZLIBINC=-I../zlib
+
+# Where the jpeg library and include files are located
+JPEGLIB=-ljpeg
+#JPEGLIB=-L../jpgsrc -ljpeg
+#JPEGINC=-I../jpgsrc
+
+# Where the lcms library and include files are located
+#LCMSLIB=-llcms
+LCMSLIB=-L../lcms/lib -llcms
+LCMSINC=-I../lcms/source
+
+# file deletion command
+RM=rm -f 
+#RM=del
+
+# directory creation command
+MKDIR=mkdir -p
+
+# file copy command
+COPY=cp
+#COPY=copy
+
+# compiler
+CC=gcc
+
+ALIGN=
+# for i386:
+#ALIGN=-malign-loops=2 -malign-functions=2
+
+CFLAGS=$(ZLIBINC) $(JPEGINC) $(LCMSINC) -Wall -O3 -funroll-loops $(OPTIONS) $(ALIGN) -s
+LDFLAGS=-L. -lmng $(ZLIBLIB) $(JPEGLIB) $(LCMSLIB) -lm -s
+
+INCPATH=$(prefix)/include
+LIBPATH=$(prefix)/lib
+
+OBJS = \
+	libmng_callback_xs.o \
+	libmng_chunk_io.o \
+	libmng_chunk_descr.o \
+	libmng_chunk_prc.o \
+	libmng_chunk_xs.o \
+	libmng_cms.o \
+	libmng_display.o \
+	libmng_dither.o \
+	libmng_error.o \
+	libmng_filter.o \
+	libmng_hlapi.o \
+	libmng_jpeg.o \
+	libmng_object_prc.o \
+	libmng_pixels.o \
+	libmng_prop_xs.o \
+	libmng_read.o \
+	libmng_trace.o \
+	libmng_write.o \
+	libmng_zlib.o
+
+.SUFFIXES: .c .o
+
+.c.o:
+	$(CC) -c $(CFLAGS) -o $@ $*.c
+
+all: $(LIBMNG_A)
+
+$(LIBMNG_A): $(LIBMNG_DLL)
+
+$(LIBMNG_DLL) : $(OBJS)
+	dllwrap --implib=$(LIBMNG_A) --dllname=$(LIBMNG_DLL) $(OBJS) $(LDFLAGS)
+   
+install : $(LIBMNG_A)
+	$(MKDIR)                 $(INSTALL_PREFIX)include	
+	$(COPY)  libmng.h        $(INSTALL_PREFIX)include
+	$(COPY)  libmng_conf.h   $(INSTALL_PREFIX)include
+	$(COPY)  libmng_types.h  $(INSTALL_PREFIX)include
+	$(MKDIR)                 $(INSTALL_PREFIX)lib
+	$(COPY)  $(LIBMNG_A)     $(INSTALL_PREFIX)lib
+
+clean:
+	$(RM) *.o
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+libmng_hlapi.o : libmng_hlapi.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_memory.h libmng_error.h libmng_trace.h libmng_read.h \
+        libmng_write.h libmng_display.h libmng_zlib.h libmng_cms.h libmng_zlib.h
+libmng_callback_xs.o : libmng_callback_xs.c libmng.h \
+        libmng_conf.h libmng_types.h libmng_data.h libmng_error.h libmng_trace.h
+libmng_prop_xs.o : libmng_prop_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_error.h libmng_trace.h libmng_cms.h
+libmng_chunk_xs.o : libmng_chunk_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h \
+        libmng_error.h libmng_trace.h
+libmng_read.o : libmng_read.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_chunk_prc.h libmng_chunk_io.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_read.h libmng_display.h
+libmng_write.o : libmng_write.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_write.h
+libmng_display.o : libmng_display.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+	libmng_error.h libmng_trace.h libmng_zlib.h libmng_cms.h libmng_pixels.h \
+        libmng_display.h
+libmng_object_prc.o : libmng_object_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_display.h libmng_pixels.h
+libmng_chunk_descr.o : libmng_chunk_descr.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_descr.h \
+        libmng_chunk_prc.h libmng_memory.h libmng_error.h libmng_trace.h
+libmng_chunk_prc.o : libmng_chunk_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h
+libmng_chunk_io.o : libmng_chunk_io.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h \
+        libmng_chunks.h libmng_chunk_io.h libmng_chunk_prc.h libmng_memory.h libmng_error.h \
+        libmng_trace.h libmng_display.h libmng_zlib.h libmng_pixels.h
+libmng_error.o : libmng_error.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_trace.o : libmng_trace.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_pixels.o : libmng_pixels.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_memory.h libmng_error.h libmng_trace.h \
+        libmng_cms.h libmng_filter.h libmng_pixels.h
+libmng_filter.o : libmng_filter.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_filter.h
+libmng_dither.o : libmng_dither.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_dither.h
+libmng_zlib.o : libmng_zlib.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h \
+        libmng_filter.h libmng_zlib.h
+libmng_jpeg.o : libmng_jpeg.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h libmng_jpeg.h
+libmng_cms.o : libmng_cms.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_error.h libmng_trace.h libmng_cms.h
+
diff --git a/src/3rdparty/libmng/makefiles/makefile.qnx b/src/3rdparty/libmng/makefiles/makefile.qnx
new file mode 100644
index 0000000..28f18d7
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.qnx
@@ -0,0 +1,160 @@
+#
+# For conditions of distribution and use, see copyright notice in libmng.h
+#
+# makefile for libmng - THE MNG library
+# this makefile is suitable for QNX Neutrino
+
+# Configuration options are now in libmng_conf.h
+
+# The architecture of your target
+# one of arm, mips, ppc, sh, x86
+ARCH = mips
+
+# The name of the library
+LIBNAME = libmng
+ARNAME = $(LIBNAME).a
+SONAME = $(LIBNAME).so
+
+# current version numbers
+MNGMAJ = 1
+MNGMIN = 0.9
+MNGVER = $(MNGMAJ).$(MNGMIN)
+
+# The artefact output folder
+OBJDIR = bin
+
+# Location of jpeg header files
+JPEG_INC = $(QNX_TARGET)/usr/include/jpeg
+
+# Location of zlib header files
+ZLIB_INC = $(QNX_TARGET)/usr/include
+
+# Location of lcms header files
+# (switch on MNG_FULL_CMS in libmng_conf.h if you want to use this)
+LCMS_INC = $(QNX_TARGET)/usr/include/lcms
+
+# default build defines
+DEF = 
+DEF_SO = -DMNG_BUILD_SO
+
+# compiler options:
+CFLAGS = -O2 -funroll-loops
+
+# include paths
+INC = -I$(ZLIB_INC) -I$(JPEG_INC)
+
+# The name of your C compiler:
+CC = nto$(ARCH)-gcc
+
+# source files
+SRC= \
+	libmng_callback_xs.c \
+	libmng_chunk_io.c \
+	libmng_chunk_descr.c \
+	libmng_chunk_prc.c \
+	libmng_chunk_xs.c \
+	libmng_cms.c \
+	libmng_display.c \
+	libmng_dither.c \
+	libmng_error.c \
+	libmng_filter.c \
+	libmng_hlapi.c \
+	libmng_jpeg.c \
+	libmng_object_prc.c \
+	libmng_pixels.c \
+	libmng_prop_xs.c \
+	libmng_read.c \
+	libmng_trace.c \
+	libmng_write.c \
+	libmng_zlib.c
+
+# object files
+OBJ=$(addprefix $(OBJDIR)/$(ARCH)/, $(SRC:%.c=%.o))
+
+# object files for shared object
+OBJ_SO=$(addprefix $(OBJDIR)/$(ARCH)/, $(SRC:%.c=%.pic.o))
+
+# type dependancies
+$(OBJDIR)/$(ARCH)/%.o: %.c
+	$(CC) $(CFLAGS) $(INC) $(DEF) -o $@ -c $<
+
+$(OBJDIR)/$(ARCH)/%.pic.o: %.c
+	$(CC) $(CFLAGS) $(INC) $(DEF_SO) -fPIC -o $@ -c $<
+
+all: init $(ARNAME) $(SONAME)
+
+init:
+	if [ ! -d $(OBJDIR)/$(ARCH) ]; then mkdir -p $(OBJDIR)/$(ARCH); fi 
+
+$(ARNAME): $(OBJ)
+	ar r $(OBJDIR)/$(ARCH)/$(ARNAME) $(OBJ)
+
+$(SONAME): $(SONAME).$(MNGMAJ)
+	ln -sf $(OBJDIR)/$(ARCH)/$(SONAME).$(MNGMAJ) $(OBJDIR)/$(ARCH)/$(SONAME)
+
+$(SONAME).$(MNGMAJ): $(SONAME).$(MNGVER)
+	ln -sf $(OBJDIR)/$(ARCH)/$(SONAME).$(MNGVER) $(OBJDIR)/$(ARCH)/$(SONAME).$(MNGMAJ)
+
+$(SONAME).$(MNGVER): $(OBJ_SO)
+	$(CC) -shared -Wl,-soname,$(SONAME).$(MNGMAJ) -o $(OBJDIR)/$(ARCH)/$(SONAME).$(MNGVER) $(OBJ_SO) \
+	-lz -lm -ljpeg
+#	-lz -lm -ljpeg -llcms
+
+clean:
+	rm -f $(OBJ) $(OBJ_SO)
+	rm -f $(OBJDIR)/$(ARCH)/$(ARNAME) $(OBJDIR)/$(ARCH)/$(SONAME)*
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+libmng_hlapi.o libmng_hlapi.pic.o: libmng_hlapi.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_memory.h libmng_error.h libmng_trace.h libmng_read.h \
+        libmng_write.h libmng_display.h libmng_zlib.h libmng_cms.h libmng_zlib.h
+libmng_callback_xs.o libmng_callback_xs.pic.o: libmng_callback_xs.c libmng.h \
+        libmng_conf.h libmng_types.h libmng_data.h libmng_error.h libmng_trace.h
+libmng_prop_xs.o libmng_prop_xs.pic.o: libmng_prop_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_error.h libmng_trace.h libmng_cms.h
+libmng_chunk_xs.o libmng_chunk_xs.pic.o: libmng_chunk_xs.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h \
+        libmng_error.h libmng_trace.h
+libmng_read.o libmng_read.pic.o: libmng_read.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_object_prc.h \
+	libmng_chunks.h libmng_chunk_prc.h libmng_chunk_io.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_read.h libmng_display.h
+libmng_write.o libmng_write.pic.o: libmng_write.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_write.h
+libmng_display.o libmng_display.pic.o: libmng_display.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+	libmng_error.h libmng_trace.h libmng_zlib.h libmng_cms.h libmng_pixels.h \
+        libmng_display.h
+libmng_object_prc.o libmng_object_prc.pic.o: libmng_object_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h libmng_display.h libmng_pixels.h
+libmng_chunk_descr.o libmng_chunk_descr.pic.o: libmng_chunk_descr.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_descr.h libmng_memory.h \
+        libmng_chunk_prc.h libmng_error.h libmng_trace.h
+libmng_chunk_prc.o libmng_chunk_prc.pic.o: libmng_chunk_prc.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_chunks.h libmng_chunk_prc.h libmng_memory.h \
+        libmng_error.h libmng_trace.h
+libmng_chunk_io.o libmng_chunk_io.pic.o: libmng_chunk_io.c libmng.h libmng_conf.h \
+        libmng_types.h libmng_data.h libmng_objects.h libmng_object_prc.h \
+        libmng_chunks.h libmng_chunk_io.h libmng_chunk_prc.h libmng_memory.h libmng_error.h \
+        libmng_trace.h libmng_display.h libmng_zlib.h libmng_pixels.h
+libmng_error.o libmng_error.pic.o: libmng_error.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_trace.o libmng_trace.pic.o: libmng_trace.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h
+libmng_pixels.o libmng_pixels.pic.o: libmng_pixels.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_memory.h libmng_error.h libmng_trace.h \
+        libmng_cms.h libmng_filter.h libmng_pixels.h
+libmng_filter.o libmng_filter.pic.o: libmng_filter.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_filter.h
+libmng_dither.o libmng_dither.pic.o: libmng_dither.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_error.h libmng_trace.h libmng_dither.h
+libmng_zlib.o libmng_zlib.pic.o: libmng_zlib.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h \
+        libmng_filter.h libmng_zlib.h
+libmng_jpeg.o libmng_jpeg.pic.o: libmng_jpeg.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_memory.h libmng_error.h libmng_trace.h libmng_pixels.h libmng_jpeg.h
+libmng_cms.o libmng_cms.pic.o: libmng_cms.c libmng.h libmng_conf.h libmng_types.h \
+	libmng_data.h libmng_objects.h libmng_error.h libmng_trace.h libmng_cms.h
diff --git a/src/3rdparty/libmng/makefiles/makefile.unix b/src/3rdparty/libmng/makefiles/makefile.unix
new file mode 100644
index 0000000..4d3fd97
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.unix
@@ -0,0 +1,67 @@
+#
+# For conditions of distribution and use, see copyright notice in libmng.h
+#
+# makefile for libmng - THE MNG library
+# this makefile is suitable for generic unix
+
+# Configuration options are now in libmng_conf.h
+
+# The name of your C compiler:
+CC= cc
+
+# Location of jpeg header files
+JPEG_INC= /cs/include/jpeg
+
+# Location of zlib header files
+ZLIB_INC= /cs/include
+
+# Location of lcms header files
+# (switch on MNG_FULL_CMS in libmng_conf.h if you want to use this)
+LCMS_INC= /ltmp/lcms-1.06/source
+
+# compiler options:
+CFLAGS= -O -I. -I$(ZLIB_INC) -I$(JPEG_INC) -I$(LCMS_INC)
+
+# source files
+SOURCES= \
+	 libmng_callback_xs.c \
+	 libmng_chunk_io.c \
+	 libmng_chunk_descr.c \
+	 libmng_chunk_prc.c \
+	 libmng_chunk_xs.c \
+	 libmng_cms.c \
+	 libmng_display.c \
+	 libmng_dither.c \
+	 libmng_error.c \
+	 libmng_filter.c \
+	 libmng_hlapi.c \
+	 libmng_jpeg.c \
+	 libmng_object_prc.c \
+	 libmng_pixels.c \
+	 libmng_prop_xs.c \
+	 libmng_read.c \
+	 libmng_trace.c \
+	 libmng_write.c \
+	 libmng_zlib.c
+
+# object files
+OBJECTS= $(SOURCES:%.c=%.o)
+
+# type dependancies
+.c.o:
+	$(CC) $(CFLAGS) -c $<
+
+all: libmng.a
+
+clean:
+	/bin/rm -f $(OBJECTS)
+	/bin/rm -f libmng.a
+	/bin/rm -f *~ core
+
+libmng.a: $(OBJECTS)
+	ar r libmng.a $(OBJECTS)
+
+depend:
+	makedepend -- $(CFLAGS) $(IFLAGS) -- *.c
+
+# DO NOT DELETE
diff --git a/src/3rdparty/libmng/makefiles/makefile.vcwin32 b/src/3rdparty/libmng/makefiles/makefile.vcwin32
new file mode 100644
index 0000000..6f9c2c0
--- /dev/null
+++ b/src/3rdparty/libmng/makefiles/makefile.vcwin32
@@ -0,0 +1,99 @@
+# makefile for libmng
+# Copyright (C) 2000 AM(s98t269@stmail.eng.kagawa-u.ac.jp)
+# For conditions of distribution and use, see copyright notice in libmng.h
+# Assumes that zlib.lib, zconf.h, and zlib.h have been copied to ..\zlib
+# Assumes that libjpeg.lib, *.h have been copied to ..\jpgsrc6b
+# Assumes that lcmsdll.lib and lcmsstat.lib have been copied to ..\lcms\lib\msvc
+# To use, do "nmake /f makefiles\makefile.vcwin32"
+
+# -------- Microsoft Visual C++ 4.0 and later, no assembler code --------
+
+CFLAGS= -Ox -GA3s -nologo -W3 -I..\zlib -I..\jpgsrc6b -I..\lcms\include
+
+CC=cl
+LD=link
+LDFLAGS= 
+O=.obj
+
+#uncomment next to put error messages in a file
+#ERRFILE= >> mngerrs
+
+# variables
+OBJS1 = libmng_callback_xs$(O) libmng_chunk_io$(O) libmng_chunk_prc$(O) libmng_chunk_descr$(0)
+OBJS2 = libmng_chunk_xs$(O) libmng_cms$(O) libmng_display$(O) libmng_dither$(O)
+OBJS3 = libmng_error$(O) libmng_filter$(O) libmng_hlapi$(O) libmng_jpeg$(O)
+OBJS4 = libmng_object_prc$(O) libmng_pixels$(O) libmng_prop_xs$(O)
+OBJS5 = libmng_read$(O) libmng_trace$(O) libmng_write$(O) libmng_zlib$(O)
+
+all: libmng.lib
+
+libmng_callback_xs$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_chunk_io$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_chunk_descr$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_chunk_prc$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_chunk_xs$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_cms$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_display$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_dither$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_error$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_filter$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_hlapi$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_jpeg$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_object_prc$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_pixels$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_prop_xs$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_read$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_trace$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_write$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng_zlib$(O): libmng.h libmng_data.h libmng_error.h libmng_trace.h
+		  $(CC) -c $(CFLAGS) $*.c $(ERRFILE)
+
+libmng.lib: $(OBJS1) $(OBJS2) $(OBJS3) $(OBJS4) $(OBJS5)
+	echo something to del > libmng.lib
+	del libmng.lib
+	lib /OUT:libmng.lib $(OBJS1) $(OBJS2) $(OBJS3) $(OBJS4) $(OBJS5)
+
+mngtest.exe: mngtest.obj libmng.lib
+	$(LD) $(LDFLAGS) mngtest.obj libmng.lib ..\zlib\zlib.lib /OUT:mngtest.exe /SUBSYSTEM:CONSOLE
+
+test: mngtest.exe
+	mngtest
+
+# End of makefile for libmng
+
diff --git a/src/3rdparty/libmng/unmaintained/autogen.sh b/src/3rdparty/libmng/unmaintained/autogen.sh
new file mode 100755
index 0000000..308ae37
--- /dev/null
+++ b/src/3rdparty/libmng/unmaintained/autogen.sh
@@ -0,0 +1,50 @@
+# autogen.sh
+#
+# invoke the auto* tools to create the configureation system
+
+# move out configure.in
+if ! test -f configure.in; then
+  echo "copying configure.in"
+  ln -s makefiles/configure.in .
+fi
+
+# move out the macros and run aclocal
+if test ! -f acinclude.m4 -a -r makefiles/acinclude.m4; then
+  echo "copying configure macros"
+  ln -s makefiles/acinclude.m4 .
+fi
+
+# copy up our Makefile template
+if ! test -f Makefile.am; then
+  echo "copying automake template"
+  ln -s makefiles/Makefile.am .
+fi
+
+echo "running aclocal"
+aclocal
+
+# libtool is named glibtool on MacOS X
+for LIBTOOLIZE in libtoolize glibtoolize nope; do
+  ($LIBTOOLIZE --version) < /dev/null > /dev/null 2>&1 && break
+done
+if test x$LIBTOOLIZE = xnope; then
+  echo "error: Could not find libtoolize in the path!"
+  echo "  You'll need to install a copy of libtool before continuing"
+  echo "  with the generation of the build system."
+  echo
+  exit 1
+fi
+
+echo "running $LIBTOOLIZE"
+$LIBTOOLIZE --automake
+
+echo "running automake"
+automake --foreign --add-missing
+
+echo "building configure script"
+autoconf
+
+# and finally invoke our new configure
+./configure $*
+
+# end
diff --git a/src/3rdparty/patches/libmng-1.0.10-endless-loop.patch b/src/3rdparty/patches/libmng-1.0.10-endless-loop.patch
new file mode 100644
index 0000000..31f0474
--- /dev/null
+++ b/src/3rdparty/patches/libmng-1.0.10-endless-loop.patch
@@ -0,0 +1,65 @@
+--- libmng_data.h.orig	2007-04-20 10:41:58.000000000 +0200
++++ libmng_data.h	2007-07-14 00:00:00.000000000 +0200
+@@ -658,6 +658,9 @@
+            mng_int32         iFrameclipb;
+ 
+            mng_uint32        iNextdelay;         /* delay *after* next image */
++
++           mng_bool          bForcedelay;
++           mng_uint32        iAccumdelay;
+ #endif
+ 
+ #ifndef MNG_SKIPCHUNK_SHOW
+--- libmng_display.c.orig	2007-04-20 10:41:58.000000000 +0200
++++ libmng_display.c	2007-07-14 00:00:00.000000000 +0200
+@@ -384,8 +384,9 @@
+ 
+   {
+ #ifndef MNG_SKIPCHUNK_FRAM
+-    if (pData->iFramedelay > 0)        /* real delay ? */
++    if (pData->iFramedelay > 0 || pData->bForcedelay) /* real delay ? */
+     {                                  /* let the app refresh first ? */
++      pData->bForcedelay = MNG_FALSE;
+       if ((pData->bRunning) && (!pData->bSkipping) &&
+           (pData->iUpdatetop < pData->iUpdatebottom) && (pData->iUpdateleft < pData->iUpdateright))
+         if (!pData->fRefresh (((mng_handle)pData),
+@@ -455,6 +456,7 @@
+       pData->iFrametime = pData->iFrametime + iWaitfor;
+                                        /* setup for next delay */
+     pData->iFramedelay = pData->iNextdelay;
++    pData->iAccumdelay += pData->iFramedelay;
+ #endif
+   }
+ 
+@@ -3340,6 +3342,9 @@
+   MNG_TRACE (pData, MNG_FN_PROCESS_DISPLAY_MEND, MNG_LC_START);
+ #endif
+ 
++  pData->bForcedelay = pData->iAccumdelay ? MNG_FALSE : MNG_TRUE;
++  pData->iAccumdelay = 0;
++
+ #ifdef MNG_SUPPORT_DYNAMICMNG
+   if (pData->bStopafterseek)           /* need to stop after this ? */
+   {
+--- libmng_hlapi.c.orig	2007-07-06 18:23:04.000000000 +0200
++++ libmng_hlapi.c	2007-07-14 00:00:00.000000000 +0200
+@@ -446,6 +446,9 @@
+   pData->iFrameclipb           = 0;
+ 
+   pData->iNextdelay            = 1;
++
++  pData->bForcedelay           = MNG_FALSE;
++  pData->iAccumdelay           = 0;
+ #endif
+ 
+ #ifndef MNG_SKIPCHUNK_SHOW
+@@ -1737,6 +1740,9 @@
+   pData->iFrameclipb           = 0;
+ 
+   pData->iNextdelay            = 1;
++
++  pData->bForcedelay           = MNG_FALSE;
++  pData->iAccumdelay           = 0;
+ #endif
+ 
+ #ifndef MNG_SKIPCHUNK_SHOW
diff --git a/src/3rdparty/zlib_dependency.pri b/src/3rdparty/zlib_dependency.pri
new file mode 100644
index 0000000..8373a8c
--- /dev/null
+++ b/src/3rdparty/zlib_dependency.pri
@@ -0,0 +1,10 @@
+# zlib dependency satisfied by bundled 3rd party zlib or system zlib
+contains(QT_CONFIG, system-zlib) {
+    symbian:                 LIBS_PRIVATE += -llibz
+    else:if(unix|win32-g++*):LIBS_PRIVATE += -lz
+    else:                    LIBS += zdll.lib
+} else {
+# We could copy the zlib sources over to this module, but for now we don't.
+#    INCLUDEPATH +=  $$PWD/zlib
+    error(zlib not available: Qt was not built with the system's zlib)
+}
diff --git a/src/plugins/imageformats/imageformats.pro b/src/plugins/imageformats/imageformats.pro
new file mode 100644
index 0000000..5279d05
--- /dev/null
+++ b/src/plugins/imageformats/imageformats.pro
@@ -0,0 +1,3 @@
+TEMPLATE = subdirs
+SUBDIRS =
+contains(QT_CONFIG, system-zlib): SUBDIRS += mng
diff --git a/src/plugins/imageformats/mng/main.cpp b/src/plugins/imageformats/mng/main.cpp
new file mode 100644
index 0000000..e5e6250
--- /dev/null
+++ b/src/plugins/imageformats/mng/main.cpp
@@ -0,0 +1,98 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qimageiohandler.h>
+#include <qstringlist.h>
+
+#ifndef QT_NO_IMAGEFORMATPLUGIN
+
+#ifdef QT_NO_IMAGEFORMAT_MNG
+#undef QT_NO_IMAGEFORMAT_MNG
+#endif
+#include <qmnghandler_p.h>
+
+#include <qiodevice.h>
+#include <qbytearray.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMngPlugin : public QImageIOPlugin
+{
+    public:
+    QStringList keys() const;
+    Capabilities capabilities(QIODevice *device, const QByteArray &format) const;
+    QImageIOHandler *create(QIODevice *device, const QByteArray &format = QByteArray()) const;
+};
+
+QStringList QMngPlugin::keys() const
+{
+    return QStringList() << QLatin1String("mng");
+}
+
+QImageIOPlugin::Capabilities QMngPlugin::capabilities(QIODevice *device, const QByteArray &format) const
+{
+    if (format == "mng")
+        return Capabilities(CanRead);
+    if (!format.isEmpty())
+        return 0;
+    if (!device->isOpen())
+        return 0;
+
+    Capabilities cap;
+    if (device->isReadable() && QMngHandler::canRead(device))
+        cap |= CanRead;
+    return cap;
+}
+
+QImageIOHandler *QMngPlugin::create(QIODevice *device, const QByteArray &format) const
+{
+    QMngHandler *hand = new QMngHandler();
+    hand->setDevice(device);
+    hand->setFormat(format);
+    return hand;
+}
+
+Q_EXPORT_STATIC_PLUGIN(QMngPlugin)
+Q_EXPORT_PLUGIN2(qmng, QMngPlugin)
+
+QT_END_NAMESPACE
+
+#endif // !QT_NO_IMAGEFORMATPLUGIN
diff --git a/src/plugins/imageformats/mng/mng.pro b/src/plugins/imageformats/mng/mng.pro
new file mode 100644
index 0000000..1bac008
--- /dev/null
+++ b/src/plugins/imageformats/mng/mng.pro
@@ -0,0 +1,20 @@
+TARGET  = qmng
+load(qt_plugin)
+
+# QTDIR_build:REQUIRES = "!contains(QT_CONFIG, no-mng)"
+
+HEADERS += qmnghandler_p.h
+SOURCES += qmnghandler.cpp
+contains(QT_CONFIG, system-mng) {
+        if(unix|win32-g++*):LIBS += -lmng
+        else:win32:         LIBS += libmng.lib
+} else {
+    include($$PWD/../../../3rdparty/libmng.pri)
+    *-g++*: QMAKE_CFLAGS_WARN_ON += -Wno-unused-parameter
+}
+
+SOURCES += main.cpp
+
+DESTDIR = $$QT.gui.plugins/imageformats
+target.path += $$[QT_INSTALL_PLUGINS]/imageformats
+INSTALLS += target
diff --git a/src/plugins/imageformats/mng/qmnghandler.cpp b/src/plugins/imageformats/mng/qmnghandler.cpp
new file mode 100644
index 0000000..dfea57f
--- /dev/null
+++ b/src/plugins/imageformats/mng/qmnghandler.cpp
@@ -0,0 +1,497 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qmnghandler_p.h"
+
+#include "qimage.h"
+#include "qvariant.h"
+#include "qcolor.h"
+
+#define MNG_USE_SO
+#include <libmng.h>
+
+QT_BEGIN_NAMESPACE
+
+class QMngHandlerPrivate
+{
+    Q_DECLARE_PUBLIC(QMngHandler)
+    public:
+    bool haveReadNone;
+    bool haveReadAll;
+    mng_handle hMNG;
+    QImage image;
+    int elapsed;
+    int nextDelay;
+    int iterCount;
+    int frameIndex;
+    int nextIndex;
+    int frameCount;
+    mng_uint32 iStyle;
+    mng_bool readData(mng_ptr pBuf, mng_uint32 iSize, mng_uint32p pRead);
+    mng_bool writeData(mng_ptr pBuf, mng_uint32 iSize, mng_uint32p pWritten);
+    mng_bool processHeader(mng_uint32 iWidth, mng_uint32 iHeight);
+    QMngHandlerPrivate(QMngHandler *q_ptr);
+    ~QMngHandlerPrivate();
+    bool getNextImage(QImage *result);
+    bool writeImage(const QImage &image);
+    int currentImageNumber() const;
+    int imageCount() const;
+    bool jumpToImage(int imageNumber);
+    bool jumpToNextImage();
+    int nextImageDelay() const;
+    bool setBackgroundColor(const QColor &color);
+    QColor backgroundColor() const;
+    QMngHandler *q_ptr;
+};
+
+static mng_bool myerror(mng_handle /*hMNG*/,
+    mng_int32   iErrorcode,
+    mng_int8    /*iSeverity*/,
+    mng_chunkid iChunkname,
+    mng_uint32  /*iChunkseq*/,
+    mng_int32   iExtra1,
+    mng_int32   iExtra2,
+    mng_pchar   zErrortext)
+{
+    qWarning("MNG error %d: %s; chunk %c%c%c%c; subcode %d:%d",
+        iErrorcode,zErrortext,
+        (iChunkname>>24)&0xff,
+        (iChunkname>>16)&0xff,
+        (iChunkname>>8)&0xff,
+        (iChunkname>>0)&0xff,
+        iExtra1,iExtra2);
+    return TRUE;
+}
+
+static mng_ptr myalloc(mng_size_t iSize)
+{
+#if defined(Q_OS_WINCE)
+    mng_ptr ptr = malloc(iSize);
+    memset(ptr, 0, iSize);
+    return ptr;
+#else
+    return (mng_ptr)calloc(1, iSize);
+#endif
+}
+
+static void myfree(mng_ptr pPtr, mng_size_t /*iSize*/)
+{
+    free(pPtr);
+}
+
+static mng_bool myopenstream(mng_handle)
+{
+    return MNG_TRUE;
+}
+
+static mng_bool myclosestream(mng_handle hMNG)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    pMydata->haveReadAll = true;
+    return MNG_TRUE;
+}
+
+static mng_bool myreaddata(mng_handle hMNG,
+                    mng_ptr    pBuf,
+                    mng_uint32 iSize,
+                    mng_uint32p pRead)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    return pMydata->readData(pBuf, iSize, pRead);
+}
+
+static mng_bool mywritedata(mng_handle hMNG,
+                     mng_ptr pBuf,
+                     mng_uint32 iSize,
+                     mng_uint32p pWritten)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    return pMydata->writeData(pBuf, iSize, pWritten);
+}
+
+static mng_bool myprocessheader(mng_handle hMNG,
+                                mng_uint32 iWidth,
+                                mng_uint32 iHeight)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    return pMydata->processHeader(iWidth, iHeight);
+}
+
+static mng_ptr mygetcanvasline(mng_handle hMNG,
+                               mng_uint32 iLinenr)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    return (mng_ptr)pMydata->image.scanLine(iLinenr);
+}
+
+static mng_bool myrefresh(mng_handle /*hMNG*/,
+                          mng_uint32 /*iX*/,
+                          mng_uint32 /*iY*/,
+                          mng_uint32 /*iWidth*/,
+                          mng_uint32 /*iHeight*/)
+{
+    return MNG_TRUE;
+}
+
+static mng_uint32 mygettickcount(mng_handle hMNG)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    return pMydata->elapsed++;
+}
+
+static mng_bool mysettimer(mng_handle hMNG,
+                           mng_uint32 iMsecs)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    pMydata->elapsed += iMsecs;
+    pMydata->nextDelay = iMsecs;
+    return MNG_TRUE;
+}
+
+static mng_bool myprocessterm(mng_handle hMNG,
+                        mng_uint8   iTermaction,
+                        mng_uint8   /*iIteraction*/,
+                        mng_uint32  /*iDelay*/,
+                        mng_uint32  iItermax)
+{
+    QMngHandlerPrivate *pMydata = reinterpret_cast<QMngHandlerPrivate *>(mng_get_userdata(hMNG));
+    if (iTermaction == 3)
+        pMydata->iterCount = iItermax;
+    return MNG_TRUE;
+}
+
+static mng_bool mytrace(mng_handle,
+                        mng_int32   iFuncnr,
+                        mng_int32   iFuncseq,
+                        mng_pchar   zFuncname)
+{
+    qDebug("mng trace: iFuncnr: %d iFuncseq: %d zFuncname: %s", iFuncnr, iFuncseq, zFuncname);
+    return MNG_TRUE;
+}
+
+QMngHandlerPrivate::QMngHandlerPrivate(QMngHandler *q_ptr)
+    : haveReadNone(true), haveReadAll(false), elapsed(0), nextDelay(0), iterCount(1),
+      frameIndex(-1), nextIndex(0), frameCount(0), q_ptr(q_ptr)
+{
+    iStyle = (QSysInfo::ByteOrder == QSysInfo::LittleEndian) ? MNG_CANVAS_BGRA8 : MNG_CANVAS_ARGB8;
+    // Initialize libmng
+    hMNG = mng_initialize((mng_ptr)this, myalloc, myfree, mytrace);
+    if (hMNG) {
+        // Set callback functions
+        mng_setcb_errorproc(hMNG, myerror);
+        mng_setcb_openstream(hMNG, myopenstream);
+        mng_setcb_closestream(hMNG, myclosestream);
+        mng_setcb_readdata(hMNG, myreaddata);
+        mng_setcb_writedata(hMNG, mywritedata);
+        mng_setcb_processheader(hMNG, myprocessheader);
+        mng_setcb_getcanvasline(hMNG, mygetcanvasline);
+        mng_setcb_refresh(hMNG, myrefresh);
+        mng_setcb_gettickcount(hMNG, mygettickcount);
+        mng_setcb_settimer(hMNG, mysettimer);
+        mng_setcb_processterm(hMNG, myprocessterm);
+        mng_set_doprogressive(hMNG, MNG_FALSE);
+        mng_set_suspensionmode(hMNG, MNG_TRUE);
+    }
+}
+
+QMngHandlerPrivate::~QMngHandlerPrivate()
+{
+    mng_cleanup(&hMNG);
+}
+
+mng_bool QMngHandlerPrivate::readData(mng_ptr pBuf, mng_uint32 iSize, mng_uint32p pRead)
+{
+    Q_Q(QMngHandler);
+    *pRead = q->device()->read((char *)pBuf, iSize);
+    return (*pRead > 0) ? MNG_TRUE : MNG_FALSE;
+}
+
+mng_bool QMngHandlerPrivate::writeData(mng_ptr pBuf, mng_uint32 iSize, mng_uint32p pWritten)
+{
+    Q_Q(QMngHandler);
+    *pWritten = q->device()->write((char *)pBuf, iSize);
+    return MNG_TRUE;
+}
+
+mng_bool QMngHandlerPrivate::processHeader(mng_uint32 iWidth, mng_uint32 iHeight)
+{
+    if (mng_set_canvasstyle(hMNG, iStyle) != MNG_NOERROR)
+        return MNG_FALSE;
+    image = QImage(iWidth, iHeight, QImage::Format_ARGB32);
+    image.fill(0);
+    return MNG_TRUE;
+}
+
+bool QMngHandlerPrivate::getNextImage(QImage *result)
+{
+    mng_retcode ret;
+    if (haveReadNone) {
+        haveReadNone = false;
+        ret = mng_readdisplay(hMNG);
+    } else {
+        ret = mng_display_resume(hMNG);
+    }
+    if ((MNG_NOERROR == ret) || (MNG_NEEDTIMERWAIT == ret)) {
+        *result = image;
+        frameIndex = nextIndex++;
+        if (haveReadAll && (frameCount == 0))
+            frameCount = nextIndex;
+        return true;
+    }
+    return false;
+}
+
+bool QMngHandlerPrivate::writeImage(const QImage &image)
+{
+    mng_reset(hMNG);
+    if (mng_create(hMNG) != MNG_NOERROR)
+        return false;
+
+    this->image = image.convertToFormat(QImage::Format_ARGB32);
+    int w = image.width();
+    int h = image.height();
+
+    if (
+    // width, height, ticks, layercount, framecount, playtime, simplicity
+         (mng_putchunk_mhdr(hMNG, w, h, 1000, 0, 0, 0, 7) == MNG_NOERROR) &&
+    // termination_action, action_after_iterations, delay, iteration_max
+         (mng_putchunk_term(hMNG, 3, 0, 1, 0x7FFFFFFF) == MNG_NOERROR) &&
+    // width, height, bitdepth, colortype, compression, filter, interlace
+         (mng_putchunk_ihdr(hMNG, w, h, 8, 6, 0, 0, 0) == MNG_NOERROR) &&
+    // width, height, colortype, bitdepth, compression, filter, interlace, canvasstyle, getcanvasline
+         (mng_putimgdata_ihdr(hMNG, w, h, 6, 8, 0, 0, 0, iStyle, mygetcanvasline) == MNG_NOERROR) &&
+         (mng_putchunk_iend(hMNG) == MNG_NOERROR) &&
+         (mng_putchunk_mend(hMNG) == MNG_NOERROR) &&
+         (mng_write(hMNG) == MNG_NOERROR)
+        )
+        return true;
+    return false;
+}
+
+int QMngHandlerPrivate::currentImageNumber() const
+{
+//    return mng_get_currentframe(hMNG) % imageCount(); not implemented, apparently
+    return frameIndex;
+}
+
+int QMngHandlerPrivate::imageCount() const
+{
+//    return mng_get_totalframes(hMNG); not implemented, apparently
+    if (haveReadAll)
+        return frameCount;
+    return 0; // Don't know
+}
+
+bool QMngHandlerPrivate::jumpToImage(int imageNumber)
+{
+    if (imageNumber == nextIndex)
+        return true;
+
+    if ((imageNumber == 0) && haveReadAll && (nextIndex == frameCount)) {
+        // Loop!
+        nextIndex = 0;
+        return true;
+    }
+    if (mng_display_freeze(hMNG) == MNG_NOERROR) {
+        if (mng_display_goframe(hMNG, imageNumber) == MNG_NOERROR) {
+            nextIndex = imageNumber;
+            return true;
+        }
+    }
+    return false;
+}
+
+bool QMngHandlerPrivate::jumpToNextImage()
+{
+    return jumpToImage((currentImageNumber()+1) % imageCount());
+}
+
+int QMngHandlerPrivate::nextImageDelay() const
+{
+    return nextDelay;
+}
+
+bool QMngHandlerPrivate::setBackgroundColor(const QColor &color)
+{
+    mng_uint16 iRed = (mng_uint16)(color.red() << 8);
+    mng_uint16 iBlue = (mng_uint16)(color.blue() << 8);
+    mng_uint16 iGreen = (mng_uint16)(color.green() << 8);
+    return (mng_set_bgcolor(hMNG, iRed, iBlue, iGreen) == MNG_NOERROR);
+}
+
+QColor QMngHandlerPrivate::backgroundColor() const
+{
+    mng_uint16 iRed;
+    mng_uint16 iBlue;
+    mng_uint16 iGreen;
+    if (mng_get_bgcolor(hMNG, &iRed, &iBlue, &iGreen) == MNG_NOERROR)
+        return QColor((iRed >> 8) & 0xFF, (iGreen >> 8) & 0xFF, (iBlue >> 8) & 0xFF);
+    return QColor();
+}
+
+QMngHandler::QMngHandler()
+    : d_ptr(new QMngHandlerPrivate(this))
+{
+}
+
+QMngHandler::~QMngHandler()
+{
+}
+
+/*! \reimp */
+bool QMngHandler::canRead() const
+{
+    Q_D(const QMngHandler);
+    if ((!d->haveReadNone
+         && (!d->haveReadAll || (d->haveReadAll && (d->nextIndex < d->frameCount))))
+        || canRead(device()))
+    {
+        setFormat("mng");
+        return true;
+    }
+    return false;
+}
+
+/*! \internal */
+bool QMngHandler::canRead(QIODevice *device)
+{
+    if (!device) {
+        qWarning("QMngHandler::canRead() called with no device");
+        return false;
+    }
+
+    return device->peek(8) == "\x8A\x4D\x4E\x47\x0D\x0A\x1A\x0A";
+}
+
+/*! \reimp */
+QByteArray QMngHandler::name() const
+{
+    return "mng";
+}
+
+/*! \reimp */
+bool QMngHandler::read(QImage *image)
+{
+    Q_D(QMngHandler);
+    return canRead() ? d->getNextImage(image) : false;
+}
+
+/*! \reimp */
+bool QMngHandler::write(const QImage &image)
+{
+    Q_D(QMngHandler);
+    return d->writeImage(image);
+}
+
+/*! \reimp */
+int QMngHandler::currentImageNumber() const
+{
+    Q_D(const QMngHandler);
+    return d->currentImageNumber();
+}
+
+/*! \reimp */
+int QMngHandler::imageCount() const
+{
+    Q_D(const QMngHandler);
+    return d->imageCount();
+}
+
+/*! \reimp */
+bool QMngHandler::jumpToImage(int imageNumber)
+{
+    Q_D(QMngHandler);
+    return d->jumpToImage(imageNumber);
+}
+
+/*! \reimp */
+bool QMngHandler::jumpToNextImage()
+{
+    Q_D(QMngHandler);
+    return d->jumpToNextImage();
+}
+
+/*! \reimp */
+int QMngHandler::loopCount() const
+{
+    Q_D(const QMngHandler);
+    if (d->iterCount == 0x7FFFFFFF)
+        return -1; // infinite loop
+    return d->iterCount-1;
+}
+
+/*! \reimp */
+int QMngHandler::nextImageDelay() const
+{
+    Q_D(const QMngHandler);
+    return d->nextImageDelay();
+}
+
+/*! \reimp */
+QVariant QMngHandler::option(ImageOption option) const
+{
+    Q_D(const QMngHandler);
+    if (option == QImageIOHandler::Animation)
+        return true;
+    else if (option == QImageIOHandler::BackgroundColor)
+        return d->backgroundColor();
+    return QVariant();
+}
+
+/*! \reimp */
+void QMngHandler::setOption(ImageOption option, const QVariant & value)
+{
+    Q_D(QMngHandler);
+    if (option == QImageIOHandler::BackgroundColor)
+        d->setBackgroundColor(qvariant_cast<QColor>(value));
+}
+
+/*! \reimp */
+bool QMngHandler::supportsOption(ImageOption option) const
+{
+    if (option == QImageIOHandler::Animation)
+        return true;
+    else if (option == QImageIOHandler::BackgroundColor)
+        return true;
+    return false;
+}
+
+QT_END_NAMESPACE
diff --git a/src/plugins/imageformats/mng/qmnghandler.pri b/src/plugins/imageformats/mng/qmnghandler.pri
new file mode 100644
index 0000000..ffb98de
--- /dev/null
+++ b/src/plugins/imageformats/mng/qmnghandler.pri
@@ -0,0 +1,10 @@
+# common to plugin and built-in forms
+INCLUDEPATH *= $$PWD
+HEADERS += $$PWD/qmnghandler_p.h
+SOURCES += $$PWD/qmnghandler.cpp
+contains(QT_CONFIG, system-mng) {
+        if(unix|win32-g++*):LIBS += -lmng
+        else:win32:         LIBS += libmng.lib
+} else {
+    include($$PWD/../../3rdparty/libmng.pri)
+}
diff --git a/src/plugins/imageformats/mng/qmnghandler_p.h b/src/plugins/imageformats/mng/qmnghandler_p.h
new file mode 100644
index 0000000..5376acd
--- /dev/null
+++ b/src/plugins/imageformats/mng/qmnghandler_p.h
@@ -0,0 +1,83 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the plugins of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QMNGHANDLER_P_H
+#define QMNGHANDLER_P_H
+
+#include <QtCore/qscopedpointer.h>
+#include <QtGui/qimageiohandler.h>
+
+QT_BEGIN_NAMESPACE
+
+class QImage;
+class QByteArray;
+class QIODevice;
+class QVariant;
+class QMngHandlerPrivate;
+
+class QMngHandler : public QImageIOHandler
+{
+    public:
+    QMngHandler();
+    ~QMngHandler();
+    virtual bool canRead() const;
+    virtual QByteArray name() const;
+    virtual bool read(QImage *image);
+    virtual bool write(const QImage &image);
+    virtual int currentImageNumber() const;
+    virtual int imageCount() const;
+    virtual bool jumpToImage(int imageNumber);
+    virtual bool jumpToNextImage();
+    virtual int loopCount() const;
+    virtual int nextImageDelay() const;
+    static bool canRead(QIODevice *device);
+    virtual QVariant option(ImageOption option) const;
+    virtual void setOption(ImageOption option, const QVariant & value);
+    virtual bool supportsOption(ImageOption option) const;
+
+    private:
+    Q_DECLARE_PRIVATE(QMngHandler)
+    QScopedPointer<QMngHandlerPrivate> d_ptr;
+};
+
+QT_END_NAMESPACE
+
+#endif // QMNGHANDLER_P_H
diff --git a/src/plugins/plugins.pro b/src/plugins/plugins.pro
new file mode 100644
index 0000000..e9abe7d
--- /dev/null
+++ b/src/plugins/plugins.pro
@@ -0,0 +1,2 @@
+TEMPLATE = subdirs
+SUBDIRS = imageformats
diff --git a/src/src.pro b/src/src.pro
new file mode 100644
index 0000000..64db4ad
--- /dev/null
+++ b/src/src.pro
@@ -0,0 +1,2 @@
+TEMPLATE = subdirs
+SUBDIRS = plugins
diff --git a/sync.profile b/sync.profile
new file mode 100644
index 0000000..98108f1
--- /dev/null
+++ b/sync.profile
@@ -0,0 +1,19 @@
+%modules = ( # path to module name map
+);
+%moduleheaders = ( # restrict the module headers to those found in relative path
+);
+%classnames = (
+);
+%mastercontent = (
+);
+%modulepris = (
+);
+# Module dependencies.
+# Every module that is required to build this module should have one entry.
+# Each of the module version specifiers can take one of the following values:
+#   - A specific Git revision.
+#   - any git symbolic ref resolvable from the module's repository (e.g. "refs/heads/master" to track master branch)
+#
+%dependencies = (
+        "qtbase" => "refs/heads/master",
+);
diff --git a/tests/auto/auto.pro b/tests/auto/auto.pro
new file mode 100644
index 0000000..5279d05
--- /dev/null
+++ b/tests/auto/auto.pro
@@ -0,0 +1,3 @@
+TEMPLATE = subdirs
+SUBDIRS =
+contains(QT_CONFIG, system-zlib): SUBDIRS += mng
diff --git a/tests/auto/mng/mng.pro b/tests/auto/mng/mng.pro
new file mode 100644
index 0000000..fcd0718
--- /dev/null
+++ b/tests/auto/mng/mng.pro
@@ -0,0 +1,11 @@
+TEMPLATE = app
+TARGET = tst_qmng
+DEPENDPATH += .
+INCLUDEPATH += .
+
+QT = core gui testlib
+CONFIG -= app_bundle
+CONFIG += testcase
+
+SOURCES += tst_qmng.cpp
+RESOURCES += $$PWD/../../shared/images/mng.qrc
diff --git a/tests/auto/mng/tst_qmng.cpp b/tests/auto/mng/tst_qmng.cpp
new file mode 100644
index 0000000..6db59fb
--- /dev/null
+++ b/tests/auto/mng/tst_qmng.cpp
@@ -0,0 +1,104 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtAddOn.JsonDb module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtTest/QtTest>
+#include <QtGui/QtGui>
+
+class tst_qmng: public QObject
+{
+    Q_OBJECT
+
+private slots:
+    void readImage_data();
+    void readImage();
+    void readCorruptImage_data();
+    void readCorruptImage();
+};
+
+void tst_qmng::readImage_data()
+{
+    QTest::addColumn<QString>("fileName");
+    QTest::addColumn<QSize>("size");
+
+    QTest::newRow("animation") << QString("animation.mng") << QSize(100, 100);
+    QTest::newRow("ball") << QString("ball.mng") << QSize(32, 32);
+    QTest::newRow("dutch") << QString("dutch.mng") << QSize(352, 264);
+    QTest::newRow("fire") << QString("fire.mng") << QSize(30, 60);
+}
+
+void tst_qmng::readImage()
+{
+    QFETCH(QString, fileName);
+    QFETCH(QSize, size);
+
+    QString path = QString(":/mng/") + fileName;
+    QImageReader reader(path);
+    QVERIFY(reader.canRead());
+    QImage image = reader.read();
+    QVERIFY(!image.isNull());
+    QCOMPARE(image.size(), size);
+}
+
+void tst_qmng::readCorruptImage_data()
+{
+    QTest::addColumn<QString>("fileName");
+    QTest::addColumn<QString>("message");
+
+    QTest::newRow("corrupt")
+            << QString("corrupt.mng")
+            << QString("MNG error 901: Application signalled I/O error; chunk IHDR; subcode 0:0");
+}
+
+void tst_qmng::readCorruptImage()
+{
+    QFETCH(QString, fileName);
+    QFETCH(QString, message);
+
+    QString path = QString(":/mng/") + fileName;
+    QImageReader reader(path);
+    if (!message.isEmpty())
+        QTest::ignoreMessage(QtWarningMsg, message.toLatin1());
+    QVERIFY(reader.canRead());
+    QImage image = reader.read();
+    QVERIFY(image.isNull());
+}
+
+QTEST_MAIN(tst_qmng)
+#include "tst_qmng.moc"
diff --git a/tests/benchmarks/benchmarks.pro b/tests/benchmarks/benchmarks.pro
new file mode 100644
index 0000000..bd41748
--- /dev/null
+++ b/tests/benchmarks/benchmarks.pro
@@ -0,0 +1,3 @@
+TEMPLATE = subdirs
+SUBDIRS = \
+    mng
diff --git a/tests/benchmarks/mng/mng.pro b/tests/benchmarks/mng/mng.pro
new file mode 100644
index 0000000..13b0bbf
--- /dev/null
+++ b/tests/benchmarks/mng/mng.pro
@@ -0,0 +1,10 @@
+TEMPLATE = app
+TARGET = tst_bench_qmng
+DEPENDPATH += .
+INCLUDEPATH += .
+
+QT = core gui testlib
+CONFIG -= app_bundle
+
+SOURCES += tst_qmng.cpp
+RESOURCES += $$PWD/../../shared/images/mng.qrc
diff --git a/tests/benchmarks/mng/tst_qmng.cpp b/tests/benchmarks/mng/tst_qmng.cpp
new file mode 100644
index 0000000..0b3e3bd
--- /dev/null
+++ b/tests/benchmarks/mng/tst_qmng.cpp
@@ -0,0 +1,108 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** All rights reserved.
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtAddOn.JsonDb module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+#include <QtTest/QtTest>
+#include <QtGui/QtGui>
+
+class tst_qmng: public QObject
+{
+    Q_OBJECT
+
+private slots:
+    void readImage_data();
+    void readImage();
+    void readCorruptImage_data();
+    void readCorruptImage();
+};
+
+void tst_qmng::readImage_data()
+{
+    QTest::addColumn<QString>("fileName");
+    QTest::addColumn<QSize>("size");
+
+    QTest::newRow("animation") << QString("animation.mng") << QSize(100, 100);
+    QTest::newRow("ball") << QString("ball.mng") << QSize(32, 32);
+    QTest::newRow("dutch") << QString("dutch.mng") << QSize(352, 264);
+    QTest::newRow("fire") << QString("fire.mng") << QSize(30, 60);
+}
+
+void tst_qmng::readImage()
+{
+    QFETCH(QString, fileName);
+    QFETCH(QSize, size);
+
+    QString path = QString(":/mng/") + fileName;
+    QBENCHMARK {
+        QImageReader reader(path);
+        QVERIFY(reader.canRead());
+        QImage image = reader.read();
+        QVERIFY(!image.isNull());
+        QCOMPARE(image.size(), size);
+    }
+}
+
+void tst_qmng::readCorruptImage_data()
+{
+    QTest::addColumn<QString>("fileName");
+    QTest::addColumn<QString>("message");
+
+    QTest::newRow("corrupt")
+            << QString("corrupt.mng")
+            << QString("MNG error 901: Application signalled I/O error; chunk IHDR; subcode 0:0");
+}
+
+void tst_qmng::readCorruptImage()
+{
+    QFETCH(QString, fileName);
+    QFETCH(QString, message);
+
+    QString path = QString(":/mng/") + fileName;
+    QBENCHMARK {
+        QImageReader reader(path);
+        if (!message.isEmpty())
+            QTest::ignoreMessage(QtWarningMsg, message.toLatin1());
+        QVERIFY(reader.canRead());
+        QImage image = reader.read();
+        QVERIFY(image.isNull());
+    }
+}
+
+QTEST_MAIN(tst_qmng)
+#include "tst_qmng.moc"
diff --git a/tests/shared/images/mng.qrc b/tests/shared/images/mng.qrc
new file mode 100644
index 0000000..8bca94e
--- /dev/null
+++ b/tests/shared/images/mng.qrc
@@ -0,0 +1,9 @@
+<RCC>
+    <qresource prefix="/">
+        <file>mng/animation.mng</file>
+        <file>mng/ball.mng</file>
+        <file>mng/corrupt.mng</file>
+        <file>mng/fire.mng</file>
+        <file>mng/dutch.mng</file>
+    </qresource>
+</RCC>
diff --git a/tests/shared/images/mng/animation.mng b/tests/shared/images/mng/animation.mng
new file mode 100644
index 0000000..12b688a
Binary files /dev/null and b/tests/shared/images/mng/animation.mng differ
diff --git a/tests/shared/images/mng/ball.mng b/tests/shared/images/mng/ball.mng
new file mode 100644
index 0000000..8154478
Binary files /dev/null and b/tests/shared/images/mng/ball.mng differ
diff --git a/tests/shared/images/mng/corrupt.mng b/tests/shared/images/mng/corrupt.mng
new file mode 100644
index 0000000..17fd43a
Binary files /dev/null and b/tests/shared/images/mng/corrupt.mng differ
diff --git a/tests/shared/images/mng/dutch.mng b/tests/shared/images/mng/dutch.mng
new file mode 100644
index 0000000..4917fde
Binary files /dev/null and b/tests/shared/images/mng/dutch.mng differ
diff --git a/tests/shared/images/mng/fire.mng b/tests/shared/images/mng/fire.mng
new file mode 100644
index 0000000..c6695c8
Binary files /dev/null and b/tests/shared/images/mng/fire.mng differ
diff --git a/tests/tests.pro b/tests/tests.pro
new file mode 100644
index 0000000..6b6bdac
--- /dev/null
+++ b/tests/tests.pro
@@ -0,0 +1,2 @@
+TEMPLATE = subdirs
+SUBDIRS = auto benchmarks