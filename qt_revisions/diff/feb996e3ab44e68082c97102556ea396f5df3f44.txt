diff --git a/examples/quick/openglunderqml/main.qml b/examples/quick/openglunderqml/main.qml
index 174bb26..66bc08b 100644
--- a/examples/quick/openglunderqml/main.qml
+++ b/examples/quick/openglunderqml/main.qml
@@ -71,7 +71,7 @@ Item {
         id: label
         color: "black"
         wrapMode: Text.WordWrap
-        text: "The background here is a squircle rendered with raw OpenGL using the 'beforeRender()' signal in QQuickCanvas. This text label and its border is rendered using QML"
+        text: "The background here is a squircle rendered with raw OpenGL using the 'beforeRender()' signal in QQuickWindow. This text label and its border is rendered using QML"
         anchors.right: parent.right
         anchors.left: parent.left
         anchors.bottom: parent.bottom
diff --git a/examples/quick/openglunderqml/squircle.cpp b/examples/quick/openglunderqml/squircle.cpp
index c25e28c..b134068 100644
--- a/examples/quick/openglunderqml/squircle.cpp
+++ b/examples/quick/openglunderqml/squircle.cpp
@@ -41,7 +41,7 @@
 
 #include "squircle.h"
 
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 #include <QOpenGLShaderProgram>
 
 Squircle::Squircle()
@@ -52,9 +52,9 @@ Squircle::Squircle()
 
 void Squircle::itemChange(ItemChange change, const ItemChangeData &)
 {
-    // The ItemSceneChange event is sent when we are first attached to a canvas.
+    // The ItemSceneChange event is sent when we are first attached to a window.
     if (change == ItemSceneChange) {
-        QQuickCanvas *c = canvas();
+        QQuickWindow *c = window();
 
         // Connect our the beforeRendering signal to our paint function.
         // Since this call is executed on the rendering thread it must be
@@ -104,7 +104,7 @@ void Squircle::paint()
     m_program->setAttributeArray(0, GL_FLOAT, values, 2);
     m_program->setUniformValue("t", (float) m_t);
 
-    glViewport(0, 0, canvas()->width(), canvas()->height());
+    glViewport(0, 0, window()->width(), window()->height());
 
     glDisable(GL_DEPTH_TEST);
 
diff --git a/src/particles/qquickcustomparticle.cpp b/src/particles/qquickcustomparticle.cpp
index 777237a..31b95c4 100644
--- a/src/particles/qquickcustomparticle.cpp
+++ b/src/particles/qquickcustomparticle.cpp
@@ -466,7 +466,7 @@ void QQuickCustomParticle::commit(int gIdx, int pIdx)
 void QQuickCustomParticle::itemChange(ItemChange change, const ItemChangeData &value)
 {
     if (change == QQuickItem::ItemSceneChange)
-        m_common.updateCanvas(value.canvas);
+        m_common.updateWindow(value.window);
     QQuickParticlePainter::itemChange(change, value);
 }
 
diff --git a/src/particles/qquickparticlepainter.cpp b/src/particles/qquickparticlepainter.cpp
index dcdbc59..c27500c 100644
--- a/src/particles/qquickparticlepainter.cpp
+++ b/src/particles/qquickparticlepainter.cpp
@@ -40,7 +40,7 @@
 ****************************************************************************/
 
 #include "qquickparticlepainter_p.h"
-#include <QQuickCanvas>
+#include <QQuickWindow>
 #include <QDebug>
 QT_BEGIN_NAMESPACE
 /*!
@@ -67,18 +67,18 @@ QT_BEGIN_NAMESPACE
 */
 QQuickParticlePainter::QQuickParticlePainter(QQuickItem *parent) :
     QQuickItem(parent),
-    m_system(0), m_count(0), m_pleaseReset(true), m_canvas(0)
+    m_system(0), m_count(0), m_pleaseReset(true), m_window(0)
 {
 }
 
 void QQuickParticlePainter::itemChange(ItemChange change, const ItemChangeData &data)
 {
     if (change == QQuickItem::ItemSceneChange) {
-        if (m_canvas)
-            disconnect(m_canvas, SIGNAL(sceneGraphInvalidated()), this, SLOT(sceneGraphInvalidated()));
-        m_canvas = data.canvas;
-        if (m_canvas)
-            connect(m_canvas, SIGNAL(sceneGraphInvalidated()), this, SLOT(sceneGraphInvalidated()), Qt::DirectConnection);
+        if (m_window)
+            disconnect(m_window, SIGNAL(sceneGraphInvalidated()), this, SLOT(sceneGraphInvalidated()));
+        m_window = data.window;
+        if (m_window)
+            connect(m_window, SIGNAL(sceneGraphInvalidated()), this, SLOT(sceneGraphInvalidated()), Qt::DirectConnection);
 
     }
 }
diff --git a/src/particles/qquickparticlepainter_p.h b/src/particles/qquickparticlepainter_p.h
index 1ae4625..af10e9f 100644
--- a/src/particles/qquickparticlepainter_p.h
+++ b/src/particles/qquickparticlepainter_p.h
@@ -126,7 +126,7 @@ protected:
     QStringList m_groups;
     QPointF m_systemOffset;
 
-    QQuickCanvas *m_canvas;
+    QQuickWindow *m_window;
 
 private:
     QSet<QPair<int,int> > m_pendingCommits;
diff --git a/src/plugins/accessible/quick/qaccessiblequickitem.cpp b/src/plugins/accessible/quick/qaccessiblequickitem.cpp
index c5a45e2..c1307bb 100644
--- a/src/plugins/accessible/quick/qaccessiblequickitem.cpp
+++ b/src/plugins/accessible/quick/qaccessiblequickitem.cpp
@@ -70,14 +70,14 @@ QRect QAccessibleQuickItem::rect() const
 
 QRect QAccessibleQuickItem::viewRect() const
 {
-    // ### no canvas in some cases.
-    if (!item()->canvas()) {
+    // ### no window in some cases.
+    if (!item()->window()) {
         return QRect();
     }
 
-    QQuickCanvas *canvas = item()->canvas();
-    QPoint screenPos = canvas->mapToGlobal(QPoint(0,0));
-    return QRect(screenPos, canvas->size());
+    QQuickWindow *window = item()->window();
+    QPoint screenPos = window->mapToGlobal(QPoint(0,0));
+    return QRect(screenPos, window->size());
 }
 
 
@@ -91,14 +91,14 @@ QAccessibleInterface *QAccessibleQuickItem::parent() const
 {
     QQuickItem *parent = item()->parentItem();
     if (parent) {
-        QQuickCanvas *canvas = item()->canvas();
+        QQuickWindow *window = item()->window();
         // Jump out to the scene widget if the parent is the root item.
-        // There are two root items, QQuickCanvas::rootItem and
+        // There are two root items, QQuickWindow::rootItem and
         // QQuickView::declarativeRoot. The former is the true root item,
         // but is not a part of the accessibility tree. Check if we hit
         // it here and return an interface for the scene instead.
-        if (canvas && (parent == canvas->rootItem())) {
-            return QAccessible::queryAccessibleInterface(canvas);
+        if (window && (parent == window->contentItem())) {
+            return QAccessible::queryAccessibleInterface(window);
         } else {
             return QAccessible::queryAccessibleInterface(parent);
         }
@@ -154,7 +154,7 @@ QAccessible::State QAccessibleQuickItem::state() const
     if (item()->hasActiveFocus())
         state.focused = true;
 
-    if (!item()->canvas() ||!item()->isVisible() || qFuzzyIsNull(item()->opacity()))
+    if (!item()->window() ||!item()->isVisible() || qFuzzyIsNull(item()->opacity()))
         state.invisible = true;
 
     QAccessible::Role r = role();
@@ -274,9 +274,9 @@ QVariant QAccessibleQuickItemValueInterface::minimumValue() const
 */
 QRect itemScreenRect(QQuickItem *item)
 {
-    // ### no canvas in some cases.
+    // ### no window in some cases.
     // ### Should we really check for 0 opacity?
-    if (!item->canvas() ||!item->isVisible() || qFuzzyIsNull(item->opacity())) {
+    if (!item->window() ||!item->isVisible() || qFuzzyIsNull(item->opacity())) {
         return QRect();
     }
 
@@ -291,7 +291,7 @@ QRect itemScreenRect(QQuickItem *item)
     }
 
     QPointF scenePoint = item->mapToScene(QPointF(0, 0));
-    QPoint screenPos = item->canvas()->mapToGlobal(scenePoint.toPoint());
+    QPoint screenPos = item->window()->mapToGlobal(scenePoint.toPoint());
     return QRect(screenPos, itemSize);
 }
 
diff --git a/src/plugins/qmltooling/qmldbg_qtquick2/highlight.cpp b/src/plugins/qmltooling/qmldbg_qtquick2/highlight.cpp
index a2ec34e..a8fcace 100644
--- a/src/plugins/qmltooling/qmldbg_qtquick2/highlight.cpp
+++ b/src/plugins/qmltooling/qmldbg_qtquick2/highlight.cpp
@@ -44,7 +44,7 @@
 #include <QtCore/QTimer>
 #include <QtGui/QPainter>
 #include <QtGui/QStaticText>
-#include <QtQuick/QQuickCanvas>
+#include <QtQuick/QQuickWindow>
 
 namespace QmlJSDebugger {
 namespace QtQuick2 {
@@ -81,7 +81,7 @@ void Highlight::setItem(QQuickItem *item)
         connect(item, SIGNAL(transformOriginChanged(TransformOrigin)),
                 SLOT(adjust()));
     }
-    QQuickCanvas *view = item->canvas();
+    QQuickWindow *view = item->window();
     QQuickItem * rootItem = view->rootItem();
     if (rootItem) {
         connect(rootItem, SIGNAL(xChanged()), SLOT(adjust()));
@@ -110,7 +110,7 @@ void Highlight::adjust()
     setSize(QSizeF(m_item->width(), m_item->height()));
     qreal scaleFactor = 1;
     QPointF originOffset = QPointF(0,0);
-    QQuickCanvas *view = m_item->canvas();
+    QQuickWindow *view = m_item->window();
     if (view->rootItem()) {
         scaleFactor = view->rootItem()->scale();
         originOffset -= view->rootItem()->pos();
diff --git a/src/qml/doc/src/cppclasses/component.qdoc b/src/qml/doc/src/cppclasses/component.qdoc
index cc4f6b5..8eb2228 100644
--- a/src/qml/doc/src/cppclasses/component.qdoc
+++ b/src/qml/doc/src/cppclasses/component.qdoc
@@ -34,7 +34,7 @@
     A QML document can be loaded with QQmlComponent or QQuickView.
     QQmlComponent loads a QML component as a C++ QObject;
     QQuickView also does this, but additionally loads the QML component
-    directly into a QQuickCanvas which displays visual QML object types
+    directly into a QQuickWindow which displays visual QML object types
     provided by Qt Quick, or object types derived from those.
     It is convenient for loading a displayable
     QML component as a root QWindow.
diff --git a/src/qml/doc/src/documents/networktransparency.qdoc b/src/qml/doc/src/documents/networktransparency.qdoc
index dd83813..b3ded04 100644
--- a/src/qml/doc/src/documents/networktransparency.qdoc
+++ b/src/qml/doc/src/documents/networktransparency.qdoc
@@ -93,8 +93,8 @@ the executable using \l{The Qt Resource System}. Using this, an executable can r
 that is compiled into the executable:
 
 \code
-    QQuickView *canvas = new QQuickView;
-    canvas->setUrl(QUrl("qrc:/dial.qml"));
+    QQuickView *view = new QQuickView;
+    view->setUrl(QUrl("qrc:/dial.qml"));
 \endcode
 
 The content itself can then use relative URLs, and so be transparently unaware that the content is
diff --git a/src/qmltest/quicktestevent.cpp b/src/qmltest/quicktestevent.cpp
index 0bbf097..a40aae8 100644
--- a/src/qmltest/quicktestevent.cpp
+++ b/src/qmltest/quicktestevent.cpp
@@ -43,7 +43,7 @@
 #include <QtTest/qtestkeyboard.h>
 #include <QtQml/qqml.h>
 #include <QtQuick/qquickitem.h>
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -259,7 +259,7 @@ QWindow *QuickTestEvent::eventWindow()
 {
     QQuickItem *sgitem = qobject_cast<QQuickItem *>(parent());
     if (sgitem)
-        return sgitem->canvas();
+        return sgitem->window();
     return 0;
 }
 
diff --git a/src/qmltest/quicktestresult.cpp b/src/qmltest/quicktestresult.cpp
index 94f45c4..ff2cf05 100644
--- a/src/qmltest/quicktestresult.cpp
+++ b/src/qmltest/quicktestresult.cpp
@@ -55,7 +55,7 @@
 #include <QtCore/qdebug.h>
 #include <QtCore/QUrl>
 #include <QtCore/QDir>
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -589,8 +589,8 @@ void QuickTestResult::stopBenchmark()
 QObject *QuickTestResult::grabImage(QQuickItem *item)
 {
     if (item) {
-        QQuickCanvas *canvas = item->canvas();
-        QImage grabbed = canvas->grabFrameBuffer();
+        QQuickWindow *window = item->window();
+        QImage grabbed = window->grabWindow();
         QRectF rf(item->x(), item->y(), item->width(), item->height());
         rf = rf.intersected(QRectF(0, 0, grabbed.width(), grabbed.height()));
         return new QuickTestImageObject(grabbed.copy(rf.toAlignedRect()));
diff --git a/src/quick/designer/designersupport.cpp b/src/quick/designer/designersupport.cpp
index 006843a..e8e26f7 100644
--- a/src/quick/designer/designersupport.cpp
+++ b/src/quick/designer/designersupport.cpp
@@ -73,7 +73,7 @@ void DesignerSupport::refFromEffectItem(QQuickItem *referencedItem, bool hide)
         return;
 
     QQuickItemPrivate::get(referencedItem)->refFromEffectItem(hide);
-    QQuickCanvasPrivate::get(referencedItem->canvas())->updateDirtyNode(referencedItem);
+    QQuickWindowPrivate::get(referencedItem->window())->updateDirtyNode(referencedItem);
 
     Q_ASSERT(QQuickItemPrivate::get(referencedItem)->rootNode());
 
@@ -147,12 +147,12 @@ void DesignerSupport::resetDirty(QQuickItem *referencedItem)
     QQuickItemPrivate::get(referencedItem)->removeFromDirtyList();
 }
 
-QTransform DesignerSupport::canvasTransform(QQuickItem *referencedItem)
+QTransform DesignerSupport::windowTransform(QQuickItem *referencedItem)
 {
     if (referencedItem == 0)
         return QTransform();
 
-    return QQuickItemPrivate::get(referencedItem)->itemToCanvasTransform();
+    return QQuickItemPrivate::get(referencedItem)->itemToWindowTransform();
 }
 
 QTransform DesignerSupport::parentTransform(QQuickItem *referencedItem)
@@ -404,7 +404,7 @@ bool DesignerSupport::isValidHeight(QQuickItem *item)
 
 void DesignerSupport::updateDirtyNode(QQuickItem *item)
 {
-    QQuickCanvasPrivate::get(item->canvas())->updateDirtyNode(item);
+    QQuickWindowPrivate::get(item->window())->updateDirtyNode(item);
 }
 
 QT_END_NAMESPACE
diff --git a/src/quick/designer/designersupport.h b/src/quick/designer/designersupport.h
index 54003cf..df87a77 100644
--- a/src/quick/designer/designersupport.h
+++ b/src/quick/designer/designersupport.h
@@ -90,16 +90,16 @@ public:
         ParentChanged           = 0x00000800,
 
         Clip                    = 0x00001000,
-        Canvas                  = 0x00002000,
+        Window                  = 0x00002000,
 
         EffectReference         = 0x00008000,
         Visible                 = 0x00010000,
         HideReference           = 0x00020000,
 
-        TransformUpdateMask     = TransformOrigin | Transform | BasicTransform | Position | Size | Canvas,
-        ComplexTransformUpdateMask     = Transform | Canvas,
-        ContentUpdateMask       = Size | Content | Smooth | Canvas,
-        ChildrenUpdateMask      = ChildrenChanged | ChildrenStackingChanged | EffectReference | Canvas
+        TransformUpdateMask     = TransformOrigin | Transform | BasicTransform | Position | Size | Window,
+        ComplexTransformUpdateMask     = Transform | Window,
+        ContentUpdateMask       = Size | Content | Smooth | Window,
+        ChildrenUpdateMask      = ChildrenChanged | ChildrenStackingChanged | EffectReference | Window
     };
 
 
@@ -114,7 +114,7 @@ public:
     static bool isDirty(QQuickItem *referencedItem, DirtyType dirtyType);
     static void resetDirty(QQuickItem *referencedItem);
 
-    static QTransform canvasTransform(QQuickItem *referencedItem);
+    static QTransform windowTransform(QQuickItem *referencedItem);
     static QTransform parentTransform(QQuickItem *referencedItem);
 
     static bool isAnchoredTo(QQuickItem *fromItem, QQuickItem *toItem);
diff --git a/src/quick/doc/src/appdevguide/porting.qdoc b/src/quick/doc/src/appdevguide/porting.qdoc
index 44afd4d..2f27880 100644
--- a/src/quick/doc/src/appdevguide/porting.qdoc
+++ b/src/quick/doc/src/appdevguide/porting.qdoc
@@ -160,7 +160,7 @@ a convenient way to port QDeclarativeItem-based classes that use the QPainter AP
 is less performant than using the \c QSG* classes.
 
 When porting from QDeclarativeView to QQuickView, note that QDeclarativeItem inherited from
-QGraphicsView. In contrast, QQuickView inherits from QQuickCanvas and uses the QWindow
+QGraphicsView. In contrast, QQuickView inherits from QQuickWindow and uses the QWindow
 infrastructure introduced in Qt 5; any QGraphicsView-specific functionality is no longer available.
 
 
diff --git a/src/quick/doc/src/concepts/visualcanvas/scenegraph.qdoc b/src/quick/doc/src/concepts/visualcanvas/scenegraph.qdoc
index d74510b..9f78403 100644
--- a/src/quick/doc/src/concepts/visualcanvas/scenegraph.qdoc
+++ b/src/quick/doc/src/concepts/visualcanvas/scenegraph.qdoc
@@ -51,7 +51,7 @@ batch rendering to minimize state changes and discarding obscured primitives.
 
 The scene graph is closely tied to QML and can not be used as
 stand-alone. The scene graph is managed and rendered by the
-QQuickCanvas class and custom QML elements will add their graphical
+QQuickWindow class and custom QML elements will add their graphical
 primitives into the scene graph through a call to
 QQuickItem::updatePaintNode().
 
@@ -96,7 +96,7 @@ the rendering, such as the shared root for a subtree of geometry nodes.
 \section1 Rendering
 
 The rendering of the scene graph happens internally in the
-QQuickCanvas class and is described under the \l{Scene Graph and
+QQuickWindow class and is described under the \l{Scene Graph and
 Rendering} section.
 
 How to integrate QPainter based graphics is explained in \l{Custom
@@ -115,7 +115,7 @@ It includes:
 \list
 
 \li Custom textures; specifically the implementation of
-QQuickCanvas::createTextureFromImage and the internal representation
+QQuickWindow::createTextureFromImage and the internal representation
 of the texture used by \l Image and \l BorderImage elements.
 
 \li Custom renderer; the adaptation layer lets the plugin decide how
diff --git a/src/quick/doc/src/whatsnew.qdoc b/src/quick/doc/src/whatsnew.qdoc
index 19e1033..1b2a27e 100644
--- a/src/quick/doc/src/whatsnew.qdoc
+++ b/src/quick/doc/src/whatsnew.qdoc
@@ -45,8 +45,8 @@ canvas from C++:
 
 \list
 \li QQuickItem - the base visual QML type (replaces \c QDeclarativeItem)
-\li QQuickView - a window for rendering a QML scene from a QML file (replaces \c QDeclarativeView)
-\li QQuickCanvas - a base canvas for displaying a QML scene
+\li QQuickView - a convenience window for rendering a QML scene from a QML file (replaces \c QDeclarativeView)
+\li QQuickWindow - a base window for displaying a QML scene
 \li QQuickPaintedItem - convenience for using the QPainter API with the scenegraph
 \li QQuickImageProvider - fetches custom images for use in QML applications (replaces \c
     QDeclarativeImageProvider)
diff --git a/src/quick/items/context2d/qquickcanvasitem.cpp b/src/quick/items/context2d/qquickcanvasitem.cpp
index f66b383..47c8b4f 100644
--- a/src/quick/items/context2d/qquickcanvasitem.cpp
+++ b/src/quick/items/context2d/qquickcanvasitem.cpp
@@ -53,19 +53,19 @@
 
 QT_BEGIN_NAMESPACE
 
-QQuickCanvasPixmap::QQuickCanvasPixmap(const QImage& image, QQuickCanvas *canvas)
+QQuickCanvasPixmap::QQuickCanvasPixmap(const QImage& image, QQuickWindow *window)
     : m_pixmap(0)
     , m_image(image)
     , m_texture(0)
-    , m_canvas(canvas)
+    , m_window(window)
 {
 
 }
 
-QQuickCanvasPixmap::QQuickCanvasPixmap(QQuickPixmap *pixmap, QQuickCanvas *canvas)
+QQuickCanvasPixmap::QQuickCanvasPixmap(QQuickPixmap *pixmap, QQuickWindow *window)
     : m_pixmap(pixmap)
     , m_texture(0)
-    , m_canvas(canvas)
+    , m_window(window)
 {
 
 }
@@ -105,9 +105,9 @@ QSGTexture *QQuickCanvasPixmap::texture()
     if (!m_texture) {
         if (m_pixmap) {
             Q_ASSERT(m_pixmap->textureFactory());
-            m_texture = m_pixmap->textureFactory()->createTexture(m_canvas);
+            m_texture = m_pixmap->textureFactory()->createTexture(m_window);
         } else {
-            m_texture = QQuickCanvasPrivate::get(m_canvas)->context->createTexture(m_image);
+            m_texture = QQuickWindowPrivate::get(m_window)->context->createTexture(m_image);
         }
     }
     return m_texture;
@@ -620,14 +620,14 @@ void QQuickCanvasItem::itemChange(QQuickItem::ItemChange change, const QQuickIte
     if (d->available)
         return;
 
-    if (value.canvas == 0)
+    if (value.window== 0)
         return;
 
-    d->canvas = value.canvas;
-    if (d->canvas->openglContext() != 0) // available context == initialized
+    d->window = value.window;
+    if (d->window->openglContext() != 0) // available context == initialized
         sceneGraphInitialized();
     else
-        connect(d->canvas, SIGNAL(sceneGraphInitialized()), SLOT(sceneGraphInitialized()));
+        connect(d->window, SIGNAL(sceneGraphInitialized()), SLOT(sceneGraphInitialized()));
 }
 
 void QQuickCanvasItem::updatePolish()
@@ -881,7 +881,7 @@ void QQuickCanvasItem::loadImage(const QUrl& url)
     if (!d->pixmaps.contains(fullPathUrl)) {
         QQuickPixmap* pix = new QQuickPixmap();
         QQmlRefPointer<QQuickCanvasPixmap> canvasPix;
-        canvasPix.take(new QQuickCanvasPixmap(pix, d->canvas));
+        canvasPix.take(new QQuickCanvasPixmap(pix, d->window));
         d->pixmaps.insert(fullPathUrl, canvasPix);
 
         pix->load(qmlEngine(this)
diff --git a/src/quick/items/context2d/qquickcanvasitem_p.h b/src/quick/items/context2d/qquickcanvasitem_p.h
index 090c763..4e592bc 100644
--- a/src/quick/items/context2d/qquickcanvasitem_p.h
+++ b/src/quick/items/context2d/qquickcanvasitem_p.h
@@ -60,8 +60,8 @@ class QQuickPixmap;
 class QQuickCanvasPixmap : public QQmlRefCount
 {
 public:
-    QQuickCanvasPixmap(const QImage& image, QQuickCanvas *canvas);
-    QQuickCanvasPixmap(QQuickPixmap *pixmap, QQuickCanvas *canvas);
+    QQuickCanvasPixmap(const QImage& image, QQuickWindow *window);
+    QQuickCanvasPixmap(QQuickPixmap *pixmap, QQuickWindow *window);
     ~QQuickCanvasPixmap();
 
     QSGTexture *texture();
@@ -76,7 +76,7 @@ private:
     QQuickPixmap *m_pixmap;
     QImage m_image;
     QSGTexture *m_texture;
-    QQuickCanvas *m_canvas;
+    QQuickWindow *m_window;
 };
 
 class QQuickCanvasItem : public QQuickItem
@@ -209,4 +209,4 @@ QML_DECLARE_TYPE(QQuickCanvasItem)
 
 QT_END_HEADER
 
-#endif //QQUICKCANVASITEM_P_H
\ No newline at end of file
+#endif //QQUICKCANVASITEM_P_H
diff --git a/src/quick/items/context2d/qquickcontext2d.cpp b/src/quick/items/context2d/qquickcontext2d.cpp
index 76f795b..2a99a2e 100644
--- a/src/quick/items/context2d/qquickcontext2d.cpp
+++ b/src/quick/items/context2d/qquickcontext2d.cpp
@@ -61,7 +61,7 @@
 #include <qqmlengine.h>
 #include <private/qv8domerrors_p.h>
 #include <QtCore/qnumeric.h>
-#include <private/qquickcanvas_p.h>
+#include <private/qquickwindow_p.h>
 #include <private/qquickwindowmanager_p.h>
 #include <QtGui/private/qguiapplication_p.h>
 #include <qpa/qplatformintegration.h>
@@ -2331,13 +2331,13 @@ static v8::Handle<v8::Value> ctx2d_drawImage(const v8::Arguments &args)
 
         QV8Context2DPixelArrayResource *pix = v8_resource_cast<QV8Context2DPixelArrayResource>(args[0]->ToObject()->GetInternalField(0)->ToObject());
         if (pix && !pix->image.isNull()) {
-            pixmap.take(new QQuickCanvasPixmap(pix->image, r->context->canvas()->canvas()));
+            pixmap.take(new QQuickCanvasPixmap(pix->image, r->context->canvas()->window()));
         } else if (imageItem) {
             pixmap.take(r->context->createPixmap(imageItem->source()));
         } else if (canvas) {
             QImage img = canvas->toImage();
             if (!img.isNull())
-                pixmap.take(new QQuickCanvasPixmap(img, canvas->canvas()));
+                pixmap.take(new QQuickCanvasPixmap(img, canvas->window()));
         } else {
             V8THROW_DOM(DOMEXCEPTION_TYPE_MISMATCH_ERR, "drawImage(), type mismatch");
         }
@@ -3371,8 +3371,8 @@ void QQuickContext2D::init(QQuickCanvasItem *canvasItem, const QVariantMap &args
     m_canvas = canvasItem;
     m_renderTarget = canvasItem->renderTarget();
 
-    QQuickCanvas *canvas = canvasItem->canvas();
-    m_windowManager =  QQuickCanvasPrivate::get(canvas)->windowManager;
+    QQuickWindow *window = canvasItem->window();
+    m_windowManager =  QQuickWindowPrivate::get(window)->windowManager;
     m_renderStrategy = canvasItem->renderStrategy();
 
     switch (m_renderTarget) {
@@ -3396,7 +3396,7 @@ void QQuickContext2D::init(QQuickCanvasItem *canvasItem, const QVariantMap &args
     m_texture->setSmooth(canvasItem->smooth());
 
     QThread *renderThread = QThread::currentThread();
-    QThread *sceneGraphThread = canvas->openglContext() ? canvas->openglContext()->thread() : 0;
+    QThread *sceneGraphThread = window->openglContext() ? window->openglContext()->thread() : 0;
 
     if (m_renderStrategy == QQuickCanvasItem::Threaded)
         renderThread = QQuickContext2DRenderThread::instance(qmlEngine(canvasItem));
@@ -3404,8 +3404,8 @@ void QQuickContext2D::init(QQuickCanvasItem *canvasItem, const QVariantMap &args
         renderThread = sceneGraphThread;
 
     if (m_renderTarget == QQuickCanvasItem::FramebufferObject && renderThread != sceneGraphThread) {
-         QOpenGLContext *cc = QQuickCanvasPrivate::get(canvas)->context->glContext();
-         m_surface = canvas;
+         QOpenGLContext *cc = QQuickWindowPrivate::get(window)->context->glContext();
+         m_surface = window;
          m_glContext = new QOpenGLContext;
          m_glContext->setFormat(cc->format());
          m_glContext->setShareContext(cc);
diff --git a/src/quick/items/items.pri b/src/quick/items/items.pri
index 9f205ed..3130106 100644
--- a/src/quick/items/items.pri
+++ b/src/quick/items/items.pri
@@ -8,8 +8,9 @@ HEADERS += \
     $$PWD/qquickitemchangelistener_p.h \
     $$PWD/qquickrectangle_p.h \
     $$PWD/qquickrectangle_p_p.h \
+    $$PWD/qquickwindow.h \
+    $$PWD/qquickwindow_p.h \
     $$PWD/qquickcanvas.h \
-    $$PWD/qquickcanvas_p.h \
     $$PWD/qquickfocusscope_p.h \
     $$PWD/qquickitemsmodule_p.h \
     $$PWD/qquickpainteditem.h \
@@ -82,7 +83,7 @@ SOURCES += \
     $$PWD/qquickanchors.cpp \
     $$PWD/qquickitem.cpp \
     $$PWD/qquickrectangle.cpp \
-    $$PWD/qquickcanvas.cpp \
+    $$PWD/qquickwindow.cpp \
     $$PWD/qquickfocusscope.cpp \
     $$PWD/qquickitemsmodule.cpp \
     $$PWD/qquickpainteditem.cpp \
diff --git a/src/quick/items/qquickanimatedsprite.cpp b/src/quick/items/qquickanimatedsprite.cpp
index a243947..8fa4acc 100644
--- a/src/quick/items/qquickanimatedsprite.cpp
+++ b/src/quick/items/qquickanimatedsprite.cpp
@@ -48,7 +48,7 @@
 #include <QtQuick/qsgnode.h>
 #include <QtQuick/qsgtexturematerial.h>
 #include <QtQuick/qsgtexture.h>
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 #include <QtQml/qqmlinfo.h>
 #include <QFile>
 #include <cmath>
@@ -516,7 +516,7 @@ QSGGeometryNode* QQuickAnimatedSprite::buildNode()
     if (image.isNull())
         return 0;
     m_sheetSize = QSizeF(image.size());
-    m_material->texture = canvas()->createTextureFromImage(image);
+    m_material->texture = window()->createTextureFromImage(image);
     m_material->texture->setFiltering(QSGTexture::Linear);
     m_spriteEngine->start(0);
     m_material->animT = 0;
diff --git a/src/quick/items/qquickborderimage.cpp b/src/quick/items/qquickborderimage.cpp
index 53ec729..a9f154b 100644
--- a/src/quick/items/qquickborderimage.cpp
+++ b/src/quick/items/qquickborderimage.cpp
@@ -557,7 +557,7 @@ QSGNode *QQuickBorderImage::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeDat
 {
     Q_D(QQuickBorderImage);
 
-    QSGTexture *texture = d->sceneGraphContext()->textureForFactory(d->pix.textureFactory(), canvas());
+    QSGTexture *texture = d->sceneGraphContext()->textureForFactory(d->pix.textureFactory(), window());
 
     if (!texture || width() <= 0 || height() <= 0) {
         delete oldNode;
diff --git a/src/quick/items/qquickcanvas.cpp b/src/quick/items/qquickcanvas.cpp
deleted file mode 100644
index de53e80..0000000
--- a/src/quick/items/qquickcanvas.cpp
+++ /dev/null
@@ -1,2657 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qquickcanvas.h"
-#include "qquickcanvas_p.h"
-
-#include "qquickitem.h"
-#include "qquickitem_p.h"
-#include "qquickevents_p_p.h"
-
-#include <QtQuick/private/qsgrenderer_p.h>
-#include <QtQuick/private/qsgtexture_p.h>
-#include <QtQuick/private/qsgflashnode_p.h>
-
-#include <private/qquickwindowmanager_p.h>
-
-#include <private/qguiapplication_p.h>
-#include <QtGui/QInputMethod>
-
-#include <private/qabstractanimation_p.h>
-
-#include <QtGui/qpainter.h>
-#include <QtGui/qevent.h>
-#include <QtGui/qmatrix4x4.h>
-#include <QtGui/qstylehints.h>
-#include <QtCore/qvarlengtharray.h>
-#include <QtCore/qabstractanimation.h>
-#include <QtQml/qqmlincubator.h>
-
-#include <QtQuick/private/qquickpixmapcache_p.h>
-
-#include <private/qqmlprofilerservice_p.h>
-#include <private/qqmlmemoryprofiler_p.h>
-
-QT_BEGIN_NAMESPACE
-
-void QQuickCanvasPrivate::updateFocusItemTransform()
-{
-    Q_Q(QQuickCanvas);
-    QQuickItem *focus = q->activeFocusItem();
-    if (focus && qApp->focusObject() == focus)
-        qApp->inputMethod()->setInputItemTransform(QQuickItemPrivate::get(focus)->itemToCanvasTransform());
-}
-
-class QQuickCanvasIncubationController : public QObject, public QQmlIncubationController
-{
-public:
-    QQuickCanvasIncubationController(QQuickCanvasPrivate *canvas)
-    : m_canvas(canvas), m_eventSent(false) {}
-
-protected:
-    virtual bool event(QEvent *e)
-    {
-        if (e->type() == QEvent::User) {
-            Q_ASSERT(m_eventSent);
-            volatile bool *amtp = m_canvas->windowManager->allowMainThreadProcessing();
-            while (incubatingObjectCount()) {
-                if (amtp)
-                    incubateWhile(amtp, 2);
-                else
-                    incubateFor(5);
-                QCoreApplication::processEvents();
-            }
-
-            m_eventSent = false;
-        }
-        return QObject::event(e);
-    }
-
-    virtual void incubatingObjectCountChanged(int count)
-    {
-        if (count && !m_eventSent) {
-            m_eventSent = true;
-            QCoreApplication::postEvent(this, new QEvent(QEvent::User));
-        }
-        // If no animations are running, the renderer may be waiting
-        m_canvas->windowManager->wakeup();
-    }
-
-private:
-    QQuickCanvasPrivate *m_canvas;
-    bool m_eventSent;
-};
-
-#ifndef QT_NO_ACCESSIBILITY
-QAccessibleInterface *QQuickCanvas::accessibleRoot() const
-{
-    return QAccessible::queryAccessibleInterface(const_cast<QQuickCanvas*>(this));
-}
-#endif
-
-
-/*
-Focus behavior
-==============
-
-Prior to being added to a valid canvas items can set and clear focus with no
-effect.  Only once items are added to a canvas (by way of having a parent set that
-already belongs to a canvas) do the focus rules apply.  Focus goes back to
-having no effect if an item is removed from a canvas.
-
-When an item is moved into a new focus scope (either being added to a canvas
-for the first time, or having its parent changed), if the focus scope already has
-a scope focused item that takes precedence over the item being added.  Otherwise,
-the focus of the added tree is used.  In the case of of a tree of items being
-added to a canvas for the first time, which may have a conflicted focus state (two
-or more items in one scope having focus set), the same rule is applied item by item -
-thus the first item that has focus will get it (assuming the scope doesn't already
-have a scope focused item), and the other items will have their focus cleared.
-*/
-
-
-// #define FOCUS_DEBUG
-// #define MOUSE_DEBUG
-// #define TOUCH_DEBUG
-// #define DIRTY_DEBUG
-
-#ifdef FOCUS_DEBUG
-void printFocusTree(QQuickItem *item, QQuickItem *scope = 0, int depth = 1);
-#endif
-
-QQuickItem::UpdatePaintNodeData::UpdatePaintNodeData()
-: transformNode(0)
-{
-}
-
-QQuickRootItem::QQuickRootItem()
-{
-}
-
-/*! \reimp */
-void QQuickCanvas::exposeEvent(QExposeEvent *)
-{
-    Q_D(QQuickCanvas);
-    d->windowManager->exposureChanged(this);
-}
-
-/*! \reimp */
-void QQuickCanvas::resizeEvent(QResizeEvent *)
-{
-    Q_D(QQuickCanvas);
-    d->windowManager->resize(this, size());
-}
-
-/*! \reimp */
-void QQuickCanvas::showEvent(QShowEvent *)
-{
-    d_func()->windowManager->show(this);
-}
-
-/*! \reimp */
-void QQuickCanvas::hideEvent(QHideEvent *)
-{
-    d_func()->windowManager->hide(this);
-}
-
-/*! \reimp */
-void QQuickCanvas::focusOutEvent(QFocusEvent *)
-{
-    Q_D(QQuickCanvas);
-    d->rootItem->setFocus(false);
-}
-
-/*! \reimp */
-void QQuickCanvas::focusInEvent(QFocusEvent *)
-{
-    Q_D(QQuickCanvas);
-    d->rootItem->setFocus(true);
-    d->updateFocusItemTransform();
-}
-
-
-void QQuickCanvasPrivate::polishItems()
-{
-    int maxPolishCycles = 100000;
-
-    while (!itemsToPolish.isEmpty() && --maxPolishCycles > 0) {
-        QSet<QQuickItem *> itms = itemsToPolish;
-        itemsToPolish.clear();
-
-        for (QSet<QQuickItem *>::iterator it = itms.begin(); it != itms.end(); ++it) {
-            QQuickItem *item = *it;
-            QQuickItemPrivate::get(item)->polishScheduled = false;
-            item->updatePolish();
-        }
-    }
-
-    if (maxPolishCycles == 0)
-        qWarning("QQuickCanvas: possible QQuickItem::polish() loop");
-
-    updateFocusItemTransform();
-}
-
-/**
- * This parameter enables that this canvas can be rendered without
- * being shown on screen. This feature is very limited in what it supports.
- *
- * There needs to be another window actually showing that we can make current
- * to get a surface to make current AND for this feature to be useful
- * one needs to hook into beforeRender() and set the render tareget.
- *
- */
-void QQuickCanvasPrivate::setRenderWithoutShowing(bool render)
-{
-    if (render == renderWithoutShowing)
-        return;
-
-    Q_Q(QQuickCanvas);
-    renderWithoutShowing = render;
-
-    if (render)
-        windowManager->show(q);
-    else
-        windowManager->hide(q);
-}
-
-
-/*!
- * Schedules the canvas to render another frame.
- *
- * Calling QQuickCanvas::update() differs from QQuickItem::update() in that
- * it always triggers a repaint, regardless of changes in the underlying
- * scene graph or not.
- */
-void QQuickCanvas::update()
-{
-    Q_D(QQuickCanvas);
-    d->windowManager->update(this);
-}
-
-void forceUpdate(QQuickItem *item)
-{
-    if (item->flags() & QQuickItem::ItemHasContents)
-        item->update();
-    QQuickItemPrivate::get(item)->dirty(QQuickItemPrivate::ChildrenUpdateMask);
-
-    QList <QQuickItem *> items = item->childItems();
-    for (int i=0; i<items.size(); ++i)
-        forceUpdate(items.at(i));
-}
-
-void QQuickCanvasPrivate::syncSceneGraph()
-{
-    QML_MEMORY_SCOPE_STRING("SceneGraph");
-    Q_Q(QQuickCanvas);
-
-    emit q->beforeSynchronizing();
-    if (!renderer) {
-        forceUpdate(rootItem);
-
-        QSGRootNode *rootNode = new QSGRootNode;
-        rootNode->appendChildNode(QQuickItemPrivate::get(rootItem)->itemNode());
-        renderer = context->createRenderer();
-        renderer->setRootNode(rootNode);
-    }
-
-    updateDirtyNodes();
-
-    // Copy the current state of clearing from canvas into renderer.
-    renderer->setClearColor(clearColor);
-    QSGRenderer::ClearMode mode = QSGRenderer::ClearStencilBuffer | QSGRenderer::ClearDepthBuffer;
-    if (clearBeforeRendering)
-        mode |= QSGRenderer::ClearColorBuffer;
-    renderer->setClearMode(mode);
-}
-
-
-void QQuickCanvasPrivate::renderSceneGraph(const QSize &size)
-{
-    QML_MEMORY_SCOPE_STRING("SceneGraph");
-    Q_Q(QQuickCanvas);
-    emit q->beforeRendering();
-    int fboId = 0;
-    renderer->setDeviceRect(QRect(QPoint(0, 0), size));
-    if (renderTargetId) {
-        fboId = renderTargetId;
-        renderer->setViewportRect(QRect(QPoint(0, 0), renderTargetSize));
-    } else {
-        renderer->setViewportRect(QRect(QPoint(0, 0), size));
-    }
-    renderer->setProjectionMatrixToDeviceRect();
-
-    context->renderNextFrame(renderer, fboId);
-    emit q->afterRendering();
-}
-
-QQuickCanvasPrivate::QQuickCanvasPrivate()
-    : rootItem(0)
-    , activeFocusItem(0)
-    , mouseGrabberItem(0)
-    , touchMouseId(-1)
-    , touchMousePressTimestamp(0)
-    , renderWithoutShowing(false)
-    , dirtyItemList(0)
-    , context(0)
-    , renderer(0)
-    , windowManager(0)
-    , clearColor(Qt::white)
-    , clearBeforeRendering(true)
-    , persistentGLContext(false)
-    , persistentSceneGraph(false)
-    , lastWheelEventAccepted(false)
-    , renderTarget(0)
-    , renderTargetId(0)
-    , incubationController(0)
-{
-}
-
-QQuickCanvasPrivate::~QQuickCanvasPrivate()
-{
-}
-
-void QQuickCanvasPrivate::init(QQuickCanvas *c)
-{
-    q_ptr = c;
-
-    Q_Q(QQuickCanvas);
-
-    rootItem = new QQuickRootItem;
-    QQmlEngine::setObjectOwnership(rootItem, QQmlEngine::CppOwnership);
-    QQuickItemPrivate *rootItemPrivate = QQuickItemPrivate::get(rootItem);
-    rootItemPrivate->canvas = q;
-    rootItemPrivate->canvasRefCount = 1;
-    rootItemPrivate->flags |= QQuickItem::ItemIsFocusScope;
-
-    // In the absence of a focus in event on some platforms assume the window will
-    // be activated immediately and set focus on the rootItem
-    // ### Remove when QTBUG-22415 is resolved.
-    //It is important that this call happens after the rootItem has a canvas..
-    rootItem->setFocus(true);
-
-    windowManager = QQuickWindowManager::instance();
-    context = windowManager->sceneGraphContext();
-    q->setSurfaceType(QWindow::OpenGLSurface);
-    q->setFormat(context->defaultSurfaceFormat());
-
-    QObject::connect(context, SIGNAL(initialized()), q, SIGNAL(sceneGraphInitialized()), Qt::DirectConnection);
-    QObject::connect(context, SIGNAL(invalidated()), q, SIGNAL(sceneGraphInvalidated()), Qt::DirectConnection);
-    QObject::connect(context, SIGNAL(invalidated()), q, SLOT(cleanupSceneGraph()), Qt::DirectConnection);
-}
-
-QQmlListProperty<QObject> QQuickCanvasPrivate::data()
-{
-    initRootItem();
-    return QQuickItemPrivate::get(rootItem)->data();
-}
-
-void QQuickCanvasPrivate::initRootItem()
-{
-    Q_Q(QQuickCanvas);
-    q->connect(q, SIGNAL(widthChanged(int)),
-            rootItem, SLOT(setWidth(int)));
-    q->connect(q, SIGNAL(heightChanged(int)),
-            rootItem, SLOT(setHeight(int)));
-    rootItem->setWidth(q->width());
-    rootItem->setHeight(q->height());
-}
-
-static QMouseEvent *touchToMouseEvent(QEvent::Type type, const QTouchEvent::TouchPoint &p, QTouchEvent *event, QQuickItem *item, bool transformNeeded = true)
-{
-    // The touch point local position and velocity are not yet transformed.
-    QMouseEvent *me = new QMouseEvent(type, transformNeeded ? item->mapFromScene(p.scenePos()) : p.pos(), p.scenePos(), p.screenPos(),
-                                      Qt::LeftButton, Qt::LeftButton, event->modifiers());
-    me->setAccepted(true);
-    me->setTimestamp(event->timestamp());
-    QVector2D transformedVelocity = p.velocity();
-    if (transformNeeded) {
-        QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-        QMatrix4x4 transformMatrix(itemPrivate->canvasToItemTransform());
-        transformedVelocity = transformMatrix.mapVector(p.velocity()).toVector2D();
-    }
-    QGuiApplicationPrivate::setMouseEventCapsAndVelocity(me, event->device()->capabilities(), transformedVelocity);
-    return me;
-}
-
-bool QQuickCanvasPrivate::translateTouchToMouse(QQuickItem *item, QTouchEvent *event)
-{
-    Q_Q(QQuickCanvas);
-    // For each point, check if it is accepted, if not, try the next point.
-    // Any of the fingers can become the mouse one.
-    // This can happen because a mouse area might not accept an event at some point but another.
-    for (int i = 0; i < event->touchPoints().count(); ++i) {
-        const QTouchEvent::TouchPoint &p = event->touchPoints().at(i);
-        // A new touch point
-        if (touchMouseId == -1 && p.state() & Qt::TouchPointPressed) {
-            QPointF pos = item->mapFromScene(p.scenePos());
-
-            // probably redundant, we check bounds in the calling function (matchingNewPoints)
-            if (!item->contains(pos))
-                break;
-
-            bool doubleClick = event->timestamp() - touchMousePressTimestamp
-                            < static_cast<ulong>(qApp->styleHints()->mouseDoubleClickInterval());
-            touchMousePressTimestamp = event->timestamp();
-            // Store the id already here and restore it to -1 if the event does not get
-            // accepted. Cannot defer setting the new value because otherwise if the event
-            // handler spins the event loop all subsequent moves and releases get lost.
-            touchMouseId = p.id();
-            itemForTouchPointId[touchMouseId] = item;
-            QScopedPointer<QMouseEvent> mousePress(touchToMouseEvent(QEvent::MouseButtonPress, p, event, item));
-
-            // Send a single press and see if that's accepted
-            if (!mouseGrabberItem)
-                item->grabMouse();
-            item->grabTouchPoints(QVector<int>() << touchMouseId);
-
-            q->sendEvent(item, mousePress.data());
-            event->setAccepted(mousePress->isAccepted());
-            if (!mousePress->isAccepted()) {
-                touchMouseId = -1;
-                if (itemForTouchPointId.value(p.id()) == item)
-                    itemForTouchPointId.remove(p.id());
-
-                if (mouseGrabberItem == item)
-                    item->ungrabMouse();
-            }
-
-            if (doubleClick && mousePress->isAccepted()) {
-                touchMousePressTimestamp = 0;
-                QScopedPointer<QMouseEvent> mouseDoubleClick(touchToMouseEvent(QEvent::MouseButtonDblClick, p, event, item));
-                q->sendEvent(item, mouseDoubleClick.data());
-                event->setAccepted(mouseDoubleClick->isAccepted());
-                if (mouseDoubleClick->isAccepted()) {
-                    return true;
-                } else {
-                    touchMouseId = -1;
-                }
-            }
-            // The event was accepted, we are done.
-            if (mousePress->isAccepted())
-                return true;
-            // The event was not accepted but touchMouseId was set.
-            if (touchMouseId != -1)
-                return false;
-            // try the next point
-
-        // Touch point was there before and moved
-        } else if (p.id() == touchMouseId) {
-            if (p.state() & Qt::TouchPointMoved) {
-                if (mouseGrabberItem) {
-                    QScopedPointer<QMouseEvent> me(touchToMouseEvent(QEvent::MouseMove, p, event, mouseGrabberItem));
-                    q->sendEvent(mouseGrabberItem, me.data());
-                    event->setAccepted(me->isAccepted());
-                    if (me->isAccepted()) {
-                        itemForTouchPointId[p.id()] = mouseGrabberItem; // N.B. the mouseGrabberItem may be different after returning from sendEvent()
-                        return true;
-                    }
-                } else {
-                    // no grabber, check if we care about mouse hover
-                    // FIXME: this should only happen once, not recursively... I'll ignore it just ignore hover now.
-                    // hover for touch???
-                    QScopedPointer<QMouseEvent> me(touchToMouseEvent(QEvent::MouseMove, p, event, item));
-                    if (lastMousePosition.isNull())
-                        lastMousePosition = me->windowPos();
-                    QPointF last = lastMousePosition;
-                    lastMousePosition = me->windowPos();
-
-                    bool accepted = me->isAccepted();
-                    bool delivered = deliverHoverEvent(rootItem, me->windowPos(), last, me->modifiers(), accepted);
-                    if (!delivered) {
-                        //take care of any exits
-                        accepted = clearHover();
-                    }
-                    me->setAccepted(accepted);
-                    break;
-                }
-            } else if (p.state() & Qt::TouchPointReleased) {
-                // currently handled point was released
-                touchMouseId = -1;
-                if (mouseGrabberItem) {
-                    QScopedPointer<QMouseEvent> me(touchToMouseEvent(QEvent::MouseButtonRelease, p, event, mouseGrabberItem));
-                    q->sendEvent(mouseGrabberItem, me.data());
-                    if (mouseGrabberItem) // might have ungrabbed due to event
-                        mouseGrabberItem->ungrabMouse();
-                    return me->isAccepted();
-                }
-            }
-            break;
-        }
-    }
-    return false;
-}
-
-void QQuickCanvasPrivate::transformTouchPoints(QList<QTouchEvent::TouchPoint> &touchPoints, const QTransform &transform)
-{
-    QMatrix4x4 transformMatrix(transform);
-    for (int i=0; i<touchPoints.count(); i++) {
-        QTouchEvent::TouchPoint &touchPoint = touchPoints[i];
-        touchPoint.setRect(transform.mapRect(touchPoint.sceneRect()));
-        touchPoint.setStartPos(transform.map(touchPoint.startScenePos()));
-        touchPoint.setLastPos(transform.map(touchPoint.lastScenePos()));
-        touchPoint.setVelocity(transformMatrix.mapVector(touchPoint.velocity()).toVector2D());
-    }
-}
-
-
-/*!
-Translates the data in \a touchEvent to this canvas.  This method leaves the item local positions in
-\a touchEvent untouched (these are filled in later).
-*/
-void QQuickCanvasPrivate::translateTouchEvent(QTouchEvent *touchEvent)
-{
-    QList<QTouchEvent::TouchPoint> touchPoints = touchEvent->touchPoints();
-    for (int i = 0; i < touchPoints.count(); ++i) {
-        QTouchEvent::TouchPoint &touchPoint = touchPoints[i];
-
-        touchPoint.setScreenRect(touchPoint.sceneRect());
-        touchPoint.setStartScreenPos(touchPoint.startScenePos());
-        touchPoint.setLastScreenPos(touchPoint.lastScenePos());
-
-        touchPoint.setSceneRect(touchPoint.rect());
-        touchPoint.setStartScenePos(touchPoint.startPos());
-        touchPoint.setLastScenePos(touchPoint.lastPos());
-
-        if (i == 0)
-            lastMousePosition = touchPoint.pos().toPoint();
-    }
-    touchEvent->setTouchPoints(touchPoints);
-}
-
-void QQuickCanvasPrivate::setFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions options)
-{
-    Q_Q(QQuickCanvas);
-
-    Q_ASSERT(item);
-    Q_ASSERT(scope || item == rootItem);
-
-#ifdef FOCUS_DEBUG
-    qWarning() << "QQuickCanvasPrivate::setFocusInScope():";
-    qWarning() << "    scope:" << (QObject *)scope;
-    if (scope)
-        qWarning() << "    scopeSubFocusItem:" << (QObject *)QQuickItemPrivate::get(scope)->subFocusItem;
-    qWarning() << "    item:" << (QObject *)item;
-    qWarning() << "    activeFocusItem:" << (QObject *)activeFocusItem;
-#endif
-
-    QQuickItemPrivate *scopePrivate = scope ? QQuickItemPrivate::get(scope) : 0;
-    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-
-    QQuickItem *oldActiveFocusItem = 0;
-    QQuickItem *newActiveFocusItem = 0;
-
-    QVarLengthArray<QQuickItem *, 20> changed;
-
-    // Does this change the active focus?
-    if (item == rootItem || (scopePrivate->activeFocus && item->isEnabled())) {
-        oldActiveFocusItem = activeFocusItem;
-        newActiveFocusItem = item;
-        while (newActiveFocusItem->isFocusScope()
-               && newActiveFocusItem->scopedFocusItem()
-               && newActiveFocusItem->scopedFocusItem()->isEnabled()) {
-            newActiveFocusItem = newActiveFocusItem->scopedFocusItem();
-        }
-
-        if (oldActiveFocusItem) {
-#ifndef QT_NO_IM
-            qApp->inputMethod()->commit();
-#endif
-
-            activeFocusItem = 0;
-            QFocusEvent event(QEvent::FocusOut, Qt::OtherFocusReason);
-            q->sendEvent(oldActiveFocusItem, &event);
-
-            QQuickItem *afi = oldActiveFocusItem;
-            while (afi && afi != scope) {
-                if (QQuickItemPrivate::get(afi)->activeFocus) {
-                    QQuickItemPrivate::get(afi)->activeFocus = false;
-                    changed << afi;
-                }
-                afi = afi->parentItem();
-            }
-        }
-    }
-
-    if (item != rootItem && !(options & DontChangeSubFocusItem)) {
-        QQuickItem *oldSubFocusItem = scopePrivate->subFocusItem;
-        if (oldSubFocusItem) {
-            QQuickItemPrivate::get(oldSubFocusItem)->focus = false;
-            changed << oldSubFocusItem;
-        }
-
-        QQuickItemPrivate::get(item)->updateSubFocusItem(scope, true);
-    }
-
-    if (!(options & DontChangeFocusProperty)) {
-//        if (item != rootItem || QGuiApplication::focusWindow() == q) {    // QTBUG-22415
-            itemPrivate->focus = true;
-            changed << item;
-//        }
-    }
-
-    if (newActiveFocusItem && rootItem->hasFocus()) {
-        activeFocusItem = newActiveFocusItem;
-
-        QQuickItemPrivate::get(newActiveFocusItem)->activeFocus = true;
-        changed << newActiveFocusItem;
-
-        QQuickItem *afi = newActiveFocusItem->parentItem();
-        while (afi && afi != scope) {
-            if (afi->isFocusScope()) {
-                QQuickItemPrivate::get(afi)->activeFocus = true;
-                changed << afi;
-            }
-            afi = afi->parentItem();
-        }
-
-        QFocusEvent event(QEvent::FocusIn, Qt::OtherFocusReason);
-        q->sendEvent(newActiveFocusItem, &event);
-    }
-
-    emit q->focusObjectChanged(activeFocusItem);
-
-    if (!changed.isEmpty())
-        notifyFocusChangesRecur(changed.data(), changed.count() - 1);
-}
-
-void QQuickCanvasPrivate::clearFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions options)
-{
-    Q_Q(QQuickCanvas);
-
-    Q_ASSERT(item);
-    Q_ASSERT(scope || item == rootItem);
-
-#ifdef FOCUS_DEBUG
-    qWarning() << "QQuickCanvasPrivate::clearFocusInScope():";
-    qWarning() << "    scope:" << (QObject *)scope;
-    qWarning() << "    item:" << (QObject *)item;
-    qWarning() << "    activeFocusItem:" << (QObject *)activeFocusItem;
-#endif
-
-    QQuickItemPrivate *scopePrivate = 0;
-    if (scope) {
-        scopePrivate = QQuickItemPrivate::get(scope);
-        if ( !scopePrivate->subFocusItem )
-            return;//No focus, nothing to do.
-    }
-
-    QQuickItem *oldActiveFocusItem = 0;
-    QQuickItem *newActiveFocusItem = 0;
-
-    QVarLengthArray<QQuickItem *, 20> changed;
-
-    Q_ASSERT(item == rootItem || item == scopePrivate->subFocusItem);
-
-    // Does this change the active focus?
-    if (item == rootItem || scopePrivate->activeFocus) {
-        oldActiveFocusItem = activeFocusItem;
-        newActiveFocusItem = scope;
-
-        Q_ASSERT(oldActiveFocusItem);
-
-#ifndef QT_NO_IM
-        qApp->inputMethod()->commit();
-#endif
-
-        activeFocusItem = 0;
-        QFocusEvent event(QEvent::FocusOut, Qt::OtherFocusReason);
-        q->sendEvent(oldActiveFocusItem, &event);
-
-        QQuickItem *afi = oldActiveFocusItem;
-        while (afi && afi != scope) {
-            if (QQuickItemPrivate::get(afi)->activeFocus) {
-                QQuickItemPrivate::get(afi)->activeFocus = false;
-                changed << afi;
-            }
-            afi = afi->parentItem();
-        }
-    }
-
-    if (item != rootItem && !(options & DontChangeSubFocusItem)) {
-        QQuickItem *oldSubFocusItem = scopePrivate->subFocusItem;
-        if (oldSubFocusItem && !(options & DontChangeFocusProperty)) {
-            QQuickItemPrivate::get(oldSubFocusItem)->focus = false;
-            changed << oldSubFocusItem;
-        }
-
-        QQuickItemPrivate::get(item)->updateSubFocusItem(scope, false);
-
-    } else if (!(options & DontChangeFocusProperty)) {
-        QQuickItemPrivate::get(item)->focus = false;
-        changed << item;
-    }
-
-    if (newActiveFocusItem) {
-        Q_ASSERT(newActiveFocusItem == scope);
-        activeFocusItem = scope;
-
-        QFocusEvent event(QEvent::FocusIn, Qt::OtherFocusReason);
-        q->sendEvent(newActiveFocusItem, &event);
-    }
-
-    emit q->focusObjectChanged(activeFocusItem);
-
-    if (!changed.isEmpty())
-        notifyFocusChangesRecur(changed.data(), changed.count() - 1);
-}
-
-void QQuickCanvasPrivate::notifyFocusChangesRecur(QQuickItem **items, int remaining)
-{
-    QQmlGuard<QQuickItem> item(*items);
-
-    if (remaining)
-        notifyFocusChangesRecur(items + 1, remaining - 1);
-
-    if (item) {
-        QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-
-        if (itemPrivate->notifiedFocus != itemPrivate->focus) {
-            itemPrivate->notifiedFocus = itemPrivate->focus;
-            emit item->focusChanged(itemPrivate->focus);
-        }
-
-        if (item && itemPrivate->notifiedActiveFocus != itemPrivate->activeFocus) {
-            itemPrivate->notifiedActiveFocus = itemPrivate->activeFocus;
-            itemPrivate->itemChange(QQuickItem::ItemActiveFocusHasChanged, itemPrivate->activeFocus);
-            emit item->activeFocusChanged(itemPrivate->activeFocus);
-        }
-    }
-}
-
-void QQuickCanvasPrivate::dirtyItem(QQuickItem *)
-{
-    Q_Q(QQuickCanvas);
-    q->maybeUpdate();
-}
-
-void QQuickCanvasPrivate::cleanup(QSGNode *n)
-{
-    Q_Q(QQuickCanvas);
-
-    Q_ASSERT(!cleanupNodeList.contains(n));
-    cleanupNodeList.append(n);
-    q->maybeUpdate();
-}
-
-
-/*!
-    \qmlmodule QtQuick.Window 2
-    \title QML Module QtQuick.Window 2.0
-    \brief Contains types for window management
-
-    This QML module contains types for creating top-level windows and accessing screen information.
-
-    To use the types in this module, import the module with the following line:
-
-    \code
-    import QtQuick.Window 2.0
-    \endcode
-*/
-
-/*!
-    \qmlclass Window QQuickCanvas
-    \inqmlmodule QtQuick.Window 2
-    \ingroup qtquick-visual
-    \brief Creates a new top-level window
-
-    The Window object creates a new top-level window for a QtQuick scene. It automatically sets up the
-    window for use with QtQuick 2.0 graphical types.
-
-    To use this type, you will need to import the module with the following line:
-    \code
-    import QtQuick.Window 2.0
-    \endcode
-
-    Restricting this import will allow you to have a QML environment without access to window system features.
-*/
-/*!
-    \class QQuickCanvas
-    \since QtQuick 2.0
-
-    \inmodule QtQuick
-
-    \brief The QQuickCanvas class provides the canvas for displaying a graphical QML scene
-
-    QQuickCanvas provides the graphical scene management needed to interact with and display
-    a scene of QQuickItems.
-
-    A QQuickCanvas always has a single invisible root item. To add items to this canvas,
-    reparent the items to the root item or to an existing item in the scene.
-
-    For easily displaying a scene from a QML file, see \l{QQuickView}.
-
-    \section1 Scene Graph and Rendering
-
-    The QQuickCanvas uses a scene graph on top of OpenGL to render. This scene graph is disconnected
-    from the QML scene and potentially lives in another thread, depending on the platform
-    implementation. Since the rendering scene graph lives independently from the QML scene, it can
-    also be completely released without affecting the state of the QML scene.
-
-    The sceneGraphInitialized() signal is emitted on the rendering thread before the QML scene is
-    rendered to the screen for the first time. If the rendering scene graph has been released
-    the signal will be emitted again before the next frame is rendered.
-
-    The rendering of each frame is broken down into the following
-    steps, in the given order:
-
-    \list 1
-
-    \li The QQuickCanvas::beforeSynchronizing() signal is emitted.
-    Applications can make direct connections (Qt::DirectConnection)
-    to this signal to do any preparation required before calls to
-    QQuickItem::updatePaintNode().
-
-    \li Synchronization of the QML state into the scene graph. This is
-    done by calling the QQuickItem::updatePaintNode() function on all
-    items that have changed since the previous frame. When a dedicated
-    rendering thread is used, the GUI thread is blocked during this
-    synchroniation. This is the only time the QML items and the nodes
-    in the scene graph interact.
-
-    \li The canvas to be rendered is made current using
-    QOpenGLContext::makeCurrent().
-
-    \li The QQuickCanvas::beforeRendering() signal is
-    emitted. Applications can make direct connections
-    (Qt::DirectConnection) to this signal to use custom OpenGL calls
-    which will then stack visually beneath the QML scene.
-
-    \li Items that have specified QSGNode::UsesPreprocess, will have their
-    QSGNode::preprocess() function invoked.
-
-    \li The QQuickCanvas is cleared according to what is specified
-    using QQuickCanvas::setClearBeforeRendering() and
-    QQuickCanvas::setClearColor().
-
-    \li The scene graph is rendered.
-
-    \li The QQuickCanvas::afterRendering() signal is
-    emitted. Applications can make direct connections
-    (Qt::DirectConnection) to this signal to use custom OpenGL calls
-    which will then stack visually over the QML scene.
-
-    \li The rendered frame is swapped and QQuickCanvas::frameSwapped()
-    is emitted.
-
-    \endlist
-
-    All of the above happen on the rendering thread, when applicable.
-
-    While the scene graph is being rendered on the rendering thread, the GUI will process animations
-    for the next frame. This means that as long as users are not using scene graph API
-    directly, the added complexity of a rendering thread can be completely ignored.
-
-    When a QQuickCanvas is programatically hidden with hide() or setVisible(false), it will
-    stop rendering and its scene graph and OpenGL context might be released. The
-    sceneGraphInvalidated() signal will be emitted when this happens.
-
-    \warning It is crucial that OpenGL operations and interaction with the scene graph happens
-    exclusively on the rendering thread, primarily during the updatePaintNode() phase.
-
-    \warning As signals related to rendering might be emitted from the rendering thread,
-    connections should be made using Qt::DirectConnection
-
-
-    \section2 Resource Management
-
-    QML will typically try to cache images, scene graph nodes, etc to improve performance, but in
-    some low-memory scenarios it might be required to aggressively release these resources. The
-    releaseResources() can be used to force clean up of certain resources. Calling releaseResources()
-    may result in the entire scene graph and its OpenGL context being deleted. The
-    sceneGraphInvalidated() signal will be emitted when this happens.
-
-*/
-QQuickCanvas::QQuickCanvas(QWindow *parent)
-    : QWindow(*(new QQuickCanvasPrivate), parent)
-{
-    Q_D(QQuickCanvas);
-    d->init(this);
-}
-
-QQuickCanvas::QQuickCanvas(QQuickCanvasPrivate &dd, QWindow *parent)
-    : QWindow(dd, parent)
-{
-    Q_D(QQuickCanvas);
-    d->init(this);
-}
-
-QQuickCanvas::~QQuickCanvas()
-{
-    Q_D(QQuickCanvas);
-
-    d->windowManager->canvasDestroyed(this);
-
-    QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);
-    delete d->incubationController; d->incubationController = 0;
-
-    delete d->rootItem; d->rootItem = 0;
-}
-
-
-
-/*!
-    This function tries to release redundant resources currently held by the QML scene.
-
-    Calling this function might result in the scene graph and the OpenGL context used
-    for rendering being released to release graphics memory. If this happens, the
-    sceneGraphInvalidated() signal will be called, allowing users to clean up their
-    own graphics resources. The setPersistentOpenGLContext() and setPersistentSceneGraph()
-    functions can be used to prevent this from happening, if handling the cleanup is
-    not feasible in the application, at the cost of higher memory usage.
-
-    \sa sceneGraphInvalidated(), setPersistentOpenGLContext(), setPersistentSceneGraph().
- */
-
-void QQuickCanvas::releaseResources()
-{
-    Q_D(QQuickCanvas);
-    d->windowManager->releaseResources();
-    QQuickPixmap::purgeCache();
-}
-
-
-
-/*!
-    Controls whether the OpenGL context can be released as a part of a call to
-    releaseResources().
-
-    The OpenGL context might still be released when the user makes an explicit
-    call to hide().
-
-    \sa setPersistentSceneGraph()
- */
-
-void QQuickCanvas::setPersistentOpenGLContext(bool persistent)
-{
-    Q_D(QQuickCanvas);
-    d->persistentGLContext = persistent;
-}
-
-
-/*!
-    Returns whether the OpenGL context can be released as a part of a call to
-    releaseResources().
- */
-
-bool QQuickCanvas::isPersistentOpenGLContext() const
-{
-    Q_D(const QQuickCanvas);
-    return d->persistentGLContext;
-}
-
-
-
-/*!
-    Controls whether the scene graph nodes and resources can be released as a
-    part of a call to releaseResources().
-
-    The scene graph nodes and resources might still be released when the user
-    makes an explicit call to hide().
-
-    \sa setPersistentOpenGLContext()
- */
-
-void QQuickCanvas::setPersistentSceneGraph(bool persistent)
-{
-    Q_D(QQuickCanvas);
-    d->persistentSceneGraph = persistent;
-}
-
-
-
-/*!
-    Returns whether the scene graph nodes and resources can be released as a part
-    of a call to releaseResources().
- */
-
-bool QQuickCanvas::isPersistentSceneGraph() const
-{
-    Q_D(const QQuickCanvas);
-    return d->persistentSceneGraph;
-}
-
-
-
-
-
-/*!
-  Returns the invisible root item of the scene.
-
-  A QQuickCanvas always has a single invisible root item. To add items to this canvas,
-  reparent the items to the root item or to an existing item in the scene.
-*/
-QQuickItem *QQuickCanvas::rootItem() const
-{
-    Q_D(const QQuickCanvas);
-
-    return d->rootItem;
-}
-
-/*!
-  Returns the item which currently has active focus.
-*/
-QQuickItem *QQuickCanvas::activeFocusItem() const
-{
-    Q_D(const QQuickCanvas);
-
-    return d->activeFocusItem;
-}
-
-QObject *QQuickCanvas::focusObject() const
-{
-    Q_D(const QQuickCanvas);
-
-    if (d->activeFocusItem)
-        return d->activeFocusItem;
-    return const_cast<QQuickCanvas*>(this);
-}
-
-
-/*!
-  Returns the item which currently has the mouse grab.
-*/
-QQuickItem *QQuickCanvas::mouseGrabberItem() const
-{
-    Q_D(const QQuickCanvas);
-
-    return d->mouseGrabberItem;
-}
-
-
-/*!
-    \qmlproperty color QtQuick.Window2::Window::color
-
-    The background color for the window.
-
-    Setting this property is more efficient than using a separate Rectangle.
-*/
-
-bool QQuickCanvasPrivate::clearHover()
-{
-    Q_Q(QQuickCanvas);
-    if (hoverItems.isEmpty())
-        return false;
-
-    QPointF pos = q->mapFromGlobal(QGuiApplicationPrivate::lastCursorPosition.toPoint());
-
-    bool accepted = false;
-    foreach (QQuickItem* item, hoverItems)
-        accepted = sendHoverEvent(QEvent::HoverLeave, item, pos, pos, QGuiApplication::keyboardModifiers(), true) || accepted;
-    hoverItems.clear();
-    return accepted;
-}
-
-/*! \reimp */
-bool QQuickCanvas::event(QEvent *e)
-{
-    Q_D(QQuickCanvas);
-
-    switch (e->type()) {
-
-    case QEvent::TouchBegin:
-    case QEvent::TouchUpdate:
-    case QEvent::TouchEnd: {
-        QTouchEvent *touch = static_cast<QTouchEvent*>(e);
-        d->translateTouchEvent(touch);
-        // return in order to avoid the QWindow::event below
-        return d->deliverTouchEvent(touch);
-    }
-        break;
-    case QEvent::TouchCancel:
-        // return in order to avoid the QWindow::event below
-        return d->deliverTouchCancelEvent(static_cast<QTouchEvent*>(e));
-        break;
-    case QEvent::Leave:
-        d->clearHover();
-        d->lastMousePosition = QPoint();
-        break;
-#ifndef QT_NO_DRAGANDDROP
-    case QEvent::DragEnter:
-    case QEvent::DragLeave:
-    case QEvent::DragMove:
-    case QEvent::Drop:
-        d->deliverDragEvent(&d->dragGrabber, e);
-        break;
-#endif
-    case QEvent::WindowDeactivate:
-        rootItem()->windowDeactivateEvent();
-        break;
-    case QEvent::FocusAboutToChange:
-        if (d->activeFocusItem)
-            qGuiApp->inputMethod()->commit();
-        break;
-    default:
-        break;
-    }
-
-    return QWindow::event(e);
-}
-
-/*! \reimp */
-void QQuickCanvas::keyPressEvent(QKeyEvent *e)
-{
-    Q_D(QQuickCanvas);
-
-    if (d->activeFocusItem)
-        sendEvent(d->activeFocusItem, e);
-}
-
-/*! \reimp */
-void QQuickCanvas::keyReleaseEvent(QKeyEvent *e)
-{
-    Q_D(QQuickCanvas);
-
-    if (d->activeFocusItem)
-        sendEvent(d->activeFocusItem, e);
-}
-
-QMouseEvent *QQuickCanvasPrivate::cloneMouseEvent(QMouseEvent *event, QPointF *transformedLocalPos)
-{
-    int caps = QGuiApplicationPrivate::mouseEventCaps(event);
-    QVector2D velocity = QGuiApplicationPrivate::mouseEventVelocity(event);
-    QMouseEvent *me = new QMouseEvent(event->type(),
-                                      transformedLocalPos ? *transformedLocalPos : event->localPos(),
-                                      event->windowPos(), event->screenPos(),
-                                      event->button(), event->buttons(), event->modifiers());
-    QGuiApplicationPrivate::setMouseEventCapsAndVelocity(me, caps, velocity);
-    me->setTimestamp(event->timestamp());
-    return me;
-}
-
-bool QQuickCanvasPrivate::deliverInitialMousePressEvent(QQuickItem *item, QMouseEvent *event)
-{
-    Q_Q(QQuickCanvas);
-
-    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-
-    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
-        QPointF p = item->mapFromScene(event->windowPos());
-        if (!item->contains(p))
-            return false;
-    }
-
-    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
-    for (int ii = children.count() - 1; ii >= 0; --ii) {
-        QQuickItem *child = children.at(ii);
-        if (!child->isVisible() || !child->isEnabled())
-            continue;
-        if (deliverInitialMousePressEvent(child, event))
-            return true;
-    }
-
-    if (itemPrivate->acceptedMouseButtons() & event->button()) {
-        QPointF localPos = item->mapFromScene(event->windowPos());
-        if (item->contains(localPos)) {
-            QScopedPointer<QMouseEvent> me(cloneMouseEvent(event, &localPos));
-            me->accept();
-            item->grabMouse();
-            q->sendEvent(item, me.data());
-            event->setAccepted(me->isAccepted());
-            if (me->isAccepted())
-                return true;
-            if (mouseGrabberItem && !event->buttons())
-                mouseGrabberItem->ungrabMouse();
-        }
-    }
-
-    return false;
-}
-
-bool QQuickCanvasPrivate::deliverMouseEvent(QMouseEvent *event)
-{
-    Q_Q(QQuickCanvas);
-
-    lastMousePosition = event->windowPos();
-
-    if (!mouseGrabberItem &&
-         event->type() == QEvent::MouseButtonPress &&
-         (event->buttons() & event->button()) == event->buttons()) {
-        if (deliverInitialMousePressEvent(rootItem, event))
-            event->accept();
-        else
-            event->ignore();
-        return event->isAccepted();
-    }
-
-    if (mouseGrabberItem) {
-        QPointF localPos = mouseGrabberItem->mapFromScene(event->windowPos());
-        QScopedPointer<QMouseEvent> me(cloneMouseEvent(event, &localPos));
-        me->accept();
-        q->sendEvent(mouseGrabberItem, me.data());
-        event->setAccepted(me->isAccepted());
-        if (me->isAccepted())
-            return true;
-    }
-
-    return false;
-}
-
-/*! \reimp */
-void QQuickCanvas::mousePressEvent(QMouseEvent *event)
-{
-    Q_D(QQuickCanvas);
-#ifdef MOUSE_DEBUG
-    qWarning() << "QQuickCanvas::mousePressEvent()" << event->localPos() << event->button() << event->buttons();
-#endif
-
-    d->deliverMouseEvent(event);
-}
-
-/*! \reimp */
-void QQuickCanvas::mouseReleaseEvent(QMouseEvent *event)
-{
-    Q_D(QQuickCanvas);
-#ifdef MOUSE_DEBUG
-    qWarning() << "QQuickCanvas::mouseReleaseEvent()" << event->localPos() << event->button() << event->buttons();
-#endif
-
-    if (!d->mouseGrabberItem) {
-        QWindow::mouseReleaseEvent(event);
-        return;
-    }
-
-    d->deliverMouseEvent(event);
-    if (d->mouseGrabberItem && !event->buttons())
-        d->mouseGrabberItem->ungrabMouse();
-}
-
-/*! \reimp */
-void QQuickCanvas::mouseDoubleClickEvent(QMouseEvent *event)
-{
-    Q_D(QQuickCanvas);
-#ifdef MOUSE_DEBUG
-    qWarning() << "QQuickCanvas::mouseDoubleClickEvent()" << event->localPos() << event->button() << event->buttons();
-#endif
-
-    if (!d->mouseGrabberItem && (event->buttons() & event->button()) == event->buttons()) {
-        if (d->deliverInitialMousePressEvent(d->rootItem, event))
-            event->accept();
-        else
-            event->ignore();
-        return;
-    }
-
-    d->deliverMouseEvent(event);
-}
-
-bool QQuickCanvasPrivate::sendHoverEvent(QEvent::Type type, QQuickItem *item,
-                                      const QPointF &scenePos, const QPointF &lastScenePos,
-                                      Qt::KeyboardModifiers modifiers, bool accepted)
-{
-    Q_Q(QQuickCanvas);
-    const QTransform transform = QQuickItemPrivate::get(item)->canvasToItemTransform();
-
-    //create copy of event
-    QHoverEvent hoverEvent(type, transform.map(scenePos), transform.map(lastScenePos), modifiers);
-    hoverEvent.setAccepted(accepted);
-
-    q->sendEvent(item, &hoverEvent);
-
-    return hoverEvent.isAccepted();
-}
-
-/*! \reimp */
-void QQuickCanvas::mouseMoveEvent(QMouseEvent *event)
-{
-    Q_D(QQuickCanvas);
-#ifdef MOUSE_DEBUG
-    qWarning() << "QQuickCanvas::mouseMoveEvent()" << event->localPos() << event->button() << event->buttons();
-#endif
-
-    if (!d->mouseGrabberItem) {
-        if (d->lastMousePosition.isNull())
-            d->lastMousePosition = event->windowPos();
-        QPointF last = d->lastMousePosition;
-        d->lastMousePosition = event->windowPos();
-
-        bool accepted = event->isAccepted();
-        bool delivered = d->deliverHoverEvent(d->rootItem, event->windowPos(), last, event->modifiers(), accepted);
-        if (!delivered) {
-            //take care of any exits
-            accepted = d->clearHover();
-        }
-        event->setAccepted(accepted);
-        return;
-    }
-
-    d->deliverMouseEvent(event);
-}
-
-bool QQuickCanvasPrivate::deliverHoverEvent(QQuickItem *item, const QPointF &scenePos, const QPointF &lastScenePos,
-                                         Qt::KeyboardModifiers modifiers, bool &accepted)
-{
-    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-
-    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
-        QPointF p = item->mapFromScene(scenePos);
-        if (!item->contains(p))
-            return false;
-    }
-
-    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
-    for (int ii = children.count() - 1; ii >= 0; --ii) {
-        QQuickItem *child = children.at(ii);
-        if (!child->isVisible() || !child->isEnabled())
-            continue;
-        if (deliverHoverEvent(child, scenePos, lastScenePos, modifiers, accepted))
-            return true;
-    }
-
-    if (itemPrivate->hoverEnabled) {
-        QPointF p = item->mapFromScene(scenePos);
-        if (item->contains(p)) {
-            if (!hoverItems.isEmpty() && hoverItems[0] == item) {
-                //move
-                accepted = sendHoverEvent(QEvent::HoverMove, item, scenePos, lastScenePos, modifiers, accepted);
-            } else {
-                QList<QQuickItem *> itemsToHover;
-                QQuickItem* parent = item;
-                itemsToHover << item;
-                while ((parent = parent->parentItem()))
-                    itemsToHover << parent;
-
-                // Leaving from previous hovered items until we reach the item or one of its ancestors.
-                while (!hoverItems.isEmpty() && !itemsToHover.contains(hoverItems[0])) {
-                    sendHoverEvent(QEvent::HoverLeave, hoverItems[0], scenePos, lastScenePos, modifiers, accepted);
-                    hoverItems.removeFirst();
-                }
-
-                if (!hoverItems.isEmpty() && hoverItems[0] == item){//Not entering a new Item
-                    // ### Shouldn't we send moves for the parent items as well?
-                    accepted = sendHoverEvent(QEvent::HoverMove, item, scenePos, lastScenePos, modifiers, accepted);
-                } else {
-                    // Enter items that are not entered yet.
-                    int startIdx = -1;
-                    if (!hoverItems.isEmpty())
-                        startIdx = itemsToHover.indexOf(hoverItems[0]) - 1;
-                    if (startIdx == -1)
-                        startIdx = itemsToHover.count() - 1;
-
-                    for (int i = startIdx; i >= 0; i--) {
-                        QQuickItem *itemToHover = itemsToHover[i];
-                        if (QQuickItemPrivate::get(itemToHover)->hoverEnabled) {
-                            hoverItems.prepend(itemToHover);
-                            sendHoverEvent(QEvent::HoverEnter, itemToHover, scenePos, lastScenePos, modifiers, accepted);
-                        }
-                    }
-                }
-            }
-            return true;
-        }
-    }
-
-    return false;
-}
-
-bool QQuickCanvasPrivate::deliverWheelEvent(QQuickItem *item, QWheelEvent *event)
-{
-    Q_Q(QQuickCanvas);
-    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-
-    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
-        QPointF p = item->mapFromScene(event->posF());
-        if (!item->contains(p))
-            return false;
-    }
-
-    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
-    for (int ii = children.count() - 1; ii >= 0; --ii) {
-        QQuickItem *child = children.at(ii);
-        if (!child->isVisible() || !child->isEnabled())
-            continue;
-        if (deliverWheelEvent(child, event))
-            return true;
-    }
-
-    QPointF p = item->mapFromScene(event->posF());
-
-    if (item->contains(p)) {
-        QWheelEvent wheel(p, p, event->pixelDelta(), event->angleDelta(), event->delta(),
-                          event->orientation(), event->buttons(), event->modifiers());
-        wheel.accept();
-        q->sendEvent(item, &wheel);
-        if (wheel.isAccepted()) {
-            event->accept();
-            return true;
-        }
-    }
-
-    return false;
-}
-
-#ifndef QT_NO_WHEELEVENT
-/*! \reimp */
-void QQuickCanvas::wheelEvent(QWheelEvent *event)
-{
-    Q_D(QQuickCanvas);
-#ifdef MOUSE_DEBUG
-    qWarning() << "QQuickCanvas::wheelEvent()" << event->pixelDelta() << event->angleDelta();
-#endif
-
-    //if the actual wheel event was accepted, accept the compatability wheel event and return early
-    if (d->lastWheelEventAccepted && event->angleDelta().isNull())
-        return;
-
-    event->ignore();
-    d->deliverWheelEvent(d->rootItem, event);
-    d->lastWheelEventAccepted = event->isAccepted();
-}
-#endif // QT_NO_WHEELEVENT
-
-
-bool QQuickCanvasPrivate::deliverTouchCancelEvent(QTouchEvent *event)
-{
-#ifdef TOUCH_DEBUG
-    qWarning("touchCancelEvent");
-#endif
-    Q_Q(QQuickCanvas);
-    // A TouchCancel event will typically not contain any points.
-    // Deliver it to all items that have active touches.
-    QSet<QQuickItem *> cancelDelivered;
-    foreach (QQuickItem *item, itemForTouchPointId) {
-        if (cancelDelivered.contains(item))
-            continue;
-        cancelDelivered.insert(item);
-        q->sendEvent(item, event);
-    }
-    touchMouseId = -1;
-    if (mouseGrabberItem)
-        mouseGrabberItem->ungrabMouse();
-    // The next touch event can only be a TouchBegin so clean up.
-    itemForTouchPointId.clear();
-    return true;
-}
-
-// check what kind of touch we have (begin/update) and
-// call deliverTouchPoints to actually dispatch the points
-bool QQuickCanvasPrivate::deliverTouchEvent(QTouchEvent *event)
-{
-#ifdef TOUCH_DEBUG
-    if (event->type() == QEvent::TouchBegin)
-        qWarning() << "touchBeginEvent";
-    else if (event->type() == QEvent::TouchUpdate)
-        qWarning() << "touchUpdateEvent points";
-    else if (event->type() == QEvent::TouchEnd)
-        qWarning("touchEndEvent");
-#endif
-
-    // List of all items that received an event before
-    // When we have TouchBegin this is and will stay empty
-    QHash<QQuickItem *, QList<QTouchEvent::TouchPoint> > updatedPoints;
-
-    // Figure out who accepted a touch point last and put it in updatedPoints
-    // Add additional item to newPoints
-    const QList<QTouchEvent::TouchPoint> &touchPoints = event->touchPoints();
-    QList<QTouchEvent::TouchPoint> newPoints;
-    for (int i=0; i<touchPoints.count(); i++) {
-        const QTouchEvent::TouchPoint &touchPoint = touchPoints.at(i);
-        if (touchPoint.state() == Qt::TouchPointPressed) {
-            newPoints << touchPoint;
-        } else {
-            // TouchPointStationary is relevant only to items which
-            // are also receiving touch points with some other state.
-            // But we have not yet decided which points go to which item,
-            // so for now we must include all non-new points in updatedPoints.
-            if (itemForTouchPointId.contains(touchPoint.id())) {
-                QQuickItem *item = itemForTouchPointId.value(touchPoint.id());
-                if (item)
-                    updatedPoints[item].append(touchPoint);
-            }
-        }
-    }
-
-    // Deliver the event, but only if there is at least one new point
-    // or some item accepted a point and should receive an update
-    if (newPoints.count() > 0 || updatedPoints.count() > 0) {
-        QSet<int> acceptedNewPoints;
-        event->setAccepted(deliverTouchPoints(rootItem, event, newPoints, &acceptedNewPoints, &updatedPoints));
-    } else
-        event->ignore();
-
-    // Remove released points from itemForTouchPointId
-    if (event->touchPointStates() & Qt::TouchPointReleased) {
-        for (int i=0; i<touchPoints.count(); i++) {
-            if (touchPoints[i].state() == Qt::TouchPointReleased) {
-                itemForTouchPointId.remove(touchPoints[i].id());
-                if (touchPoints[i].id() == touchMouseId)
-                    touchMouseId = -1;
-            }
-        }
-    }
-
-    if (event->type() == QEvent::TouchEnd) {
-        Q_ASSERT(itemForTouchPointId.isEmpty());
-    }
-
-    return event->isAccepted();
-}
-
-// This function recurses and sends the events to the individual items
-bool QQuickCanvasPrivate::deliverTouchPoints(QQuickItem *item, QTouchEvent *event, const QList<QTouchEvent::TouchPoint> &newPoints, QSet<int> *acceptedNewPoints, QHash<QQuickItem *, QList<QTouchEvent::TouchPoint> > *updatedPoints)
-{
-    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-
-    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
-        for (int i=0; i<newPoints.count(); i++) {
-            QPointF p = item->mapFromScene(newPoints[i].scenePos());
-            if (!item->contains(p))
-                return false;
-        }
-    }
-
-    // Check if our children want the event (or parts of it)
-    // This is the only point where touch event delivery recurses!
-    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
-    for (int ii = children.count() - 1; ii >= 0; --ii) {
-        QQuickItem *child = children.at(ii);
-        if (!child->isEnabled() || !child->isVisible())
-            continue;
-        if (deliverTouchPoints(child, event, newPoints, acceptedNewPoints, updatedPoints))
-            return true;
-    }
-
-    // None of the children accepted the event, so check the given item itself.
-    // First, construct matchingPoints as a list of TouchPoints which the
-    // given item might be interested in.  Any newly-pressed point which is
-    // inside the item's bounds will be interesting, and also any updated point
-    // which was already accepted by that item when it was first pressed.
-    // (A point which was already accepted is effectively "grabbed" by the item.)
-
-    // set of IDs of "interesting" new points
-    QSet<int> matchingNewPoints;
-    // set of points which this item has previously accepted, for starters
-    QList<QTouchEvent::TouchPoint> matchingPoints = (*updatedPoints)[item];
-    // now add the new points which are inside this item's bounds
-    if (newPoints.count() > 0 && acceptedNewPoints->count() < newPoints.count()) {
-        for (int i = 0; i < newPoints.count(); i++) {
-            if (acceptedNewPoints->contains(newPoints[i].id()))
-                continue;
-            QPointF p = item->mapFromScene(newPoints[i].scenePos());
-            if (item->contains(p)) {
-                matchingNewPoints.insert(newPoints[i].id());
-                matchingPoints << newPoints[i];
-            }
-        }
-    }
-    // If there are no matching new points, and the existing points are all stationary,
-    // there's no need to send an event to this item.  This is required by a test in
-    // tst_qquickcanvas::touchEvent_basic:
-    // a single stationary press on an item shouldn't cause an event
-    if (matchingNewPoints.isEmpty()) {
-        bool stationaryOnly = true;
-        Q_FOREACH (QTouchEvent::TouchPoint tp, matchingPoints)
-            if (tp.state() != Qt::TouchPointStationary)
-                stationaryOnly = false;
-        if (stationaryOnly)
-            matchingPoints.clear();
-    }
-
-    if (!matchingPoints.isEmpty()) {
-        // Now we know this item might be interested in the event. Copy and send it, but
-        // with only the subset of TouchPoints which are relevant to that item: that's matchingPoints.
-        QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-        transformTouchPoints(matchingPoints, itemPrivate->canvasToItemTransform());
-        deliverMatchingPointsToItem(item, event, acceptedNewPoints, matchingNewPoints, matchingPoints);
-    }
-
-    // record the fact that this item has been visited already
-    updatedPoints->remove(item);
-
-    // recursion is done only if ALL touch points have been delivered
-    return (acceptedNewPoints->count() == newPoints.count() && updatedPoints->isEmpty());
-}
-
-// touchEventForItemBounds has no means to generate a touch event that contains
-// only the points that are relevant for this item.  Thus the need for
-// matchingPoints to already be that set of interesting points.
-// They are all pre-transformed, too.
-bool QQuickCanvasPrivate::deliverMatchingPointsToItem(QQuickItem *item, QTouchEvent *event, QSet<int> *acceptedNewPoints, const QSet<int> &matchingNewPoints, const QList<QTouchEvent::TouchPoint> &matchingPoints)
-{
-    QScopedPointer<QTouchEvent> touchEvent(touchEventWithPoints(*event, matchingPoints));
-    touchEvent.data()->setTarget(item);
-    bool touchEventAccepted = false;
-
-    // First check whether the parent wants to be a filter,
-    // and if the parent accepts the event we are done.
-    if (sendFilteredTouchEvent(item->parentItem(), item, event)) {
-        event->accept();
-        return true;
-    }
-
-    // Since it can change in sendEvent, update itemForTouchPointId now
-    foreach (int id, matchingNewPoints)
-        itemForTouchPointId[id] = item;
-
-    // Deliver the touch event to the given item
-    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-    itemPrivate->deliverTouchEvent(touchEvent.data());
-    touchEventAccepted = touchEvent->isAccepted();
-
-    // If the touch event wasn't accepted, synthesize a mouse event and see if the item wants it.
-    if (!touchEventAccepted && (itemPrivate->acceptedMouseButtons() & Qt::LeftButton)) {
-        //  send mouse event
-        event->setAccepted(translateTouchToMouse(item, event));
-        if (event->isAccepted()) {
-            touchEventAccepted = true;
-        }
-    }
-
-    if (touchEventAccepted) {
-        // If the touch was accepted (regardless by whom or in what form),
-        // update acceptedNewPoints.
-        foreach (int id, matchingNewPoints)
-            acceptedNewPoints->insert(id);
-    } else {
-        // But if the event was not accepted then we know this item
-        // will not be interested in further updates for those touchpoint IDs either.
-        foreach (int id, matchingNewPoints)
-            if (itemForTouchPointId[id] == item)
-                itemForTouchPointId.remove(id);
-    }
-
-    return touchEventAccepted;
-}
-
-QTouchEvent *QQuickCanvasPrivate::touchEventForItemBounds(QQuickItem *target, const QTouchEvent &originalEvent)
-{
-    const QList<QTouchEvent::TouchPoint> &touchPoints = originalEvent.touchPoints();
-    QList<QTouchEvent::TouchPoint> pointsInBounds;
-    // if all points are stationary, the list of points should be empty to signal a no-op
-    if (originalEvent.touchPointStates() != Qt::TouchPointStationary) {
-        for (int i = 0; i < touchPoints.count(); ++i) {
-            const QTouchEvent::TouchPoint &tp = touchPoints.at(i);
-            if (tp.state() == Qt::TouchPointPressed) {
-                QPointF p = target->mapFromScene(tp.scenePos());
-                if (target->contains(p))
-                    pointsInBounds.append(tp);
-            } else {
-                pointsInBounds.append(tp);
-            }
-        }
-        transformTouchPoints(pointsInBounds, QQuickItemPrivate::get(target)->canvasToItemTransform());
-    }
-
-    QTouchEvent* touchEvent = touchEventWithPoints(originalEvent, pointsInBounds);
-    touchEvent->setTarget(target);
-    return touchEvent;
-}
-
-QTouchEvent *QQuickCanvasPrivate::touchEventWithPoints(const QTouchEvent &event, const QList<QTouchEvent::TouchPoint> &newPoints)
-{
-    Qt::TouchPointStates eventStates;
-    for (int i=0; i<newPoints.count(); i++)
-        eventStates |= newPoints[i].state();
-    // if all points have the same state, set the event type accordingly
-    QEvent::Type eventType = event.type();
-    switch (eventStates) {
-        case Qt::TouchPointPressed:
-            eventType = QEvent::TouchBegin;
-            break;
-        case Qt::TouchPointReleased:
-            eventType = QEvent::TouchEnd;
-            break;
-        default:
-            eventType = QEvent::TouchUpdate;
-            break;
-    }
-
-    QTouchEvent *touchEvent = new QTouchEvent(eventType);
-    touchEvent->setWindow(event.window());
-    touchEvent->setTarget(event.target());
-    touchEvent->setDevice(event.device());
-    touchEvent->setModifiers(event.modifiers());
-    touchEvent->setTouchPoints(newPoints);
-    touchEvent->setTouchPointStates(eventStates);
-    touchEvent->setTimestamp(event.timestamp());
-    touchEvent->accept();
-    return touchEvent;
-}
-
-#ifndef QT_NO_DRAGANDDROP
-void QQuickCanvasPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QEvent *event)
-{
-    Q_Q(QQuickCanvas);
-    grabber->resetTarget();
-    QQuickDragGrabber::iterator grabItem = grabber->begin();
-    if (grabItem != grabber->end()) {
-        Q_ASSERT(event->type() != QEvent::DragEnter);
-        if (event->type() == QEvent::Drop) {
-            QDropEvent *e = static_cast<QDropEvent *>(event);
-            for (e->setAccepted(false); !e->isAccepted() && grabItem != grabber->end(); grabItem = grabber->release(grabItem)) {
-                QPointF p = (**grabItem)->mapFromScene(e->pos());
-                QDropEvent translatedEvent(
-                        p.toPoint(),
-                        e->possibleActions(),
-                        e->mimeData(),
-                        e->mouseButtons(),
-                        e->keyboardModifiers());
-                QQuickDropEventEx::copyActions(&translatedEvent, *e);
-                q->sendEvent(**grabItem, &translatedEvent);
-                e->setAccepted(translatedEvent.isAccepted());
-                e->setDropAction(translatedEvent.dropAction());
-                grabber->setTarget(**grabItem);
-            }
-        }
-        if (event->type() != QEvent::DragMove) {    // Either an accepted drop or a leave.
-            QDragLeaveEvent leaveEvent;
-            for (; grabItem != grabber->end(); grabItem = grabber->release(grabItem))
-                q->sendEvent(**grabItem, &leaveEvent);
-            return;
-        } else for (; grabItem != grabber->end(); grabItem = grabber->release(grabItem)) {
-            QDragMoveEvent *moveEvent = static_cast<QDragMoveEvent *>(event);
-            if (deliverDragEvent(grabber, **grabItem, moveEvent)) {
-                moveEvent->setAccepted(true);
-                for (++grabItem; grabItem != grabber->end();) {
-                    QPointF p = (**grabItem)->mapFromScene(moveEvent->pos());
-                    if ((**grabItem)->contains(p)) {
-                        QDragMoveEvent translatedEvent(
-                                p.toPoint(),
-                                moveEvent->possibleActions(),
-                                moveEvent->mimeData(),
-                                moveEvent->mouseButtons(),
-                                moveEvent->keyboardModifiers());
-                        QQuickDropEventEx::copyActions(&translatedEvent, *moveEvent);
-                        q->sendEvent(**grabItem, &translatedEvent);
-                        ++grabItem;
-                    } else {
-                        QDragLeaveEvent leaveEvent;
-                        q->sendEvent(**grabItem, &leaveEvent);
-                        grabItem = grabber->release(grabItem);
-                    }
-                }
-                return;
-            } else {
-                QDragLeaveEvent leaveEvent;
-                q->sendEvent(**grabItem, &leaveEvent);
-            }
-        }
-    }
-    if (event->type() == QEvent::DragEnter || event->type() == QEvent::DragMove) {
-        QDragMoveEvent *e = static_cast<QDragMoveEvent *>(event);
-        QDragEnterEvent enterEvent(
-                e->pos(),
-                e->possibleActions(),
-                e->mimeData(),
-                e->mouseButtons(),
-                e->keyboardModifiers());
-        QQuickDropEventEx::copyActions(&enterEvent, *e);
-        event->setAccepted(deliverDragEvent(grabber, rootItem, &enterEvent));
-    }
-}
-
-bool QQuickCanvasPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QQuickItem *item, QDragMoveEvent *event)
-{
-    Q_Q(QQuickCanvas);
-    bool accepted = false;
-    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
-    if (!item->isVisible() || !item->isEnabled())
-        return false;
-
-    QPointF p = item->mapFromScene(event->pos());
-    if (item->contains(p)) {
-        if (event->type() == QEvent::DragMove || itemPrivate->flags & QQuickItem::ItemAcceptsDrops) {
-            QDragMoveEvent translatedEvent(
-                    p.toPoint(),
-                    event->possibleActions(),
-                    event->mimeData(),
-                    event->mouseButtons(),
-                    event->keyboardModifiers(),
-                    event->type());
-            QQuickDropEventEx::copyActions(&translatedEvent, *event);
-            q->sendEvent(item, &translatedEvent);
-            if (event->type() == QEvent::DragEnter) {
-                if (translatedEvent.isAccepted()) {
-                    grabber->grab(item);
-                    accepted = true;
-                }
-            } else {
-                accepted = true;
-            }
-        }
-    } else if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
-        return false;
-    }
-
-    QDragEnterEvent enterEvent(
-            event->pos(),
-            event->possibleActions(),
-            event->mimeData(),
-            event->mouseButtons(),
-            event->keyboardModifiers());
-    QQuickDropEventEx::copyActions(&enterEvent, *event);
-    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
-    for (int ii = children.count() - 1; ii >= 0; --ii) {
-        if (deliverDragEvent(grabber, children.at(ii), &enterEvent))
-            return true;
-    }
-
-    return accepted;
-}
-#endif // QT_NO_DRAGANDDROP
-
-bool QQuickCanvasPrivate::sendFilteredTouchEvent(QQuickItem *target, QQuickItem *item, QTouchEvent *event)
-{
-    if (!target)
-        return false;
-
-    QQuickItemPrivate *targetPrivate = QQuickItemPrivate::get(target);
-    if (targetPrivate->filtersChildMouseEvents) {
-        QScopedPointer<QTouchEvent> targetEvent(touchEventForItemBounds(target, *event));
-        if (!targetEvent->touchPoints().isEmpty()) {
-            QVector<int> touchIds;
-            for (int i = 0; i < event->touchPoints().size(); ++i)
-                touchIds.append(event->touchPoints().at(i).id());
-            if (target->childMouseEventFilter(item, targetEvent.data())) {
-                target->grabTouchPoints(touchIds);
-                if (mouseGrabberItem) {
-                    mouseGrabberItem->ungrabMouse();
-                    touchMouseId = -1;
-                }
-                return true;
-            }
-
-            // Only offer a mouse event to the filter if we have one point
-            if (targetEvent->touchPoints().count() == 1) {
-                QEvent::Type t;
-                const QTouchEvent::TouchPoint &tp = targetEvent->touchPoints().first();
-                switch (tp.state()) {
-                case Qt::TouchPointPressed:
-                    t = QEvent::MouseButtonPress;
-                    break;
-                case Qt::TouchPointReleased:
-                    t = QEvent::MouseButtonRelease;
-                    break;
-                default:
-                    // move or stationary
-                    t = QEvent::MouseMove;
-                    break;
-                }
-
-                // targetEvent is already transformed wrt local position, velocity, etc.
-                QScopedPointer<QMouseEvent> mouseEvent(touchToMouseEvent(t, targetEvent->touchPoints().first(), event, item, false));
-                if (target->childMouseEventFilter(item, mouseEvent.data())) {
-                    itemForTouchPointId[tp.id()] = target;
-                    touchMouseId = tp.id();
-                    target->grabMouse();
-                    return true;
-                }
-            }
-        }
-    }
-
-    return sendFilteredTouchEvent(target->parentItem(), item, event);
-}
-
-bool QQuickCanvasPrivate::sendFilteredMouseEvent(QQuickItem *target, QQuickItem *item, QEvent *event)
-{
-    if (!target)
-        return false;
-
-    QQuickItemPrivate *targetPrivate = QQuickItemPrivate::get(target);
-    if (targetPrivate->filtersChildMouseEvents)
-        if (target->childMouseEventFilter(item, event))
-            return true;
-
-    if (sendFilteredMouseEvent(target->parentItem(), item, event))
-        return true;
-
-    return false;
-}
-
-bool QQuickCanvasPrivate::dragOverThreshold(qreal d, Qt::Axis axis, QMouseEvent *event)
-{
-    QStyleHints *styleHints = qApp->styleHints();
-    int caps = QGuiApplicationPrivate::mouseEventCaps(event);
-    bool dragVelocityLimitAvailable = (caps & QTouchDevice::Velocity)
-        && styleHints->startDragVelocity();
-    bool overThreshold = qAbs(d) > styleHints->startDragDistance();
-    if (dragVelocityLimitAvailable) {
-        QVector2D velocityVec = QGuiApplicationPrivate::mouseEventVelocity(event);
-        qreal velocity = axis == Qt::XAxis ? velocityVec.x() : velocityVec.y();
-        overThreshold |= qAbs(velocity) > styleHints->startDragVelocity();
-    }
-    return overThreshold;
-}
-
-/*!
-    Propagates an event to a QQuickItem on the canvas
-*/
-bool QQuickCanvas::sendEvent(QQuickItem *item, QEvent *e)
-{
-    Q_D(QQuickCanvas);
-
-    if (!item) {
-        qWarning("QQuickCanvas::sendEvent: Cannot send event to a null item");
-        return false;
-    }
-
-    Q_ASSERT(e);
-
-    switch (e->type()) {
-    case QEvent::KeyPress:
-    case QEvent::KeyRelease:
-        e->accept();
-        QQuickItemPrivate::get(item)->deliverKeyEvent(static_cast<QKeyEvent *>(e));
-        while (!e->isAccepted() && (item = item->parentItem())) {
-            e->accept();
-            QQuickItemPrivate::get(item)->deliverKeyEvent(static_cast<QKeyEvent *>(e));
-        }
-        break;
-    case QEvent::FocusIn:
-    case QEvent::FocusOut:
-        QQuickItemPrivate::get(item)->deliverFocusEvent(static_cast<QFocusEvent *>(e));
-        break;
-    case QEvent::MouseButtonPress:
-    case QEvent::MouseButtonRelease:
-    case QEvent::MouseButtonDblClick:
-    case QEvent::MouseMove:
-        // XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?
-        if (!d->sendFilteredMouseEvent(item->parentItem(), item, e)) {
-            // accept because qml items by default accept and have to explicitly opt out of accepting
-            e->accept();
-            QQuickItemPrivate::get(item)->deliverMouseEvent(static_cast<QMouseEvent *>(e));
-        }
-        break;
-    case QEvent::UngrabMouse:
-        if (!d->sendFilteredMouseEvent(item->parentItem(), item, e)) {
-            e->accept();
-            item->mouseUngrabEvent();
-        }
-        break;
-    case QEvent::Wheel:
-        QQuickItemPrivate::get(item)->deliverWheelEvent(static_cast<QWheelEvent *>(e));
-        break;
-    case QEvent::HoverEnter:
-    case QEvent::HoverLeave:
-    case QEvent::HoverMove:
-        QQuickItemPrivate::get(item)->deliverHoverEvent(static_cast<QHoverEvent *>(e));
-        break;
-    case QEvent::TouchBegin:
-    case QEvent::TouchUpdate:
-    case QEvent::TouchEnd:
-        d->sendFilteredTouchEvent(item->parentItem(), item, static_cast<QTouchEvent *>(e));
-        break;
-    case QEvent::TouchCancel:
-        QQuickItemPrivate::get(item)->deliverTouchEvent(static_cast<QTouchEvent *>(e));
-        break;
-#ifndef QT_NO_DRAGANDDROP
-    case QEvent::DragEnter:
-    case QEvent::DragMove:
-    case QEvent::DragLeave:
-    case QEvent::Drop:
-        QQuickItemPrivate::get(item)->deliverDragEvent(e);
-        break;
-#endif
-    default:
-        break;
-    }
-
-    return false;
-}
-
-void QQuickCanvasPrivate::cleanupNodes()
-{
-    for (int ii = 0; ii < cleanupNodeList.count(); ++ii)
-        delete cleanupNodeList.at(ii);
-    cleanupNodeList.clear();
-}
-
-void QQuickCanvasPrivate::cleanupNodesOnShutdown(QQuickItem *item)
-{
-    QQuickItemPrivate *p = QQuickItemPrivate::get(item);
-    if (p->itemNodeInstance) {
-        delete p->itemNodeInstance;
-        p->itemNodeInstance = 0;
-
-        if (p->extra.isAllocated()) {
-            p->extra->opacityNode = 0;
-            p->extra->clipNode = 0;
-            p->extra->rootNode = 0;
-        }
-
-        p->groupNode = 0;
-        p->paintNode = 0;
-    }
-
-    for (int ii = 0; ii < p->childItems.count(); ++ii)
-        cleanupNodesOnShutdown(p->childItems.at(ii));
-}
-
-// This must be called from the render thread, with the main thread frozen
-void QQuickCanvasPrivate::cleanupNodesOnShutdown()
-{
-    Q_Q(QQuickCanvas);
-    cleanupNodes();
-    cleanupNodesOnShutdown(rootItem);
-    QSet<QQuickItem *>::const_iterator it = parentlessItems.begin();
-    for (; it != parentlessItems.end(); ++it)
-        cleanupNodesOnShutdown(*it);
-    q->cleanupSceneGraph();
-}
-
-void QQuickCanvasPrivate::updateDirtyNodes()
-{
-#ifdef DIRTY_DEBUG
-    qWarning() << "QQuickCanvasPrivate::updateDirtyNodes():";
-#endif
-
-    cleanupNodes();
-
-    QQuickItem *updateList = dirtyItemList;
-    dirtyItemList = 0;
-    if (updateList) QQuickItemPrivate::get(updateList)->prevDirtyItem = &updateList;
-
-    while (updateList) {
-        QQuickItem *item = updateList;
-        QQuickItemPrivate *itemPriv = QQuickItemPrivate::get(item);
-        itemPriv->removeFromDirtyList();
-
-#ifdef DIRTY_DEBUG
-        qWarning() << "   QSGNode:" << item << qPrintable(itemPriv->dirtyToString());
-#endif
-        updateDirtyNode(item);
-    }
-}
-
-void QQuickCanvasPrivate::updateDirtyNode(QQuickItem *item)
-{
-#ifdef QML_RUNTIME_TESTING
-    bool didFlash = false;
-#endif
-
-    QQuickItemPrivate *itemPriv = QQuickItemPrivate::get(item);
-    quint32 dirty = itemPriv->dirtyAttributes;
-    itemPriv->dirtyAttributes = 0;
-
-    if ((dirty & QQuickItemPrivate::TransformUpdateMask) ||
-        (dirty & QQuickItemPrivate::Size && itemPriv->origin() != QQuickItem::TopLeft &&
-         (itemPriv->scale() != 1. || itemPriv->rotation() != 0.))) {
-
-        QMatrix4x4 matrix;
-
-        if (itemPriv->x != 0. || itemPriv->y != 0.)
-            matrix.translate(itemPriv->x, itemPriv->y);
-
-        for (int ii = itemPriv->transforms.count() - 1; ii >= 0; --ii)
-            itemPriv->transforms.at(ii)->applyTo(&matrix);
-
-        if (itemPriv->scale() != 1. || itemPriv->rotation() != 0.) {
-            QPointF origin = item->transformOriginPoint();
-            matrix.translate(origin.x(), origin.y());
-            if (itemPriv->scale() != 1.)
-                matrix.scale(itemPriv->scale(), itemPriv->scale());
-            if (itemPriv->rotation() != 0.)
-                matrix.rotate(itemPriv->rotation(), 0, 0, 1);
-            matrix.translate(-origin.x(), -origin.y());
-        }
-
-        itemPriv->itemNode()->setMatrix(matrix);
-    }
-
-    bool clipEffectivelyChanged = (dirty & (QQuickItemPrivate::Clip | QQuickItemPrivate::Canvas)) &&
-                                  ((item->clip() == false) != (itemPriv->clipNode() == 0));
-    int effectRefCount = itemPriv->extra.isAllocated()?itemPriv->extra->effectRefCount:0;
-    bool effectRefEffectivelyChanged = (dirty & (QQuickItemPrivate::EffectReference | QQuickItemPrivate::Canvas)) &&
-                                  ((effectRefCount == 0) != (itemPriv->rootNode() == 0));
-
-    if (clipEffectivelyChanged) {
-        QSGNode *parent = itemPriv->opacityNode() ? (QSGNode *) itemPriv->opacityNode() :
-                                                    (QSGNode *)itemPriv->itemNode();
-        QSGNode *child = itemPriv->rootNode() ? (QSGNode *)itemPriv->rootNode() :
-                                                (QSGNode *)itemPriv->groupNode;
-
-        if (item->clip()) {
-            Q_ASSERT(itemPriv->clipNode() == 0);
-            itemPriv->extra.value().clipNode = new QQuickDefaultClipNode(item->clipRect());
-            itemPriv->clipNode()->update();
-
-            if (child)
-                parent->removeChildNode(child);
-            parent->appendChildNode(itemPriv->clipNode());
-            if (child)
-                itemPriv->clipNode()->appendChildNode(child);
-
-        } else {
-            Q_ASSERT(itemPriv->clipNode() != 0);
-            parent->removeChildNode(itemPriv->clipNode());
-            if (child)
-                itemPriv->clipNode()->removeChildNode(child);
-            delete itemPriv->clipNode();
-            itemPriv->extra->clipNode = 0;
-            if (child)
-                parent->appendChildNode(child);
-        }
-    }
-
-    if (dirty & QQuickItemPrivate::ChildrenUpdateMask)
-        itemPriv->childContainerNode()->removeAllChildNodes();
-
-    if (effectRefEffectivelyChanged) {
-        QSGNode *parent = itemPriv->clipNode();
-        if (!parent)
-            parent = itemPriv->opacityNode();
-        if (!parent)
-            parent = itemPriv->itemNode();
-        QSGNode *child = itemPriv->groupNode;
-
-        if (itemPriv->extra.isAllocated() && itemPriv->extra->effectRefCount) {
-            Q_ASSERT(itemPriv->rootNode() == 0);
-            itemPriv->extra->rootNode = new QSGRootNode;
-
-            if (child)
-                parent->removeChildNode(child);
-            parent->appendChildNode(itemPriv->rootNode());
-            if (child)
-                itemPriv->rootNode()->appendChildNode(child);
-        } else {
-            Q_ASSERT(itemPriv->rootNode() != 0);
-            parent->removeChildNode(itemPriv->rootNode());
-            if (child)
-                itemPriv->rootNode()->removeChildNode(child);
-            delete itemPriv->rootNode();
-            itemPriv->extra->rootNode = 0;
-            if (child)
-                parent->appendChildNode(child);
-        }
-    }
-
-    if (dirty & QQuickItemPrivate::ChildrenUpdateMask) {
-        QSGNode *groupNode = itemPriv->groupNode;
-        if (groupNode)
-            groupNode->removeAllChildNodes();
-
-        QList<QQuickItem *> orderedChildren = itemPriv->paintOrderChildItems();
-        int ii = 0;
-
-        for (; ii < orderedChildren.count() && orderedChildren.at(ii)->z() < 0; ++ii) {
-            QQuickItemPrivate *childPrivate = QQuickItemPrivate::get(orderedChildren.at(ii));
-            if (!childPrivate->explicitVisible &&
-                (!childPrivate->extra.isAllocated() || !childPrivate->extra->effectRefCount))
-                continue;
-            if (childPrivate->itemNode()->parent())
-                childPrivate->itemNode()->parent()->removeChildNode(childPrivate->itemNode());
-
-            itemPriv->childContainerNode()->appendChildNode(childPrivate->itemNode());
-        }
-
-        QSGNode *beforePaintNode = itemPriv->groupNode ? itemPriv->groupNode->lastChild() : 0;
-        if (beforePaintNode || itemPriv->extra.isAllocated())
-            itemPriv->extra.value().beforePaintNode = beforePaintNode;
-
-        if (itemPriv->paintNode)
-            itemPriv->childContainerNode()->appendChildNode(itemPriv->paintNode);
-
-        for (; ii < orderedChildren.count(); ++ii) {
-            QQuickItemPrivate *childPrivate = QQuickItemPrivate::get(orderedChildren.at(ii));
-            if (!childPrivate->explicitVisible &&
-                (!childPrivate->extra.isAllocated() || !childPrivate->extra->effectRefCount))
-                continue;
-            if (childPrivate->itemNode()->parent())
-                childPrivate->itemNode()->parent()->removeChildNode(childPrivate->itemNode());
-
-            itemPriv->childContainerNode()->appendChildNode(childPrivate->itemNode());
-        }
-    }
-
-    if ((dirty & QQuickItemPrivate::Size) && itemPriv->clipNode()) {
-        itemPriv->clipNode()->setRect(item->clipRect());
-        itemPriv->clipNode()->update();
-    }
-
-    if (dirty & (QQuickItemPrivate::OpacityValue | QQuickItemPrivate::Visible
-                 | QQuickItemPrivate::HideReference | QQuickItemPrivate::Canvas))
-    {
-        qreal opacity = itemPriv->explicitVisible && (!itemPriv->extra.isAllocated() || itemPriv->extra->hideRefCount == 0)
-                      ? itemPriv->opacity() : qreal(0);
-
-        if (opacity != 1 && !itemPriv->opacityNode()) {
-            itemPriv->extra.value().opacityNode = new QSGOpacityNode;
-
-            QSGNode *parent = itemPriv->itemNode();
-            QSGNode *child = itemPriv->clipNode();
-            if (!child)
-                child = itemPriv->rootNode();
-            if (!child)
-                child = itemPriv->groupNode;
-
-            if (child)
-                parent->removeChildNode(child);
-            parent->appendChildNode(itemPriv->opacityNode());
-            if (child)
-                itemPriv->opacityNode()->appendChildNode(child);
-        }
-        if (itemPriv->opacityNode())
-            itemPriv->opacityNode()->setOpacity(opacity);
-    }
-
-    if (dirty & QQuickItemPrivate::ContentUpdateMask) {
-
-        if (itemPriv->flags & QQuickItem::ItemHasContents) {
-            updatePaintNodeData.transformNode = itemPriv->itemNode();
-            itemPriv->paintNode = item->updatePaintNode(itemPriv->paintNode, &updatePaintNodeData);
-
-            Q_ASSERT(itemPriv->paintNode == 0 ||
-                     itemPriv->paintNode->parent() == 0 ||
-                     itemPriv->paintNode->parent() == itemPriv->childContainerNode());
-
-            if (itemPriv->paintNode && itemPriv->paintNode->parent() == 0) {
-                if (itemPriv->extra.isAllocated() && itemPriv->extra->beforePaintNode)
-                    itemPriv->childContainerNode()->insertChildNodeAfter(itemPriv->paintNode, itemPriv->extra->beforePaintNode);
-                else
-                    itemPriv->childContainerNode()->prependChildNode(itemPriv->paintNode);
-            }
-        } else if (itemPriv->paintNode) {
-            delete itemPriv->paintNode;
-            itemPriv->paintNode = 0;
-        }
-    }
-
-#ifndef QT_NO_DEBUG
-    // Check consistency.
-    const QSGNode *nodeChain[] = {
-        itemPriv->itemNodeInstance,
-        itemPriv->opacityNode(),
-        itemPriv->clipNode(),
-        itemPriv->rootNode(),
-        itemPriv->groupNode,
-        itemPriv->paintNode,
-    };
-
-    int ip = 0;
-    for (;;) {
-        while (ip < 5 && nodeChain[ip] == 0)
-            ++ip;
-        if (ip == 5)
-            break;
-        int ic = ip + 1;
-        while (ic < 5 && nodeChain[ic] == 0)
-            ++ic;
-        const QSGNode *parent = nodeChain[ip];
-        const QSGNode *child = nodeChain[ic];
-        if (child == 0) {
-            Q_ASSERT(parent == itemPriv->groupNode || parent->childCount() == 0);
-        } else {
-            Q_ASSERT(parent == itemPriv->groupNode || parent->childCount() == 1);
-            Q_ASSERT(child->parent() == parent);
-            bool containsChild = false;
-            for (QSGNode *n = parent->firstChild(); n; n = n->nextSibling())
-                containsChild |= (n == child);
-            Q_ASSERT(containsChild);
-        }
-        ip = ic;
-    }
-#endif
-
-#ifdef QML_RUNTIME_TESTING
-    if (itemPriv->sceneGraphContext()->isFlashModeEnabled()) {
-        QSGFlashNode *flash = new QSGFlashNode();
-        flash->setRect(item->boundingRect());
-        itemPriv->childContainerNode()->appendChildNode(flash);
-        didFlash = true;
-    }
-    Q_Q(QQuickCanvas);
-    if (didFlash) {
-        q->maybeUpdate();
-    }
-#endif
-
-}
-
-void QQuickCanvas::maybeUpdate()
-{
-    Q_D(QQuickCanvas);
-    d->windowManager->maybeUpdate(this);
-}
-
-void QQuickCanvas::cleanupSceneGraph()
-{
-    Q_D(QQuickCanvas);
-
-    if (!d->renderer)
-        return;
-
-    delete d->renderer->rootNode();
-    delete d->renderer;
-
-    d->renderer = 0;
-}
-
-/*!
-    Returns the opengl context used for rendering.
-
-    If the scene graph is not ready, this function will return 0.
-
-    \sa sceneGraphInitialized(), sceneGraphInvalidated()
- */
-
-QOpenGLContext *QQuickCanvas::openglContext() const
-{
-    Q_D(const QQuickCanvas);
-    if (d->context->isReady())
-        return d->context->glContext();
-    return 0;
-}
-
-
-/*!
-    \fn void QSGContext::sceneGraphInitialized()
-
-    This signal is emitted when the scene graph has been initialized.
-
-    This signal will be emitted from the scene graph rendering thread.
-
- */
-
-
-/*!
-    \fn void QSGContext::sceneGraphInvalidated()
-
-    This signal is emitted when the scene graph has been invalidated.
-
-    This signal implies that the opengl rendering context used
-    has been invalidated and all user resources tied to that context
-    should be released.
-
-    This signal will be emitted from the scene graph rendering thread.
- */
-
-
-/*!
-    Sets the render target for this canvas to be \a fbo.
-
-    The specified fbo must be created in the context of the canvas
-    or one that shares with it.
-
-    \warning
-    This function can only be called from the thread doing
-    the rendering.
- */
-
-void QQuickCanvas::setRenderTarget(QOpenGLFramebufferObject *fbo)
-{
-    Q_D(QQuickCanvas);
-    if (d->context && d->context && QThread::currentThread() != d->context->thread()) {
-        qWarning("QQuickCanvas::setRenderThread: Cannot set render target from outside the rendering thread");
-        return;
-    }
-
-    d->renderTarget = fbo;
-    if (fbo) {
-        d->renderTargetId = fbo->handle();
-        d->renderTargetSize = fbo->size();
-    } else {
-        d->renderTargetId = 0;
-        d->renderTargetSize = QSize();
-    }
-}
-
-/*!
-    \overload
- */
-void QQuickCanvas::setRenderTarget(uint fboId, const QSize &size)
-{
-    Q_D(QQuickCanvas);
-    if (d->context && d->context && QThread::currentThread() != d->context->thread()) {
-        qWarning("QQuickCanvas::setRenderThread: Cannot set render target from outside the rendering thread");
-        return;
-    }
-
-    d->renderTargetId = fboId;
-    d->renderTargetSize = size;
-
-    // Unset any previously set instance...
-    d->renderTarget = 0;
-}
-
-
-/*!
-    Returns the FBO id of the render target when set; otherwise returns 0.
- */
-uint QQuickCanvas::renderTargetId() const
-{
-    Q_D(const QQuickCanvas);
-    return d->renderTargetId;
-}
-
-/*!
-    Returns the size of the currently set render target; otherwise returns an enpty size.
- */
-QSize QQuickCanvas::renderTargetSize() const
-{
-    Q_D(const QQuickCanvas);
-    return d->renderTargetSize;
-}
-
-
-
-
-/*!
-    Returns the render target for this canvas.
-
-    The default is to render to the surface of the canvas, in which
-    case the render target is 0.
- */
-QOpenGLFramebufferObject *QQuickCanvas::renderTarget() const
-{
-    Q_D(const QQuickCanvas);
-    return d->renderTarget;
-}
-
-
-/*!
-    Grabs the contents of the framebuffer and returns it as an image.
-
-    This function might not work if the view is not visible.
-
-    \warning Calling this function will cause performance problems.
-
-    \warning This function can only be called from the GUI thread.
- */
-QImage QQuickCanvas::grabFrameBuffer()
-{
-    Q_D(QQuickCanvas);
-    return d->windowManager->grab(this);
-}
-
-/*!
-    Returns an incubation controller that splices incubation between frames
-    for this canvas. QQuickView automatically installs this controller for you,
-    otherwise you will need to install it yourself using \l{QQmlEngine::setIncubationController}
-
-    The controller is owned by the canvas and will be destroyed when the canvas
-    is deleted.
-*/
-QQmlIncubationController *QQuickCanvas::incubationController() const
-{
-    Q_D(const QQuickCanvas);
-
-    if (!d->incubationController)
-        d->incubationController = new QQuickCanvasIncubationController(const_cast<QQuickCanvasPrivate *>(d));
-    return d->incubationController;
-}
-
-
-
-/*!
-    \enum QQuickCanvas::CreateTextureOption
-
-    The CreateTextureOption enums are used to customize a texture is wrapped.
-
-    \value TextureHasAlphaChannel The texture has an alpha channel and should
-    be drawn using blending.
-
-    \value TextureHasMipmaps The texture has mipmaps and can be drawn with
-    mipmapping enabled.
-
-    \value TextureOwnsGLTexture The texture object owns the texture id and
-    will delete the GL texture when the texture object is deleted.
- */
-
-/*!
-    \fn void QQuickCanvas::beforeRendering()
-
-    This signal is emitted before the scene starts rendering.
-
-    Combined with the modes for clearing the background, this option
-    can be used to paint using raw GL under QML content.
-
-    The GL context used for rendering the scene graph will be bound
-    at this point.
-
-    \warning Since this signal is emitted from the scene graph rendering thread, the
-    receiver should be on the scene graph thread or the connection should be Qt::DirectConnection.
-
-    \warning Make very sure that a signal handler for beforeRendering leaves the GL
-    context in the same state as it was when the signal handler was entered. Failing to
-    do so can result in the scene not rendering properly.
-*/
-
-/*!
-    \fn void QQuickCanvas::afterRendering()
-
-    This signal is emitted after the scene has completed rendering, before swapbuffers is called.
-
-    This signal can be used to paint using raw GL on top of QML content,
-    or to do screen scraping of the current frame buffer.
-
-    The GL context used for rendering the scene graph will be bound at this point.
-
-    \warning Since this signal is emitted from the scene graph rendering thread, the
-    receiver should be on the scene graph thread or the connection should be Qt::DirectConnection.
-
-    \warning Make very sure that a signal handler for afterRendering() leaves the GL
-    context in the same state as it was when the signal handler was entered. Failing to
-    do so can result in the scene not rendering properly.
- */
-
-
-
-/*!
-    Sets weither the scene graph rendering of QML should clear the color buffer
-    before it starts rendering to \a enbled.
-
-    By disabling clearing of the color buffer, it is possible to do GL painting
-    under the scene graph.
-
-    The color buffer is cleared by default.
-
-    \sa beforeRendering()
- */
-
-void QQuickCanvas::setClearBeforeRendering(bool enabled)
-{
-    Q_D(QQuickCanvas);
-    d->clearBeforeRendering = enabled;
-}
-
-
-
-/*!
-    Returns weither clearing of the color buffer is done before rendering or not.
- */
-
-bool QQuickCanvas::clearBeforeRendering() const
-{
-    Q_D(const QQuickCanvas);
-    return d->clearBeforeRendering;
-}
-
-
-
-/*!
-    Creates a new QSGTexture from the supplied \a image. If the image has an
-    alpha channel, the corresponding texture will have an alpha channel.
-
-    The caller of the function is responsible for deleting the returned texture.
-    The actual GL texture will be deleted when the texture object is deleted.
-
-    Depending on the underlying implementation of the scene graph, the returned
-    texture may be part of an atlas. For code to be portable across implementations
-    one should always use the texture coordinates returned from
-    QSGTexture::normalizedTextureSubRect() when building geometry.
-
-    \warning This function will return 0 if the scene graph has not yet been
-    initialized.
-
-    \warning The returned texture is not memory managed by the scene graph and
-    must be explicitely deleted by the caller on the rendering thread.
-    This is acheived by deleting the texture from a QSGNode destructor
-    or by using deleteLater() in the case where the texture already has affinity
-    to the rendering thread.
-
-    This function can be called from any thread.
-
-    \sa sceneGraphInitialized()
- */
-
-QSGTexture *QQuickCanvas::createTextureFromImage(const QImage &image) const
-{
-    Q_D(const QQuickCanvas);
-    if (d->context && d->context->isReady())
-        return d->context->createTexture(image);
-    else
-        return 0;
-}
-
-
-
-/*!
-    Creates a new QSGTexture object from an existing GL texture \a id.
-
-    The caller of the function is responsible for deleting the returned texture.
-
-    Use \a options to customize the texture attributes.
-
-    \warning This function will return 0 if the scenegraph has not yet been
-    initialized.
-
-    \sa sceneGraphInitialized()
- */
-QSGTexture *QQuickCanvas::createTextureFromId(uint id, const QSize &size, CreateTextureOptions options) const
-{
-    Q_D(const QQuickCanvas);
-    if (d->context && d->context->isReady()) {
-        QSGPlainTexture *texture = new QSGPlainTexture();
-        texture->setTextureId(id);
-        texture->setHasAlphaChannel(options & TextureHasAlphaChannel);
-        texture->setHasMipmaps(options & TextureHasMipmaps);
-        texture->setOwnsTexture(options & TextureOwnsGLTexture);
-        texture->setTextureSize(size);
-        return texture;
-    }
-    return 0;
-}
-
-
-/*!
-    Sets the color used to clear the opengl context to \a color.
-
-    Setting the clear color has no effect when clearing is disabled.
-
-    \sa setClearBeforeRendering()
- */
-
-void QQuickCanvas::setClearColor(const QColor &color)
-{
-    Q_D(QQuickCanvas);
-    if (color == d->clearColor)
-        return;
-
-    d->clearColor = color;
-    emit clearColorChanged(color);
-}
-
-
-
-/*!
-    Returns the color used to clear the opengl context.
- */
-
-QColor QQuickCanvas::clearColor() const
-{
-    return d_func()->clearColor;
-}
-
-
-
-#include "moc_qquickcanvas.cpp"
-
-QT_END_NAMESPACE
diff --git a/src/quick/items/qquickcanvas.h b/src/quick/items/qquickcanvas.h
index 1d23996..aaeaca4 100644
--- a/src/quick/items/qquickcanvas.h
+++ b/src/quick/items/qquickcanvas.h
@@ -42,135 +42,16 @@
 #ifndef QQUICKCANVAS_H
 #define QQUICKCANVAS_H
 
-#include <QtQuick/qtquickglobal.h>
-#include <QtCore/qmetatype.h>
-#include <QtGui/qopengl.h>
-#include <QtGui/qwindow.h>
-#include <QtGui/qevent.h>
+#include "qquickwindow.h"
 
 QT_BEGIN_HEADER
 
 QT_BEGIN_NAMESPACE
 
-class QQuickItem;
-class QSGTexture;
-class QInputMethodEvent;
-class QQuickCanvasPrivate;
-class QOpenGLFramebufferObject;
-class QQmlIncubationController;
-class QInputMethodEvent;
-
-class Q_QUICK_EXPORT QQuickCanvas : public QWindow
-{
-    Q_OBJECT
-    Q_PRIVATE_PROPERTY(QQuickCanvas::d_func(), QQmlListProperty<QObject> data READ data DESIGNABLE false)
-    Q_PROPERTY(QColor color READ clearColor WRITE setClearColor NOTIFY clearColorChanged)
-    Q_CLASSINFO("DefaultProperty", "data")
-    Q_DECLARE_PRIVATE(QQuickCanvas)
-public:
-    enum CreateTextureOption {
-        TextureHasAlphaChannel  = 0x0001,
-        TextureHasMipmaps       = 0x0002,
-        TextureOwnsGLTexture    = 0x0004
-    };
-
-    Q_DECLARE_FLAGS(CreateTextureOptions, CreateTextureOption)
-
-    QQuickCanvas(QWindow *parent = 0);
-
-    virtual ~QQuickCanvas();
-
-    QQuickItem *rootItem() const;
-    QQuickItem *activeFocusItem() const;
-    QObject *focusObject() const;
-
-    QQuickItem *mouseGrabberItem() const;
-
-    bool sendEvent(QQuickItem *, QEvent *);
-
-    QImage grabFrameBuffer();
-
-    void setRenderTarget(QOpenGLFramebufferObject *fbo);
-    QOpenGLFramebufferObject *renderTarget() const;
-
-    void setRenderTarget(uint fboId, const QSize &size);
-    uint renderTargetId() const;
-    QSize renderTargetSize() const;
-
-    QQmlIncubationController *incubationController() const;
-
-#ifndef QT_NO_ACCESSIBILITY
-    virtual QAccessibleInterface *accessibleRoot() const;
-#endif
-
-    // Scene graph specific functions
-    QSGTexture *createTextureFromImage(const QImage &image) const;
-    QSGTexture *createTextureFromId(uint id, const QSize &size, CreateTextureOptions options = CreateTextureOption(0)) const;
-
-    void setClearBeforeRendering(bool enabled);
-    bool clearBeforeRendering() const;
-
-    void setClearColor(const QColor &color);
-    QColor clearColor() const;
-
-    void setPersistentOpenGLContext(bool persistent);
-    bool isPersistentOpenGLContext() const;
-
-    void setPersistentSceneGraph(bool persistent);
-    bool isPersistentSceneGraph() const;
-
-    QOpenGLContext *openglContext() const;
-
-Q_SIGNALS:
-    void frameSwapped();
-    void sceneGraphInitialized();
-    void sceneGraphInvalidated();
-    void beforeSynchronizing();
-    void beforeRendering();
-    void afterRendering();
-    void clearColorChanged(const QColor &);
-
-public Q_SLOTS:
-    void update();
-    void releaseResources();
-
-protected:
-    QQuickCanvas(QQuickCanvasPrivate &dd, QWindow *parent = 0);
-
-    virtual void exposeEvent(QExposeEvent *);
-    virtual void resizeEvent(QResizeEvent *);
-
-    virtual void showEvent(QShowEvent *);
-    virtual void hideEvent(QHideEvent *);
-
-    virtual void focusInEvent(QFocusEvent *);
-    virtual void focusOutEvent(QFocusEvent *);
-
-    virtual bool event(QEvent *);
-    virtual void keyPressEvent(QKeyEvent *);
-    virtual void keyReleaseEvent(QKeyEvent *);
-    virtual void mousePressEvent(QMouseEvent *);
-    virtual void mouseReleaseEvent(QMouseEvent *);
-    virtual void mouseDoubleClickEvent(QMouseEvent *);
-    virtual void mouseMoveEvent(QMouseEvent *);
-#ifndef QT_NO_WHEELEVENT
-    virtual void wheelEvent(QWheelEvent *);
-#endif
-
-private Q_SLOTS:
-    void maybeUpdate();
-    void cleanupSceneGraph();
-
-private:
-    friend class QQuickItem;
-    friend class QQuickCanvasRenderLoop;
-    Q_DISABLE_COPY(QQuickCanvas)
-};
+typedef QQuickWindow QQuickCanvas;
 
 QT_END_NAMESPACE
 
-Q_DECLARE_METATYPE(QQuickCanvas *)
-
 QT_END_HEADER
 
 #endif // QQUICKCANVAS_H
diff --git a/src/quick/items/qquickcanvas_p.h b/src/quick/items/qquickcanvas_p.h
deleted file mode 100644
index b93bf5a..0000000
--- a/src/quick/items/qquickcanvas_p.h
+++ /dev/null
@@ -1,224 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the QtQml module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QQUICKCANVAS_P_H
-#define QQUICKCANVAS_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "qquickitem.h"
-#include "qquickcanvas.h"
-#include <private/qqmlguard_p.h>
-
-#include <QtQuick/private/qsgcontext_p.h>
-#include <private/qquickdrag_p.h>
-
-#include <QtCore/qthread.h>
-#include <QtCore/qmutex.h>
-#include <QtCore/qwaitcondition.h>
-#include <private/qwindow_p.h>
-#include <private/qopengl_p.h>
-#include <qopenglcontext.h>
-#include <QtGui/qopenglframebufferobject.h>
-#include <QtGui/qevent.h>
-
-QT_BEGIN_NAMESPACE
-
-//Make it easy to identify and customize the root item if needed
-
-class QQuickWindowManager;
-
-class QQuickRootItem : public QQuickItem
-{
-    Q_OBJECT
-public:
-    QQuickRootItem();
-public Q_SLOTS:
-    void setWidth(int w) {QQuickItem::setWidth(qreal(w));}
-    void setHeight(int h) {QQuickItem::setHeight(qreal(h));}
-};
-
-class QQuickItemPrivate;
-class QQuickCanvasPrivate;
-
-class QTouchEvent;
-class QQuickCanvasRenderLoop;
-class QQuickCanvasIncubationController;
-
-class Q_QUICK_PRIVATE_EXPORT QQuickCanvasPrivate : public QWindowPrivate
-{
-public:
-    Q_DECLARE_PUBLIC(QQuickCanvas)
-
-    static inline QQuickCanvasPrivate *get(QQuickCanvas *c) { return c->d_func(); }
-
-    QQuickCanvasPrivate();
-    virtual ~QQuickCanvasPrivate();
-
-    void init(QQuickCanvas *);
-    void initRootItem();//Currently only used if items added in QML
-
-    QQuickRootItem *rootItem;
-    QSet<QQuickItem *> parentlessItems;
-    QQmlListProperty<QObject> data();
-
-    QQuickItem *activeFocusItem;
-
-    // Keeps track of the item currently receiving mouse events
-    QQuickItem *mouseGrabberItem;
-#ifndef QT_NO_DRAGANDDROP
-    QQuickDragGrabber dragGrabber;
-#endif
-    int touchMouseId;
-    ulong touchMousePressTimestamp;
-
-    // Mouse positions are saved in widget coordinates
-    QPointF lastMousePosition;
-    bool translateTouchToMouse(QQuickItem *item, QTouchEvent *event);
-    void translateTouchEvent(QTouchEvent *touchEvent);
-    static void transformTouchPoints(QList<QTouchEvent::TouchPoint> &touchPoints, const QTransform &transform);
-    static QMouseEvent *cloneMouseEvent(QMouseEvent *event, QPointF *transformedLocalPos = 0);
-    bool deliverInitialMousePressEvent(QQuickItem *, QMouseEvent *);
-    bool deliverMouseEvent(QMouseEvent *);
-    bool sendFilteredMouseEvent(QQuickItem *, QQuickItem *, QEvent *);
-    bool deliverWheelEvent(QQuickItem *, QWheelEvent *);
-    bool deliverTouchPoints(QQuickItem *, QTouchEvent *, const QList<QTouchEvent::TouchPoint> &, QSet<int> *,
-            QHash<QQuickItem *, QList<QTouchEvent::TouchPoint> > *);
-    bool deliverTouchEvent(QTouchEvent *);
-    bool deliverTouchCancelEvent(QTouchEvent *);
-    bool deliverHoverEvent(QQuickItem *, const QPointF &scenePos, const QPointF &lastScenePos, Qt::KeyboardModifiers modifiers, bool &accepted);
-    bool deliverMatchingPointsToItem(QQuickItem *item, QTouchEvent *event, QSet<int> *acceptedNewPoints, const QSet<int> &matchingNewPoints, const QList<QTouchEvent::TouchPoint> &matchingPoints);
-    QTouchEvent *touchEventForItemBounds(QQuickItem *target, const QTouchEvent &originalEvent);
-    QTouchEvent *touchEventWithPoints(const QTouchEvent &event, const QList<QTouchEvent::TouchPoint> &newPoints);
-    bool sendFilteredTouchEvent(QQuickItem *target, QQuickItem *item, QTouchEvent *event);
-    bool sendHoverEvent(QEvent::Type, QQuickItem *, const QPointF &scenePos, const QPointF &lastScenePos,
-                        Qt::KeyboardModifiers modifiers, bool accepted);
-    bool clearHover();
-#ifndef QT_NO_DRAGANDDROP
-    void deliverDragEvent(QQuickDragGrabber *, QEvent *);
-    bool deliverDragEvent(QQuickDragGrabber *, QQuickItem *, QDragMoveEvent *);
-#endif
-
-    QList<QQuickItem*> hoverItems;
-    enum FocusOption {
-        DontChangeFocusProperty = 0x01,
-        DontChangeSubFocusItem  = 0x02
-    };
-    Q_DECLARE_FLAGS(FocusOptions, FocusOption)
-
-    void setFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions = 0);
-    void clearFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions = 0);
-    static void notifyFocusChangesRecur(QQuickItem **item, int remaining);
-
-    void updateFocusItemTransform();
-
-    void dirtyItem(QQuickItem *);
-    void cleanup(QSGNode *);
-
-    void polishItems();
-    void syncSceneGraph();
-    void renderSceneGraph(const QSize &size);
-
-    bool renderWithoutShowing;
-    void setRenderWithoutShowing(bool enabled);
-
-    QQuickItem::UpdatePaintNodeData updatePaintNodeData;
-
-    QQuickItem *dirtyItemList;
-    QList<QSGNode *> cleanupNodeList;
-
-    QSet<QQuickItem *> itemsToPolish;
-
-    void updateDirtyNodes();
-    void cleanupNodes();
-    void cleanupNodesOnShutdown();
-    bool updateEffectiveOpacity(QQuickItem *);
-    void updateEffectiveOpacityRoot(QQuickItem *, qreal);
-    void updateDirtyNode(QQuickItem *);
-
-    void fireFrameSwapped() { emit q_func()->frameSwapped(); }
-
-    QSGContext *context;
-    QSGRenderer *renderer;
-
-    QQuickWindowManager *windowManager;
-
-    QColor clearColor;
-
-    uint clearBeforeRendering : 1;
-
-    // Currently unused in the default implementation, as we're not stopping
-    // rendering when obscured as we should...
-    uint persistentGLContext : 1;
-    uint persistentSceneGraph : 1;
-
-    uint lastWheelEventAccepted : 1;
-
-    QOpenGLFramebufferObject *renderTarget;
-    uint renderTargetId;
-    QSize renderTargetSize;
-
-    // Keeps track of which touch point (int) was last accepted by which item
-    QHash<int, QQuickItem *> itemForTouchPointId;
-
-    mutable QQuickCanvasIncubationController *incubationController;
-
-    static bool dragOverThreshold(qreal d, Qt::Axis axis, QMouseEvent *event);
-
-private:
-    static void cleanupNodesOnShutdown(QQuickItem *);
-};
-
-
-Q_DECLARE_OPERATORS_FOR_FLAGS(QQuickCanvasPrivate::FocusOptions)
-
-QT_END_NAMESPACE
-
-#endif // QQUICKCANVAS_P_H
diff --git a/src/quick/items/qquickdrag.cpp b/src/quick/items/qquickdrag.cpp
index 065a97e..972b913 100644
--- a/src/quick/items/qquickdrag.cpp
+++ b/src/quick/items/qquickdrag.cpp
@@ -82,7 +82,7 @@ public:
     void deliverEnterEvent();
     void deliverMoveEvent();
     void deliverLeaveEvent();
-    void deliverEvent(QQuickCanvas *canvas, QEvent *event);
+    void deliverEvent(QQuickWindow *window, QEvent *event);
     void start() { start(supportedActions); }
     void start(Qt::DropActions supportedActions);
     void setTarget(QQuickItem *item);
@@ -91,7 +91,7 @@ public:
 
     QQmlGuard<QObject> source;
     QQmlGuard<QObject> target;
-    QQmlGuard<QQuickCanvas> canvas;
+    QQmlGuard<QQuickWindow> window;
     QQuickItem *attachedItem;
     QQuickDragMimeData *mimeData;
     Qt::DropAction proposedAction;
@@ -147,11 +147,11 @@ void QQuickDragAttachedPrivate::itemParentChanged(QQuickItem *, QQuickItem *)
     if (!active || dragRestarted)
         return;
 
-    QQuickCanvas *newCanvas = attachedItem->canvas();
+    QQuickWindow *newWindow = attachedItem->window();
 
-    if (canvas != newCanvas)
+    if (window != newWindow)
         restartDrag();
-    else if (canvas)
+    else if (window)
         updatePosition();
 }
 
@@ -180,18 +180,18 @@ void QQuickDragAttachedPrivate::deliverEnterEvent()
     dragRestarted = false;
     itemMoved = false;
 
-    canvas = attachedItem->canvas();
+    window = attachedItem->window();
 
     mimeData->m_source = source;
     if (!overrideActions)
         mimeData->m_supportedActions = supportedActions;
     mimeData->m_keys = keys;
 
-    if (canvas) {
+    if (window) {
         QPoint scenePos = attachedItem->mapToScene(hotSpot).toPoint();
         QDragEnterEvent event(scenePos, mimeData->m_supportedActions, mimeData, Qt::NoButton, Qt::NoModifier);
         QQuickDropEventEx::setProposedAction(&event, proposedAction);
-        deliverEvent(canvas, &event);
+        deliverEvent(window, &event);
     }
 }
 
@@ -200,11 +200,11 @@ void QQuickDragAttachedPrivate::deliverMoveEvent()
     Q_Q(QQuickDragAttached);
 
     itemMoved = false;
-    if (canvas) {
+    if (window) {
         QPoint scenePos = attachedItem->mapToScene(hotSpot).toPoint();
         QDragMoveEvent event(scenePos, mimeData->m_supportedActions, mimeData, Qt::NoButton, Qt::NoModifier);
         QQuickDropEventEx::setProposedAction(&event, proposedAction);
-        deliverEvent(canvas, &event);
+        deliverEvent(window, &event);
         if (target != dragGrabber.target()) {
             target = dragGrabber.target();
             emit q->targetChanged();
@@ -214,18 +214,18 @@ void QQuickDragAttachedPrivate::deliverMoveEvent()
 
 void QQuickDragAttachedPrivate::deliverLeaveEvent()
 {
-    if (canvas) {
+    if (window) {
         QDragLeaveEvent event;
-        deliverEvent(canvas, &event);
-        canvas = 0;
+        deliverEvent(window, &event);
+        window = 0;
     }
 }
 
-void QQuickDragAttachedPrivate::deliverEvent(QQuickCanvas *canvas, QEvent *event)
+void QQuickDragAttachedPrivate::deliverEvent(QQuickWindow *window, QEvent *event)
 {
     Q_ASSERT(!inEvent);
     inEvent = true;
-    QQuickCanvasPrivate::get(canvas)->deliverDragEvent(&dragGrabber, event);
+    QQuickWindowPrivate::get(window)->deliverDragEvent(&dragGrabber, event);
     inEvent = false;
 }
 
@@ -564,13 +564,13 @@ int QQuickDragAttached::drop()
 
     QObject *target = 0;
 
-    if (d->canvas) {
+    if (d->window) {
         QPoint scenePos = d->attachedItem->mapToScene(d->hotSpot).toPoint();
 
         QDropEvent event(
                 scenePos, d->mimeData->m_supportedActions, d->mimeData, Qt::NoButton, Qt::NoModifier);
         QQuickDropEventEx::setProposedAction(&event, d->proposedAction);
-        d->deliverEvent(d->canvas, &event);
+        d->deliverEvent(d->window, &event);
 
         if (event.isAccepted()) {
             acceptedAction = event.dropAction();
diff --git a/src/quick/items/qquickdroparea.cpp b/src/quick/items/qquickdroparea.cpp
index ee89098..1892a43 100644
--- a/src/quick/items/qquickdroparea.cpp
+++ b/src/quick/items/qquickdroparea.cpp
@@ -42,7 +42,7 @@
 #include "qquickdroparea_p.h"
 #include "qquickdrag_p.h"
 #include "qquickitem_p.h"
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 
 #include <private/qqmlengine_p.h>
 
diff --git a/src/quick/items/qquickflickable.cpp b/src/quick/items/qquickflickable.cpp
index 4a5df1d..001abe3 100644
--- a/src/quick/items/qquickflickable.cpp
+++ b/src/quick/items/qquickflickable.cpp
@@ -41,8 +41,8 @@
 
 #include "qquickflickable_p.h"
 #include "qquickflickable_p_p.h"
-#include "qquickcanvas.h"
-#include "qquickcanvas_p.h"
+#include "qquickwindow.h"
+#include "qquickwindow_p.h"
 #include "qquickevents_p_p.h"
 
 #include <QtQuick/private/qquicktransition_p.h>
@@ -1007,7 +1007,7 @@ void QQuickFlickablePrivate::handleMouseMoveEvent(QMouseEvent *event)
     qint64 elapsedSincePress = computeCurrentTime(event) - lastPressTime;
     if (q->yflick()) {
         qreal dy = event->localPos().y() - pressPos.y();
-        bool overThreshold = QQuickCanvasPrivate::dragOverThreshold(dy, Qt::YAxis, event);
+        bool overThreshold = QQuickWindowPrivate::dragOverThreshold(dy, Qt::YAxis, event);
         if (overThreshold || elapsedSincePress > 200) {
             if (!vMoved)
                 vData.dragStartOffset = dy;
@@ -1041,7 +1041,7 @@ void QQuickFlickablePrivate::handleMouseMoveEvent(QMouseEvent *event)
 
     if (q->xflick()) {
         qreal dx = event->localPos().x() - pressPos.x();
-        bool overThreshold = QQuickCanvasPrivate::dragOverThreshold(dx, Qt::XAxis, event);
+        bool overThreshold = QQuickWindowPrivate::dragOverThreshold(dx, Qt::XAxis, event);
         if (overThreshold || elapsedSincePress > 200) {
             if (!hMoved)
                 hData.dragStartOffset = dx;
@@ -1226,7 +1226,7 @@ void QQuickFlickable::mouseReleaseEvent(QMouseEvent *event)
         d->clearDelayedPress();
         d->handleMouseReleaseEvent(event);
         event->accept();
-        if (canvas() && canvas()->mouseGrabberItem() == this)
+        if (window() && window()->mouseGrabberItem() == this)
             ungrabMouse();
     } else {
         QQuickItem::mouseReleaseEvent(event);
@@ -1305,12 +1305,12 @@ bool QQuickFlickablePrivate::isOutermostPressDelay() const
 void QQuickFlickablePrivate::captureDelayedPress(QMouseEvent *event)
 {
     Q_Q(QQuickFlickable);
-    if (!q->canvas() || pressDelay <= 0)
+    if (!q->window() || pressDelay <= 0)
         return;
     if (!isOutermostPressDelay())
         return;
-    delayedPressTarget = q->canvas()->mouseGrabberItem();
-    delayedPressEvent = QQuickCanvasPrivate::cloneMouseEvent(event);
+    delayedPressTarget = q->window()->mouseGrabberItem();
+    delayedPressEvent = QQuickWindowPrivate::cloneMouseEvent(event);
     delayedPressEvent->setAccepted(false);
     delayedPressTimer.start(pressDelay, q);
 }
@@ -1341,14 +1341,14 @@ void QQuickFlickable::timerEvent(QTimerEvent *event)
     if (event->timerId() == d->delayedPressTimer.timerId()) {
         d->delayedPressTimer.stop();
         if (d->delayedPressEvent) {
-            QQuickItem *grabber = canvas() ? canvas()->mouseGrabberItem() : 0;
+            QQuickItem *grabber = window() ? window()->mouseGrabberItem() : 0;
             if (!grabber || grabber != this) {
                 // We replay the mouse press but the grabber we had might not be interessted by the event (e.g. overlay)
                 // so we reset the grabber
-                if (canvas()->mouseGrabberItem() == d->delayedPressTarget)
+                if (window()->mouseGrabberItem() == d->delayedPressTarget)
                     d->delayedPressTarget->ungrabMouse();
                 // Use the event handler that will take care of finding the proper item to propagate the event
-                QQuickCanvasPrivate::get(canvas())->deliverMouseEvent(d->delayedPressEvent);
+                QQuickWindowPrivate::get(window())->deliverMouseEvent(d->delayedPressEvent);
             }
             delete d->delayedPressEvent;
             d->delayedPressEvent = 0;
@@ -1981,12 +1981,12 @@ bool QQuickFlickable::sendMouseEvent(QMouseEvent *event)
     Q_D(QQuickFlickable);
     QPointF localPos = mapFromScene(event->windowPos());
 
-    QQuickCanvas *c = canvas();
+    QQuickWindow *c = window();
     QQuickItem *grabber = c ? c->mouseGrabberItem() : 0;
     bool grabberDisabled = grabber && !grabber->isEnabled();
     bool stealThisEvent = d->stealMouse;
     if ((stealThisEvent || contains(localPos)) && (!grabber || !grabber->keepMouseGrab() || grabberDisabled)) {
-        QScopedPointer<QMouseEvent> mouseEvent(QQuickCanvasPrivate::cloneMouseEvent(event, &localPos));
+        QScopedPointer<QMouseEvent> mouseEvent(QQuickWindowPrivate::cloneMouseEvent(event, &localPos));
         mouseEvent->setAccepted(false);
 
         switch (mouseEvent->type()) {
@@ -2008,10 +2008,10 @@ bool QQuickFlickable::sendMouseEvent(QMouseEvent *event)
                 if (c->mouseGrabberItem() == d->delayedPressTarget)
                     d->delayedPressTarget->ungrabMouse();
                 // Use the event handler that will take care of finding the proper item to propagate the event
-                QQuickCanvasPrivate::get(canvas())->deliverMouseEvent(d->delayedPressEvent);
+                QQuickWindowPrivate::get(window())->deliverMouseEvent(d->delayedPressEvent);
                 d->clearDelayedPress();
                 // We send the release
-                canvas()->sendEvent(c->mouseGrabberItem(), event);
+                window()->sendEvent(c->mouseGrabberItem(), event);
                 // And the event has been consumed
                 d->stealMouse = false;
                 d->pressed = false;
@@ -2054,7 +2054,7 @@ bool QQuickFlickable::childMouseEventFilter(QQuickItem *i, QEvent *e)
     case QEvent::MouseButtonRelease:
         return sendMouseEvent(static_cast<QMouseEvent *>(e));
     case QEvent::UngrabMouse:
-        if (d->canvas && d->canvas->mouseGrabberItem() && d->canvas->mouseGrabberItem() != this) {
+        if (d->window && d->window->mouseGrabberItem() && d->window->mouseGrabberItem() != this) {
             // The grab has been taken away from a child and given to some other item.
             mouseUngrabEvent();
         }
diff --git a/src/quick/items/qquickimage.cpp b/src/quick/items/qquickimage.cpp
index 141e643..4279e27 100644
--- a/src/quick/items/qquickimage.cpp
+++ b/src/quick/items/qquickimage.cpp
@@ -536,7 +536,7 @@ QSGTextureProvider *QQuickImage::textureProvider() const
     Q_D(const QQuickImage);
     if (!d->provider) {
         // Make sure it gets thread affinity on the rendering thread so deletion works properly..
-        Q_ASSERT_X(d->canvas
+        Q_ASSERT_X(d->window
                    && d->sceneGraphContext()
                    && QThread::currentThread() == d->sceneGraphContext()->thread(),
                    "QQuickImage::textureProvider",
@@ -544,7 +544,7 @@ QSGTextureProvider *QQuickImage::textureProvider() const
         QQuickImagePrivate *dd = const_cast<QQuickImagePrivate *>(d);
         dd->provider = new QQuickImageTextureProvider;
         dd->provider->m_smooth = d->smooth;
-        dd->provider->m_texture = d->sceneGraphContext()->textureForFactory(d->pix.textureFactory(), canvas());
+        dd->provider->m_texture = d->sceneGraphContext()->textureForFactory(d->pix.textureFactory(), window());
     }
 
     return d->provider;
@@ -554,7 +554,7 @@ QSGNode *QQuickImage::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *)
 {
     Q_D(QQuickImage);
 
-    QSGTexture *texture = d->sceneGraphContext()->textureForFactory(d->pix.textureFactory(), canvas());
+    QSGTexture *texture = d->sceneGraphContext()->textureForFactory(d->pix.textureFactory(), window());
 
     // Copy over the current texture state into the texture provider...
     if (d->provider) {
diff --git a/src/quick/items/qquickitem.cpp b/src/quick/items/qquickitem.cpp
index 0d5518c..667b919 100644
--- a/src/quick/items/qquickitem.cpp
+++ b/src/quick/items/qquickitem.cpp
@@ -41,9 +41,9 @@
 
 #include "qquickitem.h"
 
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 #include <QtQml/qjsengine.h>
-#include "qquickcanvas_p.h"
+#include "qquickwindow_p.h"
 
 #include "qquickevents_p_p.h"
 #include "qquickscreen_p.h"
@@ -1352,12 +1352,12 @@ void QQuickKeysAttached::keyPressed(QKeyEvent *event, bool post)
     }
 
     // first process forwards
-    if (d->item && d->item->canvas()) {
+    if (d->item && d->item->window()) {
         d->inPress = true;
         for (int ii = 0; ii < d->targets.count(); ++ii) {
             QQuickItem *i = d->targets.at(ii);
             if (i && i->isVisible()) {
-                d->item->canvas()->sendEvent(i, event);
+                d->item->window()->sendEvent(i, event);
                 if (event->isAccepted()) {
                     d->inPress = false;
                     return;
@@ -1394,12 +1394,12 @@ void QQuickKeysAttached::keyReleased(QKeyEvent *event, bool post)
         return;
     }
 
-    if (d->item && d->item->canvas()) {
+    if (d->item && d->item->window()) {
         d->inRelease = true;
         for (int ii = 0; ii < d->targets.count(); ++ii) {
             QQuickItem *i = d->targets.at(ii);
             if (i && i->isVisible()) {
-                d->item->canvas()->sendEvent(i, event);
+                d->item->window()->sendEvent(i, event);
                 if (event->isAccepted()) {
                     d->inRelease = false;
                     return;
@@ -1419,12 +1419,12 @@ void QQuickKeysAttached::keyReleased(QKeyEvent *event, bool post)
 void QQuickKeysAttached::inputMethodEvent(QInputMethodEvent *event, bool post)
 {
     Q_D(QQuickKeysAttached);
-    if (post == m_processPost && d->item && !d->inIM && d->item->canvas()) {
+    if (post == m_processPost && d->item && !d->inIM && d->item->window()) {
         d->inIM = true;
         for (int ii = 0; ii < d->targets.count(); ++ii) {
             QQuickItem *i = d->targets.at(ii);
             if (i && i->isVisible() && (i->flags() & QQuickItem::ItemAcceptsInputMethod)) {
-                d->item->canvas()->sendEvent(i, event);
+                d->item->window()->sendEvent(i, event);
                 if (event->isAccepted()) {
                     d->imeItem = i;
                     d->inIM = false;
@@ -1714,7 +1714,7 @@ void QQuickItemPrivate::updateSubFocusItem(QQuickItem *scope, bool focus)
     surface. Using scene graph API directly is always significantly
     faster.
 
-    \sa QQuickCanvas, QQuickPaintedItem
+    \sa QQuickWindow, QQuickPaintedItem
 */
 
 /*!
@@ -1872,12 +1872,12 @@ QQuickItem::~QQuickItem()
 
     Q_D(QQuickItem);
 
-    if (d->canvasRefCount > 1)
-        d->canvasRefCount = 1; // Make sure canvas is set to null in next call to derefCanvas().
+    if (d->windowRefCount > 1)
+        d->windowRefCount = 1; // Make sure window is set to null in next call to derefWindow().
     if (d->parentItem)
         setParentItem(0);
-    else if (d->canvas)
-        d->derefCanvas();
+    else if (d->window)
+        d->derefWindow();
 
     // XXX todo - optimize
     while (!d->childItems.isEmpty())
@@ -1984,9 +1984,9 @@ void QQuickItem::setParentItem(QQuickItem *parentItem)
             scopeItem = oldParentItem;
             while (!scopeItem->isFocusScope() && scopeItem->parentItem())
                 scopeItem = scopeItem->parentItem();
-            if (d->canvas) {
-                QQuickCanvasPrivate::get(d->canvas)->clearFocusInScope(scopeItem, scopeFocusedItem,
-                                                                QQuickCanvasPrivate::DontChangeFocusProperty);
+            if (d->window) {
+                QQuickWindowPrivate::get(d->window)->clearFocusInScope(scopeItem, scopeFocusedItem,
+                                                                QQuickWindowPrivate::DontChangeFocusProperty);
                 if (scopeFocusedItem != this)
                     QQuickItemPrivate::get(scopeFocusedItem)->updateSubFocusItem(this, true);
             } else {
@@ -1999,29 +1999,29 @@ void QQuickItem::setParentItem(QQuickItem *parentItem)
         if (wasVisible) {
             emit oldParentItem->visibleChildrenChanged();
         }
-    } else if (d->canvas) {
-        QQuickCanvasPrivate::get(d->canvas)->parentlessItems.remove(this);
+    } else if (d->window) {
+        QQuickWindowPrivate::get(d->window)->parentlessItems.remove(this);
     }
 
-    QQuickCanvas *oldParentCanvas = oldParentItem ? QQuickItemPrivate::get(oldParentItem)->canvas : 0;
-    QQuickCanvas *parentCanvas = parentItem ? QQuickItemPrivate::get(parentItem)->canvas : 0;
-    if (oldParentCanvas == parentCanvas) {
-        // Avoid freeing and reallocating resources if the canvas stays the same.
+    QQuickWindow *oldParentWindow = oldParentItem ? QQuickItemPrivate::get(oldParentItem)->window : 0;
+    QQuickWindow *parentWindow = parentItem ? QQuickItemPrivate::get(parentItem)->window : 0;
+    if (oldParentWindow == parentWindow) {
+        // Avoid freeing and reallocating resources if the window stays the same.
         d->parentItem = parentItem;
     } else {
-        if (oldParentCanvas)
-            d->derefCanvas();
+        if (oldParentWindow)
+            d->derefWindow();
         d->parentItem = parentItem;
-        if (parentCanvas)
-            d->refCanvas(parentCanvas);
+        if (parentWindow)
+            d->refWindow(parentWindow);
     }
 
     d->dirty(QQuickItemPrivate::ParentChanged);
 
     if (d->parentItem)
         QQuickItemPrivate::get(d->parentItem)->addChild(this);
-    else if (d->canvas)
-        QQuickCanvasPrivate::get(d->canvas)->parentlessItems.insert(this);
+    else if (d->window)
+        QQuickWindowPrivate::get(d->window)->parentlessItems.insert(this);
 
     d->setEffectiveVisibleRecur(d->calcEffectiveVisible());
     d->setEffectiveEnableRecur(0, d->calcEffectiveEnable());
@@ -2047,9 +2047,9 @@ void QQuickItem::setParentItem(QQuickItem *parentItem)
                 QQuickItemPrivate::get(scopeFocusedItem)->focus = false;
                 emit scopeFocusedItem->focusChanged(false);
             } else {
-                if (d->canvas) {
-                    QQuickCanvasPrivate::get(d->canvas)->setFocusInScope(scopeItem, scopeFocusedItem,
-                                                                  QQuickCanvasPrivate::DontChangeFocusProperty);
+                if (d->window) {
+                    QQuickWindowPrivate::get(d->window)->setFocusInScope(scopeItem, scopeFocusedItem,
+                                                                  QQuickWindowPrivate::DontChangeFocusProperty);
                 } else {
                     QQuickItemPrivate::get(scopeFocusedItem)->updateSubFocusItem(scopeItem, true);
                 }
@@ -2134,10 +2134,10 @@ QQuickItem *QQuickItem::parentItem() const
     return d->parentItem;
 }
 
-QQuickCanvas *QQuickItem::canvas() const
+QQuickWindow *QQuickItem::window() const
 {
     Q_D(const QQuickItem);
-    return d->canvas;
+    return d->window;
 }
 
 static bool itemZOrder_sort(QQuickItem *lhs, QQuickItem *rhs)
@@ -2203,61 +2203,61 @@ void QQuickItemPrivate::removeChild(QQuickItem *child)
     emit q->childrenChanged();
 }
 
-void QQuickItemPrivate::refCanvas(QQuickCanvas *c)
+void QQuickItemPrivate::refWindow(QQuickWindow *c)
 {
-    // An item needs a canvas if it is referenced by another item which has a canvas.
+    // An item needs a window if it is referenced by another item which has a window.
     // Typically the item is referenced by a parent, but can also be referenced by a
-    // ShaderEffect or ShaderEffectSource. 'canvasRefCount' counts how many items with
-    // a canvas is referencing this item. When the reference count goes from zero to one,
-    // or one to zero, the canvas of this item is updated and propagated to the children.
-    // As long as the reference count stays above zero, the canvas is unchanged.
-    // refCanvas() increments the reference count.
-    // derefCanvas() decrements the reference count.
+    // ShaderEffect or ShaderEffectSource. 'windowRefCount' counts how many items with
+    // a window is referencing this item. When the reference count goes from zero to one,
+    // or one to zero, the window of this item is updated and propagated to the children.
+    // As long as the reference count stays above zero, the window is unchanged.
+    // refWindow() increments the reference count.
+    // derefWindow() decrements the reference count.
 
     Q_Q(QQuickItem);
-    Q_ASSERT((canvas != 0) == (canvasRefCount > 0));
+    Q_ASSERT((window != 0) == (windowRefCount > 0));
     Q_ASSERT(c);
-    if (++canvasRefCount > 1) {
-        if (c != canvas)
-            qWarning("QQuickItem: Cannot use same item on different canvases at the same time.");
-        return; // Canvas already set.
+    if (++windowRefCount > 1) {
+        if (c != window)
+            qWarning("QQuickItem: Cannot use same item on different windows at the same time.");
+        return; // Window already set.
     }
 
-    Q_ASSERT(canvas == 0);
-    canvas = c;
+    Q_ASSERT(window == 0);
+    window = c;
 
     if (polishScheduled)
-        QQuickCanvasPrivate::get(canvas)->itemsToPolish.insert(q);
+        QQuickWindowPrivate::get(window)->itemsToPolish.insert(q);
 
     if (!parentItem)
-        QQuickCanvasPrivate::get(canvas)->parentlessItems.insert(q);
+        QQuickWindowPrivate::get(window)->parentlessItems.insert(q);
 
     for (int ii = 0; ii < childItems.count(); ++ii) {
         QQuickItem *child = childItems.at(ii);
-        QQuickItemPrivate::get(child)->refCanvas(c);
+        QQuickItemPrivate::get(child)->refWindow(c);
     }
 
-    dirty(Canvas);
+    dirty(Window);
 
     if (extra.isAllocated() && extra->screenAttached)
-        extra->screenAttached->canvasChanged(c);
+        extra->screenAttached->windowChanged(c);
     itemChange(QQuickItem::ItemSceneChange, c);
 }
 
-void QQuickItemPrivate::derefCanvas()
+void QQuickItemPrivate::derefWindow()
 {
     Q_Q(QQuickItem);
-    Q_ASSERT((canvas != 0) == (canvasRefCount > 0));
+    Q_ASSERT((window != 0) == (windowRefCount > 0));
 
-    if (!canvas)
+    if (!window)
         return; // This can happen when destroying recursive shader effect sources.
 
-    if (--canvasRefCount > 0)
-        return; // There are still other references, so don't set canvas to null yet.
+    if (--windowRefCount > 0)
+        return; // There are still other references, so don't set window to null yet.
 
     q->releaseResources();
     removeFromDirtyList();
-    QQuickCanvasPrivate *c = QQuickCanvasPrivate::get(canvas);
+    QQuickWindowPrivate *c = QQuickWindowPrivate::get(window);
     if (polishScheduled)
         c->itemsToPolish.remove(q);
     QMutableHashIterator<int, QQuickItem *> itemTouchMapIt(c->itemForTouchPointId);
@@ -2274,7 +2274,7 @@ void QQuickItemPrivate::derefCanvas()
     if (!parentItem)
         c->parentlessItems.remove(q);
 
-    canvas = 0;
+    window = 0;
 
     itemNodeInstance = 0;
 
@@ -2290,33 +2290,33 @@ void QQuickItemPrivate::derefCanvas()
 
     for (int ii = 0; ii < childItems.count(); ++ii) {
         QQuickItem *child = childItems.at(ii);
-        QQuickItemPrivate::get(child)->derefCanvas();
+        QQuickItemPrivate::get(child)->derefWindow();
     }
 
-    dirty(Canvas);
+    dirty(Window);
 
     if (extra.isAllocated() && extra->screenAttached)
-        extra->screenAttached->canvasChanged(0);
-    itemChange(QQuickItem::ItemSceneChange, (QQuickCanvas *)0);
+        extra->screenAttached->windowChanged(0);
+    itemChange(QQuickItem::ItemSceneChange, (QQuickWindow *)0);
 }
 
 
 /*!
-Returns a transform that maps points from canvas space into item space.
+Returns a transform that maps points from window space into item space.
 */
-QTransform QQuickItemPrivate::canvasToItemTransform() const
+QTransform QQuickItemPrivate::windowToItemTransform() const
 {
     // XXX todo - optimize
-    return itemToCanvasTransform().inverted();
+    return itemToWindowTransform().inverted();
 }
 
 /*!
-Returns a transform that maps points from item space into canvas space.
+Returns a transform that maps points from item space into window space.
 */
-QTransform QQuickItemPrivate::itemToCanvasTransform() const
+QTransform QQuickItemPrivate::itemToWindowTransform() const
 {
     // XXX todo
-    QTransform rv = parentItem?QQuickItemPrivate::get(parentItem)->itemToCanvasTransform():QTransform();
+    QTransform rv = parentItem?QQuickItemPrivate::get(parentItem)->itemToWindowTransform():QTransform();
     itemToParentTransform(rv);
     return rv;
 }
@@ -2433,8 +2433,8 @@ QQuickItemPrivate::QQuickItemPrivate()
     , dirtyAttributes(0)
     , nextDirtyItem(0)
     , prevDirtyItem(0)
-    , canvas(0)
-    , canvasRefCount(0)
+    , window(0)
+    , windowRefCount(0)
     , parentItem(0)
     , sortedChildItems(&childItems)
     , subFocusItem(0)
@@ -3132,7 +3132,7 @@ QSGNode *QQuickItem::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *)
 /*!
     This function is called when the item's scene graph resources are no longer needed.
     It allows items to free its resources, for instance textures, that are not owned by scene graph
-    nodes. Note that scene graph nodes are managed by QQuickCanvas and should not be deleted by
+    nodes. Note that scene graph nodes are managed by QQuickWindow and should not be deleted by
     this function. Scene graph resources are no longer needed when the parent is set to null and
     the item is not used by any \l ShaderEffect or \l ShaderEffectSource.
 
@@ -3414,7 +3414,7 @@ void QQuickItem::setBaselineOffset(qreal offset)
  * Schedules a call to updatePaintNode() for this item.
  *
  * The call to QQuickItem::updatePaintNode() will always happen if the
- * item is showing in a QQuickCanvas.
+ * item is showing in a QQuickWindow.
  *
  * Only items which specifies QQuickItem::ItemHasContents are allowed
  * to call QQuickItem::update().
@@ -3431,11 +3431,11 @@ void QQuickItem::polish()
     Q_D(QQuickItem);
     if (!d->polishScheduled) {
         d->polishScheduled = true;
-        if (d->canvas) {
-            QQuickCanvasPrivate *p = QQuickCanvasPrivate::get(d->canvas);
+        if (d->window) {
+            QQuickWindowPrivate *p = QQuickWindowPrivate::get(d->window);
             bool maybeupdate = p->itemsToPolish.isEmpty();
             p->itemsToPolish.insert(this);
-            if (maybeupdate) d->canvas->maybeUpdate();
+            if (maybeupdate) d->window->maybeUpdate();
         }
     }
 }
@@ -3500,8 +3500,8 @@ QTransform QQuickItem::itemTransform(QQuickItem *other, bool *ok) const
     // invalid cases
     if (ok) *ok = true;
 
-    QTransform t = d->itemToCanvasTransform();
-    if (other) t *= QQuickItemPrivate::get(other)->canvasToItemTransform();
+    QTransform t = d->itemToWindowTransform();
+    if (other) t *= QQuickItemPrivate::get(other)->windowToItemTransform();
 
     return t;
 }
@@ -3701,9 +3701,9 @@ void QQuickItem::componentComplete()
     if (d->extra.isAllocated() && d->extra->contents)
         d->extra->contents->complete();
 
-    if (d->canvas && d->dirtyAttributes) {
+    if (d->window && d->dirtyAttributes) {
         d->addToDirtyList();
-        QQuickCanvasPrivate::get(d->canvas)->dirtyItem(this);
+        QQuickWindowPrivate::get(d->window)->dirtyItem(this);
     }
 }
 
@@ -4249,9 +4249,9 @@ bool QQuickItemPrivate::setEffectiveVisibleRecur(bool newEffectiveVisible)
     dirty(Visible);
     if (parentItem) QQuickItemPrivate::get(parentItem)->dirty(ChildrenStackingChanged);
 
-    if (canvas) {
-        QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(canvas);
-        if (canvasPriv->mouseGrabberItem == q)
+    if (window) {
+        QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(window);
+        if (windowPriv->mouseGrabberItem == q)
             q->ungrabMouse();
     }
 
@@ -4297,13 +4297,13 @@ void QQuickItemPrivate::setEffectiveEnableRecur(QQuickItem *scope, bool newEffec
 
     effectiveEnable = newEffectiveEnable;
 
-    if (canvas) {
-        QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(canvas);
-        if (canvasPriv->mouseGrabberItem == q)
+    if (window) {
+        QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(window);
+        if (windowPriv->mouseGrabberItem == q)
             q->ungrabMouse();
         if (scope && !effectiveEnable && activeFocus) {
-            canvasPriv->clearFocusInScope(
-                    scope, q,  QQuickCanvasPrivate::DontChangeFocusProperty | QQuickCanvasPrivate::DontChangeSubFocusItem);
+            windowPriv->clearFocusInScope(
+                    scope, q,  QQuickWindowPrivate::DontChangeFocusProperty | QQuickWindowPrivate::DontChangeSubFocusItem);
         }
     }
 
@@ -4312,9 +4312,9 @@ void QQuickItemPrivate::setEffectiveEnableRecur(QQuickItem *scope, bool newEffec
                 (flags & QQuickItem::ItemIsFocusScope) && scope ? q : scope, newEffectiveEnable);
     }
 
-    if (canvas && scope && effectiveEnable && focus) {
-        QQuickCanvasPrivate::get(canvas)->setFocusInScope(
-                scope, q, QQuickCanvasPrivate::DontChangeFocusProperty | QQuickCanvasPrivate::DontChangeSubFocusItem);
+    if (window && scope && effectiveEnable && focus) {
+        QQuickWindowPrivate::get(window)->setFocusInScope(
+                scope, q, QQuickWindowPrivate::DontChangeFocusProperty | QQuickWindowPrivate::DontChangeSubFocusItem);
     }
 
     emit q->enabledChanged();
@@ -4344,7 +4344,7 @@ QString QQuickItemPrivate::dirtyToString() const
     DIRTY_TO_STRING(ChildrenStackingChanged);
     DIRTY_TO_STRING(ParentChanged);
     DIRTY_TO_STRING(Clip);
-    DIRTY_TO_STRING(Canvas);
+    DIRTY_TO_STRING(Window);
     DIRTY_TO_STRING(EffectReference);
     DIRTY_TO_STRING(Visible);
     DIRTY_TO_STRING(HideReference);
@@ -4359,11 +4359,11 @@ void QQuickItemPrivate::dirty(DirtyType type)
     if (type & (TransformOrigin | Transform | BasicTransform | Position | Size))
         transformChanged();
 
-    if (!(dirtyAttributes & type) || (canvas && !prevDirtyItem)) {
+    if (!(dirtyAttributes & type) || (window && !prevDirtyItem)) {
         dirtyAttributes |= type;
-        if (canvas && componentComplete) {
+        if (window && componentComplete) {
             addToDirtyList();
-            QQuickCanvasPrivate::get(canvas)->dirtyItem(q);
+            QQuickWindowPrivate::get(window)->dirtyItem(q);
         }
     }
 }
@@ -4372,11 +4372,11 @@ void QQuickItemPrivate::addToDirtyList()
 {
     Q_Q(QQuickItem);
 
-    Q_ASSERT(canvas);
+    Q_ASSERT(window);
     if (!prevDirtyItem) {
         Q_ASSERT(!nextDirtyItem);
 
-        QQuickCanvasPrivate *p = QQuickCanvasPrivate::get(canvas);
+        QQuickWindowPrivate *p = QQuickWindowPrivate::get(window);
         nextDirtyItem = p->dirtyItemList;
         if (nextDirtyItem) QQuickItemPrivate::get(nextDirtyItem)->prevDirtyItem = &nextDirtyItem;
         prevDirtyItem = &p->dirtyItemList;
@@ -4608,8 +4608,8 @@ void QQuickItem::setFlags(Flags flags)
     Q_D(QQuickItem);
 
     if ((flags & ItemIsFocusScope) != (d->flags & ItemIsFocusScope)) {
-        if (flags & ItemIsFocusScope && !d->childItems.isEmpty() && d->canvas) {
-            qWarning("QQuickItem: Cannot set FocusScope once item has children and is in a canvas.");
+        if (flags & ItemIsFocusScope && !d->childItems.isEmpty() && d->window) {
+            qWarning("QQuickItem: Cannot set FocusScope once item has children and is in a window.");
             flags &= ~ItemIsFocusScope;
         } else if (d->flags & ItemIsFocusScope) {
             qWarning("QQuickItem: Cannot unset FocusScope flag.");
@@ -4998,19 +4998,19 @@ void QQuickItem::setFocus(bool focus)
     if (d->focus == focus)
         return;
 
-    if (d->canvas || d->parentItem) {
+    if (d->window || d->parentItem) {
         // Need to find our nearest focus scope
         QQuickItem *scope = parentItem();
         while (scope && !scope->isFocusScope() && scope->parentItem())
             scope = scope->parentItem();
-        if (d->canvas) {
+        if (d->window) {
             if (focus)
-                QQuickCanvasPrivate::get(d->canvas)->setFocusInScope(scope, this);
+                QQuickWindowPrivate::get(d->window)->setFocusInScope(scope, this);
             else
-                QQuickCanvasPrivate::get(d->canvas)->clearFocusInScope(scope, this);
+                QQuickWindowPrivate::get(d->window)->clearFocusInScope(scope, this);
         } else {
             // do the focus changes from setFocusInScope/clearFocusInScope that are
-            // unrelated to a canvas
+            // unrelated to a window
             QVarLengthArray<QQuickItem *, 20> changed;
             QQuickItem *oldSubFocusItem = QQuickItemPrivate::get(scope)->subFocusItem;
             if (oldSubFocusItem) {
@@ -5027,7 +5027,7 @@ void QQuickItem::setFocus(bool focus)
             changed << this;
             emit focusChanged(focus);
 
-            QQuickCanvasPrivate::notifyFocusChangesRecur(changed.data(), changed.count() - 1);
+            QQuickWindowPrivate::notifyFocusChangesRecur(changed.data(), changed.count() - 1);
         }
     } else {
         QVarLengthArray<QQuickItem *, 20> changed;
@@ -5042,7 +5042,7 @@ void QQuickItem::setFocus(bool focus)
         changed << this;
         emit focusChanged(focus);
 
-        QQuickCanvasPrivate::notifyFocusChangesRecur(changed.data(), changed.count() - 1);
+        QQuickWindowPrivate::notifyFocusChangesRecur(changed.data(), changed.count() - 1);
     }
 }
 
@@ -5095,11 +5095,11 @@ void QQuickItem::setFiltersChildMouseEvents(bool filter)
 bool QQuickItem::isUnderMouse() const
 {
     Q_D(const QQuickItem);
-    if (!d->canvas)
+    if (!d->window)
         return false;
 
     QPointF cursorPos = QGuiApplicationPrivate::lastCursorPosition;
-    return contains(mapFromScene(d->canvas->mapFromGlobal(cursorPos.toPoint())));
+    return contains(mapFromScene(d->window->mapFromGlobal(cursorPos.toPoint())));
 }
 
 bool QQuickItem::acceptHoverEvents() const
@@ -5117,35 +5117,35 @@ void QQuickItem::setAcceptHoverEvents(bool enabled)
 void QQuickItem::grabMouse()
 {
     Q_D(QQuickItem);
-    if (!d->canvas)
+    if (!d->window)
         return;
-    QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(d->canvas);
-    if (canvasPriv->mouseGrabberItem == this)
+    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(d->window);
+    if (windowPriv->mouseGrabberItem == this)
         return;
 
-    QQuickItem *oldGrabber = canvasPriv->mouseGrabberItem;
-    canvasPriv->mouseGrabberItem = this;
+    QQuickItem *oldGrabber = windowPriv->mouseGrabberItem;
+    windowPriv->mouseGrabberItem = this;
     if (oldGrabber) {
         QEvent ev(QEvent::UngrabMouse);
-        d->canvas->sendEvent(oldGrabber, &ev);
+        d->window->sendEvent(oldGrabber, &ev);
     }
 }
 
 void QQuickItem::ungrabMouse()
 {
     Q_D(QQuickItem);
-    if (!d->canvas)
+    if (!d->window)
         return;
-    QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(d->canvas);
-    if (canvasPriv->mouseGrabberItem != this) {
+    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(d->window);
+    if (windowPriv->mouseGrabberItem != this) {
         qWarning("QQuickItem::ungrabMouse(): Item is not the mouse grabber.");
         return;
     }
 
-    canvasPriv->mouseGrabberItem = 0;
+    windowPriv->mouseGrabberItem = 0;
 
     QEvent ev(QEvent::UngrabMouse);
-    d->canvas->sendEvent(this, &ev);
+    d->window->sendEvent(this, &ev);
 }
 
 bool QQuickItem::keepMouseGrab() const
@@ -5191,17 +5191,17 @@ void QQuickItem::setKeepMouseGrab(bool keep)
 void QQuickItem::grabTouchPoints(const QVector<int> &ids)
 {
     Q_D(QQuickItem);
-    if (!d->canvas)
+    if (!d->window)
         return;
-    QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(d->canvas);
+    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(d->window);
 
     QSet<QQuickItem*> ungrab;
     for (int i = 0; i < ids.count(); ++i) {
-        QQuickItem *oldGrabber = canvasPriv->itemForTouchPointId.value(ids.at(i));
+        QQuickItem *oldGrabber = windowPriv->itemForTouchPointId.value(ids.at(i));
         if (oldGrabber == this)
             return;
 
-        canvasPriv->itemForTouchPointId[ids.at(i)] = this;
+        windowPriv->itemForTouchPointId[ids.at(i)] = this;
         if (oldGrabber)
             ungrab.insert(oldGrabber);
     }
@@ -5217,11 +5217,11 @@ void QQuickItem::grabTouchPoints(const QVector<int> &ids)
 void QQuickItem::ungrabTouchPoints()
 {
     Q_D(QQuickItem);
-    if (!d->canvas)
+    if (!d->window)
         return;
-    QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(d->canvas);
+    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(d->window);
 
-    QMutableHashIterator<int, QQuickItem*> i(canvasPriv->itemForTouchPointId);
+    QMutableHashIterator<int, QQuickItem*> i(windowPriv->itemForTouchPointId);
     while (i.hasNext()) {
         i.next();
         if (i.value() == this)
@@ -5295,22 +5295,22 @@ QPointF QQuickItem::mapToItem(const QQuickItem *item, const QPointF &point) cons
 QPointF QQuickItem::mapToScene(const QPointF &point) const
 {
     Q_D(const QQuickItem);
-    return d->itemToCanvasTransform().map(point);
+    return d->itemToWindowTransform().map(point);
 }
 
 QRectF QQuickItem::mapRectToItem(const QQuickItem *item, const QRectF &rect) const
 {
     Q_D(const QQuickItem);
-    QTransform t = d->itemToCanvasTransform();
+    QTransform t = d->itemToWindowTransform();
     if (item)
-        t *= QQuickItemPrivate::get(item)->canvasToItemTransform();
+        t *= QQuickItemPrivate::get(item)->windowToItemTransform();
     return t.mapRect(rect);
 }
 
 QRectF QQuickItem::mapRectToScene(const QRectF &rect) const
 {
     Q_D(const QQuickItem);
-    return d->itemToCanvasTransform().mapRect(rect);
+    return d->itemToWindowTransform().mapRect(rect);
 }
 
 QPointF QQuickItem::mapFromItem(const QQuickItem *item, const QPointF &point) const
@@ -5322,21 +5322,21 @@ QPointF QQuickItem::mapFromItem(const QQuickItem *item, const QPointF &point) co
 QPointF QQuickItem::mapFromScene(const QPointF &point) const
 {
     Q_D(const QQuickItem);
-    return d->canvasToItemTransform().map(point);
+    return d->windowToItemTransform().map(point);
 }
 
 QRectF QQuickItem::mapRectFromItem(const QQuickItem *item, const QRectF &rect) const
 {
     Q_D(const QQuickItem);
-    QTransform t = item?QQuickItemPrivate::get(item)->itemToCanvasTransform():QTransform();
-    t *= d->canvasToItemTransform();
+    QTransform t = item?QQuickItemPrivate::get(item)->itemToWindowTransform():QTransform();
+    t *= d->windowToItemTransform();
     return t.mapRect(rect);
 }
 
 QRectF QQuickItem::mapRectFromScene(const QRectF &rect) const
 {
     Q_D(const QQuickItem);
-    return d->canvasToItemTransform().mapRect(rect);
+    return d->windowToItemTransform().mapRect(rect);
 }
 
 
@@ -5414,9 +5414,9 @@ QRectF QQuickItem::mapRectFromScene(const QRectF &rect) const
 
   \l {Filter}{Filters} include things like \l {Blur}{blurring}
   the item, or giving it a \l Reflection.  Some
-  filters may not be available on all canvases; if a filter is not
-  available on a certain canvas, it will simply not be applied for
-  that canvas (but the QML will still be considered valid).
+  filters may not be available on all windows; if a filter is not
+  available on a certain window, it will simply not be applied for
+  that window (but the QML will still be considered valid).
 
   \qml
   Item {
diff --git a/src/quick/items/qquickitem.h b/src/quick/items/qquickitem.h
index 15bf5dd..61bb325 100644
--- a/src/quick/items/qquickitem.h
+++ b/src/quick/items/qquickitem.h
@@ -88,7 +88,7 @@ class QQuickTransition;
 class QQuickKeyEvent;
 class QQuickAnchors;
 class QQuickItemPrivate;
-class QQuickCanvas;
+class QQuickWindow;
 class QTouchEvent;
 class QSGNode;
 class QSGTransformNode;
@@ -166,7 +166,7 @@ public:
     enum ItemChange {
         ItemChildAddedChange,      // value.item
         ItemChildRemovedChange,    // value.item
-        ItemSceneChange,           // value.canvas
+        ItemSceneChange,           // value.window
         ItemVisibleHasChanged,     // value.boolValue
         ItemParentHasChanged,      // value.item
         ItemOpacityHasChanged,     // value.realValue
@@ -176,12 +176,12 @@ public:
 
     union ItemChangeData {
         ItemChangeData(QQuickItem *v) : item(v) {}
-        ItemChangeData(QQuickCanvas *v) : canvas(v) {}
+        ItemChangeData(QQuickWindow *v) : window(v) {}
         ItemChangeData(qreal v) : realValue(v) {}
         ItemChangeData(bool v) : boolValue(v) {}
 
         QQuickItem *item;
-        QQuickCanvas *canvas;
+        QQuickWindow *window;
         qreal realValue;
         bool boolValue;
     };
@@ -195,7 +195,9 @@ public:
     QQuickItem(QQuickItem *parent = 0);
     virtual ~QQuickItem();
 
-    QQuickCanvas *canvas() const;
+    //canvas() is being removed in favor of window() really soon now
+    QQuickWindow *canvas() const { return window(); }
+    QQuickWindow *window() const;
     QQuickItem *parentItem() const;
     void setParentItem(QQuickItem *parent);
     void stackBefore(const QQuickItem *);
@@ -317,7 +319,7 @@ public:
     struct UpdatePaintNodeData {
        QSGTransformNode *transformNode;
     private:
-       friend class QQuickCanvasPrivate;
+       friend class QQuickWindowPrivate;
        UpdatePaintNodeData();
     };
 
@@ -409,8 +411,8 @@ protected:
     QQuickItem(QQuickItemPrivate &dd, QQuickItem *parent = 0);
 
 private:
-    friend class QQuickCanvas;
-    friend class QQuickCanvasPrivate;
+    friend class QQuickWindow;
+    friend class QQuickWindowPrivate;
     friend class QSGRenderer;
     friend class QAccessibleQuickItem;
     friend class QQuickAccessibleAttached;
diff --git a/src/quick/items/qquickitem_p.h b/src/quick/items/qquickitem_p.h
index 6909921..adfe384 100644
--- a/src/quick/items/qquickitem_p.h
+++ b/src/quick/items/qquickitem_p.h
@@ -59,7 +59,7 @@
 #include "qquickanchors_p_p.h"
 #include "qquickitemchangelistener_p.h"
 
-#include "qquickcanvas_p.h"
+#include "qquickwindow_p.h"
 
 #include <QtQuick/qsgnode.h>
 #include "qquickclipnode_p.h"
@@ -427,7 +427,7 @@ public:
         ParentChanged           = 0x00000800,
 
         Clip                    = 0x00001000,
-        Canvas                  = 0x00002000,
+        Window                  = 0x00002000,
 
         EffectReference         = 0x00008000,
         Visible                 = 0x00010000,
@@ -437,10 +437,10 @@ public:
         // dirtyToString()
 
         TransformUpdateMask     = TransformOrigin | Transform | BasicTransform | Position |
-                                  Size | Canvas,
-        ComplexTransformUpdateMask     = Transform | Canvas,
-        ContentUpdateMask       = Size | Content | Smooth | Canvas | Antialiasing,
-        ChildrenUpdateMask      = ChildrenChanged | ChildrenStackingChanged | EffectReference | Canvas
+                                  Size | Window,
+        ComplexTransformUpdateMask     = Transform | Window,
+        ContentUpdateMask       = Size | Content | Smooth | Window | Antialiasing,
+        ChildrenUpdateMask      = ChildrenChanged | ChildrenStackingChanged | EffectReference | Window
     };
 
     quint32 dirtyAttributes;
@@ -453,8 +453,8 @@ public:
 
     void setCulled(bool);
 
-    QQuickCanvas *canvas;
-    int canvasRefCount;
+    QQuickWindow *window;
+    int windowRefCount;
     inline QSGContext *sceneGraphContext() const;
 
     QQuickItem *parentItem;
@@ -469,14 +469,14 @@ public:
 
     inline void markSortedChildrenDirty(QQuickItem *child);
 
-    void refCanvas(QQuickCanvas *);
-    void derefCanvas();
+    void refWindow(QQuickWindow *);
+    void derefWindow();
 
     QQuickItem *subFocusItem;
     void updateSubFocusItem(QQuickItem *scope, bool focus);
 
-    QTransform canvasToItemTransform() const;
-    QTransform itemToCanvasTransform() const;
+    QTransform windowToItemTransform() const;
+    QTransform itemToWindowTransform() const;
     void itemToParentTransform(QTransform &) const;
 
     qreal x;
@@ -837,8 +837,8 @@ Qt::MouseButtons QQuickItemPrivate::acceptedMouseButtons() const
 
 QSGContext *QQuickItemPrivate::sceneGraphContext() const
 {
-    Q_ASSERT(canvas);
-    return static_cast<QQuickCanvasPrivate *>(QObjectPrivate::get(canvas))->context;
+    Q_ASSERT(window);
+    return static_cast<QQuickWindowPrivate *>(QObjectPrivate::get(window))->context;
 }
 
 void QQuickItemPrivate::markSortedChildrenDirty(QQuickItem *child)
diff --git a/src/quick/items/qquickmousearea.cpp b/src/quick/items/qquickmousearea.cpp
index 88cf547..5cfd62f 100644
--- a/src/quick/items/qquickmousearea.cpp
+++ b/src/quick/items/qquickmousearea.cpp
@@ -41,7 +41,7 @@
 
 #include "qquickmousearea_p.h"
 #include "qquickmousearea_p_p.h"
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 #include "qquickevents_p_p.h"
 #include "qquickdrag_p.h"
 
@@ -264,13 +264,13 @@ void QQuickMouseAreaPrivate::propagate(QQuickMouseEvent* event, PropagateType t)
     if (!propagateComposedEvents)
         return;
     QPointF scenePos = q->mapToScene(QPointF(event->x(), event->y()));
-    propagateHelper(event, canvas->rootItem(), scenePos, t);
+    propagateHelper(event, window->rootItem(), scenePos, t);
 }
 
 bool QQuickMouseAreaPrivate::propagateHelper(QQuickMouseEvent *ev, QQuickItem *item,const QPointF &sp, PropagateType sig)
 {
-    //Based off of QQuickCanvas::deliverInitialMousePressEvent
-    //But specific to MouseArea, so doesn't belong in canvas
+    //Based off of QQuickWindow::deliverInitialMousePressEvent
+    //But specific to MouseArea, so doesn't belong in window
     Q_Q(const QQuickMouseArea);
     QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
 
@@ -795,8 +795,8 @@ void QQuickMouseArea::mouseMoveEvent(QMouseEvent *event)
         d->drag->target()->setPos(dragPos);
 
         if (!keepMouseGrab()) {
-            bool xDragged = QQuickCanvasPrivate::dragOverThreshold(dx, Qt::XAxis, event);
-            bool yDragged = QQuickCanvasPrivate::dragOverThreshold(dy, Qt::YAxis, event);
+            bool xDragged = QQuickWindowPrivate::dragOverThreshold(dx, Qt::XAxis, event);
+            bool yDragged = QQuickWindowPrivate::dragOverThreshold(dy, Qt::YAxis, event);
             if ((!dragY && !yDragged && dragX && xDragged)
                 || (!dragX && !xDragged && dragY && yDragged)
                 || (dragX && dragY && (xDragged || yDragged))) {
@@ -835,8 +835,8 @@ void QQuickMouseArea::mouseReleaseEvent(QMouseEvent *event)
             // If we don't accept hover, we need to reset containsMouse.
             if (!acceptHoverEvents())
                 setHovered(false);
-            QQuickCanvas *c = canvas();
-            if (c && c->mouseGrabberItem() == this)
+            QQuickWindow *w = window();
+            if (w && w->mouseGrabberItem() == this)
                 ungrabMouse();
             setKeepMouseGrab(false);
         }
@@ -947,7 +947,7 @@ bool QQuickMouseArea::sendMouseEvent(QMouseEvent *event)
     Q_D(QQuickMouseArea);
     QPointF localPos = mapFromScene(event->windowPos());
 
-    QQuickCanvas *c = canvas();
+    QQuickWindow *c = window();
     QQuickItem *grabber = c ? c->mouseGrabberItem() : 0;
     bool stealThisEvent = d->stealMouse;
     if ((stealThisEvent || contains(localPos)) && (!grabber || !grabber->keepMouseGrab())) {
@@ -1067,7 +1067,7 @@ void QQuickMouseArea::itemChange(ItemChange change, const ItemChangeData &value)
         if (acceptHoverEvents() && d->hovered != (isVisible() && isUnderMouse())) {
             if (!d->hovered) {
                 QPointF cursorPos = QGuiApplicationPrivate::lastCursorPosition;
-                d->lastScenePos = d->canvas->mapFromGlobal(cursorPos.toPoint());
+                d->lastScenePos = d->window->mapFromGlobal(cursorPos.toPoint());
                 d->lastPos = mapFromScene(d->lastScenePos);
             }
             setHovered(!d->hovered);
@@ -1139,9 +1139,9 @@ void QQuickMouseArea::setHovered(bool h)
 #ifndef QT_NO_CURSOR
         if (d->cursor) {
             if (d->hovered) {
-                canvas()->setCursor(QCursor(*d->cursor));
+                window()->setCursor(QCursor(*d->cursor));
             } else {
-                canvas()->unsetCursor();
+                window()->unsetCursor();
             }
         }
 #endif
diff --git a/src/quick/items/qquickmultipointtoucharea.cpp b/src/quick/items/qquickmultipointtoucharea.cpp
index 0348c25..15e6058 100644
--- a/src/quick/items/qquickmultipointtoucharea.cpp
+++ b/src/quick/items/qquickmultipointtoucharea.cpp
@@ -40,7 +40,7 @@
 ****************************************************************************/
 
 #include "qquickmultipointtoucharea_p.h"
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 #include <private/qsgadaptationlayer_p.h>
 #include <private/qquickitem_p.h>
 #include <QEvent>
@@ -386,7 +386,7 @@ void QQuickMultiPointTouchArea::touchEvent(QTouchEvent *event)
     case QEvent::TouchUpdate:
     case QEvent::TouchEnd: {
         //if e.g. a parent Flickable has the mouse grab, don't process the touch events
-        QQuickCanvas *c = canvas();
+        QQuickWindow *c = window();
         QQuickItem *grabber = c ? c->mouseGrabberItem() : 0;
         if (grabber && grabber != this && grabber->keepMouseGrab() && grabber->isEnabled()) {
             QQuickItem *item = this;
@@ -397,7 +397,7 @@ void QQuickMultiPointTouchArea::touchEvent(QTouchEvent *event)
         }
         updateTouchData(event);
         if (event->type() == QEvent::TouchEnd) {
-            //TODO: move to canvas
+            //TODO: move to window
             _stealMouse = false;
             setKeepMouseGrab(false);
             setKeepTouchGrab(false);
@@ -593,7 +593,7 @@ void QQuickMultiPointTouchArea::mouseReleaseEvent(QMouseEvent *event)
         QQuickItem::mouseReleaseEvent(event);
         return;
     }
-    QQuickCanvas *c = canvas();
+    QQuickWindow *c = window();
     if (c && c->mouseGrabberItem() == this)
         ungrabMouse();
     setKeepMouseGrab(false);
@@ -602,7 +602,7 @@ void QQuickMultiPointTouchArea::mouseReleaseEvent(QMouseEvent *event)
 void QQuickMultiPointTouchArea::ungrab()
 {
     if (_touchPoints.count()) {
-        QQuickCanvas *c = canvas();
+        QQuickWindow *c = window();
         if (c && c->mouseGrabberItem() == this) {
             _stealMouse = false;
             setKeepMouseGrab(false);
@@ -638,7 +638,7 @@ bool QQuickMultiPointTouchArea::sendMouseEvent(QMouseEvent *event)
 {
     QPointF localPos = mapFromScene(event->windowPos());
 
-    QQuickCanvas *c = canvas();
+    QQuickWindow *c = window();
     QQuickItem *grabber = c ? c->mouseGrabberItem() : 0;
     bool stealThisEvent = _stealMouse;
     if ((stealThisEvent || contains(localPos)) && (!grabber || !grabber->keepMouseGrab())) {
@@ -709,7 +709,7 @@ bool QQuickMultiPointTouchArea::childMouseEventFilter(QQuickItem *i, QEvent *eve
 
 bool QQuickMultiPointTouchArea::shouldFilter(QEvent *event)
 {
-    QQuickCanvas *c = canvas();
+    QQuickWindow *c = window();
     QQuickItem *grabber = c ? c->mouseGrabberItem() : 0;
     bool disabledItem = grabber && !grabber->isEnabled();
     bool stealThisEvent = _stealMouse;
diff --git a/src/quick/items/qquickpathview.cpp b/src/quick/items/qquickpathview.cpp
index 52e200d..cb56dd2 100644
--- a/src/quick/items/qquickpathview.cpp
+++ b/src/quick/items/qquickpathview.cpp
@@ -41,7 +41,7 @@
 
 #include "qquickpathview_p.h"
 #include "qquickpathview_p_p.h"
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 
 #include <QtQuick/private/qquickstate_p.h>
 #include <private/qqmlglobal_p.h>
@@ -1516,7 +1516,7 @@ bool QQuickPathView::sendMouseEvent(QMouseEvent *event)
     Q_D(QQuickPathView);
     QPointF localPos = mapFromScene(event->windowPos());
 
-    QQuickCanvas *c = canvas();
+    QQuickWindow *c = window();
     QQuickItem *grabber = c ? c->mouseGrabberItem() : 0;
     bool stealThisEvent = d->stealMouse;
     if ((stealThisEvent || contains(localPos)) && (!grabber || !grabber->keepMouseGrab())) {
diff --git a/src/quick/items/qquickpincharea.cpp b/src/quick/items/qquickpincharea.cpp
index 848e887..d167d75 100644
--- a/src/quick/items/qquickpincharea.cpp
+++ b/src/quick/items/qquickpincharea.cpp
@@ -40,7 +40,7 @@
 ****************************************************************************/
 
 #include "qquickpincharea_p_p.h"
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 
 #include <QtGui/qevent.h>
 #include <QtGui/qguiapplication.h>
@@ -285,7 +285,7 @@ void QQuickPinchArea::touchEvent(QTouchEvent *event)
 
     // A common non-trivial starting scenario is the user puts down one finger,
     // then that finger remains stationary while putting down a second one.
-    // However QQuickCanvas will not send TouchUpdates for TouchPoints which
+    // However QQuickWindow will not send TouchUpdates for TouchPoints which
     // were not initially accepted; that would be inefficient and noisy.
     // So even if there is only one touchpoint so far, it's important to accept it
     // in order to get updates later on (and it's accepted by default anyway).
@@ -416,7 +416,7 @@ void QQuickPinchArea::updatePinch()
                 if (pe.accepted()) {
                     d->inPinch = true;
                     d->stealMouse = true;
-                    QQuickCanvas *c = canvas();
+                    QQuickWindow *c = window();
                     if (c && c->mouseGrabberItem() != this)
                         grabMouse();
                     setKeepMouseGrab(true);
diff --git a/src/quick/items/qquickscreen.cpp b/src/quick/items/qquickscreen.cpp
index a55cb1f..32b0d32 100644
--- a/src/quick/items/qquickscreen.cpp
+++ b/src/quick/items/qquickscreen.cpp
@@ -43,7 +43,7 @@
 
 #include "qquickitem.h"
 #include "qquickitem_p.h"
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 
 #include <QScreen>
 
@@ -108,8 +108,8 @@ QQuickScreenAttached::QQuickScreenAttached(QObject* attachee)
     if (m_attachee) {
         QQuickItemPrivate::get(m_attachee)->extra.value().screenAttached = this;
 
-        if (m_attachee->canvas()) //It might not be assigned to a canvas yet
-            canvasChanged(m_attachee->canvas());
+        if (m_attachee->window()) //It might not be assigned to a window yet
+            windowChanged(m_attachee->window());
     }
 }
 
@@ -148,7 +148,7 @@ int QQuickScreenAttached::angleBetween(int a, int b)
     return m_screen->angleBetween((Qt::ScreenOrientation)a,(Qt::ScreenOrientation)b);
 }
 
-void QQuickScreenAttached::canvasChanged(QQuickCanvas* c)//Called by QQuickItemPrivate::initCanvas
+void QQuickScreenAttached::windowChanged(QQuickWindow* c)//Called by QQuickItemPrivate::initWindow
 {
     QScreen* screen = c ? c->screen() : 0;
     if (screen != m_screen) {
diff --git a/src/quick/items/qquickscreen_p.h b/src/quick/items/qquickscreen_p.h
index 1a501f2..45a339b 100644
--- a/src/quick/items/qquickscreen_p.h
+++ b/src/quick/items/qquickscreen_p.h
@@ -53,7 +53,7 @@ QT_BEGIN_NAMESPACE
 
 
 class QQuickItem;
-class QQuickCanvas;
+class QQuickWindow;
 class QScreen;
 
 class Q_AUTOTEST_EXPORT QQuickScreenAttached : public QObject
@@ -76,7 +76,7 @@ public:
     //Treats int as Qt::ScreenOrientation, due to QTBUG-20639
     Q_INVOKABLE int angleBetween(int a, int b);
 
-    void canvasChanged(QQuickCanvas*);
+    void windowChanged(QQuickWindow*);
 
 Q_SIGNALS:
     void widthChanged();
diff --git a/src/quick/items/qquickshadereffect.cpp b/src/quick/items/qquickshadereffect.cpp
index be30230..0b8189f 100644
--- a/src/quick/items/qquickshadereffect.cpp
+++ b/src/quick/items/qquickshadereffect.cpp
@@ -47,7 +47,7 @@
 
 #include <QtQuick/private/qsgcontext_p.h>
 #include <QtQuick/qsgtextureprovider.h>
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 
 #include "qquickimage_p.h"
 #include "qquickshadereffectsource_p.h"
@@ -224,8 +224,8 @@ void QQuickShaderEffectCommon::disconnectPropertySignals(QQuickItem *item, Key::
         if (d.specialType == UniformData::Sampler) {
             QQuickItem *source = qobject_cast<QQuickItem *>(qvariant_cast<QObject *>(d.value));
             if (source) {
-                if (item->canvas())
-                    QQuickItemPrivate::get(source)->derefCanvas();
+                if (item->window())
+                    QQuickItemPrivate::get(source)->derefWindow();
                 QObject::disconnect(source, SIGNAL(destroyed(QObject*)), item, SLOT(sourceDestroyed(QObject*)));
             }
         }
@@ -257,8 +257,8 @@ void QQuickShaderEffectCommon::connectPropertySignals(QQuickItem *item, Key::Sha
         if (d.specialType == UniformData::Sampler) {
             QQuickItem *source = qobject_cast<QQuickItem *>(qvariant_cast<QObject *>(d.value));
             if (source) {
-                if (item->canvas())
-                    QQuickItemPrivate::get(source)->refCanvas(item->canvas());
+                if (item->window())
+                    QQuickItemPrivate::get(source)->refWindow(item->window());
                 QObject::connect(source, SIGNAL(destroyed(QObject*)), item, SLOT(sourceDestroyed(QObject*)));
             }
         }
@@ -454,17 +454,17 @@ void QQuickShaderEffectCommon::updateMaterial(QQuickShaderEffectNode *node,
     }
 }
 
-void QQuickShaderEffectCommon::updateCanvas(QQuickCanvas *canvas)
+void QQuickShaderEffectCommon::updateWindow(QQuickWindow *window)
 {
     // See comment in QQuickShaderEffectCommon::propertyChanged().
-    if (canvas) {
+    if (window) {
         for (int shaderType = 0; shaderType < Key::ShaderTypeCount; ++shaderType) {
             for (int i = 0; i < uniformData[shaderType].size(); ++i) {
                 const UniformData &d = uniformData[shaderType].at(i);
                 if (d.specialType == UniformData::Sampler) {
                     QQuickItem *source = qobject_cast<QQuickItem *>(qvariant_cast<QObject *>(d.value));
                     if (source)
-                        QQuickItemPrivate::get(source)->refCanvas(canvas);
+                        QQuickItemPrivate::get(source)->refWindow(window);
                 }
             }
         }
@@ -475,7 +475,7 @@ void QQuickShaderEffectCommon::updateCanvas(QQuickCanvas *canvas)
                 if (d.specialType == UniformData::Sampler) {
                     QQuickItem *source = qobject_cast<QQuickItem *>(qvariant_cast<QObject *>(d.value));
                     if (source)
-                        QQuickItemPrivate::get(source)->derefCanvas();
+                        QQuickItemPrivate::get(source)->derefWindow();
                 }
             }
         }
@@ -505,8 +505,8 @@ void QQuickShaderEffectCommon::propertyChanged(QQuickItem *item, int mappedId,
     if (d.specialType == UniformData::Sampler) {
         QQuickItem *source = qobject_cast<QQuickItem *>(qvariant_cast<QObject *>(d.value));
         if (source) {
-            if (item->canvas())
-                QQuickItemPrivate::get(source)->derefCanvas();
+            if (item->window())
+                QQuickItemPrivate::get(source)->derefWindow();
             QObject::disconnect(source, SIGNAL(destroyed(QObject*)), item, SLOT(sourceDestroyed(QObject*)));
         }
 
@@ -514,12 +514,12 @@ void QQuickShaderEffectCommon::propertyChanged(QQuickItem *item, int mappedId,
 
         source = qobject_cast<QQuickItem *>(qvariant_cast<QObject *>(d.value));
         if (source) {
-            // 'source' needs a canvas to get a scene graph node. It usually gets one through its
+            // 'source' needs a window to get a scene graph node. It usually gets one through its
             // parent, but if the source item is "inline" rather than a reference -- i.e.
             // "property variant source: Image { }" instead of "property variant source: foo" -- it
-            // will not get a parent. In those cases, 'source' should get the canvas from 'item'.
-            if (item->canvas())
-                QQuickItemPrivate::get(source)->refCanvas(item->canvas());
+            // will not get a parent. In those cases, 'source' should get the window from 'item'.
+            if (item->window())
+                QQuickItemPrivate::get(source)->refWindow(item->window());
             QObject::connect(source, SIGNAL(destroyed(QObject*)), item, SLOT(sourceDestroyed(QObject*)));
         }
         if (textureProviderChanged)
@@ -1009,7 +1009,7 @@ void QQuickShaderEffect::componentComplete()
 void QQuickShaderEffect::itemChange(ItemChange change, const ItemChangeData &value)
 {
     if (change == QQuickItem::ItemSceneChange)
-        m_common.updateCanvas(value.canvas);
+        m_common.updateWindow(value.window);
     QQuickItem::itemChange(change, value);
 }
 
diff --git a/src/quick/items/qquickshadereffect_p.h b/src/quick/items/qquickshadereffect_p.h
index 2f41324..e7bcd90 100644
--- a/src/quick/items/qquickshadereffect_p.h
+++ b/src/quick/items/qquickshadereffect_p.h
@@ -77,7 +77,7 @@ struct Q_QUICK_PRIVATE_EXPORT QQuickShaderEffectCommon
     void updateShader(QQuickItem *item, Key::ShaderType shaderType);
     void updateMaterial(QQuickShaderEffectNode *node, QQuickShaderEffectMaterial *material,
                         bool updateUniforms, bool updateUniformValues, bool updateTextureProviders);
-    void updateCanvas(QQuickCanvas *canvas);
+    void updateWindow(QQuickWindow *window);
 
     // Called by slots in QQuickShaderEffect:
     void sourceDestroyed(QObject *object);
diff --git a/src/quick/items/qquickshadereffectsource.cpp b/src/quick/items/qquickshadereffectsource.cpp
index 3804c93..5ccd7bc 100644
--- a/src/quick/items/qquickshadereffectsource.cpp
+++ b/src/quick/items/qquickshadereffectsource.cpp
@@ -42,7 +42,7 @@
 #include "qquickshadereffectsource_p.h"
 
 #include "qquickitem_p.h"
-#include "qquickcanvas_p.h"
+#include "qquickwindow_p.h"
 #include <private/qsgadaptationlayer_p.h>
 #include <QtQuick/private/qsgrenderer_p.h>
 
@@ -568,8 +568,8 @@ QQuickShaderEffectSource::~QQuickShaderEffectSource()
         QQuickItemPrivate *sd = QQuickItemPrivate::get(m_sourceItem);
         sd->removeItemChangeListener(this, QQuickItemPrivate::Geometry);
         sd->derefFromEffectItem(m_hideSource);
-        if (canvas())
-            sd->derefCanvas();
+        if (window())
+            sd->derefWindow();
     }
 }
 
@@ -578,7 +578,7 @@ void QQuickShaderEffectSource::ensureTexture()
     if (m_texture)
         return;
 
-    Q_ASSERT_X(QQuickItemPrivate::get(this)->canvas
+    Q_ASSERT_X(QQuickItemPrivate::get(this)->window
                && QQuickItemPrivate::get(this)->sceneGraphContext()
                && QThread::currentThread() == QQuickItemPrivate::get(this)->sceneGraphContext()->thread(),
                "QQuickShaderEffectSource::ensureTexture",
@@ -593,7 +593,7 @@ QSGTextureProvider *QQuickShaderEffectSource::textureProvider() const
 {
     if (!m_provider) {
         // Make sure it gets thread affinity on the rendering thread so deletion works properly..
-        Q_ASSERT_X(QQuickItemPrivate::get(this)->canvas
+        Q_ASSERT_X(QQuickItemPrivate::get(this)->window
                    && QQuickItemPrivate::get(this)->sceneGraphContext()
                    && QThread::currentThread() == QQuickItemPrivate::get(this)->sceneGraphContext()->thread(),
                    "QQuickShaderEffectSource::textureProvider",
@@ -668,19 +668,19 @@ void QQuickShaderEffectSource::setSourceItem(QQuickItem *item)
         d->derefFromEffectItem(m_hideSource);
         d->removeItemChangeListener(this, QQuickItemPrivate::Geometry);
         disconnect(m_sourceItem, SIGNAL(destroyed(QObject*)), this, SLOT(sourceItemDestroyed(QObject*)));
-        if (canvas())
-            d->derefCanvas();
+        if (window())
+            d->derefWindow();
     }
     m_sourceItem = item;
 
     if (item) {
         QQuickItemPrivate *d = QQuickItemPrivate::get(item);
-        // 'item' needs a canvas to get a scene graph node. It usually gets one through its
+        // 'item' needs a window to get a scene graph node. It usually gets one through its
         // parent, but if the source item is "inline" rather than a reference -- i.e.
         // "sourceItem: Item { }" instead of "sourceItem: foo" -- it will not get a parent.
-        // In those cases, 'item' should get the canvas from 'this'.
-        if (canvas())
-            d->refCanvas(canvas());
+        // In those cases, 'item' should get the window from 'this'.
+        if (window())
+            d->refWindow(window());
         d->refFromEffectItem(m_hideSource);
         d->addItemChangeListener(this, QQuickItemPrivate::Geometry);
         connect(m_sourceItem, SIGNAL(destroyed(QObject*)), this, SLOT(sourceItemDestroyed(QObject*)));
@@ -1015,10 +1015,10 @@ void QQuickShaderEffectSource::itemChange(ItemChange change, const ItemChangeDat
 {
     if (change == QQuickItem::ItemSceneChange && m_sourceItem) {
         // See comment in QQuickShaderEffectSource::setSourceItem().
-        if (value.canvas)
-            QQuickItemPrivate::get(m_sourceItem)->refCanvas(value.canvas);
+        if (value.window)
+            QQuickItemPrivate::get(m_sourceItem)->refWindow(value.window);
         else
-            QQuickItemPrivate::get(m_sourceItem)->derefCanvas();
+            QQuickItemPrivate::get(m_sourceItem)->derefWindow();
     }
     QQuickItem::itemChange(change, value);
 }
diff --git a/src/quick/items/qquickspritesequence.cpp b/src/quick/items/qquickspritesequence.cpp
index def6963..62ab20b 100644
--- a/src/quick/items/qquickspritesequence.cpp
+++ b/src/quick/items/qquickspritesequence.cpp
@@ -47,7 +47,7 @@
 #include <QtQuick/qsgnode.h>
 #include <QtQuick/qsgtexturematerial.h>
 #include <QtQuick/qsgtexture.h>
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 #include <QtQml/qqmlinfo.h>
 #include <QFile>
 #include <cmath>
@@ -367,7 +367,7 @@ QSGGeometryNode* QQuickSpriteSequence::buildNode()
     if (image.isNull())
         return 0;
     m_sheetSize = QSizeF(image.size());
-    m_material->texture = canvas()->createTextureFromImage(image);
+    m_material->texture = window()->createTextureFromImage(image);
     m_material->texture->setFiltering(QSGTexture::Linear);
     m_spriteEngine->start(0);
     m_material->animT = 0;
diff --git a/src/quick/items/qquicktextedit.cpp b/src/quick/items/qquicktextedit.cpp
index 7159410..3737a0e 100644
--- a/src/quick/items/qquicktextedit.cpp
+++ b/src/quick/items/qquicktextedit.cpp
@@ -44,7 +44,7 @@
 #include "qquicktextcontrol_p.h"
 #include "qquicktext_p_p.h"
 #include "qquickevents_p_p.h"
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 #include "qquicktextnode_p.h"
 #include "qquicktextutil_p.h"
 #include <QtQuick/qsgsimplerectnode.h>
diff --git a/src/quick/items/qquicktextinput.cpp b/src/quick/items/qquicktextinput.cpp
index 16adcd3..b243442 100644
--- a/src/quick/items/qquicktextinput.cpp
+++ b/src/quick/items/qquicktextinput.cpp
@@ -41,7 +41,7 @@
 
 #include "qquicktextinput_p.h"
 #include "qquicktextinput_p_p.h"
-#include "qquickcanvas.h"
+#include "qquickwindow.h"
 #include "qquicktextutil_p.h"
 
 #include <private/qqmlglobal_p.h>
diff --git a/src/quick/items/qquickview.cpp b/src/quick/items/qquickview.cpp
index 52c9959..2a56c73 100644
--- a/src/quick/items/qquickview.cpp
+++ b/src/quick/items/qquickview.cpp
@@ -42,7 +42,7 @@
 #include "qquickview.h"
 #include "qquickview_p.h"
 
-#include "qquickcanvas_p.h"
+#include "qquickwindow_p.h"
 #include "qquickitem_p.h"
 #include "qquickitemchangelistener_p.h"
 
@@ -128,9 +128,9 @@ void QQuickViewPrivate::itemGeometryChanged(QQuickItem *resizeItem, const QRectF
 
     \inmodule QtQuick
 
-    This is a convenience subclass of QQuickCanvas which
+    This is a convenience subclass of QQuickWindow which
     will automatically load and display a QML scene when given the URL of the main source file. Alternatively,
-    you can instantiate your own objects using QQmlComponent and place them in a manually setup QQuickCanvas.
+    you can instantiate your own objects using QQmlComponent and place them in a manually setup QQuickWindow.
 
     Typical usage:
 
@@ -171,7 +171,7 @@ void QQuickViewPrivate::itemGeometryChanged(QQuickItem *resizeItem, const QRectF
 
 */
 QQuickView::QQuickView(QWindow *parent)
-: QQuickCanvas(*(new QQuickViewPrivate), parent)
+: QQuickWindow(*(new QQuickViewPrivate), parent)
 {
     d_func()->init();
 }
@@ -182,7 +182,7 @@ QQuickView::QQuickView(QWindow *parent)
 
 */
 QQuickView::QQuickView(const QUrl &source, QWindow *parent)
-: QQuickCanvas(*(new QQuickViewPrivate), parent)
+: QQuickWindow(*(new QQuickViewPrivate), parent)
 {
     d_func()->init();
     setSource(source);
@@ -198,7 +198,7 @@ QQuickView::QQuickView(const QUrl &source, QWindow *parent)
   \sa Status, status(), errors()
 */
 QQuickView::QQuickView(QQmlEngine* engine, QWindow *parent)
-    : QQuickCanvas(*(new QQuickViewPrivate), parent)
+    : QQuickWindow(*(new QQuickViewPrivate), parent)
 {
     Q_ASSERT(engine);
     d_func()->init(engine);
@@ -336,7 +336,7 @@ QList<QQmlError> QQuickView::errors() const
 
 /*!
     \property QQuickView::resizeMode
-    \brief whether the view should resize the canvas contents
+    \brief whether the view should resize the window contents
 
     If this property is set to SizeViewToRootObject (the default), the view
     resizes to the size of the root item in the QML.
@@ -469,7 +469,7 @@ void QQuickViewPrivate::setRootObject(QObject *obj)
         return;
     if (QQuickItem *sgItem = qobject_cast<QQuickItem *>(obj)) {
         root = sgItem;
-        sgItem->setParentItem(q->QQuickCanvas::rootItem());
+        sgItem->setParentItem(q->QQuickWindow::rootItem());
     } else {
         qWarning() << "QQuickView only supports loading of root objects that derive from QQuickItem." << endl
                    << endl
@@ -553,7 +553,7 @@ void QQuickView::resizeEvent(QResizeEvent *e)
     if (d->resizeMode == SizeRootObjectToView)
         d->updateSize();
 
-    QQuickCanvas::resizeEvent(e);
+    QQuickWindow::resizeEvent(e);
 }
 
 /*! \reimp */
@@ -561,7 +561,7 @@ void QQuickView::keyPressEvent(QKeyEvent *e)
 {
     QQmlProfilerService::addEvent(QQmlProfilerService::Key);
 
-    QQuickCanvas::keyPressEvent(e);
+    QQuickWindow::keyPressEvent(e);
 }
 
 /*! \reimp */
@@ -569,7 +569,7 @@ void QQuickView::keyReleaseEvent(QKeyEvent *e)
 {
     QQmlProfilerService::addEvent(QQmlProfilerService::Key);
 
-    QQuickCanvas::keyReleaseEvent(e);
+    QQuickWindow::keyReleaseEvent(e);
 }
 
 /*! \reimp */
@@ -577,7 +577,7 @@ void QQuickView::mouseMoveEvent(QMouseEvent *e)
 {
     QQmlProfilerService::addEvent(QQmlProfilerService::Mouse);
 
-    QQuickCanvas::mouseMoveEvent(e);
+    QQuickWindow::mouseMoveEvent(e);
 }
 
 /*! \reimp */
@@ -585,7 +585,7 @@ void QQuickView::mousePressEvent(QMouseEvent *e)
 {
     QQmlProfilerService::addEvent(QQmlProfilerService::Mouse);
 
-    QQuickCanvas::mousePressEvent(e);
+    QQuickWindow::mousePressEvent(e);
 }
 
 /*! \reimp */
@@ -593,7 +593,7 @@ void QQuickView::mouseReleaseEvent(QMouseEvent *e)
 {
     QQmlProfilerService::addEvent(QQmlProfilerService::Mouse);
 
-    QQuickCanvas::mouseReleaseEvent(e);
+    QQuickWindow::mouseReleaseEvent(e);
 }
 
 
diff --git a/src/quick/items/qquickview.h b/src/quick/items/qquickview.h
index 89647ba..97d325e 100644
--- a/src/quick/items/qquickview.h
+++ b/src/quick/items/qquickview.h
@@ -42,7 +42,7 @@
 #ifndef QQUICKVIEW_H
 #define QQUICKVIEW_H
 
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 #include <QtCore/qurl.h>
 #include <QtQml/qqmldebug.h>
 
@@ -56,7 +56,7 @@ class QQmlError;
 class QQuickItem;
 
 class QQuickViewPrivate;
-class Q_QUICK_EXPORT QQuickView : public QQuickCanvas
+class Q_QUICK_EXPORT QQuickView : public QQuickWindow
 {
     Q_OBJECT
     Q_PROPERTY(ResizeMode resizeMode READ resizeMode WRITE setResizeMode)
diff --git a/src/quick/items/qquickview_p.h b/src/quick/items/qquickview_p.h
index fcabddd..0442f78 100644
--- a/src/quick/items/qquickview_p.h
+++ b/src/quick/items/qquickview_p.h
@@ -51,7 +51,7 @@
 #include <QtCore/QWeakPointer>
 
 #include <QtQml/qqmlengine.h>
-#include "qquickcanvas_p.h"
+#include "qquickwindow_p.h"
 
 #include "qquickitemchangelistener_p.h"
 
@@ -64,7 +64,7 @@ class QQmlError;
 class QQuickItem;
 class QQmlComponent;
 
-class QQuickViewPrivate : public QQuickCanvasPrivate,
+class QQuickViewPrivate : public QQuickWindowPrivate,
                        public QQuickItemChangeListener
 {
     Q_DECLARE_PUBLIC(QQuickView)
diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
new file mode 100644
index 0000000..1d3adea
--- /dev/null
+++ b/src/quick/items/qquickwindow.cpp
@@ -0,0 +1,2662 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "qquickwindow.h"
+#include "qquickwindow_p.h"
+
+#include "qquickitem.h"
+#include "qquickitem_p.h"
+#include "qquickevents_p_p.h"
+
+#include <QtQuick/private/qsgrenderer_p.h>
+#include <QtQuick/private/qsgtexture_p.h>
+#include <QtQuick/private/qsgflashnode_p.h>
+
+#include <private/qquickwindowmanager_p.h>
+
+#include <private/qguiapplication_p.h>
+#include <QtGui/QInputMethod>
+
+#include <private/qabstractanimation_p.h>
+
+#include <QtGui/qpainter.h>
+#include <QtGui/qevent.h>
+#include <QtGui/qmatrix4x4.h>
+#include <QtGui/qstylehints.h>
+#include <QtCore/qvarlengtharray.h>
+#include <QtCore/qabstractanimation.h>
+#include <QtQml/qqmlincubator.h>
+
+#include <QtQuick/private/qquickpixmapcache_p.h>
+
+#include <private/qqmlprofilerservice_p.h>
+#include <private/qqmlmemoryprofiler_p.h>
+
+QT_BEGIN_NAMESPACE
+
+void QQuickWindowPrivate::updateFocusItemTransform()
+{
+    Q_Q(QQuickWindow);
+    QQuickItem *focus = q->activeFocusItem();
+    if (focus && qApp->focusObject() == focus)
+        qApp->inputMethod()->setInputItemTransform(QQuickItemPrivate::get(focus)->itemToWindowTransform());
+}
+
+class QQuickWindowIncubationController : public QObject, public QQmlIncubationController
+{
+public:
+    QQuickWindowIncubationController(QQuickWindowPrivate *window)
+    : m_window(window), m_eventSent(false) {}
+
+protected:
+    virtual bool event(QEvent *e)
+    {
+        if (e->type() == QEvent::User) {
+            Q_ASSERT(m_eventSent);
+            volatile bool *amtp = m_window->windowManager->allowMainThreadProcessing();
+            while (incubatingObjectCount()) {
+                if (amtp)
+                    incubateWhile(amtp, 2);
+                else
+                    incubateFor(5);
+                QCoreApplication::processEvents();
+            }
+
+            m_eventSent = false;
+        }
+        return QObject::event(e);
+    }
+
+    virtual void incubatingObjectCountChanged(int count)
+    {
+        if (count && !m_eventSent) {
+            m_eventSent = true;
+            QCoreApplication::postEvent(this, new QEvent(QEvent::User));
+        }
+        // If no animations are running, the renderer may be waiting
+        m_window->windowManager->wakeup();
+    }
+
+private:
+    QQuickWindowPrivate *m_window;
+    bool m_eventSent;
+};
+
+#ifndef QT_NO_ACCESSIBILITY
+QAccessibleInterface *QQuickWindow::accessibleRoot() const
+{
+    return QAccessible::queryAccessibleInterface(const_cast<QQuickWindow*>(this));
+}
+#endif
+
+
+/*
+Focus behavior
+==============
+
+Prior to being added to a valid window items can set and clear focus with no
+effect.  Only once items are added to a window (by way of having a parent set that
+already belongs to a window) do the focus rules apply.  Focus goes back to
+having no effect if an item is removed from a window.
+
+When an item is moved into a new focus scope (either being added to a window
+for the first time, or having its parent changed), if the focus scope already has
+a scope focused item that takes precedence over the item being added.  Otherwise,
+the focus of the added tree is used.  In the case of of a tree of items being
+added to a window for the first time, which may have a conflicted focus state (two
+or more items in one scope having focus set), the same rule is applied item by item -
+thus the first item that has focus will get it (assuming the scope doesn't already
+have a scope focused item), and the other items will have their focus cleared.
+*/
+
+
+// #define FOCUS_DEBUG
+// #define MOUSE_DEBUG
+// #define TOUCH_DEBUG
+// #define DIRTY_DEBUG
+
+#ifdef FOCUS_DEBUG
+void printFocusTree(QQuickItem *item, QQuickItem *scope = 0, int depth = 1);
+#endif
+
+QQuickItem::UpdatePaintNodeData::UpdatePaintNodeData()
+: transformNode(0)
+{
+}
+
+QQuickRootItem::QQuickRootItem()
+{
+}
+
+/*! \reimp */
+void QQuickWindow::exposeEvent(QExposeEvent *)
+{
+    Q_D(QQuickWindow);
+    d->windowManager->exposureChanged(this);
+}
+
+/*! \reimp */
+void QQuickWindow::resizeEvent(QResizeEvent *)
+{
+    Q_D(QQuickWindow);
+    d->windowManager->resize(this, size());
+}
+
+/*! \reimp */
+void QQuickWindow::showEvent(QShowEvent *)
+{
+    d_func()->windowManager->show(this);
+}
+
+/*! \reimp */
+void QQuickWindow::hideEvent(QHideEvent *)
+{
+    d_func()->windowManager->hide(this);
+}
+
+/*! \reimp */
+void QQuickWindow::focusOutEvent(QFocusEvent *)
+{
+    Q_D(QQuickWindow);
+    d->rootItem->setFocus(false);
+}
+
+/*! \reimp */
+void QQuickWindow::focusInEvent(QFocusEvent *)
+{
+    Q_D(QQuickWindow);
+    d->rootItem->setFocus(true);
+    d->updateFocusItemTransform();
+}
+
+
+void QQuickWindowPrivate::polishItems()
+{
+    int maxPolishCycles = 100000;
+
+    while (!itemsToPolish.isEmpty() && --maxPolishCycles > 0) {
+        QSet<QQuickItem *> itms = itemsToPolish;
+        itemsToPolish.clear();
+
+        for (QSet<QQuickItem *>::iterator it = itms.begin(); it != itms.end(); ++it) {
+            QQuickItem *item = *it;
+            QQuickItemPrivate::get(item)->polishScheduled = false;
+            item->updatePolish();
+        }
+    }
+
+    if (maxPolishCycles == 0)
+        qWarning("QQuickWindow: possible QQuickItem::polish() loop");
+
+    updateFocusItemTransform();
+}
+
+/**
+ * This parameter enables that this window can be rendered without
+ * being shown on screen. This feature is very limited in what it supports.
+ *
+ * There needs to be another window actually showing that we can make current
+ * to get a surface to make current AND for this feature to be useful
+ * one needs to hook into beforeRender() and set the render tareget.
+ *
+ */
+void QQuickWindowPrivate::setRenderWithoutShowing(bool render)
+{
+    if (render == renderWithoutShowing)
+        return;
+
+    Q_Q(QQuickWindow);
+    renderWithoutShowing = render;
+
+    if (render)
+        windowManager->show(q);
+    else
+        windowManager->hide(q);
+}
+
+
+/*!
+ * Schedules the window to render another frame.
+ *
+ * Calling QQuickWindow::update() differs from QQuickItem::update() in that
+ * it always triggers a repaint, regardless of changes in the underlying
+ * scene graph or not.
+ */
+void QQuickWindow::update()
+{
+    Q_D(QQuickWindow);
+    d->windowManager->update(this);
+}
+
+void forceUpdate(QQuickItem *item)
+{
+    if (item->flags() & QQuickItem::ItemHasContents)
+        item->update();
+    QQuickItemPrivate::get(item)->dirty(QQuickItemPrivate::ChildrenUpdateMask);
+
+    QList <QQuickItem *> items = item->childItems();
+    for (int i=0; i<items.size(); ++i)
+        forceUpdate(items.at(i));
+}
+
+void QQuickWindowPrivate::syncSceneGraph()
+{
+    QML_MEMORY_SCOPE_STRING("SceneGraph");
+    Q_Q(QQuickWindow);
+
+    emit q->beforeSynchronizing();
+    if (!renderer) {
+        forceUpdate(rootItem);
+
+        QSGRootNode *rootNode = new QSGRootNode;
+        rootNode->appendChildNode(QQuickItemPrivate::get(rootItem)->itemNode());
+        renderer = context->createRenderer();
+        renderer->setRootNode(rootNode);
+    }
+
+    updateDirtyNodes();
+
+    // Copy the current state of clearing from window into renderer.
+    renderer->setClearColor(clearColor);
+    QSGRenderer::ClearMode mode = QSGRenderer::ClearStencilBuffer | QSGRenderer::ClearDepthBuffer;
+    if (clearBeforeRendering)
+        mode |= QSGRenderer::ClearColorBuffer;
+    renderer->setClearMode(mode);
+}
+
+
+void QQuickWindowPrivate::renderSceneGraph(const QSize &size)
+{
+    QML_MEMORY_SCOPE_STRING("SceneGraph");
+    Q_Q(QQuickWindow);
+    emit q->beforeRendering();
+    int fboId = 0;
+    renderer->setDeviceRect(QRect(QPoint(0, 0), size));
+    if (renderTargetId) {
+        fboId = renderTargetId;
+        renderer->setViewportRect(QRect(QPoint(0, 0), renderTargetSize));
+    } else {
+        renderer->setViewportRect(QRect(QPoint(0, 0), size));
+    }
+    renderer->setProjectionMatrixToDeviceRect();
+
+    context->renderNextFrame(renderer, fboId);
+    emit q->afterRendering();
+}
+
+QQuickWindowPrivate::QQuickWindowPrivate()
+    : rootItem(0)
+    , activeFocusItem(0)
+    , mouseGrabberItem(0)
+    , touchMouseId(-1)
+    , touchMousePressTimestamp(0)
+    , renderWithoutShowing(false)
+    , dirtyItemList(0)
+    , context(0)
+    , renderer(0)
+    , windowManager(0)
+    , clearColor(Qt::white)
+    , clearBeforeRendering(true)
+    , persistentGLContext(false)
+    , persistentSceneGraph(false)
+    , lastWheelEventAccepted(false)
+    , renderTarget(0)
+    , renderTargetId(0)
+    , incubationController(0)
+{
+}
+
+QQuickWindowPrivate::~QQuickWindowPrivate()
+{
+}
+
+void QQuickWindowPrivate::init(QQuickWindow *c)
+{
+    q_ptr = c;
+
+    Q_Q(QQuickWindow);
+
+    rootItem = new QQuickRootItem;
+    QQmlEngine::setObjectOwnership(rootItem, QQmlEngine::CppOwnership);
+    QQuickItemPrivate *rootItemPrivate = QQuickItemPrivate::get(rootItem);
+    rootItemPrivate->window = q;
+    rootItemPrivate->windowRefCount = 1;
+    rootItemPrivate->flags |= QQuickItem::ItemIsFocusScope;
+
+    // In the absence of a focus in event on some platforms assume the window will
+    // be activated immediately and set focus on the rootItem
+    // ### Remove when QTBUG-22415 is resolved.
+    //It is important that this call happens after the rootItem has a window..
+    rootItem->setFocus(true);
+
+    windowManager = QQuickWindowManager::instance();
+    context = windowManager->sceneGraphContext();
+    q->setSurfaceType(QWindow::OpenGLSurface);
+    q->setFormat(context->defaultSurfaceFormat());
+
+    QObject::connect(context, SIGNAL(initialized()), q, SIGNAL(sceneGraphInitialized()), Qt::DirectConnection);
+    QObject::connect(context, SIGNAL(invalidated()), q, SIGNAL(sceneGraphInvalidated()), Qt::DirectConnection);
+    QObject::connect(context, SIGNAL(invalidated()), q, SLOT(cleanupSceneGraph()), Qt::DirectConnection);
+}
+
+QQmlListProperty<QObject> QQuickWindowPrivate::data()
+{
+    initRootItem();
+    return QQuickItemPrivate::get(rootItem)->data();
+}
+
+void QQuickWindowPrivate::initRootItem()
+{
+    Q_Q(QQuickWindow);
+    q->connect(q, SIGNAL(widthChanged(int)),
+            rootItem, SLOT(setWidth(int)));
+    q->connect(q, SIGNAL(heightChanged(int)),
+            rootItem, SLOT(setHeight(int)));
+    rootItem->setWidth(q->width());
+    rootItem->setHeight(q->height());
+}
+
+static QMouseEvent *touchToMouseEvent(QEvent::Type type, const QTouchEvent::TouchPoint &p, QTouchEvent *event, QQuickItem *item, bool transformNeeded = true)
+{
+    // The touch point local position and velocity are not yet transformed.
+    QMouseEvent *me = new QMouseEvent(type, transformNeeded ? item->mapFromScene(p.scenePos()) : p.pos(), p.scenePos(), p.screenPos(),
+                                      Qt::LeftButton, Qt::LeftButton, event->modifiers());
+    me->setAccepted(true);
+    me->setTimestamp(event->timestamp());
+    QVector2D transformedVelocity = p.velocity();
+    if (transformNeeded) {
+        QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+        QMatrix4x4 transformMatrix(itemPrivate->windowToItemTransform());
+        transformedVelocity = transformMatrix.mapVector(p.velocity()).toVector2D();
+    }
+    QGuiApplicationPrivate::setMouseEventCapsAndVelocity(me, event->device()->capabilities(), transformedVelocity);
+    return me;
+}
+
+bool QQuickWindowPrivate::translateTouchToMouse(QQuickItem *item, QTouchEvent *event)
+{
+    Q_Q(QQuickWindow);
+    // For each point, check if it is accepted, if not, try the next point.
+    // Any of the fingers can become the mouse one.
+    // This can happen because a mouse area might not accept an event at some point but another.
+    for (int i = 0; i < event->touchPoints().count(); ++i) {
+        const QTouchEvent::TouchPoint &p = event->touchPoints().at(i);
+        // A new touch point
+        if (touchMouseId == -1 && p.state() & Qt::TouchPointPressed) {
+            QPointF pos = item->mapFromScene(p.scenePos());
+
+            // probably redundant, we check bounds in the calling function (matchingNewPoints)
+            if (!item->contains(pos))
+                break;
+
+            bool doubleClick = event->timestamp() - touchMousePressTimestamp
+                            < static_cast<ulong>(qApp->styleHints()->mouseDoubleClickInterval());
+            touchMousePressTimestamp = event->timestamp();
+            // Store the id already here and restore it to -1 if the event does not get
+            // accepted. Cannot defer setting the new value because otherwise if the event
+            // handler spins the event loop all subsequent moves and releases get lost.
+            touchMouseId = p.id();
+            itemForTouchPointId[touchMouseId] = item;
+            QScopedPointer<QMouseEvent> mousePress(touchToMouseEvent(QEvent::MouseButtonPress, p, event, item));
+
+            // Send a single press and see if that's accepted
+            if (!mouseGrabberItem)
+                item->grabMouse();
+            item->grabTouchPoints(QVector<int>() << touchMouseId);
+
+            q->sendEvent(item, mousePress.data());
+            event->setAccepted(mousePress->isAccepted());
+            if (!mousePress->isAccepted()) {
+                touchMouseId = -1;
+                if (itemForTouchPointId.value(p.id()) == item)
+                    itemForTouchPointId.remove(p.id());
+
+                if (mouseGrabberItem == item)
+                    item->ungrabMouse();
+            }
+
+            if (doubleClick && mousePress->isAccepted()) {
+                touchMousePressTimestamp = 0;
+                QScopedPointer<QMouseEvent> mouseDoubleClick(touchToMouseEvent(QEvent::MouseButtonDblClick, p, event, item));
+                q->sendEvent(item, mouseDoubleClick.data());
+                event->setAccepted(mouseDoubleClick->isAccepted());
+                if (mouseDoubleClick->isAccepted()) {
+                    return true;
+                } else {
+                    touchMouseId = -1;
+                }
+            }
+            // The event was accepted, we are done.
+            if (mousePress->isAccepted())
+                return true;
+            // The event was not accepted but touchMouseId was set.
+            if (touchMouseId != -1)
+                return false;
+            // try the next point
+
+        // Touch point was there before and moved
+        } else if (p.id() == touchMouseId) {
+            if (p.state() & Qt::TouchPointMoved) {
+                if (mouseGrabberItem) {
+                    QScopedPointer<QMouseEvent> me(touchToMouseEvent(QEvent::MouseMove, p, event, mouseGrabberItem));
+                    q->sendEvent(mouseGrabberItem, me.data());
+                    event->setAccepted(me->isAccepted());
+                    if (me->isAccepted()) {
+                        itemForTouchPointId[p.id()] = mouseGrabberItem; // N.B. the mouseGrabberItem may be different after returning from sendEvent()
+                        return true;
+                    }
+                } else {
+                    // no grabber, check if we care about mouse hover
+                    // FIXME: this should only happen once, not recursively... I'll ignore it just ignore hover now.
+                    // hover for touch???
+                    QScopedPointer<QMouseEvent> me(touchToMouseEvent(QEvent::MouseMove, p, event, item));
+                    if (lastMousePosition.isNull())
+                        lastMousePosition = me->windowPos();
+                    QPointF last = lastMousePosition;
+                    lastMousePosition = me->windowPos();
+
+                    bool accepted = me->isAccepted();
+                    bool delivered = deliverHoverEvent(rootItem, me->windowPos(), last, me->modifiers(), accepted);
+                    if (!delivered) {
+                        //take care of any exits
+                        accepted = clearHover();
+                    }
+                    me->setAccepted(accepted);
+                    break;
+                }
+            } else if (p.state() & Qt::TouchPointReleased) {
+                // currently handled point was released
+                touchMouseId = -1;
+                if (mouseGrabberItem) {
+                    QScopedPointer<QMouseEvent> me(touchToMouseEvent(QEvent::MouseButtonRelease, p, event, mouseGrabberItem));
+                    q->sendEvent(mouseGrabberItem, me.data());
+                    if (mouseGrabberItem) // might have ungrabbed due to event
+                        mouseGrabberItem->ungrabMouse();
+                    return me->isAccepted();
+                }
+            }
+            break;
+        }
+    }
+    return false;
+}
+
+void QQuickWindowPrivate::transformTouchPoints(QList<QTouchEvent::TouchPoint> &touchPoints, const QTransform &transform)
+{
+    QMatrix4x4 transformMatrix(transform);
+    for (int i=0; i<touchPoints.count(); i++) {
+        QTouchEvent::TouchPoint &touchPoint = touchPoints[i];
+        touchPoint.setRect(transform.mapRect(touchPoint.sceneRect()));
+        touchPoint.setStartPos(transform.map(touchPoint.startScenePos()));
+        touchPoint.setLastPos(transform.map(touchPoint.lastScenePos()));
+        touchPoint.setVelocity(transformMatrix.mapVector(touchPoint.velocity()).toVector2D());
+    }
+}
+
+
+/*!
+Translates the data in \a touchEvent to this window.  This method leaves the item local positions in
+\a touchEvent untouched (these are filled in later).
+*/
+void QQuickWindowPrivate::translateTouchEvent(QTouchEvent *touchEvent)
+{
+    QList<QTouchEvent::TouchPoint> touchPoints = touchEvent->touchPoints();
+    for (int i = 0; i < touchPoints.count(); ++i) {
+        QTouchEvent::TouchPoint &touchPoint = touchPoints[i];
+
+        touchPoint.setScreenRect(touchPoint.sceneRect());
+        touchPoint.setStartScreenPos(touchPoint.startScenePos());
+        touchPoint.setLastScreenPos(touchPoint.lastScenePos());
+
+        touchPoint.setSceneRect(touchPoint.rect());
+        touchPoint.setStartScenePos(touchPoint.startPos());
+        touchPoint.setLastScenePos(touchPoint.lastPos());
+
+        if (i == 0)
+            lastMousePosition = touchPoint.pos().toPoint();
+    }
+    touchEvent->setTouchPoints(touchPoints);
+}
+
+void QQuickWindowPrivate::setFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions options)
+{
+    Q_Q(QQuickWindow);
+
+    Q_ASSERT(item);
+    Q_ASSERT(scope || item == rootItem);
+
+#ifdef FOCUS_DEBUG
+    qWarning() << "QQuickWindowPrivate::setFocusInScope():";
+    qWarning() << "    scope:" << (QObject *)scope;
+    if (scope)
+        qWarning() << "    scopeSubFocusItem:" << (QObject *)QQuickItemPrivate::get(scope)->subFocusItem;
+    qWarning() << "    item:" << (QObject *)item;
+    qWarning() << "    activeFocusItem:" << (QObject *)activeFocusItem;
+#endif
+
+    QQuickItemPrivate *scopePrivate = scope ? QQuickItemPrivate::get(scope) : 0;
+    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+
+    QQuickItem *oldActiveFocusItem = 0;
+    QQuickItem *newActiveFocusItem = 0;
+
+    QVarLengthArray<QQuickItem *, 20> changed;
+
+    // Does this change the active focus?
+    if (item == rootItem || (scopePrivate->activeFocus && item->isEnabled())) {
+        oldActiveFocusItem = activeFocusItem;
+        newActiveFocusItem = item;
+        while (newActiveFocusItem->isFocusScope()
+               && newActiveFocusItem->scopedFocusItem()
+               && newActiveFocusItem->scopedFocusItem()->isEnabled()) {
+            newActiveFocusItem = newActiveFocusItem->scopedFocusItem();
+        }
+
+        if (oldActiveFocusItem) {
+#ifndef QT_NO_IM
+            qApp->inputMethod()->commit();
+#endif
+
+            activeFocusItem = 0;
+            QFocusEvent event(QEvent::FocusOut, Qt::OtherFocusReason);
+            q->sendEvent(oldActiveFocusItem, &event);
+
+            QQuickItem *afi = oldActiveFocusItem;
+            while (afi && afi != scope) {
+                if (QQuickItemPrivate::get(afi)->activeFocus) {
+                    QQuickItemPrivate::get(afi)->activeFocus = false;
+                    changed << afi;
+                }
+                afi = afi->parentItem();
+            }
+        }
+    }
+
+    if (item != rootItem && !(options & DontChangeSubFocusItem)) {
+        QQuickItem *oldSubFocusItem = scopePrivate->subFocusItem;
+        if (oldSubFocusItem) {
+            QQuickItemPrivate::get(oldSubFocusItem)->focus = false;
+            changed << oldSubFocusItem;
+        }
+
+        QQuickItemPrivate::get(item)->updateSubFocusItem(scope, true);
+    }
+
+    if (!(options & DontChangeFocusProperty)) {
+//        if (item != rootItem || QGuiApplication::focusWindow() == q) {    // QTBUG-22415
+            itemPrivate->focus = true;
+            changed << item;
+//        }
+    }
+
+    if (newActiveFocusItem && rootItem->hasFocus()) {
+        activeFocusItem = newActiveFocusItem;
+
+        QQuickItemPrivate::get(newActiveFocusItem)->activeFocus = true;
+        changed << newActiveFocusItem;
+
+        QQuickItem *afi = newActiveFocusItem->parentItem();
+        while (afi && afi != scope) {
+            if (afi->isFocusScope()) {
+                QQuickItemPrivate::get(afi)->activeFocus = true;
+                changed << afi;
+            }
+            afi = afi->parentItem();
+        }
+
+        QFocusEvent event(QEvent::FocusIn, Qt::OtherFocusReason);
+        q->sendEvent(newActiveFocusItem, &event);
+    }
+
+    emit q->focusObjectChanged(activeFocusItem);
+
+    if (!changed.isEmpty())
+        notifyFocusChangesRecur(changed.data(), changed.count() - 1);
+}
+
+void QQuickWindowPrivate::clearFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions options)
+{
+    Q_Q(QQuickWindow);
+
+    Q_ASSERT(item);
+    Q_ASSERT(scope || item == rootItem);
+
+#ifdef FOCUS_DEBUG
+    qWarning() << "QQuickWindowPrivate::clearFocusInScope():";
+    qWarning() << "    scope:" << (QObject *)scope;
+    qWarning() << "    item:" << (QObject *)item;
+    qWarning() << "    activeFocusItem:" << (QObject *)activeFocusItem;
+#endif
+
+    QQuickItemPrivate *scopePrivate = 0;
+    if (scope) {
+        scopePrivate = QQuickItemPrivate::get(scope);
+        if ( !scopePrivate->subFocusItem )
+            return;//No focus, nothing to do.
+    }
+
+    QQuickItem *oldActiveFocusItem = 0;
+    QQuickItem *newActiveFocusItem = 0;
+
+    QVarLengthArray<QQuickItem *, 20> changed;
+
+    Q_ASSERT(item == rootItem || item == scopePrivate->subFocusItem);
+
+    // Does this change the active focus?
+    if (item == rootItem || scopePrivate->activeFocus) {
+        oldActiveFocusItem = activeFocusItem;
+        newActiveFocusItem = scope;
+
+        Q_ASSERT(oldActiveFocusItem);
+
+#ifndef QT_NO_IM
+        qApp->inputMethod()->commit();
+#endif
+
+        activeFocusItem = 0;
+        QFocusEvent event(QEvent::FocusOut, Qt::OtherFocusReason);
+        q->sendEvent(oldActiveFocusItem, &event);
+
+        QQuickItem *afi = oldActiveFocusItem;
+        while (afi && afi != scope) {
+            if (QQuickItemPrivate::get(afi)->activeFocus) {
+                QQuickItemPrivate::get(afi)->activeFocus = false;
+                changed << afi;
+            }
+            afi = afi->parentItem();
+        }
+    }
+
+    if (item != rootItem && !(options & DontChangeSubFocusItem)) {
+        QQuickItem *oldSubFocusItem = scopePrivate->subFocusItem;
+        if (oldSubFocusItem && !(options & DontChangeFocusProperty)) {
+            QQuickItemPrivate::get(oldSubFocusItem)->focus = false;
+            changed << oldSubFocusItem;
+        }
+
+        QQuickItemPrivate::get(item)->updateSubFocusItem(scope, false);
+
+    } else if (!(options & DontChangeFocusProperty)) {
+        QQuickItemPrivate::get(item)->focus = false;
+        changed << item;
+    }
+
+    if (newActiveFocusItem) {
+        Q_ASSERT(newActiveFocusItem == scope);
+        activeFocusItem = scope;
+
+        QFocusEvent event(QEvent::FocusIn, Qt::OtherFocusReason);
+        q->sendEvent(newActiveFocusItem, &event);
+    }
+
+    emit q->focusObjectChanged(activeFocusItem);
+
+    if (!changed.isEmpty())
+        notifyFocusChangesRecur(changed.data(), changed.count() - 1);
+}
+
+void QQuickWindowPrivate::notifyFocusChangesRecur(QQuickItem **items, int remaining)
+{
+    QQmlGuard<QQuickItem> item(*items);
+
+    if (remaining)
+        notifyFocusChangesRecur(items + 1, remaining - 1);
+
+    if (item) {
+        QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+
+        if (itemPrivate->notifiedFocus != itemPrivate->focus) {
+            itemPrivate->notifiedFocus = itemPrivate->focus;
+            emit item->focusChanged(itemPrivate->focus);
+        }
+
+        if (item && itemPrivate->notifiedActiveFocus != itemPrivate->activeFocus) {
+            itemPrivate->notifiedActiveFocus = itemPrivate->activeFocus;
+            itemPrivate->itemChange(QQuickItem::ItemActiveFocusHasChanged, itemPrivate->activeFocus);
+            emit item->activeFocusChanged(itemPrivate->activeFocus);
+        }
+    }
+}
+
+void QQuickWindowPrivate::dirtyItem(QQuickItem *)
+{
+    Q_Q(QQuickWindow);
+    q->maybeUpdate();
+}
+
+void QQuickWindowPrivate::cleanup(QSGNode *n)
+{
+    Q_Q(QQuickWindow);
+
+    Q_ASSERT(!cleanupNodeList.contains(n));
+    cleanupNodeList.append(n);
+    q->maybeUpdate();
+}
+
+
+/*!
+    \qmlmodule QtQuick.Window 2
+    \title QML Module QtQuick.Window 2.0
+    \brief Contains types for window management
+
+    This QML module contains types for creating top-level windows and accessing screen information.
+
+    To use the types in this module, import the module with the following line:
+
+    \code
+    import QtQuick.Window 2.0
+    \endcode
+*/
+
+/*!
+    \qmlclass Window QQuickWindow
+    \inqmlmodule QtQuick.Window 2
+    \ingroup qtquick-visual
+    \brief Creates a new top-level window
+
+    The Window object creates a new top-level window for a QtQuick scene. It automatically sets up the
+    window for use with QtQuick 2.0 graphical types.
+
+    To use this type, you will need to import the module with the following line:
+    \code
+    import QtQuick.Window 2.0
+    \endcode
+
+    Restricting this import will allow you to have a QML environment without access to window system features.
+*/
+/*!
+    \class QQuickWindow
+    \since QtQuick 2.0
+
+    \inmodule QtQuick
+
+    \brief The QQuickWindow class provides the window for displaying a graphical QML scene
+
+    QQuickWindow provides the graphical scene management needed to interact with and display
+    a scene of QQuickItems.
+
+    A QQuickWindow always has a single invisible root item. To add items to this window,
+    reparent the items to the root item or to an existing item in the scene.
+
+    For easily displaying a scene from a QML file, see \l{QQuickView}.
+
+    \section1 Scene Graph and Rendering
+
+    The QQuickWindow uses a scene graph on top of OpenGL to render. This scene graph is disconnected
+    from the QML scene and potentially lives in another thread, depending on the platform
+    implementation. Since the rendering scene graph lives independently from the QML scene, it can
+    also be completely released without affecting the state of the QML scene.
+
+    The sceneGraphInitialized() signal is emitted on the rendering thread before the QML scene is
+    rendered to the screen for the first time. If the rendering scene graph has been released
+    the signal will be emitted again before the next frame is rendered.
+
+    The rendering of each frame is broken down into the following
+    steps, in the given order:
+
+    \list 1
+
+    \li The QQuickWindow::beforeSynchronizing() signal is emitted.
+    Applications can make direct connections (Qt::DirectConnection)
+    to this signal to do any preparation required before calls to
+    QQuickItem::updatePaintNode().
+
+    \li Synchronization of the QML state into the scene graph. This is
+    done by calling the QQuickItem::updatePaintNode() function on all
+    items that have changed since the previous frame. When a dedicated
+    rendering thread is used, the GUI thread is blocked during this
+    synchroniation. This is the only time the QML items and the nodes
+    in the scene graph interact.
+
+    \li The window to be rendered is made current using
+    QOpenGLContext::makeCurrent().
+
+    \li The QQuickWindow::beforeRendering() signal is
+    emitted. Applications can make direct connections
+    (Qt::DirectConnection) to this signal to use custom OpenGL calls
+    which will then stack visually beneath the QML scene.
+
+    \li Items that have specified QSGNode::UsesPreprocess, will have their
+    QSGNode::preprocess() function invoked.
+
+    \li The QQuickWindow is cleared according to what is specified
+    using QQuickWindow::setClearBeforeRendering() and
+    QQuickWindow::setClearColor().
+
+    \li The scene graph is rendered.
+
+    \li The QQuickWindow::afterRendering() signal is
+    emitted. Applications can make direct connections
+    (Qt::DirectConnection) to this signal to use custom OpenGL calls
+    which will then stack visually over the QML scene.
+
+    \li The rendered frame is swapped and QQuickWindow::frameSwapped()
+    is emitted.
+
+    \endlist
+
+    All of the above happen on the rendering thread, when applicable.
+
+    While the scene graph is being rendered on the rendering thread, the GUI will process animations
+    for the next frame. This means that as long as users are not using scene graph API
+    directly, the added complexity of a rendering thread can be completely ignored.
+
+    When a QQuickWindow is programatically hidden with hide() or setVisible(false), it will
+    stop rendering and its scene graph and OpenGL context might be released. The
+    sceneGraphInvalidated() signal will be emitted when this happens.
+
+    \warning It is crucial that OpenGL operations and interaction with the scene graph happens
+    exclusively on the rendering thread, primarily during the updatePaintNode() phase.
+
+    \warning As signals related to rendering might be emitted from the rendering thread,
+    connections should be made using Qt::DirectConnection
+
+
+    \section2 Resource Management
+
+    QML will typically try to cache images, scene graph nodes, etc to improve performance, but in
+    some low-memory scenarios it might be required to aggressively release these resources. The
+    releaseResources() can be used to force clean up of certain resources. Calling releaseResources()
+    may result in the entire scene graph and its OpenGL context being deleted. The
+    sceneGraphInvalidated() signal will be emitted when this happens.
+
+*/
+QQuickWindow::QQuickWindow(QWindow *parent)
+    : QWindow(*(new QQuickWindowPrivate), parent)
+{
+    Q_D(QQuickWindow);
+    d->init(this);
+}
+
+QQuickWindow::QQuickWindow(QQuickWindowPrivate &dd, QWindow *parent)
+    : QWindow(dd, parent)
+{
+    Q_D(QQuickWindow);
+    d->init(this);
+}
+
+QQuickWindow::~QQuickWindow()
+{
+    Q_D(QQuickWindow);
+
+    d->windowManager->windowDestroyed(this);
+
+    QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);
+    delete d->incubationController; d->incubationController = 0;
+
+    delete d->rootItem; d->rootItem = 0;
+}
+
+
+
+/*!
+    This function tries to release redundant resources currently held by the QML scene.
+
+    Calling this function might result in the scene graph and the OpenGL context used
+    for rendering being released to release graphics memory. If this happens, the
+    sceneGraphInvalidated() signal will be called, allowing users to clean up their
+    own graphics resources. The setPersistentOpenGLContext() and setPersistentSceneGraph()
+    functions can be used to prevent this from happening, if handling the cleanup is
+    not feasible in the application, at the cost of higher memory usage.
+
+    \sa sceneGraphInvalidated(), setPersistentOpenGLContext(), setPersistentSceneGraph().
+ */
+
+void QQuickWindow::releaseResources()
+{
+    Q_D(QQuickWindow);
+    d->windowManager->releaseResources();
+    QQuickPixmap::purgeCache();
+}
+
+
+
+/*!
+    Controls whether the OpenGL context can be released as a part of a call to
+    releaseResources().
+
+    The OpenGL context might still be released when the user makes an explicit
+    call to hide().
+
+    \sa setPersistentSceneGraph()
+ */
+
+void QQuickWindow::setPersistentOpenGLContext(bool persistent)
+{
+    Q_D(QQuickWindow);
+    d->persistentGLContext = persistent;
+}
+
+
+/*!
+    Returns whether the OpenGL context can be released as a part of a call to
+    releaseResources().
+ */
+
+bool QQuickWindow::isPersistentOpenGLContext() const
+{
+    Q_D(const QQuickWindow);
+    return d->persistentGLContext;
+}
+
+
+
+/*!
+    Controls whether the scene graph nodes and resources can be released as a
+    part of a call to releaseResources().
+
+    The scene graph nodes and resources might still be released when the user
+    makes an explicit call to hide().
+
+    \sa setPersistentOpenGLContext()
+ */
+
+void QQuickWindow::setPersistentSceneGraph(bool persistent)
+{
+    Q_D(QQuickWindow);
+    d->persistentSceneGraph = persistent;
+}
+
+
+
+/*!
+    Returns whether the scene graph nodes and resources can be released as a part
+    of a call to releaseResources().
+ */
+
+bool QQuickWindow::isPersistentSceneGraph() const
+{
+    Q_D(const QQuickWindow);
+    return d->persistentSceneGraph;
+}
+
+
+
+
+
+/*!
+  Returns the invisible root item of the scene.
+
+  A QQuickWindow always has a single invisible root item containing all of its content.
+  To add items to this window, reparent the items to the contentItem or to an existing
+  item in the scene.
+*/
+QQuickItem *QQuickWindow::contentItem() const
+{
+    Q_D(const QQuickWindow);
+
+    return d->rootItem;
+}
+
+/*!
+  Returns the item which currently has active focus.
+*/
+QQuickItem *QQuickWindow::activeFocusItem() const
+{
+    Q_D(const QQuickWindow);
+
+    return d->activeFocusItem;
+}
+
+/*!
+  \internal
+  \reimp
+*/
+QObject *QQuickWindow::focusObject() const
+{
+    Q_D(const QQuickWindow);
+
+    if (d->activeFocusItem)
+        return d->activeFocusItem;
+    return const_cast<QQuickWindow*>(this);
+}
+
+
+/*!
+  Returns the item which currently has the mouse grab.
+*/
+QQuickItem *QQuickWindow::mouseGrabberItem() const
+{
+    Q_D(const QQuickWindow);
+
+    return d->mouseGrabberItem;
+}
+
+
+/*!
+    \qmlproperty color QtQuick.Window2::Window::color
+
+    The background color for the window.
+
+    Setting this property is more efficient than using a separate Rectangle.
+*/
+
+bool QQuickWindowPrivate::clearHover()
+{
+    Q_Q(QQuickWindow);
+    if (hoverItems.isEmpty())
+        return false;
+
+    QPointF pos = q->mapFromGlobal(QGuiApplicationPrivate::lastCursorPosition.toPoint());
+
+    bool accepted = false;
+    foreach (QQuickItem* item, hoverItems)
+        accepted = sendHoverEvent(QEvent::HoverLeave, item, pos, pos, QGuiApplication::keyboardModifiers(), true) || accepted;
+    hoverItems.clear();
+    return accepted;
+}
+
+/*! \reimp */
+bool QQuickWindow::event(QEvent *e)
+{
+    Q_D(QQuickWindow);
+
+    switch (e->type()) {
+
+    case QEvent::TouchBegin:
+    case QEvent::TouchUpdate:
+    case QEvent::TouchEnd: {
+        QTouchEvent *touch = static_cast<QTouchEvent*>(e);
+        d->translateTouchEvent(touch);
+        // return in order to avoid the QWindow::event below
+        return d->deliverTouchEvent(touch);
+    }
+        break;
+    case QEvent::TouchCancel:
+        // return in order to avoid the QWindow::event below
+        return d->deliverTouchCancelEvent(static_cast<QTouchEvent*>(e));
+        break;
+    case QEvent::Leave:
+        d->clearHover();
+        d->lastMousePosition = QPoint();
+        break;
+#ifndef QT_NO_DRAGANDDROP
+    case QEvent::DragEnter:
+    case QEvent::DragLeave:
+    case QEvent::DragMove:
+    case QEvent::Drop:
+        d->deliverDragEvent(&d->dragGrabber, e);
+        break;
+#endif
+    case QEvent::WindowDeactivate:
+        rootItem()->windowDeactivateEvent();
+        break;
+    case QEvent::FocusAboutToChange:
+        if (d->activeFocusItem)
+            qGuiApp->inputMethod()->commit();
+        break;
+    default:
+        break;
+    }
+
+    return QWindow::event(e);
+}
+
+/*! \reimp */
+void QQuickWindow::keyPressEvent(QKeyEvent *e)
+{
+    Q_D(QQuickWindow);
+
+    if (d->activeFocusItem)
+        sendEvent(d->activeFocusItem, e);
+}
+
+/*! \reimp */
+void QQuickWindow::keyReleaseEvent(QKeyEvent *e)
+{
+    Q_D(QQuickWindow);
+
+    if (d->activeFocusItem)
+        sendEvent(d->activeFocusItem, e);
+}
+
+QMouseEvent *QQuickWindowPrivate::cloneMouseEvent(QMouseEvent *event, QPointF *transformedLocalPos)
+{
+    int caps = QGuiApplicationPrivate::mouseEventCaps(event);
+    QVector2D velocity = QGuiApplicationPrivate::mouseEventVelocity(event);
+    QMouseEvent *me = new QMouseEvent(event->type(),
+                                      transformedLocalPos ? *transformedLocalPos : event->localPos(),
+                                      event->windowPos(), event->screenPos(),
+                                      event->button(), event->buttons(), event->modifiers());
+    QGuiApplicationPrivate::setMouseEventCapsAndVelocity(me, caps, velocity);
+    me->setTimestamp(event->timestamp());
+    return me;
+}
+
+bool QQuickWindowPrivate::deliverInitialMousePressEvent(QQuickItem *item, QMouseEvent *event)
+{
+    Q_Q(QQuickWindow);
+
+    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+
+    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
+        QPointF p = item->mapFromScene(event->windowPos());
+        if (!item->contains(p))
+            return false;
+    }
+
+    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+    for (int ii = children.count() - 1; ii >= 0; --ii) {
+        QQuickItem *child = children.at(ii);
+        if (!child->isVisible() || !child->isEnabled())
+            continue;
+        if (deliverInitialMousePressEvent(child, event))
+            return true;
+    }
+
+    if (itemPrivate->acceptedMouseButtons() & event->button()) {
+        QPointF localPos = item->mapFromScene(event->windowPos());
+        if (item->contains(localPos)) {
+            QScopedPointer<QMouseEvent> me(cloneMouseEvent(event, &localPos));
+            me->accept();
+            item->grabMouse();
+            q->sendEvent(item, me.data());
+            event->setAccepted(me->isAccepted());
+            if (me->isAccepted())
+                return true;
+            if (mouseGrabberItem && !event->buttons())
+                mouseGrabberItem->ungrabMouse();
+        }
+    }
+
+    return false;
+}
+
+bool QQuickWindowPrivate::deliverMouseEvent(QMouseEvent *event)
+{
+    Q_Q(QQuickWindow);
+
+    lastMousePosition = event->windowPos();
+
+    if (!mouseGrabberItem &&
+         event->type() == QEvent::MouseButtonPress &&
+         (event->buttons() & event->button()) == event->buttons()) {
+        if (deliverInitialMousePressEvent(rootItem, event))
+            event->accept();
+        else
+            event->ignore();
+        return event->isAccepted();
+    }
+
+    if (mouseGrabberItem) {
+        QPointF localPos = mouseGrabberItem->mapFromScene(event->windowPos());
+        QScopedPointer<QMouseEvent> me(cloneMouseEvent(event, &localPos));
+        me->accept();
+        q->sendEvent(mouseGrabberItem, me.data());
+        event->setAccepted(me->isAccepted());
+        if (me->isAccepted())
+            return true;
+    }
+
+    return false;
+}
+
+/*! \reimp */
+void QQuickWindow::mousePressEvent(QMouseEvent *event)
+{
+    Q_D(QQuickWindow);
+#ifdef MOUSE_DEBUG
+    qWarning() << "QQuickWindow::mousePressEvent()" << event->localPos() << event->button() << event->buttons();
+#endif
+
+    d->deliverMouseEvent(event);
+}
+
+/*! \reimp */
+void QQuickWindow::mouseReleaseEvent(QMouseEvent *event)
+{
+    Q_D(QQuickWindow);
+#ifdef MOUSE_DEBUG
+    qWarning() << "QQuickWindow::mouseReleaseEvent()" << event->localPos() << event->button() << event->buttons();
+#endif
+
+    if (!d->mouseGrabberItem) {
+        QWindow::mouseReleaseEvent(event);
+        return;
+    }
+
+    d->deliverMouseEvent(event);
+    if (d->mouseGrabberItem && !event->buttons())
+        d->mouseGrabberItem->ungrabMouse();
+}
+
+/*! \reimp */
+void QQuickWindow::mouseDoubleClickEvent(QMouseEvent *event)
+{
+    Q_D(QQuickWindow);
+#ifdef MOUSE_DEBUG
+    qWarning() << "QQuickWindow::mouseDoubleClickEvent()" << event->localPos() << event->button() << event->buttons();
+#endif
+
+    if (!d->mouseGrabberItem && (event->buttons() & event->button()) == event->buttons()) {
+        if (d->deliverInitialMousePressEvent(d->rootItem, event))
+            event->accept();
+        else
+            event->ignore();
+        return;
+    }
+
+    d->deliverMouseEvent(event);
+}
+
+bool QQuickWindowPrivate::sendHoverEvent(QEvent::Type type, QQuickItem *item,
+                                      const QPointF &scenePos, const QPointF &lastScenePos,
+                                      Qt::KeyboardModifiers modifiers, bool accepted)
+{
+    Q_Q(QQuickWindow);
+    const QTransform transform = QQuickItemPrivate::get(item)->windowToItemTransform();
+
+    //create copy of event
+    QHoverEvent hoverEvent(type, transform.map(scenePos), transform.map(lastScenePos), modifiers);
+    hoverEvent.setAccepted(accepted);
+
+    q->sendEvent(item, &hoverEvent);
+
+    return hoverEvent.isAccepted();
+}
+
+/*! \reimp */
+void QQuickWindow::mouseMoveEvent(QMouseEvent *event)
+{
+    Q_D(QQuickWindow);
+#ifdef MOUSE_DEBUG
+    qWarning() << "QQuickWindow::mouseMoveEvent()" << event->localPos() << event->button() << event->buttons();
+#endif
+
+    if (!d->mouseGrabberItem) {
+        if (d->lastMousePosition.isNull())
+            d->lastMousePosition = event->windowPos();
+        QPointF last = d->lastMousePosition;
+        d->lastMousePosition = event->windowPos();
+
+        bool accepted = event->isAccepted();
+        bool delivered = d->deliverHoverEvent(d->rootItem, event->windowPos(), last, event->modifiers(), accepted);
+        if (!delivered) {
+            //take care of any exits
+            accepted = d->clearHover();
+        }
+        event->setAccepted(accepted);
+        return;
+    }
+
+    d->deliverMouseEvent(event);
+}
+
+bool QQuickWindowPrivate::deliverHoverEvent(QQuickItem *item, const QPointF &scenePos, const QPointF &lastScenePos,
+                                         Qt::KeyboardModifiers modifiers, bool &accepted)
+{
+    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+
+    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
+        QPointF p = item->mapFromScene(scenePos);
+        if (!item->contains(p))
+            return false;
+    }
+
+    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+    for (int ii = children.count() - 1; ii >= 0; --ii) {
+        QQuickItem *child = children.at(ii);
+        if (!child->isVisible() || !child->isEnabled())
+            continue;
+        if (deliverHoverEvent(child, scenePos, lastScenePos, modifiers, accepted))
+            return true;
+    }
+
+    if (itemPrivate->hoverEnabled) {
+        QPointF p = item->mapFromScene(scenePos);
+        if (item->contains(p)) {
+            if (!hoverItems.isEmpty() && hoverItems[0] == item) {
+                //move
+                accepted = sendHoverEvent(QEvent::HoverMove, item, scenePos, lastScenePos, modifiers, accepted);
+            } else {
+                QList<QQuickItem *> itemsToHover;
+                QQuickItem* parent = item;
+                itemsToHover << item;
+                while ((parent = parent->parentItem()))
+                    itemsToHover << parent;
+
+                // Leaving from previous hovered items until we reach the item or one of its ancestors.
+                while (!hoverItems.isEmpty() && !itemsToHover.contains(hoverItems[0])) {
+                    sendHoverEvent(QEvent::HoverLeave, hoverItems[0], scenePos, lastScenePos, modifiers, accepted);
+                    hoverItems.removeFirst();
+                }
+
+                if (!hoverItems.isEmpty() && hoverItems[0] == item){//Not entering a new Item
+                    // ### Shouldn't we send moves for the parent items as well?
+                    accepted = sendHoverEvent(QEvent::HoverMove, item, scenePos, lastScenePos, modifiers, accepted);
+                } else {
+                    // Enter items that are not entered yet.
+                    int startIdx = -1;
+                    if (!hoverItems.isEmpty())
+                        startIdx = itemsToHover.indexOf(hoverItems[0]) - 1;
+                    if (startIdx == -1)
+                        startIdx = itemsToHover.count() - 1;
+
+                    for (int i = startIdx; i >= 0; i--) {
+                        QQuickItem *itemToHover = itemsToHover[i];
+                        if (QQuickItemPrivate::get(itemToHover)->hoverEnabled) {
+                            hoverItems.prepend(itemToHover);
+                            sendHoverEvent(QEvent::HoverEnter, itemToHover, scenePos, lastScenePos, modifiers, accepted);
+                        }
+                    }
+                }
+            }
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool QQuickWindowPrivate::deliverWheelEvent(QQuickItem *item, QWheelEvent *event)
+{
+    Q_Q(QQuickWindow);
+    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+
+    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
+        QPointF p = item->mapFromScene(event->posF());
+        if (!item->contains(p))
+            return false;
+    }
+
+    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+    for (int ii = children.count() - 1; ii >= 0; --ii) {
+        QQuickItem *child = children.at(ii);
+        if (!child->isVisible() || !child->isEnabled())
+            continue;
+        if (deliverWheelEvent(child, event))
+            return true;
+    }
+
+    QPointF p = item->mapFromScene(event->posF());
+
+    if (item->contains(p)) {
+        QWheelEvent wheel(p, p, event->pixelDelta(), event->angleDelta(), event->delta(),
+                          event->orientation(), event->buttons(), event->modifiers());
+        wheel.accept();
+        q->sendEvent(item, &wheel);
+        if (wheel.isAccepted()) {
+            event->accept();
+            return true;
+        }
+    }
+
+    return false;
+}
+
+#ifndef QT_NO_WHEELEVENT
+/*! \reimp */
+void QQuickWindow::wheelEvent(QWheelEvent *event)
+{
+    Q_D(QQuickWindow);
+#ifdef MOUSE_DEBUG
+    qWarning() << "QQuickWindow::wheelEvent()" << event->pixelDelta() << event->angleDelta();
+#endif
+
+    //if the actual wheel event was accepted, accept the compatability wheel event and return early
+    if (d->lastWheelEventAccepted && event->angleDelta().isNull())
+        return;
+
+    event->ignore();
+    d->deliverWheelEvent(d->rootItem, event);
+    d->lastWheelEventAccepted = event->isAccepted();
+}
+#endif // QT_NO_WHEELEVENT
+
+
+bool QQuickWindowPrivate::deliverTouchCancelEvent(QTouchEvent *event)
+{
+#ifdef TOUCH_DEBUG
+    qWarning("touchCancelEvent");
+#endif
+    Q_Q(QQuickWindow);
+    // A TouchCancel event will typically not contain any points.
+    // Deliver it to all items that have active touches.
+    QSet<QQuickItem *> cancelDelivered;
+    foreach (QQuickItem *item, itemForTouchPointId) {
+        if (cancelDelivered.contains(item))
+            continue;
+        cancelDelivered.insert(item);
+        q->sendEvent(item, event);
+    }
+    touchMouseId = -1;
+    if (mouseGrabberItem)
+        mouseGrabberItem->ungrabMouse();
+    // The next touch event can only be a TouchBegin so clean up.
+    itemForTouchPointId.clear();
+    return true;
+}
+
+// check what kind of touch we have (begin/update) and
+// call deliverTouchPoints to actually dispatch the points
+bool QQuickWindowPrivate::deliverTouchEvent(QTouchEvent *event)
+{
+#ifdef TOUCH_DEBUG
+    if (event->type() == QEvent::TouchBegin)
+        qWarning() << "touchBeginEvent";
+    else if (event->type() == QEvent::TouchUpdate)
+        qWarning() << "touchUpdateEvent points";
+    else if (event->type() == QEvent::TouchEnd)
+        qWarning("touchEndEvent");
+#endif
+
+    // List of all items that received an event before
+    // When we have TouchBegin this is and will stay empty
+    QHash<QQuickItem *, QList<QTouchEvent::TouchPoint> > updatedPoints;
+
+    // Figure out who accepted a touch point last and put it in updatedPoints
+    // Add additional item to newPoints
+    const QList<QTouchEvent::TouchPoint> &touchPoints = event->touchPoints();
+    QList<QTouchEvent::TouchPoint> newPoints;
+    for (int i=0; i<touchPoints.count(); i++) {
+        const QTouchEvent::TouchPoint &touchPoint = touchPoints.at(i);
+        if (touchPoint.state() == Qt::TouchPointPressed) {
+            newPoints << touchPoint;
+        } else {
+            // TouchPointStationary is relevant only to items which
+            // are also receiving touch points with some other state.
+            // But we have not yet decided which points go to which item,
+            // so for now we must include all non-new points in updatedPoints.
+            if (itemForTouchPointId.contains(touchPoint.id())) {
+                QQuickItem *item = itemForTouchPointId.value(touchPoint.id());
+                if (item)
+                    updatedPoints[item].append(touchPoint);
+            }
+        }
+    }
+
+    // Deliver the event, but only if there is at least one new point
+    // or some item accepted a point and should receive an update
+    if (newPoints.count() > 0 || updatedPoints.count() > 0) {
+        QSet<int> acceptedNewPoints;
+        event->setAccepted(deliverTouchPoints(rootItem, event, newPoints, &acceptedNewPoints, &updatedPoints));
+    } else
+        event->ignore();
+
+    // Remove released points from itemForTouchPointId
+    if (event->touchPointStates() & Qt::TouchPointReleased) {
+        for (int i=0; i<touchPoints.count(); i++) {
+            if (touchPoints[i].state() == Qt::TouchPointReleased) {
+                itemForTouchPointId.remove(touchPoints[i].id());
+                if (touchPoints[i].id() == touchMouseId)
+                    touchMouseId = -1;
+            }
+        }
+    }
+
+    if (event->type() == QEvent::TouchEnd) {
+        Q_ASSERT(itemForTouchPointId.isEmpty());
+    }
+
+    return event->isAccepted();
+}
+
+// This function recurses and sends the events to the individual items
+bool QQuickWindowPrivate::deliverTouchPoints(QQuickItem *item, QTouchEvent *event, const QList<QTouchEvent::TouchPoint> &newPoints, QSet<int> *acceptedNewPoints, QHash<QQuickItem *, QList<QTouchEvent::TouchPoint> > *updatedPoints)
+{
+    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+
+    if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
+        for (int i=0; i<newPoints.count(); i++) {
+            QPointF p = item->mapFromScene(newPoints[i].scenePos());
+            if (!item->contains(p))
+                return false;
+        }
+    }
+
+    // Check if our children want the event (or parts of it)
+    // This is the only point where touch event delivery recurses!
+    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+    for (int ii = children.count() - 1; ii >= 0; --ii) {
+        QQuickItem *child = children.at(ii);
+        if (!child->isEnabled() || !child->isVisible())
+            continue;
+        if (deliverTouchPoints(child, event, newPoints, acceptedNewPoints, updatedPoints))
+            return true;
+    }
+
+    // None of the children accepted the event, so check the given item itself.
+    // First, construct matchingPoints as a list of TouchPoints which the
+    // given item might be interested in.  Any newly-pressed point which is
+    // inside the item's bounds will be interesting, and also any updated point
+    // which was already accepted by that item when it was first pressed.
+    // (A point which was already accepted is effectively "grabbed" by the item.)
+
+    // set of IDs of "interesting" new points
+    QSet<int> matchingNewPoints;
+    // set of points which this item has previously accepted, for starters
+    QList<QTouchEvent::TouchPoint> matchingPoints = (*updatedPoints)[item];
+    // now add the new points which are inside this item's bounds
+    if (newPoints.count() > 0 && acceptedNewPoints->count() < newPoints.count()) {
+        for (int i = 0; i < newPoints.count(); i++) {
+            if (acceptedNewPoints->contains(newPoints[i].id()))
+                continue;
+            QPointF p = item->mapFromScene(newPoints[i].scenePos());
+            if (item->contains(p)) {
+                matchingNewPoints.insert(newPoints[i].id());
+                matchingPoints << newPoints[i];
+            }
+        }
+    }
+    // If there are no matching new points, and the existing points are all stationary,
+    // there's no need to send an event to this item.  This is required by a test in
+    // tst_qquickwindow::touchEvent_basic:
+    // a single stationary press on an item shouldn't cause an event
+    if (matchingNewPoints.isEmpty()) {
+        bool stationaryOnly = true;
+        Q_FOREACH (QTouchEvent::TouchPoint tp, matchingPoints)
+            if (tp.state() != Qt::TouchPointStationary)
+                stationaryOnly = false;
+        if (stationaryOnly)
+            matchingPoints.clear();
+    }
+
+    if (!matchingPoints.isEmpty()) {
+        // Now we know this item might be interested in the event. Copy and send it, but
+        // with only the subset of TouchPoints which are relevant to that item: that's matchingPoints.
+        QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+        transformTouchPoints(matchingPoints, itemPrivate->windowToItemTransform());
+        deliverMatchingPointsToItem(item, event, acceptedNewPoints, matchingNewPoints, matchingPoints);
+    }
+
+    // record the fact that this item has been visited already
+    updatedPoints->remove(item);
+
+    // recursion is done only if ALL touch points have been delivered
+    return (acceptedNewPoints->count() == newPoints.count() && updatedPoints->isEmpty());
+}
+
+// touchEventForItemBounds has no means to generate a touch event that contains
+// only the points that are relevant for this item.  Thus the need for
+// matchingPoints to already be that set of interesting points.
+// They are all pre-transformed, too.
+bool QQuickWindowPrivate::deliverMatchingPointsToItem(QQuickItem *item, QTouchEvent *event, QSet<int> *acceptedNewPoints, const QSet<int> &matchingNewPoints, const QList<QTouchEvent::TouchPoint> &matchingPoints)
+{
+    QScopedPointer<QTouchEvent> touchEvent(touchEventWithPoints(*event, matchingPoints));
+    touchEvent.data()->setTarget(item);
+    bool touchEventAccepted = false;
+
+    // First check whether the parent wants to be a filter,
+    // and if the parent accepts the event we are done.
+    if (sendFilteredTouchEvent(item->parentItem(), item, event)) {
+        event->accept();
+        return true;
+    }
+
+    // Since it can change in sendEvent, update itemForTouchPointId now
+    foreach (int id, matchingNewPoints)
+        itemForTouchPointId[id] = item;
+
+    // Deliver the touch event to the given item
+    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+    itemPrivate->deliverTouchEvent(touchEvent.data());
+    touchEventAccepted = touchEvent->isAccepted();
+
+    // If the touch event wasn't accepted, synthesize a mouse event and see if the item wants it.
+    if (!touchEventAccepted && (itemPrivate->acceptedMouseButtons() & Qt::LeftButton)) {
+        //  send mouse event
+        event->setAccepted(translateTouchToMouse(item, event));
+        if (event->isAccepted()) {
+            touchEventAccepted = true;
+        }
+    }
+
+    if (touchEventAccepted) {
+        // If the touch was accepted (regardless by whom or in what form),
+        // update acceptedNewPoints.
+        foreach (int id, matchingNewPoints)
+            acceptedNewPoints->insert(id);
+    } else {
+        // But if the event was not accepted then we know this item
+        // will not be interested in further updates for those touchpoint IDs either.
+        foreach (int id, matchingNewPoints)
+            if (itemForTouchPointId[id] == item)
+                itemForTouchPointId.remove(id);
+    }
+
+    return touchEventAccepted;
+}
+
+QTouchEvent *QQuickWindowPrivate::touchEventForItemBounds(QQuickItem *target, const QTouchEvent &originalEvent)
+{
+    const QList<QTouchEvent::TouchPoint> &touchPoints = originalEvent.touchPoints();
+    QList<QTouchEvent::TouchPoint> pointsInBounds;
+    // if all points are stationary, the list of points should be empty to signal a no-op
+    if (originalEvent.touchPointStates() != Qt::TouchPointStationary) {
+        for (int i = 0; i < touchPoints.count(); ++i) {
+            const QTouchEvent::TouchPoint &tp = touchPoints.at(i);
+            if (tp.state() == Qt::TouchPointPressed) {
+                QPointF p = target->mapFromScene(tp.scenePos());
+                if (target->contains(p))
+                    pointsInBounds.append(tp);
+            } else {
+                pointsInBounds.append(tp);
+            }
+        }
+        transformTouchPoints(pointsInBounds, QQuickItemPrivate::get(target)->windowToItemTransform());
+    }
+
+    QTouchEvent* touchEvent = touchEventWithPoints(originalEvent, pointsInBounds);
+    touchEvent->setTarget(target);
+    return touchEvent;
+}
+
+QTouchEvent *QQuickWindowPrivate::touchEventWithPoints(const QTouchEvent &event, const QList<QTouchEvent::TouchPoint> &newPoints)
+{
+    Qt::TouchPointStates eventStates;
+    for (int i=0; i<newPoints.count(); i++)
+        eventStates |= newPoints[i].state();
+    // if all points have the same state, set the event type accordingly
+    QEvent::Type eventType = event.type();
+    switch (eventStates) {
+        case Qt::TouchPointPressed:
+            eventType = QEvent::TouchBegin;
+            break;
+        case Qt::TouchPointReleased:
+            eventType = QEvent::TouchEnd;
+            break;
+        default:
+            eventType = QEvent::TouchUpdate;
+            break;
+    }
+
+    QTouchEvent *touchEvent = new QTouchEvent(eventType);
+    touchEvent->setWindow(event.window());
+    touchEvent->setTarget(event.target());
+    touchEvent->setDevice(event.device());
+    touchEvent->setModifiers(event.modifiers());
+    touchEvent->setTouchPoints(newPoints);
+    touchEvent->setTouchPointStates(eventStates);
+    touchEvent->setTimestamp(event.timestamp());
+    touchEvent->accept();
+    return touchEvent;
+}
+
+#ifndef QT_NO_DRAGANDDROP
+void QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QEvent *event)
+{
+    Q_Q(QQuickWindow);
+    grabber->resetTarget();
+    QQuickDragGrabber::iterator grabItem = grabber->begin();
+    if (grabItem != grabber->end()) {
+        Q_ASSERT(event->type() != QEvent::DragEnter);
+        if (event->type() == QEvent::Drop) {
+            QDropEvent *e = static_cast<QDropEvent *>(event);
+            for (e->setAccepted(false); !e->isAccepted() && grabItem != grabber->end(); grabItem = grabber->release(grabItem)) {
+                QPointF p = (**grabItem)->mapFromScene(e->pos());
+                QDropEvent translatedEvent(
+                        p.toPoint(),
+                        e->possibleActions(),
+                        e->mimeData(),
+                        e->mouseButtons(),
+                        e->keyboardModifiers());
+                QQuickDropEventEx::copyActions(&translatedEvent, *e);
+                q->sendEvent(**grabItem, &translatedEvent);
+                e->setAccepted(translatedEvent.isAccepted());
+                e->setDropAction(translatedEvent.dropAction());
+                grabber->setTarget(**grabItem);
+            }
+        }
+        if (event->type() != QEvent::DragMove) {    // Either an accepted drop or a leave.
+            QDragLeaveEvent leaveEvent;
+            for (; grabItem != grabber->end(); grabItem = grabber->release(grabItem))
+                q->sendEvent(**grabItem, &leaveEvent);
+            return;
+        } else for (; grabItem != grabber->end(); grabItem = grabber->release(grabItem)) {
+            QDragMoveEvent *moveEvent = static_cast<QDragMoveEvent *>(event);
+            if (deliverDragEvent(grabber, **grabItem, moveEvent)) {
+                moveEvent->setAccepted(true);
+                for (++grabItem; grabItem != grabber->end();) {
+                    QPointF p = (**grabItem)->mapFromScene(moveEvent->pos());
+                    if ((**grabItem)->contains(p)) {
+                        QDragMoveEvent translatedEvent(
+                                p.toPoint(),
+                                moveEvent->possibleActions(),
+                                moveEvent->mimeData(),
+                                moveEvent->mouseButtons(),
+                                moveEvent->keyboardModifiers());
+                        QQuickDropEventEx::copyActions(&translatedEvent, *moveEvent);
+                        q->sendEvent(**grabItem, &translatedEvent);
+                        ++grabItem;
+                    } else {
+                        QDragLeaveEvent leaveEvent;
+                        q->sendEvent(**grabItem, &leaveEvent);
+                        grabItem = grabber->release(grabItem);
+                    }
+                }
+                return;
+            } else {
+                QDragLeaveEvent leaveEvent;
+                q->sendEvent(**grabItem, &leaveEvent);
+            }
+        }
+    }
+    if (event->type() == QEvent::DragEnter || event->type() == QEvent::DragMove) {
+        QDragMoveEvent *e = static_cast<QDragMoveEvent *>(event);
+        QDragEnterEvent enterEvent(
+                e->pos(),
+                e->possibleActions(),
+                e->mimeData(),
+                e->mouseButtons(),
+                e->keyboardModifiers());
+        QQuickDropEventEx::copyActions(&enterEvent, *e);
+        event->setAccepted(deliverDragEvent(grabber, rootItem, &enterEvent));
+    }
+}
+
+bool QQuickWindowPrivate::deliverDragEvent(QQuickDragGrabber *grabber, QQuickItem *item, QDragMoveEvent *event)
+{
+    Q_Q(QQuickWindow);
+    bool accepted = false;
+    QQuickItemPrivate *itemPrivate = QQuickItemPrivate::get(item);
+    if (!item->isVisible() || !item->isEnabled())
+        return false;
+
+    QPointF p = item->mapFromScene(event->pos());
+    if (item->contains(p)) {
+        if (event->type() == QEvent::DragMove || itemPrivate->flags & QQuickItem::ItemAcceptsDrops) {
+            QDragMoveEvent translatedEvent(
+                    p.toPoint(),
+                    event->possibleActions(),
+                    event->mimeData(),
+                    event->mouseButtons(),
+                    event->keyboardModifiers(),
+                    event->type());
+            QQuickDropEventEx::copyActions(&translatedEvent, *event);
+            q->sendEvent(item, &translatedEvent);
+            if (event->type() == QEvent::DragEnter) {
+                if (translatedEvent.isAccepted()) {
+                    grabber->grab(item);
+                    accepted = true;
+                }
+            } else {
+                accepted = true;
+            }
+        }
+    } else if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
+        return false;
+    }
+
+    QDragEnterEvent enterEvent(
+            event->pos(),
+            event->possibleActions(),
+            event->mimeData(),
+            event->mouseButtons(),
+            event->keyboardModifiers());
+    QQuickDropEventEx::copyActions(&enterEvent, *event);
+    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+    for (int ii = children.count() - 1; ii >= 0; --ii) {
+        if (deliverDragEvent(grabber, children.at(ii), &enterEvent))
+            return true;
+    }
+
+    return accepted;
+}
+#endif // QT_NO_DRAGANDDROP
+
+bool QQuickWindowPrivate::sendFilteredTouchEvent(QQuickItem *target, QQuickItem *item, QTouchEvent *event)
+{
+    if (!target)
+        return false;
+
+    QQuickItemPrivate *targetPrivate = QQuickItemPrivate::get(target);
+    if (targetPrivate->filtersChildMouseEvents) {
+        QScopedPointer<QTouchEvent> targetEvent(touchEventForItemBounds(target, *event));
+        if (!targetEvent->touchPoints().isEmpty()) {
+            QVector<int> touchIds;
+            for (int i = 0; i < event->touchPoints().size(); ++i)
+                touchIds.append(event->touchPoints().at(i).id());
+            if (target->childMouseEventFilter(item, targetEvent.data())) {
+                target->grabTouchPoints(touchIds);
+                if (mouseGrabberItem) {
+                    mouseGrabberItem->ungrabMouse();
+                    touchMouseId = -1;
+                }
+                return true;
+            }
+
+            // Only offer a mouse event to the filter if we have one point
+            if (targetEvent->touchPoints().count() == 1) {
+                QEvent::Type t;
+                const QTouchEvent::TouchPoint &tp = targetEvent->touchPoints().first();
+                switch (tp.state()) {
+                case Qt::TouchPointPressed:
+                    t = QEvent::MouseButtonPress;
+                    break;
+                case Qt::TouchPointReleased:
+                    t = QEvent::MouseButtonRelease;
+                    break;
+                default:
+                    // move or stationary
+                    t = QEvent::MouseMove;
+                    break;
+                }
+
+                // targetEvent is already transformed wrt local position, velocity, etc.
+                QScopedPointer<QMouseEvent> mouseEvent(touchToMouseEvent(t, targetEvent->touchPoints().first(), event, item, false));
+                if (target->childMouseEventFilter(item, mouseEvent.data())) {
+                    itemForTouchPointId[tp.id()] = target;
+                    touchMouseId = tp.id();
+                    target->grabMouse();
+                    return true;
+                }
+            }
+        }
+    }
+
+    return sendFilteredTouchEvent(target->parentItem(), item, event);
+}
+
+bool QQuickWindowPrivate::sendFilteredMouseEvent(QQuickItem *target, QQuickItem *item, QEvent *event)
+{
+    if (!target)
+        return false;
+
+    QQuickItemPrivate *targetPrivate = QQuickItemPrivate::get(target);
+    if (targetPrivate->filtersChildMouseEvents)
+        if (target->childMouseEventFilter(item, event))
+            return true;
+
+    if (sendFilteredMouseEvent(target->parentItem(), item, event))
+        return true;
+
+    return false;
+}
+
+bool QQuickWindowPrivate::dragOverThreshold(qreal d, Qt::Axis axis, QMouseEvent *event)
+{
+    QStyleHints *styleHints = qApp->styleHints();
+    int caps = QGuiApplicationPrivate::mouseEventCaps(event);
+    bool dragVelocityLimitAvailable = (caps & QTouchDevice::Velocity)
+        && styleHints->startDragVelocity();
+    bool overThreshold = qAbs(d) > styleHints->startDragDistance();
+    if (dragVelocityLimitAvailable) {
+        QVector2D velocityVec = QGuiApplicationPrivate::mouseEventVelocity(event);
+        qreal velocity = axis == Qt::XAxis ? velocityVec.x() : velocityVec.y();
+        overThreshold |= qAbs(velocity) > styleHints->startDragVelocity();
+    }
+    return overThreshold;
+}
+
+/*!
+    Propagates an event to a QQuickItem on the window
+*/
+bool QQuickWindow::sendEvent(QQuickItem *item, QEvent *e)
+{
+    Q_D(QQuickWindow);
+
+    if (!item) {
+        qWarning("QQuickWindow::sendEvent: Cannot send event to a null item");
+        return false;
+    }
+
+    Q_ASSERT(e);
+
+    switch (e->type()) {
+    case QEvent::KeyPress:
+    case QEvent::KeyRelease:
+        e->accept();
+        QQuickItemPrivate::get(item)->deliverKeyEvent(static_cast<QKeyEvent *>(e));
+        while (!e->isAccepted() && (item = item->parentItem())) {
+            e->accept();
+            QQuickItemPrivate::get(item)->deliverKeyEvent(static_cast<QKeyEvent *>(e));
+        }
+        break;
+    case QEvent::FocusIn:
+    case QEvent::FocusOut:
+        QQuickItemPrivate::get(item)->deliverFocusEvent(static_cast<QFocusEvent *>(e));
+        break;
+    case QEvent::MouseButtonPress:
+    case QEvent::MouseButtonRelease:
+    case QEvent::MouseButtonDblClick:
+    case QEvent::MouseMove:
+        // XXX todo - should sendEvent be doing this?  how does it relate to forwarded events?
+        if (!d->sendFilteredMouseEvent(item->parentItem(), item, e)) {
+            // accept because qml items by default accept and have to explicitly opt out of accepting
+            e->accept();
+            QQuickItemPrivate::get(item)->deliverMouseEvent(static_cast<QMouseEvent *>(e));
+        }
+        break;
+    case QEvent::UngrabMouse:
+        if (!d->sendFilteredMouseEvent(item->parentItem(), item, e)) {
+            e->accept();
+            item->mouseUngrabEvent();
+        }
+        break;
+    case QEvent::Wheel:
+        QQuickItemPrivate::get(item)->deliverWheelEvent(static_cast<QWheelEvent *>(e));
+        break;
+    case QEvent::HoverEnter:
+    case QEvent::HoverLeave:
+    case QEvent::HoverMove:
+        QQuickItemPrivate::get(item)->deliverHoverEvent(static_cast<QHoverEvent *>(e));
+        break;
+    case QEvent::TouchBegin:
+    case QEvent::TouchUpdate:
+    case QEvent::TouchEnd:
+        d->sendFilteredTouchEvent(item->parentItem(), item, static_cast<QTouchEvent *>(e));
+        break;
+    case QEvent::TouchCancel:
+        QQuickItemPrivate::get(item)->deliverTouchEvent(static_cast<QTouchEvent *>(e));
+        break;
+#ifndef QT_NO_DRAGANDDROP
+    case QEvent::DragEnter:
+    case QEvent::DragMove:
+    case QEvent::DragLeave:
+    case QEvent::Drop:
+        QQuickItemPrivate::get(item)->deliverDragEvent(e);
+        break;
+#endif
+    default:
+        break;
+    }
+
+    return false;
+}
+
+void QQuickWindowPrivate::cleanupNodes()
+{
+    for (int ii = 0; ii < cleanupNodeList.count(); ++ii)
+        delete cleanupNodeList.at(ii);
+    cleanupNodeList.clear();
+}
+
+void QQuickWindowPrivate::cleanupNodesOnShutdown(QQuickItem *item)
+{
+    QQuickItemPrivate *p = QQuickItemPrivate::get(item);
+    if (p->itemNodeInstance) {
+        delete p->itemNodeInstance;
+        p->itemNodeInstance = 0;
+
+        if (p->extra.isAllocated()) {
+            p->extra->opacityNode = 0;
+            p->extra->clipNode = 0;
+            p->extra->rootNode = 0;
+        }
+
+        p->groupNode = 0;
+        p->paintNode = 0;
+    }
+
+    for (int ii = 0; ii < p->childItems.count(); ++ii)
+        cleanupNodesOnShutdown(p->childItems.at(ii));
+}
+
+// This must be called from the render thread, with the main thread frozen
+void QQuickWindowPrivate::cleanupNodesOnShutdown()
+{
+    Q_Q(QQuickWindow);
+    cleanupNodes();
+    cleanupNodesOnShutdown(rootItem);
+    QSet<QQuickItem *>::const_iterator it = parentlessItems.begin();
+    for (; it != parentlessItems.end(); ++it)
+        cleanupNodesOnShutdown(*it);
+    q->cleanupSceneGraph();
+}
+
+void QQuickWindowPrivate::updateDirtyNodes()
+{
+#ifdef DIRTY_DEBUG
+    qWarning() << "QQuickWindowPrivate::updateDirtyNodes():";
+#endif
+
+    cleanupNodes();
+
+    QQuickItem *updateList = dirtyItemList;
+    dirtyItemList = 0;
+    if (updateList) QQuickItemPrivate::get(updateList)->prevDirtyItem = &updateList;
+
+    while (updateList) {
+        QQuickItem *item = updateList;
+        QQuickItemPrivate *itemPriv = QQuickItemPrivate::get(item);
+        itemPriv->removeFromDirtyList();
+
+#ifdef DIRTY_DEBUG
+        qWarning() << "   QSGNode:" << item << qPrintable(itemPriv->dirtyToString());
+#endif
+        updateDirtyNode(item);
+    }
+}
+
+void QQuickWindowPrivate::updateDirtyNode(QQuickItem *item)
+{
+#ifdef QML_RUNTIME_TESTING
+    bool didFlash = false;
+#endif
+
+    QQuickItemPrivate *itemPriv = QQuickItemPrivate::get(item);
+    quint32 dirty = itemPriv->dirtyAttributes;
+    itemPriv->dirtyAttributes = 0;
+
+    if ((dirty & QQuickItemPrivate::TransformUpdateMask) ||
+        (dirty & QQuickItemPrivate::Size && itemPriv->origin() != QQuickItem::TopLeft &&
+         (itemPriv->scale() != 1. || itemPriv->rotation() != 0.))) {
+
+        QMatrix4x4 matrix;
+
+        if (itemPriv->x != 0. || itemPriv->y != 0.)
+            matrix.translate(itemPriv->x, itemPriv->y);
+
+        for (int ii = itemPriv->transforms.count() - 1; ii >= 0; --ii)
+            itemPriv->transforms.at(ii)->applyTo(&matrix);
+
+        if (itemPriv->scale() != 1. || itemPriv->rotation() != 0.) {
+            QPointF origin = item->transformOriginPoint();
+            matrix.translate(origin.x(), origin.y());
+            if (itemPriv->scale() != 1.)
+                matrix.scale(itemPriv->scale(), itemPriv->scale());
+            if (itemPriv->rotation() != 0.)
+                matrix.rotate(itemPriv->rotation(), 0, 0, 1);
+            matrix.translate(-origin.x(), -origin.y());
+        }
+
+        itemPriv->itemNode()->setMatrix(matrix);
+    }
+
+    bool clipEffectivelyChanged = (dirty & (QQuickItemPrivate::Clip | QQuickItemPrivate::Window)) &&
+                                  ((item->clip() == false) != (itemPriv->clipNode() == 0));
+    int effectRefCount = itemPriv->extra.isAllocated()?itemPriv->extra->effectRefCount:0;
+    bool effectRefEffectivelyChanged = (dirty & (QQuickItemPrivate::EffectReference | QQuickItemPrivate::Window)) &&
+                                  ((effectRefCount == 0) != (itemPriv->rootNode() == 0));
+
+    if (clipEffectivelyChanged) {
+        QSGNode *parent = itemPriv->opacityNode() ? (QSGNode *) itemPriv->opacityNode() :
+                                                    (QSGNode *)itemPriv->itemNode();
+        QSGNode *child = itemPriv->rootNode() ? (QSGNode *)itemPriv->rootNode() :
+                                                (QSGNode *)itemPriv->groupNode;
+
+        if (item->clip()) {
+            Q_ASSERT(itemPriv->clipNode() == 0);
+            itemPriv->extra.value().clipNode = new QQuickDefaultClipNode(item->clipRect());
+            itemPriv->clipNode()->update();
+
+            if (child)
+                parent->removeChildNode(child);
+            parent->appendChildNode(itemPriv->clipNode());
+            if (child)
+                itemPriv->clipNode()->appendChildNode(child);
+
+        } else {
+            Q_ASSERT(itemPriv->clipNode() != 0);
+            parent->removeChildNode(itemPriv->clipNode());
+            if (child)
+                itemPriv->clipNode()->removeChildNode(child);
+            delete itemPriv->clipNode();
+            itemPriv->extra->clipNode = 0;
+            if (child)
+                parent->appendChildNode(child);
+        }
+    }
+
+    if (dirty & QQuickItemPrivate::ChildrenUpdateMask)
+        itemPriv->childContainerNode()->removeAllChildNodes();
+
+    if (effectRefEffectivelyChanged) {
+        QSGNode *parent = itemPriv->clipNode();
+        if (!parent)
+            parent = itemPriv->opacityNode();
+        if (!parent)
+            parent = itemPriv->itemNode();
+        QSGNode *child = itemPriv->groupNode;
+
+        if (itemPriv->extra.isAllocated() && itemPriv->extra->effectRefCount) {
+            Q_ASSERT(itemPriv->rootNode() == 0);
+            itemPriv->extra->rootNode = new QSGRootNode;
+
+            if (child)
+                parent->removeChildNode(child);
+            parent->appendChildNode(itemPriv->rootNode());
+            if (child)
+                itemPriv->rootNode()->appendChildNode(child);
+        } else {
+            Q_ASSERT(itemPriv->rootNode() != 0);
+            parent->removeChildNode(itemPriv->rootNode());
+            if (child)
+                itemPriv->rootNode()->removeChildNode(child);
+            delete itemPriv->rootNode();
+            itemPriv->extra->rootNode = 0;
+            if (child)
+                parent->appendChildNode(child);
+        }
+    }
+
+    if (dirty & QQuickItemPrivate::ChildrenUpdateMask) {
+        QSGNode *groupNode = itemPriv->groupNode;
+        if (groupNode)
+            groupNode->removeAllChildNodes();
+
+        QList<QQuickItem *> orderedChildren = itemPriv->paintOrderChildItems();
+        int ii = 0;
+
+        for (; ii < orderedChildren.count() && orderedChildren.at(ii)->z() < 0; ++ii) {
+            QQuickItemPrivate *childPrivate = QQuickItemPrivate::get(orderedChildren.at(ii));
+            if (!childPrivate->explicitVisible &&
+                (!childPrivate->extra.isAllocated() || !childPrivate->extra->effectRefCount))
+                continue;
+            if (childPrivate->itemNode()->parent())
+                childPrivate->itemNode()->parent()->removeChildNode(childPrivate->itemNode());
+
+            itemPriv->childContainerNode()->appendChildNode(childPrivate->itemNode());
+        }
+
+        QSGNode *beforePaintNode = itemPriv->groupNode ? itemPriv->groupNode->lastChild() : 0;
+        if (beforePaintNode || itemPriv->extra.isAllocated())
+            itemPriv->extra.value().beforePaintNode = beforePaintNode;
+
+        if (itemPriv->paintNode)
+            itemPriv->childContainerNode()->appendChildNode(itemPriv->paintNode);
+
+        for (; ii < orderedChildren.count(); ++ii) {
+            QQuickItemPrivate *childPrivate = QQuickItemPrivate::get(orderedChildren.at(ii));
+            if (!childPrivate->explicitVisible &&
+                (!childPrivate->extra.isAllocated() || !childPrivate->extra->effectRefCount))
+                continue;
+            if (childPrivate->itemNode()->parent())
+                childPrivate->itemNode()->parent()->removeChildNode(childPrivate->itemNode());
+
+            itemPriv->childContainerNode()->appendChildNode(childPrivate->itemNode());
+        }
+    }
+
+    if ((dirty & QQuickItemPrivate::Size) && itemPriv->clipNode()) {
+        itemPriv->clipNode()->setRect(item->clipRect());
+        itemPriv->clipNode()->update();
+    }
+
+    if (dirty & (QQuickItemPrivate::OpacityValue | QQuickItemPrivate::Visible
+                 | QQuickItemPrivate::HideReference | QQuickItemPrivate::Window))
+    {
+        qreal opacity = itemPriv->explicitVisible && (!itemPriv->extra.isAllocated() || itemPriv->extra->hideRefCount == 0)
+                      ? itemPriv->opacity() : qreal(0);
+
+        if (opacity != 1 && !itemPriv->opacityNode()) {
+            itemPriv->extra.value().opacityNode = new QSGOpacityNode;
+
+            QSGNode *parent = itemPriv->itemNode();
+            QSGNode *child = itemPriv->clipNode();
+            if (!child)
+                child = itemPriv->rootNode();
+            if (!child)
+                child = itemPriv->groupNode;
+
+            if (child)
+                parent->removeChildNode(child);
+            parent->appendChildNode(itemPriv->opacityNode());
+            if (child)
+                itemPriv->opacityNode()->appendChildNode(child);
+        }
+        if (itemPriv->opacityNode())
+            itemPriv->opacityNode()->setOpacity(opacity);
+    }
+
+    if (dirty & QQuickItemPrivate::ContentUpdateMask) {
+
+        if (itemPriv->flags & QQuickItem::ItemHasContents) {
+            updatePaintNodeData.transformNode = itemPriv->itemNode();
+            itemPriv->paintNode = item->updatePaintNode(itemPriv->paintNode, &updatePaintNodeData);
+
+            Q_ASSERT(itemPriv->paintNode == 0 ||
+                     itemPriv->paintNode->parent() == 0 ||
+                     itemPriv->paintNode->parent() == itemPriv->childContainerNode());
+
+            if (itemPriv->paintNode && itemPriv->paintNode->parent() == 0) {
+                if (itemPriv->extra.isAllocated() && itemPriv->extra->beforePaintNode)
+                    itemPriv->childContainerNode()->insertChildNodeAfter(itemPriv->paintNode, itemPriv->extra->beforePaintNode);
+                else
+                    itemPriv->childContainerNode()->prependChildNode(itemPriv->paintNode);
+            }
+        } else if (itemPriv->paintNode) {
+            delete itemPriv->paintNode;
+            itemPriv->paintNode = 0;
+        }
+    }
+
+#ifndef QT_NO_DEBUG
+    // Check consistency.
+    const QSGNode *nodeChain[] = {
+        itemPriv->itemNodeInstance,
+        itemPriv->opacityNode(),
+        itemPriv->clipNode(),
+        itemPriv->rootNode(),
+        itemPriv->groupNode,
+        itemPriv->paintNode,
+    };
+
+    int ip = 0;
+    for (;;) {
+        while (ip < 5 && nodeChain[ip] == 0)
+            ++ip;
+        if (ip == 5)
+            break;
+        int ic = ip + 1;
+        while (ic < 5 && nodeChain[ic] == 0)
+            ++ic;
+        const QSGNode *parent = nodeChain[ip];
+        const QSGNode *child = nodeChain[ic];
+        if (child == 0) {
+            Q_ASSERT(parent == itemPriv->groupNode || parent->childCount() == 0);
+        } else {
+            Q_ASSERT(parent == itemPriv->groupNode || parent->childCount() == 1);
+            Q_ASSERT(child->parent() == parent);
+            bool containsChild = false;
+            for (QSGNode *n = parent->firstChild(); n; n = n->nextSibling())
+                containsChild |= (n == child);
+            Q_ASSERT(containsChild);
+        }
+        ip = ic;
+    }
+#endif
+
+#ifdef QML_RUNTIME_TESTING
+    if (itemPriv->sceneGraphContext()->isFlashModeEnabled()) {
+        QSGFlashNode *flash = new QSGFlashNode();
+        flash->setRect(item->boundingRect());
+        itemPriv->childContainerNode()->appendChildNode(flash);
+        didFlash = true;
+    }
+    Q_Q(QQuickWindow);
+    if (didFlash) {
+        q->maybeUpdate();
+    }
+#endif
+
+}
+
+void QQuickWindow::maybeUpdate()
+{
+    Q_D(QQuickWindow);
+    d->windowManager->maybeUpdate(this);
+}
+
+void QQuickWindow::cleanupSceneGraph()
+{
+    Q_D(QQuickWindow);
+
+    if (!d->renderer)
+        return;
+
+    delete d->renderer->rootNode();
+    delete d->renderer;
+
+    d->renderer = 0;
+}
+
+/*!
+    Returns the opengl context used for rendering.
+
+    If the scene graph is not ready, this function will return 0.
+
+    \sa sceneGraphInitialized(), sceneGraphInvalidated()
+ */
+
+QOpenGLContext *QQuickWindow::openglContext() const
+{
+    Q_D(const QQuickWindow);
+    if (d->context->isReady())
+        return d->context->glContext();
+    return 0;
+}
+
+
+/*!
+    \fn void QSGContext::sceneGraphInitialized()
+
+    This signal is emitted when the scene graph has been initialized.
+
+    This signal will be emitted from the scene graph rendering thread.
+
+ */
+
+
+/*!
+    \fn void QSGContext::sceneGraphInvalidated()
+
+    This signal is emitted when the scene graph has been invalidated.
+
+    This signal implies that the opengl rendering context used
+    has been invalidated and all user resources tied to that context
+    should be released.
+
+    This signal will be emitted from the scene graph rendering thread.
+ */
+
+
+/*!
+    Sets the render target for this window to be \a fbo.
+
+    The specified fbo must be created in the context of the window
+    or one that shares with it.
+
+    \warning
+    This function can only be called from the thread doing
+    the rendering.
+ */
+
+void QQuickWindow::setRenderTarget(QOpenGLFramebufferObject *fbo)
+{
+    Q_D(QQuickWindow);
+    if (d->context && d->context && QThread::currentThread() != d->context->thread()) {
+        qWarning("QQuickWindow::setRenderThread: Cannot set render target from outside the rendering thread");
+        return;
+    }
+
+    d->renderTarget = fbo;
+    if (fbo) {
+        d->renderTargetId = fbo->handle();
+        d->renderTargetSize = fbo->size();
+    } else {
+        d->renderTargetId = 0;
+        d->renderTargetSize = QSize();
+    }
+}
+
+/*!
+    \overload
+ */
+void QQuickWindow::setRenderTarget(uint fboId, const QSize &size)
+{
+    Q_D(QQuickWindow);
+    if (d->context && d->context && QThread::currentThread() != d->context->thread()) {
+        qWarning("QQuickWindow::setRenderThread: Cannot set render target from outside the rendering thread");
+        return;
+    }
+
+    d->renderTargetId = fboId;
+    d->renderTargetSize = size;
+
+    // Unset any previously set instance...
+    d->renderTarget = 0;
+}
+
+
+/*!
+    Returns the FBO id of the render target when set; otherwise returns 0.
+ */
+uint QQuickWindow::renderTargetId() const
+{
+    Q_D(const QQuickWindow);
+    return d->renderTargetId;
+}
+
+/*!
+    Returns the size of the currently set render target; otherwise returns an enpty size.
+ */
+QSize QQuickWindow::renderTargetSize() const
+{
+    Q_D(const QQuickWindow);
+    return d->renderTargetSize;
+}
+
+
+
+
+/*!
+    Returns the render target for this window.
+
+    The default is to render to the surface of the window, in which
+    case the render target is 0.
+ */
+QOpenGLFramebufferObject *QQuickWindow::renderTarget() const
+{
+    Q_D(const QQuickWindow);
+    return d->renderTarget;
+}
+
+
+/*!
+    Grabs the contents of the window and returns it as an image.
+
+    This function might not work if the window is not visible.
+
+    \warning Calling this function will cause performance problems.
+
+    \warning This function can only be called from the GUI thread.
+ */
+QImage QQuickWindow::grabWindow()
+{
+    Q_D(QQuickWindow);
+    return d->windowManager->grab(this);
+}
+
+/*!
+    Returns an incubation controller that splices incubation between frames
+    for this window. QQuickView automatically installs this controller for you,
+    otherwise you will need to install it yourself using \l{QQmlEngine::setIncubationController}
+
+    The controller is owned by the window and will be destroyed when the window
+    is deleted.
+*/
+QQmlIncubationController *QQuickWindow::incubationController() const
+{
+    Q_D(const QQuickWindow);
+
+    if (!d->incubationController)
+        d->incubationController = new QQuickWindowIncubationController(const_cast<QQuickWindowPrivate *>(d));
+    return d->incubationController;
+}
+
+
+
+/*!
+    \enum QQuickWindow::CreateTextureOption
+
+    The CreateTextureOption enums are used to customize a texture is wrapped.
+
+    \value TextureHasAlphaChannel The texture has an alpha channel and should
+    be drawn using blending.
+
+    \value TextureHasMipmaps The texture has mipmaps and can be drawn with
+    mipmapping enabled.
+
+    \value TextureOwnsGLTexture The texture object owns the texture id and
+    will delete the GL texture when the texture object is deleted.
+ */
+
+/*!
+    \fn void QQuickWindow::beforeRendering()
+
+    This signal is emitted before the scene starts rendering.
+
+    Combined with the modes for clearing the background, this option
+    can be used to paint using raw GL under QML content.
+
+    The GL context used for rendering the scene graph will be bound
+    at this point.
+
+    \warning Since this signal is emitted from the scene graph rendering thread, the
+    receiver should be on the scene graph thread or the connection should be Qt::DirectConnection.
+
+    \warning Make very sure that a signal handler for beforeRendering leaves the GL
+    context in the same state as it was when the signal handler was entered. Failing to
+    do so can result in the scene not rendering properly.
+*/
+
+/*!
+    \fn void QQuickWindow::afterRendering()
+
+    This signal is emitted after the scene has completed rendering, before swapbuffers is called.
+
+    This signal can be used to paint using raw GL on top of QML content,
+    or to do screen scraping of the current frame buffer.
+
+    The GL context used for rendering the scene graph will be bound at this point.
+
+    \warning Since this signal is emitted from the scene graph rendering thread, the
+    receiver should be on the scene graph thread or the connection should be Qt::DirectConnection.
+
+    \warning Make very sure that a signal handler for afterRendering() leaves the GL
+    context in the same state as it was when the signal handler was entered. Failing to
+    do so can result in the scene not rendering properly.
+ */
+
+
+
+/*!
+    Sets weither the scene graph rendering of QML should clear the color buffer
+    before it starts rendering to \a enbled.
+
+    By disabling clearing of the color buffer, it is possible to do GL painting
+    under the scene graph.
+
+    The color buffer is cleared by default.
+
+    \sa beforeRendering()
+ */
+
+void QQuickWindow::setClearBeforeRendering(bool enabled)
+{
+    Q_D(QQuickWindow);
+    d->clearBeforeRendering = enabled;
+}
+
+
+
+/*!
+    Returns weither clearing of the color buffer is done before rendering or not.
+ */
+
+bool QQuickWindow::clearBeforeRendering() const
+{
+    Q_D(const QQuickWindow);
+    return d->clearBeforeRendering;
+}
+
+
+
+/*!
+    Creates a new QSGTexture from the supplied \a image. If the image has an
+    alpha channel, the corresponding texture will have an alpha channel.
+
+    The caller of the function is responsible for deleting the returned texture.
+    The actual GL texture will be deleted when the texture object is deleted.
+
+    Depending on the underlying implementation of the scene graph, the returned
+    texture may be part of an atlas. For code to be portable across implementations
+    one should always use the texture coordinates returned from
+    QSGTexture::normalizedTextureSubRect() when building geometry.
+
+    \warning This function will return 0 if the scene graph has not yet been
+    initialized.
+
+    \warning The returned texture is not memory managed by the scene graph and
+    must be explicitely deleted by the caller on the rendering thread.
+    This is acheived by deleting the texture from a QSGNode destructor
+    or by using deleteLater() in the case where the texture already has affinity
+    to the rendering thread.
+
+    This function can be called from any thread.
+
+    \sa sceneGraphInitialized()
+ */
+
+QSGTexture *QQuickWindow::createTextureFromImage(const QImage &image) const
+{
+    Q_D(const QQuickWindow);
+    if (d->context && d->context->isReady())
+        return d->context->createTexture(image);
+    else
+        return 0;
+}
+
+
+
+/*!
+    Creates a new QSGTexture object from an existing GL texture \a id.
+
+    The caller of the function is responsible for deleting the returned texture.
+
+    Use \a options to customize the texture attributes.
+
+    \warning This function will return 0 if the scenegraph has not yet been
+    initialized.
+
+    \sa sceneGraphInitialized()
+ */
+QSGTexture *QQuickWindow::createTextureFromId(uint id, const QSize &size, CreateTextureOptions options) const
+{
+    Q_D(const QQuickWindow);
+    if (d->context && d->context->isReady()) {
+        QSGPlainTexture *texture = new QSGPlainTexture();
+        texture->setTextureId(id);
+        texture->setHasAlphaChannel(options & TextureHasAlphaChannel);
+        texture->setHasMipmaps(options & TextureHasMipmaps);
+        texture->setOwnsTexture(options & TextureOwnsGLTexture);
+        texture->setTextureSize(size);
+        return texture;
+    }
+    return 0;
+}
+
+
+/*!
+    Sets the color used to clear the opengl context to \a color.
+
+    Setting the clear color has no effect when clearing is disabled.
+
+    \sa setClearBeforeRendering()
+ */
+
+void QQuickWindow::setColor(const QColor &color)
+{
+    Q_D(QQuickWindow);
+    if (color == d->clearColor)
+        return;
+
+    d->clearColor = color;
+    emit colorChanged(color);
+}
+
+
+
+/*!
+    Returns the color used to clear the opengl context.
+ */
+
+QColor QQuickWindow::color() const
+{
+    return d_func()->clearColor;
+}
+
+
+
+#include "moc_qquickwindow.cpp"
+
+QT_END_NAMESPACE
diff --git a/src/quick/items/qquickwindow.h b/src/quick/items/qquickwindow.h
new file mode 100644
index 0000000..9e351ed
--- /dev/null
+++ b/src/quick/items/qquickwindow.h
@@ -0,0 +1,181 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQUICKWINDOW_H
+#define QQUICKWINDOW_H
+
+#include <QtQuick/qtquickglobal.h>
+#include <QtCore/qmetatype.h>
+#include <QtGui/qopengl.h>
+#include <QtGui/qwindow.h>
+#include <QtGui/qevent.h>
+
+QT_BEGIN_HEADER
+
+QT_BEGIN_NAMESPACE
+
+class QQuickItem;
+class QSGTexture;
+class QInputMethodEvent;
+class QQuickWindowPrivate;
+class QOpenGLFramebufferObject;
+class QQmlIncubationController;
+class QInputMethodEvent;
+
+class Q_QUICK_EXPORT QQuickWindow : public QWindow
+{
+    Q_OBJECT
+    Q_PRIVATE_PROPERTY(QQuickWindow::d_func(), QQmlListProperty<QObject> data READ data DESIGNABLE false)
+    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
+    Q_PROPERTY(QQuickItem* contentItem READ contentItem CONSTANT FINAL)
+    Q_CLASSINFO("DefaultProperty", "data")
+    Q_DECLARE_PRIVATE(QQuickWindow)
+public:
+    enum CreateTextureOption {
+        TextureHasAlphaChannel  = 0x0001,
+        TextureHasMipmaps       = 0x0002,
+        TextureOwnsGLTexture    = 0x0004
+    };
+
+    Q_DECLARE_FLAGS(CreateTextureOptions, CreateTextureOption)
+
+    QQuickWindow(QWindow *parent = 0);
+
+    virtual ~QQuickWindow();
+
+    QQuickItem *contentItem() const;
+    //XXX rootItem renamed contentItem - this function must be removed before 5.0
+    QQuickItem *rootItem() const { return contentItem(); }
+
+    QQuickItem *activeFocusItem() const;
+    QObject *focusObject() const;
+
+    QQuickItem *mouseGrabberItem() const;
+
+    bool sendEvent(QQuickItem *, QEvent *);
+
+    QImage grabWindow();
+
+    void setRenderTarget(QOpenGLFramebufferObject *fbo);
+    QOpenGLFramebufferObject *renderTarget() const;
+
+    void setRenderTarget(uint fboId, const QSize &size);
+    uint renderTargetId() const;
+    QSize renderTargetSize() const;
+
+    QQmlIncubationController *incubationController() const;
+
+#ifndef QT_NO_ACCESSIBILITY
+    virtual QAccessibleInterface *accessibleRoot() const;
+#endif
+
+    // Scene graph specific functions
+    QSGTexture *createTextureFromImage(const QImage &image) const;
+    QSGTexture *createTextureFromId(uint id, const QSize &size, CreateTextureOptions options = CreateTextureOption(0)) const;
+
+    void setClearBeforeRendering(bool enabled);
+    bool clearBeforeRendering() const;
+
+    void setColor(const QColor &color);
+    QColor color() const;
+
+    void setPersistentOpenGLContext(bool persistent);
+    bool isPersistentOpenGLContext() const;
+
+    void setPersistentSceneGraph(bool persistent);
+    bool isPersistentSceneGraph() const;
+
+    QOpenGLContext *openglContext() const;
+
+Q_SIGNALS:
+    void frameSwapped();
+    void sceneGraphInitialized();
+    void sceneGraphInvalidated();
+    void beforeSynchronizing();
+    void beforeRendering();
+    void afterRendering();
+    void colorChanged(const QColor &);
+
+public Q_SLOTS:
+    void update();
+    void releaseResources();
+
+protected:
+    QQuickWindow(QQuickWindowPrivate &dd, QWindow *parent = 0);
+
+    virtual void exposeEvent(QExposeEvent *);
+    virtual void resizeEvent(QResizeEvent *);
+
+    virtual void showEvent(QShowEvent *);
+    virtual void hideEvent(QHideEvent *);
+
+    virtual void focusInEvent(QFocusEvent *);
+    virtual void focusOutEvent(QFocusEvent *);
+
+    virtual bool event(QEvent *);
+    virtual void keyPressEvent(QKeyEvent *);
+    virtual void keyReleaseEvent(QKeyEvent *);
+    virtual void mousePressEvent(QMouseEvent *);
+    virtual void mouseReleaseEvent(QMouseEvent *);
+    virtual void mouseDoubleClickEvent(QMouseEvent *);
+    virtual void mouseMoveEvent(QMouseEvent *);
+#ifndef QT_NO_WHEELEVENT
+    virtual void wheelEvent(QWheelEvent *);
+#endif
+
+private Q_SLOTS:
+    void maybeUpdate();
+    void cleanupSceneGraph();
+
+private:
+    friend class QQuickItem;
+    friend class QQuickWindowRenderLoop;
+    Q_DISABLE_COPY(QQuickWindow)
+};
+
+QT_END_NAMESPACE
+
+Q_DECLARE_METATYPE(QQuickWindow *)
+
+QT_END_HEADER
+
+#endif // QQUICKWINDOW_H
+
diff --git a/src/quick/items/qquickwindow_p.h b/src/quick/items/qquickwindow_p.h
new file mode 100644
index 0000000..52e46ca
--- /dev/null
+++ b/src/quick/items/qquickwindow_p.h
@@ -0,0 +1,224 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the QtQml module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef QQUICKWINDOW_P_H
+#define QQUICKWINDOW_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "qquickitem.h"
+#include "qquickwindow.h"
+#include <private/qqmlguard_p.h>
+
+#include <QtQuick/private/qsgcontext_p.h>
+#include <private/qquickdrag_p.h>
+
+#include <QtCore/qthread.h>
+#include <QtCore/qmutex.h>
+#include <QtCore/qwaitcondition.h>
+#include <private/qwindow_p.h>
+#include <private/qopengl_p.h>
+#include <qopenglcontext.h>
+#include <QtGui/qopenglframebufferobject.h>
+#include <QtGui/qevent.h>
+
+QT_BEGIN_NAMESPACE
+
+//Make it easy to identify and customize the root item if needed
+
+class QQuickWindowManager;
+
+class QQuickRootItem : public QQuickItem
+{
+    Q_OBJECT
+public:
+    QQuickRootItem();
+public Q_SLOTS:
+    void setWidth(int w) {QQuickItem::setWidth(qreal(w));}
+    void setHeight(int h) {QQuickItem::setHeight(qreal(h));}
+};
+
+class QQuickItemPrivate;
+class QQuickWindowPrivate;
+
+class QTouchEvent;
+class QQuickWindowRenderLoop;
+class QQuickWindowIncubationController;
+
+class Q_QUICK_PRIVATE_EXPORT QQuickWindowPrivate : public QWindowPrivate
+{
+public:
+    Q_DECLARE_PUBLIC(QQuickWindow)
+
+    static inline QQuickWindowPrivate *get(QQuickWindow *c) { return c->d_func(); }
+
+    QQuickWindowPrivate();
+    virtual ~QQuickWindowPrivate();
+
+    void init(QQuickWindow *);
+    void initRootItem();//Currently only used if items added in QML
+
+    QQuickRootItem *rootItem;
+    QSet<QQuickItem *> parentlessItems;
+    QQmlListProperty<QObject> data();
+
+    QQuickItem *activeFocusItem;
+
+    // Keeps track of the item currently receiving mouse events
+    QQuickItem *mouseGrabberItem;
+#ifndef QT_NO_DRAGANDDROP
+    QQuickDragGrabber dragGrabber;
+#endif
+    int touchMouseId;
+    ulong touchMousePressTimestamp;
+
+    // Mouse positions are saved in widget coordinates
+    QPointF lastMousePosition;
+    bool translateTouchToMouse(QQuickItem *item, QTouchEvent *event);
+    void translateTouchEvent(QTouchEvent *touchEvent);
+    static void transformTouchPoints(QList<QTouchEvent::TouchPoint> &touchPoints, const QTransform &transform);
+    static QMouseEvent *cloneMouseEvent(QMouseEvent *event, QPointF *transformedLocalPos = 0);
+    bool deliverInitialMousePressEvent(QQuickItem *, QMouseEvent *);
+    bool deliverMouseEvent(QMouseEvent *);
+    bool sendFilteredMouseEvent(QQuickItem *, QQuickItem *, QEvent *);
+    bool deliverWheelEvent(QQuickItem *, QWheelEvent *);
+    bool deliverTouchPoints(QQuickItem *, QTouchEvent *, const QList<QTouchEvent::TouchPoint> &, QSet<int> *,
+            QHash<QQuickItem *, QList<QTouchEvent::TouchPoint> > *);
+    bool deliverTouchEvent(QTouchEvent *);
+    bool deliverTouchCancelEvent(QTouchEvent *);
+    bool deliverHoverEvent(QQuickItem *, const QPointF &scenePos, const QPointF &lastScenePos, Qt::KeyboardModifiers modifiers, bool &accepted);
+    bool deliverMatchingPointsToItem(QQuickItem *item, QTouchEvent *event, QSet<int> *acceptedNewPoints, const QSet<int> &matchingNewPoints, const QList<QTouchEvent::TouchPoint> &matchingPoints);
+    QTouchEvent *touchEventForItemBounds(QQuickItem *target, const QTouchEvent &originalEvent);
+    QTouchEvent *touchEventWithPoints(const QTouchEvent &event, const QList<QTouchEvent::TouchPoint> &newPoints);
+    bool sendFilteredTouchEvent(QQuickItem *target, QQuickItem *item, QTouchEvent *event);
+    bool sendHoverEvent(QEvent::Type, QQuickItem *, const QPointF &scenePos, const QPointF &lastScenePos,
+                        Qt::KeyboardModifiers modifiers, bool accepted);
+    bool clearHover();
+#ifndef QT_NO_DRAGANDDROP
+    void deliverDragEvent(QQuickDragGrabber *, QEvent *);
+    bool deliverDragEvent(QQuickDragGrabber *, QQuickItem *, QDragMoveEvent *);
+#endif
+
+    QList<QQuickItem*> hoverItems;
+    enum FocusOption {
+        DontChangeFocusProperty = 0x01,
+        DontChangeSubFocusItem  = 0x02
+    };
+    Q_DECLARE_FLAGS(FocusOptions, FocusOption)
+
+    void setFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions = 0);
+    void clearFocusInScope(QQuickItem *scope, QQuickItem *item, FocusOptions = 0);
+    static void notifyFocusChangesRecur(QQuickItem **item, int remaining);
+
+    void updateFocusItemTransform();
+
+    void dirtyItem(QQuickItem *);
+    void cleanup(QSGNode *);
+
+    void polishItems();
+    void syncSceneGraph();
+    void renderSceneGraph(const QSize &size);
+
+    bool renderWithoutShowing;
+    void setRenderWithoutShowing(bool enabled);
+
+    QQuickItem::UpdatePaintNodeData updatePaintNodeData;
+
+    QQuickItem *dirtyItemList;
+    QList<QSGNode *> cleanupNodeList;
+
+    QSet<QQuickItem *> itemsToPolish;
+
+    void updateDirtyNodes();
+    void cleanupNodes();
+    void cleanupNodesOnShutdown();
+    bool updateEffectiveOpacity(QQuickItem *);
+    void updateEffectiveOpacityRoot(QQuickItem *, qreal);
+    void updateDirtyNode(QQuickItem *);
+
+    void fireFrameSwapped() { emit q_func()->frameSwapped(); }
+
+    QSGContext *context;
+    QSGRenderer *renderer;
+
+    QQuickWindowManager *windowManager;
+
+    QColor clearColor;
+
+    uint clearBeforeRendering : 1;
+
+    // Currently unused in the default implementation, as we're not stopping
+    // rendering when obscured as we should...
+    uint persistentGLContext : 1;
+    uint persistentSceneGraph : 1;
+
+    uint lastWheelEventAccepted : 1;
+
+    QOpenGLFramebufferObject *renderTarget;
+    uint renderTargetId;
+    QSize renderTargetSize;
+
+    // Keeps track of which touch point (int) was last accepted by which item
+    QHash<int, QQuickItem *> itemForTouchPointId;
+
+    mutable QQuickWindowIncubationController *incubationController;
+
+    static bool dragOverThreshold(qreal d, Qt::Axis axis, QMouseEvent *event);
+
+private:
+    static void cleanupNodesOnShutdown(QQuickItem *);
+};
+
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(QQuickWindowPrivate::FocusOptions)
+
+QT_END_NAMESPACE
+
+#endif // QQUICKWINDOW_P_H
diff --git a/src/quick/items/qquickwindowmanager.cpp b/src/quick/items/qquickwindowmanager.cpp
index 3cfa871..28a1e66 100644
--- a/src/quick/items/qquickwindowmanager.cpp
+++ b/src/quick/items/qquickwindowmanager.cpp
@@ -53,8 +53,8 @@
 
 #include <QtQml/private/qqmlglobal_p.h>
 
-#include <QtQuick/QQuickCanvas>
-#include <QtQuick/private/qquickcanvas_p.h>
+#include <QtQuick/QQuickWindow>
+#include <QtQuick/private/qquickwindow_p.h>
 #include <QtQuick/private/qsgcontext_p.h>
 
 QT_BEGIN_NAMESPACE
@@ -63,9 +63,9 @@ const QEvent::Type QEvent_Sync = QEvent::Type(QEvent::User);
 const QEvent::Type QEvent_DeferredUpdate = QEvent::Type(QEvent::User + 1);
 
 
-#define QQUICK_CANVAS_TIMING
-#ifdef QQUICK_CANVAS_TIMING
-static bool qquick_canvas_timing = !qgetenv("QML_CANVAS_TIMING").isEmpty();
+#define QQUICK_RENDER_TIMING
+#ifdef QQUICK_RENDER_TIMING
+static bool qquick_render_timing = !qgetenv("QML_RENDER_TIMING").isEmpty();
 static QTime threadTimer;
 static int syncTime;
 static int renderTime;
@@ -163,7 +163,7 @@ public:
         , shouldExit(false)
         , hasExited(false)
         , isDeferredUpdatePosted(false)
-        , canvasToGrab(0)
+        , windowToGrab(0)
     {
         sg->moveToThread(this);
 
@@ -177,17 +177,17 @@ public:
 
     void releaseResources() { }
 
-    void show(QQuickCanvas *canvas);
-    void hide(QQuickCanvas *canvas);
+    void show(QQuickWindow *window);
+    void hide(QQuickWindow *window);
 
-    void canvasDestroyed(QQuickCanvas *canvas);
+    void windowDestroyed(QQuickWindow *window);
 
-    void exposureChanged(QQuickCanvas *canvas);
-    QImage grab(QQuickCanvas *canvas);
-    void resize(QQuickCanvas *canvas, const QSize &size);
+    void exposureChanged(QQuickWindow *window);
+    QImage grab(QQuickWindow *window);
+    void resize(QQuickWindow *window, const QSize &size);
     void handleDeferredUpdate();
-    void maybeUpdate(QQuickCanvas *canvas);
-    void update(QQuickCanvas *canvas) { maybeUpdate(canvas); } // identical for this implementation
+    void maybeUpdate(QQuickWindow *window);
+    void update(QQuickWindow *window) { maybeUpdate(window); } // identical for this implementation
     void wakeup();
 
     void startRendering();
@@ -211,9 +211,9 @@ public:
 
     void run();
 
-    QQuickCanvas *masterCanvas() {
-        QQuickCanvas *win = 0;
-        for (QHash<QQuickCanvas *, CanvasData *>::const_iterator it = m_rendered_windows.constBegin();
+    QQuickWindow *masterWindow() {
+        QQuickWindow *win = 0;
+        for (QHash<QQuickWindow *, WindowData *>::const_iterator it = m_rendered_windows.constBegin();
             it != m_rendered_windows.constEnd() && !win; ++it) {
             if (it.value()->isVisible)
                 win = it.key();
@@ -224,11 +224,11 @@ public:
 public slots:
     void animationStarted();
     void animationStopped();
-    void canvasVisibilityChanged();
+    void windowVisibilityChanged();
 
 private:
     void handleAddedWindows();
-    void handleAddedWindow(QQuickCanvas *canvas);
+    void handleAddedWindow(QQuickWindow *window);
     void handleRemovedWindows(bool clearGLContext = true);
 
     QSGContext *sg;
@@ -252,10 +252,10 @@ private:
     uint hasExited : 1;
     uint isDeferredUpdatePosted : 1;
 
-    QQuickCanvas *canvasToGrab;
+    QQuickWindow *windowToGrab;
     QImage grabContent;
 
-    struct CanvasData {
+    struct WindowData {
         QSize renderedSize;
         QSize windowSize;
         QSize viewportSize;
@@ -264,18 +264,18 @@ private:
         uint isVisible : 1;
     };
 
-    QHash<QQuickCanvas *, CanvasData *> m_rendered_windows;
+    QHash<QQuickWindow *, WindowData *> m_rendered_windows;
 
-    struct CanvasTracker {
-        QQuickCanvas *canvas;
+    struct WindowTracker {
+        QQuickWindow *window;
         uint isVisible : 1;
         uint toBeRemoved : 1;
     };
 
-    QList<CanvasTracker> m_tracked_windows;
+    QList<WindowTracker> m_tracked_windows;
 
-    QList<QQuickCanvas *> m_removed_windows;
-    QList<QQuickCanvas *> m_added_windows;
+    QList<QQuickWindow *> m_removed_windows;
+    QList<QQuickWindow *> m_added_windows;
 };
 
 
@@ -284,20 +284,20 @@ class QQuickTrivialWindowManager : public QObject, public QQuickWindowManager
 public:
     QQuickTrivialWindowManager();
 
-    void show(QQuickCanvas *canvas);
-    void hide(QQuickCanvas *canvas);
+    void show(QQuickWindow *window);
+    void hide(QQuickWindow *window);
 
-    void canvasDestroyed(QQuickCanvas *canvas);
+    void windowDestroyed(QQuickWindow *window);
 
     void initializeGL();
-    void renderCanvas(QQuickCanvas *canvas);
-    void exposureChanged(QQuickCanvas *canvas);
-    QImage grab(QQuickCanvas *canvas);
-    void resize(QQuickCanvas *canvas, const QSize &size);
+    void renderWindow(QQuickWindow *window);
+    void exposureChanged(QQuickWindow *window);
+    QImage grab(QQuickWindow *window);
+    void resize(QQuickWindow *window, const QSize &size);
     void wakeup();
 
-    void maybeUpdate(QQuickCanvas *canvas);
-    void update(QQuickCanvas *canvas) { maybeUpdate(canvas); } // identical for this implementation.
+    void maybeUpdate(QQuickWindow *window);
+    void update(QQuickWindow *window) { maybeUpdate(window); } // identical for this implementation.
 
     void releaseResources() { }
 
@@ -307,12 +307,12 @@ public:
 
     bool event(QEvent *);
 
-    struct CanvasData {
+    struct WindowData {
         bool updatePending : 1;
         bool grabOnly : 1;
     };
 
-    QHash<QQuickCanvas *, CanvasData> m_windows;
+    QHash<QQuickWindow *, WindowData> m_windows;
 
     QOpenGLContext *gl;
     QSGContext *sg;
@@ -366,7 +366,7 @@ void QQuickRenderThreadSingleContextWindowManager::initialize()
 {
     Q_ASSERT(m_rendered_windows.size());
 
-    QQuickCanvas *win = masterCanvas();
+    QQuickWindow *win = masterWindow();
     if (!win)
         return;
 
@@ -375,7 +375,7 @@ void QQuickRenderThreadSingleContextWindowManager::initialize()
     gl->setFormat(win->requestedFormat());
     gl->create();
     if (!gl->makeCurrent(win))
-        qWarning("QQuickCanvas: makeCurrent() failed...");
+        qWarning("QQuickWindow: makeCurrent() failed...");
 
     Q_ASSERT(!sg->isReady());
     sg->initialize(gl);
@@ -383,42 +383,42 @@ void QQuickRenderThreadSingleContextWindowManager::initialize()
 
 
 /*!
-    This function is called when the canvas is created to register the canvas with
+    This function is called when the window is created to register the window with
     the window manager.
 
     Called on GUI Thread.
  */
 
-void QQuickRenderThreadSingleContextWindowManager::show(QQuickCanvas *canvas)
+void QQuickRenderThreadSingleContextWindowManager::show(QQuickWindow *window)
 {
 #ifdef THREAD_DEBUG
-    printf("GUI: Canvas added to windowing system, %p, %dx%d\n", canvas, canvas->width(), canvas->height());
+    printf("GUI: Window added to windowing system, %p, %dx%d\n", window, window->width(), window->height());
 #endif
 
-    CanvasTracker tracker;
-    tracker.canvas = canvas;
+    WindowTracker tracker;
+    tracker.window = window;
     tracker.isVisible = false;
     tracker.toBeRemoved = false;
     m_tracked_windows << tracker;
 
-    connect(canvas, SIGNAL(widthChanged(int)), this, SLOT(canvasVisibilityChanged()), Qt::DirectConnection);
-    connect(canvas, SIGNAL(heightChanged(int)), this, SLOT(canvasVisibilityChanged()), Qt::DirectConnection);
+    connect(window, SIGNAL(widthChanged(int)), this, SLOT(windowVisibilityChanged()), Qt::DirectConnection);
+    connect(window, SIGNAL(heightChanged(int)), this, SLOT(windowVisibilityChanged()), Qt::DirectConnection);
 
-    canvasVisibilityChanged();
+    windowVisibilityChanged();
 }
 
 
-void QQuickRenderThreadSingleContextWindowManager::handleAddedWindow(QQuickCanvas *canvas)
+void QQuickRenderThreadSingleContextWindowManager::handleAddedWindow(QQuickWindow *window)
 {
 #ifdef THREAD_DEBUG
-    printf("                RenderThread: adding canvas: %p\n", canvas);
+    printf("                RenderThread: adding window: %p\n", window);
 #endif
 
-    CanvasData *data = new CanvasData;
+    WindowData *data = new WindowData;
     data->sizeWasChanged = false;
-    data->windowSize = canvas->size();
-    data->isVisible = canvas->isVisible();
-    m_rendered_windows[canvas] = data;
+    data->windowSize = window->size();
+    data->isVisible = window->isVisible();
+    m_rendered_windows[window] = data;
 
     isExternalUpdatePending = true;
 }
@@ -434,23 +434,23 @@ void QQuickRenderThreadSingleContextWindowManager::handleAddedWindows()
 #endif
 
     while (m_added_windows.size()) {
-        QQuickCanvas *canvas = m_added_windows.takeLast();
-        handleAddedWindow(canvas);
+        QQuickWindow *window = m_added_windows.takeLast();
+        handleAddedWindow(window);
     }
 }
 
 
 /*!
-    Called on the GUI Thread, from the canvas' destructor
+    Called on the GUI Thread, from the window' destructor
  */
 
-void QQuickRenderThreadSingleContextWindowManager::canvasDestroyed(QQuickCanvas *canvas)
+void QQuickRenderThreadSingleContextWindowManager::windowDestroyed(QQuickWindow *window)
 {
 #ifdef THREAD_DEBUG
-    printf("GUI: Canvas destroyed: %p\n", canvas);
+    printf("GUI: Window destroyed: %p\n", window);
 #endif
 
-    hide(canvas);
+    hide(window);
 }
 
 
@@ -458,15 +458,15 @@ void QQuickRenderThreadSingleContextWindowManager::canvasDestroyed(QQuickCanvas
     Called on GUI Thread
  */
 
-void QQuickRenderThreadSingleContextWindowManager::hide(QQuickCanvas *canvas)
+void QQuickRenderThreadSingleContextWindowManager::hide(QQuickWindow *window)
 {
 #ifdef THREAD_DEBUG
-    printf("GUI: Canvas hidden: %p\n", canvas);
+    printf("GUI: Window hidden: %p\n", window);
 #endif
 
     int position = -1;
     for (int i=0; i<m_tracked_windows.size(); ++i) {
-        if (m_tracked_windows.at(i).canvas == canvas) {
+        if (m_tracked_windows.at(i).window == window) {
             m_tracked_windows[i].toBeRemoved = true;
             position = i;
             break;
@@ -474,14 +474,14 @@ void QQuickRenderThreadSingleContextWindowManager::hide(QQuickCanvas *canvas)
     }
 
     if (position >= 0) {
-        disconnect(canvas, SIGNAL(widthChanged(int)), this, SLOT(canvasVisibilityChanged()));
-        disconnect(canvas, SIGNAL(heightChanged(int)), this, SLOT(canvasVisibilityChanged()));
-        canvasVisibilityChanged();
+        disconnect(window, SIGNAL(widthChanged(int)), this, SLOT(windowVisibilityChanged()));
+        disconnect(window, SIGNAL(heightChanged(int)), this, SLOT(windowVisibilityChanged()));
+        windowVisibilityChanged();
         m_tracked_windows.removeAt(position);
     }
 
 #ifdef THREAD_DEBUG
-    printf("GUI: Canvas removal completed... %p\n", canvas);
+    printf("GUI: Window removal completed... %p\n", window);
 #endif
 }
 
@@ -496,13 +496,13 @@ void QQuickRenderThreadSingleContextWindowManager::handleRemovedWindows(bool cle
 
     bool removedAnything = false;
     while (m_removed_windows.size()) {
-        QQuickCanvas *canvas = m_removed_windows.takeLast();
+        QQuickWindow *window = m_removed_windows.takeLast();
 #ifdef THREAD_DEBUG
-    printf("                RenderThread: removing %p\n", canvas);
+    printf("                RenderThread: removing %p\n", window);
 #endif
 
-        QQuickCanvasPrivate::get(canvas)->cleanupNodesOnShutdown();
-        delete m_rendered_windows.take(canvas);
+        QQuickWindowPrivate::get(window)->cleanupNodesOnShutdown();
+        delete m_rendered_windows.take(window);
         removedAnything = true;
     }
 
@@ -519,26 +519,26 @@ void QQuickRenderThreadSingleContextWindowManager::handleRemovedWindows(bool cle
     Called on GUI Thread
  */
 
-void QQuickRenderThreadSingleContextWindowManager::canvasVisibilityChanged()
+void QQuickRenderThreadSingleContextWindowManager::windowVisibilityChanged()
 {
     bool anyoneShowing = false;
-    QList<QQuickCanvas *> toAdd, toRemove;
+    QList<QQuickWindow *> toAdd, toRemove;
 
     // Not optimal, but also not frequently used...
     for (int i=0; i<m_tracked_windows.size(); ++i) {
-        CanvasTracker &t = const_cast<CanvasTracker &>(m_tracked_windows.at(i));
-        QQuickCanvas *win = t.canvas;
+        WindowTracker &t = const_cast<WindowTracker &>(m_tracked_windows.at(i));
+        QQuickWindow *win = t.window;
 
-        Q_ASSERT(win->isVisible() || QQuickCanvasPrivate::get(win)->renderWithoutShowing || t.toBeRemoved);
-        bool canvasVisible = win->width() > 0 && win->height() > 0;
-        anyoneShowing |= (canvasVisible && !t.toBeRemoved);
+        Q_ASSERT(win->isVisible() || QQuickWindowPrivate::get(win)->renderWithoutShowing || t.toBeRemoved);
+        bool windowVisible = win->width() > 0 && win->height() > 0;
+        anyoneShowing |= (windowVisible && !t.toBeRemoved);
 
-        if ((!canvasVisible && t.isVisible) || t.toBeRemoved) {
+        if ((!windowVisible && t.isVisible) || t.toBeRemoved) {
             toRemove << win;
-        } else if (canvasVisible && !t.isVisible) {
+        } else if (windowVisible && !t.isVisible) {
             toAdd << win;
         }
-        t.isVisible = canvasVisible;
+        t.isVisible = windowVisible;
     }
 
     if (isRunning()) {
@@ -616,39 +616,39 @@ void QQuickRenderThreadSingleContextWindowManager::run()
 #ifdef THREAD_DEBUG
         printf("                RenderThread: Doing locked sync\n");
 #endif
-#ifdef QQUICK_CANVAS_TIMING
-        if (qquick_canvas_timing)
+#ifdef QQUICK_RENDER_TIMING
+        if (qquick_render_timing)
             threadTimer.start();
 #endif
         inSync = true;
-        for (QHash<QQuickCanvas *, CanvasData *>::const_iterator it = m_rendered_windows.constBegin();
+        for (QHash<QQuickWindow *, WindowData *>::const_iterator it = m_rendered_windows.constBegin();
              it != m_rendered_windows.constEnd(); ++it) {
-            QQuickCanvas *canvas = it.key();
+            QQuickWindow *window = it.key();
 
 #ifdef THREAD_DEBUG
-            printf("                RenderThread: Syncing canvas: %p\n", canvas);
+            printf("                RenderThread: Syncing window: %p\n", window);
 #endif
 
-            CanvasData *canvasData = it.value();
-            QQuickCanvasPrivate *canvasPrivate = QQuickCanvasPrivate::get(canvas);
+            WindowData *windowData = it.value();
+            QQuickWindowPrivate *windowPrivate = QQuickWindowPrivate::get(window);
 
-            Q_ASSERT(canvasData->windowSize.width() > 0 && canvasData->windowSize.height() > 0);
+            Q_ASSERT(windowData->windowSize.width() > 0 && windowData->windowSize.height() > 0);
 
-            if (!canvasData->isVisible)
-                gl->makeCurrent(masterCanvas());
+            if (!windowData->isVisible)
+                gl->makeCurrent(masterWindow());
             else
-                gl->makeCurrent(canvas);
+                gl->makeCurrent(window);
 
-            if (canvasData->viewportSize != canvasData->windowSize) {
+            if (windowData->viewportSize != windowData->windowSize) {
 #ifdef THREAD_DEBUG
                 printf("                RenderThread: --- window has changed size...\n");
 #endif
-                canvasData->viewportSize = canvasData->windowSize;
-                canvasData->sizeWasChanged = true;
-                glViewport(0, 0, canvasData->viewportSize.width(), canvasData->viewportSize.height());
+                windowData->viewportSize = windowData->windowSize;
+                windowData->sizeWasChanged = true;
+                glViewport(0, 0, windowData->viewportSize.width(), windowData->viewportSize.height());
             }
 
-            canvasPrivate->syncSceneGraph();
+            windowPrivate->syncSceneGraph();
         }
         inSync = false;
 
@@ -659,65 +659,65 @@ void QQuickRenderThreadSingleContextWindowManager::run()
 #ifdef THREAD_DEBUG
         printf("                RenderThread: sync done\n");
 #endif
-#ifdef QQUICK_CANVAS_TIMING
-        if (qquick_canvas_timing)
+#ifdef QQUICK_RENDER_TIMING
+        if (qquick_render_timing)
             syncTime = threadTimer.elapsed();
 #endif
 
-        for (QHash<QQuickCanvas *, CanvasData *>::const_iterator it = m_rendered_windows.constBegin();
+        for (QHash<QQuickWindow *, WindowData *>::const_iterator it = m_rendered_windows.constBegin();
              it != m_rendered_windows.constEnd(); ++it) {
-            QQuickCanvas *canvas = it.key();
-            CanvasData *canvasData = it.value();
-            QQuickCanvasPrivate *canvasPrivate = QQuickCanvasPrivate::get(canvas);
+            QQuickWindow *window = it.key();
+            WindowData *windowData = it.value();
+            QQuickWindowPrivate *windowPrivate = QQuickWindowPrivate::get(window);
 
 #ifdef THREAD_DEBUG
-            printf("                RenderThread: Rendering canvas %p\n", canvas);
+            printf("                RenderThread: Rendering window %p\n", window);
 #endif
 
-            Q_ASSERT(canvasData->windowSize.width() > 0 && canvasData->windowSize.height() > 0);
+            Q_ASSERT(windowData->windowSize.width() > 0 && windowData->windowSize.height() > 0);
 
 #ifdef THREAD_DEBUG
             printf("                RenderThread: --- rendering at size %dx%d\n",
-                   canvasData->viewportSize.width(), canvasData->viewportSize.height()
+                   windowData->viewportSize.width(), windowData->viewportSize.height()
                    );
 #endif
 
             // We only need to re-makeCurrent when we have multiple surfaces.
             if (m_rendered_windows.size() > 1)
-                gl->makeCurrent(canvas);
+                gl->makeCurrent(window);
 
-            canvasPrivate->renderSceneGraph(canvasData->viewportSize);
-#ifdef QQUICK_CANVAS_TIMING
-            if (qquick_canvas_timing)
+            windowPrivate->renderSceneGraph(windowData->viewportSize);
+#ifdef QQUICK_RENDER_TIMING
+            if (qquick_render_timing)
                 renderTime = threadTimer.elapsed() - syncTime;
 #endif
 
             // The content of the target buffer is undefined after swap() so grab needs
             // to happen before swap();
-            if (canvas == canvasToGrab) {
+            if (window == windowToGrab) {
 #ifdef THREAD_DEBUG
                 printf("                RenderThread: --- grabbing...\n");
 #endif
-                grabContent = qt_gl_read_framebuffer(canvasData->windowSize, false, false);
-                canvasToGrab = 0;
+                grabContent = qt_gl_read_framebuffer(windowData->windowSize, false, false);
+                windowToGrab = 0;
             }
 
 #ifdef THREAD_DEBUG
             printf("                RenderThread: --- wait for swap...\n");
 #endif
 
-            if (canvasData->isVisible && canvas->isExposed())
-                gl->swapBuffers(canvas);
+            if (windowData->isVisible && window->isExposed())
+                gl->swapBuffers(window);
 
-            canvasPrivate->fireFrameSwapped();
+            windowPrivate->fireFrameSwapped();
 #ifdef THREAD_DEBUG
             printf("                RenderThread: --- swap complete...\n");
 #endif
 
         }
 
-#ifdef QQUICK_CANVAS_TIMING
-            if (qquick_canvas_timing) {
+#ifdef QQUICK_RENDER_TIMING
+            if (qquick_render_timing) {
                 swapTime = threadTimer.elapsed() - renderTime;
                 qDebug() << "- Breakdown of frame time; sync:" << syncTime
                          << "ms render:" << renderTime << "ms swap:" << swapTime
@@ -730,12 +730,12 @@ void QQuickRenderThreadSingleContextWindowManager::run()
         handleRemovedWindows();
 
         // Update sizes...
-        for (QHash<QQuickCanvas *, CanvasData *>::const_iterator it = m_rendered_windows.constBegin();
+        for (QHash<QQuickWindow *, WindowData *>::const_iterator it = m_rendered_windows.constBegin();
              it != m_rendered_windows.constEnd(); ++it) {
-            CanvasData *canvasData = it.value();
-            if (canvasData->sizeWasChanged) {
-                canvasData->renderedSize = canvasData->viewportSize;
-                canvasData->sizeWasChanged = false;
+            WindowData *windowData = it.value();
+            if (windowData->sizeWasChanged) {
+                windowData->renderedSize = windowData->viewportSize;
+                windowData->sizeWasChanged = false;
             }
         }
 
@@ -746,7 +746,7 @@ void QQuickRenderThreadSingleContextWindowManager::run()
         // but we don't want to lock an extra time.
         wake();
 
-        if (!animationRunning && !isExternalUpdatePending && !shouldExit && !canvasToGrab) {
+        if (!animationRunning && !isExternalUpdatePending && !shouldExit && !windowToGrab) {
 #ifdef THREAD_DEBUG
             printf("                RenderThread: nothing to do, going to sleep...\n");
 #endif
@@ -800,7 +800,7 @@ bool QQuickRenderThreadSingleContextWindowManager::event(QEvent *e)
 
     if (e->type() == QEvent_Sync) {
 
-        // If all canvases have been hidden, ignore the event
+        // If all windows have been hidden, ignore the event
         if (!isRunning())
             return true;
 
@@ -855,9 +855,9 @@ void QQuickRenderThreadSingleContextWindowManager::sync(bool guiAlreadyLocked)
     if (!guiAlreadyLocked)
         lockInGui();
 
-    for (QHash<QQuickCanvas *, CanvasData *>::const_iterator it = m_rendered_windows.constBegin();
+    for (QHash<QQuickWindow *, WindowData *>::const_iterator it = m_rendered_windows.constBegin();
          it != m_rendered_windows.constEnd(); ++it) {
-        QQuickCanvasPrivate::get(it.key())->polishItems();
+        QQuickWindowPrivate::get(it.key())->polishItems();
     }
 
     wake();
@@ -943,42 +943,42 @@ void QQuickRenderThreadSingleContextWindowManager::animationStopped()
 }
 
 
-void QQuickRenderThreadSingleContextWindowManager::exposureChanged(QQuickCanvas *canvas)
+void QQuickRenderThreadSingleContextWindowManager::exposureChanged(QQuickWindow *window)
 {
-    Q_UNUSED(canvas);
+    Q_UNUSED(window);
 #ifdef THREAD_DEBUG
-    printf("GUI: exposure changed: %p\n", canvas);
+    printf("GUI: exposure changed: %p\n", window);
 #endif
 
-    if (canvas->isExposed())
-        maybeUpdate(canvas);
+    if (window->isExposed())
+        maybeUpdate(window);
 
 #ifdef THREAD_DEBUG
-    printf("GUI: exposure changed done: %p\n", canvas);
+    printf("GUI: exposure changed done: %p\n", window);
 #endif
 }
 
 
 
-void QQuickRenderThreadSingleContextWindowManager::resize(QQuickCanvas *canvas, const QSize &size)
+void QQuickRenderThreadSingleContextWindowManager::resize(QQuickWindow *window, const QSize &size)
 {
 #ifdef THREAD_DEBUG
-    printf("GUI: Resize Event: %p = %dx%d\n", canvas, size.width(), size.height());
+    printf("GUI: Resize Event: %p = %dx%d\n", window, size.width(), size.height());
 #endif
 
     // If the rendering thread is not running we do not need to do anything.
-    // Also if the canvas is being resized to an invalid size, it will be removed
-    // by the canvasVisibilityChanged slot as result of width/heightcChanged()
+    // Also if the window is being resized to an invalid size, it will be removed
+    // by the windowVisibilityChanged slot as result of width/heightcChanged()
     if (!isRunning() || size.width() <= 0 || size.height() <= 0)
         return;
 
     lockInGui();
     exhaustSyncEvent();
 
-    CanvasData *canvasData = m_rendered_windows.value(canvas);
-    if (canvasData) {
-        canvasData->windowSize = size;
-        while (isRunning() && canvasData->renderedSize != size && size.width() > 0 && size.height() > 0) {
+    WindowData *windowData = m_rendered_windows.value(window);
+    if (windowData) {
+        windowData->windowSize = size;
+        while (isRunning() && windowData->renderedSize != size && size.width() > 0 && size.height() > 0) {
             if (isRenderBlocked)
                 wake();
             wait();
@@ -987,7 +987,7 @@ void QQuickRenderThreadSingleContextWindowManager::resize(QQuickCanvas *canvas,
     unlockInGui();
 
 #ifdef THREAD_DEBUG
-    printf("GUI: Resize done: %p\n", canvas);
+    printf("GUI: Resize done: %p\n", window);
 #endif
 }
 
@@ -1066,13 +1066,13 @@ void QQuickRenderThreadSingleContextWindowManager::stopRendering()
 
 
 
-QImage QQuickRenderThreadSingleContextWindowManager::grab(QQuickCanvas *canvas)
+QImage QQuickRenderThreadSingleContextWindowManager::grab(QQuickWindow *window)
 {
     if (!isRunning())
         return QImage();
 
     if (QThread::currentThread() != qApp->thread()) {
-        qWarning("QQuickCanvas::grabFrameBuffer: can only be called from the GUI thread");
+        qWarning("QQuickWindow::grabFrameBuffer: can only be called from the GUI thread");
         return QImage();
     }
 
@@ -1083,8 +1083,8 @@ QImage QQuickRenderThreadSingleContextWindowManager::grab(QQuickCanvas *canvas)
     lockInGui();
     exhaustSyncEvent();
 
-    canvasToGrab = canvas;
-    while (isRunning() && canvasToGrab) {
+    windowToGrab = window;
+    while (isRunning() && windowToGrab) {
         if (isRenderBlocked)
             wake();
         wait();
@@ -1114,10 +1114,10 @@ void QQuickRenderThreadSingleContextWindowManager::handleDeferredUpdate()
     unlockInGui();
 }
 
-void QQuickRenderThreadSingleContextWindowManager::maybeUpdate(QQuickCanvas *)
+void QQuickRenderThreadSingleContextWindowManager::maybeUpdate(QQuickWindow *)
 {
     Q_ASSERT_X(QThread::currentThread() == QCoreApplication::instance()->thread() || inSync,
-               "QQuickCanvas::update",
+               "QQuickWindow::update",
                "Function can only be called from GUI thread or during QQuickItem::updatePaintNode()");
 
     if (inSync) {
@@ -1150,23 +1150,23 @@ QQuickTrivialWindowManager::QQuickTrivialWindowManager()
 }
 
 
-void QQuickTrivialWindowManager::show(QQuickCanvas *canvas)
+void QQuickTrivialWindowManager::show(QQuickWindow *window)
 {
-    CanvasData data;
+    WindowData data;
     data.updatePending = false;
     data.grabOnly = false;
-    m_windows[canvas] = data;
+    m_windows[window] = data;
 
-    maybeUpdate(canvas);
+    maybeUpdate(window);
 }
 
-void QQuickTrivialWindowManager::hide(QQuickCanvas *canvas)
+void QQuickTrivialWindowManager::hide(QQuickWindow *window)
 {
-    if (!m_windows.contains(canvas))
+    if (!m_windows.contains(window))
         return;
 
-    m_windows.remove(canvas);
-    QQuickCanvasPrivate *cd = QQuickCanvasPrivate::get(canvas);
+    m_windows.remove(window);
+    QQuickWindowPrivate *cd = QQuickWindowPrivate::get(window);
     cd->cleanupNodesOnShutdown();
 
     if (m_windows.size() == 0) {
@@ -1176,81 +1176,81 @@ void QQuickTrivialWindowManager::hide(QQuickCanvas *canvas)
     }
 }
 
-void QQuickTrivialWindowManager::canvasDestroyed(QQuickCanvas *canvas)
+void QQuickTrivialWindowManager::windowDestroyed(QQuickWindow *window)
 {
-    hide(canvas);
+    hide(window);
 }
 
-void QQuickTrivialWindowManager::renderCanvas(QQuickCanvas *canvas)
+void QQuickTrivialWindowManager::renderWindow(QQuickWindow *window)
 {
-    if (!canvas->isExposed() || !m_windows.contains(canvas))
+    if (!window->isExposed() || !m_windows.contains(window))
         return;
 
-    CanvasData &data = const_cast<CanvasData &>(m_windows[canvas]);
+    WindowData &data = const_cast<WindowData &>(m_windows[window]);
 
-    QQuickCanvas *masterCanvas = 0;
-    if (!canvas->isVisible()) {
+    QQuickWindow *masterWindow = 0;
+    if (!window->isVisible()) {
         // Find a "proper surface" to bind...
-        for (QHash<QQuickCanvas *, CanvasData>::const_iterator it = m_windows.constBegin();
-             it != m_windows.constEnd() && !masterCanvas; ++it) {
+        for (QHash<QQuickWindow *, WindowData>::const_iterator it = m_windows.constBegin();
+             it != m_windows.constEnd() && !masterWindow; ++it) {
             if (it.key()->isVisible())
-                masterCanvas = it.key();
+                masterWindow = it.key();
         }
     } else {
-        masterCanvas = canvas;
+        masterWindow = window;
     }
 
-    if (!masterCanvas)
+    if (!masterWindow)
         return;
 
     if (!gl) {
         gl = new QOpenGLContext();
-        gl->setFormat(masterCanvas->requestedFormat());
+        gl->setFormat(masterWindow->requestedFormat());
         gl->create();
-        if (!gl->makeCurrent(masterCanvas))
-            qWarning("QQuickCanvas: makeCurrent() failed...");
+        if (!gl->makeCurrent(masterWindow))
+            qWarning("QQuickWindow: makeCurrent() failed...");
         sg->initialize(gl);
     } else {
-        gl->makeCurrent(masterCanvas);
+        gl->makeCurrent(masterWindow);
     }
 
     bool alsoSwap = data.updatePending;
     data.updatePending = false;
 
-    QQuickCanvasPrivate *cd = QQuickCanvasPrivate::get(canvas);
+    QQuickWindowPrivate *cd = QQuickWindowPrivate::get(window);
     cd->polishItems();
     cd->syncSceneGraph();
-    cd->renderSceneGraph(canvas->size());
+    cd->renderSceneGraph(window->size());
 
     if (data.grabOnly) {
-        grabContent = qt_gl_read_framebuffer(canvas->size(), false, false);
+        grabContent = qt_gl_read_framebuffer(window->size(), false, false);
         data.grabOnly = false;
     }
 
-    if (alsoSwap && canvas->isVisible()) {
-        gl->swapBuffers(canvas);
+    if (alsoSwap && window->isVisible()) {
+        gl->swapBuffers(window);
         cd->fireFrameSwapped();
     }
 
     // Might have been set during syncSceneGraph()
     if (data.updatePending)
-        maybeUpdate(canvas);
+        maybeUpdate(window);
 }
 
-void QQuickTrivialWindowManager::exposureChanged(QQuickCanvas *canvas)
+void QQuickTrivialWindowManager::exposureChanged(QQuickWindow *window)
 {
-    if (canvas->isExposed())
-        maybeUpdate(canvas);
+    if (window->isExposed())
+        maybeUpdate(window);
 }
 
-QImage QQuickTrivialWindowManager::grab(QQuickCanvas *canvas)
+QImage QQuickTrivialWindowManager::grab(QQuickWindow *window)
 {
-    if (!m_windows.contains(canvas))
+    if (!m_windows.contains(window))
         return QImage();
 
-    m_windows[canvas].grabOnly = true;
+    m_windows[window].grabOnly = true;
 
-    renderCanvas(canvas);
+    renderWindow(window);
 
     QImage grabbed = grabContent;
     grabContent = QImage();
@@ -1259,18 +1259,18 @@ QImage QQuickTrivialWindowManager::grab(QQuickCanvas *canvas)
 
 
 
-void QQuickTrivialWindowManager::resize(QQuickCanvas *, const QSize &)
+void QQuickTrivialWindowManager::resize(QQuickWindow *, const QSize &)
 {
 }
 
 
 
-void QQuickTrivialWindowManager::maybeUpdate(QQuickCanvas *canvas)
+void QQuickTrivialWindowManager::maybeUpdate(QQuickWindow *window)
 {
-    if (!m_windows.contains(canvas))
+    if (!m_windows.contains(window))
         return;
 
-    m_windows[canvas].updatePending = true;
+    m_windows[window].updatePending = true;
 
     if (!eventPending) {
         QCoreApplication::postEvent(this, new QEvent(QEvent::User));
@@ -1299,11 +1299,11 @@ bool QQuickTrivialWindowManager::event(QEvent *e)
 {
     if (e->type() == QEvent::User) {
         eventPending = false;
-        for (QHash<QQuickCanvas *, CanvasData>::const_iterator it = m_windows.constBegin();
+        for (QHash<QQuickWindow *, WindowData>::const_iterator it = m_windows.constBegin();
              it != m_windows.constEnd(); ++it) {
-            const CanvasData &data = it.value();
+            const WindowData &data = it.value();
             if (data.updatePending)
-                renderCanvas(it.key());
+                renderWindow(it.key());
         }
         return true;
     }
diff --git a/src/quick/items/qquickwindowmanager_p.h b/src/quick/items/qquickwindowmanager_p.h
index 5535019..ccad33c 100644
--- a/src/quick/items/qquickwindowmanager_p.h
+++ b/src/quick/items/qquickwindowmanager_p.h
@@ -47,7 +47,7 @@
 
 QT_BEGIN_NAMESPACE
 
-class QQuickCanvas;
+class QQuickWindow;
 class QSGContext;
 
 class Q_QUICK_PRIVATE_EXPORT QQuickWindowManager
@@ -55,17 +55,17 @@ class Q_QUICK_PRIVATE_EXPORT QQuickWindowManager
 public:
     virtual ~QQuickWindowManager();
 
-    virtual void show(QQuickCanvas *canvas) = 0;
-    virtual void hide(QQuickCanvas *canvas) = 0;
+    virtual void show(QQuickWindow *window) = 0;
+    virtual void hide(QQuickWindow *window) = 0;
 
-    virtual void canvasDestroyed(QQuickCanvas *canvas) = 0;
+    virtual void windowDestroyed(QQuickWindow *window) = 0;
 
-    virtual void exposureChanged(QQuickCanvas *canvas) = 0;
-    virtual QImage grab(QQuickCanvas *canvas) = 0;
-    virtual void resize(QQuickCanvas *canvas, const QSize &size) = 0;
+    virtual void exposureChanged(QQuickWindow *window) = 0;
+    virtual QImage grab(QQuickWindow *window) = 0;
+    virtual void resize(QQuickWindow *window, const QSize &size) = 0;
 
-    virtual void update(QQuickCanvas *canvas) = 0;
-    virtual void maybeUpdate(QQuickCanvas *canvas) = 0;
+    virtual void update(QQuickWindow *window) = 0;
+    virtual void maybeUpdate(QQuickWindow *window) = 0;
     virtual void wakeup() = 0;
 
     virtual volatile bool *allowMainThreadProcessing() = 0;
diff --git a/src/quick/items/qquickwindowmodule.cpp b/src/quick/items/qquickwindowmodule.cpp
index 4c96207..97911c0 100644
--- a/src/quick/items/qquickwindowmodule.cpp
+++ b/src/quick/items/qquickwindowmodule.cpp
@@ -41,7 +41,7 @@
 
 #include "qquickwindowmodule_p.h"
 #include "qquickscreen_p.h"
-#include <QtQuick/QQuickCanvas>
+#include <QtQuick/QQuickWindow>
 
 QT_BEGIN_NAMESPACE
 
@@ -49,7 +49,7 @@ void QQuickWindowModule::defineModule()
 {
     const char uri[] = "QtQuick.Window";
 
-    qmlRegisterType<QQuickCanvas>(uri, 2, 0, "Window");
+    qmlRegisterType<QQuickWindow>(uri, 2, 0, "Window");
     qmlRegisterUncreatableType<QQuickScreen>(uri, 2, 0, "Screen", QStringLiteral("Screen can only be used via the attached property."));
 }
 
diff --git a/src/quick/scenegraph/qsgcontext.cpp b/src/quick/scenegraph/qsgcontext.cpp
index 47cc667..ed6a75d 100644
--- a/src/quick/scenegraph/qsgcontext.cpp
+++ b/src/quick/scenegraph/qsgcontext.cpp
@@ -190,7 +190,7 @@ void QSGContext::invalidate()
 }
 
 
-QSGTexture *QSGContext::textureForFactory(QQuickTextureFactory *factory, QQuickCanvas *canvas)
+QSGTexture *QSGContext::textureForFactory(QQuickTextureFactory *factory, QQuickWindow *window)
 {
     Q_D(QSGContext);
     if (!factory)
@@ -202,7 +202,7 @@ QSGTexture *QSGContext::textureForFactory(QQuickTextureFactory *factory, QQuickC
         if (QQuickDefaultTextureFactory *dtf = qobject_cast<QQuickDefaultTextureFactory *>(factory))
             texture = createTexture(dtf->image());
         else
-            texture = factory->createTexture(canvas);
+            texture = factory->createTexture(window);
         d->textures.insert(factory, texture);
         connect(factory, SIGNAL(destroyed(QObject *)), this, SLOT(textureFactoryDestroyed(QObject *)), Qt::DirectConnection);
     }
diff --git a/src/quick/scenegraph/qsgcontext_p.h b/src/quick/scenegraph/qsgcontext_p.h
index a2495a8..99fbdd2 100644
--- a/src/quick/scenegraph/qsgcontext_p.h
+++ b/src/quick/scenegraph/qsgcontext_p.h
@@ -65,7 +65,7 @@ class QSGImageNode;
 class QSGGlyphNode;
 class QSGRenderer;
 class QSGDistanceFieldGlyphCache;
-class QQuickCanvas;
+class QQuickWindow;
 class QSGTexture;
 class QSGMaterial;
 class QSGMaterialShader;
@@ -111,7 +111,7 @@ public:
 
     virtual QSurfaceFormat defaultSurfaceFormat() const;
 
-    QSGTexture *textureForFactory(QQuickTextureFactory *factory, QQuickCanvas *canvas);
+    QSGTexture *textureForFactory(QQuickTextureFactory *factory, QQuickWindow *window);
 
     static QSGContext *createDefaultContext();
 
diff --git a/src/quick/scenegraph/qsgshareddistancefieldglyphcache.cpp b/src/quick/scenegraph/qsgshareddistancefieldglyphcache.cpp
index e6bd529..dcbff84 100644
--- a/src/quick/scenegraph/qsgshareddistancefieldglyphcache.cpp
+++ b/src/quick/scenegraph/qsgshareddistancefieldglyphcache.cpp
@@ -54,7 +54,7 @@
 
 #include <qpa/qplatformsharedgraphicscache.h>
 
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 
 // #define QSGSHAREDDISTANCEFIELDGLYPHCACHE_DEBUG
 
@@ -228,12 +228,12 @@ QSGSharedDistanceFieldGlyphCache::QSGSharedDistanceFieldGlyphCache(const QByteAr
             this, SLOT(reportItemsInvalidated(QByteArray,QVector<quint32>)),
             Qt::DirectConnection);
 
-    QQuickCanvas *canvas = static_cast<QQuickCanvas *>(c->surface());
-    Q_ASSERT(canvas != 0);
+    QQuickWindow *window = static_cast<QQuickWindow *>(c->surface());
+    Q_ASSERT(window != 0);
 
-    connect(canvas, SIGNAL(beforeSynchronizing()), this, SLOT(sceneGraphUpdateStarted()),
+    connect(window, SIGNAL(beforeSynchronizing()), this, SLOT(sceneGraphUpdateStarted()),
             Qt::DirectConnection);
-    connect(canvas, SIGNAL(beforeRendering()), this, SLOT(sceneGraphUpdateDone()),
+    connect(window, SIGNAL(beforeRendering()), this, SLOT(sceneGraphUpdateDone()),
             Qt::DirectConnection);
 }
 
diff --git a/src/quick/scenegraph/util/qsgtexture.cpp b/src/quick/scenegraph/util/qsgtexture.cpp
index c3f15cc..facf077 100644
--- a/src/quick/scenegraph/util/qsgtexture.cpp
+++ b/src/quick/scenegraph/util/qsgtexture.cpp
@@ -191,7 +191,7 @@ static void qt_debug_remove_texture(QSGTexture* texture)
     masks. The scene graph backend provides a default implementation
     of normal color textures. As the implementation of these may be
     hardware specific, they are are constructed via the factory
-    function QQuickCanvas::createTextureFromImage().
+    function QQuickWindow::createTextureFromImage().
 
     The texture is a wrapper around an OpenGL texture, which texture
     id is given by textureId() and which size in pixels is given by
diff --git a/src/quick/util/qquickimageprovider.h b/src/quick/util/qquickimageprovider.h
index 459b3ea..dd814d4 100644
--- a/src/quick/util/qquickimageprovider.h
+++ b/src/quick/util/qquickimageprovider.h
@@ -54,7 +54,7 @@ QT_BEGIN_NAMESPACE
 
 class QQuickImageProviderPrivate;
 class QSGTexture;
-class QQuickCanvas;
+class QQuickWindow;
 
 class Q_QUICK_EXPORT QQuickTextureFactory : public QObject
 {
@@ -62,7 +62,7 @@ public:
     QQuickTextureFactory();
     virtual ~QQuickTextureFactory();
 
-    virtual QSGTexture *createTexture(QQuickCanvas *canvas) const = 0;
+    virtual QSGTexture *createTexture(QQuickWindow *window) const = 0;
     virtual QSize textureSize() const = 0;
     virtual int textureByteCount() const = 0;
     virtual QImage image() const;
diff --git a/src/quick/util/qquickpixmapcache.cpp b/src/quick/util/qquickpixmapcache.cpp
index 592def1..1f4da46 100644
--- a/src/quick/util/qquickpixmapcache.cpp
+++ b/src/quick/util/qquickpixmapcache.cpp
@@ -88,7 +88,7 @@ static inline QString imageId(const QUrl &url)
     return url.toString(QUrl::RemoveScheme | QUrl::RemoveAuthority).mid(1);
 }
 
-QSGTexture *QQuickDefaultTextureFactory::createTexture(QQuickCanvas *) const
+QSGTexture *QQuickDefaultTextureFactory::createTexture(QQuickWindow *) const
 {
     QSGPlainTexture *t = new QSGPlainTexture();
     t->setImage(im);
diff --git a/src/quick/util/qquickpixmapcache_p.h b/src/quick/util/qquickpixmapcache_p.h
index 3695c30..ca4405c 100644
--- a/src/quick/util/qquickpixmapcache_p.h
+++ b/src/quick/util/qquickpixmapcache_p.h
@@ -68,7 +68,7 @@ public:
     {
     }
 
-    QSGTexture *createTexture(QQuickCanvas *canvas) const;
+    QSGTexture *createTexture(QQuickWindow *window) const;
     QSize textureSize() const { return im.size(); }
     int textureByteCount() const { return im.byteCount(); }
     QImage image() const { return im; }
diff --git a/tests/auto/particles/shared/particlestestsshared.h b/tests/auto/particles/shared/particlestestsshared.h
index d1d1813..6cd805a 100644
--- a/tests/auto/particles/shared/particlestestsshared.h
+++ b/tests/auto/particles/shared/particlestestsshared.h
@@ -68,17 +68,17 @@ bool myFuzzyGEQ(qreal a, qreal b)
 
 QQuickView* createView(const QUrl &filename, int additionalWait=0)
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *view = new QQuickView(0);
 
-    canvas->setSource(filename);
-    if (canvas->status() != QQuickView::Ready)
+    view->setSource(filename);
+    if (view->status() != QQuickView::Ready)
         return 0;
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    view->show();
+    QTest::qWaitForWindowShown(view);
     if (additionalWait)
         QTest::qWait(additionalWait);
 
-    return canvas;
+    return view;
 }
 
 void ensureAnimTime(int requiredTime, QAbstractAnimation* anim)//With consistentTiming, who knows how long an animation really takes...
diff --git a/tests/auto/quick/examples/tst_examples.cpp b/tests/auto/quick/examples/tst_examples.cpp
index 6cce5b8..309a149 100644
--- a/tests/auto/quick/examples/tst_examples.cpp
+++ b/tests/auto/quick/examples/tst_examples.cpp
@@ -83,10 +83,10 @@ private:
 
     QQmlEngine engine;
 
-    QQuickCanvas *canvas;
+    QQuickWindow *window;
 };
 
-tst_examples::tst_examples() : canvas(0)
+tst_examples::tst_examples() : window(0)
 {
     // Add files to exclude here
     excludedFiles << "examples/quick/canvas/tiger/tiger.qml"; // QTBUG-26528
@@ -123,7 +123,7 @@ tst_examples::tst_examples() : canvas(0)
 
 tst_examples::~tst_examples()
 {
-    delete canvas;
+    delete window;
 }
 
 void tst_examples::init()
@@ -262,13 +262,13 @@ void tst_examples::sgexamples()
         component.completeCreate();
     QVERIFY(root);
 
-    if (!canvas) {
-        canvas = new QQuickCanvas();
-        canvas->resize(240, 320);
-        canvas->show();
-        QTest::qWaitForWindowShown(canvas);
+    if (!window) {
+        window = new QQuickWindow();
+        window->resize(240, 320);
+        window->show();
+        QTest::qWaitForWindowShown(window);
     }
-    root->setParentItem(canvas->rootItem());
+    root->setParentItem(window->rootItem());
     component.completeCreate();
 
     qApp->processEvents();
@@ -306,13 +306,13 @@ void tst_examples::sgsnippets()
         component.completeCreate();
     QVERIFY(root);
 
-    if (!canvas) {
-        canvas = new QQuickCanvas();
-        canvas->resize(240, 320);
-        canvas->show();
-        QTest::qWaitForWindowShown(canvas);
+    if (!window) {
+        window = new QQuickWindow();
+        window->resize(240, 320);
+        window->show();
+        QTest::qWaitForWindowShown(window);
     }
-    root->setParentItem(canvas->rootItem());
+    root->setParentItem(window->rootItem());
     component.completeCreate();
 
     qApp->processEvents();
diff --git a/tests/auto/quick/qquickaccessible/tst_qquickaccessible.cpp b/tests/auto/quick/qquickaccessible/tst_qquickaccessible.cpp
index fa2c1cf..a99a775 100644
--- a/tests/auto/quick/qquickaccessible/tst_qquickaccessible.cpp
+++ b/tests/auto/quick/qquickaccessible/tst_qquickaccessible.cpp
@@ -277,12 +277,12 @@ void tst_QQuickAccessible::basicPropertiesTest()
     QAI app = QAI(QAccessible::queryAccessibleInterface(qApp));
     QCOMPARE(app->childCount(), 0);
 
-    QQuickView *canvas = new QQuickView();
-    canvas->setSource(testFileUrl("statictext.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView();
+    window->setSource(testFileUrl("statictext.qml"));
+    window->show();
     QCOMPARE(app->childCount(), 1);
 
-    QAI iface = QAI(QAccessible::queryAccessibleInterface(canvas));
+    QAI iface = QAI(QAccessible::queryAccessibleInterface(window));
     QVERIFY(iface.data());
     QCOMPARE(iface->childCount(), 1);
 
@@ -318,7 +318,7 @@ void tst_QQuickAccessible::basicPropertiesTest()
     QCOMPARE(iface->indexOfChild(text2.data()), -1);
     QCOMPARE(text2->indexOfChild(item.data()), -1);
 
-    delete canvas;
+    delete window;
 }
 
 QAI topLevelChildAt(QAccessibleInterface *iface, int x, int y)
@@ -336,13 +336,13 @@ QAI topLevelChildAt(QAccessibleInterface *iface, int x, int y)
 
 void tst_QQuickAccessible::hitTest()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("hittest.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("hittest.qml"));
+    window->show();
 
-    QAI canvasIface = QAI(QAccessible::queryAccessibleInterface(canvas));
-    QVERIFY(canvasIface.data());
-    QAI rootItem = QAI(canvasIface->child(0));
+    QAI windowIface = QAI(QAccessible::queryAccessibleInterface(window));
+    QVERIFY(windowIface.data());
+    QAI rootItem = QAI(windowIface->child(0));
     QRect rootRect = rootItem->rect();
 
     // check the root item from app
@@ -378,21 +378,21 @@ void tst_QQuickAccessible::hitTest()
     QVERIFY(rect201);
 
     QRect rect201Rect = rect201->rect();
-    rootItemIface = QAI(canvasIface->childAt(rect201Rect.x() + 20, rect201Rect.y() + 20));
+    rootItemIface = QAI(windowIface->childAt(rect201Rect.x() + 20, rect201Rect.y() + 20));
     QVERIFY(rootItemIface);
     QCOMPARE(rootItemIface->rect(), rect201Rect);
     QCOMPARE(rootItemIface->text(QAccessible::Name), QLatin1String("rect201"));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickAccessible::checkableTest()
 {
-    QQuickView *canvas = new QQuickView();
-    canvas->setSource(testFileUrl("checkbuttons.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView();
+    window->setSource(testFileUrl("checkbuttons.qml"));
+    window->show();
 
-    QAI iface = QAI(QAccessible::queryAccessibleInterface(canvas));
+    QAI iface = QAI(QAccessible::queryAccessibleInterface(window));
     QVERIFY(iface.data());
     QAI root = QAI(iface->child(0));
 
diff --git a/tests/auto/quick/qquickanimatedimage/tst_qquickanimatedimage.cpp b/tests/auto/quick/qquickanimatedimage/tst_qquickanimatedimage.cpp
index 690d5c1..c527ded 100644
--- a/tests/auto/quick/qquickanimatedimage/tst_qquickanimatedimage.cpp
+++ b/tests/auto/quick/qquickanimatedimage/tst_qquickanimatedimage.cpp
@@ -81,8 +81,8 @@ private slots:
 
 void tst_qquickanimatedimage::cleanup()
 {
-    QQuickCanvas canvas;
-    canvas.releaseResources();
+    QQuickWindow window;
+    window.releaseResources();
 }
 
 void tst_qquickanimatedimage::play()
@@ -149,20 +149,20 @@ void tst_qquickanimatedimage::mirror_running()
 {
     // test where mirror is set to true after animation has started
 
-    QQuickView canvas;
-    canvas.show();
+    QQuickView window;
+    window.show();
 
-    canvas.setSource(testFileUrl("hearts.qml"));
-    QQuickAnimatedImage *anim = qobject_cast<QQuickAnimatedImage *>(canvas.rootObject());
+    window.setSource(testFileUrl("hearts.qml"));
+    QQuickAnimatedImage *anim = qobject_cast<QQuickAnimatedImage *>(window.rootObject());
     QVERIFY(anim);
 
     int width = anim->property("width").toInt();
 
     QCOMPARE(anim->currentFrame(), 0);
-    QPixmap frame0 = QPixmap::fromImage(canvas.grabFrameBuffer());
+    QPixmap frame0 = QPixmap::fromImage(window.grabWindow());
 
     anim->setCurrentFrame(1);
-    QPixmap frame1 = QPixmap::fromImage(canvas.grabFrameBuffer());
+    QPixmap frame1 = QPixmap::fromImage(window.grabWindow());
 
     anim->setCurrentFrame(0);
 
@@ -173,11 +173,11 @@ void tst_qquickanimatedimage::mirror_running()
     anim->setProperty("mirror", true);
 
     QCOMPARE(anim->currentFrame(), 1);
-    QPixmap frame1_flipped = QPixmap::fromImage(canvas.grabFrameBuffer());
+    QPixmap frame1_flipped = QPixmap::fromImage(window.grabWindow());
 
     QTRY_VERIFY(spy.count() == 1); spy.clear();
     QCOMPARE(anim->currentFrame(), 0);  // animation only has 2 frames, should cycle back to first
-    QPixmap frame0_flipped = QPixmap::fromImage(canvas.grabFrameBuffer());
+    QPixmap frame0_flipped = QPixmap::fromImage(window.grabWindow());
 
     QSKIP("Skip while QTBUG-19351 and QTBUG-19252 are not resolved");
 
@@ -196,15 +196,15 @@ void tst_qquickanimatedimage::mirror_notRunning()
 {
     QFETCH(QUrl, fileUrl);
 
-    QQuickView canvas;
-    canvas.show();
+    QQuickView window;
+    window.show();
 
-    canvas.setSource(fileUrl);
-    QQuickAnimatedImage *anim = qobject_cast<QQuickAnimatedImage *>(canvas.rootObject());
+    window.setSource(fileUrl);
+    QQuickAnimatedImage *anim = qobject_cast<QQuickAnimatedImage *>(window.rootObject());
     QVERIFY(anim);
 
     int width = anim->property("width").toInt();
-    QPixmap screenshot = QPixmap::fromImage(canvas.grabFrameBuffer());
+    QPixmap screenshot = QPixmap::fromImage(window.grabWindow());
 
     QTransform transform;
     transform.translate(width, 0).scale(-1, 1.0);
@@ -215,7 +215,7 @@ void tst_qquickanimatedimage::mirror_notRunning()
     bool paused = anim->isPlaying();
 
     anim->setProperty("mirror", true);
-    screenshot = QPixmap::fromImage(canvas.grabFrameBuffer());
+    screenshot = QPixmap::fromImage(window.grabWindow());
 
     QCOMPARE(screenshot, expected);
 
diff --git a/tests/auto/quick/qquickanimatedsprite/tst_qquickanimatedsprite.cpp b/tests/auto/quick/qquickanimatedsprite/tst_qquickanimatedsprite.cpp
index b45b5d5..2ed837f 100644
--- a/tests/auto/quick/qquickanimatedsprite/tst_qquickanimatedsprite.cpp
+++ b/tests/auto/quick/qquickanimatedsprite/tst_qquickanimatedsprite.cpp
@@ -64,14 +64,14 @@ void tst_qquickanimatedsprite::initTestCase()
 
 void tst_qquickanimatedsprite::test_properties()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
-    canvas->setSource(testFileUrl("basic.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("basic.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QVERIFY(canvas->rootObject());
-    QQuickAnimatedSprite* sprite = canvas->rootObject()->findChild<QQuickAnimatedSprite*>("sprite");
+    QVERIFY(window->rootObject());
+    QQuickAnimatedSprite* sprite = window->rootObject()->findChild<QQuickAnimatedSprite*>("sprite");
     QVERIFY(sprite);
 
     QVERIFY(sprite->running());
@@ -84,19 +84,19 @@ void tst_qquickanimatedsprite::test_properties()
     sprite->setInterpolate(false);
     QVERIFY(!sprite->interpolate());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickanimatedsprite::test_frameChangedSignal()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
-    canvas->setSource(testFileUrl("frameChange.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("frameChange.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QVERIFY(canvas->rootObject());
-    QQuickAnimatedSprite* sprite = canvas->rootObject()->findChild<QQuickAnimatedSprite*>("sprite");
+    QVERIFY(window->rootObject());
+    QQuickAnimatedSprite* sprite = window->rootObject()->findChild<QQuickAnimatedSprite*>("sprite");
     QVERIFY(sprite);
 
     QVERIFY(!sprite->running());
@@ -109,7 +109,7 @@ void tst_qquickanimatedsprite::test_frameChangedSignal()
     QTRY_COMPARE(frameChangedSpy.count(), 3*6);
     QTRY_VERIFY(!sprite->running());
 
-    delete canvas;
+    delete window;
 }
 
 QTEST_MAIN(tst_qquickanimatedsprite)
diff --git a/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp b/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp
index c277330..65affa5 100644
--- a/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp
+++ b/tests/auto/quick/qquickapplication/tst_qquickapplication.cpp
@@ -80,25 +80,25 @@ void tst_qquickapplication::active()
                       "}", QUrl::fromLocalFile(""));
     QQuickItem *item = qobject_cast<QQuickItem *>(component.create());
     QVERIFY(item);
-    QQuickCanvas canvas;
-    item->setParentItem(canvas.rootItem());
+    QQuickWindow window;
+    item->setParentItem(window.rootItem());
 
     // not active
     QVERIFY(!item->property("active").toBool());
     QVERIFY(!item->property("active2").toBool());
 
     // active
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
-    QVERIFY(QGuiApplication::focusWindow() == &canvas);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
+    QVERIFY(QGuiApplication::focusWindow() == &window);
     QVERIFY(item->property("active").toBool());
     QVERIFY(item->property("active2").toBool());
 
     // not active again
     QWindowSystemInterface::handleWindowActivated(0);
 
-    QTRY_VERIFY(QGuiApplication::focusWindow() != &canvas);
+    QTRY_VERIFY(QGuiApplication::focusWindow() != &window);
     QVERIFY(!item->property("active").toBool());
     QVERIFY(!item->property("active2").toBool());
 }
diff --git a/tests/auto/quick/qquickborderimage/tst_qquickborderimage.cpp b/tests/auto/quick/qquickborderimage/tst_qquickborderimage.cpp
index 7e32ca0..30994b7 100644
--- a/tests/auto/quick/qquickborderimage/tst_qquickborderimage.cpp
+++ b/tests/auto/quick/qquickborderimage/tst_qquickborderimage.cpp
@@ -98,8 +98,8 @@ private:
 
 void tst_qquickborderimage::cleanup()
 {
-    QQuickCanvas canvas;
-    canvas.releaseResources();
+    QQuickWindow window;
+    window.releaseResources();
     engine.clearComponentCache();
 }
 
@@ -237,12 +237,12 @@ void tst_qquickborderimage::smooth()
 
 void tst_qquickborderimage::mirror()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("mirror.qml"));
-    QQuickBorderImage *image = qobject_cast<QQuickBorderImage*>(canvas->rootObject());
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("mirror.qml"));
+    QQuickBorderImage *image = qobject_cast<QQuickBorderImage*>(window->rootObject());
     QVERIFY(image != 0);
 
-    QImage screenshot = canvas->grabFrameBuffer();
+    QImage screenshot = window->grabWindow();
 
     QImage srcPixmap(screenshot);
     QTransform transform;
@@ -250,10 +250,10 @@ void tst_qquickborderimage::mirror()
     srcPixmap = srcPixmap.transformed(transform);
 
     image->setProperty("mirror", true);
-    screenshot = canvas->grabFrameBuffer();
+    screenshot = window->grabWindow();
     QCOMPARE(screenshot, srcPixmap);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickborderimage::tileModes()
diff --git a/tests/auto/quick/qquickcanvas/data/AnimationsWhileHidden.qml b/tests/auto/quick/qquickcanvas/data/AnimationsWhileHidden.qml
deleted file mode 100644
index e95b029..0000000
--- a/tests/auto/quick/qquickcanvas/data/AnimationsWhileHidden.qml
+++ /dev/null
@@ -1,17 +0,0 @@
-import QtQuick 2.0
-import QtQuick.Window 2.0 as Window
-
-Window.Window
-{
-    id: win
-    visible: true
-    width: 250
-    height: 250
-
-    SequentialAnimation {
-        PauseAnimation { duration: 500 }
-        PropertyAction { target: win; property: "visible"; value: true }
-        loops: Animation.Infinite
-        running: true
-    }
-}
diff --git a/tests/auto/quick/qquickcanvas/data/Headless.qml b/tests/auto/quick/qquickcanvas/data/Headless.qml
deleted file mode 100644
index 2e09cb1..0000000
--- a/tests/auto/quick/qquickcanvas/data/Headless.qml
+++ /dev/null
@@ -1,33 +0,0 @@
-import QtQuick 2.0
-import QtQuick.Window 2.0 as Window
-
-Window.Window {
-
-    width: 300
-    height: 200
-    visible: true
-
-    Text {
-        anchors.left: parent.left
-        anchors.top: parent.top
-        text: "Testing headless mode"
-    }
-
-    Rectangle {
-        anchors.centerIn: parent
-        width: 100
-        height: 50
-        rotation: -30
-        gradient: Gradient {
-            GradientStop { position: 0; color: "lightsteelblue" }
-            GradientStop { position: 1; color: "black" }
-        }
-    }
-
-    Image {
-        source: "colors.png"
-        anchors.bottom: parent.bottom
-        anchors.right: parent.right
-    }
-
-}
diff --git a/tests/auto/quick/qquickcanvas/data/colors.png b/tests/auto/quick/qquickcanvas/data/colors.png
deleted file mode 100644
index dfb62f3..0000000
Binary files a/tests/auto/quick/qquickcanvas/data/colors.png and /dev/null differ
diff --git a/tests/auto/quick/qquickcanvas/data/focus.qml b/tests/auto/quick/qquickcanvas/data/focus.qml
deleted file mode 100644
index 901f2fc..0000000
--- a/tests/auto/quick/qquickcanvas/data/focus.qml
+++ /dev/null
@@ -1,11 +0,0 @@
-import QtQuick 2.0
-import QtQuick.Window 2.0 as Window
-
-Window.Window {
-     Item {
-          objectName: "item1"
-     }
-     Item {
-          objectName: "item2"
-     }
-}
diff --git a/tests/auto/quick/qquickcanvas/data/ownershipRootItem.qml b/tests/auto/quick/qquickcanvas/data/ownershipRootItem.qml
deleted file mode 100644
index dfc4159..0000000
--- a/tests/auto/quick/qquickcanvas/data/ownershipRootItem.qml
+++ /dev/null
@@ -1,11 +0,0 @@
-import QtQuick 2.0
-import QtQuick.Window 2.0 as Window
-
-Window.Window {
-RootItemAccessor {
-  id:accessor
-  objectName:"accessor"
-  Component.onCompleted:accessor.rootItem();
-}
-
-}
\ No newline at end of file
diff --git a/tests/auto/quick/qquickcanvas/data/window.qml b/tests/auto/quick/qquickcanvas/data/window.qml
deleted file mode 100644
index d79d516..0000000
--- a/tests/auto/quick/qquickcanvas/data/window.qml
+++ /dev/null
@@ -1,9 +0,0 @@
-import QtQuick 2.0
-import QtQuick.Window 2.0 as Window
-
-Window.Window {
-    color: "#00FF00"
-    Item {
-        objectName: "item"
-    }
-}
diff --git a/tests/auto/quick/qquickcanvas/qquickcanvas.pro b/tests/auto/quick/qquickcanvas/qquickcanvas.pro
deleted file mode 100644
index b9ed73d..0000000
--- a/tests/auto/quick/qquickcanvas/qquickcanvas.pro
+++ /dev/null
@@ -1,17 +0,0 @@
-CONFIG += testcase
-TARGET = tst_qquickcanvas
-SOURCES += tst_qquickcanvas.cpp
-
-include (../../shared/util.pri)
-
-macx:CONFIG -= app_bundle
-
-CONFIG += parallel_test
-QT += core-private gui-private qml-private quick-private v8-private testlib
-
-TESTDATA = data/*
-
-OTHER_FILES += \
-    data/AnimationsWhileHidden.qml \
-    data/Headless.qml
-
diff --git a/tests/auto/quick/qquickcanvas/tst_qquickcanvas.cpp b/tests/auto/quick/qquickcanvas/tst_qquickcanvas.cpp
deleted file mode 100644
index 3c684a6..0000000
--- a/tests/auto/quick/qquickcanvas/tst_qquickcanvas.cpp
+++ /dev/null
@@ -1,1065 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/
-**
-** This file is part of the test suite of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser General Public
-** License version 2.1 as published by the Free Software Foundation and
-** appearing in the file LICENSE.LGPL included in the packaging of this
-** file. Please review the following information to ensure the GNU Lesser
-** General Public License version 2.1 requirements will be met:
-** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Nokia gives you certain additional
-** rights. These rights are described in the Nokia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU General
-** Public License version 3.0 as published by the Free Software Foundation
-** and appearing in the file LICENSE.GPL included in the packaging of this
-** file. Please review the following information to ensure the GNU General
-** Public License version 3.0 requirements will be met:
-** http://www.gnu.org/copyleft/gpl.html.
-**
-** Other Usage
-** Alternatively, this file may be used in accordance with the terms and
-** conditions contained in a signed written agreement between you and Nokia.
-**
-**
-**
-**
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include <qtest.h>
-#include <QDebug>
-#include <QTouchEvent>
-#include <QtQuick/QQuickItem>
-#include <QtQuick/QQuickCanvas>
-#include <QtQml/QQmlEngine>
-#include <QtQml/QQmlComponent>
-#include <QtQuick/private/qquickrectangle_p.h>
-#include "../../shared/util.h"
-#include <QSignalSpy>
-#include <private/qquickcanvas_p.h>
-#include <private/qguiapplication_p.h>
-
-struct TouchEventData {
-    QEvent::Type type;
-    QWidget *widget;
-    QWindow *window;
-    Qt::TouchPointStates states;
-    QList<QTouchEvent::TouchPoint> touchPoints;
-};
-
-static QTouchEvent::TouchPoint makeTouchPoint(QQuickItem *item, const QPointF &p, const QPointF &lastPoint = QPointF())
-{
-    QPointF last = lastPoint.isNull() ? p : lastPoint;
-
-    QTouchEvent::TouchPoint tp;
-
-    tp.setPos(p);
-    tp.setLastPos(last);
-    tp.setScenePos(item->mapToScene(p));
-    tp.setLastScenePos(item->mapToScene(last));
-    tp.setScreenPos(item->canvas()->mapToGlobal(tp.scenePos().toPoint()));
-    tp.setLastScreenPos(item->canvas()->mapToGlobal(tp.lastScenePos().toPoint()));
-    return tp;
-}
-
-static TouchEventData makeTouchData(QEvent::Type type, QWindow *w, Qt::TouchPointStates states = 0,
-                                    const QList<QTouchEvent::TouchPoint>& touchPoints = QList<QTouchEvent::TouchPoint>())
-{
-    TouchEventData d = { type, 0, w, states, touchPoints };
-    return d;
-}
-static TouchEventData makeTouchData(QEvent::Type type, QWindow *w, Qt::TouchPointStates states, const QTouchEvent::TouchPoint &touchPoint)
-{
-    QList<QTouchEvent::TouchPoint> points;
-    points << touchPoint;
-    return makeTouchData(type, w, states, points);
-}
-
-#define COMPARE_TOUCH_POINTS(tp1, tp2) \
-{ \
-    QCOMPARE(tp1.pos(), tp2.pos()); \
-    QCOMPARE(tp1.lastPos(), tp2.lastPos()); \
-    QCOMPARE(tp1.scenePos(), tp2.scenePos()); \
-    QCOMPARE(tp1.lastScenePos(), tp2.lastScenePos()); \
-    QCOMPARE(tp1.screenPos(), tp2.screenPos()); \
-    QCOMPARE(tp1.lastScreenPos(), tp2.lastScreenPos()); \
-}
-
-#define COMPARE_TOUCH_DATA(d1, d2) \
-{ \
-    QCOMPARE((int)d1.type, (int)d2.type); \
-    QCOMPARE(d1.widget, d2.widget); \
-    QCOMPARE((int)d1.states, (int)d2.states); \
-    QCOMPARE(d1.touchPoints.count(), d2.touchPoints.count()); \
-    for (int i=0; i<d1.touchPoints.count(); i++) { \
-        COMPARE_TOUCH_POINTS(d1.touchPoints[i], d2.touchPoints[i]); \
-    } \
-}
-
-
-class RootItemAccessor : public QQuickItem
-{
-    Q_OBJECT
-public:
-    RootItemAccessor()
-        : m_rootItemDestroyed(false)
-        , m_rootItem(0)
-    {
-    }
-    Q_INVOKABLE QQuickItem *rootItem()
-    {
-        if (!m_rootItem) {
-            QQuickCanvasPrivate *c = QQuickCanvasPrivate::get(canvas());
-            m_rootItem = c->rootItem;
-            QObject::connect(m_rootItem, SIGNAL(destroyed()), this, SLOT(rootItemDestroyed()));
-        }
-        return m_rootItem;
-    }
-    bool isRootItemDestroyed() {return m_rootItemDestroyed;}
-public slots:
-    void rootItemDestroyed() {
-        m_rootItemDestroyed = true;
-    }
-
-private:
-    bool m_rootItemDestroyed;
-    QQuickItem *m_rootItem;
-};
-
-class TestTouchItem : public QQuickRectangle
-{
-    Q_OBJECT
-public:
-    TestTouchItem(QQuickItem *parent = 0)
-        : QQuickRectangle(parent), acceptTouchEvents(true), acceptMouseEvents(true),
-          mousePressId(0),
-          spinLoopWhenPressed(false), touchEventCount(0)
-    {
-        border()->setWidth(1);
-        setAcceptedMouseButtons(Qt::LeftButton);
-        setFiltersChildMouseEvents(true);
-    }
-
-    void reset() {
-        acceptTouchEvents = acceptMouseEvents = true;
-        setEnabled(true);
-        setVisible(true);
-
-        lastEvent = makeTouchData(QEvent::None, canvas(), 0, QList<QTouchEvent::TouchPoint>());//CHECK_VALID
-
-        lastVelocity = lastVelocityFromMouseMove = QVector2D();
-        lastMousePos = QPointF();
-        lastMouseCapabilityFlags = 0;
-    }
-
-    static void clearMousePressCounter()
-    {
-        mousePressNum = mouseMoveNum = mouseReleaseNum = 0;
-    }
-
-    void clearTouchEventCounter()
-    {
-        touchEventCount = 0;
-    }
-
-    bool acceptTouchEvents;
-    bool acceptMouseEvents;
-    TouchEventData lastEvent;
-    int mousePressId;
-    bool spinLoopWhenPressed;
-    int touchEventCount;
-    QVector2D lastVelocity;
-    QVector2D lastVelocityFromMouseMove;
-    QPointF lastMousePos;
-    int lastMouseCapabilityFlags;
-
-    void touchEvent(QTouchEvent *event) {
-        if (!acceptTouchEvents) {
-            event->ignore();
-            return;
-        }
-        ++touchEventCount;
-        lastEvent = makeTouchData(event->type(), event->window(), event->touchPointStates(), event->touchPoints());
-        if (event->device()->capabilities().testFlag(QTouchDevice::Velocity) && !event->touchPoints().isEmpty()) {
-            lastVelocity = event->touchPoints().first().velocity();
-        } else {
-            lastVelocity = QVector2D();
-        }
-        if (spinLoopWhenPressed && event->touchPointStates().testFlag(Qt::TouchPointPressed)) {
-            QCoreApplication::processEvents();
-        }
-    }
-
-    void mousePressEvent(QMouseEvent *e) {
-        if (!acceptMouseEvents) {
-            e->ignore();
-            return;
-        }
-        mousePressId = ++mousePressNum;
-        lastMousePos = e->pos();
-        lastMouseCapabilityFlags = QGuiApplicationPrivate::mouseEventCaps(e);
-    }
-
-    void mouseMoveEvent(QMouseEvent *e) {
-        if (!acceptMouseEvents) {
-            e->ignore();
-            return;
-        }
-        ++mouseMoveNum;
-        lastVelocityFromMouseMove = QGuiApplicationPrivate::mouseEventVelocity(e);
-        lastMouseCapabilityFlags = QGuiApplicationPrivate::mouseEventCaps(e);
-        lastMousePos = e->pos();
-    }
-
-    void mouseReleaseEvent(QMouseEvent *e) {
-        if (!acceptMouseEvents) {
-            e->ignore();
-            return;
-        }
-        ++mouseReleaseNum;
-        lastMousePos = e->pos();
-        lastMouseCapabilityFlags = QGuiApplicationPrivate::mouseEventCaps(e);
-    }
-
-    bool childMouseEventFilter(QQuickItem *, QEvent *event) {
-        // TODO Is it a bug if a QTouchEvent comes here?
-        if (event->type() == QEvent::MouseButtonPress)
-            mousePressId = ++mousePressNum;
-        return false;
-    }
-
-    static int mousePressNum, mouseMoveNum, mouseReleaseNum;
-};
-
-int TestTouchItem::mousePressNum = 0;
-int TestTouchItem::mouseMoveNum = 0;
-int TestTouchItem::mouseReleaseNum = 0;
-
-class ConstantUpdateItem : public QQuickItem
-{
-Q_OBJECT
-public:
-    ConstantUpdateItem(QQuickItem *parent = 0) : QQuickItem(parent), iterations(0) {setFlag(ItemHasContents);}
-
-    int iterations;
-protected:
-    QSGNode* updatePaintNode(QSGNode *, UpdatePaintNodeData *){
-        iterations++;
-        update();
-        return 0;
-    }
-};
-
-class tst_qquickcanvas : public QQmlDataTest
-{
-    Q_OBJECT
-public:
-
-private slots:
-    void initTestCase()
-    {
-        QQmlDataTest::initTestCase();
-        touchDevice = new QTouchDevice;
-        touchDevice->setType(QTouchDevice::TouchScreen);
-        QWindowSystemInterface::registerTouchDevice(touchDevice);
-        touchDeviceWithVelocity = new QTouchDevice;
-        touchDeviceWithVelocity->setType(QTouchDevice::TouchScreen);
-        touchDeviceWithVelocity->setCapabilities(QTouchDevice::Position | QTouchDevice::Velocity);
-        QWindowSystemInterface::registerTouchDevice(touchDeviceWithVelocity);
-    }
-
-
-    void constantUpdates();
-    void mouseFiltering();
-    void headless();
-
-    void touchEvent_basic();
-    void touchEvent_propagation();
-    void touchEvent_propagation_data();
-    void touchEvent_cancel();
-    void touchEvent_reentrant();
-    void touchEvent_velocity();
-
-    void mouseFromTouch_basic();
-
-    void clearCanvas();
-
-    void qmlCreation();
-    void clearColor();
-
-    void grab();
-    void multipleWindows();
-
-    void animationsWhileHidden();
-
-    void focusObject();
-
-    void ignoreUnhandledMouseEvents();
-
-    void ownershipRootItem();
-private:
-    QTouchDevice *touchDevice;
-    QTouchDevice *touchDeviceWithVelocity;
-};
-
-//If the item calls update inside updatePaintNode, it should schedule another update
-void tst_qquickcanvas::constantUpdates()
-{
-    QQuickCanvas canvas;
-    canvas.resize(250, 250);
-    ConstantUpdateItem item(canvas.rootItem());
-    canvas.show();
-    QTRY_VERIFY(item.iterations > 60);
-}
-
-void tst_qquickcanvas::touchEvent_basic()
-{
-    TestTouchItem::clearMousePressCounter();
-
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    TestTouchItem *bottomItem = new TestTouchItem(canvas->rootItem());
-    bottomItem->setObjectName("Bottom Item");
-    bottomItem->setSize(QSizeF(150, 150));
-
-    TestTouchItem *middleItem = new TestTouchItem(bottomItem);
-    middleItem->setObjectName("Middle Item");
-    middleItem->setPos(QPointF(50, 50));
-    middleItem->setSize(QSizeF(150, 150));
-
-    TestTouchItem *topItem = new TestTouchItem(middleItem);
-    topItem->setObjectName("Top Item");
-    topItem->setPos(QPointF(50, 50));
-    topItem->setSize(QSizeF(150, 150));
-
-    QPointF pos(10, 10);
-
-    // press single point
-    QTest::touchEvent(canvas, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),canvas);
-    QTest::qWait(50);
-
-    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
-
-    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
-    // At one point this was failing with kwin (KDE window manager) because canvas->setPos(100, 100)
-    // would put the decorated window at that position rather than the canvas itself.
-    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed, makeTouchPoint(topItem, pos)));
-    topItem->reset();
-
-    // press multiple points
-    QTest::touchEvent(canvas, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),canvas)
-            .press(1, bottomItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
-    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
-    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed, makeTouchPoint(topItem, pos)));
-    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed, makeTouchPoint(bottomItem, pos)));
-    topItem->reset();
-    bottomItem->reset();
-
-    // touch point on top item moves to bottom item, but top item should still receive the event
-    QTest::touchEvent(canvas, touchDevice).press(0, topItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QTest::touchEvent(canvas, touchDevice).move(0, bottomItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
-    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchUpdate, canvas, Qt::TouchPointMoved,
-            makeTouchPoint(topItem, topItem->mapFromItem(bottomItem, pos), pos)));
-    topItem->reset();
-
-    // touch point on bottom item moves to top item, but bottom item should still receive the event
-    QTest::touchEvent(canvas, touchDevice).press(0, bottomItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QTest::touchEvent(canvas, touchDevice).move(0, topItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
-    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchUpdate, canvas, Qt::TouchPointMoved,
-            makeTouchPoint(bottomItem, bottomItem->mapFromItem(topItem, pos), pos)));
-    bottomItem->reset();
-
-    // a single stationary press on an item shouldn't cause an event
-    QTest::touchEvent(canvas, touchDevice).press(0, topItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QTest::touchEvent(canvas, touchDevice).stationary(0)
-            .press(1, bottomItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);    // received press only, not stationary
-    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
-    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed, makeTouchPoint(topItem, pos)));
-    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed, makeTouchPoint(bottomItem, pos)));
-    topItem->reset();
-    bottomItem->reset();
-    // cleanup: what is pressed must be released
-    // Otherwise you will get an assertion failure:
-    // ASSERT: "itemForTouchPointId.isEmpty()" in file items/qquickcanvas.cpp
-    QTest::touchEvent(canvas, touchDevice).release(0, pos.toPoint(), canvas).release(1, pos.toPoint(), canvas);
-
-    // move touch point from top item to bottom, and release
-    QTest::touchEvent(canvas, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),canvas);
-    QTest::qWait(50);
-    QTest::touchEvent(canvas, touchDevice).release(0, bottomItem->mapToScene(pos).toPoint(),canvas);
-    QTest::qWait(50);
-    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
-    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchEnd, canvas, Qt::TouchPointReleased,
-            makeTouchPoint(topItem, topItem->mapFromItem(bottomItem, pos), pos)));
-    topItem->reset();
-
-    // release while another point is pressed
-    QTest::touchEvent(canvas, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),canvas)
-            .press(1, bottomItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QTest::touchEvent(canvas, touchDevice).move(0, bottomItem->mapToScene(pos).toPoint(), canvas);
-    QTest::qWait(50);
-    QTest::touchEvent(canvas, touchDevice).release(0, bottomItem->mapToScene(pos).toPoint(), canvas)
-                             .stationary(1);
-    QTest::qWait(50);
-    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
-    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
-    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchEnd, canvas, Qt::TouchPointReleased,
-            makeTouchPoint(topItem, topItem->mapFromItem(bottomItem, pos))));
-    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed, makeTouchPoint(bottomItem, pos)));
-    topItem->reset();
-    bottomItem->reset();
-
-    delete topItem;
-    delete middleItem;
-    delete bottomItem;
-    delete canvas;
-}
-
-void tst_qquickcanvas::touchEvent_propagation()
-{
-    TestTouchItem::clearMousePressCounter();
-
-    QFETCH(bool, acceptTouchEvents);
-    QFETCH(bool, acceptMouseEvents);
-    QFETCH(bool, enableItem);
-    QFETCH(bool, showItem);
-
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    TestTouchItem *bottomItem = new TestTouchItem(canvas->rootItem());
-    bottomItem->setObjectName("Bottom Item");
-    bottomItem->setSize(QSizeF(150, 150));
-
-    TestTouchItem *middleItem = new TestTouchItem(bottomItem);
-    middleItem->setObjectName("Middle Item");
-    middleItem->setPos(QPointF(50, 50));
-    middleItem->setSize(QSizeF(150, 150));
-
-    TestTouchItem *topItem = new TestTouchItem(middleItem);
-    topItem->setObjectName("Top Item");
-    topItem->setPos(QPointF(50, 50));
-    topItem->setSize(QSizeF(150, 150));
-
-    QPointF pos(10, 10);
-    QPoint pointInBottomItem = bottomItem->mapToScene(pos).toPoint();  // (10, 10)
-    QPoint pointInMiddleItem = middleItem->mapToScene(pos).toPoint();  // (60, 60) overlaps with bottomItem
-    QPoint pointInTopItem = topItem->mapToScene(pos).toPoint();  // (110, 110) overlaps with bottom & top items
-
-    // disable topItem
-    topItem->acceptTouchEvents = acceptTouchEvents;
-    topItem->acceptMouseEvents = acceptMouseEvents;
-    topItem->setEnabled(enableItem);
-    topItem->setVisible(showItem);
-
-    // single touch to top item, should be received by middle item
-    QTest::touchEvent(canvas, touchDevice).press(0, pointInTopItem, canvas);
-    QTest::qWait(50);
-    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
-    QCOMPARE(middleItem->lastEvent.touchPoints.count(), 1);
-    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
-    COMPARE_TOUCH_DATA(middleItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed,
-            makeTouchPoint(middleItem, middleItem->mapFromItem(topItem, pos))));
-
-    // touch top and middle items, middle item should get both events
-    QTest::touchEvent(canvas, touchDevice).press(0, pointInTopItem, canvas)
-            .press(1, pointInMiddleItem, canvas);
-    QTest::qWait(50);
-    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
-    QCOMPARE(middleItem->lastEvent.touchPoints.count(), 2);
-    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
-    COMPARE_TOUCH_DATA(middleItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed,
-           (QList<QTouchEvent::TouchPoint>() << makeTouchPoint(middleItem, middleItem->mapFromItem(topItem, pos))
-                                              << makeTouchPoint(middleItem, pos) )));
-    middleItem->reset();
-
-    // disable middleItem as well
-    middleItem->acceptTouchEvents = acceptTouchEvents;
-    middleItem->acceptMouseEvents = acceptMouseEvents;
-    middleItem->setEnabled(enableItem);
-    middleItem->setVisible(showItem);
-
-    // touch top and middle items, bottom item should get all events
-    QTest::touchEvent(canvas, touchDevice).press(0, pointInTopItem, canvas)
-            .press(1, pointInMiddleItem, canvas);
-    QTest::qWait(50);
-    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
-    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 2);
-    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed,
-            (QList<QTouchEvent::TouchPoint>() << makeTouchPoint(bottomItem, bottomItem->mapFromItem(topItem, pos))
-                                              << makeTouchPoint(bottomItem, bottomItem->mapFromItem(middleItem, pos)) )));
-    bottomItem->reset();
-
-    // disable bottom item as well
-    bottomItem->acceptTouchEvents = acceptTouchEvents;
-    bottomItem->setEnabled(enableItem);
-    bottomItem->setVisible(showItem);
-
-    // no events should be received
-    QTest::touchEvent(canvas, touchDevice).press(0, pointInTopItem, canvas)
-            .press(1, pointInMiddleItem, canvas)
-            .press(2, pointInBottomItem, canvas);
-    QTest::qWait(50);
-    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
-    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
-
-    topItem->reset();
-    middleItem->reset();
-    bottomItem->reset();
-
-    // disable middle item, touch on top item
-    middleItem->acceptTouchEvents = acceptTouchEvents;
-    middleItem->setEnabled(enableItem);
-    middleItem->setVisible(showItem);
-    QTest::touchEvent(canvas, touchDevice).press(0, pointInTopItem, canvas);
-    QTest::qWait(50);
-    if (!enableItem || !showItem) {
-        // middle item is disabled or has 0 opacity, bottom item receives the event
-        QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
-        QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-        QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
-        COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed,
-                makeTouchPoint(bottomItem, bottomItem->mapFromItem(topItem, pos))));
-    } else {
-        // middle item ignores event, sends it to the top item (top-most child)
-        QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
-        QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
-        QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
-        COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed,
-                makeTouchPoint(topItem, pos)));
-    }
-
-    delete topItem;
-    delete middleItem;
-    delete bottomItem;
-    delete canvas;
-}
-
-void tst_qquickcanvas::touchEvent_propagation_data()
-{
-    QTest::addColumn<bool>("acceptTouchEvents");
-    QTest::addColumn<bool>("acceptMouseEvents");
-    QTest::addColumn<bool>("enableItem");
-    QTest::addColumn<bool>("showItem");
-
-    QTest::newRow("disable events") << false << false << true << true;
-    QTest::newRow("disable item") << true << true << false << true;
-    QTest::newRow("hide item") << true << true << true << false;
-}
-
-void tst_qquickcanvas::touchEvent_cancel()
-{
-    TestTouchItem::clearMousePressCounter();
-
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    TestTouchItem *item = new TestTouchItem(canvas->rootItem());
-    item->setPos(QPointF(50, 50));
-    item->setSize(QSizeF(150, 150));
-
-    QPointF pos(10, 10);
-    QTest::touchEvent(canvas, touchDevice).press(0, item->mapToScene(pos).toPoint(),canvas);
-    QCoreApplication::processEvents();
-
-    QTRY_COMPARE(item->lastEvent.touchPoints.count(), 1);
-    TouchEventData d = makeTouchData(QEvent::TouchBegin, canvas, Qt::TouchPointPressed, makeTouchPoint(item,pos));
-    COMPARE_TOUCH_DATA(item->lastEvent, d);
-    item->reset();
-
-    QWindowSystemInterface::handleTouchCancelEvent(0, touchDevice);
-    QCoreApplication::processEvents();
-    d = makeTouchData(QEvent::TouchCancel, canvas);
-    COMPARE_TOUCH_DATA(item->lastEvent, d);
-
-    delete item;
-    delete canvas;
-}
-
-void tst_qquickcanvas::touchEvent_reentrant()
-{
-    TestTouchItem::clearMousePressCounter();
-
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    TestTouchItem *item = new TestTouchItem(canvas->rootItem());
-
-    item->spinLoopWhenPressed = true; // will call processEvents() from the touch handler
-
-    item->setPos(QPointF(50, 50));
-    item->setSize(QSizeF(150, 150));
-    QPointF pos(60, 60);
-
-    // None of these should commit from the dtor.
-    QTest::QTouchEventSequence press = QTest::touchEvent(canvas, touchDevice, false).press(0, pos.toPoint(), canvas);
-    pos += QPointF(2, 2);
-    QTest::QTouchEventSequence move = QTest::touchEvent(canvas, touchDevice, false).move(0, pos.toPoint(), canvas);
-    QTest::QTouchEventSequence release = QTest::touchEvent(canvas, touchDevice, false).release(0, pos.toPoint(), canvas);
-
-    // Now commit (i.e. call QWindowSystemInterface::handleTouchEvent), but do not process the events yet.
-    press.commit(false);
-    move.commit(false);
-    release.commit(false);
-
-    QCoreApplication::processEvents();
-
-    QTRY_COMPARE(item->touchEventCount, 3);
-
-    delete item;
-    delete canvas;
-}
-
-void tst_qquickcanvas::touchEvent_velocity()
-{
-    TestTouchItem::clearMousePressCounter();
-
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-    QTest::qWait(10);
-
-    TestTouchItem *item = new TestTouchItem(canvas->rootItem());
-    item->setPos(QPointF(50, 50));
-    item->setSize(QSizeF(150, 150));
-
-    QList<QWindowSystemInterface::TouchPoint> points;
-    QWindowSystemInterface::TouchPoint tp;
-    tp.id = 1;
-    tp.state = Qt::TouchPointPressed;
-    QPoint pos = canvas->mapToGlobal(item->mapToScene(QPointF(10, 10)).toPoint());
-    tp.area = QRectF(pos, QSizeF(4, 4));
-    points << tp;
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    points[0].state = Qt::TouchPointMoved;
-    points[0].area.adjust(5, 5, 5, 5);
-    QVector2D velocity(1.5, 2.5);
-    points[0].velocity = velocity;
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    QCoreApplication::processEvents();
-    QCOMPARE(item->touchEventCount, 2);
-    QCOMPARE(item->lastEvent.touchPoints.count(), 1);
-    QCOMPARE(item->lastVelocity, velocity);
-
-    // Now have a transformation on the item and check if velocity and position are transformed accordingly.
-    item->setRotation(90); // clockwise
-    QMatrix4x4 transformMatrix;
-    transformMatrix.rotate(-90, 0, 0, 1); // counterclockwise
-    QVector2D transformedVelocity = transformMatrix.mapVector(velocity).toVector2D();
-    points[0].area.adjust(5, 5, 5, 5);
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    QCoreApplication::processEvents();
-    QCOMPARE(item->lastVelocity, transformedVelocity);
-    QPoint itemLocalPos = item->mapFromScene(canvas->mapFromGlobal(points[0].area.center().toPoint())).toPoint();
-    QPoint itemLocalPosFromEvent = item->lastEvent.touchPoints[0].pos().toPoint();
-    QCOMPARE(itemLocalPos, itemLocalPosFromEvent);
-
-    points[0].state = Qt::TouchPointReleased;
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    QCoreApplication::processEvents();
-    delete item;
-    delete canvas;
-}
-
-void tst_qquickcanvas::mouseFromTouch_basic()
-{
-    // Turn off accepting touch events with acceptTouchEvents. This
-    // should result in sending mouse events generated from the touch
-    // with the new event propagation system.
-
-    TestTouchItem::clearMousePressCounter();
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-    QTest::qWait(10);
-
-    TestTouchItem *item = new TestTouchItem(canvas->rootItem());
-    item->setPos(QPointF(50, 50));
-    item->setSize(QSizeF(150, 150));
-    item->acceptTouchEvents = false;
-
-    QList<QWindowSystemInterface::TouchPoint> points;
-    QWindowSystemInterface::TouchPoint tp;
-    tp.id = 1;
-    tp.state = Qt::TouchPointPressed;
-    QPoint pos = canvas->mapToGlobal(item->mapToScene(QPointF(10, 10)).toPoint());
-    tp.area = QRectF(pos, QSizeF(4, 4));
-    points << tp;
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    points[0].state = Qt::TouchPointMoved;
-    points[0].area.adjust(5, 5, 5, 5);
-    QVector2D velocity(1.5, 2.5);
-    points[0].velocity = velocity;
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    points[0].state = Qt::TouchPointReleased;
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    QCoreApplication::processEvents();
-
-    // The item should have received a mouse press, move, and release.
-    QCOMPARE(item->mousePressNum, 1);
-    QCOMPARE(item->mouseMoveNum, 1);
-    QCOMPARE(item->mouseReleaseNum, 1);
-    QCOMPARE(item->lastMousePos.toPoint(), item->mapFromScene(canvas->mapFromGlobal(points[0].area.center().toPoint())).toPoint());
-    QCOMPARE(item->lastVelocityFromMouseMove, velocity);
-    QVERIFY((item->lastMouseCapabilityFlags & QTouchDevice::Velocity) != 0);
-
-    // Now the same with a transformation.
-    item->setRotation(90); // clockwise
-    QMatrix4x4 transformMatrix;
-    transformMatrix.rotate(-90, 0, 0, 1); // counterclockwise
-    QVector2D transformedVelocity = transformMatrix.mapVector(velocity).toVector2D();
-    points[0].state = Qt::TouchPointPressed;
-    points[0].velocity = velocity;
-    points[0].area = QRectF(pos, QSizeF(4, 4));
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    points[0].state = Qt::TouchPointMoved;
-    points[0].area.adjust(5, 5, 5, 5);
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    QCoreApplication::processEvents();
-    QCOMPARE(item->lastMousePos.toPoint(), item->mapFromScene(canvas->mapFromGlobal(points[0].area.center().toPoint())).toPoint());
-    QCOMPARE(item->lastVelocityFromMouseMove, transformedVelocity);
-
-    points[0].state = Qt::TouchPointReleased;
-    QWindowSystemInterface::handleTouchEvent(canvas, touchDeviceWithVelocity, points);
-    QCoreApplication::processEvents();
-    delete item;
-    delete canvas;
-}
-
-void tst_qquickcanvas::clearCanvas()
-{
-    QQuickCanvas *canvas = new QQuickCanvas;
-    QQuickItem *item = new QQuickItem;
-    item->setParentItem(canvas->rootItem());
-
-    QVERIFY(item->canvas() == canvas);
-
-    delete canvas;
-
-    QVERIFY(item->canvas() == 0);
-
-    delete item;
-}
-
-void tst_qquickcanvas::mouseFiltering()
-{
-    TestTouchItem::clearMousePressCounter();
-
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    TestTouchItem *bottomItem = new TestTouchItem(canvas->rootItem());
-    bottomItem->setObjectName("Bottom Item");
-    bottomItem->setSize(QSizeF(150, 150));
-
-    TestTouchItem *middleItem = new TestTouchItem(bottomItem);
-    middleItem->setObjectName("Middle Item");
-    middleItem->setPos(QPointF(50, 50));
-    middleItem->setSize(QSizeF(150, 150));
-
-    TestTouchItem *topItem = new TestTouchItem(middleItem);
-    topItem->setObjectName("Top Item");
-    topItem->setPos(QPointF(50, 50));
-    topItem->setSize(QSizeF(150, 150));
-
-    QPoint pos(100, 100);
-
-    QTest::mousePress(canvas, Qt::LeftButton, 0, pos);
-
-    // Mouse filtering propagates down the stack, so the
-    // correct order is
-    // 1. middleItem filters event
-    // 2. bottomItem filters event
-    // 3. topItem receives event
-    QTRY_COMPARE(middleItem->mousePressId, 1);
-    QTRY_COMPARE(bottomItem->mousePressId, 2);
-    QTRY_COMPARE(topItem->mousePressId, 3);
-
-    delete canvas;
-}
-
-void tst_qquickcanvas::qmlCreation()
-{
-    QQmlEngine engine;
-    QQmlComponent component(&engine);
-    component.loadUrl(testFileUrl("window.qml"));
-    QObject* created = component.create();
-    QVERIFY(created);
-
-    QQuickCanvas* canvas = qobject_cast<QQuickCanvas*>(created);
-    QVERIFY(canvas);
-    QCOMPARE(canvas->clearColor(), QColor(Qt::green));
-
-    QQuickItem* item = canvas->findChild<QQuickItem*>("item");
-    QVERIFY(item);
-    QCOMPARE(item->canvas(), canvas);
-
-    delete canvas;
-}
-
-void tst_qquickcanvas::clearColor()
-{
-    //### Can we examine rendering to make sure it is really blue?
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(250, 250);
-    canvas->setPos(100, 100);
-    canvas->setClearColor(Qt::blue);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-    QCOMPARE(canvas->clearColor(), QColor(Qt::blue));
-    delete canvas;
-}
-
-void tst_qquickcanvas::grab()
-{
-    QQuickCanvas canvas;
-    canvas.setClearColor(Qt::red);
-
-    canvas.resize(250, 250);
-    canvas.show();
-
-    QTest::qWaitForWindowShown(&canvas);
-
-    QImage content = canvas.grabFrameBuffer();
-    QCOMPARE(content.width(), canvas.width());
-    QCOMPARE(content.height(), canvas.height());
-    QCOMPARE((uint) content.convertToFormat(QImage::Format_RGB32).pixel(0, 0), (uint) 0xffff0000);
-}
-
-void tst_qquickcanvas::multipleWindows()
-{
-    QList<QQuickCanvas *> windows;
-    for (int i=0; i<6; ++i) {
-        QQuickCanvas *c = new QQuickCanvas();
-        c->setClearColor(Qt::GlobalColor(Qt::red + i));
-        c->resize(300, 200);
-        c->setPos(100 + i * 30, 100 + i * 20);
-        c->show();
-        windows << c;
-        QVERIFY(c->isVisible());
-    }
-
-    // move them
-    for (int i=0; i<windows.size(); ++i) {
-        QQuickCanvas *c = windows.at(i);
-        c->setPos(c->x() - 10, c->y() - 10);
-    }
-
-    // resize them
-    for (int i=0; i<windows.size(); ++i) {
-        QQuickCanvas *c = windows.at(i);
-        c->resize(200, 150);
-    }
-
-    qDeleteAll(windows);
-}
-
-void tst_qquickcanvas::animationsWhileHidden()
-{
-    QQmlEngine engine;
-    QQmlComponent component(&engine);
-    component.loadUrl(testFileUrl("AnimationsWhileHidden.qml"));
-    QObject* created = component.create();
-
-    QQuickCanvas* canvas = qobject_cast<QQuickCanvas*>(created);
-    QVERIFY(canvas);
-    QVERIFY(canvas->isVisible());
-
-    // Now hide the window and verify that it went off screen
-    canvas->hide();
-    QTest::qWait(10);
-    QVERIFY(!canvas->isVisible());
-
-    // Running animaiton should cause it to become visible again shortly.
-    QTRY_VERIFY(canvas->isVisible());
-
-    delete canvas;
-}
-
-
-void tst_qquickcanvas::headless()
-{
-    QQmlEngine engine;
-    QQmlComponent component(&engine);
-    component.loadUrl(testFileUrl("Headless.qml"));
-    QObject* created = component.create();
-
-    QQuickCanvas* canvas = qobject_cast<QQuickCanvas*>(created);
-    QVERIFY(canvas);
-
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->isVisible());
-
-    QSignalSpy initialized(canvas, SIGNAL(sceneGraphInitialized()));
-    QSignalSpy invalidated(canvas, SIGNAL(sceneGraphInvalidated()));
-
-    // Verify that the canvas is alive and kicking
-    QVERIFY(canvas->openglContext() != 0);
-
-    // Store the visual result
-    QImage originalContent = canvas->grabFrameBuffer();
-
-    // Hide the canvas and verify signal emittion and GL context deletion
-    canvas->hide();
-    canvas->releaseResources();
-
-    QTRY_COMPARE(invalidated.size(), 1);
-    QVERIFY(canvas->openglContext() == 0);
-
-    // Destroy the native windowing system buffers
-    canvas->destroy();
-    QVERIFY(canvas->handle() == 0);
-
-    // Show and verify that we are back and running
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    QTRY_COMPARE(initialized.size(), 1);
-    QVERIFY(canvas->openglContext() != 0);
-
-    // Verify that the visual output is the same
-    QImage newContent = canvas->grabFrameBuffer();
-
-    QCOMPARE(originalContent, newContent);
-
-    delete canvas;
-}
-
-void tst_qquickcanvas::focusObject()
-{
-    QQmlEngine engine;
-    QQmlComponent component(&engine);
-    component.loadUrl(testFileUrl("focus.qml"));
-    QObject *created = component.create();
-    QVERIFY(created);
-
-    QQuickCanvas *canvas = qobject_cast<QQuickCanvas*>(created);
-    QVERIFY(canvas);
-
-    QQuickItem *item1 = canvas->findChild<QQuickItem*>("item1");
-    QVERIFY(item1);
-    item1->setFocus(true);
-    QCOMPARE(item1, canvas->focusObject());
-
-    QQuickItem *item2 = canvas->findChild<QQuickItem*>("item2");
-    QVERIFY(item2);
-    item2->setFocus(true);
-    QCOMPARE(item2, canvas->focusObject());
-
-    delete canvas;
-}
-
-void tst_qquickcanvas::ignoreUnhandledMouseEvents()
-{
-    QQuickCanvas* canvas = new QQuickCanvas;
-    canvas->resize(100, 100);
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    QQuickItem* item = new QQuickItem;
-    item->setSize(QSizeF(100, 100));
-    item->setParentItem(canvas->rootItem());
-
-    {
-        QMouseEvent me(QEvent::MouseButtonPress, QPointF(50, 50), Qt::LeftButton, Qt::LeftButton,
-                       Qt::NoModifier);
-        me.setAccepted(true);
-        QVERIFY(QCoreApplication::sendEvent(canvas, &me));
-        QVERIFY(!me.isAccepted());
-    }
-
-    {
-        QMouseEvent me(QEvent::MouseMove, QPointF(51, 51), Qt::LeftButton, Qt::LeftButton,
-                       Qt::NoModifier);
-        me.setAccepted(true);
-        QVERIFY(QCoreApplication::sendEvent(canvas, &me));
-        QVERIFY(!me.isAccepted());
-    }
-
-    {
-        QMouseEvent me(QEvent::MouseButtonRelease, QPointF(51, 51), Qt::LeftButton, Qt::LeftButton,
-                       Qt::NoModifier);
-        me.setAccepted(true);
-        QVERIFY(QCoreApplication::sendEvent(canvas, &me));
-        QVERIFY(!me.isAccepted());
-    }
-
-    delete canvas;
-}
-
-
-void tst_qquickcanvas::ownershipRootItem()
-{
-    qmlRegisterType<RootItemAccessor>("QtQuick", 2, 0, "RootItemAccessor");
-
-    QQmlEngine engine;
-    QQmlComponent component(&engine);
-    component.loadUrl(testFileUrl("ownershipRootItem.qml"));
-    QObject* created = component.create();
-
-    QQuickCanvas* canvas = qobject_cast<QQuickCanvas*>(created);
-    QVERIFY(canvas);
-    QTest::qWaitForWindowShown(canvas);
-
-    RootItemAccessor* accessor = canvas->findChild<RootItemAccessor*>("accessor");
-    QVERIFY(accessor);
-    engine.collectGarbage();
-
-    QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);
-    QCoreApplication::processEvents();
-    QVERIFY(!accessor->isRootItemDestroyed());
-}
-QTEST_MAIN(tst_qquickcanvas)
-
-#include "tst_qquickcanvas.moc"
diff --git a/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp b/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp
index 12c1a03..7649a37 100644
--- a/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp
+++ b/tests/auto/quick/qquickdrag/tst_qquickdrag.cpp
@@ -179,8 +179,8 @@ void tst_QQuickDrag::cleanupTestCase()
 
 void tst_QQuickDrag::active()
 {
-    QQuickCanvas canvas;
-    TestDropTarget dropTarget(canvas.rootItem());
+    QQuickWindow window;
+    TestDropTarget dropTarget(window.rootItem());
     dropTarget.setSize(QSizeF(100, 100));
     QQmlComponent component(&engine);
     component.setData(
@@ -389,8 +389,8 @@ void tst_QQuickDrag::active()
 
 void tst_QQuickDrag::drop()
 {
-    QQuickCanvas canvas;
-    TestDropTarget outerTarget(canvas.rootItem());
+    QQuickWindow window;
+    TestDropTarget outerTarget(window.rootItem());
     outerTarget.setSize(QSizeF(100, 100));
     outerTarget.acceptAction = Qt::CopyAction;
     TestDropTarget innerTarget(&outerTarget);
@@ -525,8 +525,8 @@ void tst_QQuickDrag::drop()
 
 void tst_QQuickDrag::move()
 {
-    QQuickCanvas canvas;
-    TestDropTarget outerTarget(canvas.rootItem());
+    QQuickWindow window;
+    TestDropTarget outerTarget(window.rootItem());
     outerTarget.setSize(QSizeF(100, 100));
     TestDropTarget leftTarget(&outerTarget);
     leftTarget.setPos(QPointF(0, 35));
@@ -679,12 +679,12 @@ void tst_QQuickDrag::move()
 
 void tst_QQuickDrag::parentChange()
 {
-    QQuickCanvas canvas1;
-    TestDropTarget dropTarget1(canvas1.rootItem());
+    QQuickWindow window1;
+    TestDropTarget dropTarget1(window1.rootItem());
     dropTarget1.setSize(QSizeF(100, 100));
 
-    QQuickCanvas canvas2;
-    TestDropTarget dropTarget2(canvas2.rootItem());
+    QQuickWindow window2;
+    TestDropTarget dropTarget2(window2.rootItem());
     dropTarget2.setSize(QSizeF(100, 100));
 
     QQmlComponent component(&engine);
@@ -704,12 +704,12 @@ void tst_QQuickDrag::parentChange()
     QCOMPARE(evaluate<bool>(item, "Drag.active"), true);
 
     // Verify setting a parent item for an item with an active drag sends an enter event.
-    item->setParentItem(canvas1.rootItem());
+    item->setParentItem(window1.rootItem());
     QCOMPARE(dropTarget1.enterEvents, 0);
     QCoreApplication::processEvents();
     QCOMPARE(dropTarget1.enterEvents, 1);
 
-    // Changing the parent within the same canvas should send a move event.
+    // Changing the parent within the same window should send a move event.
     item->setParentItem(&dropTarget1);
     QCOMPARE(dropTarget1.enterEvents, 1);
     QCOMPARE(dropTarget1.moveEvents, 0);
@@ -717,9 +717,9 @@ void tst_QQuickDrag::parentChange()
     QCOMPARE(dropTarget1.enterEvents, 1);
     QCOMPARE(dropTarget1.moveEvents, 1);
 
-    // Changing the parent to an item in another canvas sends a leave event in the old canvas
-    // and an enter on the new canvas.
-    item->setParentItem(canvas2.rootItem());
+    // Changing the parent to an item in another window sends a leave event in the old window
+    // and an enter on the new window.
+    item->setParentItem(window2.rootItem());
     QCOMPARE(dropTarget1.enterEvents, 1);
     QCOMPARE(dropTarget1.moveEvents, 1);
     QCOMPARE(dropTarget1.leaveEvents, 0);
@@ -746,13 +746,13 @@ void tst_QQuickDrag::parentChange()
 
     // Go around again and verify no events if active is false.
     evaluate<void>(item, "Drag.active = false");
-    item->setParentItem(canvas1.rootItem());
+    item->setParentItem(window1.rootItem());
     QCoreApplication::processEvents();
 
     item->setParentItem(&dropTarget1);
     QCoreApplication::processEvents();
 
-    item->setParentItem(canvas2.rootItem());
+    item->setParentItem(window2.rootItem());
     QCoreApplication::processEvents();
 
     item->setParentItem(0);
@@ -766,8 +766,8 @@ void tst_QQuickDrag::parentChange()
 
 void tst_QQuickDrag::hotSpot()
 {
-    QQuickCanvas canvas;
-    TestDropTarget dropTarget(canvas.rootItem());
+    QQuickWindow window;
+    TestDropTarget dropTarget(window.rootItem());
     dropTarget.setSize(QSizeF(100, 100));
     QQmlComponent component(&engine);
     component.setData(
@@ -830,8 +830,8 @@ void tst_QQuickDrag::hotSpot()
 
 void tst_QQuickDrag::supportedActions()
 {
-    QQuickCanvas canvas;
-    TestDropTarget dropTarget(canvas.rootItem());
+    QQuickWindow window;
+    TestDropTarget dropTarget(window.rootItem());
     dropTarget.setSize(QSizeF(100, 100));
     QQmlComponent component(&engine);
     component.setData(
@@ -888,8 +888,8 @@ void tst_QQuickDrag::supportedActions()
 
 void tst_QQuickDrag::proposedAction()
 {
-    QQuickCanvas canvas;
-    TestDropTarget dropTarget(canvas.rootItem());
+    QQuickWindow window;
+    TestDropTarget dropTarget(window.rootItem());
     dropTarget.setSize(QSizeF(100, 100));
     QQmlComponent component(&engine);
     component.setData(
@@ -957,9 +957,9 @@ void tst_QQuickDrag::keys()
     QCOMPARE(item->property("keys").toStringList(), QStringList() << "red" << "blue");
 
     // Test changing the keys restarts a drag.
-    QQuickCanvas canvas;
-    item->setParentItem(canvas.rootItem());
-    TestDropTarget dropTarget(canvas.rootItem());
+    QQuickWindow window;
+    item->setParentItem(window.rootItem());
+    TestDropTarget dropTarget(window.rootItem());
     dropTarget.setSize(QSizeF(100, 100));
 
     evaluate<void>(item, "Drag.start()");
@@ -1005,9 +1005,9 @@ void tst_QQuickDrag::source()
     QCOMPARE(evaluate<QObject *>(item, "source"), static_cast<QObject *>(item));
 
     // Test changing the source restarts a drag.
-    QQuickCanvas canvas;
-    item->setParentItem(canvas.rootItem());
-    TestDropTarget dropTarget(canvas.rootItem());
+    QQuickWindow window;
+    item->setParentItem(window.rootItem());
+    TestDropTarget dropTarget(window.rootItem());
     dropTarget.setSize(QSizeF(100, 100));
 
     evaluate<void>(item, "Drag.start()");
@@ -1182,8 +1182,8 @@ void tst_QQuickDrag::recursion()
     if (!warning.isEmpty())
         QTest::ignoreMessage(QtWarningMsg, warning.constData());
 
-    QQuickCanvas canvas;
-    RecursingDropTarget dropTarget(script, type, canvas.rootItem());
+    QQuickWindow window;
+    RecursingDropTarget dropTarget(script, type, window.rootItem());
     dropTarget.setSize(QSizeF(100, 100));
     QQmlComponent component(&engine);
     component.setData(
@@ -1195,7 +1195,7 @@ void tst_QQuickDrag::recursion()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *item = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(item);
-    item->setParentItem(canvas.rootItem());
+    item->setParentItem(window.rootItem());
 
     dropTarget.setItem(item);
 
diff --git a/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp b/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp
index 5480c0c..8ccca9c 100644
--- a/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp
+++ b/tests/auto/quick/qquickdroparea/tst_qquickdroparea.cpp
@@ -101,7 +101,7 @@ void tst_QQuickDropArea::cleanupTestCase()
 
 void tst_QQuickDropArea::containsDrag_internal()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -121,7 +121,7 @@ void tst_QQuickDropArea::containsDrag_internal()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea);
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QQuickItem *dragItem = dropArea->findChild<QQuickItem *>("dragItem");
     QVERIFY(dragItem);
@@ -172,7 +172,7 @@ void tst_QQuickDropArea::containsDrag_internal()
 
 void tst_QQuickDropArea::containsDrag_external()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -187,22 +187,22 @@ void tst_QQuickDropArea::containsDrag_external()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea);
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QMimeData data;
-    QQuickCanvas alternateCanvas;
+    QQuickWindow alternateWindow;
 
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), false);
     QCOMPARE(evaluate<bool>(dropArea, "hasDrag"), false);
 
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<bool>(dropArea, "hasDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(evaluate<int>(dropArea, "exitEvents"), 0);
 
     evaluate<void>(dropArea, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), false);
     QCOMPARE(evaluate<bool>(dropArea, "hasDrag"), false);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 0);
@@ -210,13 +210,13 @@ void tst_QQuickDropArea::containsDrag_external()
 
     evaluate<void>(dropArea, "{ enterEvents = 0; exitEvents = 0 }");
 
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(150, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(150, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), false);
     QCOMPARE(evaluate<bool>(dropArea, "hasDrag"), false);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea, "exitEvents"), 0);
 
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<bool>(dropArea, "hasDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
@@ -224,18 +224,18 @@ void tst_QQuickDropArea::containsDrag_external()
 
     evaluate<void>(dropArea, "{ enterEvents = 0; exitEvents = 0 }");
 
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(150, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(150, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), false);
     QCOMPARE(evaluate<bool>(dropArea, "hasDrag"), false);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea, "exitEvents"), 1);
 
-    QWindowSystemInterface::handleDrop(&canvas, &data, QPoint(150, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrop(&window, &data, QPoint(150, 50), Qt::CopyAction);
 }
 
 void tst_QQuickDropArea::keys_internal()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -255,7 +255,7 @@ void tst_QQuickDropArea::keys_internal()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea);
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QQuickItem *dragItem = dropArea->findChild<QQuickItem *>("dragItem");
     QVERIFY(dragItem);
@@ -342,7 +342,7 @@ void tst_QQuickDropArea::keys_internal()
 
 void tst_QQuickDropArea::keys_external()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -355,95 +355,95 @@ void tst_QQuickDropArea::keys_external()
             "}", QUrl());
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QMimeData data;
-    QQuickCanvas alternateCanvas;
+    QQuickWindow alternateWindow;
 
     data.setData("text/x-red", "red");
     data.setData("text/x-blue", "blue");
 
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), false);
 
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(dropArea->property("dragKeys").toStringList(), QStringList() << "text/x-red" << "text/x-blue");
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     evaluate<void>(dropArea, "keys = \"text/x-blue\"");
     QCOMPARE(dropArea->property("keys").toStringList(), QStringList() << "text/x-blue");
     QCOMPARE(dropArea->property("dropKeys").toStringList(), QStringList() << "text/x-blue");
     evaluate<void>(dropArea, "{ enterEvents = 0; dragKeys = undefined }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(dropArea->property("dragKeys").toStringList(), QStringList() << "text/x-red" << "text/x-blue");
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     evaluate<void>(dropArea, "keys = \"text/x-red\"");
     QCOMPARE(dropArea->property("keys").toStringList(), QStringList() << "text/x-red");
     QCOMPARE(dropArea->property("dropKeys").toStringList(), QStringList() << "text/x-red");
     evaluate<void>(dropArea, "{ enterEvents = 0; dragKeys = undefined }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(dropArea->property("dragKeys").toStringList(), QStringList() << "text/x-red" << "text/x-blue");
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     evaluate<void>(dropArea, "keys = \"text/x-green\"");
     QCOMPARE(dropArea->property("keys").toStringList(), QStringList() << "text/x-green");
     QCOMPARE(dropArea->property("dropKeys").toStringList(), QStringList() << "text/x-green");
     evaluate<void>(dropArea, "{ enterEvents = 0; dragKeys = undefined }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), false);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 0);
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     evaluate<void>(dropArea, "keys = [\"text/x-red\", \"text/x-green\"]");
     QCOMPARE(dropArea->property("keys").toStringList(), QStringList() << "text/x-red" << "text/x-green");
     QCOMPARE(dropArea->property("dropKeys").toStringList(), QStringList() << "text/x-red" << "text/x-green");
     evaluate<void>(dropArea, "{ enterEvents = 0; dragKeys = undefined }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(dropArea->property("dragKeys").toStringList(), QStringList() << "text/x-red" << "text/x-blue");
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     data.removeFormat("text/x-red");
     data.removeFormat("text/x-blue");
     evaluate<void>(dropArea, "{ enterEvents = 0; dragKeys = undefined }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), false);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 0);
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     evaluate<void>(dropArea, "keys = []");
     QCOMPARE(dropArea->property("keys").toStringList(), QStringList());
     QCOMPARE(dropArea->property("dropKeys").toStringList(), QStringList());
     evaluate<void>(dropArea, "{ enterEvents = 0; dragKeys = undefined }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(dropArea->property("dragKeys").toStringList(), QStringList());
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     data.setData("text/x-red", "red");
     data.setData("text/x-blue", "blue");
     QCOMPARE(dropArea->property("keys").toStringList(), QStringList());
     QCOMPARE(dropArea->property("dropKeys").toStringList(), QStringList());
     evaluate<void>(dropArea, "{ enterEvents = 0; dragKeys = undefined }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(dropArea->property("dragKeys").toStringList(), QStringList() << "text/x-red" << "text/x-blue");
 
-    QWindowSystemInterface::handleDrop(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrop(&window, &data, QPoint(50, 50), Qt::CopyAction);
 }
 
 void tst_QQuickDropArea::source_internal()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -462,7 +462,7 @@ void tst_QQuickDropArea::source_internal()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea);
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QQuickItem *dragItem = dropArea->findChild<QQuickItem *>("dragItem");
     QVERIFY(dragItem);
@@ -504,7 +504,7 @@ void tst_QQuickDropArea::source_internal()
 
 void tst_QQuickDropArea::position_internal()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -527,7 +527,7 @@ void tst_QQuickDropArea::position_internal()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea);
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QQuickItem *dragItem = dropArea->findChild<QQuickItem *>("dragItem");
     QVERIFY(dragItem);
@@ -571,7 +571,7 @@ void tst_QQuickDropArea::position_internal()
 
 void tst_QQuickDropArea::position_external()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -589,11 +589,11 @@ void tst_QQuickDropArea::position_external()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea);
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QMimeData data;
 
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 1);
     QCOMPARE(evaluate<int>(dropArea, "moveEvents"), 1);
     QCOMPARE(evaluate<qreal>(dropArea, "drag.x"), qreal(50));
@@ -604,7 +604,7 @@ void tst_QQuickDropArea::position_external()
     QCOMPARE(evaluate<qreal>(dropArea, "eventY"), qreal(50));
 
     evaluate<void>(dropArea, "{ enterEvents = 0; moveEvents = 0; eventX = -1; eventY = -1 }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(40, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(40, 50), Qt::CopyAction);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea, "moveEvents"), 1);
     QCOMPARE(evaluate<qreal>(dropArea, "drag.x"), qreal(40));
@@ -615,7 +615,7 @@ void tst_QQuickDropArea::position_external()
     QCOMPARE(evaluate<qreal>(dropArea, "eventY"), qreal(50));
 
     evaluate<void>(dropArea, "{ enterEvents = 0; moveEvents = 0; eventX = -1; eventY = -1 }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(75, 25), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(75, 25), Qt::CopyAction);
     QCOMPARE(evaluate<int>(dropArea, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea, "moveEvents"), 1);
     QCOMPARE(evaluate<qreal>(dropArea, "drag.x"), qreal(75));
@@ -625,12 +625,12 @@ void tst_QQuickDropArea::position_external()
     QCOMPARE(evaluate<qreal>(dropArea, "eventX"), qreal(75));
     QCOMPARE(evaluate<qreal>(dropArea, "eventY"), qreal(25));
 
-    QWindowSystemInterface::handleDrop(&canvas, &data, QPoint(75, 25), Qt::CopyAction);
+    QWindowSystemInterface::handleDrop(&window, &data, QPoint(75, 25), Qt::CopyAction);
 }
 
 void tst_QQuickDropArea::drop_internal()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -666,7 +666,7 @@ void tst_QQuickDropArea::drop_internal()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea);
-    dropArea->setParentItem(canvas.rootItem());
+    dropArea->setParentItem(window.rootItem());
 
     QQuickItem *dragItem = dropArea->findChild<QQuickItem *>("dragItem");
     QVERIFY(dragItem);
@@ -768,7 +768,7 @@ void tst_QQuickDropArea::drop_internal()
 
 void tst_QQuickDropArea::simultaneousDrags()
 {
-    QQuickCanvas canvas;
+    QQuickWindow window;
     QQmlComponent component(&engine);
     component.setData(
             "import QtQuick 2.0\n"
@@ -805,7 +805,7 @@ void tst_QQuickDropArea::simultaneousDrags()
     QScopedPointer<QObject> object(component.create());
     QQuickItem *dropArea1 = qobject_cast<QQuickItem *>(object.data());
     QVERIFY(dropArea1);
-    dropArea1->setParentItem(canvas.rootItem());
+    dropArea1->setParentItem(window.rootItem());
 
     QQuickItem *dropArea2 = dropArea1->findChild<QQuickItem *>("dropArea2");
     QVERIFY(dropArea2);
@@ -820,7 +820,7 @@ void tst_QQuickDropArea::simultaneousDrags()
     data.setData("text/x-red", "red");
     data.setData("text/x-blue", "blue");
 
-    QQuickCanvas alternateCanvas;
+    QQuickWindow alternateWindow;
 
     // Mixed internal drags.
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
@@ -890,7 +890,7 @@ void tst_QQuickDropArea::simultaneousDrags()
 
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
     evaluate<void>(dropArea2, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -898,7 +898,7 @@ void tst_QQuickDropArea::simultaneousDrags()
     QCOMPARE(evaluate<int>(dropArea2, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea2, "exitEvents"), 0);
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -906,7 +906,7 @@ void tst_QQuickDropArea::simultaneousDrags()
     QCOMPARE(evaluate<int>(dropArea2, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea2, "exitEvents"), 0);
 
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -924,7 +924,7 @@ void tst_QQuickDropArea::simultaneousDrags()
 
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
     evaluate<void>(dropArea2, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), false);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -935,7 +935,7 @@ void tst_QQuickDropArea::simultaneousDrags()
     // external then internal.
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
     evaluate<void>(dropArea2, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 1);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -969,7 +969,7 @@ void tst_QQuickDropArea::simultaneousDrags()
     QCOMPARE(evaluate<int>(dropArea2, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea2, "exitEvents"), 0);
 
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), false);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 1);
@@ -1065,7 +1065,7 @@ void tst_QQuickDropArea::simultaneousDrags()
 
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
     evaluate<void>(dropArea2, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -1075,7 +1075,7 @@ void tst_QQuickDropArea::simultaneousDrags()
 
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
     evaluate<void>(dropArea2, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -1085,7 +1085,7 @@ void tst_QQuickDropArea::simultaneousDrags()
 
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
     evaluate<void>(dropArea2, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&canvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&window, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), true);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -1105,7 +1105,7 @@ void tst_QQuickDropArea::simultaneousDrags()
 
     evaluate<void>(dropArea1, "{ enterEvents = 0; exitEvents = 0 }");
     evaluate<void>(dropArea2, "{ enterEvents = 0; exitEvents = 0 }");
-    QWindowSystemInterface::handleDrag(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrag(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
     QCOMPARE(evaluate<bool>(dropArea1, "containsDrag"), false);
     QCOMPARE(evaluate<int>(dropArea1, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea1, "exitEvents"), 0);
@@ -1113,7 +1113,7 @@ void tst_QQuickDropArea::simultaneousDrags()
     QCOMPARE(evaluate<int>(dropArea2, "enterEvents"), 0);
     QCOMPARE(evaluate<int>(dropArea2, "exitEvents"), 1);
 
-    QWindowSystemInterface::handleDrop(&alternateCanvas, &data, QPoint(50, 50), Qt::CopyAction);
+    QWindowSystemInterface::handleDrop(&alternateWindow, &data, QPoint(50, 50), Qt::CopyAction);
 }
 
 QTEST_MAIN(tst_QQuickDropArea)
diff --git a/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp b/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp
index 90f4b6c..cb8dba3 100644
--- a/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp
+++ b/tests/auto/quick/qquickflickable/tst_qquickflickable.cpp
@@ -206,16 +206,16 @@ void tst_qquickflickable::rebound()
     QSKIP("Producing flicks on Mac CI impossible due to timing problems");
 #endif
 
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("rebound.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("rebound.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
-    QQuickTransition *rebound = canvas->rootObject()->findChild<QQuickTransition*>("rebound");
+    QQuickTransition *rebound = window->rootObject()->findChild<QQuickTransition*>("rebound");
     QVERIFY(rebound);
     QSignalSpy reboundSpy(rebound, SIGNAL(runningChanged()));
 
@@ -225,9 +225,9 @@ void tst_qquickflickable::rebound()
     QSignalSpy hMoveSpy(flickable, SIGNAL(movingHorizontallyChanged()));
 
     // flick and test the transition is run
-    flick(canvas, QPoint(20,20), QPoint(120,120), 200);
+    flick(window, QPoint(20,20), QPoint(120,120), 200);
 
-    QTRY_COMPARE(canvas->rootObject()->property("transitionsStarted").toInt(), 2);
+    QTRY_COMPARE(window->rootObject()->property("transitionsStarted").toInt(), 2);
     QCOMPARE(hMoveSpy.count(), 1);
     QCOMPARE(vMoveSpy.count(), 1);
     QCOMPARE(movementStartedSpy.count(), 1);
@@ -242,7 +242,7 @@ void tst_qquickflickable::rebound()
     QCOMPARE(vMoveSpy.count(), 2);
     QCOMPARE(movementStartedSpy.count(), 1);
     QCOMPARE(movementEndedSpy.count(), 1);
-    QCOMPARE(canvas->rootObject()->property("transitionsStarted").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("transitionsStarted").toInt(), 2);
     QVERIFY(!rebound->running());
     QCOMPARE(reboundSpy.count(), 2);
 
@@ -250,16 +250,16 @@ void tst_qquickflickable::rebound()
     vMoveSpy.clear();
     movementStartedSpy.clear();
     movementEndedSpy.clear();
-    canvas->rootObject()->setProperty("transitionsStarted", 0);
-    canvas->rootObject()->setProperty("transitionsFinished", 0);
+    window->rootObject()->setProperty("transitionsStarted", 0);
+    window->rootObject()->setProperty("transitionsFinished", 0);
 
     // flick and trigger the transition multiple times
     // (moving signals are emitted as soon as the first transition starts)
-    flick(canvas, QPoint(20,20), QPoint(120,120), 200);     // both x and y will bounce back
-    flick(canvas, QPoint(20,120), QPoint(120,20), 200);     // only x will bounce back
+    flick(window, QPoint(20,20), QPoint(120,120), 200);     // both x and y will bounce back
+    flick(window, QPoint(20,120), QPoint(120,20), 200);     // only x will bounce back
 
     QVERIFY(flickable->isMoving());
-    QVERIFY(canvas->rootObject()->property("transitionsStarted").toInt() >= 1);
+    QVERIFY(window->rootObject()->property("transitionsStarted").toInt() >= 1);
     QCOMPARE(hMoveSpy.count(), 1);
     QCOMPARE(vMoveSpy.count(), 1);
     QCOMPARE(movementStartedSpy.count(), 1);
@@ -278,15 +278,15 @@ void tst_qquickflickable::rebound()
     vMoveSpy.clear();
     movementStartedSpy.clear();
     movementEndedSpy.clear();
-    canvas->rootObject()->setProperty("transitionsStarted", 0);
-    canvas->rootObject()->setProperty("transitionsFinished", 0);
+    window->rootObject()->setProperty("transitionsStarted", 0);
+    window->rootObject()->setProperty("transitionsFinished", 0);
 
     // disable and the default transition should run
     // (i.e. moving but transition->running = false)
-    canvas->rootObject()->setProperty("transitionEnabled", false);
+    window->rootObject()->setProperty("transitionEnabled", false);
 
-    flick(canvas, QPoint(20,20), QPoint(120,120), 200);
-    QCOMPARE(canvas->rootObject()->property("transitionsStarted").toInt(), 0);
+    flick(window, QPoint(20,20), QPoint(120,120), 200);
+    QCOMPARE(window->rootObject()->property("transitionsStarted").toInt(), 0);
     QCOMPARE(hMoveSpy.count(), 1);
     QCOMPARE(vMoveSpy.count(), 1);
     QCOMPARE(movementStartedSpy.count(), 1);
@@ -297,9 +297,9 @@ void tst_qquickflickable::rebound()
     QCOMPARE(vMoveSpy.count(), 2);
     QCOMPARE(movementStartedSpy.count(), 1);
     QCOMPARE(movementEndedSpy.count(), 1);
-    QCOMPARE(canvas->rootObject()->property("transitionsStarted").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("transitionsStarted").toInt(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::maximumFlickVelocity()
@@ -356,19 +356,19 @@ void tst_qquickflickable::pressDelay()
 // QTBUG-17361
 void tst_qquickflickable::nestedPressDelay()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("nestedPressDelay.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("nestedPressDelay.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *outer = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *outer = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(outer != 0);
 
-    QQuickFlickable *inner = canvas->rootObject()->findChild<QQuickFlickable*>("innerFlickable");
+    QQuickFlickable *inner = window->rootObject()->findChild<QQuickFlickable*>("innerFlickable");
     QVERIFY(inner != 0);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(150, 150));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(150, 150));
     // the MouseArea is not pressed immediately
     QVERIFY(outer->property("pressed").toBool() == false);
 
@@ -376,9 +376,9 @@ void tst_qquickflickable::nestedPressDelay()
     // QTRY_VERIFY() has 5sec timeout, so will timeout well within 10sec.
     QTRY_VERIFY(outer->property("pressed").toBool() == true);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(150, 150));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(150, 150));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::flickableDirection()
@@ -436,13 +436,13 @@ void tst_qquickflickable::returnToBounds()
 {
     QFETCH(bool, setRebound);
 
-    QQuickView *canvas = new QQuickView;
-    canvas->rootContext()->setContextProperty("setRebound", setRebound);
-    canvas->setSource(testFileUrl("resize.qml"));
-    QVERIFY(canvas->rootObject() != 0);
-    QQuickFlickable *obj = findItem<QQuickFlickable>(canvas->rootObject(), "flick");
+    QQuickView *window = new QQuickView;
+    window->rootContext()->setContextProperty("setRebound", setRebound);
+    window->setSource(testFileUrl("resize.qml"));
+    QVERIFY(window->rootObject() != 0);
+    QQuickFlickable *obj = findItem<QQuickFlickable>(window->rootObject(), "flick");
 
-    QQuickTransition *rebound = canvas->rootObject()->findChild<QQuickTransition*>("rebound");
+    QQuickTransition *rebound = window->rootObject()->findChild<QQuickTransition*>("rebound");
     QVERIFY(rebound);
     QSignalSpy reboundSpy(rebound, SIGNAL(runningChanged()));
 
@@ -457,7 +457,7 @@ void tst_qquickflickable::returnToBounds()
     QTRY_COMPARE(obj->contentX(), 100.);
     QTRY_COMPARE(obj->contentY(), 400.);
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "returnToBounds");
+    QMetaObject::invokeMethod(window->rootObject(), "returnToBounds");
 
     if (setRebound)
         QTRY_VERIFY(rebound->running());
@@ -468,7 +468,7 @@ void tst_qquickflickable::returnToBounds()
     QVERIFY(!rebound->running());
     QCOMPARE(reboundSpy.count(), setRebound ? 2 : 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::returnToBounds_data()
@@ -481,20 +481,20 @@ void tst_qquickflickable::returnToBounds_data()
 
 void tst_qquickflickable::wheel()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("wheel.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("wheel.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flick = canvas->rootObject()->findChild<QQuickFlickable*>("flick");
+    QQuickFlickable *flick = window->rootObject()->findChild<QQuickFlickable*>("flick");
     QVERIFY(flick != 0);
 
     {
         QPoint pos(200, 200);
-        QWheelEvent event(pos, canvas->mapToGlobal(pos), QPoint(), QPoint(0,-120), -120, Qt::Vertical, Qt::NoButton, Qt::NoModifier);
+        QWheelEvent event(pos, window->mapToGlobal(pos), QPoint(), QPoint(0,-120), -120, Qt::Vertical, Qt::NoButton, Qt::NoModifier);
         event.setAccepted(false);
-        QGuiApplication::sendEvent(canvas, &event);
+        QGuiApplication::sendEvent(window, &event);
     }
 
     QTRY_VERIFY(flick->contentY() > 0);
@@ -505,16 +505,16 @@ void tst_qquickflickable::wheel()
 
     {
         QPoint pos(200, 200);
-        QWheelEvent event(pos, canvas->mapToGlobal(pos), QPoint(), QPoint(-120,0), -120, Qt::Horizontal, Qt::NoButton, Qt::NoModifier);
+        QWheelEvent event(pos, window->mapToGlobal(pos), QPoint(), QPoint(-120,0), -120, Qt::Horizontal, Qt::NoButton, Qt::NoModifier);
 
         event.setAccepted(false);
-        QGuiApplication::sendEvent(canvas, &event);
+        QGuiApplication::sendEvent(window, &event);
     }
 
     QTRY_VERIFY(flick->contentX() > 0);
     QVERIFY(flick->contentY() == 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::movingAndFlicking_data()
@@ -553,14 +553,14 @@ void tst_qquickflickable::movingAndFlicking()
 
     const QPoint flickFrom(50, 200);   // centre
 
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("flickable03.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowActive(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("flickable03.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowActive(window);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
     QSignalSpy vMoveSpy(flickable, SIGNAL(movingVerticallyChanged()));
@@ -576,7 +576,7 @@ void tst_qquickflickable::movingAndFlicking()
     QSignalSpy flickEndSpy(flickable, SIGNAL(flickEnded()));
 
     // do a flick that keeps the view within the bounds
-    flick(canvas, flickFrom, flickToWithoutSnapBack, 200);
+    flick(window, flickFrom, flickToWithoutSnapBack, 200);
 
     QVERIFY(flickable->isMoving());
     QCOMPARE(flickable->isMovingHorizontally(), horizontalEnabled);
@@ -632,7 +632,7 @@ void tst_qquickflickable::movingAndFlicking()
     flickable->setContentX(0);
     flickable->setContentY(0);
     QTRY_VERIFY(!flickable->isMoving());
-    flick(canvas, flickFrom, flickToWithSnapBack, 200);
+    flick(window, flickFrom, flickToWithSnapBack, 200);
 
     QVERIFY(flickable->isMoving());
     QCOMPARE(flickable->isMovingHorizontally(), horizontalEnabled);
@@ -677,7 +677,7 @@ void tst_qquickflickable::movingAndFlicking()
     QCOMPARE(flickable->contentX(), 0.0);
     QCOMPARE(flickable->contentY(), 0.0);
 
-    delete canvas;
+    delete window;
 }
 
 
@@ -713,14 +713,14 @@ void tst_qquickflickable::movingAndDragging()
 
     const QPoint moveFrom(50, 200);   // centre
 
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("flickable03.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("flickable03.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
     QSignalSpy vDragSpy(flickable, SIGNAL(draggingVerticallyChanged()));
@@ -736,10 +736,10 @@ void tst_qquickflickable::movingAndDragging()
     QSignalSpy moveEndSpy(flickable, SIGNAL(movementEnded()));
 
     // start the drag
-    QTest::mousePress(canvas, Qt::LeftButton, 0, moveFrom);
-    QTest::mouseMove(canvas, moveFrom + moveByWithoutSnapBack);
-    QTest::mouseMove(canvas, moveFrom + moveByWithoutSnapBack*2);
-    QTest::mouseMove(canvas, moveFrom + moveByWithoutSnapBack*3);
+    QTest::mousePress(window, Qt::LeftButton, 0, moveFrom);
+    QTest::mouseMove(window, moveFrom + moveByWithoutSnapBack);
+    QTest::mouseMove(window, moveFrom + moveByWithoutSnapBack*2);
+    QTest::mouseMove(window, moveFrom + moveByWithoutSnapBack*3);
 
     QVERIFY(flickable->isMoving());
     QCOMPARE(flickable->isMovingHorizontally(), horizontalEnabled);
@@ -758,7 +758,7 @@ void tst_qquickflickable::movingAndDragging()
     QCOMPARE(moveStartSpy.count(), 1);
     QCOMPARE(dragStartSpy.count(), 1);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, moveFrom + moveByWithoutSnapBack*3);
+    QTest::mouseRelease(window, Qt::LeftButton, 0, moveFrom + moveByWithoutSnapBack*3);
 
     QVERIFY(!flickable->isDragging());
     QVERIFY(!flickable->isDraggingHorizontally());
@@ -807,10 +807,10 @@ void tst_qquickflickable::movingAndDragging()
      flickable->setContentX(0);
      flickable->setContentY(0);
      QTRY_VERIFY(!flickable->isMoving());
-     QTest::mousePress(canvas, Qt::LeftButton, 0, moveFrom);
-     QTest::mouseMove(canvas, moveFrom + moveByWithSnapBack);
-     QTest::mouseMove(canvas, moveFrom + moveByWithSnapBack*2);
-     QTest::mouseMove(canvas, moveFrom + moveByWithSnapBack*3);
+     QTest::mousePress(window, Qt::LeftButton, 0, moveFrom);
+     QTest::mouseMove(window, moveFrom + moveByWithSnapBack);
+     QTest::mouseMove(window, moveFrom + moveByWithSnapBack*2);
+     QTest::mouseMove(window, moveFrom + moveByWithSnapBack*3);
 
      QVERIFY(flickable->isMoving());
      QCOMPARE(flickable->isMovingHorizontally(), horizontalEnabled);
@@ -831,7 +831,7 @@ void tst_qquickflickable::movingAndDragging()
      QCOMPARE(dragStartSpy.count(), 1);
      QCOMPARE(dragEndSpy.count(), 0);
 
-     QTest::mouseRelease(canvas, Qt::LeftButton, 0, moveFrom + moveByWithSnapBack*3);
+     QTest::mouseRelease(window, Qt::LeftButton, 0, moveFrom + moveByWithSnapBack*3);
 
      // should now start snapping back to bounds (moving but not dragging)
      QVERIFY(flickable->isMoving());
@@ -875,7 +875,7 @@ void tst_qquickflickable::movingAndDragging()
      QCOMPARE(flickable->contentX(), 0.0);
      QCOMPARE(flickable->contentY(), 0.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::flickOnRelease()
@@ -883,14 +883,14 @@ void tst_qquickflickable::flickOnRelease()
 #ifdef Q_OS_MAC
     QSKIP("Producing flicks on Mac CI impossible due to timing problems");
 #endif
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("flickable03.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
-
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("flickable03.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->rootObject() != 0);
+
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
     // Vertical with a quick press-move-release: should cause a flick in release.
@@ -900,9 +900,9 @@ void tst_qquickflickable::flickOnRelease()
     // underlying drivers will hopefully provide a pre-calculated velocity
     // (based on more data than what the UI gets), thus making this use case
     // working even with small movements.
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50, 300));
-    QTest::mouseMove(canvas, QPoint(50, 10), 10);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 10), 10);
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50, 300));
+    QTest::mouseMove(window, QPoint(50, 10), 10);
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50, 10), 10);
 
     QCOMPARE(vFlickSpy.count(), 1);
 
@@ -912,7 +912,7 @@ void tst_qquickflickable::flickOnRelease()
     // Stop on a full pixel after user interaction
     QCOMPARE(flickable->contentY(), (qreal)qRound(flickable->contentY()));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::pressWhileFlicking()
@@ -921,14 +921,14 @@ void tst_qquickflickable::pressWhileFlicking()
     QSKIP("Producing flicks on Mac CI impossible due to timing problems");
 #endif
 
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("flickable03.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("flickable03.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
     QSignalSpy vMoveSpy(flickable, SIGNAL(movingVerticallyChanged()));
@@ -940,7 +940,7 @@ void tst_qquickflickable::pressWhileFlicking()
 
     // flick then press while it is still moving
     // flicking == false, moving == true;
-    flick(canvas, QPoint(20,190), QPoint(20, 50), 200);
+    flick(window, QPoint(20,190), QPoint(20, 50), 200);
     QVERIFY(flickable->verticalVelocity() > 0.0);
     QVERIFY(flickable->isFlicking());
     QVERIFY(flickable->isFlickingVertically());
@@ -955,13 +955,13 @@ void tst_qquickflickable::pressWhileFlicking()
     QCOMPARE(hFlickSpy.count(), 0);
     QCOMPARE(flickSpy.count(), 1);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(20, 50));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(20, 50));
     QTRY_VERIFY(!flickable->isFlicking());
     QVERIFY(!flickable->isFlickingVertically());
     QVERIFY(flickable->isMoving());
     QVERIFY(flickable->isMovingVertically());
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(20,50));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(20,50));
     QVERIFY(!flickable->isFlicking());
     QVERIFY(!flickable->isFlickingVertically());
     QTRY_VERIFY(!flickable->isMoving());
@@ -969,35 +969,35 @@ void tst_qquickflickable::pressWhileFlicking()
     // Stop on a full pixel after user interaction
     QCOMPARE(flickable->contentX(), (qreal)qRound(flickable->contentX()));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::disabled()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("disabled.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("disabled.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flick = canvas->rootObject()->findChild<QQuickFlickable*>("flickable");
+    QQuickFlickable *flick = window->rootObject()->findChild<QQuickFlickable*>("flickable");
     QVERIFY(flick != 0);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50, 90));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50, 90));
 
-    QTest::mouseMove(canvas, QPoint(50, 80));
-    QTest::mouseMove(canvas, QPoint(50, 70));
-    QTest::mouseMove(canvas, QPoint(50, 60));
+    QTest::mouseMove(window, QPoint(50, 80));
+    QTest::mouseMove(window, QPoint(50, 70));
+    QTest::mouseMove(window, QPoint(50, 60));
 
     QVERIFY(flick->isMoving() == false);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 60));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50, 60));
 
     // verify that mouse clicks on other elements still work (QTBUG-20584)
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50, 10));
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 10));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50, 10));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50, 10));
 
-    QTRY_VERIFY(canvas->rootObject()->property("clicked").toBool() == true);
+    QTRY_VERIFY(window->rootObject()->property("clicked").toBool() == true);
 }
 
 void tst_qquickflickable::flickVelocity()
@@ -1006,22 +1006,22 @@ void tst_qquickflickable::flickVelocity()
     QSKIP("Producing flicks on Mac CI impossible due to timing problems");
 #endif
 
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("flickable03.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("flickable03.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
     // flick up
-    flick(canvas, QPoint(20,190), QPoint(20, 50), 200);
+    flick(window, QPoint(20,190), QPoint(20, 50), 200);
     QVERIFY(flickable->verticalVelocity() > 0.0);
     QTRY_VERIFY(flickable->verticalVelocity() == 0.0);
 
     // flick down
-    flick(canvas, QPoint(20,10), QPoint(20, 140), 200);
+    flick(window, QPoint(20,10), QPoint(20, 140), 200);
     QVERIFY(flickable->verticalVelocity() < 0.0);
     QTRY_VERIFY(flickable->verticalVelocity() == 0.0);
 
@@ -1029,17 +1029,17 @@ void tst_qquickflickable::flickVelocity()
     QQuickFlickablePrivate *fp = QQuickFlickablePrivate::get(flickable);
     bool boosted = false;
     for (int i = 0; i < 6; ++i) {
-        flick(canvas, QPoint(20,390), QPoint(20, 50), 100);
+        flick(window, QPoint(20,390), QPoint(20, 50), 100);
         boosted |= fp->flickBoost > 1.0;
     }
     QVERIFY(boosted);
 
     // Flick in opposite direction -> boost cancelled.
-    flick(canvas, QPoint(20,10), QPoint(20, 340), 200);
+    flick(window, QPoint(20,10), QPoint(20, 340), 200);
     QTRY_VERIFY(flickable->verticalVelocity() < 0.0);
     QVERIFY(fp->flickBoost == 1.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickflickable::margins()
@@ -1103,20 +1103,20 @@ void tst_qquickflickable::margins()
 
 void tst_qquickflickable::cancelOnMouseGrab()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("cancel.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("cancel.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(10, 10));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(10, 10));
     // drag out of bounds
-    QTest::mouseMove(canvas, QPoint(50, 50));
-    QTest::mouseMove(canvas, QPoint(100, 100));
-    QTest::mouseMove(canvas, QPoint(150, 150));
+    QTest::mouseMove(window, QPoint(50, 50));
+    QTest::mouseMove(window, QPoint(100, 100));
+    QTest::mouseMove(window, QPoint(150, 150));
 
     QVERIFY(flickable->contentX() != 0);
     QVERIFY(flickable->contentY() != 0);
@@ -1124,7 +1124,7 @@ void tst_qquickflickable::cancelOnMouseGrab()
     QVERIFY(flickable->isDragging());
 
     // grabbing mouse will cancel flickable interaction.
-    QQuickItem *item = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *item = window->rootObject()->findChild<QQuickItem*>("row");
     item->grabMouse();
 
     QTRY_COMPARE(flickable->contentX(), 0.);
@@ -1132,54 +1132,54 @@ void tst_qquickflickable::cancelOnMouseGrab()
     QTRY_VERIFY(!flickable->isMoving());
     QTRY_VERIFY(!flickable->isDragging());
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 10));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50, 10));
 }
 
 void tst_qquickflickable::clickAndDragWhenTransformed()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("transformedFlickable.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
-
-    QQuickFlickable *flickable = canvas->rootObject()->findChild<QQuickFlickable*>("flickable");
+    QQuickView *view = new QQuickView;
+    view->setSource(testFileUrl("transformedFlickable.qml"));
+    view->show();
+    view->requestActivateWindow();
+    QTest::qWaitForWindowShown(view);
+    QVERIFY(view->rootObject() != 0);
+
+    QQuickFlickable *flickable = view->rootObject()->findChild<QQuickFlickable*>("flickable");
     QVERIFY(flickable != 0);
 
     // click outside child rect
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(190, 190));
+    QTest::mousePress(view, Qt::LeftButton, 0, QPoint(190, 190));
     QTest::qWait(10);
     QCOMPARE(flickable->property("itemPressed").toBool(), false);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(190, 190));
+    QTest::mouseRelease(view, Qt::LeftButton, 0, QPoint(190, 190));
 
     // click inside child rect
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(200, 200));
+    QTest::mousePress(view, Qt::LeftButton, 0, QPoint(200, 200));
     QTest::qWait(10);
     QCOMPARE(flickable->property("itemPressed").toBool(), true);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(200, 200));
+    QTest::mouseRelease(view, Qt::LeftButton, 0, QPoint(200, 200));
 
     const int threshold = qApp->styleHints()->startDragDistance();
 
     // drag outside bounds
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(160, 160));
+    QTest::mousePress(view, Qt::LeftButton, 0, QPoint(160, 160));
     QTest::qWait(10);
-    QTest::mouseMove(canvas, QPoint(160 + threshold * 2, 160));
-    QTest::mouseMove(canvas, QPoint(160 + threshold * 3, 160));
+    QTest::mouseMove(view, QPoint(160 + threshold * 2, 160));
+    QTest::mouseMove(view, QPoint(160 + threshold * 3, 160));
     QCOMPARE(flickable->isDragging(), false);
     QCOMPARE(flickable->property("itemPressed").toBool(), false);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(180, 160));
+    QTest::mouseRelease(view, Qt::LeftButton, 0, QPoint(180, 160));
 
     // drag inside bounds
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(200, 140));
+    QTest::mousePress(view, Qt::LeftButton, 0, QPoint(200, 140));
     QTest::qWait(10);
-    QTest::mouseMove(canvas, QPoint(200 + threshold * 2, 140));
-    QTest::mouseMove(canvas, QPoint(200 + threshold * 3, 140));
+    QTest::mouseMove(view, QPoint(200 + threshold * 2, 140));
+    QTest::mouseMove(view, QPoint(200 + threshold * 3, 140));
     QCOMPARE(flickable->isDragging(), true);
     QCOMPARE(flickable->property("itemPressed").toBool(), false);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(220, 140));
+    QTest::mouseRelease(view, Qt::LeftButton, 0, QPoint(220, 140));
 
-    delete canvas;
+    delete view;
 }
 
 QTEST_MAIN(tst_qquickflickable)
diff --git a/tests/auto/quick/qquickflipable/tst_qquickflipable.cpp b/tests/auto/quick/qquickflipable/tst_qquickflipable.cpp
index 8c1c248..37e29f6 100644
--- a/tests/auto/quick/qquickflipable/tst_qquickflipable.cpp
+++ b/tests/auto/quick/qquickflipable/tst_qquickflipable.cpp
@@ -126,22 +126,22 @@ void tst_qquickflipable::flipFlipable()
 
 void tst_qquickflipable::QTBUG_9161_crash()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("crash.qml"));
-    QQuickItem *root = canvas->rootObject();
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("crash.qml"));
+    QQuickItem *root = window->rootObject();
     QVERIFY(root != 0);
-    canvas->show();
-    delete canvas;
+    window->show();
+    delete window;
 }
 
 void tst_qquickflipable::QTBUG_8474_qgv_abort()
 {
-    QQuickView *canvas = new QQuickView;
-    canvas->setSource(testFileUrl("flipable-abort.qml"));
-    QQuickItem *root = canvas->rootObject();
+    QQuickView *window = new QQuickView;
+    window->setSource(testFileUrl("flipable-abort.qml"));
+    QQuickItem *root = window->rootObject();
     QVERIFY(root != 0);
-    canvas->show();
-    delete canvas;
+    window->show();
+    delete window;
 }
 
 QTEST_MAIN(tst_qquickflipable)
diff --git a/tests/auto/quick/qquickfocusscope/tst_qquickfocusscope.cpp b/tests/auto/quick/qquickfocusscope/tst_qquickfocusscope.cpp
index 7d14485..34e5ce0 100644
--- a/tests/auto/quick/qquickfocusscope/tst_qquickfocusscope.cpp
+++ b/tests/auto/quick/qquickfocusscope/tst_qquickfocusscope.cpp
@@ -543,7 +543,7 @@ void tst_qquickfocusscope::canvasFocus()
     QTest::qWaitForWindowShown(view);
     QTRY_VERIFY(view == qGuiApp->focusWindow());
 
-    // Now the canvas has focus, active focus given to item1
+    // Now the window has focus, active focus given to item1
     QCOMPARE(rootItem->hasFocus(), true);
     QCOMPARE(rootItem->hasActiveFocus(), true);
     QCOMPARE(scope1->hasFocus(), true);
@@ -584,7 +584,7 @@ void tst_qquickfocusscope::canvasFocus()
     QCOMPARE(item1ActiveFocusSpy.count(), 2);
 
 
-    // canvas does not have focus, so item2 will not get active focus
+    // window does not have focus, so item2 will not get active focus
     item2->forceActiveFocus();
 
     QCOMPARE(rootItem->hasFocus(), false);
@@ -609,7 +609,7 @@ void tst_qquickfocusscope::canvasFocus()
     QCOMPARE(item2FocusSpy.count(), 1);
     QCOMPARE(item2ActiveFocusSpy.count(), 0);
 
-    // give the canvas focus, and item2 will get active focus
+    // give the window focus, and item2 will get active focus
     view->show();
     view->requestActivateWindow();
     QTest::qWaitForWindowShown(view);
diff --git a/tests/auto/quick/qquickfontloader/tst_qquickfontloader.cpp b/tests/auto/quick/qquickfontloader/tst_qquickfontloader.cpp
index cab8a22..c6eaf05 100644
--- a/tests/auto/quick/qquickfontloader/tst_qquickfontloader.cpp
+++ b/tests/auto/quick/qquickfontloader/tst_qquickfontloader.cpp
@@ -248,19 +248,19 @@ void tst_qquickfontloader::changeFontSourceViaState()
 #if defined(Q_OS_WIN)
     QSKIP("Windows doesn't support font loading.");
 #endif
-    QQuickView canvas(testFileUrl("qtbug-20268.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowShown(&canvas);
-    QTRY_COMPARE(&canvas, qGuiApp->focusWindow());
+    QQuickView window(testFileUrl("qtbug-20268.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowShown(&window);
+    QTRY_COMPARE(&window, qGuiApp->focusWindow());
 
-    QQuickFontLoader *fontObject = qobject_cast<QQuickFontLoader*>(qvariant_cast<QObject *>(canvas.rootObject()->property("fontloader")));
+    QQuickFontLoader *fontObject = qobject_cast<QQuickFontLoader*>(qvariant_cast<QObject *>(window.rootObject()->property("fontloader")));
     QVERIFY(fontObject != 0);
     QTRY_VERIFY(fontObject->status() == QQuickFontLoader::Ready);
     QVERIFY(fontObject->source() != QUrl(""));
     QTRY_COMPARE(fontObject->name(), QString("OCRA"));
 
-    canvas.rootObject()->setProperty("usename", true);
+    window.rootObject()->setProperty("usename", true);
 
     // This warning should probably not be printed once QTBUG-20268 is fixed
     QString warning = QString(testFileUrl("qtbug-20268.qml").toString()) +
@@ -269,7 +269,7 @@ void tst_qquickfontloader::changeFontSourceViaState()
 
     QEXPECT_FAIL("", "QTBUG-20268", Abort);
     QTRY_VERIFY(fontObject->status() == QQuickFontLoader::Ready);
-    QCOMPARE(canvas.rootObject()->property("name").toString(), QString("Tahoma"));
+    QCOMPARE(window.rootObject()->property("name").toString(), QString("Tahoma"));
 }
 
 QTEST_MAIN(tst_qquickfontloader)
diff --git a/tests/auto/quick/qquickgridview/tst_qquickgridview.cpp b/tests/auto/quick/qquickgridview/tst_qquickgridview.cpp
index 51c7a0b..bb10d53 100644
--- a/tests/auto/quick/qquickgridview/tst_qquickgridview.cpp
+++ b/tests/auto/quick/qquickgridview/tst_qquickgridview.cpp
@@ -332,7 +332,7 @@ void tst_QQuickGridView::cleanupTestCase()
 
 void tst_QQuickGridView::items()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     model.addItem("Fred", "12345");
@@ -343,20 +343,20 @@ void tst_QQuickGridView::items()
     model.addItem("Ben", "04321");
     model.addItem("Jim", "0780");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("gridview1.qml"));
+    window->setSource(testFileUrl("gridview1.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
 
     QTRY_COMPARE(gridview->count(), model.count());
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
     QTRY_COMPARE(contentItem->childItems().count(), model.count()+1); // assumes all are visible, +1 for the (default) highlight item
 
     for (int i = 0; i < model.count(); ++i) {
@@ -375,12 +375,12 @@ void tst_QQuickGridView::items()
     int itemCount = findItems<QQuickItem>(contentItem, "wrapper").count();
     QTRY_VERIFY(itemCount == 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::changed()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     model.addItem("Fred", "12345");
@@ -391,13 +391,13 @@ void tst_QQuickGridView::changed()
     model.addItem("Ben", "04321");
     model.addItem("Jim", "0780");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("gridview1.qml"));
+    window->setSource(testFileUrl("gridview1.qml"));
     qApp->processEvents();
 
-    QQuickFlickable *gridview = findItem<QQuickFlickable>(canvas->rootObject(), "grid");
+    QQuickFlickable *gridview = findItem<QQuickFlickable>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -411,24 +411,24 @@ void tst_QQuickGridView::changed()
     QTRY_VERIFY(number != 0);
     QTRY_COMPARE(number->text(), model.number(1));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::inserted_basic()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     model.addItem("Fred", "12345");
     model.addItem("John", "2345");
     model.addItem("Bob", "54321");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -436,7 +436,7 @@ void tst_QQuickGridView::inserted_basic()
 
     model.insertItem(1, "Will", "9876");
 
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
     QTRY_COMPARE(contentItem->childItems().count(), model.count()+1); // assumes all are visible, +1 for the (default) highlight item
 
     QQuickText *name = findItem<QQuickText>(contentItem, "textName", 1);
@@ -447,7 +447,7 @@ void tst_QQuickGridView::inserted_basic()
     QTRY_COMPARE(number->text(), model.number(1));
 
     // Checks that onAdd is called
-    int added = canvas->rootObject()->property("added").toInt();
+    int added = window->rootObject()->property("added").toInt();
     QTRY_COMPARE(added, 1);
 
     // Confirm items positioned correctly
@@ -487,7 +487,7 @@ void tst_QQuickGridView::inserted_basic()
 
     QTRY_VERIFY(gridview->contentY() == 120);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::inserted_defaultLayout(QQuickGridView::Flow flow,
@@ -505,17 +505,17 @@ void tst_QQuickGridView::inserted_defaultLayout(QQuickGridView::Flow flow,
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testTopToBottom", flow == QQuickGridView::FlowTopToBottom);
     ctxt->setContextProperty("testRightToLeft", horizLayout == Qt::RightToLeft);
     ctxt->setContextProperty("testBottomToTop", verticalLayout == QQuickGridView::BottomToTop);
-    canvas->setSource(testFileUrl("layouts.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("layouts.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -564,7 +564,7 @@ void tst_QQuickGridView::inserted_defaultLayout(QQuickGridView::Flow flow,
         QCOMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::inserted_defaultLayout_data()
@@ -692,19 +692,19 @@ void tst_QQuickGridView::insertBeforeVisible()
     QFETCH(int, cacheBuffer);
 
     QQuickText *name;
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("gridview1.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -748,7 +748,7 @@ void tst_QQuickGridView::insertBeforeVisible()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::insertBeforeVisible_data()
@@ -776,25 +776,25 @@ void tst_QQuickGridView::insertBeforeVisible_data()
 
 void tst_QQuickGridView::removed_basic()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
 
     model.removeItem(1);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     QQuickText *name = findItem<QQuickText>(contentItem, "textName", 1);
     QTRY_VERIFY(name != 0);
@@ -805,7 +805,7 @@ void tst_QQuickGridView::removed_basic()
 
 
     // Checks that onRemove is called
-    QString removed = canvas->rootObject()->property("removed").toString();
+    QString removed = window->rootObject()->property("removed").toString();
     QTRY_COMPARE(removed, QString("Item1"));
 
     // Confirm items positioned correctly
@@ -819,7 +819,7 @@ void tst_QQuickGridView::removed_basic()
 
     // Remove first item (which is the current item);
     model.removeItem(0);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     name = findItem<QQuickText>(contentItem, "textName", 0);
     QTRY_VERIFY(name != 0);
@@ -840,7 +840,7 @@ void tst_QQuickGridView::removed_basic()
 
     // Remove items not visible
     model.removeItem(25);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     // Confirm items positioned correctly
     itemCount = findItems<QQuickItem>(contentItem, "wrapper").count();
@@ -859,7 +859,7 @@ void tst_QQuickGridView::removed_basic()
     QTRY_COMPARE(gridview->contentY(), 120.0);
 
     model.removeItem(1);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     // Confirm items positioned correctly
     for (int i = 6; i < 18; ++i) {
@@ -872,7 +872,7 @@ void tst_QQuickGridView::removed_basic()
     // Remove currentIndex
     QQuickItem *oldCurrent = gridview->currentItem();
     model.removeItem(9);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     QTRY_COMPARE(gridview->currentIndex(), 9);
     QTRY_VERIFY(gridview->currentItem() != oldCurrent);
@@ -912,7 +912,7 @@ void tst_QQuickGridView::removed_basic()
     QTRY_COMPARE(gridview->currentIndex(), 7);
     QTRY_VERIFY(gridview->currentItem() == oldCurrent);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::removed_defaultLayout(QQuickGridView::Flow flow,
@@ -928,22 +928,22 @@ void tst_QQuickGridView::removed_defaultLayout(QQuickGridView::Flow flow,
     QFETCH(QString, firstVisible);
     QFETCH(QString, firstVisible_ttb);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testTopToBottom", flow == QQuickGridView::FlowTopToBottom);
     ctxt->setContextProperty("testRightToLeft", horizLayout == Qt::RightToLeft);
     ctxt->setContextProperty("testBottomToTop", verticalLayout == QQuickGridView::BottomToTop);
-    canvas->setSource(testFileUrl("layouts.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("layouts.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -988,7 +988,7 @@ void tst_QQuickGridView::removed_defaultLayout(QQuickGridView::Flow flow,
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::removed_defaultLayout_data()
@@ -1149,17 +1149,17 @@ void tst_QQuickGridView::addOrRemoveBeforeVisible()
     QFETCH(bool, doAdd);
     QFETCH(qreal, newTopContentY);
 
-    QQuickView *canvas = getView();
-    canvas->show();
+    QQuickView *window = getView();
+    window->show();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -1212,7 +1212,7 @@ void tst_QQuickGridView::addOrRemoveBeforeVisible()
         QTRY_VERIFY(item->y() == (i/3)*60 + newTopContentY);
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::addOrRemoveBeforeVisible_data()
@@ -1226,18 +1226,18 @@ void tst_QQuickGridView::addOrRemoveBeforeVisible_data()
 
 void tst_QQuickGridView::clear()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
-    canvas->show();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QVERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
@@ -1257,7 +1257,7 @@ void tst_QQuickGridView::clear()
     QVERIFY(gridview->currentItem() != 0);
     QVERIFY(gridview->currentIndex() == 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::moved_defaultLayout(QQuickGridView::Flow flow,
@@ -1273,22 +1273,22 @@ void tst_QQuickGridView::moved_defaultLayout(QQuickGridView::Flow flow,
     QFETCH(int, count_ttb);
     QFETCH(qreal, rowOffsetAfterMove);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testTopToBottom", flow == QQuickGridView::FlowTopToBottom);
     ctxt->setContextProperty("testRightToLeft", horizLayout == Qt::RightToLeft);
     ctxt->setContextProperty("testBottomToTop", verticalLayout == QQuickGridView::BottomToTop);
-    canvas->setSource(testFileUrl("layouts.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("layouts.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -1338,7 +1338,7 @@ void tst_QQuickGridView::moved_defaultLayout(QQuickGridView::Flow flow,
             QTRY_COMPARE(gridview->currentIndex(), i);
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::moved_defaultLayout_data()
@@ -1532,18 +1532,18 @@ void tst_QQuickGridView::multipleChanges(bool condensed)
     QFETCH(int, newCount);
     QFETCH(int, newCurrentIndex);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QaimModel model;
     for (int i = 0; i < startCount; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
-    canvas->show();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
 
@@ -1598,7 +1598,7 @@ void tst_QQuickGridView::multipleChanges(bool condensed)
         QTRY_COMPARE(number->text(), model.number(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::multipleChanges_data()
@@ -1777,18 +1777,18 @@ void tst_QQuickGridView::multipleChanges_data()
 void tst_QQuickGridView::swapWithFirstItem()
 {
     // QTBUG_9697
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
-    canvas->show();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     // ensure content position is stable
@@ -1796,7 +1796,7 @@ void tst_QQuickGridView::swapWithFirstItem()
     model.moveItem(10, 0);
     QTRY_VERIFY(gridview->contentY() == 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::currentIndex()
@@ -1805,19 +1805,19 @@ void tst_QQuickGridView::currentIndex()
     for (int i = 0; i < 60; i++)
         model.addItem("Item" + QString::number(i), QString::number(i));
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
+    window->show();
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     QString filename(testFile("gridview-initCurrent.qml"));
-    canvas->setSource(QUrl::fromLocalFile(filename));
+    window->setSource(QUrl::fromLocalFile(filename));
 
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QVERIFY(gridview != 0);
     QTRY_VERIFY(!QQuickItemPrivate::get(gridview)->polishScheduled);
 
@@ -1836,22 +1836,22 @@ void tst_QQuickGridView::currentIndex()
     QTRY_VERIFY(gridview->verticalVelocity() != 0.0);
 
     // footer should become visible if it is out of view, and then current index moves to the first row
-    canvas->rootObject()->setProperty("showFooter", true);
+    window->rootObject()->setProperty("showFooter", true);
     QTRY_VERIFY(gridview->footerItem());
     gridview->setCurrentIndex(model.count()-3);
     QTRY_VERIFY(gridview->footerItem()->y() > gridview->contentY() + gridview->height());
     gridview->setCurrentIndex(model.count()-2);
     QTRY_COMPARE(gridview->contentY() + gridview->height(), (60.0 * model.count()/3) + gridview->footerItem()->height());
-    canvas->rootObject()->setProperty("showFooter", false);
+    window->rootObject()->setProperty("showFooter", false);
 
     // header should become visible if it is out of view, and then current index moves to the last row
-    canvas->rootObject()->setProperty("showHeader", true);
+    window->rootObject()->setProperty("showHeader", true);
     QTRY_VERIFY(gridview->headerItem());
     gridview->setCurrentIndex(3);
     QTRY_VERIFY(gridview->headerItem()->y() + gridview->headerItem()->height() < gridview->contentY());
     gridview->setCurrentIndex(1);
     QTRY_COMPARE(gridview->contentY(), -gridview->headerItem()->height());
-    canvas->rootObject()->setProperty("showHeader", false);
+    window->rootObject()->setProperty("showHeader", false);
 
     // turn off auto highlight
     gridview->setHighlightFollowsCurrentItem(false);
@@ -1867,7 +1867,7 @@ void tst_QQuickGridView::currentIndex()
     // insert item before currentIndex
     gridview->setCurrentIndex(28);
     model.insertItem(0, "Foo", "1111");
-    QTRY_COMPARE(canvas->rootObject()->property("current").toInt(), 29);
+    QTRY_COMPARE(window->rootObject()->property("current").toInt(), 29);
 
     // check removing highlight by setting currentIndex to -1;
     gridview->setCurrentIndex(-1);
@@ -1882,7 +1882,7 @@ void tst_QQuickGridView::currentIndex()
     gridview->setContentY(200);
     QTRY_VERIFY(!delegateVisible(gridview->currentItem()));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::noCurrentIndex()
@@ -1891,18 +1891,18 @@ void tst_QQuickGridView::noCurrentIndex()
     for (int i = 0; i < 60; i++)
         model.addItem("Item" + QString::number(i), QString::number(i));
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     QString filename(testFile("gridview-noCurrent.qml"));
-    canvas->setSource(QUrl::fromLocalFile(filename));
-    canvas->show();
+    window->setSource(QUrl::fromLocalFile(filename));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QVERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
@@ -1919,7 +1919,7 @@ void tst_QQuickGridView::noCurrentIndex()
     QVERIFY(gridview->currentItem());
     QVERIFY(gridview->highlightItem());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::keyNavigation()
@@ -1940,28 +1940,28 @@ void tst_QQuickGridView::keyNavigation()
     for (int i = 0; i < 18; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
-    canvas->show();
-    QTest::qWaitForWindowActive(canvas);
+    QQuickView *window = getView();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
+    window->show();
+    QTest::qWaitForWindowActive(window);
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     gridview->setFlow(flow);
     gridview->setLayoutDirection(layoutDirection);
     gridview->setVerticalLayoutDirection(verticalLayoutDirection);
     QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
 
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowActive(canvas);
-    QTRY_VERIFY(qGuiApp->focusWindow() == canvas);
+    window->requestActivateWindow();
+    QTest::qWaitForWindowActive(window);
+    QTRY_VERIFY(qGuiApp->focusWindow() == window);
     QCOMPARE(gridview->currentIndex(), 0);
 
-    QTest::keyClick(canvas, forwardsKey);
+    QTest::keyClick(window, forwardsKey);
     QCOMPARE(gridview->currentIndex(), 1);
 
-    QTest::keyClick(canvas, backwardsKey);
+    QTest::keyClick(window, backwardsKey);
     QCOMPARE(gridview->currentIndex(), 0);
 
     gridview->setCurrentIndex(7);
@@ -1981,87 +1981,87 @@ void tst_QQuickGridView::keyNavigation()
     QCOMPARE(gridview->currentIndex(), indexDownFrom7);
 
     gridview->setCurrentIndex(7);
-    QTest::keyClick(canvas, Qt::Key_Right);
+    QTest::keyClick(window, Qt::Key_Right);
     QCOMPARE(gridview->currentIndex(), indexRightOf7);
-    QTest::keyClick(canvas, Qt::Key_Left);
+    QTest::keyClick(window, Qt::Key_Left);
     QCOMPARE(gridview->currentIndex(), 7);
-    QTest::keyClick(canvas, Qt::Key_Left);
+    QTest::keyClick(window, Qt::Key_Left);
     QCOMPARE(gridview->currentIndex(), indexLeftOf7);
-    QTest::keyClick(canvas, Qt::Key_Right);
+    QTest::keyClick(window, Qt::Key_Right);
     QCOMPARE(gridview->currentIndex(), 7);
-    QTest::keyClick(canvas, Qt::Key_Up);
+    QTest::keyClick(window, Qt::Key_Up);
     QCOMPARE(gridview->currentIndex(), indexUpFrom7);
-    QTest::keyClick(canvas, Qt::Key_Down);
+    QTest::keyClick(window, Qt::Key_Down);
     QCOMPARE(gridview->currentIndex(), 7);
-    QTest::keyClick(canvas, Qt::Key_Down);
+    QTest::keyClick(window, Qt::Key_Down);
     QCOMPARE(gridview->currentIndex(), indexDownFrom7);
 
     // hold down a key to go forwards
     gridview->setCurrentIndex(0);
     for (int i=0; i<model.count()-1; i++) {
 //        QTest::qWait(500);
-        QTest::simulateEvent(canvas, true, forwardsKey, Qt::NoModifier, "", true);
+        QTest::simulateEvent(window, true, forwardsKey, Qt::NoModifier, "", true);
         QTRY_COMPARE(gridview->currentIndex(), i+1);
     }
-    QTest::keyRelease(canvas, forwardsKey);
+    QTest::keyRelease(window, forwardsKey);
     QTRY_COMPARE(gridview->currentIndex(), model.count()-1);
     QTRY_COMPARE(gridview->contentX(), contentPosAtLastItem.x());
     QTRY_COMPARE(gridview->contentY(), contentPosAtLastItem.y());
 
     // hold down a key to go backwards
     for (int i=model.count()-1; i > 0; i--) {
-        QTest::simulateEvent(canvas, true, backwardsKey, Qt::NoModifier, "", true);
+        QTest::simulateEvent(window, true, backwardsKey, Qt::NoModifier, "", true);
         QTRY_COMPARE(gridview->currentIndex(), i-1);
     }
-    QTest::keyRelease(canvas, backwardsKey);
+    QTest::keyRelease(window, backwardsKey);
     QTRY_COMPARE(gridview->currentIndex(), 0);
     QTRY_COMPARE(gridview->contentX(), contentPosAtFirstItem.x());
     QTRY_COMPARE(gridview->contentY(), contentPosAtFirstItem.y());
 
     // no wrap
     QVERIFY(!gridview->isWrapEnabled());
-    QTest::keyClick(canvas, forwardsKey);
+    QTest::keyClick(window, forwardsKey);
     QCOMPARE(gridview->currentIndex(), 1);
-    QTest::keyClick(canvas, backwardsKey);
+    QTest::keyClick(window, backwardsKey);
     QCOMPARE(gridview->currentIndex(), 0);
 
-    QTest::keyClick(canvas, backwardsKey);
+    QTest::keyClick(window, backwardsKey);
     QCOMPARE(gridview->currentIndex(), 0);
 
     // with wrap
     gridview->setWrapEnabled(true);
     QVERIFY(gridview->isWrapEnabled());
 
-    QTest::keyClick(canvas, backwardsKey);
+    QTest::keyClick(window, backwardsKey);
     QCOMPARE(gridview->currentIndex(), model.count()-1);
     QTRY_COMPARE(gridview->contentX(), contentPosAtLastItem.x());
     QTRY_COMPARE(gridview->contentY(), contentPosAtLastItem.y());
 
-    QTest::keyClick(canvas, forwardsKey);
+    QTest::keyClick(window, forwardsKey);
     QCOMPARE(gridview->currentIndex(), 0);
     QTRY_COMPARE(gridview->contentX(), contentPosAtFirstItem.x());
     QTRY_COMPARE(gridview->contentY(), contentPosAtFirstItem.y());
 
     // Test key press still accepted when position wraps to same index.
-    canvas->rootObject()->setProperty("lastKey", 0);
+    window->rootObject()->setProperty("lastKey", 0);
     model.removeItems(1, model.count() - 1);
 
-    QTest::keyClick(canvas, backwardsKey);
-    QCOMPARE(canvas->rootObject()->property("lastKey").toInt(), 0);
+    QTest::keyClick(window, backwardsKey);
+    QCOMPARE(window->rootObject()->property("lastKey").toInt(), 0);
 
-    QTest::keyClick(canvas, forwardsKey);
-    QCOMPARE(canvas->rootObject()->property("lastKey").toInt(), 0);
+    QTest::keyClick(window, forwardsKey);
+    QCOMPARE(window->rootObject()->property("lastKey").toInt(), 0);
 
     // Test key press not accepted at limits when wrap is disabled.
     gridview->setWrapEnabled(false);
 
-    QTest::keyClick(canvas, backwardsKey);
-    QCOMPARE(canvas->rootObject()->property("lastKey").toInt(), int(backwardsKey));
+    QTest::keyClick(window, backwardsKey);
+    QCOMPARE(window->rootObject()->property("lastKey").toInt(), int(backwardsKey));
 
-    QTest::keyClick(canvas, forwardsKey);
-    QCOMPARE(canvas->rootObject()->property("lastKey").toInt(), int(forwardsKey));
+    QTest::keyClick(window, forwardsKey);
+    QCOMPARE(window->rootObject()->property("lastKey").toInt(), int(forwardsKey));
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::keyNavigation_data()
@@ -2137,22 +2137,22 @@ void tst_QQuickGridView::keyNavigation_data()
 
 void tst_QQuickGridView::changeFlow()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i));
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testRightToLeft", QVariant(false));
     ctxt->setContextProperty("testTopToBottom", QVariant(false));
     ctxt->setContextProperty("testBottomToTop", QVariant(false));
 
-    canvas->setSource(testFileUrl("layouts.qml"));
+    window->setSource(testFileUrl("layouts.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -2230,7 +2230,7 @@ void tst_QQuickGridView::changeFlow()
         QTRY_COMPARE(number->text(), model.number(i));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::defaultValues()
@@ -2285,11 +2285,11 @@ void tst_QQuickGridView::properties()
 
 void tst_QQuickGridView::propertyChanges()
 {
-    QQuickView *canvas = createView();
-    QTRY_VERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychangestest.qml"));
+    QQuickView *window = createView();
+    QTRY_VERIFY(window);
+    window->setSource(testFileUrl("propertychangestest.qml"));
 
-    QQuickGridView *gridView = canvas->rootObject()->findChild<QQuickGridView*>("gridView");
+    QQuickGridView *gridView = window->rootObject()->findChild<QQuickGridView*>("gridView");
     QTRY_VERIFY(gridView);
 
     QSignalSpy keyNavigationWrapsSpy(gridView, SIGNAL(keyNavigationWrapsChanged()));
@@ -2353,22 +2353,22 @@ void tst_QQuickGridView::propertyChanges()
     gridView->setFlow(QQuickGridView::FlowTopToBottom);
     QTRY_COMPARE(flowSpy.count(),3);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::componentChanges()
 {
-    QQuickView *canvas = createView();
-    QTRY_VERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychangestest.qml"));
+    QQuickView *window = createView();
+    QTRY_VERIFY(window);
+    window->setSource(testFileUrl("propertychangestest.qml"));
 
-    QQuickGridView *gridView = canvas->rootObject()->findChild<QQuickGridView*>("gridView");
+    QQuickGridView *gridView = window->rootObject()->findChild<QQuickGridView*>("gridView");
     QTRY_VERIFY(gridView);
 
-    QQmlComponent component(canvas->engine());
+    QQmlComponent component(window->engine());
     component.setData("import QtQuick 2.0; Rectangle { color: \"blue\"; }", QUrl::fromLocalFile(""));
 
-    QQmlComponent delegateComponent(canvas->engine());
+    QQmlComponent delegateComponent(window->engine());
     delegateComponent.setData("import QtQuick 2.0; Text { text: '<b>Name:</b> ' + name }", QUrl::fromLocalFile(""));
 
     QSignalSpy highlightSpy(gridView, SIGNAL(highlightChanged()));
@@ -2410,19 +2410,19 @@ void tst_QQuickGridView::componentChanges()
     QTRY_COMPARE(headerItemSpy.count(),1);
     QTRY_COMPARE(footerItemSpy.count(),1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::modelChanges()
 {
-    QQuickView *canvas = createView();
-    QTRY_VERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychangestest.qml"));
+    QQuickView *window = createView();
+    QTRY_VERIFY(window);
+    window->setSource(testFileUrl("propertychangestest.qml"));
 
-    QQuickGridView *gridView = canvas->rootObject()->findChild<QQuickGridView*>("gridView");
+    QQuickGridView *gridView = window->rootObject()->findChild<QQuickGridView*>("gridView");
     QTRY_VERIFY(gridView);
 
-    QQuickListModel *alternateModel = canvas->rootObject()->findChild<QQuickListModel*>("alternateModel");
+    QQuickListModel *alternateModel = window->rootObject()->findChild<QQuickListModel*>("alternateModel");
     QTRY_VERIFY(alternateModel);
     QVariant modelVariant = QVariant::fromValue<QObject *>(alternateModel);
     QSignalSpy modelSpy(gridView, SIGNAL(modelChanged()));
@@ -2436,28 +2436,28 @@ void tst_QQuickGridView::modelChanges()
 
     gridView->setModel(QVariant());
     QTRY_COMPARE(modelSpy.count(),2);
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::positionViewAtIndex()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testRightToLeft", QVariant(false));
     ctxt->setContextProperty("testTopToBottom", QVariant(false));
     ctxt->setContextProperty("testBottomToTop", QVariant(false));
 
-    canvas->setSource(testFileUrl("layouts.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("layouts.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -2618,7 +2618,7 @@ void tst_QQuickGridView::positionViewAtIndex()
     QTRY_COMPARE(gridview->contentX(), 0.);
 
     gridview->setContentX(80);
-    canvas->rootObject()->setProperty("showHeader", true);
+    window->rootObject()->setProperty("showHeader", true);
     gridview->positionViewAtBeginning();
     QTRY_COMPARE(gridview->contentX(), -30.);
 
@@ -2627,7 +2627,7 @@ void tst_QQuickGridView::positionViewAtIndex()
     QTRY_COMPARE(gridview->contentX(), 400.);   // 8*80 - 240   (8 columns)
 
     gridview->setContentX(80);
-    canvas->rootObject()->setProperty("showFooter", true);
+    window->rootObject()->setProperty("showFooter", true);
     gridview->positionViewAtEnd();
     QTRY_COMPARE(gridview->contentX(), 430.);
 
@@ -2639,22 +2639,22 @@ void tst_QQuickGridView::positionViewAtIndex()
     QVERIFY(gridview->highlightItem());
     QCOMPARE(gridview->highlightItem()->x(), 80.);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::snapping()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     gridview->setHeight(220);
@@ -2675,20 +2675,20 @@ void tst_QQuickGridView::snapping()
     gridview->positionViewAtIndex(15, QQuickGridView::End);
     QCOMPARE(gridview->contentY(), 120.);
 
-    delete canvas;
+    delete window;
 
 }
 
 void tst_QQuickGridView::mirroring()
 {
-    QQuickView *canvasA = createView();
-    canvasA->setSource(testFileUrl("mirroring.qml"));
-    QQuickGridView *gridviewA = findItem<QQuickGridView>(canvasA->rootObject(), "view");
+    QQuickView *windowA = createView();
+    windowA->setSource(testFileUrl("mirroring.qml"));
+    QQuickGridView *gridviewA = findItem<QQuickGridView>(windowA->rootObject(), "view");
     QTRY_VERIFY(gridviewA != 0);
 
-    QQuickView *canvasB = createView();
-    canvasB->setSource(testFileUrl("mirroring.qml"));
-    QQuickGridView *gridviewB = findItem<QQuickGridView>(canvasB->rootObject(), "view");
+    QQuickView *windowB = createView();
+    windowB->setSource(testFileUrl("mirroring.qml"));
+    QQuickGridView *gridviewB = findItem<QQuickGridView>(windowB->rootObject(), "view");
     QTRY_VERIFY(gridviewA != 0);
     qApp->processEvents();
 
@@ -2736,28 +2736,28 @@ void tst_QQuickGridView::mirroring()
     foreach (const QString objectName, objectNames)
         QCOMPARE(findItem<QQuickItem>(gridviewA, objectName)->x(), findItem<QQuickItem>(gridviewB, objectName)->x());
 
-    delete canvasA;
-    delete canvasB;
+    delete windowA;
+    delete windowB;
 }
 
 void tst_QQuickGridView::positionViewAtIndex_rightToLeft()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testTopToBottom", QVariant(true));
     ctxt->setContextProperty("testRightToLeft", QVariant(true));
     ctxt->setContextProperty("testBottomToTop", QVariant(false));
 
-    canvas->setSource(testFileUrl("layouts.qml"));
+    window->setSource(testFileUrl("layouts.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -2870,25 +2870,25 @@ void tst_QQuickGridView::positionViewAtIndex_rightToLeft()
     gridview->positionViewAtIndex(20, QQuickGridView::Contain);
     QTRY_COMPARE(gridview->contentX(), -560.);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::resetModel()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QStringList strings;
     strings << "one" << "two" << "three";
     QStringListModel model(strings);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("displaygrid.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("displaygrid.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -2914,28 +2914,28 @@ void tst_QQuickGridView::resetModel()
         QTRY_COMPARE(display->text(), strings.at(i));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::enforceRange()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testRightToLeft", QVariant(false));
     ctxt->setContextProperty("testTopToBottom", QVariant(false));
 
-    canvas->setSource(testFileUrl("gridview-enforcerange.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("gridview-enforcerange.qml"));
+    window->show();
     qApp->processEvents();
-    QVERIFY(canvas->rootObject() != 0);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QTRY_COMPARE(gridview->preferredHighlightBegin(), 100.0);
@@ -2972,27 +2972,27 @@ void tst_QQuickGridView::enforceRange()
     ctxt->setContextProperty("testModel", &model2);
     QCOMPARE(gridview->count(), 5);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::enforceRange_rightToLeft()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testRightToLeft", QVariant(true));
     ctxt->setContextProperty("testTopToBottom", QVariant(true));
 
-    canvas->setSource(testFileUrl("gridview-enforcerange.qml"));
+    window->setSource(testFileUrl("gridview-enforcerange.qml"));
     qApp->processEvents();
-    QVERIFY(canvas->rootObject() != 0);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QCOMPARE(gridview->preferredHighlightBegin(), 100.0);
@@ -3030,34 +3030,34 @@ void tst_QQuickGridView::enforceRange_rightToLeft()
     ctxt->setContextProperty("testModel", &model2);
     QCOMPARE(gridview->count(), 5);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::QTBUG_8456()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("setindex.qml"));
+    window->setSource(testFileUrl("setindex.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QTRY_COMPARE(gridview->currentIndex(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::manualHighlight()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QString filename(testFile("manual-highlight.qml"));
-    canvas->setSource(QUrl::fromLocalFile(filename));
+    window->setSource(QUrl::fromLocalFile(filename));
 
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -3091,7 +3091,7 @@ void tst_QQuickGridView::manualHighlight()
     QTRY_COMPARE(gridview->highlightItem()->y() - 5, gridview->currentItem()->y());
     QTRY_COMPARE(gridview->highlightItem()->x() - 5, gridview->currentItem()->x());
 
-    delete canvas;
+    delete window;
 }
 
 
@@ -3106,19 +3106,19 @@ void tst_QQuickGridView::footer()
     QFETCH(QPointF, firstDelegatePos);
     QFETCH(QPointF, resizeContentPos);
 
-    QQuickView *canvas = getView();
-    canvas->show();
+    QQuickView *window = getView();
+    window->show();
 
     QaimModel model;
     for (int i = 0; i < 7; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("footer.qml"));
+    window->setSource(testFileUrl("footer.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     gridview->setFlow(flow);
     gridview->setLayoutDirection(layoutDirection);
@@ -3178,17 +3178,17 @@ void tst_QQuickGridView::footer()
     QTRY_COMPARE(footer->pos(), posWhenNoItems);
 
     // if header is toggled, it shouldn't affect the footer position
-    canvas->rootObject()->setProperty("showHeader", true);
+    window->rootObject()->setProperty("showHeader", true);
     QVERIFY(findItem<QQuickItem>(contentItem, "header") != 0);
     QTRY_COMPARE(footer->pos(), posWhenNoItems);
-    canvas->rootObject()->setProperty("showHeader", false);
+    window->rootObject()->setProperty("showHeader", false);
 
     // add 30 items
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
     QSignalSpy footerItemSpy(gridview, SIGNAL(footerItemChanged()));
-    QMetaObject::invokeMethod(canvas->rootObject(), "changeFooter");
+    QMetaObject::invokeMethod(window->rootObject(), "changeFooter");
 
     QCOMPARE(footerItemSpy.count(), 1);
 
@@ -3214,7 +3214,7 @@ void tst_QQuickGridView::footer()
     footer->setWidth(40);
     QTRY_COMPARE(QPointF(gridview->contentX(), gridview->contentY()), resizeContentPos);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::footer_data()
@@ -3310,11 +3310,11 @@ void tst_QQuickGridView::footer_data()
 
 void tst_QQuickGridView::initialZValues()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("initialZValues.qml"));
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("initialZValues.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -3325,7 +3325,7 @@ void tst_QQuickGridView::initialZValues()
     QVERIFY(gridview->footerItem());
     QTRY_COMPARE(gridview->footerItem()->z(), gridview->property("initialZ").toReal());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::header()
@@ -3344,15 +3344,15 @@ void tst_QQuickGridView::header()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->rootContext()->setContextProperty("initialViewWidth", 240);
-    canvas->rootContext()->setContextProperty("initialViewHeight", 320);
-    canvas->setSource(testFileUrl("header.qml"));
-    canvas->show();
+    QQuickView *window = getView();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("initialViewWidth", 240);
+    window->rootContext()->setContextProperty("initialViewHeight", 320);
+    window->setSource(testFileUrl("header.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     gridview->setFlow(flow);
     gridview->setLayoutDirection(layoutDirection);
@@ -3392,7 +3392,7 @@ void tst_QQuickGridView::header()
         model.addItem("Item" + QString::number(i), "");
 
     QSignalSpy headerItemSpy(gridview, SIGNAL(headerItemChanged()));
-    QMetaObject::invokeMethod(canvas->rootObject(), "changeHeader");
+    QMetaObject::invokeMethod(window->rootObject(), "changeHeader");
 
     QCOMPARE(headerItemSpy.count(), 1);
 
@@ -3416,20 +3416,20 @@ void tst_QQuickGridView::header()
     header->setWidth(40);
     QTRY_COMPARE(QPointF(gridview->contentX(), gridview->contentY()), resizeContentPos);
 
-    releaseView(canvas);
+    releaseView(window);
 
 
     // QTBUG-21207 header should become visible if view resizes from initial empty size
 
-    canvas = getView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->rootContext()->setContextProperty("initialViewWidth", 240);
-    canvas->rootContext()->setContextProperty("initialViewHeight", 320);
-    canvas->setSource(testFileUrl("header.qml"));
-    canvas->show();
+    window = getView();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("initialViewWidth", 240);
+    window->rootContext()->setContextProperty("initialViewHeight", 320);
+    window->setSource(testFileUrl("header.qml"));
+    window->show();
     qApp->processEvents();
 
-    gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     gridview->setFlow(flow);
     gridview->setLayoutDirection(layoutDirection);
@@ -3441,7 +3441,7 @@ void tst_QQuickGridView::header()
     QTRY_COMPARE(gridview->headerItem()->pos(), initialHeaderPos);
     QCOMPARE(QPointF(gridview->contentX(), gridview->contentY()), initialContentPos);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::header_data()
@@ -3564,16 +3564,16 @@ void tst_QQuickGridView::extents()
     QFETCH(QPointF, origin_empty);
     QFETCH(QPointF, origin_nonEmpty);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QmlListModel model;
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("headerfooter.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("headerfooter.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = qobject_cast<QQuickGridView*>(canvas->rootObject());
+    QQuickGridView *gridview = qobject_cast<QQuickGridView*>(window->rootObject());
     QTRY_VERIFY(gridview != 0);
     gridview->setFlow(flow);
     gridview->setLayoutDirection(layoutDirection);
@@ -3604,7 +3604,7 @@ void tst_QQuickGridView::extents()
     QCOMPARE(gridview->originX(), origin_nonEmpty.x());
     QCOMPARE(gridview->originY(), origin_nonEmpty.y());
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::extents_data()
@@ -3677,18 +3677,18 @@ void tst_QQuickGridView::resetModel_headerFooter()
 {
     // Resetting a model shouldn't crash in views with header/footer
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 6; i++)
         model.addItem("Item" + QString::number(i), "");
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("headerfooter.qml"));
+    window->setSource(testFileUrl("headerfooter.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = qobject_cast<QQuickGridView*>(canvas->rootObject());
+    QQuickGridView *gridview = qobject_cast<QQuickGridView*>(window->rootObject());
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -3712,28 +3712,28 @@ void tst_QQuickGridView::resetModel_headerFooter()
     QVERIFY(footer);
     QCOMPARE(footer->y(), 60.*2);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::resizeViewAndRepaint()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("initialWidth", 240);
     ctxt->setContextProperty("initialHeight", 100);
 
-    canvas->setSource(testFileUrl("resizeview.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("resizeview.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -3783,7 +3783,7 @@ void tst_QQuickGridView::resizeViewAndRepaint()
         QCOMPARE(delegateVisible(item), i < 6); // inside view visible, outside not visible
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::resizeGrid()
@@ -3798,25 +3798,25 @@ void tst_QQuickGridView::resizeGrid()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testTopToBottom", flow == QQuickGridView::FlowTopToBottom);
     ctxt->setContextProperty("testRightToLeft", layoutDirection == Qt::RightToLeft);
     ctxt->setContextProperty("testBottomToTop", verticalLayoutDirection == QQuickGridView::BottomToTop);
-    canvas->setSource(testFileUrl("resizegrid.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("resizegrid.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
 
     // set the width to slightly larger than 3 items across, to test
     // items are aligned correctly in right-to-left
-    canvas->rootObject()->setWidth(260);
-    canvas->rootObject()->setHeight(320);
+    window->rootObject()->setWidth(260);
+    window->rootObject()->setHeight(320);
     QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
 
     QCOMPARE(gridview->contentX(), initialContentPos.x());
@@ -3839,8 +3839,8 @@ void tst_QQuickGridView::resizeGrid()
     }
 
     // change from 3x5 grid to 4x7
-    canvas->rootObject()->setWidth(canvas->rootObject()->width() + 80);
-    canvas->rootObject()->setHeight(canvas->rootObject()->height() + 60*2);
+    window->rootObject()->setWidth(window->rootObject()->width() + 80);
+    window->rootObject()->setHeight(window->rootObject()->height() + 60*2);
     QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
 
     // other than in LeftToRight+RightToLeft layout, the first item should not move
@@ -3870,7 +3870,7 @@ void tst_QQuickGridView::resizeGrid()
         QCOMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::resizeGrid_data()
@@ -3933,16 +3933,16 @@ void tst_QQuickGridView::changeColumnCount()
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = createView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("initialWidth", 100);
     ctxt->setContextProperty("initialHeight", 320);
-    canvas->setSource(testFileUrl("resizeview.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("resizeview.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -3982,7 +3982,7 @@ void tst_QQuickGridView::changeColumnCount()
         QCOMPARE(item->y(), qreal(i*60));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::indexAt_itemAt_data()
@@ -4004,7 +4004,7 @@ void tst_QQuickGridView::indexAt_itemAt()
     QFETCH(qreal, y);
     QFETCH(int, index);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QaimModel model;
     model.addItem("Fred", "12345");
@@ -4015,11 +4015,11 @@ void tst_QQuickGridView::indexAt_itemAt()
     model.addItem("Ben", "04321");
     model.addItem("Jim", "0780");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -4035,7 +4035,7 @@ void tst_QQuickGridView::indexAt_itemAt()
     QCOMPARE(gridview->indexAt(x, y), index);
     QVERIFY(gridview->itemAt(x, y) == item);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::onAdd()
@@ -4046,22 +4046,22 @@ void tst_QQuickGridView::onAdd()
     const int delegateWidth = 50;
     const int delegateHeight = 100;
     QaimModel model;
-    QQuickView *canvas = getView();
-    canvas->setGeometry(0,0,5 * delegateWidth, 5 * delegateHeight); // just ensure all items fit
+    QQuickView *window = getView();
+    window->setGeometry(0,0,5 * delegateWidth, 5 * delegateHeight); // just ensure all items fit
 
     // these initial items should not trigger GridView.onAdd
     for (int i=0; i<initialItemCount; i++)
         model.addItem("dummy value", "dummy value");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("delegateWidth", delegateWidth);
     ctxt->setContextProperty("delegateHeight", delegateHeight);
-    canvas->setSource(testFileUrl("attachedSignals.qml"));
+    window->setSource(testFileUrl("attachedSignals.qml"));
 
-    QObject *object = canvas->rootObject();
-    object->setProperty("width", canvas->width());
-    object->setProperty("height", canvas->height());
+    QObject *object = window->rootObject();
+    object->setProperty("width", window->width());
+    object->setProperty("height", window->height());
     qApp->processEvents();
 
     QList<QPair<QString, QString> > items;
@@ -4069,7 +4069,7 @@ void tst_QQuickGridView::onAdd()
         items << qMakePair(QString("value %1").arg(i), QString::number(i));
     model.addItems(items);
 
-    QTRY_COMPARE(model.count(), qobject_cast<QQuickGridView*>(canvas->rootObject())->count());
+    QTRY_COMPARE(model.count(), qobject_cast<QQuickGridView*>(window->rootObject())->count());
     qApp->processEvents();
 
     QVariantList result = object->property("addedDelegates").toList();
@@ -4077,7 +4077,7 @@ void tst_QQuickGridView::onAdd()
     for (int i=0; i<items.count(); i++)
         QCOMPARE(result[i].toString(), items[i].first);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::onAdd_data()
@@ -4110,19 +4110,19 @@ void tst_QQuickGridView::onRemove()
     for (int i=0; i<initialItemCount; i++)
         model.addItem(QString("value %1").arg(i), "dummy value");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("delegateWidth", delegateWidth);
     ctxt->setContextProperty("delegateHeight", delegateHeight);
-    canvas->setSource(testFileUrl("attachedSignals.qml"));
-    QObject *object = canvas->rootObject();
+    window->setSource(testFileUrl("attachedSignals.qml"));
+    QObject *object = window->rootObject();
 
     model.removeItems(indexToRemove, removeCount);
-    QTRY_COMPARE(model.count(), qobject_cast<QQuickGridView*>(canvas->rootObject())->count());
+    QTRY_COMPARE(model.count(), qobject_cast<QQuickGridView*>(window->rootObject())->count());
     QCOMPARE(object->property("removedDelegateCount"), QVariant(removeCount));
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::onRemove_data()
@@ -4150,13 +4150,13 @@ void tst_QQuickGridView::onRemove_data()
 
 void tst_QQuickGridView::columnCount()
 {
-    QQuickView canvas;
-    canvas.setSource(testFileUrl("gridview4.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowShown(&canvas);
+    QQuickView window;
+    window.setSource(testFileUrl("gridview4.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowShown(&window);
 
-    QQuickGridView *view = qobject_cast<QQuickGridView*>(canvas.rootObject());
+    QQuickGridView *view = qobject_cast<QQuickGridView*>(window.rootObject());
 
     QCOMPARE(view->cellWidth(), qreal(405)/qreal(9));
     QCOMPARE(view->cellHeight(), qreal(100));
@@ -4170,21 +4170,21 @@ void tst_QQuickGridView::columnCount()
 void tst_QQuickGridView::margins()
 {
     {
-        QQuickView *canvas = createView();
+        QQuickView *window = createView();
 
         QaimModel model;
         for (int i = 0; i < 40; i++)
             model.addItem("Item" + QString::number(i), "");
 
-        QQmlContext *ctxt = canvas->rootContext();
+        QQmlContext *ctxt = window->rootContext();
         ctxt->setContextProperty("testModel", &model);
         ctxt->setContextProperty("testRightToLeft", QVariant(false));
 
-        canvas->setSource(testFileUrl("margins.qml"));
-        canvas->show();
+        window->setSource(testFileUrl("margins.qml"));
+        window->show();
         qApp->processEvents();
 
-        QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+        QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
         QTRY_VERIFY(gridview != 0);
         QQuickItem *contentItem = gridview->contentItem();
         QTRY_VERIFY(contentItem != 0);
@@ -4229,25 +4229,25 @@ void tst_QQuickGridView::margins()
         QCOMPARE(gridview->originX(), 0.);
         QTRY_COMPARE(gridview->contentX(), pos-10);
 
-        delete canvas;
+        delete window;
     }
     {
         //RTL
-        QQuickView *canvas = createView();
-        canvas->show();
+        QQuickView *window = createView();
+        window->show();
 
         QaimModel model;
         for (int i = 0; i < 40; i++)
             model.addItem("Item" + QString::number(i), "");
 
-        QQmlContext *ctxt = canvas->rootContext();
+        QQmlContext *ctxt = window->rootContext();
         ctxt->setContextProperty("testModel", &model);
         ctxt->setContextProperty("testRightToLeft", QVariant(true));
 
-        canvas->setSource(testFileUrl("margins.qml"));
+        window->setSource(testFileUrl("margins.qml"));
         qApp->processEvents();
 
-        QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+        QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
         QTRY_VERIFY(gridview != 0);
 
         QQuickItem *contentItem = gridview->contentItem();
@@ -4294,18 +4294,18 @@ void tst_QQuickGridView::margins()
         QCOMPARE(gridview->originX(), -900.);
         QTRY_COMPARE(gridview->contentX(), pos+10);
 
-        delete canvas;
+        delete window;
     }
 }
 
 void tst_QQuickGridView::creationContext()
 {
-    QQuickView canvas;
-    canvas.setGeometry(0,0,240,320);
-    canvas.setSource(testFileUrl("creationContext.qml"));
+    QQuickView window;
+    window.setGeometry(0,0,240,320);
+    window.setSource(testFileUrl("creationContext.qml"));
     qApp->processEvents();
 
-    QQuickItem *rootItem = qobject_cast<QQuickItem *>(canvas.rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem *>(window.rootObject());
     QVERIFY(rootItem);
     QVERIFY(rootItem->property("count").toInt() > 0);
 
@@ -4359,13 +4359,13 @@ void tst_QQuickGridView::snapToRow()
     QFETCH(qreal, endExtent);
     QFETCH(qreal, startExtent);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
-    canvas->setSource(testFileUrl("snapToRow.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("snapToRow.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     gridview->setFlow(flow);
@@ -4377,7 +4377,7 @@ void tst_QQuickGridView::snapToRow()
     QTRY_VERIFY(contentItem != 0);
 
     // confirm that a flick hits an item boundary
-    flick(canvas, flickStart, flickEnd, 180);
+    flick(window, flickStart, flickEnd, 180);
     QTRY_VERIFY(gridview->isMoving() == false); // wait until it stops
     if (flow == QQuickGridView::FlowLeftToRight)
         QCOMPARE(qreal(fmod(gridview->contentY(),80.0)), snapAlignment);
@@ -4386,7 +4386,7 @@ void tst_QQuickGridView::snapToRow()
 
     // flick to end
     do {
-        flick(canvas, flickStart, flickEnd, 180);
+        flick(window, flickStart, flickEnd, 180);
         QTRY_VERIFY(gridview->isMoving() == false); // wait until it stops
     } while (flow == QQuickGridView::FlowLeftToRight
            ? !gridview->isAtYEnd()
@@ -4399,7 +4399,7 @@ void tst_QQuickGridView::snapToRow()
 
     // flick to start
     do {
-        flick(canvas, flickEnd, flickStart, 180);
+        flick(window, flickEnd, flickStart, 180);
         QTRY_VERIFY(gridview->isMoving() == false); // wait until it stops
     } while (flow == QQuickGridView::FlowLeftToRight
            ? !gridview->isAtYBeginning()
@@ -4410,7 +4410,7 @@ void tst_QQuickGridView::snapToRow()
     else
         QCOMPARE(gridview->contentX(), startExtent);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::snapOneRow_data()
@@ -4454,13 +4454,13 @@ void tst_QQuickGridView::snapOneRow()
     QFETCH(qreal, endExtent);
     QFETCH(qreal, startExtent);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
-    canvas->setSource(testFileUrl("snapOneRow.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("snapOneRow.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
 
     gridview->setFlow(flow);
@@ -4474,7 +4474,7 @@ void tst_QQuickGridView::snapOneRow()
     QSignalSpy currentIndexSpy(gridview, SIGNAL(currentIndexChanged()));
 
     // confirm that a flick hits next row boundary
-    flick(canvas, flickStart, flickEnd, 180);
+    flick(window, flickStart, flickEnd, 180);
     QTRY_VERIFY(gridview->isMoving() == false); // wait until it stops
     if (flow == QQuickGridView::FlowLeftToRight)
         QCOMPARE(gridview->contentY(), snapAlignment);
@@ -4488,7 +4488,7 @@ void tst_QQuickGridView::snapOneRow()
 
     // flick to end
     do {
-        flick(canvas, flickStart, flickEnd, 180);
+        flick(window, flickStart, flickEnd, 180);
         QTRY_VERIFY(gridview->isMoving() == false); // wait until it stops
     } while (flow == QQuickGridView::FlowLeftToRight
            ? !gridview->isAtYEnd()
@@ -4506,7 +4506,7 @@ void tst_QQuickGridView::snapOneRow()
 
     // flick to start
     do {
-        flick(canvas, flickEnd, flickStart, 180);
+        flick(window, flickEnd, flickStart, 180);
         QTRY_VERIFY(gridview->isMoving() == false); // wait until it stops
     } while (flow == QQuickGridView::FlowLeftToRight
            ? !gridview->isAtYBeginning()
@@ -4522,26 +4522,26 @@ void tst_QQuickGridView::snapOneRow()
         QCOMPARE(currentIndexSpy.count(), 6);
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 
 void tst_QQuickGridView::unaligned()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     for (int i = 0; i < 10; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("unaligned.qml"));
+    window->setSource(testFileUrl("unaligned.qml"));
     qApp->processEvents();
 
-    QQuickGridView *gridview = qobject_cast<QQuickGridView*>(canvas->rootObject());
+    QQuickGridView *gridview = qobject_cast<QQuickGridView*>(window->rootObject());
     QVERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -4583,7 +4583,7 @@ void tst_QQuickGridView::unaligned()
         QCOMPARE(item->y(), qreal(i/9)*gridview->cellHeight());
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::populateTransitions()
@@ -4603,18 +4603,18 @@ void tst_QQuickGridView::populateTransitions()
             model.addItem("item" + QString::number(i), "");
     }
 
-    QQuickView *canvas = getView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->rootContext()->setContextProperty("usePopulateTransition", usePopulateTransition);
-    canvas->rootContext()->setContextProperty("dynamicallyPopulate", dynamicallyPopulate);
-    canvas->rootContext()->setContextProperty("transitionFrom", transitionFrom);
-    canvas->rootContext()->setContextProperty("transitionVia", transitionVia);
-    canvas->rootContext()->setContextProperty("model_transitionFrom", &model_transitionFrom);
-    canvas->rootContext()->setContextProperty("model_transitionVia", &model_transitionVia);
-    canvas->setSource(testFileUrl("populateTransitions.qml"));
-    canvas->show();
-
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickView *window = getView();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("usePopulateTransition", usePopulateTransition);
+    window->rootContext()->setContextProperty("dynamicallyPopulate", dynamicallyPopulate);
+    window->rootContext()->setContextProperty("transitionFrom", transitionFrom);
+    window->rootContext()->setContextProperty("transitionVia", transitionVia);
+    window->rootContext()->setContextProperty("model_transitionFrom", &model_transitionFrom);
+    window->rootContext()->setContextProperty("model_transitionVia", &model_transitionVia);
+    window->setSource(testFileUrl("populateTransitions.qml"));
+    window->show();
+
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QVERIFY(gridview);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem);
@@ -4652,7 +4652,7 @@ void tst_QQuickGridView::populateTransitions()
     QTRY_COMPARE(gridview->property("countPopulateTransitions").toInt(), 0);
 
     // clear the model
-    canvas->rootContext()->setContextProperty("testModel", QVariant());
+    window->rootContext()->setContextProperty("testModel", QVariant());
     QTRY_COMPARE(gridview->count(), 0);
     QTRY_COMPARE(findItems<QQuickItem>(contentItem, "wrapper").count(), 0);
     gridview->setProperty("countPopulateTransitions", 0);
@@ -4662,7 +4662,7 @@ void tst_QQuickGridView::populateTransitions()
     model.clear();
     for (int i = 0; i < 30; i++)
         model.addItem("item" + QString::number(i), "");
-    canvas->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("testModel", &model);
     QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
 
     QTRY_COMPARE(gridview->property("countPopulateTransitions").toInt(), usePopulateTransition ? 18 : 0);
@@ -4697,7 +4697,7 @@ void tst_QQuickGridView::populateTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::populateTransitions_data()
@@ -4737,17 +4737,17 @@ void tst_QQuickGridView::addTransitions()
     QaimModel model_targetItems_transitionFrom;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("model_targetItems_transitionFrom", &model_targetItems_transitionFrom);
     ctxt->setContextProperty("model_displacedItems_transitionVia", &model_displacedItems_transitionVia);
     ctxt->setContextProperty("targetItems_transitionFrom", targetItems_transitionFrom);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
-    canvas->setSource(testFileUrl("addTransitions.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("addTransitions.qml"));
+    window->show();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
@@ -4832,7 +4832,7 @@ void tst_QQuickGridView::addTransitions()
         QCOMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::addTransitions_data()
@@ -4941,17 +4941,17 @@ void tst_QQuickGridView::moveTransitions()
     QaimModel model_targetItems_transitionVia;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("model_targetItems_transitionVia", &model_targetItems_transitionVia);
     ctxt->setContextProperty("model_displacedItems_transitionVia", &model_displacedItems_transitionVia);
     ctxt->setContextProperty("targetItems_transitionVia", targetItems_transitionVia);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
-    canvas->setSource(testFileUrl("moveTransitions.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("moveTransitions.qml"));
+    window->show();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
@@ -5029,7 +5029,7 @@ void tst_QQuickGridView::moveTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::moveTransitions_data()
@@ -5185,17 +5185,17 @@ void tst_QQuickGridView::removeTransitions()
     QaimModel model_targetItems_transitionTo;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("model_targetItems_transitionTo", &model_targetItems_transitionTo);
     ctxt->setContextProperty("model_displacedItems_transitionVia", &model_displacedItems_transitionVia);
     ctxt->setContextProperty("targetItems_transitionTo", targetItems_transitionTo);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
-    canvas->setSource(testFileUrl("removeTransitions.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("removeTransitions.qml"));
+    window->show();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
@@ -5282,7 +5282,7 @@ void tst_QQuickGridView::removeTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::removeTransitions_data()
@@ -5389,8 +5389,8 @@ void tst_QQuickGridView::displacedTransitions()
     QPointF moveDisplaced_transitionVia(50, -100);
     QPointF removeDisplaced_transitionVia(150, 100);
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("model_displaced_transitionVia", &model_displaced_transitionVia);
     ctxt->setContextProperty("model_addDisplaced_transitionVia", &model_addDisplaced_transitionVia);
@@ -5408,11 +5408,11 @@ void tst_QQuickGridView::displacedTransitions()
     ctxt->setContextProperty("moveDisplacedEnabled", moveDisplacedEnabled);
     ctxt->setContextProperty("useRemoveDisplaced", useRemoveDisplaced);
     ctxt->setContextProperty("removeDisplacedEnabled", removeDisplacedEnabled);
-    canvas->setSource(testFileUrl("displacedTransitions.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("displacedTransitions.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
@@ -5500,7 +5500,7 @@ void tst_QQuickGridView::displacedTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::displacedTransitions_data()
@@ -5613,8 +5613,8 @@ void tst_QQuickGridView::multipleTransitions()
     for (int i = 0; i < initialCount; i++)
         model.addItem("Original item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("addTargets_transitionFrom", addTargets_transitionFrom);
     ctxt->setContextProperty("addDisplaced_transitionFrom", addDisplaced_transitionFrom);
@@ -5626,11 +5626,11 @@ void tst_QQuickGridView::multipleTransitions()
     ctxt->setContextProperty("enableMoveTransitions", enableMoveTransitions);
     ctxt->setContextProperty("enableRemoveTransitions", enableRemoveTransitions);
     ctxt->setContextProperty("rippleAddDisplaced", rippleAddDisplaced);
-    canvas->setSource(testFileUrl("multipleTransitions.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("multipleTransitions.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
@@ -5641,7 +5641,7 @@ void tst_QQuickGridView::multipleTransitions()
         QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
     }
 
-    int timeBetweenActions = canvas->rootObject()->property("timeBetweenActions").toInt();
+    int timeBetweenActions = window->rootObject()->property("timeBetweenActions").toInt();
 
     for (int i=0; i<changes.count(); i++) {
         switch (changes[i].type) {
@@ -5717,7 +5717,7 @@ void tst_QQuickGridView::multipleTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickGridView::multipleTransitions_data()
@@ -5788,21 +5788,21 @@ void tst_QQuickGridView::multipleDisplaced()
     for (int i = 0; i < 30; i++)
         model.addItem("Original item" + QString::number(i), "");
 
-    QQuickView *canvas = createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = createView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("multipleDisplaced.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("multipleDisplaced.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QTRY_VERIFY(gridview != 0);
     QQuickItem *contentItem = gridview->contentItem();
     QVERIFY(contentItem != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(gridview)->polishScheduled, false);
 
     model.moveItems(12, 8, 1);
-    QTest::qWait(canvas->rootObject()->property("duration").toInt() / 2);
+    QTest::qWait(window->rootObject()->property("duration").toInt() / 2);
     model.moveItems(8, 3, 1);
     QTRY_VERIFY(gridview->property("displaceTransitionsDone").toBool());
 
@@ -5824,23 +5824,23 @@ void tst_QQuickGridView::multipleDisplaced()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::cacheBuffer()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 90; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("gridview1.qml"));
-    canvas->show();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("gridview1.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickGridView *gridview = findItem<QQuickGridView>(canvas->rootObject(), "grid");
+    QQuickGridView *gridview = findItem<QQuickGridView>(window->rootObject(), "grid");
     QVERIFY(gridview != 0);
 
     QQuickItem *contentItem = gridview->contentItem();
@@ -5857,9 +5857,9 @@ void tst_QQuickGridView::cacheBuffer()
     }
 
     QQmlIncubationController controller;
-    canvas->engine()->setIncubationController(&controller);
+    window->engine()->setIncubationController(&controller);
 
-    canvas->rootObject()->setProperty("cacheBuffer", 200);
+    window->rootObject()->setProperty("cacheBuffer", 200);
     QTRY_VERIFY(gridview->cacheBuffer() == 200);
 
     // items will be created one at a time
@@ -5917,19 +5917,19 @@ void tst_QQuickGridView::cacheBuffer()
         controller.incubateWhile(&b);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::asynchronous()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
     QQmlIncubationController controller;
-    canvas->engine()->setIncubationController(&controller);
+    window->engine()->setIncubationController(&controller);
 
-    canvas->setSource(testFileUrl("asyncloader.qml"));
+    window->setSource(testFileUrl("asyncloader.qml"));
 
-    QQuickItem *rootObject = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootObject = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootObject);
 
     QQuickGridView *gridview = 0;
@@ -5964,7 +5964,7 @@ void tst_QQuickGridView::asynchronous()
         QVERIFY(item->y() == (i/3)*100);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickGridView::unrequestedVisibility()
@@ -5973,23 +5973,23 @@ void tst_QQuickGridView::unrequestedVisibility()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i));
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testWrap", QVariant(false));
 
-    canvas->setSource(testFileUrl("unrequestedItems.qml"));
+    window->setSource(testFileUrl("unrequestedItems.qml"));
 
-    canvas->show();
+    window->show();
 
     qApp->processEvents();
 
-    QQuickGridView *leftview = findItem<QQuickGridView>(canvas->rootObject(), "leftGrid");
+    QQuickGridView *leftview = findItem<QQuickGridView>(window->rootObject(), "leftGrid");
     QTRY_VERIFY(leftview != 0);
 
-    QQuickGridView *rightview = findItem<QQuickGridView>(canvas->rootObject(), "rightGrid");
+    QQuickGridView *rightview = findItem<QQuickGridView>(window->rootObject(), "rightGrid");
     QTRY_VERIFY(rightview != 0);
 
     QQuickItem *leftContent = leftview->contentItem();
@@ -6136,7 +6136,7 @@ void tst_QQuickGridView::unrequestedVisibility()
     QVERIFY(item = findItem<QQuickItem>(rightContent, "wrapper", 10));
     QCOMPARE(delegateVisible(item), false);
 
-    delete canvas;
+    delete window;
 }
 
 
diff --git a/tests/auto/quick/qquickimage/tst_qquickimage.cpp b/tests/auto/quick/qquickimage/tst_qquickimage.cpp
index 0ff825c..d81fc40 100644
--- a/tests/auto/quick/qquickimage/tst_qquickimage.cpp
+++ b/tests/auto/quick/qquickimage/tst_qquickimage.cpp
@@ -55,7 +55,7 @@
 #include <QtTest/QSignalSpy>
 #include <QtGui/QPainter>
 #include <QtGui/QImageReader>
-#include <QQuickCanvas>
+#include <QQuickWindow>
 
 #include "../../shared/util.h"
 #include "../../shared/testhttpserver.h"
@@ -113,8 +113,8 @@ tst_qquickimage::tst_qquickimage()
 
 void tst_qquickimage::cleanup()
 {
-    QQuickCanvas canvas;
-    canvas.releaseResources();
+    QQuickWindow window;
+    window.releaseResources();
     engine.clearComponentCache();
 }
 
@@ -259,23 +259,23 @@ void tst_qquickimage::resized()
 
 void tst_qquickimage::preserveAspectRatio()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->show();
 
-    canvas->setSource(testFileUrl("aspectratio.qml"));
-    QQuickImage *image = qobject_cast<QQuickImage*>(canvas->rootObject());
+    window->setSource(testFileUrl("aspectratio.qml"));
+    QQuickImage *image = qobject_cast<QQuickImage*>(window->rootObject());
     QVERIFY(image != 0);
     image->setWidth(80.0);
     QCOMPARE(image->width(), 80.);
     QCOMPARE(image->height(), 80.);
 
-    canvas->setSource(testFileUrl("aspectratio.qml"));
-    image = qobject_cast<QQuickImage*>(canvas->rootObject());
+    window->setSource(testFileUrl("aspectratio.qml"));
+    image = qobject_cast<QQuickImage*>(window->rootObject());
     image->setHeight(60.0);
     QVERIFY(image != 0);
     QCOMPARE(image->height(), 60.);
     QCOMPARE(image->width(), 60.);
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickimage::smooth()
@@ -304,21 +304,21 @@ void tst_qquickimage::mirror()
     qreal height = 250;
 
     foreach (QQuickImage::FillMode fillMode, fillModes) {
-        QQuickView *canvas = new QQuickView;
-        canvas->setSource(testFileUrl("mirror.qml"));
+        QQuickView *window = new QQuickView;
+        window->setSource(testFileUrl("mirror.qml"));
 
-        QQuickImage *obj = canvas->rootObject()->findChild<QQuickImage*>("image");
+        QQuickImage *obj = window->rootObject()->findChild<QQuickImage*>("image");
         QVERIFY(obj != 0);
 
         obj->setFillMode(fillMode);
         obj->setProperty("mirror", true);
-        canvas->show();
-        canvas->requestActivateWindow();
-        QTest::qWaitForWindowShown(canvas);
+        window->show();
+        window->requestActivateWindow();
+        QTest::qWaitForWindowShown(window);
 
-        QImage screenshot = canvas->grabFrameBuffer();
+        QImage screenshot = window->grabWindow();
         screenshots[fillMode] = screenshot;
-        delete canvas;
+        delete window;
     }
 
     foreach (QQuickImage::FillMode fillMode, fillModes) {
@@ -504,7 +504,7 @@ void tst_qquickimage::tiling_QTBUG_6716()
     QQuickImage *tiling = findItem<QQuickImage>(view.rootObject(), "tiling");
 
     QVERIFY(tiling != 0);
-    QImage img = view.grabFrameBuffer();
+    QImage img = view.grabWindow();
     for (int x = 0; x < tiling->width(); ++x) {
         for (int y = 0; y < tiling->height(); ++y) {
             QVERIFY(img.pixel(x, y) == qRgb(0, 255, 0));
@@ -638,13 +638,13 @@ void tst_qquickimage::sourceSize_QTBUG_14303()
 
 void tst_qquickimage::sourceSize_QTBUG_16389()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("qtbug_16389.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("qtbug_16389.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickImage *image = findItem<QQuickImage>(canvas->rootObject(), "iconImage");
-    QQuickItem *handle = findItem<QQuickItem>(canvas->rootObject(), "blueHandle");
+    QQuickImage *image = findItem<QQuickImage>(window->rootObject(), "iconImage");
+    QQuickItem *handle = findItem<QQuickItem>(window->rootObject(), "blueHandle");
 
     QCOMPARE(image->sourceSize().width(), 200);
     QCOMPARE(image->sourceSize().height(), 200);
@@ -658,7 +658,7 @@ void tst_qquickimage::sourceSize_QTBUG_16389()
     QCOMPARE(image->paintedWidth(), 20.0);
     QCOMPARE(image->paintedHeight(), 20.0);
 
-    delete canvas;
+    delete window;
 }
 
 static int numberOfWarnings = 0;
@@ -671,23 +671,23 @@ static void checkWarnings(QtMsgType, const char *msg)
 // QTBUG-15690
 void tst_qquickimage::nullPixmapPaint()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("nullpixmap.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("nullpixmap.qml"));
+    window->show();
 
-    QQuickImage *image = qobject_cast<QQuickImage*>(canvas->rootObject());
+    QQuickImage *image = qobject_cast<QQuickImage*>(window->rootObject());
     QTRY_VERIFY(image != 0);
     image->setSource(SERVER_ADDR + QString("/no-such-file.png"));
 
     QtMsgHandler previousMsgHandler = qInstallMsgHandler(checkWarnings);
 
     // used to print "QTransform::translate with NaN called"
-    QPixmap pm = QPixmap::fromImage(canvas->grabFrameBuffer());
+    QPixmap pm = QPixmap::fromImage(window->grabWindow());
     qInstallMsgHandler(previousMsgHandler);
     QVERIFY(numberOfWarnings == 0);
     delete image;
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickimage::imageCrash_QTBUG_22125()
@@ -732,16 +732,16 @@ void tst_qquickimage::sourceSize()
     QFETCH(qreal, implicitWidth);
     QFETCH(qreal, implicitHeight);
 
-    QQuickView *canvas = new QQuickView(0);
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = new QQuickView(0);
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("srcWidth", sourceWidth);
     ctxt->setContextProperty("srcHeight", sourceHeight);
 
-    canvas->setSource(testFileUrl("sourceSize.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("sourceSize.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickImage *image = qobject_cast<QQuickImage*>(canvas->rootObject());
+    QQuickImage *image = qobject_cast<QQuickImage*>(window->rootObject());
     QVERIFY(image);
 
     QCOMPARE(image->sourceSize().width(), sourceWidth);
@@ -749,7 +749,7 @@ void tst_qquickimage::sourceSize()
     QCOMPARE(image->implicitWidth(), implicitWidth);
     QCOMPARE(image->implicitHeight(), implicitHeight);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickimage::sourceSizeChanges()
diff --git a/tests/auto/quick/qquickitem/tst_qquickitem.cpp b/tests/auto/quick/qquickitem/tst_qquickitem.cpp
index 6a13f41..0eb9d3e 100644
--- a/tests/auto/quick/qquickitem/tst_qquickitem.cpp
+++ b/tests/auto/quick/qquickitem/tst_qquickitem.cpp
@@ -42,7 +42,7 @@
 #include <qtest.h>
 
 #include <QtQuick/qquickitem.h>
-#include <QtQuick/qquickcanvas.h>
+#include <QtQuick/qquickwindow.h>
 #include <QtQuick/qquickview.h>
 #include <QtWidgets/QGraphicsSceneMouseEvent>
 #include "private/qquickfocusscope_p.h"
@@ -78,16 +78,16 @@ protected:
     virtual void wheelEvent(QWheelEvent *event) { event->accept(); ++wheelCount; }
 };
 
-class TestCanvas: public QQuickCanvas
+class TestWindow: public QQuickWindow
 {
 public:
-    TestCanvas()
-        : QQuickCanvas()
+    TestWindow()
+        : QQuickWindow()
     {}
 
     virtual bool event(QEvent *event)
     {
-        return QQuickCanvas::event(event);
+        return QQuickWindow::event(event);
     }
 };
 
@@ -133,10 +133,10 @@ public:
 private slots:
     void initTestCase();
 
-    void noCanvas();
+    void noWindow();
     void simpleFocus();
     void scopedFocus();
-    void addedToCanvas();
+    void addedToWindow();
     void changeParent();
     void multipleFocusClears();
     void focusSubItemInNonFocusScope();
@@ -186,8 +186,8 @@ void tst_qquickitem::initTestCase()
     qmlRegisterType<TestPolishItem>("Qt.test", 1, 0, "TestPolishItem");
 }
 
-// Focus still updates when outside a canvas
-void tst_qquickitem::noCanvas()
+// Focus still updates when outside a window
+void tst_qquickitem::noWindow()
 {
     QQuickItem *root = new TestItem;
     QQuickItem *child = new TestItem(root);
@@ -247,13 +247,13 @@ struct FocusState : public QHash<QQuickItem *, FocusData>
 #define FVERIFY() \
     do { \
         if (focusState.activeFocusItem) { \
-            QCOMPARE(canvas.activeFocusItem(), focusState.activeFocusItem); \
-            if (qobject_cast<TestItem *>(canvas.activeFocusItem())) \
-                QCOMPARE(qobject_cast<TestItem *>(canvas.activeFocusItem())->focused, true); \
-            else if (qobject_cast<TestFocusScope *>(canvas.activeFocusItem())) \
-                QCOMPARE(qobject_cast<TestFocusScope *>(canvas.activeFocusItem())->focused, true); \
+            QCOMPARE(window.activeFocusItem(), focusState.activeFocusItem); \
+            if (qobject_cast<TestItem *>(window.activeFocusItem())) \
+                QCOMPARE(qobject_cast<TestItem *>(window.activeFocusItem())->focused, true); \
+            else if (qobject_cast<TestFocusScope *>(window.activeFocusItem())) \
+                QCOMPARE(qobject_cast<TestFocusScope *>(window.activeFocusItem())->focused, true); \
         } else { \
-            QCOMPARE(canvas.activeFocusItem(), canvas.rootItem()); \
+            QCOMPARE(window.activeFocusItem(), window.rootItem()); \
         } \
         for (QHash<QQuickItem *, FocusData>::Iterator iter = focusState.begin(); \
             iter != focusState.end(); \
@@ -266,18 +266,18 @@ struct FocusState : public QHash<QQuickItem *, FocusData>
 // Tests a simple set of top-level scoped items
 void tst_qquickitem::simpleFocus()
 {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
 
 #ifdef Q_OS_MAC
     QSKIP("QTBUG-24094: fails on Mac OS X 10.7");
 #endif
 
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
 
-    QQuickItem *l1c1 = new TestItem(canvas.rootItem());
-    QQuickItem *l1c2 = new TestItem(canvas.rootItem());
-    QQuickItem *l1c3 = new TestItem(canvas.rootItem());
+    QQuickItem *l1c1 = new TestItem(window.rootItem());
+    QQuickItem *l1c2 = new TestItem(window.rootItem());
+    QQuickItem *l1c3 = new TestItem(window.rootItem());
 
     QQuickItem *l2c1 = new TestItem(l1c1);
     QQuickItem *l2c2 = new TestItem(l1c1);
@@ -322,13 +322,13 @@ void tst_qquickitem::simpleFocus()
 // Items with a focus scope
 void tst_qquickitem::scopedFocus()
 {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
 
-    QQuickItem *l1c1 = new TestItem(canvas.rootItem());
-    QQuickItem *l1c2 = new TestItem(canvas.rootItem());
-    QQuickItem *l1c3 = new TestItem(canvas.rootItem());
+    QQuickItem *l1c1 = new TestItem(window.rootItem());
+    QQuickItem *l1c2 = new TestItem(window.rootItem());
+    QQuickItem *l1c3 = new TestItem(window.rootItem());
 
     QQuickItem *l2c1 = new TestItem(l1c1);
     QQuickItem *l2c2 = new TestItem(l1c1);
@@ -398,13 +398,13 @@ void tst_qquickitem::scopedFocus()
     FVERIFY();
 }
 
-// Tests focus corrects itself when a tree is added to a canvas for the first time
-void tst_qquickitem::addedToCanvas()
+// Tests focus corrects itself when a tree is added to a window for the first time
+void tst_qquickitem::addedToWindow()
 {
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
 
     QQuickItem *item = new TestItem;
 
@@ -415,18 +415,18 @@ void tst_qquickitem::addedToCanvas()
     focusState[item].set(true, false);
     FVERIFY();
 
-    item->setParentItem(canvas.rootItem());
+    item->setParentItem(window.rootItem());
     focusState[item].set(true, true);
     focusState.active(item);
     FVERIFY();
     }
 
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
 
-    QQuickItem *item = new TestItem(canvas.rootItem());
+    QQuickItem *item = new TestItem(window.rootItem());
 
     QQuickItem *tree = new TestItem;
     QQuickItem *c1 = new TestItem(tree);
@@ -451,9 +451,9 @@ void tst_qquickitem::addedToCanvas()
     }
 
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
 
     QQuickItem *tree = new TestItem;
     QQuickItem *c1 = new TestItem(tree);
@@ -467,7 +467,7 @@ void tst_qquickitem::addedToCanvas()
     focusState[c2].set(true, false);
     FVERIFY();
 
-    tree->setParentItem(canvas.rootItem());
+    tree->setParentItem(window.rootItem());
     focusState[c1].set(false, false);
     focusState[c2].set(true, true);
     focusState.active(c2);
@@ -475,9 +475,9 @@ void tst_qquickitem::addedToCanvas()
     }
 
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
     QQuickItem *tree = new TestFocusScope;
     QQuickItem *c1 = new TestItem(tree);
     QQuickItem *c2 = new TestItem(tree);
@@ -490,7 +490,7 @@ void tst_qquickitem::addedToCanvas()
     focusState[c2].set(true, false);
     FVERIFY();
 
-    tree->setParentItem(canvas.rootItem());
+    tree->setParentItem(window.rootItem());
     focusState[c1].set(false, false);
     focusState[c2].set(true, false);
     FVERIFY();
@@ -503,9 +503,9 @@ void tst_qquickitem::addedToCanvas()
     }
 
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
     QQuickItem *tree = new TestFocusScope;
     QQuickItem *c1 = new TestItem(tree);
     QQuickItem *c2 = new TestItem(tree);
@@ -520,7 +520,7 @@ void tst_qquickitem::addedToCanvas()
     focusState[c2].set(true, false);
     FVERIFY();
 
-    tree->setParentItem(canvas.rootItem());
+    tree->setParentItem(window.rootItem());
     focusState[tree].set(true, true);
     focusState[c1].set(false, false);
     focusState[c2].set(true, true);
@@ -529,10 +529,10 @@ void tst_qquickitem::addedToCanvas()
     }
 
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
-    QQuickItem *child = new TestItem(canvas.rootItem());
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
+    QQuickItem *child = new TestItem(window.rootItem());
     QQuickItem *tree = new TestFocusScope;
     QQuickItem *c1 = new TestItem(tree);
     QQuickItem *c2 = new TestItem(tree);
@@ -550,7 +550,7 @@ void tst_qquickitem::addedToCanvas()
     focusState.active(child);
     FVERIFY();
 
-    tree->setParentItem(canvas.rootItem());
+    tree->setParentItem(window.rootItem());
     focusState[tree].set(false, false);
     focusState[c1].set(false, false);
     focusState[c2].set(true, false);
@@ -569,10 +569,10 @@ void tst_qquickitem::changeParent()
 {
     // Parent to no parent
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
-    QQuickItem *child = new TestItem(canvas.rootItem());
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
+    QQuickItem *child = new TestItem(window.rootItem());
 
     FocusState focusState;
     focusState << child;
@@ -591,11 +591,11 @@ void tst_qquickitem::changeParent()
 
     // Different parent, same focus scope
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
-    QQuickItem *child = new TestItem(canvas.rootItem());
-    QQuickItem *child2 = new TestItem(canvas.rootItem());
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
+    QQuickItem *child = new TestItem(window.rootItem());
+    QQuickItem *child2 = new TestItem(window.rootItem());
 
     FocusState focusState;
     focusState << child << child2;
@@ -612,11 +612,11 @@ void tst_qquickitem::changeParent()
 
     // Different parent, different focus scope
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
-    QQuickItem *child = new TestItem(canvas.rootItem());
-    QQuickItem *child2 = new TestFocusScope(canvas.rootItem());
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
+    QQuickItem *child = new TestItem(window.rootItem());
+    QQuickItem *child2 = new TestFocusScope(window.rootItem());
     QQuickItem *item = new TestItem(child);
 
     FocusState focusState;
@@ -634,11 +634,11 @@ void tst_qquickitem::changeParent()
     FVERIFY();
     }
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
-    QQuickItem *child = new TestItem(canvas.rootItem());
-    QQuickItem *child2 = new TestFocusScope(canvas.rootItem());
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
+    QQuickItem *child = new TestItem(window.rootItem());
+    QQuickItem *child2 = new TestFocusScope(window.rootItem());
     QQuickItem *item = new TestItem(child2);
 
     FocusState focusState;
@@ -656,11 +656,11 @@ void tst_qquickitem::changeParent()
     FVERIFY();
     }
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
-    QQuickItem *child = new TestItem(canvas.rootItem());
-    QQuickItem *child2 = new TestFocusScope(canvas.rootItem());
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
+    QQuickItem *child = new TestItem(window.rootItem());
+    QQuickItem *child2 = new TestFocusScope(window.rootItem());
     QQuickItem *item = new TestItem(child2);
 
     FocusState focusState;
@@ -682,10 +682,10 @@ void tst_qquickitem::changeParent()
     // child has active focus, then its fs parent changes parent to 0, then
     // child is deleted, then its parent changes again to a valid parent
     {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
-    QQuickItem *item = new TestFocusScope(canvas.rootItem());
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
+    QQuickItem *item = new TestFocusScope(window.rootItem());
     QQuickItem *child = new TestItem(item);
     QQuickItem *child2 = new TestItem;
 
@@ -708,7 +708,7 @@ void tst_qquickitem::changeParent()
 
     focusState.remove(child);
     delete child;
-    item->setParentItem(canvas.rootItem());
+    item->setParentItem(window.rootItem());
     focusState[item].set(true, true);
     focusState.active(item);
     FVERIFY();
@@ -754,9 +754,9 @@ void tst_qquickitem::focusSubItemInNonFocusScope()
 
 void tst_qquickitem::parentItemWithFocus()
 {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
     {
     QQuickItem parent;
     QQuickItem child;
@@ -776,7 +776,7 @@ void tst_qquickitem::parentItemWithFocus()
     focusState[&child].set(false, false);
     FVERIFY();
 
-    parent.setParentItem(canvas.rootItem());
+    parent.setParentItem(window.rootItem());
     focusState[&parent].set(true, true);
     focusState[&child].set(false, false);
     focusState.active(&parent);
@@ -809,7 +809,7 @@ void tst_qquickitem::parentItemWithFocus()
     focusState[&grandchild].set(false, false);
     FVERIFY();
 
-    parent.setParentItem(canvas.rootItem());
+    parent.setParentItem(window.rootItem());
     focusState[&parent].set(true, true);
     focusState[&child].set(false, false);
     focusState[&grandchild].set(false, false);
@@ -853,11 +853,11 @@ void tst_qquickitem::parentItemWithFocus()
 
 void tst_qquickitem::reparentFocusedItem()
 {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == &canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == &window);
 
-    QQuickItem parent(canvas.rootItem());
+    QQuickItem parent(window.rootItem());
     QQuickItem child(&parent);
     QQuickItem sibling(&parent);
     QQuickItem grandchild(&child);
@@ -1022,8 +1022,8 @@ void tst_qquickitem::enabled()
 
 void tst_qquickitem::enabledFocus()
 {
-    QQuickCanvas canvas;
-    ensureFocus(&canvas);
+    QQuickWindow window;
+    ensureFocus(&window);
 
     QQuickFocusScope root;
 
@@ -1034,18 +1034,18 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(root.hasFocus(), true);
     QCOMPARE(root.hasActiveFocus(), false);
 
-    root.setParentItem(canvas.rootItem());
+    root.setParentItem(window.rootItem());
 
     QCOMPARE(root.isEnabled(), false);
     QCOMPARE(root.hasFocus(), true);
     QCOMPARE(root.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), canvas.rootItem());
+    QCOMPARE(window.activeFocusItem(), window.rootItem());
 
     root.setEnabled(true);
     QCOMPARE(root.isEnabled(), true);
     QCOMPARE(root.hasFocus(), true);
     QCOMPARE(root.hasActiveFocus(), true);
-    QCOMPARE(canvas.activeFocusItem(), static_cast<QQuickItem *>(&root));
+    QCOMPARE(window.activeFocusItem(), static_cast<QQuickItem *>(&root));
 
     QQuickItem child1;
     child1.setParentItem(&root);
@@ -1053,7 +1053,7 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child1.isEnabled(), true);
     QCOMPARE(child1.hasFocus(), false);
     QCOMPARE(child1.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), static_cast<QQuickItem *>(&root));
+    QCOMPARE(window.activeFocusItem(), static_cast<QQuickItem *>(&root));
 
     QQuickItem child2;
     child2.setFocus(true);
@@ -1065,7 +1065,7 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child2.isEnabled(), true);
     QCOMPARE(child2.hasFocus(), true);
     QCOMPARE(child2.hasActiveFocus(), true);
-    QCOMPARE(canvas.activeFocusItem(), &child2);
+    QCOMPARE(window.activeFocusItem(), &child2);
 
     child2.setEnabled(false);
 
@@ -1078,7 +1078,7 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child2.isEnabled(), false);
     QCOMPARE(child2.hasFocus(), true);
     QCOMPARE(child2.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), static_cast<QQuickItem *>(&root));
+    QCOMPARE(window.activeFocusItem(), static_cast<QQuickItem *>(&root));
 
     child1.setEnabled(false);
     QCOMPARE(child1.isEnabled(), false);
@@ -1092,13 +1092,13 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child2.isEnabled(), false);
     QCOMPARE(child2.hasFocus(), false);
     QCOMPARE(child2.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), static_cast<QQuickItem *>(&root));
+    QCOMPARE(window.activeFocusItem(), static_cast<QQuickItem *>(&root));
 
     child1.setEnabled(true);
     QCOMPARE(child1.isEnabled(), true);
     QCOMPARE(child1.hasFocus(), true);
     QCOMPARE(child1.hasActiveFocus(), true);
-    QCOMPARE(canvas.activeFocusItem(), static_cast<QQuickItem *>(&child1));
+    QCOMPARE(window.activeFocusItem(), static_cast<QQuickItem *>(&child1));
 
     root.setFocus(false);
     QCOMPARE(root.isEnabled(), true);
@@ -1107,7 +1107,7 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child1.isEnabled(), true);
     QCOMPARE(child1.hasFocus(), true);
     QCOMPARE(child1.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), canvas.rootItem());
+    QCOMPARE(window.activeFocusItem(), window.rootItem());
 
     child2.forceActiveFocus();
     QCOMPARE(root.isEnabled(), true);
@@ -1119,7 +1119,7 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child2.isEnabled(), false);
     QCOMPARE(child2.hasFocus(), true);
     QCOMPARE(child2.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), static_cast<QQuickItem *>(&root));
+    QCOMPARE(window.activeFocusItem(), static_cast<QQuickItem *>(&root));
 
     root.setEnabled(false);
     QCOMPARE(root.isEnabled(), false);
@@ -1131,7 +1131,7 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child2.isEnabled(), false);
     QCOMPARE(child2.hasFocus(), true);
     QCOMPARE(child2.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), canvas.rootItem());
+    QCOMPARE(window.activeFocusItem(), window.rootItem());
 
     child1.forceActiveFocus();
     QCOMPARE(root.isEnabled(), false);
@@ -1143,7 +1143,7 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child2.isEnabled(), false);
     QCOMPARE(child2.hasFocus(), false);
     QCOMPARE(child2.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), canvas.rootItem());
+    QCOMPARE(window.activeFocusItem(), window.rootItem());
 
     root.setEnabled(true);
     QCOMPARE(root.isEnabled(), true);
@@ -1155,83 +1155,83 @@ void tst_qquickitem::enabledFocus()
     QCOMPARE(child2.isEnabled(), false);
     QCOMPARE(child2.hasFocus(), false);
     QCOMPARE(child2.hasActiveFocus(), false);
-    QCOMPARE(canvas.activeFocusItem(), static_cast<QQuickItem *>(&child1));
+    QCOMPARE(window.activeFocusItem(), static_cast<QQuickItem *>(&child1));
 }
 
 void tst_qquickitem::mouseGrab()
 {
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(200, 200);
-    canvas->show();
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(200, 200);
+    window->show();
 
     TestItem *child1 = new TestItem;
     child1->setAcceptedMouseButtons(Qt::LeftButton);
     child1->setSize(QSizeF(200, 100));
-    child1->setParentItem(canvas->rootItem());
+    child1->setParentItem(window->rootItem());
 
     TestItem *child2 = new TestItem;
     child2->setAcceptedMouseButtons(Qt::LeftButton);
     child2->setY(51);
     child2->setSize(QSizeF(200, 100));
-    child2->setParentItem(canvas->rootItem());
+    child2->setParentItem(window->rootItem());
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(100);
-    QVERIFY(canvas->mouseGrabberItem() == child1);
+    QVERIFY(window->mouseGrabberItem() == child1);
     QTest::qWait(100);
 
     QCOMPARE(child1->pressCount, 1);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
-    QVERIFY(canvas->mouseGrabberItem() == 0);
+    QVERIFY(window->mouseGrabberItem() == 0);
     QCOMPARE(child1->releaseCount, 1);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
-    QVERIFY(canvas->mouseGrabberItem() == child1);
+    QVERIFY(window->mouseGrabberItem() == child1);
     QCOMPARE(child1->pressCount, 2);
     child1->setEnabled(false);
-    QVERIFY(canvas->mouseGrabberItem() == 0);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QVERIFY(window->mouseGrabberItem() == 0);
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
     QCOMPARE(child1->releaseCount, 1);
     child1->setEnabled(true);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
-    QVERIFY(canvas->mouseGrabberItem() == child1);
+    QVERIFY(window->mouseGrabberItem() == child1);
     QCOMPARE(child1->pressCount, 3);
     child1->setVisible(false);
-    QVERIFY(canvas->mouseGrabberItem() == 0);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QVERIFY(window->mouseGrabberItem() == 0);
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50,50));
     QCOMPARE(child1->releaseCount, 1);
     child1->setVisible(true);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
-    QVERIFY(canvas->mouseGrabberItem() == child1);
+    QVERIFY(window->mouseGrabberItem() == child1);
     QCOMPARE(child1->pressCount, 4);
     child2->grabMouse();
-    QVERIFY(canvas->mouseGrabberItem() == child2);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QVERIFY(window->mouseGrabberItem() == child2);
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
     QCOMPARE(child1->releaseCount, 1);
     QCOMPARE(child2->releaseCount, 1);
 
     child2->grabMouse();
-    QVERIFY(canvas->mouseGrabberItem() == child2);
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QVERIFY(window->mouseGrabberItem() == child2);
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
     QCOMPARE(child1->pressCount, 4);
     QCOMPARE(child2->pressCount, 1);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50,50));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50,50));
     QTest::qWait(50);
     QCOMPARE(child1->releaseCount, 1);
     QCOMPARE(child2->releaseCount, 2);
 
     delete child1;
     delete child2;
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickitem::touchEventAcceptIgnore_data()
@@ -1246,13 +1246,13 @@ void tst_qquickitem::touchEventAcceptIgnore()
 {
     QFETCH(bool, itemSupportsTouch);
 
-    TestCanvas *canvas = new TestCanvas;
-    canvas->resize(100, 100);
-    canvas->show();
+    TestWindow *window = new TestWindow;
+    window->resize(100, 100);
+    window->show();
 
     TestItem *item = new TestItem;
     item->setSize(QSizeF(100, 100));
-    item->setParentItem(canvas->rootItem());
+    item->setParentItem(window->rootItem());
     item->acceptIncomingTouchEvents = itemSupportsTouch;
 
     static QTouchDevice* device = 0;
@@ -1278,7 +1278,7 @@ void tst_qquickitem::touchEventAcceptIgnore()
 
         item->touchEventReached = false;
 
-        bool accepted = canvas->event(&event);
+        bool accepted = window->event(&event);
 
         QVERIFY(item->touchEventReached);
         QCOMPARE(accepted && event.isAccepted(), itemSupportsTouch);
@@ -1298,7 +1298,7 @@ void tst_qquickitem::touchEventAcceptIgnore()
 
         item->touchEventReached = false;
 
-        bool accepted = canvas->event(&event);
+        bool accepted = window->event(&event);
 
         QCOMPARE(item->touchEventReached, itemSupportsTouch);
         QCOMPARE(accepted && event.isAccepted(), itemSupportsTouch);
@@ -1318,23 +1318,23 @@ void tst_qquickitem::touchEventAcceptIgnore()
 
         item->touchEventReached = false;
 
-        bool accepted = canvas->event(&event);
+        bool accepted = window->event(&event);
 
         QCOMPARE(item->touchEventReached, itemSupportsTouch);
         QCOMPARE(accepted && event.isAccepted(), itemSupportsTouch);
     }
 
     delete item;
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickitem::polishOutsideAnimation()
 {
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(200, 200);
-    canvas->show();
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(200, 200);
+    window->show();
 
-    TestPolishItem *item = new TestPolishItem(canvas->rootItem());
+    TestPolishItem *item = new TestPolishItem(window->rootItem());
     item->setSize(QSizeF(200, 100));
     QTest::qWait(50);
 
@@ -1342,7 +1342,7 @@ void tst_qquickitem::polishOutsideAnimation()
     QTRY_VERIFY(item->wasPolished);
 
     delete item;
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickitem::polishOnCompleted()
@@ -1377,20 +1377,20 @@ void tst_qquickitem::wheelEvent()
 
     const bool shouldReceiveWheelEvents = visible && enabled;
 
-    QQuickCanvas *canvas = new QQuickCanvas;
-    canvas->resize(200, 200);
-    canvas->show();
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(200, 200);
+    window->show();
 
     TestItem *item = new TestItem;
     item->setSize(QSizeF(200, 100));
-    item->setParentItem(canvas->rootItem());
+    item->setParentItem(window->rootItem());
 
     item->setEnabled(enabled);
     item->setVisible(visible);
 
     QWheelEvent event(QPoint(100, 50), -120, Qt::NoButton, Qt::NoModifier, Qt::Vertical);
     event.setAccepted(false);
-    QGuiApplication::sendEvent(canvas, &event);
+    QGuiApplication::sendEvent(window, &event);
 
     if (shouldReceiveWheelEvents) {
         QVERIFY(event.isAccepted());
@@ -1400,7 +1400,7 @@ void tst_qquickitem::wheelEvent()
         QCOMPARE(item->wheelCount, 0);
     }
 
-    delete canvas;
+    delete window;
 }
 
 class HoverItem : public QQuickItem
@@ -1463,13 +1463,13 @@ void tst_qquickitem::hoverEvent()
     QFETCH(bool, enabled);
     QFETCH(bool, acceptHoverEvents);
 
-    QQuickCanvas *canvas = new QQuickCanvas();
-    canvas->resize(200, 200);
-    canvas->show();
+    QQuickWindow *window = new QQuickWindow();
+    window->resize(200, 200);
+    window->show();
 
     HoverItem *item = new HoverItem;
     item->setSize(QSizeF(100, 100));
-    item->setParentItem(canvas->rootItem());
+    item->setParentItem(window->rootItem());
 
     item->setEnabled(enabled);
     item->setVisible(visible);
@@ -1479,14 +1479,14 @@ void tst_qquickitem::hoverEvent()
     const QPoint inside(50, 50);
     const QPoint anotherInside(51, 51);
 
-    sendMouseMove(canvas, outside);
+    sendMouseMove(window, outside);
     item->resetCounters();
 
     // Enter, then move twice inside, then leave.
-    sendMouseMove(canvas, inside);
-    sendMouseMove(canvas, anotherInside);
-    sendMouseMove(canvas, inside);
-    sendMouseMove(canvas, outside);
+    sendMouseMove(window, inside);
+    sendMouseMove(window, anotherInside);
+    sendMouseMove(window, inside);
+    sendMouseMove(window, outside);
 
     const bool shouldReceiveHoverEvents = visible && enabled && acceptHoverEvents;
     if (shouldReceiveHoverEvents) {
@@ -1499,16 +1499,16 @@ void tst_qquickitem::hoverEvent()
         QCOMPARE(item->hoverLeaveCount, 0);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickitem::hoverEventInParent()
 {
-    QQuickCanvas *canvas = new QQuickCanvas();
-    canvas->resize(200, 200);
-    canvas->show();
+    QQuickWindow *window = new QQuickWindow();
+    window->resize(200, 200);
+    window->show();
 
-    HoverItem *parentItem = new HoverItem(canvas->rootItem());
+    HoverItem *parentItem = new HoverItem(window->rootItem());
     parentItem->setSize(QSizeF(200, 200));
     parentItem->setAcceptHoverEvents(true);
 
@@ -1524,12 +1524,12 @@ void tst_qquickitem::hoverEventInParent()
     const QPoint insideLeft(50, 100);
     const QPoint insideRight(150, 100);
 
-    sendMouseMove(canvas, insideLeft);
+    sendMouseMove(window, insideLeft);
     parentItem->resetCounters();
     leftItem->resetCounters();
     rightItem->resetCounters();
 
-    sendMouseMove(canvas, insideRight);
+    sendMouseMove(window, insideRight);
     QCOMPARE(parentItem->hoverEnterCount, 0);
     QCOMPARE(parentItem->hoverLeaveCount, 0);
     QCOMPARE(leftItem->hoverEnterCount, 0);
@@ -1537,7 +1537,7 @@ void tst_qquickitem::hoverEventInParent()
     QCOMPARE(rightItem->hoverEnterCount, 1);
     QCOMPARE(rightItem->hoverLeaveCount, 0);
 
-    sendMouseMove(canvas, insideLeft);
+    sendMouseMove(window, insideLeft);
     QCOMPARE(parentItem->hoverEnterCount, 0);
     QCOMPARE(parentItem->hoverLeaveCount, 0);
     QCOMPARE(leftItem->hoverEnterCount, 1);
@@ -1545,7 +1545,7 @@ void tst_qquickitem::hoverEventInParent()
     QCOMPARE(rightItem->hoverEnterCount, 1);
     QCOMPARE(rightItem->hoverLeaveCount, 1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickitem::paintOrder_data()
@@ -1667,58 +1667,58 @@ void tst_qquickitem::acceptedMouseButtons()
     TestItem item;
     QCOMPARE(item.acceptedMouseButtons(), Qt::MouseButtons(Qt::NoButton));
 
-    QQuickCanvas canvas;
+    QQuickWindow window;
     item.setSize(QSizeF(200,100));
-    item.setParentItem(canvas.rootItem());
+    item.setParentItem(window.rootItem());
 
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 0);
     QCOMPARE(item.releaseCount, 0);
 
-    QTest::mousePress(&canvas, Qt::RightButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::RightButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::RightButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::RightButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 0);
     QCOMPARE(item.releaseCount, 0);
 
-    QTest::mousePress(&canvas, Qt::MiddleButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::MiddleButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::MiddleButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::MiddleButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 0);
     QCOMPARE(item.releaseCount, 0);
 
     item.setAcceptedMouseButtons(Qt::LeftButton);
     QCOMPARE(item.acceptedMouseButtons(), Qt::MouseButtons(Qt::LeftButton));
 
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 1);
     QCOMPARE(item.releaseCount, 1);
 
-    QTest::mousePress(&canvas, Qt::RightButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::RightButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::RightButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::RightButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 1);
     QCOMPARE(item.releaseCount, 1);
 
-    QTest::mousePress(&canvas, Qt::MiddleButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::MiddleButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::MiddleButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::MiddleButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 1);
     QCOMPARE(item.releaseCount, 1);
 
     item.setAcceptedMouseButtons(Qt::RightButton | Qt::MiddleButton);
     QCOMPARE(item.acceptedMouseButtons(), Qt::MouseButtons(Qt::RightButton | Qt::MiddleButton));
 
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 1);
     QCOMPARE(item.releaseCount, 1);
 
-    QTest::mousePress(&canvas, Qt::RightButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::RightButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::RightButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::RightButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 2);
     QCOMPARE(item.releaseCount, 2);
 
-    QTest::mousePress(&canvas, Qt::MiddleButton, 0, QPoint(50, 50));
-    QTest::mouseRelease(&canvas, Qt::MiddleButton, 0, QPoint(50, 50));
+    QTest::mousePress(&window, Qt::MiddleButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(&window, Qt::MiddleButton, 0, QPoint(50, 50));
     QCOMPARE(item.pressCount, 3);
     QCOMPARE(item.releaseCount, 3);
 }
diff --git a/tests/auto/quick/qquickitem2/tst_qquickitem.cpp b/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
index a3fa3f6..c1cc942 100644
--- a/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
+++ b/tests/auto/quick/qquickitem2/tst_qquickitem.cpp
@@ -273,26 +273,26 @@ void tst_QQuickItem::cleanup()
 
 void tst_QQuickItem::keys()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
     KeysTestObject *testObject = new KeysTestObject;
-    canvas->rootContext()->setContextProperty("keysTestObject", testObject);
+    window->rootContext()->setContextProperty("keysTestObject", testObject);
 
-    canvas->rootContext()->setContextProperty("enableKeyHanding", QVariant(true));
-    canvas->rootContext()->setContextProperty("forwardeeVisible", QVariant(true));
+    window->rootContext()->setContextProperty("enableKeyHanding", QVariant(true));
+    window->rootContext()->setContextProperty("forwardeeVisible", QVariant(true));
 
-    canvas->setSource(testFileUrl("keystest.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    window->setSource(testFileUrl("keystest.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    QVERIFY(canvas->rootObject());
-    QCOMPARE(canvas->rootObject()->property("isEnabled").toBool(), true);
+    QVERIFY(window->rootObject());
+    QCOMPARE(window->rootObject()->property("isEnabled").toBool(), true);
 
     QKeyEvent key(QEvent::KeyPress, Qt::Key_A, Qt::NoModifier, "A", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_A));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_A));
     QCOMPARE(testObject->mText, QLatin1String("A"));
@@ -302,7 +302,7 @@ void tst_QQuickItem::keys()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyRelease, Qt::Key_A, Qt::ShiftModifier, "A", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_A));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_A));
     QCOMPARE(testObject->mText, QLatin1String("A"));
@@ -312,7 +312,7 @@ void tst_QQuickItem::keys()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_Return));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_Return));
     QCOMPARE(testObject->mText, QLatin1String("Return"));
@@ -322,7 +322,7 @@ void tst_QQuickItem::keys()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_0, Qt::NoModifier, "0", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_0));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_0));
     QCOMPARE(testObject->mText, QLatin1String("0"));
@@ -332,7 +332,7 @@ void tst_QQuickItem::keys()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_9, Qt::NoModifier, "9", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_9));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_9));
     QCOMPARE(testObject->mText, QLatin1String("9"));
@@ -342,7 +342,7 @@ void tst_QQuickItem::keys()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Tab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_Tab));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_Tab));
     QCOMPARE(testObject->mText, QLatin1String("Tab"));
@@ -352,7 +352,7 @@ void tst_QQuickItem::keys()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Backtab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_Backtab));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_Backtab));
     QCOMPARE(testObject->mText, QLatin1String("Backtab"));
@@ -362,7 +362,7 @@ void tst_QQuickItem::keys()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_VolumeUp, Qt::NoModifier, 1234, 0, 0);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_VolumeUp));
     QCOMPARE(testObject->mForwardedKey, int(Qt::Key_VolumeUp));
     QVERIFY(testObject->mModifiers == Qt::NoModifier);
@@ -371,9 +371,9 @@ void tst_QQuickItem::keys()
 
     testObject->reset();
 
-    canvas->rootContext()->setContextProperty("forwardeeVisible", QVariant(false));
+    window->rootContext()->setContextProperty("forwardeeVisible", QVariant(false));
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_A, Qt::NoModifier, "A", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_A));
     QCOMPARE(testObject->mForwardedKey, 0);
     QCOMPARE(testObject->mText, QLatin1String("A"));
@@ -382,47 +382,47 @@ void tst_QQuickItem::keys()
 
     testObject->reset();
 
-    canvas->rootContext()->setContextProperty("enableKeyHanding", QVariant(false));
-    QCOMPARE(canvas->rootObject()->property("isEnabled").toBool(), false);
+    window->rootContext()->setContextProperty("enableKeyHanding", QVariant(false));
+    QCOMPARE(window->rootObject()->property("isEnabled").toBool(), false);
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, 0);
     QVERIFY(!key.isAccepted());
 
-    canvas->rootContext()->setContextProperty("enableKeyHanding", QVariant(true));
-    QCOMPARE(canvas->rootObject()->property("isEnabled").toBool(), true);
+    window->rootContext()->setContextProperty("enableKeyHanding", QVariant(true));
+    QCOMPARE(window->rootObject()->property("isEnabled").toBool(), true);
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_Return));
     QVERIFY(key.isAccepted());
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 void tst_QQuickItem::keysProcessingOrder()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
     KeysTestObject *testObject = new KeysTestObject;
-    canvas->rootContext()->setContextProperty("keysTestObject", testObject);
+    window->rootContext()->setContextProperty("keysTestObject", testObject);
 
-    canvas->setSource(testFileUrl("keyspriority.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    window->setSource(testFileUrl("keyspriority.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    KeyTestItem *testItem = qobject_cast<KeyTestItem*>(canvas->rootObject());
+    KeyTestItem *testItem = qobject_cast<KeyTestItem*>(window->rootObject());
     QVERIFY(testItem);
 
     QCOMPARE(testItem->property("priorityTest").toInt(), 0);
 
     QKeyEvent key(QEvent::KeyPress, Qt::Key_A, Qt::NoModifier, "A", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_A));
     QCOMPARE(testObject->mText, QLatin1String("A"));
     QVERIFY(testObject->mModifiers == Qt::NoModifier);
@@ -435,14 +435,14 @@ void tst_QQuickItem::keysProcessingOrder()
     QCOMPARE(testItem->property("priorityTest").toInt(), 1);
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_A, Qt::NoModifier, "A", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, 0);
     QVERIFY(key.isAccepted());
 
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_B, Qt::NoModifier, "B", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, int(Qt::Key_B));
     QCOMPARE(testObject->mText, QLatin1String("B"));
     QVERIFY(testObject->mModifiers == Qt::NoModifier);
@@ -451,11 +451,11 @@ void tst_QQuickItem::keysProcessingOrder()
     testObject->reset();
 
     key = QKeyEvent(QEvent::KeyRelease, Qt::Key_B, Qt::NoModifier, "B", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QCOMPARE(testObject->mKey, 0);
     QVERIFY(key.isAccepted());
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
@@ -465,19 +465,19 @@ void tst_QQuickItem::keysim()
     QInputMethodPrivate *inputMethodPrivate = QInputMethodPrivate::get(qApp->inputMethod());
     inputMethodPrivate->testContext = &platformInputContext;
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
-    canvas->setSource(testFileUrl("keysim.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    window->setSource(testFileUrl("keysim.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    QVERIFY(canvas->rootObject());
-    QVERIFY(canvas->rootObject()->hasFocus() && canvas->rootObject()->hasActiveFocus());
+    QVERIFY(window->rootObject());
+    QVERIFY(window->rootObject()->hasFocus() && window->rootObject()->hasActiveFocus());
 
-    QQuickTextInput *input = canvas->rootObject()->findChild<QQuickTextInput*>();
+    QQuickTextInput *input = window->rootObject()->findChild<QQuickTextInput*>();
     QVERIFY(input);
 
     QInputMethodEvent ev("Hello world!", QList<QInputMethodEvent::Attribute>());
@@ -486,7 +486,7 @@ void tst_QQuickItem::keysim()
     QEXPECT_FAIL("", "QTBUG-24280", Continue);
     QCOMPARE(input->text(), QLatin1String("Hello world!"));
 
-    delete canvas;
+    delete window;
 }
 
 QQuickItemPrivate *childPrivate(QQuickItem *rootItem, const char * itemString)
@@ -511,11 +511,11 @@ bool anchorsMirrored(QQuickItem *rootItem, const char * itemString)
 
 void tst_QQuickItem::layoutMirroring()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("layoutmirroring.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("layoutmirroring.qml"));
+    window->show();
 
-    QQuickItem *rootItem = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootItem);
     QQuickItemPrivate *rootPrivate = QQuickItemPrivate::get(rootItem);
     QVERIFY(rootPrivate);
@@ -650,93 +650,93 @@ void tst_QQuickItem::layoutMirroringIllegalParent()
 
 void tst_QQuickItem::keyNavigation()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
-    canvas->setSource(testFileUrl("keynavigationtest.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    window->setSource(testFileUrl("keynavigationtest.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    QQuickItem *item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    QQuickItem *item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     QVariant result;
-    QVERIFY(QMetaObject::invokeMethod(canvas->rootObject(), "verify",
+    QVERIFY(QMetaObject::invokeMethod(window->rootObject(), "verify",
             Q_RETURN_ARG(QVariant, result)));
     QVERIFY(result.toBool());
 
     // right
     QKeyEvent key(QEvent::KeyPress, Qt::Key_Right, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item2");
+    item = findItem<QQuickItem>(window->rootObject(), "item2");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // down
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Down, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item4");
+    item = findItem<QQuickItem>(window->rootObject(), "item4");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // left
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Left, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item3");
+    item = findItem<QQuickItem>(window->rootObject(), "item3");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // up
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Up, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // tab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Tab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item2");
+    item = findItem<QQuickItem>(window->rootObject(), "item2");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // backtab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Backtab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::keyNavigation_RightToLeft()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
-    canvas->setSource(testFileUrl("keynavigationtest.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    window->setSource(testFileUrl("keynavigationtest.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    QQuickItem *rootItem = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootItem);
     QQuickItemPrivate* rootItemPrivate = QQuickItemPrivate::get(rootItem);
 
@@ -746,240 +746,240 @@ void tst_QQuickItem::keyNavigation_RightToLeft()
     rootItemPrivate->resolveLayoutMirror();
 
     QEvent wa(QEvent::WindowActivate);
-    QGuiApplication::sendEvent(canvas, &wa);
+    QGuiApplication::sendEvent(window, &wa);
     QFocusEvent fe(QEvent::FocusIn);
-    QGuiApplication::sendEvent(canvas, &fe);
+    QGuiApplication::sendEvent(window, &fe);
 
-    QQuickItem *item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    QQuickItem *item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     QVariant result;
-    QVERIFY(QMetaObject::invokeMethod(canvas->rootObject(), "verify",
+    QVERIFY(QMetaObject::invokeMethod(window->rootObject(), "verify",
             Q_RETURN_ARG(QVariant, result)));
     QVERIFY(result.toBool());
 
     // right
     QKeyEvent key(QEvent::KeyPress, Qt::Key_Left, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item2");
+    item = findItem<QQuickItem>(window->rootObject(), "item2");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // left
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Right, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::keyNavigation_skipNotVisible()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
-    canvas->setSource(testFileUrl("keynavigationtest.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    window->setSource(testFileUrl("keynavigationtest.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    QQuickItem *item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    QQuickItem *item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // Set item 2 to not visible
-    item = findItem<QQuickItem>(canvas->rootObject(), "item2");
+    item = findItem<QQuickItem>(window->rootObject(), "item2");
     QVERIFY(item);
     item->setVisible(false);
     QVERIFY(!item->isVisible());
 
     // right
     QKeyEvent key(QEvent::KeyPress, Qt::Key_Right, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // tab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Tab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item3");
+    item = findItem<QQuickItem>(window->rootObject(), "item3");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // backtab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Backtab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     //Set item 3 to not visible
-    item = findItem<QQuickItem>(canvas->rootObject(), "item3");
+    item = findItem<QQuickItem>(window->rootObject(), "item3");
     QVERIFY(item);
     item->setVisible(false);
     QVERIFY(!item->isVisible());
 
     // tab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Tab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item4");
+    item = findItem<QQuickItem>(window->rootObject(), "item4");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // backtab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Backtab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::keyNavigation_implicitSetting()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
-    canvas->setSource(testFileUrl("keynavigationtest_implicit.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    window->setSource(testFileUrl("keynavigationtest_implicit.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
     QEvent wa(QEvent::WindowActivate);
-    QGuiApplication::sendEvent(canvas, &wa);
+    QGuiApplication::sendEvent(window, &wa);
     QFocusEvent fe(QEvent::FocusIn);
-    QGuiApplication::sendEvent(canvas, &fe);
+    QGuiApplication::sendEvent(window, &fe);
 
-    QQuickItem *item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    QQuickItem *item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     QVariant result;
-    QVERIFY(QMetaObject::invokeMethod(canvas->rootObject(), "verify",
+    QVERIFY(QMetaObject::invokeMethod(window->rootObject(), "verify",
             Q_RETURN_ARG(QVariant, result)));
     QVERIFY(result.toBool());
 
     // right
     QKeyEvent key(QEvent::KeyPress, Qt::Key_Right, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item2");
+    item = findItem<QQuickItem>(window->rootObject(), "item2");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // back to item1
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Left, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // down
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Down, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item3");
+    item = findItem<QQuickItem>(window->rootObject(), "item3");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // move to item4
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Right, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item4");
+    item = findItem<QQuickItem>(window->rootObject(), "item4");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // left
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Left, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item3");
+    item = findItem<QQuickItem>(window->rootObject(), "item3");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // back to item4
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Right, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item4");
+    item = findItem<QQuickItem>(window->rootObject(), "item4");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // up
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Up, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item2");
+    item = findItem<QQuickItem>(window->rootObject(), "item2");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // back to item4
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Down, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item4");
+    item = findItem<QQuickItem>(window->rootObject(), "item4");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // tab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Tab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item1");
+    item = findItem<QQuickItem>(window->rootObject(), "item1");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // back to item4
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Backtab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item4");
+    item = findItem<QQuickItem>(window->rootObject(), "item4");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
     // backtab
     key = QKeyEvent(QEvent::KeyPress, Qt::Key_Backtab, Qt::NoModifier, "", false, 1);
-    QGuiApplication::sendEvent(canvas, &key);
+    QGuiApplication::sendEvent(window, &key);
     QVERIFY(key.isAccepted());
 
-    item = findItem<QQuickItem>(canvas->rootObject(), "item3");
+    item = findItem<QQuickItem>(window->rootObject(), "item3");
     QVERIFY(item);
     QVERIFY(item->hasActiveFocus());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::smooth()
@@ -1046,17 +1046,17 @@ void tst_QQuickItem::mapCoordinates()
     QFETCH(int, x);
     QFETCH(int, y);
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(300, 300));
-    canvas->setSource(testFileUrl("mapCoordinates.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(300, 300));
+    window->setSource(testFileUrl("mapCoordinates.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root != 0);
-    QQuickItem *a = findItem<QQuickItem>(canvas->rootObject(), "itemA");
+    QQuickItem *a = findItem<QQuickItem>(window->rootObject(), "itemA");
     QVERIFY(a != 0);
-    QQuickItem *b = findItem<QQuickItem>(canvas->rootObject(), "itemB");
+    QQuickItem *b = findItem<QQuickItem>(window->rootObject(), "itemB");
     QVERIFY(b != 0);
 
     QVariant result;
@@ -1090,7 +1090,7 @@ void tst_QQuickItem::mapCoordinates()
             Q_RETURN_ARG(QVariant, result), Q_ARG(QVariant, x), Q_ARG(QVariant, y)));
     QVERIFY(result.toBool());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::mapCoordinates_data()
@@ -1109,17 +1109,17 @@ void tst_QQuickItem::mapCoordinatesRect()
     QFETCH(int, width);
     QFETCH(int, height);
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(300, 300));
-    canvas->setSource(testFileUrl("mapCoordinatesRect.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(300, 300));
+    window->setSource(testFileUrl("mapCoordinatesRect.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root != 0);
-    QQuickItem *a = findItem<QQuickItem>(canvas->rootObject(), "itemA");
+    QQuickItem *a = findItem<QQuickItem>(window->rootObject(), "itemA");
     QVERIFY(a != 0);
-    QQuickItem *b = findItem<QQuickItem>(canvas->rootObject(), "itemB");
+    QQuickItem *b = findItem<QQuickItem>(window->rootObject(), "itemB");
     QVERIFY(b != 0);
 
     QVariant result;
@@ -1153,7 +1153,7 @@ void tst_QQuickItem::mapCoordinatesRect()
             Q_RETURN_ARG(QVariant, result), Q_ARG(QVariant, x), Q_ARG(QVariant, y), Q_ARG(QVariant, width), Q_ARG(QVariant, height)));
     QVERIFY(result.toBool());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::mapCoordinatesRect_data()
@@ -1224,16 +1224,16 @@ void tst_QQuickItem::resourcesProperty()
 
 void tst_QQuickItem::propertyChanges()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(300, 300));
-    canvas->setSource(testFileUrl("propertychanges.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(300, 300));
+    window->setSource(testFileUrl("propertychanges.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    QQuickItem *item = findItem<QQuickItem>(canvas->rootObject(), "item");
-    QQuickItem *parentItem = findItem<QQuickItem>(canvas->rootObject(), "parentItem");
+    QQuickItem *item = findItem<QQuickItem>(window->rootObject(), "item");
+    QQuickItem *parentItem = findItem<QQuickItem>(window->rootObject(), "parentItem");
 
     QVERIFY(item);
     QVERIFY(parentItem);
@@ -1301,17 +1301,17 @@ void tst_QQuickItem::propertyChanges()
     QCOMPARE(item->y(), 10.0);
     QCOMPARE(ySpy.count(), 1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::childrenRect()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("childrenRect.qml"));
-    canvas->setBaseSize(QSize(240,320));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("childrenRect.qml"));
+    window->setBaseSize(QSize(240,320));
+    window->show();
 
-    QQuickItem *o = canvas->rootObject();
+    QQuickItem *o = window->rootObject();
     QQuickItem *item = o->findChild<QQuickItem*>("testItem");
     QCOMPARE(item->width(), qreal(0));
     QCOMPARE(item->height(), qreal(0));
@@ -1329,34 +1329,34 @@ void tst_QQuickItem::childrenRect()
     QCOMPARE(item->height(), qreal(0));
 
     delete o;
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-11383
 void tst_QQuickItem::childrenRectBug()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
     QString warning = testFileUrl("childrenRectBug.qml").toString() + ":7:5: QML Item: Binding loop detected for property \"height\"";
     QTest::ignoreMessage(QtWarningMsg, qPrintable(warning));
     QTest::ignoreMessage(QtWarningMsg, qPrintable(warning));
 
-    canvas->setSource(testFileUrl("childrenRectBug.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("childrenRectBug.qml"));
+    window->show();
 
-    QQuickItem *o = canvas->rootObject();
+    QQuickItem *o = window->rootObject();
     QQuickItem *item = o->findChild<QQuickItem*>("theItem");
     QCOMPARE(item->width(), qreal(200));
     QCOMPARE(item->height(), qreal(100));
     QCOMPARE(item->x(), qreal(100));
 
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-11465
 void tst_QQuickItem::childrenRectBug2()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
     QString warning1 = testFileUrl("childrenRectBug2.qml").toString() + ":7:5: QML Item: Binding loop detected for property \"width\"";
     QTest::ignoreMessage(QtWarningMsg, qPrintable(warning1));
@@ -1368,10 +1368,10 @@ void tst_QQuickItem::childrenRectBug2()
     QTest::ignoreMessage(QtWarningMsg, qPrintable(warning2));
     QTest::ignoreMessage(QtWarningMsg, qPrintable(warning2));
 
-    canvas->setSource(testFileUrl("childrenRectBug2.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("childrenRectBug2.qml"));
+    window->show();
 
-    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(canvas->rootObject());
+    QQuickRectangle *rect = qobject_cast<QQuickRectangle*>(window->rootObject());
     QVERIFY(rect);
     QQuickItem *item = rect->findChild<QQuickItem*>("theItem");
     QCOMPARE(item->width(), qreal(100));
@@ -1384,37 +1384,37 @@ void tst_QQuickItem::childrenRectBug2()
     QCOMPARE(item->height(), qreal(50));
     QCOMPARE(item->x(), qreal(75));
 
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-12722
 void tst_QQuickItem::childrenRectBug3()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("childrenRectBug3.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("childrenRectBug3.qml"));
+    window->show();
 
     //don't crash on delete
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-13893
 void tst_QQuickItem::transformCrash()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("transformCrash.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("transformCrash.qml"));
+    window->show();
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::implicitSize()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("implicitsize.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("implicitsize.qml"));
+    window->show();
 
-    QQuickItem *item = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *item = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(item);
     QCOMPARE(item->width(), qreal(80));
     QCOMPARE(item->height(), qreal(60));
@@ -1476,7 +1476,7 @@ void tst_QQuickItem::implicitSize()
     QCOMPARE(item->width(), qreal(150));
     QCOMPARE(item->height(), qreal(80));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::qtbug_16871()
@@ -1490,11 +1490,11 @@ void tst_QQuickItem::qtbug_16871()
 
 void tst_QQuickItem::visibleChildren()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl("visiblechildren.qml"));
-    canvas->show();
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl("visiblechildren.qml"));
+    window->show();
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root);
 
     QCOMPARE(root->property("test1_1").toBool(), true);
@@ -1544,17 +1544,17 @@ void tst_QQuickItem::visibleChildren()
     QCOMPARE(root->property("test8_4").toBool(), true);
     QCOMPARE(root->property("test8_5").toBool(), true);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::parentLoop()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
     QTest::ignoreMessage(QtWarningMsg, "QQuickItem::setParentItem: Parent is already part of this items subtree.");
-    canvas->setSource(testFileUrl("parentLoop.qml"));
+    window->setSource(testFileUrl("parentLoop.qml"));
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root);
 
     QQuickItem *item1 = root->findChild<QQuickItem*>("item1");
@@ -1565,7 +1565,7 @@ void tst_QQuickItem::parentLoop()
     QVERIFY(item2);
     QCOMPARE(item2->parentItem(), item1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickItem::contains_data()
@@ -1636,16 +1636,16 @@ void tst_QQuickItem::contains()
     QFETCH(bool, insideTarget);
     QFETCH(QList<QPoint>, points);
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->rootContext()->setContextProperty("circleShapeTest", circleTest);
-    canvas->setBaseSize(QSize(400, 400));
-    canvas->setSource(testFileUrl("hollowTestItem.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_VERIFY(QGuiApplication::focusWindow() == canvas);
+    QQuickView *window = new QQuickView(0);
+    window->rootContext()->setContextProperty("circleShapeTest", circleTest);
+    window->setBaseSize(QSize(400, 400));
+    window->setSource(testFileUrl("hollowTestItem.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_VERIFY(QGuiApplication::focusWindow() == window);
 
-    QQuickItem *root = qobject_cast<QQuickItem *>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem *>(window->rootObject());
     QVERIFY(root);
 
     HollowTestItem *hollowItem = root->findChild<HollowTestItem *>("hollowItem");
@@ -1653,22 +1653,22 @@ void tst_QQuickItem::contains()
 
     foreach (const QPoint &point, points) {
         // check mouse hover
-        QTest::mouseMove(canvas, point);
+        QTest::mouseMove(window, point);
         QTest::qWait(10);
         QCOMPARE(hollowItem->isHovered(), insideTarget);
 
         // check mouse press
-        QTest::mousePress(canvas, Qt::LeftButton, 0, point);
+        QTest::mousePress(window, Qt::LeftButton, 0, point);
         QTest::qWait(10);
         QCOMPARE(hollowItem->isPressed(), insideTarget);
 
         // check mouse release
-        QTest::mouseRelease(canvas, Qt::LeftButton, 0, point);
+        QTest::mouseRelease(window, Qt::LeftButton, 0, point);
         QTest::qWait(10);
         QCOMPARE(hollowItem->isPressed(), false);
     }
 
-    delete canvas;
+    delete window;
 }
 
 
diff --git a/tests/auto/quick/qquickitemlayer/tst_qquickitemlayer.cpp b/tests/auto/quick/qquickitemlayer/tst_qquickitemlayer.cpp
index a8bf69e..020a77c 100644
--- a/tests/auto/quick/qquickitemlayer/tst_qquickitemlayer.cpp
+++ b/tests/auto/quick/qquickitemlayer/tst_qquickitemlayer.cpp
@@ -61,7 +61,7 @@ public:
         view.show();
         QTest::qWaitForWindowShown(&view);
 
-        return view.grabFrameBuffer();
+        return view.grabWindow();
     }
 
 private slots:
@@ -268,7 +268,7 @@ void tst_QQuickItemLayer::layerVisibility()
 
     QTest::qWaitForWindowActive(&view);
 
-    QImage fb = view.grabFrameBuffer();
+    QImage fb = view.grabWindow();
     uint pixel = fb.pixel(0, 0);
 
     if (!visible || opacity == 0) {
@@ -312,7 +312,7 @@ void tst_QQuickItemLayer::layerZOrder()
 
     QTest::qWaitForWindowShown(&view);
 
-    QImage fb = view.grabFrameBuffer();
+    QImage fb = view.grabWindow();
 
     QCOMPARE(fb.pixel(50, 50), qRgb(0, 0, 0xff));
     QCOMPARE(fb.pixel(150, 150), qRgb(0, 0xff, 00));
@@ -349,7 +349,7 @@ void tst_QQuickItemLayer::changeZOrder()
 
     QTest::qWaitForWindowShown(&view);
 
-    QImage fb = view.grabFrameBuffer();
+    QImage fb = view.grabWindow();
 
     QRgb topLeft = fb.pixel(50, 50);
     QRgb topRight = fb.pixel(150, 50);
diff --git a/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp b/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
index e0c923e..6c68632 100644
--- a/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
+++ b/tests/auto/quick/qquicklistview/tst_qquicklistview.cpp
@@ -346,34 +346,34 @@ void tst_QQuickListView::cleanupTestCase()
 template <class T>
 void tst_QQuickListView::items(const QUrl &source, bool forceLayout)
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     T model;
     model.addItem("Fred", "12345");
     model.addItem("John", "2345");
     model.addItem("Bob", "54321");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(source);
+    window->setSource(source);
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QTRY_VERIFY(testObject->error() == false);
 
     QTRY_VERIFY(listview->highlightItem() != 0);
     QTRY_COMPARE(listview->count(), model.count());
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
     QTRY_COMPARE(contentItem->childItems().count(), model.count()+1); // assumes all are visible, +1 for the (default) highlight item
 
     // current item should be first item
@@ -390,20 +390,20 @@ void tst_QQuickListView::items(const QUrl &source, bool forceLayout)
 
     // switch to other delegate
     testObject->setAnimate(true);
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QTRY_VERIFY(testObject->error() == false);
     QTRY_VERIFY(listview->currentItem());
 
     // set invalid highlight
     testObject->setInvalidHighlight(true);
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QTRY_VERIFY(testObject->error() == false);
     QTRY_VERIFY(listview->currentItem());
     QTRY_VERIFY(listview->highlightItem() == 0);
 
     // back to normal highlight
     testObject->setInvalidHighlight(false);
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QTRY_VERIFY(testObject->error() == false);
     QTRY_VERIFY(listview->currentItem());
     QTRY_VERIFY(listview->highlightItem() != 0);
@@ -422,7 +422,7 @@ void tst_QQuickListView::items(const QUrl &source, bool forceLayout)
     QTRY_COMPARE(listview->highlightResizeVelocity(), 1000.0);
     QTRY_COMPARE(listview->highlightMoveVelocity(), 1000.0);
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
@@ -430,23 +430,23 @@ void tst_QQuickListView::items(const QUrl &source, bool forceLayout)
 template <class T>
 void tst_QQuickListView::changed(const QUrl &source, bool forceLayout)
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     T model;
     model.addItem("Fred", "12345");
     model.addItem("John", "2345");
     model.addItem("Bob", "54321");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(source);
+    window->setSource(source);
     qApp->processEvents();
 
-    QQuickFlickable *listview = findItem<QQuickFlickable>(canvas->rootObject(), "list");
+    QQuickFlickable *listview = findItem<QQuickFlickable>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -464,31 +464,31 @@ void tst_QQuickListView::changed(const QUrl &source, bool forceLayout)
     QTRY_VERIFY(number != 0);
     QTRY_COMPARE(number->text(), model.number(1));
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 template <class T>
 void tst_QQuickListView::inserted(const QUrl &source)
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     T model;
     model.addItem("Fred", "12345");
     model.addItem("John", "2345");
     model.addItem("Bob", "54321");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(source);
+    window->setSource(source);
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -496,7 +496,7 @@ void tst_QQuickListView::inserted(const QUrl &source)
 
     model.insertItem(1, "Will", "9876");
 
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
     QTRY_COMPARE(contentItem->childItems().count(), model.count()+1); // assumes all are visible, +1 for the (default) highlight item
 
     QQuickText *name = findItem<QQuickText>(contentItem, "textName", 1);
@@ -514,7 +514,7 @@ void tst_QQuickListView::inserted(const QUrl &source)
 
     model.insertItem(0, "Foo", "1111"); // zero index, and current item
 
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
     QTRY_COMPARE(contentItem->childItems().count(), model.count()+1); // assumes all are visible, +1 for the (default) highlight item
 
     name = findItem<QQuickText>(contentItem, "textName", 0);
@@ -555,14 +555,14 @@ void tst_QQuickListView::inserted(const QUrl &source)
     // QTBUG-19675
     model.clear();
     model.insertItem(0, "Hello", "1234");
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     QQuickItem *item = findItem<QQuickItem>(contentItem, "wrapper", 0);
     QVERIFY(item);
     QCOMPARE(item->y(), 0.);
     QTRY_VERIFY(listview->contentY() == 0);
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
@@ -578,19 +578,19 @@ void tst_QQuickListView::inserted_more(QQuickItemView::VerticalLayoutDirection v
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -648,7 +648,7 @@ void tst_QQuickListView::inserted_more(QQuickItemView::VerticalLayoutDirection v
         QTRY_COMPARE(number->text(), model.number(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -739,24 +739,24 @@ void tst_QQuickListView::insertBeforeVisible()
     QFETCH(int, cacheBuffer);
 
     QQuickText *name;
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -800,7 +800,7 @@ void tst_QQuickListView::insertBeforeVisible()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -830,31 +830,31 @@ void tst_QQuickListView::insertBeforeVisible_data()
 template <class T>
 void tst_QQuickListView::removed(const QUrl &source, bool /* animated */)
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     T model;
     for (int i = 0; i < 50; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(source);
-    canvas->show();
+    window->setSource(source);
+    window->show();
     qApp->processEvents();
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     model.removeItem(1);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     QQuickText *name = findItem<QQuickText>(contentItem, "textName", 1);
     QTRY_VERIFY(name != 0);
@@ -874,7 +874,7 @@ void tst_QQuickListView::removed(const QUrl &source, bool /* animated */)
 
     // Remove first item (which is the current item);
     model.removeItem(0);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     name = findItem<QQuickText>(contentItem, "textName", 0);
     QTRY_VERIFY(name != 0);
@@ -894,7 +894,7 @@ void tst_QQuickListView::removed(const QUrl &source, bool /* animated */)
 
     // Remove items not visible
     model.removeItem(18);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     // Confirm items positioned correctly
     itemCount = findItems<QQuickItem>(contentItem, "wrapper").count();
@@ -910,7 +910,7 @@ void tst_QQuickListView::removed(const QUrl &source, bool /* animated */)
     listview->setCurrentIndex(10);
 
     model.removeItem(1); // post: top item will be at 20
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     // Confirm items positioned correctly
     for (int i = 2; i < 18; ++i) {
@@ -1004,7 +1004,7 @@ void tst_QQuickListView::removed(const QUrl &source, bool /* animated */)
         model.removeItems(model.count() - 1, 1);
     QTRY_VERIFY(findItems<QQuickItem>(contentItem, "wrapper").count() > 16);
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
@@ -1016,24 +1016,24 @@ void tst_QQuickListView::removed_more(const QUrl &source, QQuickItemView::Vertic
     QFETCH(int, removeCount);
     QFETCH(qreal, itemsOffsetAfterMove);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     T model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(source);
-    canvas->show();
+    window->setSource(source);
+    window->show();
     qApp->processEvents();
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -1089,7 +1089,7 @@ void tst_QQuickListView::removed_more(const QUrl &source, QQuickItemView::Vertic
         QTRY_COMPARE(number->text(), model.number(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -1199,23 +1199,23 @@ void tst_QQuickListView::removed_more_data()
 template <class T>
 void tst_QQuickListView::clear(const QUrl &source, QQuickItemView::VerticalLayoutDirection verticalLayoutDirection)
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     T model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(source);
-    canvas->show();
+    window->setSource(source);
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -1242,7 +1242,7 @@ void tst_QQuickListView::clear(const QUrl &source, QQuickItemView::VerticalLayou
     QVERIFY(listview->currentItem() != 0);
     QVERIFY(listview->currentIndex() == 0);
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
@@ -1257,24 +1257,24 @@ void tst_QQuickListView::moved(const QUrl &source, QQuickItemView::VerticalLayou
 
     QQuickText *name;
     QQuickText *number;
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     T model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(source);
-    canvas->show();
+    window->setSource(source);
+    window->show();
     qApp->processEvents();
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -1326,7 +1326,7 @@ void tst_QQuickListView::moved(const QUrl &source, QQuickItemView::VerticalLayou
             QTRY_COMPARE(listview->currentIndex(), i);
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -1488,24 +1488,24 @@ void tst_QQuickListView::multipleChanges(bool condensed)
     QFETCH(int, newCount);
     QFETCH(int, newCurrentIndex);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QmlListModel model;
     for (int i = 0; i < startCount; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
@@ -1561,7 +1561,7 @@ void tst_QQuickListView::multipleChanges(bool condensed)
     }
 
     delete testObject;
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::multipleChanges_data()
@@ -1737,23 +1737,23 @@ void tst_QQuickListView::multipleChanges_data()
 
 void tst_QQuickListView::swapWithFirstItem()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
@@ -1763,25 +1763,25 @@ void tst_QQuickListView::swapWithFirstItem()
     QTRY_VERIFY(listview->contentY() == 0);
 
     delete testObject;
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::enforceRange()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("listview-enforcerange.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listview-enforcerange.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QTRY_COMPARE(listview->preferredHighlightBegin(), 100.0);
@@ -1817,7 +1817,7 @@ void tst_QQuickListView::enforceRange()
     ctxt->setContextProperty("testModel", &model2);
     QCOMPARE(listview->count(), 5);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::enforceRange_withoutHighlight()
@@ -1827,7 +1827,7 @@ void tst_QQuickListView::enforceRange_withoutHighlight()
     // to the correct position (i.e. to the next/previous item, not next/previous section)
     // when moving up/down via incrementCurrentIndex() and decrementCurrentIndex()
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     model.addItem("Item 0", "a");
@@ -1835,14 +1835,14 @@ void tst_QQuickListView::enforceRange_withoutHighlight()
     model.addItem("Item 2", "b");
     model.addItem("Item 3", "c");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("listview-enforcerange-nohighlight.qml"));
-    canvas->show();
-    QTest::qWaitForWindowExposed(canvas);
+    window->setSource(testFileUrl("listview-enforcerange-nohighlight.qml"));
+    window->show();
+    QTest::qWaitForWindowExposed(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
@@ -1852,40 +1852,40 @@ void tst_QQuickListView::enforceRange_withoutHighlight()
     QTRY_COMPARE(listview->contentY(), expectedPos);
 
     expectedPos += 20 + 10;     // scroll past 1st section and section delegate of 2nd section
-    QTest::keyClick(canvas, Qt::Key_Down);
+    QTest::keyClick(window, Qt::Key_Down);
 
     QTRY_COMPARE(listview->contentY(), expectedPos);
 
     expectedPos += 20;     // scroll past 1st item of 2nd section
-    QTest::keyClick(canvas, Qt::Key_Down);
+    QTest::keyClick(window, Qt::Key_Down);
     QTRY_COMPARE(listview->contentY(), expectedPos);
 
     expectedPos += 20 + 10;     // scroll past 2nd item of 2nd section and section delegate of 3rd section
-    QTest::keyClick(canvas, Qt::Key_Down);
+    QTest::keyClick(window, Qt::Key_Down);
     QTRY_COMPARE(listview->contentY(), expectedPos);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::spacing()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -1924,27 +1924,27 @@ void tst_QQuickListView::spacing()
         QTRY_COMPARE(item->y(), i*20.0);
     }
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 template <typename T>
 void tst_QQuickListView::sections(const QUrl &source)
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     T model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i/5));
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(source);
-    canvas->show();
+    window->setSource(source);
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -2023,25 +2023,25 @@ void tst_QQuickListView::sections(const QUrl &source)
     QTRY_VERIFY(item);
     QTRY_COMPARE(item->height(), 40.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::sectionsDelegate()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i/5));
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("listview-sections_delegate.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listview-sections_delegate.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -2108,7 +2108,7 @@ void tst_QQuickListView::sectionsDelegate()
     model.modifyItem(11, "Two", "aaa");
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
     QTRY_COMPARE(findItems<QQuickItem>(contentItem, "sect_aaa").count(), 1);
-    canvas->rootObject()->setProperty("sectionProperty", "name");
+    window->rootObject()->setProperty("sectionProperty", "name");
     // ensure view has settled.
     QTRY_COMPARE(findItems<QQuickItem>(contentItem, "sect_Four").count(), 1);
     for (int i = 0; i < 4; ++i) {
@@ -2118,7 +2118,7 @@ void tst_QQuickListView::sectionsDelegate()
         QTRY_COMPARE(item->y(), qreal(i*20*4));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::sectionsDragOutsideBounds_data()
@@ -2137,20 +2137,20 @@ void tst_QQuickListView::sectionsDragOutsideBounds()
     QFETCH(int, distance);
     QFETCH(int, cacheBuffer);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QmlListModel model;
     for (int i = 0; i < 10; i++)
         model.addItem("Item" + QString::number(i), QString::number(i/5));
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("listview-sections_delegate.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listview-sections_delegate.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     listview->setCacheBuffer(cacheBuffer);
 
@@ -2161,42 +2161,42 @@ void tst_QQuickListView::sectionsDragOutsideBounds()
 
     // QTBUG-17769
     // Drag view up beyond bounds
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(20,20));
-    QTest::mouseMove(canvas, QPoint(20,0));
-    QTest::mouseMove(canvas, QPoint(20,-50));
-    QTest::mouseMove(canvas, QPoint(20,-distance));
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(20,-distance));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(20,20));
+    QTest::mouseMove(window, QPoint(20,0));
+    QTest::mouseMove(window, QPoint(20,-50));
+    QTest::mouseMove(window, QPoint(20,-distance));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(20,-distance));
     // view should settle back at 0
     QTRY_COMPARE(listview->contentY(), 0.0);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(20,0));
-    QTest::mouseMove(canvas, QPoint(20,20));
-    QTest::mouseMove(canvas, QPoint(20,70));
-    QTest::mouseMove(canvas, QPoint(20,distance));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(20,0));
+    QTest::mouseMove(window, QPoint(20,20));
+    QTest::mouseMove(window, QPoint(20,70));
+    QTest::mouseMove(window, QPoint(20,distance));
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(20,distance));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(20,distance));
     // view should settle back at 0
     QTRY_COMPARE(listview->contentY(), 0.0);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::sectionsDelegate_headerVisibility()
 {
     QSKIP("QTBUG-24395");
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i/5));
 
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("listview-sections_delegate.qml"));
-    canvas->show();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->setSource(testFileUrl("listview-sections_delegate.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -2211,26 +2211,26 @@ void tst_QQuickListView::sectionsDelegate_headerVisibility()
     listview->setCurrentIndex(0);
     QTRY_COMPARE(listview->contentY(), 0.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::sectionsPositioning()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i/5));
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("listview-sections_delegate.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listview-sections_delegate.qml"));
+    window->show();
     qApp->processEvents();
-    canvas->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels | QQuickViewSection::CurrentLabelAtStart | QQuickViewSection::NextLabelAtEnd)));
+    window->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels | QQuickViewSection::CurrentLabelAtStart | QQuickViewSection::NextLabelAtEnd)));
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -2348,20 +2348,20 @@ void tst_QQuickListView::sectionsPositioning()
 
     // Turn sticky footer off
     listview->setContentY(20);
-    canvas->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels | QQuickViewSection::CurrentLabelAtStart)));
+    window->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels | QQuickViewSection::CurrentLabelAtStart)));
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
     QTRY_VERIFY(item = findVisibleChild(contentItem, "sect_new")); // inline label restored
     QCOMPARE(item->y(), 340.);
 
     // Turn sticky header off
     listview->setContentY(30);
-    canvas->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels)));
+    window->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels)));
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
     QTRY_VERIFY(item = findVisibleChild(contentItem, "sect_aaa")); // inline label restored
     QCOMPARE(item->y(), 0.);
 
     // if an empty model is set the header/footer should be cleaned up
-    canvas->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels | QQuickViewSection::CurrentLabelAtStart | QQuickViewSection::NextLabelAtEnd)));
+    window->rootObject()->setProperty("sectionPositioning", QVariant(int(QQuickViewSection::InlineLabels | QQuickViewSection::CurrentLabelAtStart | QQuickViewSection::NextLabelAtEnd)));
     QTRY_VERIFY(findVisibleChild(contentItem, "sect_aaa")); // section header
     QTRY_VERIFY(findVisibleChild(contentItem, "sect_new")); // section footer
     QmlListModel model1;
@@ -2377,18 +2377,18 @@ void tst_QQuickListView::sectionsPositioning()
     QTRY_VERIFY(!findVisibleChild(contentItem, "sect_aaa")); // section header
     QTRY_VERIFY(!findVisibleChild(contentItem, "sect_new")); // section footer
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::sectionPropertyChange()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("sectionpropertychange.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("sectionpropertychange.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -2403,7 +2403,7 @@ void tst_QQuickListView::sectionPropertyChange()
         QTRY_COMPARE(item->y(), qreal(25. + i*75.));
     }
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "switchGroups");
+    QMetaObject::invokeMethod(window->rootObject(), "switchGroups");
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     // Confirm items positioned correctly
@@ -2413,7 +2413,7 @@ void tst_QQuickListView::sectionPropertyChange()
         QTRY_COMPARE(item->y(), qreal(25. + i*75.));
     }
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "switchGroups");
+    QMetaObject::invokeMethod(window->rootObject(), "switchGroups");
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     // Confirm items positioned correctly
@@ -2423,7 +2423,7 @@ void tst_QQuickListView::sectionPropertyChange()
         QTRY_COMPARE(item->y(), qreal(25. + i*75.));
     }
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "switchGrouped");
+    QMetaObject::invokeMethod(window->rootObject(), "switchGrouped");
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     // Confirm items positioned correctly
@@ -2433,7 +2433,7 @@ void tst_QQuickListView::sectionPropertyChange()
         QTRY_COMPARE(item->y(), qreal(25. + i*50.));
     }
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "switchGrouped");
+    QMetaObject::invokeMethod(window->rootObject(), "switchGrouped");
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     // Confirm items positioned correctly
@@ -2443,18 +2443,18 @@ void tst_QQuickListView::sectionPropertyChange()
         QTRY_COMPARE(item->y(), qreal(25. + i*75.));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::sectionDelegateChange()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("sectiondelegatechange.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("sectiondelegatechange.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = qobject_cast<QQuickListView *>(canvas->rootObject());
+    QQuickListView *listview = qobject_cast<QQuickListView *>(window->rootObject());
     QVERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -2471,7 +2471,7 @@ void tst_QQuickListView::sectionDelegateChange()
         QTRY_COMPARE(item->y(), qreal(25. + i*50.));
     }
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "switchDelegates");
+    QMetaObject::invokeMethod(window->rootObject(), "switchDelegates");
     QQUICK_VERIFY_POLISH(listview);
 
     QCOMPARE(findItems<QQuickItem>(contentItem, "section1").count(), 0);
@@ -2483,23 +2483,23 @@ void tst_QQuickListView::sectionDelegateChange()
         QTRY_COMPARE(item->y(), qreal(50. + i*75.));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::currentIndex_delayedItemCreation()
 {
     QFETCH(bool, setCurrentToZero);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     // test currentIndexChanged() is emitted even if currentIndex = 0 on start up
     // (since the currentItem will have changed and that shares the same index)
-    canvas->rootContext()->setContextProperty("setCurrentToZero", setCurrentToZero);
+    window->rootContext()->setContextProperty("setCurrentToZero", setCurrentToZero);
 
-    canvas->setSource(testFileUrl("fillModelOnComponentCompleted.qml"));
+    window->setSource(testFileUrl("fillModelOnComponentCompleted.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -2508,7 +2508,7 @@ void tst_QQuickListView::currentIndex_delayedItemCreation()
     QCOMPARE(listview->currentIndex(), 0);
     QTRY_COMPARE(spy.count(), 1);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::currentIndex_delayedItemCreation_data()
@@ -2525,19 +2525,19 @@ void tst_QQuickListView::currentIndex()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i));
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testWrap", QVariant(false));
 
     QString filename(testFile("listview-initCurrent.qml"));
-    canvas->setSource(QUrl::fromLocalFile(filename));
-    canvas->show();
+    window->setSource(QUrl::fromLocalFile(filename));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -2556,22 +2556,22 @@ void tst_QQuickListView::currentIndex()
     QTRY_VERIFY(listview->verticalVelocity() != 0.0);
 
     // footer should become visible if it is out of view, and then current index is set to count-1
-    canvas->rootObject()->setProperty("showFooter", true);
+    window->rootObject()->setProperty("showFooter", true);
     QTRY_VERIFY(listview->footerItem());
     listview->setCurrentIndex(model.count()-2);
     QTRY_VERIFY(listview->footerItem()->y() > listview->contentY() + listview->height());
     listview->setCurrentIndex(model.count()-1);
     QTRY_COMPARE(listview->contentY() + listview->height(), (20.0 * model.count()) + listview->footerItem()->height());
-    canvas->rootObject()->setProperty("showFooter", false);
+    window->rootObject()->setProperty("showFooter", false);
 
     // header should become visible if it is out of view, and then current index is set to 0
-    canvas->rootObject()->setProperty("showHeader", true);
+    window->rootObject()->setProperty("showHeader", true);
     QTRY_VERIFY(listview->headerItem());
     listview->setCurrentIndex(1);
     QTRY_VERIFY(listview->headerItem()->y() + listview->headerItem()->height() < listview->contentY());
     listview->setCurrentIndex(0);
     QTRY_COMPARE(listview->contentY(), -listview->headerItem()->height());
-    canvas->rootObject()->setProperty("showHeader", false);
+    window->rootObject()->setProperty("showHeader", false);
 
     // turn off auto highlight
     listview->setHighlightFollowsCurrentItem(false);
@@ -2586,7 +2586,7 @@ void tst_QQuickListView::currentIndex()
     // insert item before currentIndex
     listview->setCurrentIndex(28);
     model.insertItem(0, "Foo", "1111");
-    QTRY_COMPARE(canvas->rootObject()->property("current").toInt(), 29);
+    QTRY_COMPARE(window->rootObject()->property("current").toInt(), 29);
 
     // check removing highlight by setting currentIndex to -1;
     listview->setCurrentIndex(-1);
@@ -2601,7 +2601,7 @@ void tst_QQuickListView::currentIndex()
     listview->setContentY(200);
     QTRY_VERIFY(!delegateVisible(listview->currentItem()));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::noCurrentIndex()
@@ -2610,18 +2610,18 @@ void tst_QQuickListView::noCurrentIndex()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i));
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     QString filename(testFile("listview-noCurrent.qml"));
-    canvas->setSource(QUrl::fromLocalFile(filename));
-    canvas->show();
+    window->setSource(QUrl::fromLocalFile(filename));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -2639,7 +2639,7 @@ void tst_QQuickListView::noCurrentIndex()
     QVERIFY(listview->highlightItem());
     QVERIFY(listview->currentItem());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::keyNavigation()
@@ -2656,15 +2656,15 @@ void tst_QQuickListView::keyNavigation()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
     TestObject *testObject = new TestObject;
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->rootContext()->setContextProperty("testObject", testObject);
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
-    QTest::qWaitForWindowActive(canvas);
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("testObject", testObject);
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
+    QTest::qWaitForWindowActive(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     listview->setOrientation(orientation);
@@ -2672,33 +2672,32 @@ void tst_QQuickListView::keyNavigation()
     listview->setVerticalLayoutDirection(verticalLayoutDirection);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowActive(canvas);
-    QTRY_VERIFY(qGuiApp->focusWindow() == canvas);
-    QCOMPARE(listview->currentIndex(), 0);
+    window->requestActivateWindow();
+    QTest::qWaitForWindowActive(window);
+    QTRY_VERIFY(qGuiApp->focusWindow() == window);
 
-    QTest::keyClick(canvas, forwardsKey);
+    QTest::keyClick(window, forwardsKey);
     QCOMPARE(listview->currentIndex(), 1);
 
-    QTest::keyClick(canvas, backwardsKey);
+    QTest::keyClick(window, backwardsKey);
     QCOMPARE(listview->currentIndex(), 0);
 
     // hold down a key to go forwards
     for (int i=0; i<model.count()-1; i++) {
-        QTest::simulateEvent(canvas, true, forwardsKey, Qt::NoModifier, "", true);
+        QTest::simulateEvent(window, true, forwardsKey, Qt::NoModifier, "", true);
         QTRY_COMPARE(listview->currentIndex(), i+1);
     }
-    QTest::keyRelease(canvas, forwardsKey);
+    QTest::keyRelease(window, forwardsKey);
     QTRY_COMPARE(listview->currentIndex(), model.count()-1);
     QTRY_COMPARE(listview->contentX(), contentPosAtLastItem.x());
     QTRY_COMPARE(listview->contentY(), contentPosAtLastItem.y());
 
     // hold down a key to go backwards
     for (int i=model.count()-1; i > 0; i--) {
-        QTest::simulateEvent(canvas, true, backwardsKey, Qt::NoModifier, "", true);
+        QTest::simulateEvent(window, true, backwardsKey, Qt::NoModifier, "", true);
         QTRY_COMPARE(listview->currentIndex(), i-1);
     }
-    QTest::keyRelease(canvas, backwardsKey);
+    QTest::keyRelease(window, backwardsKey);
     QTRY_COMPARE(listview->currentIndex(), 0);
     QTRY_COMPARE(listview->contentX(), contentPosAtFirstItem.x());
     QTRY_COMPARE(listview->contentY(), contentPosAtFirstItem.y());
@@ -2727,7 +2726,7 @@ void tst_QQuickListView::keyNavigation()
     QTRY_COMPARE(listview->contentX(), contentPosAtFirstItem.x());
     QTRY_COMPARE(listview->contentY(), contentPosAtFirstItem.y());
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -2768,18 +2767,18 @@ void tst_QQuickListView::keyNavigation_data()
 
 void tst_QQuickListView::itemList()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("itemlist.qml"));
-    canvas->show();
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("itemlist.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "view");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "view");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
 
-    QQuickVisualItemModel *model = canvas->rootObject()->findChild<QQuickVisualItemModel*>("itemModel");
+    QQuickVisualItemModel *model = window->rootObject()->findChild<QQuickVisualItemModel*>("itemModel");
     QTRY_VERIFY(model != 0);
 
     QTRY_VERIFY(model->count() == 3);
@@ -2804,23 +2803,23 @@ void tst_QQuickListView::itemList()
     QTRY_VERIFY(text);
     QTRY_COMPARE(text->text(), QLatin1String("index: 2"));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::itemListFlicker()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("itemlist-flicker.qml"));
-    canvas->show();
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("itemlist-flicker.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "view");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "view");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
 
-    QQuickVisualItemModel *model = canvas->rootObject()->findChild<QQuickVisualItemModel*>("itemModel");
+    QQuickVisualItemModel *model = window->rootObject()->findChild<QQuickVisualItemModel*>("itemModel");
     QTRY_VERIFY(model != 0);
 
     QTRY_VERIFY(model->count() == 3);
@@ -2853,28 +2852,28 @@ void tst_QQuickListView::itemListFlicker()
     QVERIFY(item = findItem<QQuickItem>(contentItem, "item3"));
     QVERIFY(delegateVisible(item));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::cacheBuffer()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 90; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -2893,7 +2892,7 @@ void tst_QQuickListView::cacheBuffer()
     }
 
     QQmlIncubationController controller;
-    canvas->engine()->setIncubationController(&controller);
+    window->engine()->setIncubationController(&controller);
 
     testObject->setCacheBuffer(200);
     QTRY_VERIFY(listview->cacheBuffer() == 200);
@@ -2953,28 +2952,28 @@ void tst_QQuickListView::cacheBuffer()
         controller.incubateWhile(&b);
     }
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 void tst_QQuickListView::positionViewAtIndex()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
-    canvas->show();
-    canvas->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -3100,7 +3099,7 @@ void tst_QQuickListView::positionViewAtIndex()
     QTRY_COMPARE(listview->contentY(), 0.);
 
     listview->setContentY(80);
-    canvas->rootObject()->setProperty("showHeader", true);
+    window->rootObject()->setProperty("showHeader", true);
     listview->positionViewAtBeginning();
     QTRY_COMPARE(listview->contentY(), -30.);
 
@@ -3109,7 +3108,7 @@ void tst_QQuickListView::positionViewAtIndex()
     QTRY_COMPARE(listview->contentY(), 480.); // 40*20 - 320
 
     listview->setContentY(80);
-    canvas->rootObject()->setProperty("showFooter", true);
+    window->rootObject()->setProperty("showFooter", true);
     listview->positionViewAtEnd();
     QTRY_COMPARE(listview->contentY(), 510.);
 
@@ -3121,26 +3120,26 @@ void tst_QQuickListView::positionViewAtIndex()
     QVERIFY(listview->highlightItem());
     QCOMPARE(listview->highlightItem()->y(), 20.);
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 void tst_QQuickListView::resetModel()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QStringList strings;
     strings << "one" << "two" << "three";
     QStringListModel model(strings);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("displaylist.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("displaylist.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -3166,16 +3165,16 @@ void tst_QQuickListView::resetModel()
         QTRY_COMPARE(display->text(), strings.at(i));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::propertyChanges()
 {
-    QQuickView *canvas = createView();
-    QTRY_VERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychangestest.qml"));
+    QQuickView *window = createView();
+    QTRY_VERIFY(window);
+    window->setSource(testFileUrl("propertychangestest.qml"));
 
-    QQuickListView *listView = canvas->rootObject()->findChild<QQuickListView*>("listView");
+    QQuickListView *listView = window->rootObject()->findChild<QQuickListView*>("listView");
     QTRY_VERIFY(listView);
 
     QSignalSpy highlightFollowsCurrentItemSpy(listView, SIGNAL(highlightFollowsCurrentItemChanged()));
@@ -3234,22 +3233,22 @@ void tst_QQuickListView::propertyChanges()
     QTRY_COMPARE(cacheBufferSpy.count(),1);
     QTRY_COMPARE(snapModeSpy.count(),1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::componentChanges()
 {
-    QQuickView *canvas = createView();
-    QTRY_VERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychangestest.qml"));
+    QQuickView *window = createView();
+    QTRY_VERIFY(window);
+    window->setSource(testFileUrl("propertychangestest.qml"));
 
-    QQuickListView *listView = canvas->rootObject()->findChild<QQuickListView*>("listView");
+    QQuickListView *listView = window->rootObject()->findChild<QQuickListView*>("listView");
     QTRY_VERIFY(listView);
 
-    QQmlComponent component(canvas->engine());
+    QQmlComponent component(window->engine());
     component.setData("import QtQuick 2.0; Rectangle { color: \"blue\"; }", QUrl::fromLocalFile(""));
 
-    QQmlComponent delegateComponent(canvas->engine());
+    QQmlComponent delegateComponent(window->engine());
     delegateComponent.setData("import QtQuick 2.0; Text { text: '<b>Name:</b> ' + name }", QUrl::fromLocalFile(""));
 
     QSignalSpy highlightSpy(listView, SIGNAL(highlightChanged()));
@@ -3282,19 +3281,19 @@ void tst_QQuickListView::componentChanges()
     QTRY_COMPARE(headerSpy.count(),1);
     QTRY_COMPARE(footerSpy.count(),1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::modelChanges()
 {
-    QQuickView *canvas = createView();
-    QTRY_VERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychangestest.qml"));
+    QQuickView *window = createView();
+    QTRY_VERIFY(window);
+    window->setSource(testFileUrl("propertychangestest.qml"));
 
-    QQuickListView *listView = canvas->rootObject()->findChild<QQuickListView*>("listView");
+    QQuickListView *listView = window->rootObject()->findChild<QQuickListView*>("listView");
     QTRY_VERIFY(listView);
 
-    QQuickListModel *alternateModel = canvas->rootObject()->findChild<QQuickListModel*>("alternateModel");
+    QQuickListModel *alternateModel = window->rootObject()->findChild<QQuickListModel*>("alternateModel");
     QTRY_VERIFY(alternateModel);
     QVariant modelVariant = QVariant::fromValue<QObject *>(alternateModel);
     QSignalSpy modelSpy(listView, SIGNAL(modelChanged()));
@@ -3309,17 +3308,17 @@ void tst_QQuickListView::modelChanges()
     listView->setModel(QVariant());
     QTRY_COMPARE(modelSpy.count(),2);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::QTBUG_9791()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("strictlyenforcerange.qml"));
+    window->setSource(testFileUrl("strictlyenforcerange.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = qobject_cast<QQuickListView*>(canvas->rootObject());
+    QQuickListView *listview = qobject_cast<QQuickListView*>(window->rootObject());
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -3344,20 +3343,20 @@ void tst_QQuickListView::QTBUG_9791()
     // check that view is positioned correctly
     QTRY_COMPARE(listview->contentX(), 590.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::manualHighlight()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
     QString filename(testFile("manual-highlight.qml"));
-    canvas->setSource(QUrl::fromLocalFile(filename));
+    window->setSource(QUrl::fromLocalFile(filename));
 
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -3380,28 +3379,28 @@ void tst_QQuickListView::manualHighlight()
     QTRY_COMPARE(listview->currentItem(), findItem<QQuickItem>(contentItem, "wrapper", 2));
     QTRY_COMPARE(listview->highlightItem()->y() - 5, listview->currentItem()->y());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::QTBUG_11105()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -3428,17 +3427,17 @@ void tst_QQuickListView::QTBUG_11105()
     itemCount = findItems<QQuickItem>(contentItem, "wrapper").count();
     QCOMPARE(itemCount, 5);
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 void tst_QQuickListView::initialZValues()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("initialZValues.qml"));
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("initialZValues.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -3449,7 +3448,7 @@ void tst_QQuickListView::initialZValues()
     QVERIFY(listview->footerItem());
     QTRY_COMPARE(listview->footerItem()->z(), listview->property("initialZ").toReal());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::header()
@@ -3468,15 +3467,15 @@ void tst_QQuickListView::header()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->rootContext()->setContextProperty("initialViewWidth", 240);
-    canvas->rootContext()->setContextProperty("initialViewHeight", 320);
-    canvas->setSource(testFileUrl("header.qml"));
-    canvas->show();
+    QQuickView *window = getView();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("initialViewWidth", 240);
+    window->rootContext()->setContextProperty("initialViewHeight", 320);
+    window->setSource(testFileUrl("header.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     listview->setOrientation(orientation);
     listview->setLayoutDirection(layoutDirection);
@@ -3516,7 +3515,7 @@ void tst_QQuickListView::header()
         model.addItem("Item" + QString::number(i), "");
 
     QSignalSpy headerItemSpy(listview, SIGNAL(headerItemChanged()));
-    QMetaObject::invokeMethod(canvas->rootObject(), "changeHeader");
+    QMetaObject::invokeMethod(window->rootObject(), "changeHeader");
 
     QCOMPARE(headerItemSpy.count(), 1);
 
@@ -3541,20 +3540,20 @@ void tst_QQuickListView::header()
     header->setWidth(40);
     QTRY_COMPARE(QPointF(listview->contentX(), listview->contentY()), resizeContentPos);
 
-    releaseView(canvas);
+    releaseView(window);
 
 
     // QTBUG-21207 header should become visible if view resizes from initial empty size
 
-    canvas = getView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->rootContext()->setContextProperty("initialViewWidth", 0.0);
-    canvas->rootContext()->setContextProperty("initialViewHeight", 0.0);
-    canvas->setSource(testFileUrl("header.qml"));
-    canvas->show();
+    window = getView();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("initialViewWidth", 0.0);
+    window->rootContext()->setContextProperty("initialViewHeight", 0.0);
+    window->setSource(testFileUrl("header.qml"));
+    window->show();
     qApp->processEvents();
 
-    listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     listview->setOrientation(orientation);
     listview->setLayoutDirection(layoutDirection);
@@ -3566,7 +3565,7 @@ void tst_QQuickListView::header()
     QTRY_COMPARE(listview->headerItem()->pos(), initialHeaderPos);
     QCOMPARE(QPointF(listview->contentX(), listview->contentY()), initialContentPos);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::header_data()
@@ -3634,15 +3633,15 @@ void tst_QQuickListView::header_data()
 
 void tst_QQuickListView::header_delayItemCreation()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
 
-    canvas->rootContext()->setContextProperty("setCurrentToZero", QVariant(false));
-    canvas->setSource(testFileUrl("fillModelOnComponentCompleted.qml"));
+    window->rootContext()->setContextProperty("setCurrentToZero", QVariant(false));
+    window->setSource(testFileUrl("fillModelOnComponentCompleted.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -3657,7 +3656,7 @@ void tst_QQuickListView::header_delayItemCreation()
     model.clear();
     QTRY_COMPARE(header->y(), -header->height());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::footer()
@@ -3672,20 +3671,20 @@ void tst_QQuickListView::footer()
     QFETCH(QPointF, changedContentPos);
     QFETCH(QPointF, resizeContentPos);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QmlListModel model;
     for (int i = 0; i < 3; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("footer.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("footer.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     listview->setOrientation(orientation);
     listview->setLayoutDirection(layoutDirection);
@@ -3740,16 +3739,16 @@ void tst_QQuickListView::footer()
     QTRY_COMPARE(footer->pos(), posWhenNoItems);
 
     // if header is present, it's at a negative pos, so the footer should not move
-    canvas->rootObject()->setProperty("showHeader", true);
+    window->rootObject()->setProperty("showHeader", true);
     QTRY_COMPARE(footer->pos(), posWhenNoItems);
-    canvas->rootObject()->setProperty("showHeader", false);
+    window->rootObject()->setProperty("showHeader", false);
 
     // add 30 items
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
     QSignalSpy footerItemSpy(listview, SIGNAL(footerItemChanged()));
-    QMetaObject::invokeMethod(canvas->rootObject(), "changeFooter");
+    QMetaObject::invokeMethod(window->rootObject(), "changeFooter");
 
     QCOMPARE(footerItemSpy.count(), 1);
 
@@ -3774,7 +3773,7 @@ void tst_QQuickListView::footer()
     footer->setWidth(40);
     QTRY_COMPARE(QPointF(listview->contentX(), listview->contentY()), resizeContentPos);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::footer_data()
@@ -3863,16 +3862,16 @@ void tst_QQuickListView::extents()
     QFETCH(QPointF, origin_empty);
     QFETCH(QPointF, origin_nonEmpty);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QmlListModel model;
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
-    canvas->setSource(testFileUrl("headerfooter.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("headerfooter.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = qobject_cast<QQuickListView*>(canvas->rootObject());
+    QQuickListView *listview = qobject_cast<QQuickListView*>(window->rootObject());
     QTRY_VERIFY(listview != 0);
     listview->setOrientation(orientation);
     listview->setLayoutDirection(layoutDirection);
@@ -3903,7 +3902,7 @@ void tst_QQuickListView::extents()
     QCOMPARE(listview->originX(), origin_nonEmpty.x());
     QCOMPARE(listview->originY(), origin_nonEmpty.y());
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::extents_data()
@@ -3950,18 +3949,18 @@ void tst_QQuickListView::resetModel_headerFooter()
 {
     // Resetting a model shouldn't crash in views with header/footer
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 4; i++)
         model.addItem("Item" + QString::number(i), "");
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("headerfooter.qml"));
+    window->setSource(testFileUrl("headerfooter.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = qobject_cast<QQuickListView*>(canvas->rootObject());
+    QQuickListView *listview = qobject_cast<QQuickListView*>(window->rootObject());
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -3985,28 +3984,28 @@ void tst_QQuickListView::resetModel_headerFooter()
     QVERIFY(footer);
     QCOMPARE(footer->y(), 30.*4);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::resizeView()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -4022,13 +4021,13 @@ void tst_QQuickListView::resizeView()
     }
 
     QVariant heightRatio;
-    QMetaObject::invokeMethod(canvas->rootObject(), "heightRatio", Q_RETURN_ARG(QVariant, heightRatio));
+    QMetaObject::invokeMethod(window->rootObject(), "heightRatio", Q_RETURN_ARG(QVariant, heightRatio));
     QCOMPARE(heightRatio.toReal(), 0.4);
 
     listview->setHeight(200);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "heightRatio", Q_RETURN_ARG(QVariant, heightRatio));
+    QMetaObject::invokeMethod(window->rootObject(), "heightRatio", Q_RETURN_ARG(QVariant, heightRatio));
     QCOMPARE(heightRatio.toReal(), 0.25);
 
     // Ensure we handle -ve sizes
@@ -4064,27 +4063,27 @@ void tst_QQuickListView::resizeView()
         QCOMPARE(delegateVisible(item), i < 6); // inside view visible, outside not visible
     }
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 void tst_QQuickListView::resizeViewAndRepaint()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 40; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("initialHeight", 100);
 
-    canvas->setSource(testFileUrl("resizeview.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("resizeview.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -4100,28 +4099,28 @@ void tst_QQuickListView::resizeViewAndRepaint()
     listview->setHeight(100);
     QTRY_VERIFY(!findItem<QQuickItem>(contentItem, "wrapper", 10));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::sizeLessThan1()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("sizelessthan1.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("sizelessthan1.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -4136,18 +4135,18 @@ void tst_QQuickListView::sizeLessThan1()
         QTRY_COMPARE(item->y(), i*0.5);
     }
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 void tst_QQuickListView::QTBUG_14821()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("qtbug14821.qml"));
+    window->setSource(testFileUrl("qtbug14821.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = qobject_cast<QQuickListView*>(canvas->rootObject());
+    QQuickListView *listview = qobject_cast<QQuickListView*>(window->rootObject());
     QVERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -4159,26 +4158,26 @@ void tst_QQuickListView::QTBUG_14821()
     listview->incrementCurrentIndex();
     QCOMPARE(listview->currentIndex(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::resizeDelegate()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QStringList strings;
     for (int i = 0; i < 30; ++i)
         strings << QString::number(i);
     QStringListModel model(strings);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("displaylist.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("displaylist.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QVERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
@@ -4199,7 +4198,7 @@ void tst_QQuickListView::resizeDelegate()
     QCOMPARE(listview->currentItem()->y(), 500.0);
     QTRY_COMPARE(listview->highlightItem()->y(), 500.0);
 
-    canvas->rootObject()->setProperty("delegateHeight", 30);
+    window->rootObject()->setProperty("delegateHeight", 30);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     for (int i = 0; i < 11; ++i) {
@@ -4225,7 +4224,7 @@ void tst_QQuickListView::resizeDelegate()
     QTRY_COMPARE(listview->currentItem()->y(), 30.0);
     QTRY_COMPARE(listview->highlightItem()->y(), 30.0);
 
-    canvas->rootObject()->setProperty("delegateHeight", 20);
+    window->rootObject()->setProperty("delegateHeight", 20);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     for (int i = 5; i < 11; ++i) {
@@ -4237,7 +4236,7 @@ void tst_QQuickListView::resizeDelegate()
     QTRY_COMPARE(listview->currentItem()->y(), 70.0);
     QTRY_COMPARE(listview->highlightItem()->y(), 70.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::resizeFirstDelegate()
@@ -4245,24 +4244,24 @@ void tst_QQuickListView::resizeFirstDelegate()
     // QTBUG-20712: Content Y jumps constantly if first delegate height == 0
     // and other delegates have height > 0
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     // bug only occurs when all items in the model are visible
     QmlListModel model;
     for (int i = 0; i < 10; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QVERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
@@ -4312,7 +4311,7 @@ void tst_QQuickListView::resizeFirstDelegate()
     }
 
     delete testObject;
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::repositionResizedDelegate()
@@ -4325,20 +4324,20 @@ void tst_QQuickListView::repositionResizedDelegate()
     QFETCH(QRectF, origPositionerRect);
     QFETCH(QRectF, resizedPositionerRect);
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testHorizontal", orientation == QQuickListView::Horizontal);
     ctxt->setContextProperty("testRightToLeft", layoutDirection == Qt::RightToLeft);
     ctxt->setContextProperty("testBottomToTop", verticalLayoutDirection == QQuickListView::BottomToTop);
-    canvas->setSource(testFileUrl("repositionResizedDelegate.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("repositionResizedDelegate.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = qobject_cast<QQuickListView*>(canvas->rootObject());
+    QQuickListView *listview = qobject_cast<QQuickListView*>(window->rootObject());
     QTRY_VERIFY(listview != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
-    QQuickItem *positioner = findItem<QQuickItem>(canvas->rootObject(), "positioner");
+    QQuickItem *positioner = findItem<QQuickItem>(window->rootObject(), "positioner");
     QVERIFY(positioner);
     QTRY_COMPARE(positioner->boundingRect().size(), origPositionerRect.size());
     QTRY_COMPARE(positioner->pos(), origPositionerRect.topLeft());
@@ -4353,14 +4352,14 @@ void tst_QQuickListView::repositionResizedDelegate()
     listview->setContentY(contentPos_itemFirstHalfVisible.y());
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
     prevSpyCount = spy.count();
-    QVERIFY(QMetaObject::invokeMethod(canvas->rootObject(), "incrementRepeater"));
+    QVERIFY(QMetaObject::invokeMethod(window->rootObject(), "incrementRepeater"));
     QTRY_COMPARE(positioner->boundingRect().size(), resizedPositionerRect.size());
     QTRY_COMPARE(positioner->pos(), resizedPositionerRect.topLeft());
     QCOMPARE(listview->contentX(), contentPos_itemFirstHalfVisible.x());
     QCOMPARE(listview->contentY(), contentPos_itemFirstHalfVisible.y());
     QCOMPARE(spy.count(), prevSpyCount);
 
-    QVERIFY(QMetaObject::invokeMethod(canvas->rootObject(), "decrementRepeater"));
+    QVERIFY(QMetaObject::invokeMethod(window->rootObject(), "decrementRepeater"));
     QTRY_COMPARE(positioner->boundingRect().size(), origPositionerRect.size());
     QTRY_COMPARE(positioner->pos(), origPositionerRect.topLeft());
     QCOMPARE(listview->contentX(), contentPos_itemFirstHalfVisible.x());
@@ -4371,8 +4370,8 @@ void tst_QQuickListView::repositionResizedDelegate()
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
     prevSpyCount = spy.count();
 
-    QVERIFY(QMetaObject::invokeMethod(canvas->rootObject(), "incrementRepeater"));
-    positioner = findItem<QQuickItem>(canvas->rootObject(), "positioner");
+    QVERIFY(QMetaObject::invokeMethod(window->rootObject(), "incrementRepeater"));
+    positioner = findItem<QQuickItem>(window->rootObject(), "positioner");
     QTRY_COMPARE(positioner->boundingRect().size(), resizedPositionerRect.size());
     QTRY_COMPARE(positioner->pos(), resizedPositionerRect.topLeft());
     QCOMPARE(listview->contentX(), contentPos_itemSecondHalfVisible.x());
@@ -4380,7 +4379,7 @@ void tst_QQuickListView::repositionResizedDelegate()
     qApp->processEvents();
     QCOMPARE(spy.count(), prevSpyCount);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::repositionResizedDelegate_data()
@@ -4420,22 +4419,22 @@ void tst_QQuickListView::repositionResizedDelegate_data()
 
 void tst_QQuickListView::QTBUG_16037()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
-    canvas->setSource(testFileUrl("qtbug16037.qml"));
+    window->setSource(testFileUrl("qtbug16037.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "listview");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "listview");
     QTRY_VERIFY(listview != 0);
 
     QVERIFY(listview->contentHeight() <= 0.0);
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "setModel");
+    QMetaObject::invokeMethod(window->rootObject(), "setModel");
 
     QTRY_COMPARE(listview->contentHeight(), 80.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::indexAt_itemAt_data()
@@ -4457,23 +4456,23 @@ void tst_QQuickListView::indexAt_itemAt()
     QFETCH(qreal, y);
     QFETCH(int, index);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
     QmlListModel model;
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("listviewtest.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("listviewtest.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -4488,22 +4487,22 @@ void tst_QQuickListView::indexAt_itemAt()
     QCOMPARE(listview->indexAt(x,y), index);
     QVERIFY(listview->itemAt(x,y) == item);
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
 void tst_QQuickListView::incrementalModel()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     IncrementalModel model;
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("displaylist.qml"));
+    window->setSource(testFileUrl("displaylist.qml"));
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -4515,7 +4514,7 @@ void tst_QQuickListView::incrementalModel()
 
     QTRY_COMPARE(listview->count(), 25);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::onAdd()
@@ -4530,30 +4529,30 @@ void tst_QQuickListView::onAdd()
     for (int i=0; i<initialItemCount; i++)
         model.addItem("dummy value", "dummy value");
 
-    QQuickView *canvas = createView();
-    canvas->setGeometry(0,0,200, delegateHeight * (initialItemCount + itemsToAdd));
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = createView();
+    window->setGeometry(0,0,200, delegateHeight * (initialItemCount + itemsToAdd));
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("delegateHeight", delegateHeight);
-    canvas->setSource(testFileUrl("attachedSignals.qml"));
+    window->setSource(testFileUrl("attachedSignals.qml"));
 
-    QObject *object = canvas->rootObject();
-    object->setProperty("width", canvas->width());
-    object->setProperty("height", canvas->height());
+    QObject *object = window->rootObject();
+    object->setProperty("width", window->width());
+    object->setProperty("height", window->height());
     qApp->processEvents();
 
     QList<QPair<QString, QString> > items;
     for (int i=0; i<itemsToAdd; i++)
         items << qMakePair(QString("value %1").arg(i), QString::number(i));
     model.addItems(items);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     QVariantList result = object->property("addedDelegates").toList();
     QCOMPARE(result.count(), items.count());
     for (int i=0; i<items.count(); i++)
         QCOMPARE(result[i].toString(), items[i].first);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::onAdd_data()
@@ -4585,20 +4584,20 @@ void tst_QQuickListView::onRemove()
     for (int i=0; i<initialItemCount; i++)
         model.addItem(QString("value %1").arg(i), "dummy value");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("delegateHeight", delegateHeight);
-    canvas->setSource(testFileUrl("attachedSignals.qml"));
+    window->setSource(testFileUrl("attachedSignals.qml"));
 
-    QObject *object = canvas->rootObject();
+    QObject *object = window->rootObject();
 
     model.removeItems(indexToRemove, removeCount);
-    QTRY_COMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QTRY_COMPARE(window->rootObject()->property("count").toInt(), model.count());
 
     QCOMPARE(object->property("removedDelegateCount"), QVariant(removeCount));
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::onRemove_data()
@@ -4626,14 +4625,14 @@ void tst_QQuickListView::onRemove_data()
 
 void tst_QQuickListView::rightToLeft()
 {
-    QQuickView *canvas = createView();
-    canvas->setGeometry(0,0,640,320);
-    canvas->setSource(testFileUrl("rightToLeft.qml"));
-    canvas->show();
+    QQuickView *window = createView();
+    window->setGeometry(0,0,640,320);
+    window->setSource(testFileUrl("rightToLeft.qml"));
+    window->show();
     qApp->processEvents();
 
-    QVERIFY(canvas->rootObject() != 0);
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "view");
+    QVERIFY(window->rootObject() != 0);
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "view");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -4641,7 +4640,7 @@ void tst_QQuickListView::rightToLeft()
 
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
-    QQuickVisualItemModel *model = canvas->rootObject()->findChild<QQuickVisualItemModel*>("itemModel");
+    QQuickVisualItemModel *model = window->rootObject()->findChild<QQuickVisualItemModel*>("itemModel");
     QTRY_VERIFY(model != 0);
 
     QTRY_VERIFY(model->count() == 3);
@@ -4672,22 +4671,22 @@ void tst_QQuickListView::rightToLeft()
     QCOMPARE(listview->contentX(), -640.);
 
     // Ensure resizing maintains position relative to right edge
-    qobject_cast<QQuickItem*>(canvas->rootObject())->setWidth(600);
+    qobject_cast<QQuickItem*>(window->rootObject())->setWidth(600);
     QTRY_COMPARE(listview->contentX(), -600.);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::test_mirroring()
 {
-    QQuickView *canvasA = createView();
-    canvasA->setSource(testFileUrl("rightToLeft.qml"));
-    QQuickListView *listviewA = findItem<QQuickListView>(canvasA->rootObject(), "view");
+    QQuickView *windowA = createView();
+    windowA->setSource(testFileUrl("rightToLeft.qml"));
+    QQuickListView *listviewA = findItem<QQuickListView>(windowA->rootObject(), "view");
     QTRY_VERIFY(listviewA != 0);
 
-    QQuickView *canvasB = createView();
-    canvasB->setSource(testFileUrl("rightToLeft.qml"));
-    QQuickListView *listviewB = findItem<QQuickListView>(canvasB->rootObject(), "view");
+    QQuickView *windowB = createView();
+    windowB->setSource(testFileUrl("rightToLeft.qml"));
+    QQuickListView *listviewB = findItem<QQuickListView>(windowB->rootObject(), "view");
     QTRY_VERIFY(listviewA != 0);
     qApp->processEvents();
 
@@ -4735,26 +4734,26 @@ void tst_QQuickListView::test_mirroring()
     foreach (const QString objectName, objectNames)
         QCOMPARE(findItem<QQuickItem>(listviewA, objectName)->x(), findItem<QQuickItem>(listviewB, objectName)->x());
 
-    delete canvasA;
-    delete canvasB;
+    delete windowA;
+    delete windowB;
 }
 
 void tst_QQuickListView::margins()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     for (int i = 0; i < 50; i++)
         model.addItem("Item" + QString::number(i), "");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("margins.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("margins.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QTRY_VERIFY(contentItem != 0);
@@ -4800,7 +4799,7 @@ void tst_QQuickListView::margins()
     QCOMPARE(listview->originY(), 20.);
     QTRY_COMPARE(listview->contentY(), pos-10);
 
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-24028
@@ -4819,13 +4818,13 @@ void tst_QQuickListView::marginsResize()
     else
         flickStart.rx() += (layoutDirection == Qt::LeftToRight) ? 180 : -180;
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
-    canvas->setSource(testFileUrl("margins2.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("margins2.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "listview");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "listview");
     QTRY_VERIFY(listview != 0);
 
     listview->setOrientation(orientation);
@@ -4847,7 +4846,7 @@ void tst_QQuickListView::marginsResize()
         QTRY_COMPARE(listview->contentX(), end);
 
     // flick past the end and check content pos still settles on correct extents
-    flick(canvas, flickStart, flickEnd, 180);
+    flick(window, flickStart, flickEnd, 180);
     QTRY_VERIFY(listview->isMoving() == false);
     if (orientation == QQuickListView::Vertical)
         QTRY_COMPARE(listview->contentY(), end);
@@ -4862,14 +4861,14 @@ void tst_QQuickListView::marginsResize()
         QTRY_COMPARE(listview->contentX(), start);
 
     // flick past the beginning and check content pos still settles on correct extents
-    flick(canvas, flickEnd, flickStart, 180);
+    flick(window, flickEnd, flickStart, 180);
     QTRY_VERIFY(listview->isMoving() == false);
     if (orientation == QQuickListView::Vertical)
         QTRY_COMPARE(listview->contentY(), start);
     else
         QTRY_COMPARE(listview->contentX(), start);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::marginsResize_data()
@@ -4956,13 +4955,13 @@ void tst_QQuickListView::snapToItem()
     QFETCH(qreal, endExtent);
     QFETCH(qreal, startExtent);
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
-    canvas->setSource(testFileUrl("snapToItem.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("snapToItem.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     listview->setOrientation(orientation);
@@ -4975,7 +4974,7 @@ void tst_QQuickListView::snapToItem()
     QTRY_VERIFY(contentItem != 0);
 
     // confirm that a flick hits an item boundary
-    flick(canvas, flickStart, flickEnd, 180);
+    flick(window, flickStart, flickEnd, 180);
     QTRY_VERIFY(listview->isMoving() == false); // wait until it stops
     if (orientation == QQuickListView::Vertical)
         QCOMPARE(qreal(fmod(listview->contentY(),80.0)), snapAlignment);
@@ -4984,7 +4983,7 @@ void tst_QQuickListView::snapToItem()
 
     // flick to end
     do {
-        flick(canvas, flickStart, flickEnd, 180);
+        flick(window, flickStart, flickEnd, 180);
         QTRY_VERIFY(listview->isMoving() == false); // wait until it stops
     } while (orientation == QQuickListView::Vertical
            ? verticalLayoutDirection == QQuickItemView::TopToBottom ? !listview->isAtYEnd() : !listview->isAtYBeginning()
@@ -4997,7 +4996,7 @@ void tst_QQuickListView::snapToItem()
 
     // flick to start
     do {
-        flick(canvas, flickEnd, flickStart, 180);
+        flick(window, flickEnd, flickStart, 180);
         QTRY_VERIFY(listview->isMoving() == false); // wait until it stops
     } while (orientation == QQuickListView::Vertical
            ? verticalLayoutDirection == QQuickItemView::TopToBottom ? !listview->isAtYBeginning() : !listview->isAtYEnd()
@@ -5008,7 +5007,7 @@ void tst_QQuickListView::snapToItem()
     else
         QCOMPARE(listview->contentX(), startExtent);
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::qListModelInterface_items()
@@ -5211,12 +5210,12 @@ void tst_QQuickListView::qAbstractItemModel_sections()
 
 void tst_QQuickListView::creationContext()
 {
-    QQuickView canvas;
-    canvas.setGeometry(0,0,240,320);
-    canvas.setSource(testFileUrl("creationContext.qml"));
+    QQuickView window;
+    window.setGeometry(0,0,240,320);
+    window.setSource(testFileUrl("creationContext.qml"));
     qApp->processEvents();
 
-    QQuickItem *rootItem = qobject_cast<QQuickItem *>(canvas.rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem *>(window.rootObject());
     QVERIFY(rootItem);
     QVERIFY(rootItem->property("count").toInt() > 0);
 
@@ -5233,26 +5232,26 @@ void tst_QQuickListView::creationContext()
 
 void tst_QQuickListView::QTBUG_21742()
 {
-    QQuickView canvas;
-    canvas.setGeometry(0,0,200,200);
-    canvas.setSource(testFileUrl("qtbug-21742.qml"));
+    QQuickView window;
+    window.setGeometry(0,0,200,200);
+    window.setSource(testFileUrl("qtbug-21742.qml"));
     qApp->processEvents();
 
-    QQuickItem *rootItem = qobject_cast<QQuickItem *>(canvas.rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem *>(window.rootObject());
     QVERIFY(rootItem);
     QCOMPARE(rootItem->property("count").toInt(), 1);
 }
 
 void tst_QQuickListView::asynchronous()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
     QQmlIncubationController controller;
-    canvas->engine()->setIncubationController(&controller);
+    window->engine()->setIncubationController(&controller);
 
-    canvas->setSource(testFileUrl("asyncloader.qml"));
+    window->setSource(testFileUrl("asyncloader.qml"));
 
-    QQuickItem *rootObject = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootObject = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootObject);
 
     QQuickListView *listview = 0;
@@ -5285,7 +5284,7 @@ void tst_QQuickListView::asynchronous()
         QTRY_COMPARE(item->y(), i*50.0);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::snapOneItem_data()
@@ -5350,13 +5349,13 @@ void tst_QQuickListView::snapOneItem()
     QSKIP("QTBUG-24338");
 #endif
 
-    QQuickView *canvas = getView();
+    QQuickView *window = getView();
 
-    canvas->setSource(testFileUrl("snapOneItem.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("snapOneItem.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     listview->setOrientation(orientation);
@@ -5371,7 +5370,7 @@ void tst_QQuickListView::snapOneItem()
     QSignalSpy currentIndexSpy(listview, SIGNAL(currentIndexChanged()));
 
     // confirm that a flick hits the next item boundary
-    flick(canvas, flickStart, flickEnd, 180);
+    flick(window, flickStart, flickEnd, 180);
     QTRY_VERIFY(listview->isMoving() == false); // wait until it stops
     if (orientation == QQuickListView::Vertical)
         QCOMPARE(listview->contentY(), snapAlignment);
@@ -5385,7 +5384,7 @@ void tst_QQuickListView::snapOneItem()
 
     // flick to end
     do {
-        flick(canvas, flickStart, flickEnd, 180);
+        flick(window, flickStart, flickEnd, 180);
         QTRY_VERIFY(listview->isMoving() == false); // wait until it stops
     } while (orientation == QQuickListView::Vertical
            ? verticalLayoutDirection == QQuickItemView::TopToBottom ? !listview->isAtYEnd() : !listview->isAtYBeginning()
@@ -5403,7 +5402,7 @@ void tst_QQuickListView::snapOneItem()
 
     // flick to start
     do {
-        flick(canvas, flickEnd, flickStart, 180);
+        flick(window, flickEnd, flickStart, 180);
         QTRY_VERIFY(listview->isMoving() == false); // wait until it stops
     } while (orientation == QQuickListView::Vertical
            ? verticalLayoutDirection == QQuickItemView::TopToBottom ? !listview->isAtYBeginning() : !listview->isAtYEnd()
@@ -5419,7 +5418,7 @@ void tst_QQuickListView::snapOneItem()
         QCOMPARE(currentIndexSpy.count(), 6);
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::unrequestedVisibility()
@@ -5428,21 +5427,21 @@ void tst_QQuickListView::unrequestedVisibility()
     for (int i = 0; i < 30; i++)
         model.addItem("Item" + QString::number(i), QString::number(i));
 
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testWrap", QVariant(false));
 
-    canvas->setSource(testFileUrl("unrequestedItems.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("unrequestedItems.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *leftview = findItem<QQuickListView>(canvas->rootObject(), "leftList");
+    QQuickListView *leftview = findItem<QQuickListView>(window->rootObject(), "leftList");
     QTRY_VERIFY(leftview != 0);
 
-    QQuickListView *rightview = findItem<QQuickListView>(canvas->rootObject(), "rightList");
+    QQuickListView *rightview = findItem<QQuickListView>(window->rootObject(), "rightList");
     QTRY_VERIFY(rightview != 0);
 
     QQuickItem *leftContent = leftview->contentItem();
@@ -5584,7 +5583,7 @@ void tst_QQuickListView::unrequestedVisibility()
     QVERIFY(item = findItem<QQuickItem>(rightContent, "wrapper", 17));
     QCOMPARE(delegateVisible(item), false);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::populateTransitions()
@@ -5604,20 +5603,20 @@ void tst_QQuickListView::populateTransitions()
             model.addItem("item" + QString::number(i), "");
     }
 
-    QQuickView *canvas = getView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
-    canvas->rootContext()->setContextProperty("testObject", new TestObject(canvas->rootContext()));
-    canvas->rootContext()->setContextProperty("usePopulateTransition", usePopulateTransition);
-    canvas->rootContext()->setContextProperty("dynamicallyPopulate", dynamicallyPopulate);
-    canvas->rootContext()->setContextProperty("transitionFrom", transitionFrom);
-    canvas->rootContext()->setContextProperty("transitionVia", transitionVia);
-    canvas->rootContext()->setContextProperty("model_transitionFrom", &model_transitionFrom);
-    canvas->rootContext()->setContextProperty("model_transitionVia", &model_transitionVia);
-    canvas->setSource(testFileUrl("populateTransitions.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
-
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickView *window = getView();
+    window->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("testObject", new TestObject(window->rootContext()));
+    window->rootContext()->setContextProperty("usePopulateTransition", usePopulateTransition);
+    window->rootContext()->setContextProperty("dynamicallyPopulate", dynamicallyPopulate);
+    window->rootContext()->setContextProperty("transitionFrom", transitionFrom);
+    window->rootContext()->setContextProperty("transitionVia", transitionVia);
+    window->rootContext()->setContextProperty("model_transitionFrom", &model_transitionFrom);
+    window->rootContext()->setContextProperty("model_transitionVia", &model_transitionVia);
+    window->setSource(testFileUrl("populateTransitions.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QVERIFY(listview);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem);
@@ -5654,7 +5653,7 @@ void tst_QQuickListView::populateTransitions()
     QTRY_COMPARE(listview->property("countPopulateTransitions").toInt(), 0);
 
     // clear the model
-    canvas->rootContext()->setContextProperty("testModel", QVariant());
+    window->rootContext()->setContextProperty("testModel", QVariant());
     QTRY_COMPARE(listview->count(), 0);
     QTRY_COMPARE(findItems<QQuickItem>(contentItem, "wrapper").count(), 0);
     listview->setProperty("countPopulateTransitions", 0);
@@ -5664,7 +5663,7 @@ void tst_QQuickListView::populateTransitions()
     model.clear();
     for (int i = 0; i < 30; i++)
         model.addItem("item" + QString::number(i), "");
-    canvas->rootContext()->setContextProperty("testModel", &model);
+    window->rootContext()->setContextProperty("testModel", &model);
     QTRY_COMPARE(listview->property("countPopulateTransitions").toInt(), usePopulateTransition ? 16 : 0);
     QTRY_COMPARE(listview->property("countAddTransitions").toInt(), 0);
 
@@ -5697,7 +5696,7 @@ void tst_QQuickListView::populateTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::populateTransitions_data()
@@ -5737,8 +5736,8 @@ void tst_QQuickListView::addTransitions()
     QaimModel model_targetItems_transitionFrom;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("model_targetItems_transitionFrom", &model_targetItems_transitionFrom);
@@ -5746,11 +5745,11 @@ void tst_QQuickListView::addTransitions()
     ctxt->setContextProperty("targetItems_transitionFrom", targetItems_transitionFrom);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
     ctxt->setContextProperty("testObject", testObject);
-    canvas->setSource(testFileUrl("addTransitions.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("addTransitions.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
@@ -5835,7 +5834,7 @@ void tst_QQuickListView::addTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -5932,8 +5931,8 @@ void tst_QQuickListView::moveTransitions()
     QaimModel model_targetItems_transitionVia;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("model_targetItems_transitionVia", &model_targetItems_transitionVia);
@@ -5941,11 +5940,11 @@ void tst_QQuickListView::moveTransitions()
     ctxt->setContextProperty("targetItems_transitionVia", targetItems_transitionVia);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
     ctxt->setContextProperty("testObject", testObject);
-    canvas->setSource(testFileUrl("moveTransitions.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("moveTransitions.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
@@ -6020,7 +6019,7 @@ void tst_QQuickListView::moveTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -6135,8 +6134,8 @@ void tst_QQuickListView::removeTransitions()
     QaimModel model_targetItems_transitionTo;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("model_targetItems_transitionTo", &model_targetItems_transitionTo);
@@ -6144,11 +6143,11 @@ void tst_QQuickListView::removeTransitions()
     ctxt->setContextProperty("targetItems_transitionTo", targetItems_transitionTo);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
     ctxt->setContextProperty("testObject", testObject);
-    canvas->setSource(testFileUrl("removeTransitions.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("removeTransitions.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
@@ -6234,7 +6233,7 @@ void tst_QQuickListView::removeTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -6334,9 +6333,9 @@ void tst_QQuickListView::displacedTransitions()
     QPointF moveDisplaced_transitionVia(50, -100);
     QPointF removeDisplaced_transitionVia(150, 100);
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
-    TestObject *testObject = new TestObject(canvas);
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
+    TestObject *testObject = new TestObject(window);
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testObject", testObject);
     ctxt->setContextProperty("model_displaced_transitionVia", &model_displaced_transitionVia);
@@ -6355,11 +6354,11 @@ void tst_QQuickListView::displacedTransitions()
     ctxt->setContextProperty("moveDisplacedEnabled", moveDisplacedEnabled);
     ctxt->setContextProperty("useRemoveDisplaced", useRemoveDisplaced);
     ctxt->setContextProperty("removeDisplacedEnabled", removeDisplacedEnabled);
-    canvas->setSource(testFileUrl("displacedTransitions.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("displacedTransitions.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
@@ -6447,7 +6446,7 @@ void tst_QQuickListView::displacedTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 void tst_QQuickListView::displacedTransitions_data()
@@ -6559,8 +6558,8 @@ void tst_QQuickListView::multipleTransitions()
     for (int i = 0; i < initialCount; i++)
         model.addItem("Original item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testModel", &model);
     ctxt->setContextProperty("testObject", testObject);
@@ -6574,11 +6573,11 @@ void tst_QQuickListView::multipleTransitions()
     ctxt->setContextProperty("enableMoveTransitions", enableMoveTransitions);
     ctxt->setContextProperty("enableRemoveTransitions", enableRemoveTransitions);
     ctxt->setContextProperty("rippleAddDisplaced", rippleAddDisplaced);
-    canvas->setSource(testFileUrl("multipleTransitions.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("multipleTransitions.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
@@ -6589,7 +6588,7 @@ void tst_QQuickListView::multipleTransitions()
         QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
     }
 
-    int timeBetweenActions = canvas->rootObject()->property("timeBetweenActions").toInt();
+    int timeBetweenActions = window->rootObject()->property("timeBetweenActions").toInt();
 
     for (int i=0; i<changes.count(); i++) {
         switch (changes[i].type) {
@@ -6653,7 +6652,7 @@ void tst_QQuickListView::multipleTransitions()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
     delete testObject;
 }
 
@@ -6725,22 +6724,22 @@ void tst_QQuickListView::multipleDisplaced()
     for (int i = 0; i < 30; i++)
         model.addItem("Original item" + QString::number(i), "");
 
-    QQuickView *canvas = getView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = getView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
-    ctxt->setContextProperty("testObject", new TestObject(canvas));
-    canvas->setSource(testFileUrl("multipleDisplaced.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    ctxt->setContextProperty("testObject", new TestObject(window));
+    window->setSource(testFileUrl("multipleDisplaced.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     model.moveItems(12, 8, 1);
-    QTest::qWait(canvas->rootObject()->property("duration").toInt() / 2);
+    QTest::qWait(window->rootObject()->property("duration").toInt() / 2);
     model.moveItems(8, 3, 1);
     QTRY_VERIFY(listview->property("displaceTransitionsDone").toBool());
 
@@ -6762,7 +6761,7 @@ void tst_QQuickListView::multipleDisplaced()
         QTRY_COMPARE(name->text(), model.name(i));
     }
 
-    releaseView(canvas);
+    releaseView(window);
 }
 
 QList<int> tst_QQuickListView::toIntList(const QVariantList &list)
@@ -6818,13 +6817,13 @@ void tst_QQuickListView::matchItemLists(const QVariantList &itemLists, const QLi
 
 void tst_QQuickListView::flickBeyondBounds()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("flickBeyondBoundsBug.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("flickBeyondBoundsBug.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QTRY_VERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -6832,7 +6831,7 @@ void tst_QQuickListView::flickBeyondBounds()
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
     // Flick view up beyond bounds
-    flick(canvas, QPoint(10, 10), QPoint(10, -1000), 180);
+    flick(window, QPoint(10, 10), QPoint(10, -1000), 180);
     QTRY_VERIFY(findItems<QQuickItem>(contentItem, "wrapper").count() == 0);
 
     // We're really testing that we don't get stuck in a loop,
@@ -6845,48 +6844,48 @@ void tst_QQuickListView::flickBeyondBounds()
         QTRY_VERIFY(item->y() == i*45);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::destroyItemOnCreation()
 {
     QmlListModel model;
-    QQuickView *canvas = createView();
-    canvas->rootContext()->setContextProperty("testModel", &model);
+    QQuickView *window = createView();
+    window->rootContext()->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("destroyItemOnCreation.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("destroyItemOnCreation.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickListView *listview = findItem<QQuickListView>(canvas->rootObject(), "list");
+    QQuickListView *listview = findItem<QQuickListView>(window->rootObject(), "list");
     QVERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
     QVERIFY(contentItem != 0);
     QTRY_COMPARE(QQuickItemPrivate::get(listview)->polishScheduled, false);
 
-    QCOMPARE(canvas->rootObject()->property("createdIndex").toInt(), -1);
+    QCOMPARE(window->rootObject()->property("createdIndex").toInt(), -1);
     model.addItem("new item", "");
-    QTRY_COMPARE(canvas->rootObject()->property("createdIndex").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("createdIndex").toInt(), 0);
 
     QTRY_COMPARE(findItems<QQuickItem>(contentItem, "wrapper").count(), 0);
     QCOMPARE(model.count(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickListView::parentBinding()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     m_errorCount = 0;
     QtMsgHandler old = qInstallMsgHandler(errorMsgHandler);
 
-    canvas->setSource(testFileUrl("parentBinding.qml"));
-    canvas->show();
-    QTest::qWaitForWindowExposed(canvas);
+    window->setSource(testFileUrl("parentBinding.qml"));
+    window->show();
+    QTest::qWaitForWindowExposed(window);
 
-    QQuickListView *listview = qobject_cast<QQuickListView*>(canvas->rootObject());
+    QQuickListView *listview = qobject_cast<QQuickListView*>(window->rootObject());
     QVERIFY(listview != 0);
 
     QQuickItem *contentItem = listview->contentItem();
@@ -6903,7 +6902,7 @@ void tst_QQuickListView::parentBinding()
 
     qInstallMsgHandler(old);
 
-    delete canvas;
+    delete window;
 }
 
 QTEST_MAIN(tst_QQuickListView)
diff --git a/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp b/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp
index b2ef190..67a36af 100644
--- a/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp
+++ b/tests/auto/quick/qquickmousearea/tst_qquickmousearea.cpp
@@ -122,23 +122,23 @@ void tst_QQuickMouseArea::rejectedButton_data()
 
 void tst_QQuickMouseArea::dragProperties()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("dragproperties.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window->setSource(testFileUrl("dragproperties.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseRegion = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseRegion = window->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QQuickDrag *drag = mouseRegion->drag();
     QVERIFY(mouseRegion != 0);
     QVERIFY(drag != 0);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
     QVERIFY(blackRect == drag->target());
-    QQuickItem *rootItem = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootItem != 0);
     QSignalSpy targetSpy(drag, SIGNAL(targetChanged()));
     drag->setTarget(rootItem);
@@ -202,37 +202,37 @@ void tst_QQuickMouseArea::dragProperties()
     drag->setFilterChildren(true);
     QCOMPARE(filterChildrenSpy.count(), 1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::resetDrag()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->rootContext()->setContextProperty("haveTarget", QVariant(true));
-    canvas->setSource(testFileUrl("dragreset.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window->rootContext()->setContextProperty("haveTarget", QVariant(true));
+    window->setSource(testFileUrl("dragreset.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseRegion = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseRegion = window->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QQuickDrag *drag = mouseRegion->drag();
     QVERIFY(mouseRegion != 0);
     QVERIFY(drag != 0);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
     QVERIFY(blackRect == drag->target());
-    QQuickItem *rootItem = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootItem != 0);
     QSignalSpy targetSpy(drag, SIGNAL(targetChanged()));
     QVERIFY(drag->target() != 0);
-    canvas->rootContext()->setContextProperty("haveTarget", QVariant(false));
+    window->rootContext()->setContextProperty("haveTarget", QVariant(false));
     QCOMPARE(targetSpy.count(),1);
     QVERIFY(drag->target() == 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::dragging()
@@ -240,15 +240,15 @@ void tst_QQuickMouseArea::dragging()
     QFETCH(Qt::MouseButtons, acceptedButtons);
     QFETCH(Qt::MouseButton, button);
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("dragging.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
+    window->setSource(testFileUrl("dragging.qml"));
+    window->show();
+    window->requestActivateWindow();
     QTest::qWait(20);
-    QVERIFY(canvas->rootObject() != 0);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseRegion = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseRegion = window->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QQuickDrag *drag = mouseRegion->drag();
     QVERIFY(mouseRegion != 0);
     QVERIFY(drag != 0);
@@ -256,13 +256,13 @@ void tst_QQuickMouseArea::dragging()
     mouseRegion->setAcceptedButtons(acceptedButtons);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
     QVERIFY(blackRect == drag->target());
 
     QVERIFY(!drag->active());
 
-    QTest::mousePress(canvas, button, 0, QPoint(100,100));
+    QTest::mousePress(window, button, 0, QPoint(100,100));
 
     QVERIFY(!drag->active());
     QCOMPARE(blackRect->x(), 50.0);
@@ -271,23 +271,23 @@ void tst_QQuickMouseArea::dragging()
     // First move event triggers drag, second is acted upon.
     // This is due to possibility of higher stacked area taking precedence.
 
-    QTest::mouseMove(canvas, QPoint(111,111));
+    QTest::mouseMove(window, QPoint(111,111));
     QTest::qWait(50);
-    QTest::mouseMove(canvas, QPoint(122,122));
+    QTest::mouseMove(window, QPoint(122,122));
     QTest::qWait(50);
 
     QVERIFY(drag->active());
     QCOMPARE(blackRect->x(), 72.0);
     QCOMPARE(blackRect->y(), 72.0);
 
-    QTest::mouseRelease(canvas, button, 0, QPoint(122,122));
+    QTest::mouseRelease(window, button, 0, QPoint(122,122));
     QTest::qWait(50);
 
     QVERIFY(!drag->active());
     QCOMPARE(blackRect->x(), 72.0);
     QCOMPARE(blackRect->y(), 72.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::invalidDrag()
@@ -295,15 +295,15 @@ void tst_QQuickMouseArea::invalidDrag()
     QFETCH(Qt::MouseButtons, acceptedButtons);
     QFETCH(Qt::MouseButton, button);
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("dragging.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
+    window->setSource(testFileUrl("dragging.qml"));
+    window->show();
+    window->requestActivateWindow();
     QTest::qWait(20);
-    QVERIFY(canvas->rootObject() != 0);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseRegion = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseRegion = window->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QQuickDrag *drag = mouseRegion->drag();
     QVERIFY(mouseRegion != 0);
     QVERIFY(drag != 0);
@@ -311,13 +311,13 @@ void tst_QQuickMouseArea::invalidDrag()
     mouseRegion->setAcceptedButtons(acceptedButtons);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
     QVERIFY(blackRect == drag->target());
 
     QVERIFY(!drag->active());
 
-    QTest::mousePress(canvas, button, 0, QPoint(100,100));
+    QTest::mousePress(window, button, 0, QPoint(100,100));
 
     QVERIFY(!drag->active());
     QCOMPARE(blackRect->x(), 50.0);
@@ -326,43 +326,43 @@ void tst_QQuickMouseArea::invalidDrag()
     // First move event triggers drag, second is acted upon.
     // This is due to possibility of higher stacked area taking precedence.
 
-    QTest::mouseMove(canvas, QPoint(111,111));
+    QTest::mouseMove(window, QPoint(111,111));
     QTest::qWait(50);
-    QTest::mouseMove(canvas, QPoint(122,122));
+    QTest::mouseMove(window, QPoint(122,122));
     QTest::qWait(50);
 
     QVERIFY(!drag->active());
     QCOMPARE(blackRect->x(), 50.0);
     QCOMPARE(blackRect->y(), 50.0);
 
-    QTest::mouseRelease(canvas, button, 0, QPoint(122,122));
+    QTest::mouseRelease(window, button, 0, QPoint(122,122));
     QTest::qWait(50);
 
     QVERIFY(!drag->active());
     QCOMPARE(blackRect->x(), 50.0);
     QCOMPARE(blackRect->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::setDragOnPressed()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("setDragOnPressed.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
+    window->setSource(testFileUrl("setDragOnPressed.qml"));
+    window->show();
+    window->requestActivateWindow();
     QTest::qWait(20);
-    QVERIFY(canvas->rootObject() != 0);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseArea = qobject_cast<QQuickMouseArea *>(canvas->rootObject());
+    QQuickMouseArea *mouseArea = qobject_cast<QQuickMouseArea *>(window->rootObject());
     QVERIFY(mouseArea);
 
     // target
     QQuickItem *target = mouseArea->findChild<QQuickItem*>("target");
     QVERIFY(target);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
 
     QQuickDrag *drag = mouseArea->drag();
     QVERIFY(drag);
@@ -374,52 +374,52 @@ void tst_QQuickMouseArea::setDragOnPressed()
     // First move event triggers drag, second is acted upon.
     // This is due to possibility of higher stacked area taking precedence.
 
-    QTest::mouseMove(canvas, QPoint(111,102));
+    QTest::mouseMove(window, QPoint(111,102));
     QTest::qWait(50);
-    QTest::mouseMove(canvas, QPoint(122,122));
+    QTest::mouseMove(window, QPoint(122,122));
     QTest::qWait(50);
 
     QVERIFY(drag->active());
     QCOMPARE(target->x(), 72.0);
     QCOMPARE(target->y(), 50.0);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(122,122));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(122,122));
     QTest::qWait(50);
 
     QVERIFY(!drag->active());
     QCOMPARE(target->x(), 72.0);
     QCOMPARE(target->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 QQuickView *tst_QQuickMouseArea::createView()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setBaseSize(QSize(240,320));
+    QQuickView *window = new QQuickView(0);
+    window->setBaseSize(QSize(240,320));
 
-    return canvas;
+    return window;
 }
 
 void tst_QQuickMouseArea::updateMouseAreaPosOnClick()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("updateMousePosOnClick.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("updateMousePosOnClick.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseRegion = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseRegion = window->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QVERIFY(mouseRegion != 0);
 
-    QQuickRectangle *rect = canvas->rootObject()->findChild<QQuickRectangle*>("ball");
+    QQuickRectangle *rect = window->rootObject()->findChild<QQuickRectangle*>("ball");
     QVERIFY(rect != 0);
 
     QCOMPARE(mouseRegion->mouseX(), rect->x());
     QCOMPARE(mouseRegion->mouseY(), rect->y());
 
     QMouseEvent event(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &event);
+    QGuiApplication::sendEvent(window, &event);
 
     QCOMPARE(mouseRegion->mouseX(), 100.0);
     QCOMPARE(mouseRegion->mouseY(), 100.0);
@@ -427,28 +427,28 @@ void tst_QQuickMouseArea::updateMouseAreaPosOnClick()
     QCOMPARE(mouseRegion->mouseX(), rect->x());
     QCOMPARE(mouseRegion->mouseY(), rect->y());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::updateMouseAreaPosOnResize()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("updateMousePosOnResize.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("updateMousePosOnResize.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseRegion = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseRegion = window->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QVERIFY(mouseRegion != 0);
 
-    QQuickRectangle *rect = canvas->rootObject()->findChild<QQuickRectangle*>("brother");
+    QQuickRectangle *rect = window->rootObject()->findChild<QQuickRectangle*>("brother");
     QVERIFY(rect != 0);
 
     QCOMPARE(mouseRegion->mouseX(), 0.0);
     QCOMPARE(mouseRegion->mouseY(), 0.0);
 
     QMouseEvent event(QEvent::MouseButtonPress, rect->pos().toPoint(), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &event);
+    QGuiApplication::sendEvent(window, &event);
 
     QVERIFY(!mouseRegion->property("emitPositionChanged").toBool());
     QVERIFY(mouseRegion->property("mouseMatchesPos").toBool());
@@ -462,141 +462,141 @@ void tst_QQuickMouseArea::updateMouseAreaPosOnResize()
     QCOMPARE(mouseRegion->mouseX(), rect->x());
     QCOMPARE(mouseRegion->mouseY(), rect->y());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::noOnClickedWithPressAndHold()
 {
     {
         // We handle onPressAndHold, therefore no onClicked
-        QQuickView *canvas = createView();
-        canvas->setSource(testFileUrl("clickandhold.qml"));
-        canvas->show();
-        canvas->requestActivateWindow();
-        QVERIFY(canvas->rootObject() != 0);
+        QQuickView *window = createView();
+        window->setSource(testFileUrl("clickandhold.qml"));
+        window->show();
+        window->requestActivateWindow();
+        QVERIFY(window->rootObject() != 0);
 
         QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-        QGuiApplication::sendEvent(canvas, &pressEvent);
+        QGuiApplication::sendEvent(window, &pressEvent);
 
-        QVERIFY(!canvas->rootObject()->property("clicked").toBool());
-        QVERIFY(!canvas->rootObject()->property("held").toBool());
+        QVERIFY(!window->rootObject()->property("clicked").toBool());
+        QVERIFY(!window->rootObject()->property("held").toBool());
 
         QTest::qWait(1000);
 
         QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-        QGuiApplication::sendEvent(canvas, &releaseEvent);
+        QGuiApplication::sendEvent(window, &releaseEvent);
 
-        QVERIFY(!canvas->rootObject()->property("clicked").toBool());
-        QVERIFY(canvas->rootObject()->property("held").toBool());
+        QVERIFY(!window->rootObject()->property("clicked").toBool());
+        QVERIFY(window->rootObject()->property("held").toBool());
 
-        delete canvas;
+        delete window;
     }
 
     {
         // We do not handle onPressAndHold, therefore we get onClicked
-        QQuickView *canvas = createView();
-        canvas->setSource(testFileUrl("noclickandhold.qml"));
-        canvas->show();
-        canvas->requestActivateWindow();
-        QVERIFY(canvas->rootObject() != 0);
+        QQuickView *window = createView();
+        window->setSource(testFileUrl("noclickandhold.qml"));
+        window->show();
+        window->requestActivateWindow();
+        QVERIFY(window->rootObject() != 0);
 
         QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-        QGuiApplication::sendEvent(canvas, &pressEvent);
+        QGuiApplication::sendEvent(window, &pressEvent);
 
-        QVERIFY(!canvas->rootObject()->property("clicked").toBool());
+        QVERIFY(!window->rootObject()->property("clicked").toBool());
 
         QTest::qWait(1000);
 
         QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-        QGuiApplication::sendEvent(canvas, &releaseEvent);
+        QGuiApplication::sendEvent(window, &releaseEvent);
 
-        QVERIFY(canvas->rootObject()->property("clicked").toBool());
+        QVERIFY(window->rootObject()->property("clicked").toBool());
 
-        delete canvas;
+        delete window;
     }
 }
 
 void tst_QQuickMouseArea::onMousePressRejected()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("rejectEvent.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
-    QVERIFY(canvas->rootObject()->property("enabled").toBool());
-
-    QVERIFY(!canvas->rootObject()->property("mr1_pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr1_released").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr1_canceled").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr2_pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr2_released").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr2_canceled").toBool());
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("rejectEvent.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
+    QVERIFY(window->rootObject()->property("enabled").toBool());
+
+    QVERIFY(!window->rootObject()->property("mr1_pressed").toBool());
+    QVERIFY(!window->rootObject()->property("mr1_released").toBool());
+    QVERIFY(!window->rootObject()->property("mr1_canceled").toBool());
+    QVERIFY(!window->rootObject()->property("mr2_pressed").toBool());
+    QVERIFY(!window->rootObject()->property("mr2_released").toBool());
+    QVERIFY(!window->rootObject()->property("mr2_canceled").toBool());
 
     QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
 
-    QVERIFY(canvas->rootObject()->property("mr1_pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr1_released").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr1_canceled").toBool());
-    QVERIFY(canvas->rootObject()->property("mr2_pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr2_released").toBool());
-    QVERIFY(canvas->rootObject()->property("mr2_canceled").toBool());
+    QVERIFY(window->rootObject()->property("mr1_pressed").toBool());
+    QVERIFY(!window->rootObject()->property("mr1_released").toBool());
+    QVERIFY(!window->rootObject()->property("mr1_canceled").toBool());
+    QVERIFY(window->rootObject()->property("mr2_pressed").toBool());
+    QVERIFY(!window->rootObject()->property("mr2_released").toBool());
+    QVERIFY(window->rootObject()->property("mr2_canceled").toBool());
 
     QTest::qWait(200);
 
     QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QVERIFY(canvas->rootObject()->property("mr1_released").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr1_canceled").toBool());
-    QVERIFY(!canvas->rootObject()->property("mr2_released").toBool());
+    QVERIFY(window->rootObject()->property("mr1_released").toBool());
+    QVERIFY(!window->rootObject()->property("mr1_canceled").toBool());
+    QVERIFY(!window->rootObject()->property("mr2_released").toBool());
 
-    delete canvas;
+    delete window;
 }
 void tst_QQuickMouseArea::pressedCanceledOnWindowDeactivate()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("pressedCanceled.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
-    QVERIFY(!canvas->rootObject()->property("pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("canceled").toBool());
-    QVERIFY(!canvas->rootObject()->property("released").toBool());
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("pressedCanceled.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
+    QVERIFY(!window->rootObject()->property("pressed").toBool());
+    QVERIFY(!window->rootObject()->property("canceled").toBool());
+    QVERIFY(!window->rootObject()->property("released").toBool());
 
     QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
 
-    QVERIFY(canvas->rootObject()->property("pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("canceled").toBool());
-    QVERIFY(!canvas->rootObject()->property("released").toBool());
+    QVERIFY(window->rootObject()->property("pressed").toBool());
+    QVERIFY(!window->rootObject()->property("canceled").toBool());
+    QVERIFY(!window->rootObject()->property("released").toBool());
 
     QTest::qWait(200);
 
     QEvent windowDeactivateEvent(QEvent::WindowDeactivate);
-    QGuiApplication::sendEvent(canvas, &windowDeactivateEvent);
-    QVERIFY(!canvas->rootObject()->property("pressed").toBool());
-    QVERIFY(canvas->rootObject()->property("canceled").toBool());
-    QVERIFY(!canvas->rootObject()->property("released").toBool());
+    QGuiApplication::sendEvent(window, &windowDeactivateEvent);
+    QVERIFY(!window->rootObject()->property("pressed").toBool());
+    QVERIFY(window->rootObject()->property("canceled").toBool());
+    QVERIFY(!window->rootObject()->property("released").toBool());
 
     QTest::qWait(200);
 
     //press again
-    QGuiApplication::sendEvent(canvas, &pressEvent);
-    QVERIFY(canvas->rootObject()->property("pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("canceled").toBool());
-    QVERIFY(!canvas->rootObject()->property("released").toBool());
+    QGuiApplication::sendEvent(window, &pressEvent);
+    QVERIFY(window->rootObject()->property("pressed").toBool());
+    QVERIFY(!window->rootObject()->property("canceled").toBool());
+    QVERIFY(!window->rootObject()->property("released").toBool());
 
     QTest::qWait(200);
 
     //release
     QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
-    QVERIFY(!canvas->rootObject()->property("pressed").toBool());
-    QVERIFY(!canvas->rootObject()->property("canceled").toBool());
-    QVERIFY(canvas->rootObject()->property("released").toBool());
+    QGuiApplication::sendEvent(window, &releaseEvent);
+    QVERIFY(!window->rootObject()->property("pressed").toBool());
+    QVERIFY(!window->rootObject()->property("canceled").toBool());
+    QVERIFY(window->rootObject()->property("released").toBool());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::doubleClick()
@@ -604,36 +604,36 @@ void tst_QQuickMouseArea::doubleClick()
     QFETCH(Qt::MouseButtons, acceptedButtons);
     QFETCH(Qt::MouseButton, button);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("doubleclick.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("doubleclick.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseArea = canvas->rootObject()->findChild<QQuickMouseArea *>("mousearea");
+    QQuickMouseArea *mouseArea = window->rootObject()->findChild<QQuickMouseArea *>("mousearea");
     QVERIFY(mouseArea);
     mouseArea->setAcceptedButtons(acceptedButtons);
 
     // The sequence for a double click is:
     // press, release, (click), press, double click, release
     QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
 
     QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QCOMPARE(canvas->rootObject()->property("released").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("released").toInt(), 1);
 
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
     pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QCOMPARE(canvas->rootObject()->property("clicked").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("doubleClicked").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("released").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("clicked").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("doubleClicked").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("released").toInt(), 2);
 
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-14832
@@ -642,36 +642,36 @@ void tst_QQuickMouseArea::clickTwice()
     QFETCH(Qt::MouseButtons, acceptedButtons);
     QFETCH(Qt::MouseButton, button);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("clicktwice.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("clicktwice.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseArea = canvas->rootObject()->findChild<QQuickMouseArea *>("mousearea");
+    QQuickMouseArea *mouseArea = window->rootObject()->findChild<QQuickMouseArea *>("mousearea");
     QVERIFY(mouseArea);
     mouseArea->setAcceptedButtons(acceptedButtons);
 
     QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
 
     QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QCOMPARE(canvas->rootObject()->property("pressed").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("released").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("clicked").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("pressed").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("released").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("clicked").toInt(), 1);
 
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
     pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QCOMPARE(canvas->rootObject()->property("pressed").toInt(), 2);
-    QCOMPARE(canvas->rootObject()->property("released").toInt(), 2);
-    QCOMPARE(canvas->rootObject()->property("clicked").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("pressed").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("released").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("clicked").toInt(), 2);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::invalidClick()
@@ -679,90 +679,90 @@ void tst_QQuickMouseArea::invalidClick()
     QFETCH(Qt::MouseButtons, acceptedButtons);
     QFETCH(Qt::MouseButton, button);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("doubleclick.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("doubleclick.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseArea = canvas->rootObject()->findChild<QQuickMouseArea *>("mousearea");
+    QQuickMouseArea *mouseArea = window->rootObject()->findChild<QQuickMouseArea *>("mousearea");
     QVERIFY(mouseArea);
     mouseArea->setAcceptedButtons(acceptedButtons);
 
     // The sequence for a double click is:
     // press, release, (click), press, double click, release
     QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
 
     QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QCOMPARE(canvas->rootObject()->property("released").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("released").toInt(), 0);
 
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
     pressEvent = QMouseEvent(QEvent::MouseButtonDblClick, QPoint(100, 100), button, button, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QCOMPARE(canvas->rootObject()->property("clicked").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("doubleClicked").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("released").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("clicked").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("doubleClicked").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("released").toInt(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::pressedOrdering()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("pressedOrdering.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("pressedOrdering.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QCOMPARE(canvas->rootObject()->property("value").toString(), QLatin1String("base"));
+    QCOMPARE(window->rootObject()->property("value").toString(), QLatin1String("base"));
 
     QMouseEvent pressEvent(QEvent::MouseButtonPress, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
 
-    QCOMPARE(canvas->rootObject()->property("value").toString(), QLatin1String("pressed"));
+    QCOMPARE(window->rootObject()->property("value").toString(), QLatin1String("pressed"));
 
     QMouseEvent releaseEvent(QEvent::MouseButtonRelease, QPoint(100, 100), Qt::LeftButton, Qt::LeftButton, 0);
-    QGuiApplication::sendEvent(canvas, &releaseEvent);
+    QGuiApplication::sendEvent(window, &releaseEvent);
 
-    QCOMPARE(canvas->rootObject()->property("value").toString(), QLatin1String("toggled"));
+    QCOMPARE(window->rootObject()->property("value").toString(), QLatin1String("toggled"));
 
-    QGuiApplication::sendEvent(canvas, &pressEvent);
+    QGuiApplication::sendEvent(window, &pressEvent);
 
-    QCOMPARE(canvas->rootObject()->property("value").toString(), QLatin1String("pressed"));
+    QCOMPARE(window->rootObject()->property("value").toString(), QLatin1String("pressed"));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::preventStealing()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("preventstealing.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window->setSource(testFileUrl("preventstealing.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable*>(window->rootObject());
     QVERIFY(flickable != 0);
 
-    QQuickMouseArea *mouseArea = canvas->rootObject()->findChild<QQuickMouseArea*>("mousearea");
+    QQuickMouseArea *mouseArea = window->rootObject()->findChild<QQuickMouseArea*>("mousearea");
     QVERIFY(mouseArea != 0);
 
     QSignalSpy mousePositionSpy(mouseArea, SIGNAL(positionChanged(QQuickMouseEvent*)));
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(80, 80));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(80, 80));
 
     // Without preventStealing, mouse movement over MouseArea would
     // cause the Flickable to steal mouse and trigger content movement.
 
-    QTest::mouseMove(canvas,QPoint(69,69));
-    QTest::mouseMove(canvas,QPoint(58,58));
-    QTest::mouseMove(canvas,QPoint(47,47));
+    QTest::mouseMove(window,QPoint(69,69));
+    QTest::mouseMove(window,QPoint(58,58));
+    QTest::mouseMove(window,QPoint(47,47));
 
     // We should have received all three move events
     QCOMPARE(mousePositionSpy.count(), 3);
@@ -772,19 +772,19 @@ void tst_QQuickMouseArea::preventStealing()
     QCOMPARE(flickable->contentX(), 0.);
     QCOMPARE(flickable->contentY(), 0.);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(47, 47));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(47, 47));
 
     // Now allow stealing and confirm Flickable does its thing.
-    canvas->rootObject()->setProperty("stealing", false);
+    window->rootObject()->setProperty("stealing", false);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(80, 80));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(80, 80));
 
     // Without preventStealing, mouse movement over MouseArea would
     // cause the Flickable to steal mouse and trigger content movement.
 
-    QTest::mouseMove(canvas,QPoint(69,69));
-    QTest::mouseMove(canvas,QPoint(58,58));
-    QTest::mouseMove(canvas,QPoint(47,47));
+    QTest::mouseMove(window,QPoint(69,69));
+    QTest::mouseMove(window,QPoint(58,58));
+    QTest::mouseMove(window,QPoint(47,47));
 
     // We should only have received the first move event
     QCOMPARE(mousePositionSpy.count(), 4);
@@ -796,193 +796,193 @@ void tst_QQuickMouseArea::preventStealing()
     QCOMPARE(flickable->contentX(), 11.);
     QCOMPARE(flickable->contentY(), 11.);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(50, 50));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(50, 50));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::clickThrough()
 {
     QSKIP("QTBUG-23976 Unstable");
     //With no handlers defined click, doubleClick and PressAndHold should propagate to those with handlers
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("clickThrough.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("clickThrough.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
 
-    QTRY_COMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QTRY_COMPARE(canvas->rootObject()->property("clicks").toInt(), 1);
+    QTRY_COMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("clicks").toInt(), 1);
 
     // to avoid generating a double click.
     int doubleClickInterval = qApp->styleHints()->mouseDoubleClickInterval() + 10;
     QTest::qWait(doubleClickInterval);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(1000);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
 
-    QTRY_COMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QTRY_COMPARE(canvas->rootObject()->property("clicks").toInt(), 1);
-    QTRY_COMPARE(canvas->rootObject()->property("pressAndHolds").toInt(), 1);
+    QTRY_COMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("clicks").toInt(), 1);
+    QTRY_COMPARE(window->rootObject()->property("pressAndHolds").toInt(), 1);
 
-    QTest::mouseDClick(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseDClick(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(100);
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QTRY_COMPARE(canvas->rootObject()->property("clicks").toInt(), 2);
-    QTRY_COMPARE(canvas->rootObject()->property("doubleClicks").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("pressAndHolds").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("clicks").toInt(), 2);
+    QTRY_COMPARE(window->rootObject()->property("doubleClicks").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("pressAndHolds").toInt(), 1);
 
-    delete canvas;
+    delete window;
 
     //With handlers defined click, doubleClick and PressAndHold should propagate only when explicitly ignored
-    canvas = createView();
-    canvas->setSource(testFileUrl("clickThrough2.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window = createView();
+    window->setSource(testFileUrl("clickThrough2.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("clicks").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("clicks").toInt(), 0);
 
     QTest::qWait(doubleClickInterval); // to avoid generating a double click.
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(1000);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(100);
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("clicks").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("pressAndHolds").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("clicks").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("pressAndHolds").toInt(), 0);
 
-    QTest::mouseDClick(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseDClick(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(100);
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("clicks").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("doubleClicks").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("pressAndHolds").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("clicks").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("doubleClicks").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("pressAndHolds").toInt(), 0);
 
-    canvas->rootObject()->setProperty("letThrough", QVariant(true));
+    window->rootObject()->setProperty("letThrough", QVariant(true));
 
     QTest::qWait(doubleClickInterval); // to avoid generating a double click.
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QTRY_COMPARE(canvas->rootObject()->property("clicks").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("clicks").toInt(), 1);
 
     QTest::qWait(doubleClickInterval); // to avoid generating a double click.
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(1000);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(100);
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("clicks").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("pressAndHolds").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("clicks").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("pressAndHolds").toInt(), 1);
 
-    QTest::mouseDClick(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseDClick(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(100);
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QTRY_COMPARE(canvas->rootObject()->property("clicks").toInt(), 2);
-    QCOMPARE(canvas->rootObject()->property("doubleClicks").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("pressAndHolds").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("clicks").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("doubleClicks").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("pressAndHolds").toInt(), 1);
 
-    canvas->rootObject()->setProperty("noPropagation", QVariant(true));
+    window->rootObject()->setProperty("noPropagation", QVariant(true));
 
     QTest::qWait(doubleClickInterval); // to avoid generating a double click.
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
 
     QTest::qWait(doubleClickInterval); // to avoid generating a double click.
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(1000);
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(100);
 
-    QTest::mouseDClick(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mouseDClick(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(100);
 
-    QCOMPARE(canvas->rootObject()->property("presses").toInt(), 0);
-    QTRY_COMPARE(canvas->rootObject()->property("clicks").toInt(), 2);
-    QCOMPARE(canvas->rootObject()->property("doubleClicks").toInt(), 1);
-    QCOMPARE(canvas->rootObject()->property("pressAndHolds").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("presses").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("clicks").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("doubleClicks").toInt(), 1);
+    QCOMPARE(window->rootObject()->property("pressAndHolds").toInt(), 1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::hoverPosition()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("hoverPosition.qml"));
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("hoverPosition.qml"));
 
-    QQuickItem *root = canvas->rootObject();
+    QQuickItem *root = window->rootObject();
     QVERIFY(root != 0);
 
     QCOMPARE(root->property("mouseX").toReal(), qreal(0));
     QCOMPARE(root->property("mouseY").toReal(), qreal(0));
 
-    QTest::mouseMove(canvas,QPoint(10,32));
+    QTest::mouseMove(window,QPoint(10,32));
 
 
     QCOMPARE(root->property("mouseX").toReal(), qreal(10));
     QCOMPARE(root->property("mouseY").toReal(), qreal(32));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::hoverPropagation()
 {
     //QTBUG-18175, to behave like GV did.
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("hoverPropagation.qml"));
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("hoverPropagation.qml"));
 
-    QQuickItem *root = canvas->rootObject();
+    QQuickItem *root = window->rootObject();
     QVERIFY(root != 0);
 
     QCOMPARE(root->property("point1").toBool(), false);
     QCOMPARE(root->property("point2").toBool(), false);
 
     QMouseEvent moveEvent(QEvent::MouseMove, QPoint(32, 32), Qt::NoButton, Qt::NoButton, 0);
-    QGuiApplication::sendEvent(canvas, &moveEvent);
+    QGuiApplication::sendEvent(window, &moveEvent);
 
     QCOMPARE(root->property("point1").toBool(), true);
     QCOMPARE(root->property("point2").toBool(), false);
 
     QMouseEvent moveEvent2(QEvent::MouseMove, QPoint(232, 32), Qt::NoButton, Qt::NoButton, 0);
-    QGuiApplication::sendEvent(canvas, &moveEvent2);
+    QGuiApplication::sendEvent(window, &moveEvent2);
     QCOMPARE(root->property("point1").toBool(), false);
     QCOMPARE(root->property("point2").toBool(), true);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::hoverVisible()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("hoverVisible.qml"));
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("hoverVisible.qml"));
 
-    QQuickItem *root = canvas->rootObject();
+    QQuickItem *root = window->rootObject();
     QVERIFY(root != 0);
 
-    QQuickMouseArea *mouseTracker = canvas->rootObject()->findChild<QQuickMouseArea*>("mousetracker");
+    QQuickMouseArea *mouseTracker = window->rootObject()->findChild<QQuickMouseArea*>("mousetracker");
     QVERIFY(mouseTracker != 0);
 
     QSignalSpy enteredSpy(mouseTracker, SIGNAL(entered()));
 
     // Note: We need to use a position that is different from the position in the last event
     // generated in the previous test case. Otherwise it is not interpreted as a move.
-    QTest::mouseMove(canvas,QPoint(11,33));
+    QTest::mouseMove(window,QPoint(11,33));
 
     QCOMPARE(mouseTracker->hovered(), false);
     QCOMPARE(enteredSpy.count(), 0);
@@ -994,19 +994,19 @@ void tst_QQuickMouseArea::hoverVisible()
 
     QCOMPARE(QPointF(mouseTracker->mouseX(), mouseTracker->mouseY()), QPointF(11,33));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::disableAfterPress()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("dragging.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("dragging.qml"));
+    window->show();
+    window->requestActivateWindow();
     QTest::qWait(20);
-    QVERIFY(canvas->rootObject() != 0);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseArea = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseArea = window->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QQuickDrag *drag = mouseArea->drag();
     QVERIFY(mouseArea != 0);
     QVERIFY(drag != 0);
@@ -1016,13 +1016,13 @@ void tst_QQuickMouseArea::disableAfterPress()
     QSignalSpy mouseReleaseSpy(mouseArea, SIGNAL(released(QQuickMouseEvent*)));
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
     QVERIFY(blackRect == drag->target());
 
     QVERIFY(!drag->active());
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
 
     QTRY_COMPARE(mousePressSpy.count(), 1);
 
@@ -1033,9 +1033,9 @@ void tst_QQuickMouseArea::disableAfterPress()
     // First move event triggers drag, second is acted upon.
     // This is due to possibility of higher stacked area taking precedence.
 
-    QTest::mouseMove(canvas, QPoint(111,111));
+    QTest::mouseMove(window, QPoint(111,111));
     QTest::qWait(50);
-    QTest::mouseMove(canvas, QPoint(122,122));
+    QTest::mouseMove(window, QPoint(122,122));
 
     QTRY_COMPARE(mousePositionSpy.count(), 2);
 
@@ -1046,9 +1046,9 @@ void tst_QQuickMouseArea::disableAfterPress()
     mouseArea->setEnabled(false);
 
     // move should still be acted upon
-    QTest::mouseMove(canvas, QPoint(133,133));
+    QTest::mouseMove(window, QPoint(133,133));
     QTest::qWait(50);
-    QTest::mouseMove(canvas, QPoint(144,144));
+    QTest::mouseMove(window, QPoint(144,144));
 
     QTRY_COMPARE(mousePositionSpy.count(), 4);
 
@@ -1059,7 +1059,7 @@ void tst_QQuickMouseArea::disableAfterPress()
     QVERIFY(mouseArea->pressed());
     QVERIFY(mouseArea->hovered());
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(144,144));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(144,144));
 
     QTRY_COMPARE(mouseReleaseSpy.count(), 1);
 
@@ -1078,13 +1078,13 @@ void tst_QQuickMouseArea::disableAfterPress()
     mousePositionSpy.clear();
     mouseReleaseSpy.clear();
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(100,100));
     QTest::qWait(50);
     QCOMPARE(mousePressSpy.count(), 0);
 
-    QTest::mouseMove(canvas, QPoint(111,111));
+    QTest::mouseMove(window, QPoint(111,111));
     QTest::qWait(50);
-    QTest::mouseMove(canvas, QPoint(122,122));
+    QTest::mouseMove(window, QPoint(122,122));
     QTest::qWait(50);
 
     QCOMPARE(mousePositionSpy.count(), 0);
@@ -1093,32 +1093,32 @@ void tst_QQuickMouseArea::disableAfterPress()
     QCOMPARE(blackRect->x(), 50.0);
     QCOMPARE(blackRect->y(), 50.0);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(122,122));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(122,122));
     QTest::qWait(50);
 
     QCOMPARE(mouseReleaseSpy.count(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::onWheel()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("wheel.qml"));
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("wheel.qml"));
 
-    QQuickItem *root = canvas->rootObject();
+    QQuickItem *root = window->rootObject();
     QVERIFY(root != 0);
 
     QWheelEvent wheelEvent(QPoint(10, 32), QPoint(10, 32), QPoint(60, 20), QPoint(0, 120),
                            0, Qt::Vertical,Qt::NoButton, Qt::ControlModifier);
-    QGuiApplication::sendEvent(canvas, &wheelEvent);
+    QGuiApplication::sendEvent(window, &wheelEvent);
 
     QCOMPARE(root->property("angleDeltaY").toInt(), 120);
     QCOMPARE(root->property("mouseX").toReal(), qreal(10));
     QCOMPARE(root->property("mouseY").toReal(), qreal(32));
     QCOMPARE(root->property("controlPressed").toBool(), true);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::transformedMouseArea_data()
@@ -1149,33 +1149,33 @@ void tst_QQuickMouseArea::transformedMouseArea()
     QFETCH(bool, insideTarget);
     QFETCH(QList<QPoint>, points);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("transformedMouseArea.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("transformedMouseArea.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMouseArea *mouseArea = canvas->rootObject()->findChild<QQuickMouseArea *>("mouseArea");
+    QQuickMouseArea *mouseArea = window->rootObject()->findChild<QQuickMouseArea *>("mouseArea");
     QVERIFY(mouseArea != 0);
 
     foreach (const QPoint &point, points) {
         // check hover
-        QTest::mouseMove(canvas, point);
+        QTest::mouseMove(window, point);
         QTest::qWait(10);
         QCOMPARE(mouseArea->property("containsMouse").toBool(), insideTarget);
 
         // check mouse press
-        QTest::mousePress(canvas, Qt::LeftButton, 0, point);
+        QTest::mousePress(window, Qt::LeftButton, 0, point);
         QTest::qWait(10);
         QCOMPARE(mouseArea->property("pressed").toBool(), insideTarget);
 
         // check mouse release
-        QTest::mouseRelease(canvas, Qt::LeftButton, 0, point);
+        QTest::mouseRelease(window, Qt::LeftButton, 0, point);
         QTest::qWait(10);
         QCOMPARE(mouseArea->property("pressed").toBool(), false);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMouseArea::pressedMultipleButtons_data()
@@ -1267,13 +1267,13 @@ void tst_QQuickMouseArea::pressedMultipleButtons()
     QFETCH(QList<Qt::MouseButtons>, pressedButtons);
     QFETCH(int, changeCount);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("simple.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *view = createView();
+    view->setSource(testFileUrl("simple.qml"));
+    view->show();
+    view->requestActivateWindow();
+    QVERIFY(view->rootObject() != 0);
 
-    QQuickMouseArea *mouseArea = canvas->rootObject()->findChild<QQuickMouseArea *>("mousearea");
+    QQuickMouseArea *mouseArea = view->rootObject()->findChild<QQuickMouseArea *>("mousearea");
     QVERIFY(mouseArea != 0);
 
     QSignalSpy pressedSpy(mouseArea, SIGNAL(pressedChanged()));
@@ -1287,7 +1287,7 @@ void tst_QQuickMouseArea::pressedMultipleButtons()
         int btns = buttons.at(i);
 
         // The windowsysteminterface takes care of sending releases
-        QTest::mousePress(canvas, (Qt::MouseButton)btns, 0, point);
+        QTest::mousePress(view, (Qt::MouseButton)btns, 0, point);
 
         QCOMPARE(mouseArea->pressed(), pressed.at(i));
         QCOMPARE(mouseArea->pressedButtons(), pressedButtons.at(i));
@@ -1295,25 +1295,25 @@ void tst_QQuickMouseArea::pressedMultipleButtons()
         prevButtons = buttons.at(i);
     }
 
-    QTest::mousePress(canvas, Qt::NoButton, 0, point);
+    QTest::mousePress(view, Qt::NoButton, 0, point);
     QCOMPARE(mouseArea->pressed(), false);
 
     QCOMPARE(pressedSpy.count(), 2);
     QCOMPARE(pressedButtonsSpy.count(), changeCount);
 
-    delete canvas;
+    delete view;
 }
 
 void tst_QQuickMouseArea::changeAxis()
 {
-    QQuickView *canvas = createView();
+    QQuickView *view = createView();
 
-    canvas->setSource(testFileUrl("changeAxis.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTRY_VERIFY(canvas->rootObject() != 0);
+    view->setSource(testFileUrl("changeAxis.qml"));
+    view->show();
+    view->requestActivateWindow();
+    QTRY_VERIFY(view->rootObject() != 0);
 
-    QQuickMouseArea *mouseRegion = canvas->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
+    QQuickMouseArea *mouseRegion = view->rootObject()->findChild<QQuickMouseArea*>("mouseregion");
     QQuickDrag *drag = mouseRegion->drag();
     QVERIFY(mouseRegion != 0);
     QVERIFY(drag != 0);
@@ -1321,22 +1321,22 @@ void tst_QQuickMouseArea::changeAxis()
     mouseRegion->setAcceptedButtons(Qt::LeftButton);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = view->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
     QVERIFY(blackRect == drag->target());
 
     QVERIFY(!drag->active());
 
     // Start a diagonal drag
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(100, 100));
+    QTest::mousePress(view, Qt::LeftButton, 0, QPoint(100, 100));
 
     QVERIFY(!drag->active());
     QCOMPARE(blackRect->x(), 50.0);
     QCOMPARE(blackRect->y(), 50.0);
 
-    QTest::mouseMove(canvas, QPoint(111, 111));
+    QTest::mouseMove(view, QPoint(111, 111));
     QTest::qWait(50);
-    QTest::mouseMove(canvas, QPoint(122, 122));
+    QTest::mouseMove(view, QPoint(122, 122));
 
     QTRY_VERIFY(drag->active());
     QCOMPARE(blackRect->x(), 72.0);
@@ -1346,24 +1346,24 @@ void tst_QQuickMouseArea::changeAxis()
     /* When blackRect.x becomes bigger than 75, the drag axis is changed to
      * Drag.YAxis by the QML code. Verify that this happens, and that the drag
      * movement is effectively constrained to the Y axis. */
-    QTest::mouseMove(canvas, QPoint(133, 133));
+    QTest::mouseMove(view, QPoint(133, 133));
 
     QTRY_COMPARE(blackRect->x(), 83.0);
     QTRY_COMPARE(blackRect->y(), 83.0);
     QTRY_COMPARE(drag->axis(), QQuickDrag::YAxis);
 
-    QTest::mouseMove(canvas, QPoint(144, 144));
+    QTest::mouseMove(view, QPoint(144, 144));
 
     QTRY_COMPARE(blackRect->y(), 94.0);
     QCOMPARE(blackRect->x(), 83.0);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(144, 144));
+    QTest::mouseRelease(view, Qt::LeftButton, 0, QPoint(144, 144));
 
     QTRY_VERIFY(!drag->active());
     QCOMPARE(blackRect->x(), 83.0);
     QCOMPARE(blackRect->y(), 94.0);
 
-    delete canvas;
+    delete view;
 }
 
 QTEST_MAIN(tst_QQuickMouseArea)
diff --git a/tests/auto/quick/qquickmultipointtoucharea/tst_qquickmultipointtoucharea.cpp b/tests/auto/quick/qquickmultipointtoucharea/tst_qquickmultipointtoucharea.cpp
index f657268..e3795c5 100644
--- a/tests/auto/quick/qquickmultipointtoucharea/tst_qquickmultipointtoucharea.cpp
+++ b/tests/auto/quick/qquickmultipointtoucharea/tst_qquickmultipointtoucharea.cpp
@@ -81,10 +81,10 @@ private:
 
 void tst_QQuickMultiPointTouchArea::properties()
 {
-    QQuickView *canvas = createAndShowView("properties.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("properties.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMultiPointTouchArea *area = qobject_cast<QQuickMultiPointTouchArea *>(canvas->rootObject());
+    QQuickMultiPointTouchArea *area = qobject_cast<QQuickMultiPointTouchArea *>(window->rootObject());
     QVERIFY(area != 0);
 
     QCOMPARE(area->minimumTouchPoints(), 2);
@@ -93,15 +93,15 @@ void tst_QQuickMultiPointTouchArea::properties()
     QQmlListReference ref(area, "touchPoints");
     QCOMPARE(ref.count(), 4);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMultiPointTouchArea::signalTest()
 {
-    QQuickView *canvas = createAndShowView("signalTest.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("signalTest.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMultiPointTouchArea *area = qobject_cast<QQuickMultiPointTouchArea *>(canvas->rootObject());
+    QQuickMultiPointTouchArea *area = qobject_cast<QQuickMultiPointTouchArea *>(window->rootObject());
     QVERIFY(area != 0);
 
     QPoint p1(20,100);
@@ -110,7 +110,7 @@ void tst_QQuickMultiPointTouchArea::signalTest()
     QPoint p4(80,100);
     QPoint p5(100,100);
 
-    QTest::QTouchEventSequence sequence = QTest::touchEvent(canvas, device);
+    QTest::QTouchEventSequence sequence = QTest::touchEvent(window, device);
 
     sequence.press(0, p1).press(1, p2).commit();
 
@@ -157,21 +157,21 @@ void tst_QQuickMultiPointTouchArea::signalTest()
     QCOMPARE(area->property("touchUpdatedHandled").toBool(), true);
     QMetaObject::invokeMethod(area, "clearCounts");
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMultiPointTouchArea::release()
 {
-    QQuickView *canvas = createAndShowView("basic.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("basic.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickTouchPoint *point1 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point1");
+    QQuickTouchPoint *point1 = window->rootObject()->findChild<QQuickTouchPoint*>("point1");
 
     QCOMPARE(point1->pressed(), false);
 
     QPoint p1(20,100);
 
-    QTest::QTouchEventSequence sequence = QTest::touchEvent(canvas, device);
+    QTest::QTouchEventSequence sequence = QTest::touchEvent(window, device);
 
     sequence.press(0, p1).commit();
 
@@ -192,17 +192,17 @@ void tst_QQuickMultiPointTouchArea::release()
     QCOMPARE(point1->pressed(), false);
     QCOMPARE(point1->x(), qreal(24)); QCOMPARE(point1->y(), qreal(120));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMultiPointTouchArea::reuse()
 {
-    QQuickView *canvas = createAndShowView("basic.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("basic.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickTouchPoint *point1 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point1");
-    QQuickTouchPoint *point2 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point2");
-    QQuickTouchPoint *point3 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point3");
+    QQuickTouchPoint *point1 = window->rootObject()->findChild<QQuickTouchPoint*>("point1");
+    QQuickTouchPoint *point2 = window->rootObject()->findChild<QQuickTouchPoint*>("point2");
+    QQuickTouchPoint *point3 = window->rootObject()->findChild<QQuickTouchPoint*>("point3");
 
     QCOMPARE(point1->pressed(), false);
     QCOMPARE(point2->pressed(), false);
@@ -212,7 +212,7 @@ void tst_QQuickMultiPointTouchArea::reuse()
     QPoint p3(60,100);
     QPoint p4(80,100);
 
-    QTest::QTouchEventSequence sequence = QTest::touchEvent(canvas, device);
+    QTest::QTouchEventSequence sequence = QTest::touchEvent(window, device);
 
     sequence.press(0, p1).press(1, p2).commit();
 
@@ -255,19 +255,19 @@ void tst_QQuickMultiPointTouchArea::reuse()
 
     QCOMPARE(point1->x(), qreal(80)); QCOMPARE(point1->y(), qreal(100));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMultiPointTouchArea::nonOverlapping()
 {
-    QQuickView *canvas = createAndShowView("nonOverlapping.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("nonOverlapping.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickTouchPoint *point11 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point11");
-    QQuickTouchPoint *point12 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point12");
-    QQuickTouchPoint *point21 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point21");
-    QQuickTouchPoint *point22 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point22");
-    QQuickTouchPoint *point23 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point23");
+    QQuickTouchPoint *point11 = window->rootObject()->findChild<QQuickTouchPoint*>("point11");
+    QQuickTouchPoint *point12 = window->rootObject()->findChild<QQuickTouchPoint*>("point12");
+    QQuickTouchPoint *point21 = window->rootObject()->findChild<QQuickTouchPoint*>("point21");
+    QQuickTouchPoint *point22 = window->rootObject()->findChild<QQuickTouchPoint*>("point22");
+    QQuickTouchPoint *point23 = window->rootObject()->findChild<QQuickTouchPoint*>("point23");
 
     QCOMPARE(point11->pressed(), false);
     QCOMPARE(point12->pressed(), false);
@@ -281,7 +281,7 @@ void tst_QQuickMultiPointTouchArea::nonOverlapping()
     QPoint p4(80,180);
     QPoint p5(100,180);
 
-    QTest::QTouchEventSequence sequence = QTest::touchEvent(canvas, device);
+    QTest::QTouchEventSequence sequence = QTest::touchEvent(window, device);
 
     sequence.press(0, p1).commit();
 
@@ -364,19 +364,19 @@ void tst_QQuickMultiPointTouchArea::nonOverlapping()
     QCOMPARE(point22->pressed(), false);
     QCOMPARE(point23->pressed(), false);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMultiPointTouchArea::nested()
 {
-    QQuickView *canvas = createAndShowView("nested.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("nested.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickTouchPoint *point11 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point11");
-    QQuickTouchPoint *point12 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point12");
-    QQuickTouchPoint *point21 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point21");
-    QQuickTouchPoint *point22 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point22");
-    QQuickTouchPoint *point23 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point23");
+    QQuickTouchPoint *point11 = window->rootObject()->findChild<QQuickTouchPoint*>("point11");
+    QQuickTouchPoint *point12 = window->rootObject()->findChild<QQuickTouchPoint*>("point12");
+    QQuickTouchPoint *point21 = window->rootObject()->findChild<QQuickTouchPoint*>("point21");
+    QQuickTouchPoint *point22 = window->rootObject()->findChild<QQuickTouchPoint*>("point22");
+    QQuickTouchPoint *point23 = window->rootObject()->findChild<QQuickTouchPoint*>("point23");
 
     QCOMPARE(point11->pressed(), false);
     QCOMPARE(point12->pressed(), false);
@@ -388,7 +388,7 @@ void tst_QQuickMultiPointTouchArea::nested()
     QPoint p2(40,100);
     QPoint p3(60,180);
 
-    QTest::QTouchEventSequence sequence = QTest::touchEvent(canvas, device);
+    QTest::QTouchEventSequence sequence = QTest::touchEvent(window, device);
 
     sequence.press(0, p1).commit();
 
@@ -502,7 +502,7 @@ void tst_QQuickMultiPointTouchArea::nested()
     sequence.release(0, p1).commit();
 
     //test with grabbing turned off
-    canvas->rootObject()->setProperty("grabInnerArea", false);
+    window->rootObject()->setProperty("grabInnerArea", false);
 
     sequence.press(0, p1).press(1, p2).press(2, p3).commit();
 
@@ -549,19 +549,19 @@ void tst_QQuickMultiPointTouchArea::nested()
 
     sequence.release(0, p1).release(1, p2).release(2, p3).commit();
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMultiPointTouchArea::inFlickable()
 {
-    QQuickView *canvas = createAndShowView("inFlickable.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("inFlickable.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = qobject_cast<QQuickFlickable *>(canvas->rootObject());
+    QQuickFlickable *flickable = qobject_cast<QQuickFlickable *>(window->rootObject());
     QVERIFY(flickable != 0);
 
-    QQuickTouchPoint *point11 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point1");
-    QQuickTouchPoint *point12 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point2");
+    QQuickTouchPoint *point11 = window->rootObject()->findChild<QQuickTouchPoint*>("point1");
+    QQuickTouchPoint *point12 = window->rootObject()->findChild<QQuickTouchPoint*>("point2");
 
     QCOMPARE(point11->pressed(), false);
     QCOMPARE(point12->pressed(), false);
@@ -570,33 +570,33 @@ void tst_QQuickMultiPointTouchArea::inFlickable()
     QPoint p2(40,100);
 
     //moving one point vertically
-    QTest::touchEvent(canvas, device).press(0, p1);
+    QTest::touchEvent(window, device).press(0, p1);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     QVERIFY(flickable->contentY() < 0);
     QCOMPARE(point11->pressed(), false);
     QCOMPARE(point12->pressed(), false);
 
-    QTest::touchEvent(canvas, device).release(0, p1);
+    QTest::touchEvent(window, device).release(0, p1);
     QTest::qWait(50);
 
     QTRY_VERIFY(!flickable->isMoving());
 
     //moving two points vertically
     p1 = QPoint(20,100);
-    QTest::touchEvent(canvas, device).press(0, p1).press(1, p2);
-    QTest::mousePress(canvas, Qt::LeftButton, 0, p1);
+    QTest::touchEvent(window, device).press(0, p1).press(1, p2);
+    QTest::mousePress(window, Qt::LeftButton, 0, p1);
 
     QCOMPARE(point11->pressed(), true);
     QCOMPARE(point12->pressed(), true);
@@ -604,20 +604,20 @@ void tst_QQuickMultiPointTouchArea::inFlickable()
     QCOMPARE(flickable->property("touchCount").toInt(), 2);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     QVERIFY(flickable->contentY() < 0);
     QCOMPARE(point11->pressed(), false);
@@ -625,8 +625,8 @@ void tst_QQuickMultiPointTouchArea::inFlickable()
     QCOMPARE(flickable->property("cancelCount").toInt(), 2);
     QCOMPARE(flickable->property("touchCount").toInt(), 0);
 
-    QTest::touchEvent(canvas, device).release(0, p1).release(1, p2);
-    QTest::mouseRelease(canvas,Qt::LeftButton, 0, p1);
+    QTest::touchEvent(window, device).release(0, p1).release(1, p2);
+    QTest::mouseRelease(window,Qt::LeftButton, 0, p1);
     QTest::qWait(50);
 
     QTRY_VERIFY(!flickable->isMoving());
@@ -634,65 +634,65 @@ void tst_QQuickMultiPointTouchArea::inFlickable()
     //moving two points horizontally, then one point vertically
     p1 = QPoint(20,100);
     p2 = QPoint(40,100);
-    QTest::touchEvent(canvas, device).press(0, p1).press(1, p2);
-    QTest::mousePress(canvas, Qt::LeftButton, 0, p1);
+    QTest::touchEvent(window, device).press(0, p1).press(1, p2);
+    QTest::mousePress(window, Qt::LeftButton, 0, p1);
 
     QCOMPARE(point11->pressed(), true);
     QCOMPARE(point12->pressed(), true);
 
     p1 += QPoint(15,0); p2 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(15,0); p2 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(15,0); p2 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(15,0); p2 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(0,15); p2 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1).move(1, p2);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1).move(1, p2);
+    QTest::mouseMove(window, p1);
 
     QVERIFY(flickable->contentY() == 0);
     QCOMPARE(point11->pressed(), true);
     QCOMPARE(point12->pressed(), true);
 
-    QTest::touchEvent(canvas, device).release(0, p1).release(1, p2);
-    QTest::mouseRelease(canvas,Qt::LeftButton, 0, p1);
+    QTest::touchEvent(window, device).release(0, p1).release(1, p2);
+    QTest::mouseRelease(window,Qt::LeftButton, 0, p1);
     QTest::qWait(50);
 
-    delete canvas;
+    delete window;
 }
 
 // test that dragging out of a Flickable containing a MPTA doesn't harm Flickable's state.
 void tst_QQuickMultiPointTouchArea::inFlickable2()
 {
-    QQuickView *canvas = createAndShowView("inFlickable2.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("inFlickable2.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = canvas->rootObject()->findChild<QQuickFlickable*>("flickable");
+    QQuickFlickable *flickable = window->rootObject()->findChild<QQuickFlickable*>("flickable");
     QVERIFY(flickable != 0);
 
-    QQuickTouchPoint *point11 = canvas->rootObject()->findChild<QQuickTouchPoint*>("point1");
+    QQuickTouchPoint *point11 = window->rootObject()->findChild<QQuickTouchPoint*>("point1");
     QVERIFY(point11);
 
     QCOMPARE(point11->pressed(), false);
@@ -700,72 +700,72 @@ void tst_QQuickMultiPointTouchArea::inFlickable2()
     QPoint p1(50,100);
 
     // move point horizontally, out of Flickable area
-    QTest::touchEvent(canvas, device).press(0, p1);
-    QTest::mousePress(canvas, Qt::LeftButton, 0, p1);
+    QTest::touchEvent(window, device).press(0, p1);
+    QTest::mousePress(window, Qt::LeftButton, 0, p1);
 
     p1 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1);
+    QTest::mouseMove(window, p1);
 
     p1 += QPoint(15,0);
-    QTest::touchEvent(canvas, device).move(0, p1);
-    QTest::mouseMove(canvas, p1);
+    QTest::touchEvent(window, device).move(0, p1);
+    QTest::mouseMove(window, p1);
 
     QVERIFY(!flickable->isMoving());
     QVERIFY(point11->pressed());
 
-    QTest::touchEvent(canvas, device).release(0, p1);
-    QTest::mouseRelease(canvas,Qt::LeftButton, 0, p1);
+    QTest::touchEvent(window, device).release(0, p1);
+    QTest::mouseRelease(window,Qt::LeftButton, 0, p1);
     QTest::qWait(50);
 
     QTRY_VERIFY(!flickable->isMoving());
 
     // Check that we can still move the Flickable
     p1 = QPoint(50,100);
-    QTest::touchEvent(canvas, device).press(0, p1);
+    QTest::touchEvent(window, device).press(0, p1);
 
     QCOMPARE(point11->pressed(), true);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     p1 += QPoint(0,15);
-    QTest::touchEvent(canvas, device).move(0, p1);
+    QTest::touchEvent(window, device).move(0, p1);
 
     QVERIFY(flickable->contentY() < 0);
     QVERIFY(flickable->isMoving());
     QCOMPARE(point11->pressed(), true);
 
-    QTest::touchEvent(canvas, device).release(0, p1);
+    QTest::touchEvent(window, device).release(0, p1);
     QTest::qWait(50);
 
     QTRY_VERIFY(!flickable->isMoving());
 
 
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-23327
 void tst_QQuickMultiPointTouchArea::invisible()
 {
-    QQuickView *canvas = createAndShowView("signalTest.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createAndShowView("signalTest.qml");
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickMultiPointTouchArea *area = qobject_cast<QQuickMultiPointTouchArea *>(canvas->rootObject());
+    QQuickMultiPointTouchArea *area = qobject_cast<QQuickMultiPointTouchArea *>(window->rootObject());
     QVERIFY(area != 0);
 
     area->setVisible(false);
@@ -773,7 +773,7 @@ void tst_QQuickMultiPointTouchArea::invisible()
     QPoint p1(20,100);
     QPoint p2(40,100);
 
-    QTest::QTouchEventSequence sequence = QTest::touchEvent(canvas, device);
+    QTest::QTouchEventSequence sequence = QTest::touchEvent(window, device);
 
     sequence.press(0, p1).press(1, p2).commit();
 
@@ -782,7 +782,7 @@ void tst_QQuickMultiPointTouchArea::invisible()
     QCOMPARE(area->property("touchPointReleaseCount").toInt(), 0);
     QCOMPARE(area->property("touchCount").toInt(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickMultiPointTouchArea::transformedTouchArea_data()
@@ -825,13 +825,13 @@ void tst_QQuickMultiPointTouchArea::transformedTouchArea()
     QFETCH(int, total2);
     QFETCH(int, total3);
 
-    QQuickView *canvas = createAndShowView("transformedMultiPointTouchArea.qml");
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *view = createAndShowView("transformedMultiPointTouchArea.qml");
+    QVERIFY(view->rootObject() != 0);
 
-    QQuickMultiPointTouchArea *area = canvas->rootObject()->findChild<QQuickMultiPointTouchArea *>("touchArea");
+    QQuickMultiPointTouchArea *area = view->rootObject()->findChild<QQuickMultiPointTouchArea *>("touchArea");
     QVERIFY(area != 0);
 
-    QTest::QTouchEventSequence sequence = QTest::touchEvent(canvas, device);
+    QTest::QTouchEventSequence sequence = QTest::touchEvent(view, device);
 
     sequence.press(0, p1).commit();
     QCOMPARE(area->property("pointCount").toInt(), total1);
@@ -842,18 +842,18 @@ void tst_QQuickMultiPointTouchArea::transformedTouchArea()
     sequence.stationary(0).stationary(1).press(2, p3).commit();
     QCOMPARE(area->property("pointCount").toInt(), total3);
 
-    delete canvas;
+    delete view;
 }
 
 QQuickView *tst_QQuickMultiPointTouchArea::createAndShowView(const QString &file)
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setSource(testFileUrl(file));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
+    QQuickView *window = new QQuickView(0);
+    window->setSource(testFileUrl(file));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
 
-    return canvas;
+    return window;
 }
 
 QTEST_MAIN(tst_QQuickMultiPointTouchArea)
diff --git a/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp b/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp
index d857535..fad068b 100644
--- a/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp
+++ b/tests/auto/quick/qquickpathview/tst_qquickpathview.cpp
@@ -196,7 +196,7 @@ void tst_QQuickPathView::initValues()
 
 void tst_QQuickPathView::items()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QaimModel model;
     model.addItem("Fred", "12345");
@@ -204,17 +204,17 @@ void tst_QQuickPathView::items()
     model.addItem("Bob", "54321");
     model.addItem("Bill", "4321");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathview0.qml"));
+    window->setSource(testFileUrl("pathview0.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     QCOMPARE(pathview->count(), model.count());
-    QCOMPARE(canvas->rootObject()->property("count").toInt(), model.count());
+    QCOMPARE(window->rootObject()->property("count").toInt(), model.count());
     QCOMPARE(pathview->childItems().count(), model.count()+1); // assumes all are visible, including highlight
 
     for (int i = 0; i < model.count(); ++i) {
@@ -236,7 +236,7 @@ void tst_QQuickPathView::items()
     offset.setY(pathview->highlightItem()->height()/2);
     QCOMPARE(pathview->highlightItem()->pos() + offset, start);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::pathview2()
@@ -327,8 +327,8 @@ void tst_QQuickPathView::insertModel()
     QFETCH(qreal, offset);
     QFETCH(int, currentIndex);
 
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     model.addItem("Ben", "12345");
@@ -340,13 +340,13 @@ void tst_QQuickPathView::insertModel()
     model.addItem("Jimmy", "3535");
     model.addItem("Barb", "9039");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathview0.qml"));
+    window->setSource(testFileUrl("pathview0.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     pathview->setHighlightRangeMode((QQuickPathView::HighlightRangeMode)mode);
@@ -366,7 +366,7 @@ void tst_QQuickPathView::insertModel()
 
     QCOMPARE(pathview->currentIndex(), currentIndex);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::removeModel_data()
@@ -421,8 +421,8 @@ void tst_QQuickPathView::removeModel()
     QFETCH(qreal, offset);
     QFETCH(int, currentIndex);
 
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     model.addItem("Ben", "12345");
@@ -434,13 +434,13 @@ void tst_QQuickPathView::removeModel()
     model.addItem("Jimmy", "3535");
     model.addItem("Barb", "9039");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathview0.qml"));
+    window->setSource(testFileUrl("pathview0.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     pathview->setHighlightRangeMode((QQuickPathView::HighlightRangeMode)mode);
@@ -456,7 +456,7 @@ void tst_QQuickPathView::removeModel()
 
     QCOMPARE(pathview->currentIndex(), currentIndex);
 
-    delete canvas;
+    delete window;
 }
 
 
@@ -516,8 +516,8 @@ void tst_QQuickPathView::moveModel()
     QFETCH(qreal, offset);
     QFETCH(int, currentIndex);
 
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     model.addItem("Ben", "12345");
@@ -529,13 +529,13 @@ void tst_QQuickPathView::moveModel()
     model.addItem("Jimmy", "3535");
     model.addItem("Barb", "9039");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathview0.qml"));
+    window->setSource(testFileUrl("pathview0.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     pathview->setHighlightRangeMode((QQuickPathView::HighlightRangeMode)mode);
@@ -551,7 +551,7 @@ void tst_QQuickPathView::moveModel()
 
     QCOMPARE(pathview->currentIndex(), currentIndex);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::consecutiveModelChanges_data()
@@ -617,8 +617,8 @@ void tst_QQuickPathView::consecutiveModelChanges()
     QFETCH(qreal, offset);
     QFETCH(int, currentIndex);
 
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     model.addItem("Ben", "12345");
@@ -630,13 +630,13 @@ void tst_QQuickPathView::consecutiveModelChanges()
     model.addItem("Jimmy", "3535");
     model.addItem("Barb", "9039");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathview0.qml"));
+    window->setSource(testFileUrl("pathview0.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     pathview->setHighlightRangeMode(mode);
@@ -681,7 +681,7 @@ void tst_QQuickPathView::consecutiveModelChanges()
 
     QCOMPARE(pathview->currentIndex(), currentIndex);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::path()
@@ -733,10 +733,10 @@ void tst_QQuickPathView::path()
 
 void tst_QQuickPathView::dataModel()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
@@ -757,13 +757,13 @@ void tst_QQuickPathView::dataModel()
 
     ctxt->setContextProperty("testData", &model);
 
-    canvas->setSource(testFileUrl("datamodel.qml"));
+    window->setSource(testFileUrl("datamodel.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(canvas->rootObject());
+    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != 0);
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QVERIFY(testObject->error() == false);
 
     QQuickItem *item = findItem<QQuickItem>(pathview, "wrapper", 0);
@@ -774,7 +774,7 @@ void tst_QQuickPathView::dataModel()
     model.insertItem(4, "orange", "10");
     QTest::qWait(100);
 
-    QCOMPARE(canvas->rootObject()->property("viewCount").toInt(), model.count());
+    QCOMPARE(window->rootObject()->property("viewCount").toInt(), model.count());
     QTRY_COMPARE(findItems<QQuickItem>(pathview, "wrapper").count(), 14);
 
     QVERIFY(pathview->currentIndex() == 0);
@@ -785,14 +785,14 @@ void tst_QQuickPathView::dataModel()
     QCOMPARE(text->text(), model.name(4));
 
     model.removeItem(2);
-    QCOMPARE(canvas->rootObject()->property("viewCount").toInt(), model.count());
+    QCOMPARE(window->rootObject()->property("viewCount").toInt(), model.count());
     text = findItem<QQuickText>(pathview, "myText", 2);
     QVERIFY(text);
     QCOMPARE(text->text(), model.name(2));
     QCOMPARE(pathview->currentItem(), findItem<QQuickItem>(pathview, "wrapper", 0));
 
     testObject->setPathItemCount(5);
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QVERIFY(testObject->error() == false);
 
     QTRY_COMPARE(findItems<QQuickItem>(pathview, "wrapper").count(), 5);
@@ -842,14 +842,14 @@ void tst_QQuickPathView::dataModel()
     model.removeItem(model.count()-1);
     QCOMPARE(pathview->currentIndex(), model.count()-1);
 
-    delete canvas;
+    delete window;
     delete testObject;
 }
 
 void tst_QQuickPathView::pathMoved()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     model.addItem("Ben", "12345");
@@ -857,13 +857,13 @@ void tst_QQuickPathView::pathMoved()
     model.addItem("Bob", "54321");
     model.addItem("Bill", "4321");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathview0.qml"));
+    window->setSource(testFileUrl("pathview0.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     QQuickRectangle *firstItem = findItem<QQuickRectangle>(pathview, "wrapper", 0);
@@ -892,7 +892,7 @@ void tst_QQuickPathView::pathMoved()
     // Change delegate size
     pathview->setOffset(0.1);
     pathview->setOffset(0.0);
-    canvas->rootObject()->setProperty("delegateWidth", 30);
+    window->rootObject()->setProperty("delegateWidth", 30);
     QCOMPARE(firstItem->width(), 30.0);
     offset.setX(firstItem->width()/2);
     QTRY_COMPARE(firstItem->pos() + offset, start);
@@ -900,10 +900,10 @@ void tst_QQuickPathView::pathMoved()
     // Change delegate scale
     pathview->setOffset(0.1);
     pathview->setOffset(0.0);
-    canvas->rootObject()->setProperty("delegateScale", 1.2);
+    window->rootObject()->setProperty("delegateScale", 1.2);
     QTRY_COMPARE(firstItem->pos() + offset, start);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::offset_data()
@@ -937,8 +937,8 @@ void tst_QQuickPathView::offset()
 
 void tst_QQuickPathView::setCurrentIndex()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
     model.addItem("Ben", "12345");
@@ -946,13 +946,13 @@ void tst_QQuickPathView::setCurrentIndex()
     model.addItem("Bob", "54321");
     model.addItem("Bill", "4321");
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathview0.qml"));
+    window->setSource(testFileUrl("pathview0.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     QQuickRectangle *firstItem = findItem<QQuickRectangle>(pathview, "wrapper", 0);
@@ -964,15 +964,15 @@ void tst_QQuickPathView::setCurrentIndex()
     offset.setX(firstItem->width()/2);
     offset.setY(firstItem->height()/2);
     QCOMPARE(firstItem->pos() + offset, start);
-    QCOMPARE(canvas->rootObject()->property("currentA").toInt(), 0);
-    QCOMPARE(canvas->rootObject()->property("currentB").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("currentA").toInt(), 0);
+    QCOMPARE(window->rootObject()->property("currentB").toInt(), 0);
 
     pathview->setCurrentIndex(2);
 
     firstItem = findItem<QQuickRectangle>(pathview, "wrapper", 2);
     QTRY_COMPARE(firstItem->pos() + offset, start);
-    QCOMPARE(canvas->rootObject()->property("currentA").toInt(), 2);
-    QCOMPARE(canvas->rootObject()->property("currentB").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("currentA").toInt(), 2);
+    QCOMPARE(window->rootObject()->property("currentB").toInt(), 2);
     QCOMPARE(pathview->currentItem(), firstItem);
     QCOMPARE(firstItem->property("onPath"), QVariant(true));
 
@@ -1080,24 +1080,24 @@ void tst_QQuickPathView::setCurrentIndex()
     QCOMPARE(pathview->currentItem(), firstItem);
     QCOMPARE(firstItem->property("onPath"), QVariant(true));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::resetModel()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QStringList strings;
     strings << "one" << "two" << "three";
     QStringListModel model(strings);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("displaypath.qml"));
+    window->setSource(testFileUrl("displaypath.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     QCOMPARE(pathview->count(), model.rowCount());
@@ -1120,16 +1120,16 @@ void tst_QQuickPathView::resetModel()
         QCOMPARE(display->text(), strings.at(i));
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::propertyChanges()
 {
-    QQuickView *canvas = createView();
-    QVERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychanges.qml"));
+    QQuickView *window = createView();
+    QVERIFY(window);
+    window->setSource(testFileUrl("propertychanges.qml"));
 
-    QQuickPathView *pathView = canvas->rootObject()->findChild<QQuickPathView*>("pathView");
+    QQuickPathView *pathView = window->rootObject()->findChild<QQuickPathView*>("pathView");
     QVERIFY(pathView);
 
     QSignalSpy snapPositionSpy(pathView, SIGNAL(preferredHighlightBeginChanged()));
@@ -1162,19 +1162,19 @@ void tst_QQuickPathView::propertyChanges()
     pathView->setMaximumFlickVelocity(1000);
     QCOMPARE(maximumFlickVelocitySpy.count(), 1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::pathChanges()
 {
-    QQuickView *canvas = createView();
-    QVERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychanges.qml"));
+    QQuickView *window = createView();
+    QVERIFY(window);
+    window->setSource(testFileUrl("propertychanges.qml"));
 
-    QQuickPathView *pathView = canvas->rootObject()->findChild<QQuickPathView*>("pathView");
+    QQuickPathView *pathView = window->rootObject()->findChild<QQuickPathView*>("pathView");
     QVERIFY(pathView);
 
-    QQuickPath *path = canvas->rootObject()->findChild<QQuickPath*>("path");
+    QQuickPath *path = window->rootObject()->findChild<QQuickPath*>("path");
     QVERIFY(path);
 
     QSignalSpy startXSpy(path, SIGNAL(startXChanged()));
@@ -1198,7 +1198,7 @@ void tst_QQuickPathView::pathChanges()
     QCOMPARE(startXSpy.count(),1);
     QCOMPARE(startYSpy.count(),1);
 
-    QQuickPath *alternatePath = canvas->rootObject()->findChild<QQuickPath*>("alternatePath");
+    QQuickPath *alternatePath = window->rootObject()->findChild<QQuickPath*>("alternatePath");
     QVERIFY(alternatePath);
 
     QSignalSpy pathSpy(pathView, SIGNAL(pathChanged()));
@@ -1212,7 +1212,7 @@ void tst_QQuickPathView::pathChanges()
     pathView->setPath(alternatePath);
     QCOMPARE(pathSpy.count(),1);
 
-    QQuickPathAttribute *pathAttribute = canvas->rootObject()->findChild<QQuickPathAttribute*>("pathAttribute");
+    QQuickPathAttribute *pathAttribute = window->rootObject()->findChild<QQuickPathAttribute*>("pathAttribute");
     QVERIFY(pathAttribute);
 
     QSignalSpy nameSpy(pathAttribute, SIGNAL(nameChanged()));
@@ -1224,19 +1224,19 @@ void tst_QQuickPathView::pathChanges()
 
     pathAttribute->setName("scale");
     QCOMPARE(nameSpy.count(),1);
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::componentChanges()
 {
-    QQuickView *canvas = createView();
-    QVERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychanges.qml"));
+    QQuickView *window = createView();
+    QVERIFY(window);
+    window->setSource(testFileUrl("propertychanges.qml"));
 
-    QQuickPathView *pathView = canvas->rootObject()->findChild<QQuickPathView*>("pathView");
+    QQuickPathView *pathView = window->rootObject()->findChild<QQuickPathView*>("pathView");
     QVERIFY(pathView);
 
-    QQmlComponent delegateComponent(canvas->engine());
+    QQmlComponent delegateComponent(window->engine());
     delegateComponent.setData("import QtQuick 2.0; Text { text: '<b>Name:</b> ' + name }", QUrl::fromLocalFile(""));
 
     QSignalSpy delegateSpy(pathView, SIGNAL(delegateChanged()));
@@ -1247,19 +1247,19 @@ void tst_QQuickPathView::componentChanges()
 
     pathView->setDelegate(&delegateComponent);
     QCOMPARE(delegateSpy.count(),1);
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::modelChanges()
 {
-    QQuickView *canvas = createView();
-    QVERIFY(canvas);
-    canvas->setSource(testFileUrl("propertychanges.qml"));
+    QQuickView *window = createView();
+    QVERIFY(window);
+    window->setSource(testFileUrl("propertychanges.qml"));
 
-    QQuickPathView *pathView = canvas->rootObject()->findChild<QQuickPathView*>("pathView");
+    QQuickPathView *pathView = window->rootObject()->findChild<QQuickPathView*>("pathView");
     QVERIFY(pathView);
 
-    QQuickListModel *alternateModel = canvas->rootObject()->findChild<QQuickListModel*>("alternateModel");
+    QQuickListModel *alternateModel = window->rootObject()->findChild<QQuickListModel*>("alternateModel");
     QVERIFY(alternateModel);
     QVariant modelVariant = QVariant::fromValue<QObject *>(alternateModel);
     QSignalSpy modelSpy(pathView, SIGNAL(modelChanged()));
@@ -1274,19 +1274,19 @@ void tst_QQuickPathView::modelChanges()
     pathView->setModel(QVariant());
     QCOMPARE(modelSpy.count(),2);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::pathUpdateOnStartChanged()
 {
-    QQuickView *canvas = createView();
-    QVERIFY(canvas);
-    canvas->setSource(testFileUrl("pathUpdateOnStartChanged.qml"));
+    QQuickView *window = createView();
+    QVERIFY(window);
+    window->setSource(testFileUrl("pathUpdateOnStartChanged.qml"));
 
-    QQuickPathView *pathView = canvas->rootObject()->findChild<QQuickPathView*>("pathView");
+    QQuickPathView *pathView = window->rootObject()->findChild<QQuickPathView*>("pathView");
     QVERIFY(pathView);
 
-    QQuickPath *path = canvas->rootObject()->findChild<QQuickPath*>("path");
+    QQuickPath *path = window->rootObject()->findChild<QQuickPath*>("path");
     QVERIFY(path);
     QCOMPARE(path->startX(), 400.0);
     QCOMPARE(path->startY(), 300.0);
@@ -1296,18 +1296,18 @@ void tst_QQuickPathView::pathUpdateOnStartChanged()
     QCOMPARE(item->x(), path->startX() - item->width() / 2.0);
     QCOMPARE(item->y(), path->startY() - item->height() / 2.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::package()
 {
-    QQuickView *canvas = createView();
-    QVERIFY(canvas);
-    canvas->setSource(testFileUrl("pathview_package.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    QQuickView *window = createView();
+    QVERIFY(window);
+    window->setSource(testFileUrl("pathview_package.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickPathView *pathView = canvas->rootObject()->findChild<QQuickPathView*>("photoPathView");
+    QQuickPathView *pathView = window->rootObject()->findChild<QQuickPathView*>("photoPathView");
     QVERIFY(pathView);
 
 #ifdef Q_OS_MAC
@@ -1318,28 +1318,28 @@ void tst_QQuickPathView::package()
     QVERIFY(item);
     QVERIFY(item->scale() != 1.0);
 
-    delete canvas;
+    delete window;
 }
 
 //QTBUG-13017
 void tst_QQuickPathView::emptyModel()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QStringListModel model;
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("emptyModel", &model);
 
-    canvas->setSource(testFileUrl("emptymodel.qml"));
+    window->setSource(testFileUrl("emptymodel.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(canvas->rootObject());
+    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != 0);
 
     QCOMPARE(pathview->offset(), qreal(0.0));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::closed()
@@ -1366,18 +1366,18 @@ void tst_QQuickPathView::closed()
 // QTBUG-14239
 void tst_QQuickPathView::pathUpdate()
 {
-    QQuickView *canvas = createView();
-    QVERIFY(canvas);
-    canvas->setSource(testFileUrl("pathUpdate.qml"));
+    QQuickView *window = createView();
+    QVERIFY(window);
+    window->setSource(testFileUrl("pathUpdate.qml"));
 
-    QQuickPathView *pathView = canvas->rootObject()->findChild<QQuickPathView*>("pathView");
+    QQuickPathView *pathView = window->rootObject()->findChild<QQuickPathView*>("pathView");
     QVERIFY(pathView);
 
     QQuickItem *item = findItem<QQuickItem>(pathView, "wrapper", 0);
     QVERIFY(item);
     QCOMPARE(item->x(), 150.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::visualDataModel()
@@ -1418,14 +1418,14 @@ void tst_QQuickPathView::undefinedPath()
 
 void tst_QQuickPathView::mouseDrag()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("dragpath.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_COMPARE(canvas, qGuiApp->focusWindow());
-
-    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(canvas->rootObject());
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("dragpath.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_COMPARE(window, qGuiApp->focusWindow());
+
+    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != 0);
 
     QSignalSpy movingSpy(pathview, SIGNAL(movingChanged()));
@@ -1437,12 +1437,12 @@ void tst_QQuickPathView::mouseDrag()
 
     int current = pathview->currentIndex();
 
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(10,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(10,100));
     QTest::qWait(100);
 
     {
         QMouseEvent mv(QEvent::MouseMove, QPoint(30,100), Qt::LeftButton, Qt::LeftButton,Qt::NoModifier);
-        QGuiApplication::sendEvent(canvas, &mv);
+        QGuiApplication::sendEvent(window, &mv);
     }
     // first move beyond threshold does not trigger drag
     QVERIFY(!pathview->isMoving());
@@ -1456,7 +1456,7 @@ void tst_QQuickPathView::mouseDrag()
 
     {
         QMouseEvent mv(QEvent::MouseMove, QPoint(90,100), Qt::LeftButton, Qt::LeftButton,Qt::NoModifier);
-        QGuiApplication::sendEvent(canvas, &mv);
+        QGuiApplication::sendEvent(window, &mv);
     }
     // next move beyond threshold does trigger drag
     QVERIFY(pathview->isMoving());
@@ -1470,7 +1470,7 @@ void tst_QQuickPathView::mouseDrag()
 
     QVERIFY(pathview->currentIndex() != current);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(40,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(40,100));
     QVERIFY(!pathview->isDragging());
     QCOMPARE(draggingSpy.count(), 2);
     QCOMPARE(dragStartedSpy.count(), 1);
@@ -1479,22 +1479,22 @@ void tst_QQuickPathView::mouseDrag()
     QTRY_COMPARE(moveEndedSpy.count(), 1);
     QCOMPARE(moveStartedSpy.count(), 1);
 
-    delete canvas;
+    delete window;
 }
 
 #ifndef QT_NO_WIDGETS
 void tst_QQuickPathView::treeModel()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QStandardItemModel model;
     initStandardTreeModel(&model);
-    canvas->engine()->rootContext()->setContextProperty("myModel", &model);
+    window->engine()->rootContext()->setContextProperty("myModel", &model);
 
-    canvas->setSource(testFileUrl("treemodel.qml"));
+    window->setSource(testFileUrl("treemodel.qml"));
 
-    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(canvas->rootObject());
+    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != 0);
     QCOMPARE(pathview->count(), 3);
 
@@ -1508,21 +1508,21 @@ void tst_QQuickPathView::treeModel()
     QTRY_VERIFY(item = findItem<QQuickText>(pathview, "wrapper", 0));
     QTRY_COMPARE(item->text(), QLatin1String("Row 2 Child Item"));
 
-    delete canvas;
+    delete window;
 }
 #endif
 
 void tst_QQuickPathView::changePreferredHighlight()
 {
-    QQuickView *canvas = createView();
-    canvas->setGeometry(0,0,400,200);
-    canvas->setSource(testFileUrl("dragpath.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_COMPARE(canvas, qGuiApp->focusWindow());
-
-    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(canvas->rootObject());
+    QQuickView *window = createView();
+    window->setGeometry(0,0,400,200);
+    window->setSource(testFileUrl("dragpath.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_COMPARE(window, qGuiApp->focusWindow());
+
+    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != 0);
 
     int current = pathview->currentIndex();
@@ -1544,16 +1544,16 @@ void tst_QQuickPathView::changePreferredHighlight()
     QTRY_COMPARE(firstItem->pos() + offset, start);
     QCOMPARE(pathview->currentIndex(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::creationContext()
 {
-    QQuickView canvas;
-    canvas.setGeometry(0,0,240,320);
-    canvas.setSource(testFileUrl("creationContext.qml"));
+    QQuickView window;
+    window.setGeometry(0,0,240,320);
+    window.setSource(testFileUrl("creationContext.qml"));
 
-    QQuickItem *rootItem = qobject_cast<QQuickItem *>(canvas.rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem *>(window.rootObject());
     QVERIFY(rootItem);
     QVERIFY(rootItem->property("count").toInt() > 0);
 
@@ -1565,18 +1565,18 @@ void tst_QQuickPathView::creationContext()
 // QTBUG-21320
 void tst_QQuickPathView::currentOffsetOnInsertion()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
 
     QaimModel model;
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testModel", &model);
 
-    canvas->setSource(testFileUrl("pathline.qml"));
+    window->setSource(testFileUrl("pathline.qml"));
     qApp->processEvents();
 
-    QQuickPathView *pathview = findItem<QQuickPathView>(canvas->rootObject(), "view");
+    QQuickPathView *pathview = findItem<QQuickPathView>(window->rootObject(), "view");
     QVERIFY(pathview != 0);
 
     pathview->setPreferredHighlightBegin(0.5);
@@ -1638,19 +1638,19 @@ void tst_QQuickPathView::currentOffsetOnInsertion()
     // verify that current item (item 1) is still at offset 0.5
     QCOMPARE(item->pos() + offset, start);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::asynchronous()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
     QQmlIncubationController controller;
-    canvas->engine()->setIncubationController(&controller);
+    window->engine()->setIncubationController(&controller);
 
-    canvas->setSource(testFileUrl("asyncloader.qml"));
+    window->setSource(testFileUrl("asyncloader.qml"));
 
-    QQuickItem *rootObject = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootObject = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootObject);
 
     QQuickPathView *pathview = 0;
@@ -1694,7 +1694,7 @@ void tst_QQuickPathView::asynchronous()
         QCOMPARE(curItem->pos() + offset, itemPos);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::missingPercent()
@@ -1709,14 +1709,14 @@ void tst_QQuickPathView::missingPercent()
 
 void tst_QQuickPathView::cancelDrag()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("dragpath.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_COMPARE(canvas, qGuiApp->focusWindow());
-
-    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(canvas->rootObject());
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("dragpath.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_COMPARE(window, qGuiApp->focusWindow());
+
+    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != 0);
 
     QSignalSpy draggingSpy(pathview, SIGNAL(draggingChanged()));
@@ -1724,10 +1724,10 @@ void tst_QQuickPathView::cancelDrag()
     QSignalSpy dragEndedSpy(pathview, SIGNAL(dragEnded()));
 
     // drag between snap points
-    QTest::mousePress(canvas, Qt::LeftButton, 0, QPoint(10,100));
+    QTest::mousePress(window, Qt::LeftButton, 0, QPoint(10,100));
     QTest::qWait(100);
-    QTest::mouseMove(canvas, QPoint(30, 100));
-    QTest::mouseMove(canvas, QPoint(85, 100));
+    QTest::mouseMove(window, QPoint(30, 100));
+    QTest::mouseMove(window, QPoint(85, 100));
 
     QTRY_VERIFY(pathview->offset() != qFloor(pathview->offset()));
     QTRY_VERIFY(pathview->isMoving());
@@ -1737,7 +1737,7 @@ void tst_QQuickPathView::cancelDrag()
     QCOMPARE(dragEndedSpy.count(), 0);
 
     // steal mouse grab - cancels PathView dragging
-    QQuickItem *item = canvas->rootObject()->findChild<QQuickItem*>("text");
+    QQuickItem *item = window->rootObject()->findChild<QQuickItem*>("text");
     item->grabMouse();
 
     // returns to a snap point.
@@ -1748,25 +1748,25 @@ void tst_QQuickPathView::cancelDrag()
     QCOMPARE(dragStartedSpy.count(), 1);
     QCOMPARE(dragEndedSpy.count(), 1);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, QPoint(40,100));
+    QTest::mouseRelease(window, Qt::LeftButton, 0, QPoint(40,100));
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::maximumFlickVelocity()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("dragpath.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_COMPARE(canvas, qGuiApp->focusWindow());
-
-    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(canvas->rootObject());
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("dragpath.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_COMPARE(window, qGuiApp->focusWindow());
+
+    QQuickPathView *pathview = qobject_cast<QQuickPathView*>(window->rootObject());
     QVERIFY(pathview != 0);
 
     pathview->setMaximumFlickVelocity(700);
-    flick(canvas, QPoint(200,10), QPoint(10,10), 180);
+    flick(window, QPoint(200,10), QPoint(10,10), 180);
     QVERIFY(pathview->isMoving());
     QVERIFY(pathview->isFlicking());
     QTRY_VERIFY(!pathview->isMoving());
@@ -1775,7 +1775,7 @@ void tst_QQuickPathView::maximumFlickVelocity()
 
     pathview->setOffset(0.);
     pathview->setMaximumFlickVelocity(300);
-    flick(canvas, QPoint(200,10), QPoint(10,10), 180);
+    flick(window, QPoint(200,10), QPoint(10,10), 180);
     QVERIFY(pathview->isMoving());
     QVERIFY(pathview->isFlicking());
     QTRY_VERIFY(!pathview->isMoving());
@@ -1784,7 +1784,7 @@ void tst_QQuickPathView::maximumFlickVelocity()
 
     pathview->setOffset(0.);
     pathview->setMaximumFlickVelocity(500);
-    flick(canvas, QPoint(200,10), QPoint(10,10), 180);
+    flick(window, QPoint(200,10), QPoint(10,10), 180);
     QVERIFY(pathview->isMoving());
     QVERIFY(pathview->isFlicking());
     QTRY_VERIFY(!pathview->isMoving());
@@ -1795,26 +1795,26 @@ void tst_QQuickPathView::maximumFlickVelocity()
     QVERIFY(dist3 > dist2);
     QVERIFY(dist2 < dist1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPathView::snapToItem()
 {
     QFETCH(bool, enforceRange);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("panels.qml"));
-    QQuickPathView *pathview = canvas->rootObject()->findChild<QQuickPathView*>("view");
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("panels.qml"));
+    QQuickPathView *pathview = window->rootObject()->findChild<QQuickPathView*>("view");
     QVERIFY(pathview != 0);
 
-    canvas->rootObject()->setProperty("enforceRange", enforceRange);
+    window->rootObject()->setProperty("enforceRange", enforceRange);
     QTRY_VERIFY(!pathview->isMoving()); // ensure stable
 
     int currentIndex = pathview->currentIndex();
 
     QSignalSpy snapModeSpy(pathview, SIGNAL(snapModeChanged()));
 
-    flick(canvas, QPoint(200,10), QPoint(10,10), 180);
+    flick(window, QPoint(200,10), QPoint(10,10), 180);
 
     QVERIFY(pathview->isMoving());
     QTRY_VERIFY(!pathview->isMoving());
@@ -1839,28 +1839,28 @@ void tst_QQuickPathView::snapOneItem()
 {
     QFETCH(bool, enforceRange);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("panels.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QTRY_COMPARE(canvas, qGuiApp->focusWindow());
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("panels.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QTRY_COMPARE(window, qGuiApp->focusWindow());
 
-    QQuickPathView *pathview = canvas->rootObject()->findChild<QQuickPathView*>("view");
+    QQuickPathView *pathview = window->rootObject()->findChild<QQuickPathView*>("view");
     QVERIFY(pathview != 0);
 
-    canvas->rootObject()->setProperty("enforceRange", enforceRange);
+    window->rootObject()->setProperty("enforceRange", enforceRange);
 
     QSignalSpy snapModeSpy(pathview, SIGNAL(snapModeChanged()));
 
-    canvas->rootObject()->setProperty("snapOne", true);
+    window->rootObject()->setProperty("snapOne", true);
     QVERIFY(snapModeSpy.count() == 1);
     QTRY_VERIFY(!pathview->isMoving()); // ensure stable
 
     int currentIndex = pathview->currentIndex();
 
     double startOffset = pathview->offset();
-    flick(canvas, QPoint(200,10), QPoint(10,10), 180);
+    flick(window, QPoint(200,10), QPoint(10,10), 180);
 
     QVERIFY(pathview->isMoving());
     QTRY_VERIFY(!pathview->isMoving());
diff --git a/tests/auto/quick/qquickpincharea/tst_qquickpincharea.cpp b/tests/auto/quick/qquickpincharea/tst_qquickpincharea.cpp
index 3f4937a..5c765b2 100644
--- a/tests/auto/quick/qquickpincharea/tst_qquickpincharea.cpp
+++ b/tests/auto/quick/qquickpincharea/tst_qquickpincharea.cpp
@@ -83,22 +83,22 @@ void tst_QQuickPinchArea::cleanupTestCase()
 }
 void tst_QQuickPinchArea::pinchProperties()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("pinchproperties.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("pinchproperties.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QQuickPinch *pinch = pinchArea->pinch();
     QVERIFY(pinchArea != 0);
     QVERIFY(pinch != 0);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
     QVERIFY(blackRect == pinch->target());
-    QQuickItem *rootItem = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootItem = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootItem != 0);
     QSignalSpy targetSpy(pinch, SIGNAL(targetChanged()));
     pinch->setTarget(rootItem);
@@ -195,7 +195,7 @@ void tst_QQuickPinchArea::pinchProperties()
     QCOMPARE(rotMinSpy.count(),1);
     QCOMPARE(rotMaxSpy.count(),1);
 
-    delete canvas;
+    delete window;
 }
 
 QTouchEvent::TouchPoint makeTouchPoint(int id, QPoint p, QQuickView *v, QQuickItem *i)
@@ -209,47 +209,47 @@ QTouchEvent::TouchPoint makeTouchPoint(int id, QPoint p, QQuickView *v, QQuickIt
 
 void tst_QQuickPinchArea::scale()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("pinchproperties.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("pinchproperties.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->rootObject() != 0);
     qApp->processEvents();
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QQuickPinch *pinch = pinchArea->pinch();
     QVERIFY(pinchArea != 0);
     QVERIFY(pinch != 0);
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root != 0);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
 
     QPoint p1(80, 80);
     QPoint p2(100, 100);
     {
-        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
-        pinchSequence.press(0, p1, canvas).commit();
+        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(window, device);
+        pinchSequence.press(0, p1, window).commit();
         // In order for the stationary point to remember its previous position,
         // we have to reuse the same pinchSequence object.  Otherwise if we let it
         // be destroyed and then start a new sequence, point 0 will default to being
         // stationary at 0, 0, and PinchArea will filter out that touchpoint because
         // it is outside its bounds.
-        pinchSequence.stationary(0).press(1, p2, canvas).commit();
+        pinchSequence.stationary(0).press(1, p2, window).commit();
         p1 -= QPoint(10,10);
         p2 += QPoint(10,10);
-        pinchSequence.move(0, p1,canvas).move(1, p2,canvas).commit();
+        pinchSequence.move(0, p1,window).move(1, p2,window).commit();
 
         QCOMPARE(root->property("scale").toReal(), 1.0);
         QVERIFY(root->property("pinchActive").toBool());
 
         p1 -= QPoint(10,10);
         p2 += QPoint(10,10);
-        pinchSequence.move(0, p1,canvas).move(1, p2,canvas).commit();
+        pinchSequence.move(0, p1,window).move(1, p2,window).commit();
 
         QCOMPARE(root->property("scale").toReal(), 1.5);
         QCOMPARE(root->property("center").toPointF(), QPointF(40, 40)); // blackrect is at 50,50
@@ -260,56 +260,56 @@ void tst_QQuickPinchArea::scale()
     p1 -= QPoint(50,50);
     p2 += QPoint(50,50);
     {
-        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
-        pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(window, device);
+        pinchSequence.move(0, p1, window).move(1, p2, window).commit();
         QCOMPARE(blackRect->scale(), 2.0);
-        pinchSequence.release(0, p1, canvas).release(1, p2, canvas).commit();
+        pinchSequence.release(0, p1, window).release(1, p2, window).commit();
     }
     QVERIFY(!root->property("pinchActive").toBool());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPinchArea::pan()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("pinchproperties.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("pinchproperties.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->rootObject() != 0);
     qApp->processEvents();
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QQuickPinch *pinch = pinchArea->pinch();
     QVERIFY(pinchArea != 0);
     QVERIFY(pinch != 0);
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root != 0);
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
 
     QPoint p1(80, 80);
     QPoint p2(100, 100);
     {
-        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
-        pinchSequence.press(0, p1, canvas).commit();
+        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(window, device);
+        pinchSequence.press(0, p1, window).commit();
         // In order for the stationary point to remember its previous position,
         // we have to reuse the same pinchSequence object.
-        pinchSequence.stationary(0).press(1, p2, canvas).commit();
+        pinchSequence.stationary(0).press(1, p2, window).commit();
         p1 += QPoint(10,10);
         p2 += QPoint(10,10);
-        pinchSequence.move(0, p1,canvas).move(1, p2,canvas).commit();
+        pinchSequence.move(0, p1,window).move(1, p2,window).commit();
 
         QCOMPARE(root->property("scale").toReal(), 1.0);
         QVERIFY(root->property("pinchActive").toBool());
 
         p1 += QPoint(10,10);
         p2 += QPoint(10,10);
-        pinchSequence.move(0, p1,canvas).move(1, p2,canvas).commit();
+        pinchSequence.move(0, p1,window).move(1, p2,window).commit();
     }
 
     QCOMPARE(root->property("center").toPointF(), QPointF(60, 60)); // blackrect is at 50,50
@@ -319,61 +319,61 @@ void tst_QQuickPinchArea::pan()
     // pan x beyond bound
     p1 += QPoint(100,100);
     p2 += QPoint(100,100);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas).move(1, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window).move(1, p2, window);
 
     QCOMPARE(blackRect->x(), 140.0);
     QCOMPARE(blackRect->y(), 160.0);
 
-    QTest::touchEvent(canvas, device).release(0, p1, canvas).release(1, p2, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window).release(1, p2, window);
     QVERIFY(!root->property("pinchActive").toBool());
 
-    delete canvas;
+    delete window;
 }
 
 // test pinch, release one point, touch again to continue pinch
 void tst_QQuickPinchArea::retouch()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("pinchproperties.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("pinchproperties.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->rootObject() != 0);
     qApp->processEvents();
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QQuickPinch *pinch = pinchArea->pinch();
     QVERIFY(pinchArea != 0);
     QVERIFY(pinch != 0);
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root != 0);
 
     QSignalSpy startedSpy(pinchArea, SIGNAL(pinchStarted(QQuickPinchEvent *)));
     QSignalSpy finishedSpy(pinchArea, SIGNAL(pinchFinished(QQuickPinchEvent *)));
 
     // target
-    QQuickItem *blackRect = canvas->rootObject()->findChild<QQuickItem*>("blackrect");
+    QQuickItem *blackRect = window->rootObject()->findChild<QQuickItem*>("blackrect");
     QVERIFY(blackRect != 0);
 
     QPoint p1(80, 80);
     QPoint p2(100, 100);
     {
-        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
-        pinchSequence.press(0, p1, canvas).commit();
+        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(window, device);
+        pinchSequence.press(0, p1, window).commit();
         // In order for the stationary point to remember its previous position,
         // we have to reuse the same pinchSequence object.
-        pinchSequence.stationary(0).press(1, p2, canvas).commit();
+        pinchSequence.stationary(0).press(1, p2, window).commit();
         p1 -= QPoint(10,10);
         p2 += QPoint(10,10);
-        pinchSequence.move(0, p1,canvas).move(1, p2,canvas).commit();
+        pinchSequence.move(0, p1,window).move(1, p2,window).commit();
 
         QCOMPARE(root->property("scale").toReal(), 1.0);
         QVERIFY(root->property("pinchActive").toBool());
 
         p1 -= QPoint(10,10);
         p2 += QPoint(10,10);
-        pinchSequence.move(0, p1,canvas).move(1, p2,canvas).commit();
+        pinchSequence.move(0, p1,window).move(1, p2,window).commit();
 
         QCOMPARE(startedSpy.count(), 1);
 
@@ -381,39 +381,39 @@ void tst_QQuickPinchArea::retouch()
         QCOMPARE(root->property("center").toPointF(), QPointF(40, 40)); // blackrect is at 50,50
         QCOMPARE(blackRect->scale(), 1.5);
 
-        QCOMPARE(canvas->rootObject()->property("pointCount").toInt(), 2);
+        QCOMPARE(window->rootObject()->property("pointCount").toInt(), 2);
 
         QCOMPARE(startedSpy.count(), 1);
         QCOMPARE(finishedSpy.count(), 0);
 
         // Hold down the first finger but release the second one
-        pinchSequence.stationary(0).release(1, p2, canvas).commit();
+        pinchSequence.stationary(0).release(1, p2, window).commit();
 
         QCOMPARE(startedSpy.count(), 1);
         QCOMPARE(finishedSpy.count(), 0);
 
-        QCOMPARE(canvas->rootObject()->property("pointCount").toInt(), 1);
+        QCOMPARE(window->rootObject()->property("pointCount").toInt(), 1);
 
         // Keep holding down the first finger and re-touch the second one, then move them both
-        pinchSequence.stationary(0).press(1, p2, canvas).commit();
+        pinchSequence.stationary(0).press(1, p2, window).commit();
         p1 -= QPoint(10,10);
         p2 += QPoint(10,10);
-        pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+        pinchSequence.move(0, p1, window).move(1, p2, window).commit();
 
         // Lifting and retouching results in onPinchStarted being called again
         QCOMPARE(startedSpy.count(), 2);
         QCOMPARE(finishedSpy.count(), 0);
 
-        QCOMPARE(canvas->rootObject()->property("pointCount").toInt(), 2);
+        QCOMPARE(window->rootObject()->property("pointCount").toInt(), 2);
 
-        pinchSequence.release(0, p1, canvas).release(1, p2, canvas).commit();
+        pinchSequence.release(0, p1, window).release(1, p2, window).commit();
 
         QVERIFY(!root->property("pinchActive").toBool());
         QCOMPARE(startedSpy.count(), 2);
         QCOMPARE(finishedSpy.count(), 1);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickPinchArea::transformedPinchArea_data()
@@ -447,43 +447,43 @@ void tst_QQuickPinchArea::transformedPinchArea()
     QFETCH(QPoint, p2);
     QFETCH(bool, shouldPinch);
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("transformedPinchArea.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *view = createView();
+    view->setSource(testFileUrl("transformedPinchArea.qml"));
+    view->show();
+    view->requestActivateWindow();
+    QTest::qWaitForWindowShown(view);
+    QVERIFY(view->rootObject() != 0);
     qApp->processEvents();
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pinchArea");
+    QQuickPinchArea *pinchArea = view->rootObject()->findChild<QQuickPinchArea*>("pinchArea");
     QVERIFY(pinchArea != 0);
 
     const int threshold = qApp->styleHints()->startDragDistance();
 
     {
-        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
+        QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(view, device);
         // start pinch
-        pinchSequence.press(0, p1, canvas).commit();
+        pinchSequence.press(0, p1, view).commit();
         // In order for the stationary point to remember its previous position,
         // we have to reuse the same pinchSequence object.
-        pinchSequence.stationary(0).press(1, p2, canvas).commit();
-        pinchSequence.stationary(0).move(1, p2 + QPoint(threshold * 2, 0), canvas).commit();
+        pinchSequence.stationary(0).press(1, p2, view).commit();
+        pinchSequence.stationary(0).move(1, p2 + QPoint(threshold * 2, 0), view).commit();
         QCOMPARE(pinchArea->property("pinching").toBool(), shouldPinch);
 
         // release pinch
-        pinchSequence.release(0, p1, canvas).release(1, p2, canvas).commit();
+        pinchSequence.release(0, p1, view).release(1, p2, view).commit();
         QCOMPARE(pinchArea->property("pinching").toBool(), false);
     }
 
-    delete canvas;
+    delete view;
 }
 
 QQuickView *tst_QQuickPinchArea::createView()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    return canvas;
+    return window;
 }
 
 QTEST_MAIN(tst_QQuickPinchArea)
diff --git a/tests/auto/quick/qquickpositioners/tst_qquickpositioners.cpp b/tests/auto/quick/qquickpositioners/tst_qquickpositioners.cpp
index 1b7adbe..2a87c24 100644
--- a/tests/auto/quick/qquickpositioners/tst_qquickpositioners.cpp
+++ b/tests/auto/quick/qquickpositioners/tst_qquickpositioners.cpp
@@ -289,17 +289,17 @@ tst_qquickpositioners::tst_qquickpositioners()
 
 void tst_qquickpositioners::test_horizontal()
 {
-    QQuickView *canvas = createView(testFile("horizontal.qml"));
+    QQuickView *window = createView(testFile("horizontal.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", false);
+    window->rootObject()->setProperty("testRightToLeft", false);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -309,26 +309,26 @@ void tst_qquickpositioners::test_horizontal()
     QCOMPARE(three->x(), 70.0);
     QCOMPARE(three->y(), 0.0);
 
-    QQuickItem *row = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *row = window->rootObject()->findChild<QQuickItem*>("row");
     QCOMPARE(row->width(), 110.0);
     QCOMPARE(row->height(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_horizontal_rtl()
 {
-    QQuickView *canvas = createView(testFile("horizontal.qml"));
+    QQuickView *window = createView(testFile("horizontal.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", true);
+    window->rootObject()->setProperty("testRightToLeft", true);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     QCOMPARE(one->x(), 60.0);
@@ -338,7 +338,7 @@ void tst_qquickpositioners::test_horizontal_rtl()
     QCOMPARE(three->x(), 0.0);
     QCOMPARE(three->y(), 0.0);
 
-    QQuickItem *row = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *row = window->rootObject()->findChild<QQuickItem*>("row");
     QCOMPARE(row->width(), 110.0);
     QCOMPARE(row->height(), 50.0);
 
@@ -351,22 +351,22 @@ void tst_qquickpositioners::test_horizontal_rtl()
     QCOMPARE(three->x(), 90.0);
     QCOMPARE(three->y(), 0.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_horizontal_spacing()
 {
-    QQuickView *canvas = createView(testFile("horizontal-spacing.qml"));
+    QQuickView *window = createView(testFile("horizontal-spacing.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", false);
+    window->rootObject()->setProperty("testRightToLeft", false);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -376,26 +376,26 @@ void tst_qquickpositioners::test_horizontal_spacing()
     QCOMPARE(three->x(), 90.0);
     QCOMPARE(three->y(), 0.0);
 
-    QQuickItem *row = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *row = window->rootObject()->findChild<QQuickItem*>("row");
     QCOMPARE(row->width(), 130.0);
     QCOMPARE(row->height(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_horizontal_spacing_rightToLeft()
 {
-    QQuickView *canvas = createView(testFile("horizontal-spacing.qml"));
+    QQuickView *window = createView(testFile("horizontal-spacing.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", true);
+    window->rootObject()->setProperty("testRightToLeft", true);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     QCOMPARE(one->x(), 80.0);
@@ -405,26 +405,26 @@ void tst_qquickpositioners::test_horizontal_spacing_rightToLeft()
     QCOMPARE(three->x(), 00.0);
     QCOMPARE(three->y(), 0.0);
 
-    QQuickItem *row = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *row = window->rootObject()->findChild<QQuickItem*>("row");
     QCOMPARE(row->width(), 130.0);
     QCOMPARE(row->height(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_horizontal_animated()
 {
-    QQuickView *canvas = createView(testFile("horizontal-animated.qml"), false);
+    QQuickView *window = createView(testFile("horizontal-animated.qml"), false);
 
-    canvas->rootObject()->setProperty("testRightToLeft", false);
+    window->rootObject()->setProperty("testRightToLeft", false);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     //Note that they animate in
@@ -432,9 +432,9 @@ void tst_qquickpositioners::test_horizontal_animated()
     QCOMPARE(two->x(), -100.0);
     QCOMPARE(three->x(), -100.0);
 
-    QTest::qWaitForWindowShown(canvas); //It may not relayout until the next frame, so it needs to be drawn
+    QTest::qWaitForWindowShown(window); //It may not relayout until the next frame, so it needs to be drawn
 
-    QQuickItem *row = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *row = window->rootObject()->findChild<QQuickItem*>("row");
     QVERIFY(row);
     QCOMPARE(row->width(), 100.0);
     QCOMPARE(row->height(), 50.0);
@@ -463,22 +463,22 @@ void tst_qquickpositioners::test_horizontal_animated()
     QTRY_COMPARE(two->x(), 50.0);
     QTRY_COMPARE(three->x(), 100.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_horizontal_animated_rightToLeft()
 {
-    QQuickView *canvas = createView(testFile("horizontal-animated.qml"), false);
+    QQuickView *window = createView(testFile("horizontal-animated.qml"), false);
 
-    canvas->rootObject()->setProperty("testRightToLeft", true);
+    window->rootObject()->setProperty("testRightToLeft", true);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     //Note that they animate in
@@ -486,9 +486,9 @@ void tst_qquickpositioners::test_horizontal_animated_rightToLeft()
     QCOMPARE(two->x(), -100.0);
     QCOMPARE(three->x(), -100.0);
 
-    QTest::qWaitForWindowShown(canvas); //It may not relayout until the next frame, so it needs to be drawn
+    QTest::qWaitForWindowShown(window); //It may not relayout until the next frame, so it needs to be drawn
 
-    QQuickItem *row = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *row = window->rootObject()->findChild<QQuickItem*>("row");
     QVERIFY(row);
     QCOMPARE(row->width(), 100.0);
     QCOMPARE(row->height(), 50.0);
@@ -519,23 +519,23 @@ void tst_qquickpositioners::test_horizontal_animated_rightToLeft()
     QTRY_COMPARE(one->x(), 100.0);
     QTRY_COMPARE(two->x(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_horizontal_animated_disabled()
 {
-    QQuickView *canvas = createView(testFile("horizontal-animated-disabled.qml"));
+    QQuickView *window = createView(testFile("horizontal-animated-disabled.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
-    QQuickItem *row = canvas->rootObject()->findChild<QQuickItem*>("row");
+    QQuickItem *row = window->rootObject()->findChild<QQuickItem*>("row");
     QVERIFY(row);
 
     qApp->processEvents();
@@ -557,7 +557,7 @@ void tst_qquickpositioners::test_horizontal_animated_disabled()
     QTRY_COMPARE(two->x(), 50.0);
     QTRY_COMPARE(three->x(), 100.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::populateTransitions(const QString &positionerObjectName)
@@ -577,8 +577,8 @@ void tst_qquickpositioners::populateTransitions(const QString &positionerObjectN
     QaimModel model_targetItems_transitionFrom;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = QQuickViewTestUtil::createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = QQuickViewTestUtil::createView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("usePopulateTransition", usePopulateTransition);
     ctxt->setContextProperty("enableAddTransition", true);
     ctxt->setContextProperty("dynamicallyPopulate", dynamicallyPopulate);
@@ -588,16 +588,16 @@ void tst_qquickpositioners::populateTransitions(const QString &positionerObjectN
     ctxt->setContextProperty("targetItems_transitionFrom", targetItems_transitionFrom);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
     ctxt->setContextProperty("testedPositioner", positionerObjectName);
-    canvas->setSource(testFileUrl("transitions.qml"));
+    window->setSource(testFileUrl("transitions.qml"));
 
-    QQuickItem *positioner = canvas->rootObject()->findChild<QQuickItem*>(positionerObjectName);
+    QQuickItem *positioner = window->rootObject()->findChild<QQuickItem*>(positionerObjectName);
     QVERIFY(positioner);
-    canvas->show();
+    window->show();
     qApp->processEvents();
 
     if (!dynamicallyPopulate && usePopulateTransition) {
-        QTRY_COMPARE(canvas->rootObject()->property("populateTransitionsDone").toInt(), model.count());
-        QTRY_COMPARE(canvas->rootObject()->property("addTransitionsDone").toInt(), 0);
+        QTRY_COMPARE(window->rootObject()->property("populateTransitionsDone").toInt(), model.count());
+        QTRY_COMPARE(window->rootObject()->property("addTransitionsDone").toInt(), 0);
 
         QList<QPair<QString, QString> > targetData;
         QList<int> targetIndexes;
@@ -607,29 +607,29 @@ void tst_qquickpositioners::populateTransitions(const QString &positionerObjectN
         }
         QList<QQuickItem *> targetItems = findItems<QQuickItem>(positioner, "wrapper", targetIndexes);
         model_targetItems_transitionFrom.matchAgainst(targetData, "wasn't animated from target 'from' pos", "shouldn't have been animated from target 'from' pos");
-        matchItemsAndIndexes(canvas->rootObject()->property("targetTrans_items").toMap(), model, targetIndexes);
-        matchIndexLists(canvas->rootObject()->property("targetTrans_targetIndexes").toList(), targetIndexes);
-        matchItemLists(canvas->rootObject()->property("targetTrans_targetItems").toList(), targetItems);
+        matchItemsAndIndexes(window->rootObject()->property("targetTrans_items").toMap(), model, targetIndexes);
+        matchIndexLists(window->rootObject()->property("targetTrans_targetIndexes").toList(), targetIndexes);
+        matchItemLists(window->rootObject()->property("targetTrans_targetItems").toList(), targetItems);
 
     } else if (dynamicallyPopulate) {
-        QTRY_COMPARE(canvas->rootObject()->property("populateTransitionsDone").toInt(), 0);
-        QTRY_COMPARE(canvas->rootObject()->property("addTransitionsDone").toInt(), model.count());
+        QTRY_COMPARE(window->rootObject()->property("populateTransitionsDone").toInt(), 0);
+        QTRY_COMPARE(window->rootObject()->property("addTransitionsDone").toInt(), model.count());
     } else {
         QTRY_COMPARE(QQuickItemPrivate::get(positioner)->polishScheduled, false);
-        QTRY_COMPARE(canvas->rootObject()->property("populateTransitionsDone").toInt(), 0);
-        QTRY_COMPARE(canvas->rootObject()->property("addTransitionsDone").toInt(), 0);
+        QTRY_COMPARE(window->rootObject()->property("populateTransitionsDone").toInt(), 0);
+        QTRY_COMPARE(window->rootObject()->property("addTransitionsDone").toInt(), 0);
     }
 
-    checkItemPositions(positioner, &model, canvas->rootObject()->property("incrementalSize").toInt());
+    checkItemPositions(positioner, &model, window->rootObject()->property("incrementalSize").toInt());
 
     // add an item and check this is done with add transition, not populate
-    canvas->rootObject()->setProperty("populateTransitionsDone", 0);
-    canvas->rootObject()->setProperty("addTransitionsDone", 0);
+    window->rootObject()->setProperty("populateTransitionsDone", 0);
+    window->rootObject()->setProperty("addTransitionsDone", 0);
     model.insertItem(0, "new item", "");
-    QTRY_COMPARE(canvas->rootObject()->property("addTransitionsDone").toInt(), 1);
-    QTRY_COMPARE(canvas->rootObject()->property("populateTransitionsDone").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("addTransitionsDone").toInt(), 1);
+    QTRY_COMPARE(window->rootObject()->property("populateTransitionsDone").toInt(), 0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::populateTransitions_data()
@@ -658,19 +658,19 @@ void tst_qquickpositioners::addTransitions(const QString &positionerObjectName)
     QaimModel model_targetItems_transitionFrom;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = QQuickViewTestUtil::createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = QQuickViewTestUtil::createView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("usePopulateTransition", QVariant(false));
     ctxt->setContextProperty("enableAddTransition", QVariant(true));
     ctxt->setContextProperty("model_targetItems_transitionFrom", &model_targetItems_transitionFrom);
     ctxt->setContextProperty("model_displacedItems_transitionVia", &model_displacedItems_transitionVia);
     ctxt->setContextProperty("targetItems_transitionFrom", targetItems_transitionFrom);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
-    canvas->setSource(testFileUrl("transitions.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("transitions.qml"));
+    window->show();
     qApp->processEvents();
 
-    QQuickItem *positioner = canvas->rootObject()->findChild<QQuickItem*>(positionerObjectName);
+    QQuickItem *positioner = window->rootObject()->findChild<QQuickItem*>(positionerObjectName);
     QVERIFY(positioner);
     positioner->findChild<QQuickItem*>("repeater")->setProperty("model", QVariant::fromValue(&model));
     QTRY_COMPARE(QQuickItemPrivate::get(positioner)->polishScheduled, false);
@@ -688,19 +688,19 @@ void tst_qquickpositioners::addTransitions(const QString &positionerObjectName)
     QList<QQuickItem *> targetItems = findItems<QQuickItem>(positioner, "wrapper", targetIndexes);
 
     // check add transition was run for first lot of added items
-    QTRY_COMPARE(canvas->rootObject()->property("populateTransitionsDone").toInt(), 0);
-    QTRY_COMPARE(canvas->rootObject()->property("addTransitionsDone").toInt(), initialItemCount);
-    QTRY_COMPARE(canvas->rootObject()->property("displaceTransitionsDone").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("populateTransitionsDone").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("addTransitionsDone").toInt(), initialItemCount);
+    QTRY_COMPARE(window->rootObject()->property("displaceTransitionsDone").toInt(), 0);
     model_targetItems_transitionFrom.matchAgainst(targetData, "wasn't animated from target 'from' pos", "shouldn't have been animated from target 'from' pos");
-    matchItemsAndIndexes(canvas->rootObject()->property("targetTrans_items").toMap(), model, targetIndexes);
-    matchIndexLists(canvas->rootObject()->property("targetTrans_targetIndexes").toList(), targetIndexes);
-    matchItemLists(canvas->rootObject()->property("targetTrans_targetItems").toList(), targetItems);
+    matchItemsAndIndexes(window->rootObject()->property("targetTrans_items").toMap(), model, targetIndexes);
+    matchIndexLists(window->rootObject()->property("targetTrans_targetIndexes").toList(), targetIndexes);
+    matchItemLists(window->rootObject()->property("targetTrans_targetItems").toList(), targetItems);
 
     model_targetItems_transitionFrom.clear();
-    canvas->rootObject()->setProperty("addTransitionsDone", 0);
-    canvas->rootObject()->setProperty("targetTrans_items", QVariantMap());
-    canvas->rootObject()->setProperty("targetTrans_targetIndexes", QVariantList());
-    canvas->rootObject()->setProperty("targetTrans_targetItems", QVariantList());
+    window->rootObject()->setProperty("addTransitionsDone", 0);
+    window->rootObject()->setProperty("targetTrans_items", QVariantMap());
+    window->rootObject()->setProperty("targetTrans_targetIndexes", QVariantList());
+    window->rootObject()->setProperty("targetTrans_targetItems", QVariantList());
 
     // do insertion
     targetData.clear();
@@ -714,28 +714,28 @@ void tst_qquickpositioners::addTransitions(const QString &positionerObjectName)
 
     targetItems = findItems<QQuickItem>(positioner, "wrapper", targetIndexes);
 
-    QTRY_COMPARE(canvas->rootObject()->property("addTransitionsDone").toInt(), targetData.count());
-    QTRY_COMPARE(canvas->rootObject()->property("displaceTransitionsDone").toInt(), expectedDisplacedIndexes.count());
+    QTRY_COMPARE(window->rootObject()->property("addTransitionsDone").toInt(), targetData.count());
+    QTRY_COMPARE(window->rootObject()->property("displaceTransitionsDone").toInt(), expectedDisplacedIndexes.count());
 
     // check the target and displaced items were animated
     model_targetItems_transitionFrom.matchAgainst(targetData, "wasn't animated from target 'from' pos", "shouldn't have been animated from target 'from' pos");
     model_displacedItems_transitionVia.matchAgainst(expectedDisplacedValues, "wasn't animated with displaced anim", "shouldn't have been animated with displaced anim");
 
     // check attached properties
-    matchItemsAndIndexes(canvas->rootObject()->property("targetTrans_items").toMap(), model, targetIndexes);
-    matchIndexLists(canvas->rootObject()->property("targetTrans_targetIndexes").toList(), targetIndexes);
-    matchItemLists(canvas->rootObject()->property("targetTrans_targetItems").toList(), targetItems);
+    matchItemsAndIndexes(window->rootObject()->property("targetTrans_items").toMap(), model, targetIndexes);
+    matchIndexLists(window->rootObject()->property("targetTrans_targetIndexes").toList(), targetIndexes);
+    matchItemLists(window->rootObject()->property("targetTrans_targetItems").toList(), targetItems);
     if (expectedDisplacedIndexes.isValid()) {
         // adjust expectedDisplacedIndexes to their final values after the move
         QList<int> displacedIndexes = adjustIndexesForAddDisplaced(expectedDisplacedIndexes.indexes, insertionIndex, insertionCount);
-        matchItemsAndIndexes(canvas->rootObject()->property("displacedTrans_items").toMap(), model, displacedIndexes);
-        matchIndexLists(canvas->rootObject()->property("displacedTrans_targetIndexes").toList(), targetIndexes);
-        matchItemLists(canvas->rootObject()->property("displacedTrans_targetItems").toList(), targetItems);
+        matchItemsAndIndexes(window->rootObject()->property("displacedTrans_items").toMap(), model, displacedIndexes);
+        matchIndexLists(window->rootObject()->property("displacedTrans_targetIndexes").toList(), targetIndexes);
+        matchItemLists(window->rootObject()->property("displacedTrans_targetItems").toList(), targetItems);
     }
 
-    checkItemPositions(positioner, &model, canvas->rootObject()->property("incrementalSize").toInt());
+    checkItemPositions(positioner, &model, window->rootObject()->property("incrementalSize").toInt());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::addTransitions_data()
@@ -771,21 +771,21 @@ void tst_qquickpositioners::moveTransitions(const QString &positionerObjectName)
     QaimModel model_targetItems_transitionFrom;
     QaimModel model_displacedItems_transitionVia;
 
-    QQuickView *canvas = QQuickViewTestUtil::createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = QQuickViewTestUtil::createView();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("usePopulateTransition", QVariant(false));
     ctxt->setContextProperty("enableAddTransition", QVariant(false));
     ctxt->setContextProperty("model_targetItems_transitionFrom", &model_targetItems_transitionFrom);
     ctxt->setContextProperty("model_displacedItems_transitionVia", &model_displacedItems_transitionVia);
     ctxt->setContextProperty("targetItems_transitionFrom", targetItems_transitionFrom);
     ctxt->setContextProperty("displacedItems_transitionVia", displacedItems_transitionVia);
-    canvas->setSource(testFileUrl("transitions.qml"));
-    canvas->show();
+    window->setSource(testFileUrl("transitions.qml"));
+    window->show();
     qApp->processEvents();
 
     QList<QPair<QString,QString> > expectedDisplacedValues = expectedDisplacedIndexes.getModelDataValues(model);
 
-    QQuickItem *positioner = canvas->rootObject()->findChild<QQuickItem*>(positionerObjectName);
+    QQuickItem *positioner = window->rootObject()->findChild<QQuickItem*>(positionerObjectName);
     QVERIFY(positioner);
     positioner->findChild<QQuickItem*>("repeater")->setProperty("model", QVariant::fromValue(&model));
     QTRY_COMPARE(QQuickItemPrivate::get(positioner)->polishScheduled, false);
@@ -808,17 +808,17 @@ void tst_qquickpositioners::moveTransitions(const QString &positionerObjectName)
             break;
     }
 
-    QTRY_COMPARE(canvas->rootObject()->property("displaceTransitionsDone").toInt(), expectedDisplacedIndexes.count());
-    QCOMPARE(canvas->rootObject()->property("addTransitionsDone").toInt(), 0);
+    QTRY_COMPARE(window->rootObject()->property("displaceTransitionsDone").toInt(), expectedDisplacedIndexes.count());
+    QCOMPARE(window->rootObject()->property("addTransitionsDone").toInt(), 0);
 
     // check the target and displaced items were animated
     QCOMPARE(model_targetItems_transitionFrom.count(), 0);
     model_displacedItems_transitionVia.matchAgainst(expectedDisplacedValues, "wasn't animated with displaced anim", "shouldn't have been animated with displaced anim");
 
     // check attached properties
-    QCOMPARE(canvas->rootObject()->property("targetTrans_items").toMap().count(), 0);
-    QCOMPARE(canvas->rootObject()->property("targetTrans_targetIndexes").toList().count(), 0);
-    QCOMPARE(canvas->rootObject()->property("targetTrans_targetItems").toList().count(), 0);
+    QCOMPARE(window->rootObject()->property("targetTrans_items").toMap().count(), 0);
+    QCOMPARE(window->rootObject()->property("targetTrans_targetIndexes").toList().count(), 0);
+    QCOMPARE(window->rootObject()->property("targetTrans_targetItems").toList().count(), 0);
     if (expectedDisplacedIndexes.isValid()) {
         // adjust expectedDisplacedIndexes to their final values after the move
         QList<int> displacedIndexes;
@@ -830,21 +830,21 @@ void tst_qquickpositioners::moveTransitions(const QString &positionerObjectName)
             displacedIndexes = adjustIndexesForRemoveDisplaced(expectedDisplacedIndexes.indexes, change.index, change.count);
         else
             QVERIFY(false);
-        matchItemsAndIndexes(canvas->rootObject()->property("displacedTrans_items").toMap(), model, displacedIndexes);
+        matchItemsAndIndexes(window->rootObject()->property("displacedTrans_items").toMap(), model, displacedIndexes);
 
         QVariantList listOfEmptyIntLists;
         for (int i=0; i<displacedIndexes.count(); i++)
             listOfEmptyIntLists << QVariant::fromValue(QList<int>());
-        QCOMPARE(canvas->rootObject()->property("displacedTrans_targetIndexes").toList(), listOfEmptyIntLists);
+        QCOMPARE(window->rootObject()->property("displacedTrans_targetIndexes").toList(), listOfEmptyIntLists);
         QVariantList listOfEmptyObjectLists;
         for (int i=0; i<displacedIndexes.count(); i++)
             listOfEmptyObjectLists.insert(listOfEmptyObjectLists.count(), QVariantList());
-        QCOMPARE(canvas->rootObject()->property("displacedTrans_targetItems").toList(), listOfEmptyObjectLists);
+        QCOMPARE(window->rootObject()->property("displacedTrans_targetItems").toList(), listOfEmptyObjectLists);
     }
 
-    checkItemPositions(positioner, &model, canvas->rootObject()->property("incrementalSize").toInt());
+    checkItemPositions(positioner, &model, window->rootObject()->property("incrementalSize").toInt());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::moveTransitions_data()
@@ -930,15 +930,15 @@ void tst_qquickpositioners::checkItemPositions(QQuickItem *positioner, QaimModel
 
 void tst_qquickpositioners::test_vertical()
 {
-    QQuickView *canvas = createView(testFile("vertical.qml"));
+    QQuickView *window = createView(testFile("vertical.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -948,25 +948,25 @@ void tst_qquickpositioners::test_vertical()
     QCOMPARE(three->x(), 0.0);
     QCOMPARE(three->y(), 60.0);
 
-    QQuickItem *column = canvas->rootObject()->findChild<QQuickItem*>("column");
+    QQuickItem *column = window->rootObject()->findChild<QQuickItem*>("column");
     QVERIFY(column);
     QCOMPARE(column->height(), 80.0);
     QCOMPARE(column->width(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_vertical_spacing()
 {
-    QQuickView *canvas = createView(testFile("vertical-spacing.qml"));
+    QQuickView *window = createView(testFile("vertical-spacing.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -976,33 +976,33 @@ void tst_qquickpositioners::test_vertical_spacing()
     QCOMPARE(three->x(), 0.0);
     QCOMPARE(three->y(), 80.0);
 
-    QQuickItem *column = canvas->rootObject()->findChild<QQuickItem*>("column");
+    QQuickItem *column = window->rootObject()->findChild<QQuickItem*>("column");
     QCOMPARE(column->height(), 100.0);
     QCOMPARE(column->width(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_vertical_animated()
 {
-    QQuickView *canvas = createView(testFile("vertical-animated.qml"), false);
+    QQuickView *window = createView(testFile("vertical-animated.qml"), false);
 
     //Note that they animate in
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
     QCOMPARE(one->y(), -100.0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
     QCOMPARE(two->y(), -100.0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
     QCOMPARE(three->y(), -100.0);
 
-    QTest::qWaitForWindowShown(canvas); //It may not relayout until the next frame, so it needs to be drawn
+    QTest::qWaitForWindowShown(window); //It may not relayout until the next frame, so it needs to be drawn
 
-    QQuickItem *column = canvas->rootObject()->findChild<QQuickItem*>("column");
+    QQuickItem *column = window->rootObject()->findChild<QQuickItem*>("column");
     QVERIFY(column);
     QCOMPARE(column->height(), 100.0);
     QCOMPARE(column->width(), 50.0);
@@ -1030,22 +1030,22 @@ void tst_qquickpositioners::test_vertical_animated()
     QTRY_COMPARE(two->y(), 50.0);
     QTRY_COMPARE(three->y(), 100.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid()
 {
-    QQuickView *canvas = createView(testFile("gridtest.qml"));
+    QQuickView *window = createView(testFile("gridtest.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1059,27 +1059,27 @@ void tst_qquickpositioners::test_grid()
     QCOMPARE(five->x(), 50.0);
     QCOMPARE(five->y(), 50.0);
 
-    QQuickGrid *grid = canvas->rootObject()->findChild<QQuickGrid*>("grid");
+    QQuickGrid *grid = window->rootObject()->findChild<QQuickGrid*>("grid");
     QCOMPARE(grid->flow(), QQuickGrid::LeftToRight);
     QCOMPARE(grid->width(), 100.0);
     QCOMPARE(grid->height(), 100.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid_topToBottom()
 {
-    QQuickView *canvas = createView(testFile("grid-toptobottom.qml"));
+    QQuickView *window = createView(testFile("grid-toptobottom.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1093,29 +1093,29 @@ void tst_qquickpositioners::test_grid_topToBottom()
     QCOMPARE(five->x(), 50.0);
     QCOMPARE(five->y(), 50.0);
 
-    QQuickGrid *grid = canvas->rootObject()->findChild<QQuickGrid*>("grid");
+    QQuickGrid *grid = window->rootObject()->findChild<QQuickGrid*>("grid");
     QCOMPARE(grid->flow(), QQuickGrid::TopToBottom);
     QCOMPARE(grid->width(), 100.0);
     QCOMPARE(grid->height(), 120.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid_rightToLeft()
 {
-    QQuickView *canvas = createView(testFile("gridtest.qml"));
+    QQuickView *window = createView(testFile("gridtest.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", true);
+    window->rootObject()->setProperty("testRightToLeft", true);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 50.0);
@@ -1129,7 +1129,7 @@ void tst_qquickpositioners::test_grid_rightToLeft()
     QCOMPARE(five->x(), 40.0);
     QCOMPARE(five->y(), 50.0);
 
-    QQuickGrid *grid = canvas->rootObject()->findChild<QQuickGrid*>("grid");
+    QQuickGrid *grid = window->rootObject()->findChild<QQuickGrid*>("grid");
     QCOMPARE(grid->layoutDirection(), Qt::RightToLeft);
     QCOMPARE(grid->width(), 100.0);
     QCOMPARE(grid->height(), 100.0);
@@ -1147,22 +1147,22 @@ void tst_qquickpositioners::test_grid_rightToLeft()
     QCOMPARE(five->x(), 140.0);
     QCOMPARE(five->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid_spacing()
 {
-    QQuickView *canvas = createView(testFile("grid-spacing.qml"));
+    QQuickView *window = createView(testFile("grid-spacing.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1176,26 +1176,26 @@ void tst_qquickpositioners::test_grid_spacing()
     QCOMPARE(five->x(), 54.0);
     QCOMPARE(five->y(), 54.0);
 
-    QQuickItem *grid = canvas->rootObject()->findChild<QQuickItem*>("grid");
+    QQuickItem *grid = window->rootObject()->findChild<QQuickItem*>("grid");
     QCOMPARE(grid->width(), 128.0);
     QCOMPARE(grid->height(), 104.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid_row_column_spacing()
 {
-    QQuickView *canvas = createView(testFile("grid-row-column-spacing.qml"));
+    QQuickView *window = createView(testFile("grid-row-column-spacing.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1209,48 +1209,48 @@ void tst_qquickpositioners::test_grid_row_column_spacing()
     QCOMPARE(five->x(), 61.0);
     QCOMPARE(five->y(), 57.0);
 
-    QQuickItem *grid = canvas->rootObject()->findChild<QQuickItem*>("grid");
+    QQuickItem *grid = window->rootObject()->findChild<QQuickItem*>("grid");
     QCOMPARE(grid->width(), 142.0);
     QCOMPARE(grid->height(), 107.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid_animated()
 {
-    QQuickView *canvas = createView(testFile("grid-animated.qml"), false);
+    QQuickView *window = createView(testFile("grid-animated.qml"), false);
 
-    canvas->rootObject()->setProperty("testRightToLeft", false);
+    window->rootObject()->setProperty("testRightToLeft", false);
 
     //Note that all animate in
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
     QCOMPARE(one->x(), -100.0);
     QCOMPARE(one->y(), -100.0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
     QCOMPARE(two->x(), -100.0);
     QCOMPARE(two->y(), -100.0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
     QCOMPARE(three->x(), -100.0);
     QCOMPARE(three->y(), -100.0);
 
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
     QCOMPARE(four->x(), -100.0);
     QCOMPARE(four->y(), -100.0);
 
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
     QCOMPARE(five->x(), -100.0);
     QCOMPARE(five->y(), -100.0);
 
-    QTest::qWaitForWindowShown(canvas); //It may not relayout until the next frame, so it needs to be drawn
+    QTest::qWaitForWindowShown(window); //It may not relayout until the next frame, so it needs to be drawn
 
-    QQuickItem *grid = canvas->rootObject()->findChild<QQuickItem*>("grid");
+    QQuickItem *grid = window->rootObject()->findChild<QQuickItem*>("grid");
     QVERIFY(grid);
     QCOMPARE(grid->width(), 150.0);
     QCOMPARE(grid->height(), 100.0);
@@ -1298,44 +1298,44 @@ void tst_qquickpositioners::test_grid_animated()
     QTRY_COMPARE(five->x(), 50.0);
     QTRY_COMPARE(five->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid_animated_rightToLeft()
 {
-    QQuickView *canvas = createView(testFile("grid-animated.qml"), false);
+    QQuickView *window = createView(testFile("grid-animated.qml"), false);
 
-    canvas->rootObject()->setProperty("testRightToLeft", true);
+    window->rootObject()->setProperty("testRightToLeft", true);
 
     //Note that all animate in
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
     QCOMPARE(one->x(), -100.0);
     QCOMPARE(one->y(), -100.0);
 
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
     QCOMPARE(two->x(), -100.0);
     QCOMPARE(two->y(), -100.0);
 
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
     QCOMPARE(three->x(), -100.0);
     QCOMPARE(three->y(), -100.0);
 
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
     QCOMPARE(four->x(), -100.0);
     QCOMPARE(four->y(), -100.0);
 
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
     QCOMPARE(five->x(), -100.0);
     QCOMPARE(five->y(), -100.0);
 
-    QTest::qWaitForWindowShown(canvas); //It may not relayout until the next frame, so it needs to be drawn
+    QTest::qWaitForWindowShown(window); //It may not relayout until the next frame, so it needs to be drawn
 
-    QQuickItem *grid = canvas->rootObject()->findChild<QQuickItem*>("grid");
+    QQuickItem *grid = window->rootObject()->findChild<QQuickItem*>("grid");
     QVERIFY(grid);
     QCOMPARE(grid->width(), 150.0);
     QCOMPARE(grid->height(), 100.0);
@@ -1383,22 +1383,22 @@ void tst_qquickpositioners::test_grid_animated_rightToLeft()
     QTRY_COMPARE(five->x(), 50.0);
     QTRY_COMPARE(five->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_grid_zero_columns()
 {
-    QQuickView *canvas = createView(testFile("gridzerocolumns.qml"));
+    QQuickView *window = createView(testFile("gridzerocolumns.qml"));
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1412,21 +1412,21 @@ void tst_qquickpositioners::test_grid_zero_columns()
     QCOMPARE(five->x(), 0.0);
     QCOMPARE(five->y(), 50.0);
 
-    QQuickItem *grid = canvas->rootObject()->findChild<QQuickItem*>("grid");
+    QQuickItem *grid = window->rootObject()->findChild<QQuickItem*>("grid");
     QCOMPARE(grid->width(), 170.0);
     QCOMPARE(grid->height(), 60.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_propertychanges()
 {
-    QQuickView *canvas = createView(testFile("propertychangestest.qml"));
+    QQuickView *window = createView(testFile("propertychangestest.qml"));
 
-    QQuickGrid *grid = qobject_cast<QQuickGrid*>(canvas->rootObject());
+    QQuickGrid *grid = qobject_cast<QQuickGrid*>(window->rootObject());
     QVERIFY(grid != 0);
-    QQuickTransition *rowTransition = canvas->rootObject()->findChild<QQuickTransition*>("rowTransition");
-    QQuickTransition *columnTransition = canvas->rootObject()->findChild<QQuickTransition*>("columnTransition");
+    QQuickTransition *rowTransition = window->rootObject()->findChild<QQuickTransition*>("rowTransition");
+    QQuickTransition *columnTransition = window->rootObject()->findChild<QQuickTransition*>("columnTransition");
 
     QSignalSpy addSpy(grid, SIGNAL(addChanged()));
     QSignalSpy moveSpy(grid, SIGNAL(moveChanged()));
@@ -1475,20 +1475,20 @@ void tst_qquickpositioners::test_propertychanges()
     QCOMPARE(columnsSpy.count(),2);
     QCOMPARE(rowsSpy.count(),2);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_repeater()
 {
-    QQuickView *canvas = createView(testFile("repeatertest.qml"));
+    QQuickView *window = createView(testFile("repeatertest.qml"));
 
-    QQuickRectangle *one = findItem<QQuickRectangle>(canvas->rootItem(), "one");
+    QQuickRectangle *one = findItem<QQuickRectangle>(window->rootItem(), "one");
     QVERIFY(one != 0);
 
-    QQuickRectangle *two = findItem<QQuickRectangle>(canvas->rootItem(), "two");
+    QQuickRectangle *two = findItem<QQuickRectangle>(window->rootItem(), "two");
     QVERIFY(two != 0);
 
-    QQuickRectangle *three = findItem<QQuickRectangle>(canvas->rootItem(), "three");
+    QQuickRectangle *three = findItem<QQuickRectangle>(window->rootItem(), "three");
     QVERIFY(three != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1498,24 +1498,24 @@ void tst_qquickpositioners::test_repeater()
     QCOMPARE(three->x(), 100.0);
     QCOMPARE(three->y(), 0.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_flow()
 {
-    QQuickView *canvas = createView(testFile("flowtest.qml"));
+    QQuickView *window = createView(testFile("flowtest.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", false);
+    window->rootObject()->setProperty("testRightToLeft", false);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1529,29 +1529,29 @@ void tst_qquickpositioners::test_flow()
     QCOMPARE(five->x(), 50.0);
     QCOMPARE(five->y(), 70.0);
 
-    QQuickItem *flow = canvas->rootObject()->findChild<QQuickItem*>("flow");
+    QQuickItem *flow = window->rootObject()->findChild<QQuickItem*>("flow");
     QVERIFY(flow);
     QCOMPARE(flow->width(), 90.0);
     QCOMPARE(flow->height(), 120.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_flow_rightToLeft()
 {
-    QQuickView *canvas = createView(testFile("flowtest.qml"));
+    QQuickView *window = createView(testFile("flowtest.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", true);
+    window->rootObject()->setProperty("testRightToLeft", true);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 40.0);
@@ -1565,29 +1565,29 @@ void tst_qquickpositioners::test_flow_rightToLeft()
     QCOMPARE(five->x(), 30.0);
     QCOMPARE(five->y(), 70.0);
 
-    QQuickItem *flow = canvas->rootObject()->findChild<QQuickItem*>("flow");
+    QQuickItem *flow = window->rootObject()->findChild<QQuickItem*>("flow");
     QVERIFY(flow);
     QCOMPARE(flow->width(), 90.0);
     QCOMPARE(flow->height(), 120.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_flow_topToBottom()
 {
-    QQuickView *canvas = createView(testFile("flowtest-toptobottom.qml"));
+    QQuickView *window = createView(testFile("flowtest-toptobottom.qml"));
 
-    canvas->rootObject()->setProperty("testRightToLeft", false);
+    window->rootObject()->setProperty("testRightToLeft", false);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 0.0);
@@ -1601,12 +1601,12 @@ void tst_qquickpositioners::test_flow_topToBottom()
     QCOMPARE(five->x(), 100.0);
     QCOMPARE(five->y(), 50.0);
 
-    QQuickItem *flow = canvas->rootObject()->findChild<QQuickItem*>("flow");
+    QQuickItem *flow = window->rootObject()->findChild<QQuickItem*>("flow");
     QVERIFY(flow);
     QCOMPARE(flow->height(), 90.0);
     QCOMPARE(flow->width(), 150.0);
 
-    canvas->rootObject()->setProperty("testRightToLeft", true);
+    window->rootObject()->setProperty("testRightToLeft", true);
 
     QVERIFY(flow);
     QCOMPARE(flow->height(), 90.0);
@@ -1623,27 +1623,27 @@ void tst_qquickpositioners::test_flow_topToBottom()
     QCOMPARE(five->x(), 40.0);
     QCOMPARE(five->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_flow_resize()
 {
-    QQuickView *canvas = createView(testFile("flowtest.qml"));
+    QQuickView *window = createView(testFile("flowtest.qml"));
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root);
     root->setWidth(125);
     root->setProperty("testRightToLeft", false);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QVERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QTRY_COMPARE(one->x(), 0.0);
@@ -1657,27 +1657,27 @@ void tst_qquickpositioners::test_flow_resize()
     QTRY_COMPARE(five->x(), 50.0);
     QTRY_COMPARE(five->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_flow_resize_rightToLeft()
 {
-    QQuickView *canvas = createView(testFile("flowtest.qml"));
+    QQuickView *window = createView(testFile("flowtest.qml"));
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root);
     root->setWidth(125);
     root->setProperty("testRightToLeft", true);
 
-    QQuickRectangle *one = canvas->rootObject()->findChild<QQuickRectangle*>("one");
+    QQuickRectangle *one = window->rootObject()->findChild<QQuickRectangle*>("one");
     QTRY_VERIFY(one != 0);
-    QQuickRectangle *two = canvas->rootObject()->findChild<QQuickRectangle*>("two");
+    QQuickRectangle *two = window->rootObject()->findChild<QQuickRectangle*>("two");
     QVERIFY(two != 0);
-    QQuickRectangle *three = canvas->rootObject()->findChild<QQuickRectangle*>("three");
+    QQuickRectangle *three = window->rootObject()->findChild<QQuickRectangle*>("three");
     QVERIFY(three != 0);
-    QQuickRectangle *four = canvas->rootObject()->findChild<QQuickRectangle*>("four");
+    QQuickRectangle *four = window->rootObject()->findChild<QQuickRectangle*>("four");
     QVERIFY(four != 0);
-    QQuickRectangle *five = canvas->rootObject()->findChild<QQuickRectangle*>("five");
+    QQuickRectangle *five = window->rootObject()->findChild<QQuickRectangle*>("five");
     QVERIFY(five != 0);
 
     QCOMPARE(one->x(), 75.0);
@@ -1691,36 +1691,36 @@ void tst_qquickpositioners::test_flow_resize_rightToLeft()
     QCOMPARE(five->x(), 65.0);
     QCOMPARE(five->y(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_flow_implicit_resize()
 {
-    QQuickView *canvas = createView(testFile("flow-testimplicitsize.qml"));
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView(testFile("flow-testimplicitsize.qml"));
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlow *flow = canvas->rootObject()->findChild<QQuickFlow*>("flow");
+    QQuickFlow *flow = window->rootObject()->findChild<QQuickFlow*>("flow");
     QVERIFY(flow != 0);
 
     QCOMPARE(flow->width(), 100.0);
     QCOMPARE(flow->height(), 120.0);
 
-    canvas->rootObject()->setProperty("flowLayout", 0);
+    window->rootObject()->setProperty("flowLayout", 0);
     QCOMPARE(flow->flow(), QQuickFlow::LeftToRight);
     QCOMPARE(flow->width(), 220.0);
     QCOMPARE(flow->height(), 50.0);
 
-    canvas->rootObject()->setProperty("flowLayout", 1);
+    window->rootObject()->setProperty("flowLayout", 1);
     QCOMPARE(flow->flow(), QQuickFlow::TopToBottom);
     QCOMPARE(flow->width(), 100.0);
     QCOMPARE(flow->height(), 120.0);
 
-    canvas->rootObject()->setProperty("flowLayout", 2);
+    window->rootObject()->setProperty("flowLayout", 2);
     QCOMPARE(flow->layoutDirection(), Qt::RightToLeft);
     QCOMPARE(flow->width(), 220.0);
     QCOMPARE(flow->height(), 50.0);
 
-    delete canvas;
+    delete window;
 }
 
 QString warningMessage;
@@ -1839,11 +1839,11 @@ void tst_qquickpositioners::test_mirroring()
     objectNames << "one" << "two" << "three" << "four" << "five";
 
     foreach (const QString qmlFile, qmlFiles) {
-        QQuickView *canvasA = createView(testFile(qmlFile));
-        QQuickItem *rootA = qobject_cast<QQuickItem*>(canvasA->rootObject());
+        QQuickView *windowA = createView(testFile(qmlFile));
+        QQuickItem *rootA = qobject_cast<QQuickItem*>(windowA->rootObject());
 
-        QQuickView *canvasB = createView(testFile(qmlFile));
-        QQuickItem *rootB = qobject_cast<QQuickItem*>(canvasB->rootObject());
+        QQuickView *windowB = createView(testFile(qmlFile));
+        QQuickItem *rootB = qobject_cast<QQuickItem*>(windowB->rootObject());
 
         rootA->setProperty("testRightToLeft", true); // layoutDirection: Qt.RightToLeft
 
@@ -1884,24 +1884,24 @@ void tst_qquickpositioners::test_mirroring()
             QQuickItem *itemB = rootB->findChild<QQuickItem*>(objectName);
             QTRY_COMPARE(itemA->x(), itemB->x());
         }
-        delete canvasA;
-        delete canvasB;
+        delete windowA;
+        delete windowB;
     }
 }
 
 void tst_qquickpositioners::test_allInvisible()
 {
     //QTBUG-19361
-    QQuickView *canvas = createView(testFile("allInvisible.qml"));
+    QQuickView *window = createView(testFile("allInvisible.qml"));
 
-    QQuickItem *root = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *root = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(root);
 
-    QQuickRow *row = canvas->rootObject()->findChild<QQuickRow*>("row");
+    QQuickRow *row = window->rootObject()->findChild<QQuickRow*>("row");
     QVERIFY(row != 0);
     QVERIFY(row->width() == 0);
     QVERIFY(row->height() == 0);
-    QQuickColumn *column = canvas->rootObject()->findChild<QQuickColumn*>("column");
+    QQuickColumn *column = window->rootObject()->findChild<QQuickColumn*>("column");
     QVERIFY(column != 0);
     QVERIFY(column->width() == 0);
     QVERIFY(column->height() == 0);
@@ -1911,10 +1911,10 @@ void tst_qquickpositioners::test_attachedproperties()
 {
     QFETCH(QString, filename);
 
-    QQuickView *canvas = createView(filename);
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView(filename);
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickRectangle *greenRect = canvas->rootObject()->findChild<QQuickRectangle *>("greenRect");
+    QQuickRectangle *greenRect = window->rootObject()->findChild<QQuickRectangle *>("greenRect");
     QVERIFY(greenRect != 0);
 
     int posIndex = greenRect->property("posIndex").toInt();
@@ -1924,7 +1924,7 @@ void tst_qquickpositioners::test_attachedproperties()
     bool isLast = greenRect->property("isLastItem").toBool();
     QVERIFY(isLast == false);
 
-    QQuickRectangle *yellowRect = canvas->rootObject()->findChild<QQuickRectangle *>("yellowRect");
+    QQuickRectangle *yellowRect = window->rootObject()->findChild<QQuickRectangle *>("yellowRect");
     QVERIFY(yellowRect != 0);
 
     posIndex = yellowRect->property("posIndex").toInt();
@@ -1943,7 +1943,7 @@ void tst_qquickpositioners::test_attachedproperties()
     isLast = yellowRect->property("isLastItem").toBool();
     QVERIFY(isLast == true);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickpositioners::test_attachedproperties_data()
@@ -1958,13 +1958,13 @@ void tst_qquickpositioners::test_attachedproperties_data()
 
 void tst_qquickpositioners::test_attachedproperties_dynamic()
 {
-    QQuickView *canvas = createView(testFile("attachedproperties-dynamic.qml"));
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView(testFile("attachedproperties-dynamic.qml"));
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickRow *row = canvas->rootObject()->findChild<QQuickRow *>("pos");
+    QQuickRow *row = window->rootObject()->findChild<QQuickRow *>("pos");
     QVERIFY(row != 0);
 
-    QQuickRectangle *rect0 = canvas->rootObject()->findChild<QQuickRectangle *>("rect0");
+    QQuickRectangle *rect0 = window->rootObject()->findChild<QQuickRectangle *>("rect0");
     QVERIFY(rect0 != 0);
 
     int posIndex = rect0->property("index").toInt();
@@ -1974,7 +1974,7 @@ void tst_qquickpositioners::test_attachedproperties_dynamic()
     bool isLast = rect0->property("lastItem").toBool();
     QVERIFY(isLast == false);
 
-    QQuickRectangle *rect1 = canvas->rootObject()->findChild<QQuickRectangle *>("rect1");
+    QQuickRectangle *rect1 = window->rootObject()->findChild<QQuickRectangle *>("rect1");
     QVERIFY(rect1 != 0);
 
     posIndex = rect1->property("index").toInt();
@@ -1990,7 +1990,7 @@ void tst_qquickpositioners::test_attachedproperties_dynamic()
     QTRY_VERIFY(rect1->property("firstItem").toBool() == false);
     QTRY_VERIFY(rect1->property("lastItem").toBool() == false);
 
-    QQuickRectangle *rect2 = canvas->rootObject()->findChild<QQuickRectangle *>("rect2");
+    QQuickRectangle *rect2 = window->rootObject()->findChild<QQuickRectangle *>("rect2");
     QVERIFY(rect2 != 0);
 
     posIndex = rect2->property("index").toInt();
@@ -2009,23 +2009,23 @@ void tst_qquickpositioners::test_attachedproperties_dynamic()
     QTRY_VERIFY(rect1->property("firstItem").toBool() == false);
     QTRY_VERIFY(rect1->property("lastItem").toBool() == true);
 
-    delete canvas;
+    delete window;
 }
 
 QQuickView *tst_qquickpositioners::createView(const QString &filename, bool wait)
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
     qDebug() << "1";
 
-    canvas->setSource(QUrl::fromLocalFile(filename));
+    window->setSource(QUrl::fromLocalFile(filename));
     qDebug() << "2";
-    canvas->show();
+    window->show();
     qDebug() << "3";
     if (wait)
-        QTest::qWaitForWindowShown(canvas); //It may not relayout until the next frame, so it needs to be drawn
+        QTest::qWaitForWindowShown(window); //It may not relayout until the next frame, so it needs to be drawn
     qDebug() << "4";
 
-    return canvas;
+    return window;
 }
 
 void tst_qquickpositioners::matchIndexLists(const QVariantList &indexLists, const QList<int> &expectedIndexes)
diff --git a/tests/auto/quick/qquickrepeater/tst_qquickrepeater.cpp b/tests/auto/quick/qquickrepeater/tst_qquickrepeater.cpp
index d9cbed0..171e330 100644
--- a/tests/auto/quick/qquickrepeater/tst_qquickrepeater.cpp
+++ b/tests/auto/quick/qquickrepeater/tst_qquickrepeater.cpp
@@ -110,17 +110,17 @@ tst_QQuickRepeater::tst_QQuickRepeater()
 
 void tst_QQuickRepeater::numberModel()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testData", 5);
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("intmodel.qml"));
+    window->setSource(testFileUrl("intmodel.qml"));
     qApp->processEvents();
 
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
     QCOMPARE(repeater->parentItem()->childItems().count(), 5+1);
 
@@ -129,11 +129,11 @@ void tst_QQuickRepeater::numberModel()
         QCOMPARE(repeater->itemAt(i), repeater->parentItem()->childItems().at(i));
     QVERIFY(!repeater->itemAt(repeater->count()));
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QVERIFY(testObject->error() == false);
 
     delete testObject;
-    delete canvas;
+    delete window;
 }
 
 class MyObject : public QObject
@@ -150,18 +150,18 @@ public:
 
 void tst_QQuickRepeater::objectList()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
     QObjectList data;
     for (int i=0; i<100; i++)
         data << new MyObject(i);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testData", QVariant::fromValue(data));
 
-    canvas->setSource(testFileUrl("objlist.qml"));
+    window->setSource(testFileUrl("objlist.qml"));
     qApp->processEvents();
 
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
     QCOMPARE(repeater->property("errors").toInt(), 0);//If this fails either they are out of order or can't find the object's data
     QCOMPARE(repeater->property("instantiated").toInt(), 100);
@@ -178,7 +178,7 @@ void tst_QQuickRepeater::objectList()
     QCOMPARE(removedSpy.count(), data.count());
 
     qDeleteAll(data);
-    delete canvas;
+    delete window;
 }
 
 /*
@@ -188,7 +188,7 @@ elements to test this.
 */
 void tst_QQuickRepeater::stringList()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QStringList data;
     data << "One";
@@ -196,16 +196,16 @@ void tst_QQuickRepeater::stringList()
     data << "Three";
     data << "Four";
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testData", data);
 
-    canvas->setSource(testFileUrl("repeater1.qml"));
+    window->setSource(testFileUrl("repeater1.qml"));
     qApp->processEvents();
 
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
 
-    QQuickItem *container = findItem<QQuickItem>(canvas->rootObject(), "container");
+    QQuickItem *container = findItem<QQuickItem>(window->rootObject(), "container");
     QVERIFY(container != 0);
 
     QCOMPARE(container->childItems().count(), data.count() + 3);
@@ -235,24 +235,24 @@ void tst_QQuickRepeater::stringList()
     }
     QVERIFY(saw_repeater);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickRepeater::dataModel_adding()
 {
-    QQuickView *canvas = createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = createView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
     QaimModel testModel;
     ctxt->setContextProperty("testData", &testModel);
-    canvas->setSource(testFileUrl("repeater2.qml"));
+    window->setSource(testFileUrl("repeater2.qml"));
     qApp->processEvents();
 
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
-    QQuickItem *container = findItem<QQuickItem>(canvas->rootObject(), "container");
+    QQuickItem *container = findItem<QQuickItem>(window->rootObject(), "container");
     QVERIFY(container != 0);
 
     QVERIFY(!repeater->itemAt(0));
@@ -299,13 +299,13 @@ void tst_QQuickRepeater::dataModel_adding()
     delete testObject;
     addedSpy.clear();
     countSpy.clear();
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickRepeater::dataModel_removing()
 {
-    QQuickView *canvas = createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = createView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
@@ -317,12 +317,12 @@ void tst_QQuickRepeater::dataModel_removing()
     testModel.addItem("five", "5");
 
     ctxt->setContextProperty("testData", &testModel);
-    canvas->setSource(testFileUrl("repeater2.qml"));
+    window->setSource(testFileUrl("repeater2.qml"));
     qApp->processEvents();
 
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
-    QQuickItem *container = findItem<QQuickItem>(canvas->rootObject(), "container");
+    QQuickItem *container = findItem<QQuickItem>(window->rootObject(), "container");
     QVERIFY(container != 0);
     QCOMPARE(container->childItems().count(), repeater->count()+1);
 
@@ -367,13 +367,13 @@ void tst_QQuickRepeater::dataModel_removing()
     removedSpy.clear();
 
     delete testObject;
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickRepeater::dataModel_changes()
 {
-    QQuickView *canvas = createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = createView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
@@ -383,53 +383,53 @@ void tst_QQuickRepeater::dataModel_changes()
     testModel.addItem("three", "3");
 
     ctxt->setContextProperty("testData", &testModel);
-    canvas->setSource(testFileUrl("repeater2.qml"));
+    window->setSource(testFileUrl("repeater2.qml"));
     qApp->processEvents();
 
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
-    QQuickItem *container = findItem<QQuickItem>(canvas->rootObject(), "container");
+    QQuickItem *container = findItem<QQuickItem>(window->rootObject(), "container");
     QVERIFY(container != 0);
     QCOMPARE(container->childItems().count(), repeater->count()+1);
 
     // Check that model changes are propagated
-    QQuickText *text = findItem<QQuickText>(canvas->rootObject(), "myName", 1);
+    QQuickText *text = findItem<QQuickText>(window->rootObject(), "myName", 1);
     QVERIFY(text);
     QCOMPARE(text->text(), QString("two"));
 
     testModel.modifyItem(1, "Item two", "_2");
-    text = findItem<QQuickText>(canvas->rootObject(), "myName", 1);
+    text = findItem<QQuickText>(window->rootObject(), "myName", 1);
     QVERIFY(text);
     QCOMPARE(text->text(), QString("Item two"));
 
-    text = findItem<QQuickText>(canvas->rootObject(), "myNumber", 1);
+    text = findItem<QQuickText>(window->rootObject(), "myNumber", 1);
     QVERIFY(text);
     QCOMPARE(text->text(), QString("_2"));
 
     delete testObject;
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickRepeater::itemModel()
 {
-    QQuickView *canvas = createView();
-    QQmlContext *ctxt = canvas->rootContext();
+    QQuickView *window = createView();
+    QQmlContext *ctxt = window->rootContext();
     TestObject *testObject = new TestObject;
     ctxt->setContextProperty("testObject", testObject);
 
-    canvas->setSource(testFileUrl("itemlist.qml"));
+    window->setSource(testFileUrl("itemlist.qml"));
     qApp->processEvents();
 
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
 
-    QQuickItem *container = findItem<QQuickItem>(canvas->rootObject(), "container");
+    QQuickItem *container = findItem<QQuickItem>(window->rootObject(), "container");
     QVERIFY(container != 0);
 
     QCOMPARE(container->childItems().count(), 1);
 
     testObject->setUseModel(true);
-    QMetaObject::invokeMethod(canvas->rootObject(), "checkProperties");
+    QMetaObject::invokeMethod(window->rootObject(), "checkProperties");
     QVERIFY(testObject->error() == false);
 
     QCOMPARE(container->childItems().count(), 4);
@@ -438,7 +438,7 @@ void tst_QQuickRepeater::itemModel()
     QVERIFY(qobject_cast<QObject*>(container->childItems().at(2))->objectName() == "item3");
     QVERIFY(container->childItems().at(3) == repeater);
 
-    QMetaObject::invokeMethod(canvas->rootObject(), "switchModel");
+    QMetaObject::invokeMethod(window->rootObject(), "switchModel");
     QCOMPARE(container->childItems().count(), 3);
     QVERIFY(qobject_cast<QObject*>(container->childItems().at(0))->objectName() == "item4");
     QVERIFY(qobject_cast<QObject*>(container->childItems().at(1))->objectName() == "item5");
@@ -448,24 +448,24 @@ void tst_QQuickRepeater::itemModel()
     QCOMPARE(container->childItems().count(), 1);
 
     delete testObject;
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickRepeater::resetModel()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
     QStringList dataA;
     for (int i=0; i<10; i++)
         dataA << QString::number(i);
 
-    QQmlContext *ctxt = canvas->rootContext();
+    QQmlContext *ctxt = window->rootContext();
     ctxt->setContextProperty("testData", dataA);
-    canvas->setSource(testFileUrl("repeater1.qml"));
+    window->setSource(testFileUrl("repeater1.qml"));
     qApp->processEvents();
-    QQuickRepeater *repeater = findItem<QQuickRepeater>(canvas->rootObject(), "repeater");
+    QQuickRepeater *repeater = findItem<QQuickRepeater>(window->rootObject(), "repeater");
     QVERIFY(repeater != 0);
-    QQuickItem *container = findItem<QQuickItem>(canvas->rootObject(), "container");
+    QQuickItem *container = findItem<QQuickItem>(window->rootObject(), "container");
     QVERIFY(container != 0);
 
     QCOMPARE(repeater->count(), dataA.count());
@@ -516,7 +516,7 @@ void tst_QQuickRepeater::resetModel()
     removedSpy.clear();
     addedSpy.clear();
 
-    delete canvas;
+    delete window;
 }
 
 // QTBUG-17156
@@ -575,14 +575,14 @@ void tst_QQuickRepeater::properties()
 
 void tst_QQuickRepeater::asynchronous()
 {
-    QQuickView *canvas = createView();
-    canvas->show();
+    QQuickView *window = createView();
+    window->show();
     QQmlIncubationController controller;
-    canvas->engine()->setIncubationController(&controller);
+    window->engine()->setIncubationController(&controller);
 
-    canvas->setSource(testFileUrl("asyncloader.qml"));
+    window->setSource(testFileUrl("asyncloader.qml"));
 
-    QQuickItem *rootObject = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickItem *rootObject = qobject_cast<QQuickItem*>(window->rootObject());
     QVERIFY(rootObject);
 
     QQuickItem *container = findItem<QQuickItem>(rootObject, "container");
@@ -626,7 +626,7 @@ void tst_QQuickRepeater::asynchronous()
         QTRY_COMPARE(item->y(), i * 50.0);
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_QQuickRepeater::initParent()
diff --git a/tests/auto/quick/qquickspritesequence/tst_qquickspritesequence.cpp b/tests/auto/quick/qquickspritesequence/tst_qquickspritesequence.cpp
index 7a82cbb..4f541dd 100644
--- a/tests/auto/quick/qquickspritesequence/tst_qquickspritesequence.cpp
+++ b/tests/auto/quick/qquickspritesequence/tst_qquickspritesequence.cpp
@@ -57,14 +57,14 @@ private slots:
 
 void tst_qquickspritesequence::test_properties()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
-    canvas->setSource(testFileUrl("basic.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("basic.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QVERIFY(canvas->rootObject());
-    QQuickSpriteSequence* sprite = canvas->rootObject()->findChild<QQuickSpriteSequence*>("sprite");
+    QVERIFY(window->rootObject());
+    QQuickSpriteSequence* sprite = window->rootObject()->findChild<QQuickSpriteSequence*>("sprite");
     QVERIFY(sprite);
 
     QVERIFY(sprite->running());
@@ -75,35 +75,35 @@ void tst_qquickspritesequence::test_properties()
     sprite->setInterpolate(false);
     QVERIFY(!sprite->interpolate());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickspritesequence::test_framerateAdvance()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
-    canvas->setSource(testFileUrl("advance.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("advance.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
 
-    QVERIFY(canvas->rootObject());
-    QQuickSpriteSequence* sprite = canvas->rootObject()->findChild<QQuickSpriteSequence*>("sprite");
+    QVERIFY(window->rootObject());
+    QQuickSpriteSequence* sprite = window->rootObject()->findChild<QQuickSpriteSequence*>("sprite");
     QVERIFY(sprite);
 
     QTRY_COMPARE(sprite->currentSprite(), QLatin1String("secondState"));
-    delete canvas;
+    delete window;
 }
 
 void tst_qquickspritesequence::test_jumpToCrash()
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
-    canvas->setSource(testFileUrl("crashonstart.qml"));
-    canvas->show();
-    QTest::qWaitForWindowShown(canvas);
+    window->setSource(testFileUrl("crashonstart.qml"));
+    window->show();
+    QTest::qWaitForWindowShown(window);
     //verify: Don't crash
 
-    delete canvas;
+    delete window;
 }
 
 QTEST_MAIN(tst_qquickspritesequence)
diff --git a/tests/auto/quick/qquicktext/tst_qquicktext.cpp b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
index c16da4c..da5a524 100644
--- a/tests/auto/quick/qquicktext/tst_qquicktext.cpp
+++ b/tests/auto/quick/qquicktext/tst_qquicktext.cpp
@@ -228,10 +228,10 @@ tst_qquicktext::tst_qquicktext()
 
 QQuickView *tst_qquicktext::createView(const QString &filename)
 {
-    QQuickView *canvas = new QQuickView(0);
+    QQuickView *window = new QQuickView(0);
 
-    canvas->setSource(QUrl::fromLocalFile(filename));
-    return canvas;
+    window->setSource(QUrl::fromLocalFile(filename));
+    return window;
 }
 
 void tst_qquicktext::text()
@@ -502,9 +502,9 @@ void tst_qquicktext::multilineElide_data()
 void tst_qquicktext::multilineElide()
 {
     QFETCH(QQuickText::TextFormat, format);
-    QQuickView *canvas = createView(testFile("multilineelide.qml"));
+    QQuickView *window = createView(testFile("multilineelide.qml"));
 
-    QQuickText *myText = qobject_cast<QQuickText*>(canvas->rootObject());
+    QQuickText *myText = qobject_cast<QQuickText*>(window->rootObject());
     QVERIFY(myText != 0);
     myText->setTextFormat(format);
 
@@ -547,7 +547,7 @@ void tst_qquicktext::multilineElide()
     myText->setLineHeight(1.1);
     QCOMPARE(myText->lineCount(), 1);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktext::implicitElide_data()
@@ -671,27 +671,27 @@ void tst_qquicktext::alignments()
     QFETCH(int, vAlign);
     QFETCH(QString, expectfile);
 
-    QQuickView *canvas = createView(testFile("alignments.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
+    QQuickView *window = createView(testFile("alignments.qml"));
+    window->show();
+    window->requestActivateWindow();
     QTest::qWait(50);
-    QTRY_COMPARE(QGuiApplication::activeWindow(), static_cast<QWidget *>(canvas));
+    QTRY_COMPARE(QGuiApplication::activeWindow(), static_cast<QWidget *>(window));
 
-    QObject *ob = canvas->rootObject();
+    QObject *ob = window->rootObject();
     QVERIFY(ob != 0);
     ob->setProperty("horizontalAlignment",hAlign);
     ob->setProperty("verticalAlignment",vAlign);
     QTRY_COMPARE(ob->property("running").toBool(),false);
-    QImage actual(canvas->width(), canvas->height(), QImage::Format_RGB32);
+    QImage actual(window->width(), window->height(), QImage::Format_RGB32);
     actual.fill(qRgb(255,255,255));
     QPainter p(&actual);
-    canvas->render(&p);
+    window->render(&p);
 
     QImage expect(expectfile);
     if (QGuiApplicationPrivate::graphics_system_name == "raster" || QGuiApplicationPrivate::graphics_system_name == "") {
         QCOMPARE(actual,expect);
     }
-    delete canvas;
+    delete window;
 #endif
 }
 
@@ -734,10 +734,10 @@ void tst_qquicktext::horizontalAlignment()
 
 void tst_qquicktext::horizontalAlignment_RightToLeft()
 {
-    QQuickView *canvas = createView(testFile("horizontalAlignment_RightToLeft.qml"));
-    QQuickText *text = canvas->rootObject()->findChild<QQuickText*>("text");
+    QQuickView *window = createView(testFile("horizontalAlignment_RightToLeft.qml"));
+    QQuickText *text = window->rootObject()->findChild<QQuickText*>("text");
     QVERIFY(text != 0);
-    canvas->show();
+    window->show();
 
     QQuickTextPrivate *textPrivate = QQuickTextPrivate::get(text);
     QVERIFY(textPrivate != 0);
@@ -747,19 +747,19 @@ void tst_qquicktext::horizontalAlignment_RightToLeft()
     // implicit alignment should follow the reading direction of RTL text
     QCOMPARE(text->hAlign(), QQuickText::AlignRight);
     QCOMPARE(text->effectiveHAlign(), text->hAlign());
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > window->width()/2);
 
     // explicitly left aligned text
     text->setHAlign(QQuickText::AlignLeft);
     QCOMPARE(text->hAlign(), QQuickText::AlignLeft);
     QCOMPARE(text->effectiveHAlign(), text->hAlign());
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < window->width()/2);
 
     // explicitly right aligned text
     text->setHAlign(QQuickText::AlignRight);
     QCOMPARE(text->hAlign(), QQuickText::AlignRight);
     QCOMPARE(text->effectiveHAlign(), text->hAlign());
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > window->width()/2);
 
     // change to rich text
     QString textString = text->text();
@@ -792,13 +792,13 @@ void tst_qquicktext::horizontalAlignment_RightToLeft()
     text->setHAlign(QQuickText::AlignHCenter);
     QCOMPARE(text->hAlign(), QQuickText::AlignHCenter);
     QCOMPARE(text->effectiveHAlign(), text->hAlign());
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < canvas->width()/2);
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().right() > canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < window->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().right() > window->width()/2);
 
     // reseted alignment should go back to following the text reading direction
     text->resetHAlign();
     QCOMPARE(text->hAlign(), QQuickText::AlignRight);
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > window->width()/2);
 
     // mirror the text item
     QQuickItemPrivate::get(text)->setLayoutMirror(true);
@@ -806,19 +806,19 @@ void tst_qquicktext::horizontalAlignment_RightToLeft()
     // mirrored implicit alignment should continue to follow the reading direction of the text
     QCOMPARE(text->hAlign(), QQuickText::AlignRight);
     QCOMPARE(text->effectiveHAlign(), QQuickText::AlignRight);
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > window->width()/2);
 
     // mirrored explicitly right aligned behaves as left aligned
     text->setHAlign(QQuickText::AlignRight);
     QCOMPARE(text->hAlign(), QQuickText::AlignRight);
     QCOMPARE(text->effectiveHAlign(), QQuickText::AlignLeft);
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < window->width()/2);
 
     // mirrored explicitly left aligned behaves as right aligned
     text->setHAlign(QQuickText::AlignLeft);
     QCOMPARE(text->hAlign(), QQuickText::AlignLeft);
     QCOMPARE(text->effectiveHAlign(), QQuickText::AlignRight);
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() > window->width()/2);
 
     // disable mirroring
     QQuickItemPrivate::get(text)->setLayoutMirror(false);
@@ -827,7 +827,7 @@ void tst_qquicktext::horizontalAlignment_RightToLeft()
     // English text should be implicitly left aligned
     text->setText("Hello world!");
     QCOMPARE(text->hAlign(), QQuickText::AlignLeft);
-    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < canvas->width()/2);
+    QVERIFY(textPrivate->layout.lineAt(0).naturalTextRect().left() < window->width()/2);
 
     // empty text with implicit alignment follows the system locale-based
     // keyboard input direction from QInputMethod::inputDirection()
@@ -837,7 +837,7 @@ void tst_qquicktext::horizontalAlignment_RightToLeft()
     text->setHAlign(QQuickText::AlignRight);
     QCOMPARE(text->hAlign(), QQuickText::AlignRight);
 
-    delete canvas;
+    delete window;
 
     // alignment of Text with no text set to it
     QString componentStr = "import QtQuick 2.0\nText {}";
@@ -873,7 +873,7 @@ void tst_qquicktext::hAlignImplicitWidth()
 
     {
         // Left Align
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int left = numberOfNonWhitePixels(0, image.width() / 3, image);
         int mid = numberOfNonWhitePixels(image.width() / 3, 2 * image.width() / 3, image);
         int right = numberOfNonWhitePixels( 2 * image.width() / 3, image.width(), image);
@@ -883,7 +883,7 @@ void tst_qquicktext::hAlignImplicitWidth()
     {
         // HCenter Align
         text->setHAlign(QQuickText::AlignHCenter);
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int left = numberOfNonWhitePixels(0, image.width() / 3, image);
         int mid = numberOfNonWhitePixels(image.width() / 3, 2 * image.width() / 3, image);
         int right = numberOfNonWhitePixels( 2 * image.width() / 3, image.width(), image);
@@ -893,7 +893,7 @@ void tst_qquicktext::hAlignImplicitWidth()
     {
         // Right Align
         text->setHAlign(QQuickText::AlignRight);
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int left = numberOfNonWhitePixels(0, image.width() / 3, image);
         int mid = numberOfNonWhitePixels(image.width() / 3, 2 * image.width() / 3, image);
         int right = numberOfNonWhitePixels( 2 * image.width() / 3, image.width(), image);
@@ -1879,9 +1879,9 @@ void tst_qquicktext::embeddedImages()
 
 void tst_qquicktext::lineCount()
 {
-    QQuickView *canvas = createView(testFile("lineCount.qml"));
+    QQuickView *window = createView(testFile("lineCount.qml"));
 
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     QVERIFY(myText->lineCount() > 1);
@@ -1903,14 +1903,14 @@ void tst_qquicktext::lineCount()
     QCOMPARE(myText->truncated(), true);
     QCOMPARE(myText->maximumLineCount(), 2);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktext::lineHeight()
 {
-    QQuickView *canvas = createView(testFile("lineHeight.qml"));
+    QQuickView *window = createView(testFile("lineHeight.qml"));
 
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     QVERIFY(myText->lineHeight() == 1);
@@ -1936,7 +1936,7 @@ void tst_qquicktext::lineHeight()
     myText->setLineHeight(10);
     QCOMPARE(myText->height(), myText->lineCount() * 10.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktext::implicitSize_data()
@@ -2440,9 +2440,9 @@ void tst_qquicktext::clipRect()
 
 void tst_qquicktext::lineLaidOut()
 {
-    QQuickView *canvas = createView(testFile("lineLayout.qml"));
+    QQuickView *window = createView(testFile("lineLayout.qml"));
 
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     QQuickTextPrivate *textPrivate = QQuickTextPrivate::get(myText);
@@ -2461,18 +2461,18 @@ void tst_qquicktext::lineLaidOut()
         }
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktext::lineLaidOutRelayout()
 {
-    QQuickView *canvas = createView(testFile("lineLayoutRelayout.qml"));
+    QQuickView *window = createView(testFile("lineLayoutRelayout.qml"));
 
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
 
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     QQuickTextPrivate *textPrivate = QQuickTextPrivate::get(myText);
@@ -2493,7 +2493,7 @@ void tst_qquicktext::lineLaidOutRelayout()
         }
     }
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktext::imgTagsBaseUrl_data()
@@ -2637,8 +2637,8 @@ void tst_qquicktext::imgTagsMultipleImages()
 
 void tst_qquicktext::imgTagsElide()
 {
-    QQuickView *canvas = createView(testFile("imgTagsElide.qml"));
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickView *window = createView(testFile("imgTagsElide.qml"));
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     QQuickTextPrivate *textPrivate = QQuickTextPrivate::get(myText);
@@ -2648,13 +2648,13 @@ void tst_qquicktext::imgTagsElide()
     QTRY_VERIFY(textPrivate->visibleImgTags.count() == 1);
 
     delete myText;
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktext::imgTagsUpdates()
 {
-    QQuickView *canvas = createView(testFile("imgTagsUpdates.qml"));
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickView *window = createView(testFile("imgTagsUpdates.qml"));
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     QSignalSpy spy(myText, SIGNAL(contentSizeChanged()));
@@ -2675,7 +2675,7 @@ void tst_qquicktext::imgTagsUpdates()
     QVERIFY(spy.count() == 3);
 
     delete myText;
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktext::imgTagsError()
@@ -2702,10 +2702,10 @@ void tst_qquicktext::fontSizeMode()
 {
     QFETCH(QString, text);
 
-    QScopedPointer<QQuickView> canvas(createView(testFile("fontSizeMode.qml")));
-    canvas->show();
+    QScopedPointer<QQuickView> window(createView(testFile("fontSizeMode.qml")));
+    window->show();
 
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     myText->setText(text);
@@ -2945,10 +2945,10 @@ void tst_qquicktext::fontSizeModeMultiline()
 {
     QFETCH(QString, text);
 
-    QScopedPointer<QQuickView> canvas(createView(testFile("fontSizeMode.qml")));
-    canvas->show();
+    QScopedPointer<QQuickView> window(createView(testFile("fontSizeMode.qml")));
+    window->show();
 
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     myText->setText(text);
@@ -3193,10 +3193,10 @@ void tst_qquicktext::multilengthStrings()
 {
     QFETCH(QString, source);
 
-    QScopedPointer<QQuickView> canvas(createView(source));
-    canvas->show();
+    QScopedPointer<QQuickView> window(createView(source));
+    window->show();
 
-    QQuickText *myText = canvas->rootObject()->findChild<QQuickText*>("myText");
+    QQuickText *myText = window->rootObject()->findChild<QQuickText*>("myText");
     QVERIFY(myText != 0);
 
     const QString longText = "the quick brown fox jumped over the lazy dog";
diff --git a/tests/auto/quick/qquicktextedit/tst_qquicktextedit.cpp b/tests/auto/quick/qquicktextedit/tst_qquicktextedit.cpp
index ffff922..fe8beb4 100644
--- a/tests/auto/quick/qquicktextedit/tst_qquicktextedit.cpp
+++ b/tests/auto/quick/qquicktextedit/tst_qquicktextedit.cpp
@@ -583,17 +583,17 @@ void tst_qquicktextedit::alignments()
     QFETCH(int, vAlign);
     QFETCH(QString, expectfile);
 
-    QQuickView canvas(testFileUrl("alignments.qml"));
+    QQuickView window(testFileUrl("alignments.qml"));
 
-    canvas.show();
-    QTest::qWaitForWindowShown(&canvas);
+    window.show();
+    QTest::qWaitForWindowShown(&window);
 
-    QObject *ob = canvas.rootObject();
+    QObject *ob = window.rootObject();
     QVERIFY(ob != 0);
     ob->setProperty("horizontalAlignment",hAlign);
     ob->setProperty("verticalAlignment",vAlign);
     QTRY_COMPARE(ob->property("running").toBool(),false);
-    QImage actual = canvas.grabFrameBuffer();
+    QImage actual = window.grabWindow();
 
     expectfile = createExpectedFileIfNotFound(expectfile, actual);
 
@@ -644,26 +644,26 @@ void tst_qquicktextedit::hAlign_RightToLeft()
     QInputMethodPrivate *inputMethodPrivate = QInputMethodPrivate::get(qApp->inputMethod());
     inputMethodPrivate->testContext = &platformInputContext;
 
-    QQuickView canvas(testFileUrl("horizontalAlignment_RightToLeft.qml"));
-    QQuickTextEdit *textEdit = canvas.rootObject()->findChild<QQuickTextEdit*>("text");
+    QQuickView window(testFileUrl("horizontalAlignment_RightToLeft.qml"));
+    QQuickTextEdit *textEdit = window.rootObject()->findChild<QQuickTextEdit*>("text");
     QVERIFY(textEdit != 0);
-    canvas.show();
+    window.show();
 
     const QString rtlText = textEdit->text();
 
     // implicit alignment should follow the reading direction of text
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // explicitly left aligned
     textEdit->setHAlign(QQuickTextEdit::AlignLeft);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignLeft);
-    QVERIFY(textEdit->positionToRectangle(0).x() < canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() < window.width()/2);
 
     // explicitly right aligned
     textEdit->setHAlign(QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     QString textString = textEdit->text();
     textEdit->setText(QString("<i>") + textString + QString("</i>"));
@@ -672,31 +672,31 @@ void tst_qquicktextedit::hAlign_RightToLeft()
     // implicitly aligned rich text should follow the reading direction of RTL text
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->effectiveHAlign(), textEdit->hAlign());
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // explicitly left aligned rich text
     textEdit->setHAlign(QQuickTextEdit::AlignLeft);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignLeft);
     QCOMPARE(textEdit->effectiveHAlign(), textEdit->hAlign());
-    QVERIFY(textEdit->positionToRectangle(0).x() < canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() < window.width()/2);
 
     // explicitly right aligned rich text
     textEdit->setHAlign(QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->effectiveHAlign(), textEdit->hAlign());
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     textEdit->setText(textString);
 
     // explicitly center aligned
     textEdit->setHAlign(QQuickTextEdit::AlignHCenter);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignHCenter);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // reseted alignment should go back to following the text reading direction
     textEdit->resetHAlign();
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // mirror the text item
     QQuickItemPrivate::get(textEdit)->setLayoutMirror(true);
@@ -704,19 +704,19 @@ void tst_qquicktextedit::hAlign_RightToLeft()
     // mirrored implicit alignment should continue to follow the reading direction of the text
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->effectiveHAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // mirrored explicitly right aligned behaves as left aligned
     textEdit->setHAlign(QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->effectiveHAlign(), QQuickTextEdit::AlignLeft);
-    QVERIFY(textEdit->positionToRectangle(0).x() < canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() < window.width()/2);
 
     // mirrored explicitly left aligned behaves as right aligned
     textEdit->setHAlign(QQuickTextEdit::AlignLeft);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignLeft);
     QCOMPARE(textEdit->effectiveHAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // disable mirroring
     QQuickItemPrivate::get(textEdit)->setLayoutMirror(false);
@@ -725,10 +725,10 @@ void tst_qquicktextedit::hAlign_RightToLeft()
     // English text should be implicitly left aligned
     textEdit->setText("Hello world!");
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignLeft);
-    QVERIFY(textEdit->positionToRectangle(0).x() < canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() < window.width()/2);
 
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textEdit->hasActiveFocus());
 
     textEdit->setText(QString());
@@ -747,7 +747,7 @@ void tst_qquicktextedit::hAlign_RightToLeft()
     platformInputContext.setInputDirection(Qt::LeftToRight);
     QVERIFY(qApp->inputMethod()->inputDirection() == Qt::LeftToRight);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignLeft);
-    QVERIFY(textEdit->positionToRectangle(0).x() < canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() < window.width()/2);
 
     QSignalSpy cursorRectangleSpy(textEdit, SIGNAL(cursorRectangleChanged()));
 
@@ -755,27 +755,27 @@ void tst_qquicktextedit::hAlign_RightToLeft()
     QCOMPARE(cursorRectangleSpy.count(), 1);
     QVERIFY(qApp->inputMethod()->inputDirection() == Qt::RightToLeft);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // neutral text follows also input method direction
     textEdit->resetHAlign();
     textEdit->setText(" ()((=<>");
     platformInputContext.setInputDirection(Qt::LeftToRight);
     QCOMPARE(textEdit->effectiveHAlign(), QQuickTextEdit::AlignLeft);
-    QVERIFY(textEdit->cursorRectangle().left() < canvas.width()/2);
+    QVERIFY(textEdit->cursorRectangle().left() < window.width()/2);
     platformInputContext.setInputDirection(Qt::RightToLeft);
     QCOMPARE(textEdit->effectiveHAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->cursorRectangle().left() > canvas.width()/2);
+    QVERIFY(textEdit->cursorRectangle().left() > window.width()/2);
 
     // set input direction while having content
     platformInputContext.setInputDirection(Qt::LeftToRight);
     textEdit->setText("a");
     textEdit->setCursorPosition(1);
     platformInputContext.setInputDirection(Qt::RightToLeft);
-    QTest::keyClick(&canvas, Qt::Key_Backspace);
+    QTest::keyClick(&window, Qt::Key_Backspace);
     QVERIFY(textEdit->text().isEmpty());
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->cursorRectangle().left() > canvas.width()/2);
+    QVERIFY(textEdit->cursorRectangle().left() > window.width()/2);
 
     // input direction changed while not having focus
     platformInputContext.setInputDirection(Qt::LeftToRight);
@@ -783,19 +783,19 @@ void tst_qquicktextedit::hAlign_RightToLeft()
     platformInputContext.setInputDirection(Qt::RightToLeft);
     textEdit->setFocus(true);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->cursorRectangle().left() > canvas.width()/2);
+    QVERIFY(textEdit->cursorRectangle().left() > window.width()/2);
 
     textEdit->setHAlign(QQuickTextEdit::AlignRight);
     QCOMPARE(textEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(textEdit->positionToRectangle(0).x() > canvas.width()/2);
+    QVERIFY(textEdit->positionToRectangle(0).x() > window.width()/2);
 
     // make sure editor doesn't rely on input for updating size
-    QQuickTextEdit *emptyEdit = canvas.rootObject()->findChild<QQuickTextEdit*>("emptyTextEdit");
+    QQuickTextEdit *emptyEdit = window.rootObject()->findChild<QQuickTextEdit*>("emptyTextEdit");
     QVERIFY(emptyEdit != 0);
     platformInputContext.setInputDirection(Qt::RightToLeft);
     emptyEdit->setFocus(true);
     QCOMPARE(emptyEdit->hAlign(), QQuickTextEdit::AlignRight);
-    QVERIFY(emptyEdit->cursorRectangle().left() > canvas.width()/2);
+    QVERIFY(emptyEdit->cursorRectangle().left() > window.width()/2);
 }
 
 
@@ -821,7 +821,7 @@ void tst_qquicktextedit::hAlignVisual()
     QVERIFY(text != 0);
     {
         // Left Align
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int left = numberOfNonWhitePixels(0, image.width() / 3, image);
         int mid = numberOfNonWhitePixels(image.width() / 3, 2 * image.width() / 3, image);
         int right = numberOfNonWhitePixels( 2 * image.width() / 3, image.width(), image);
@@ -831,7 +831,7 @@ void tst_qquicktextedit::hAlignVisual()
     {
         // HCenter Align
         text->setHAlign(QQuickText::AlignHCenter);
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int left = numberOfNonWhitePixels(0, image.width() / 3, image);
         int mid = numberOfNonWhitePixels(image.width() / 3, 2 * image.width() / 3, image);
         int right = numberOfNonWhitePixels( 2 * image.width() / 3, image.width(), image);
@@ -841,7 +841,7 @@ void tst_qquicktextedit::hAlignVisual()
     {
         // Right Align
         text->setHAlign(QQuickText::AlignRight);
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int left = numberOfNonWhitePixels(0, image.width() / 3, image);
         int mid = numberOfNonWhitePixels(image.width() / 3, 2 * image.width() / 3, image);
         int right = numberOfNonWhitePixels( 2 * image.width() / 3, image.width(), image);
@@ -853,7 +853,7 @@ void tst_qquicktextedit::hAlignVisual()
 
     {
         // Left Align
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int x = qCeil(text->implicitWidth());
         int left = numberOfNonWhitePixels(0, x, image);
         int right = numberOfNonWhitePixels(x, image.width() - x, image);
@@ -863,7 +863,7 @@ void tst_qquicktextedit::hAlignVisual()
     {
         // HCenter Align
         text->setHAlign(QQuickText::AlignHCenter);
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int x1 = qFloor(image.width() - text->implicitWidth()) / 2;
         int x2 = image.width() - x1;
         int left = numberOfNonWhitePixels(0, x1, image);
@@ -876,7 +876,7 @@ void tst_qquicktextedit::hAlignVisual()
     {
         // Right Align
         text->setHAlign(QQuickText::AlignRight);
-        QImage image = view.grabFrameBuffer();
+        QImage image = view.grabWindow();
         int x = image.width() - qCeil(text->implicitWidth());
         int left = numberOfNonWhitePixels(0, x, image);
         int right = numberOfNonWhitePixels(x, image.width() - x, image);
@@ -1083,12 +1083,12 @@ void tst_qquicktextedit::textMargin()
 
 void tst_qquicktextedit::persistentSelection()
 {
-    QQuickView canvas(testFileUrl("persistentSelection.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("persistentSelection.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QQuickTextEdit *edit = qobject_cast<QQuickTextEdit *>(canvas.rootObject());
+    QQuickTextEdit *edit = qobject_cast<QQuickTextEdit *>(window.rootObject());
     QVERIFY(edit);
     QVERIFY(edit->hasActiveFocus());
 
@@ -1150,26 +1150,26 @@ void tst_qquicktextedit::focusOnPress()
     QCOMPARE(textEditObject->focusOnPress(), true);
     QCOMPARE(activeFocusOnPressSpy.count(), 0);
 
-    QQuickCanvas canvas;
-    canvas.resize(100, 50);
-    textEditObject->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    window.resize(100, 50);
+    textEditObject->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
     QCOMPARE(textEditObject->hasFocus(), false);
     QCOMPARE(textEditObject->hasActiveFocus(), false);
 
-    QPoint centerPoint(canvas.width()/2, canvas.height()/2);
+    QPoint centerPoint(window.width()/2, window.height()/2);
     Qt::KeyboardModifiers noModifiers = 0;
-    QTest::mousePress(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mousePress(&window, Qt::LeftButton, noModifiers, centerPoint);
     QGuiApplication::processEvents();
     QCOMPARE(textEditObject->hasFocus(), true);
     QCOMPARE(textEditObject->hasActiveFocus(), true);
     QCOMPARE(focusSpy.count(), 1);
     QCOMPARE(activeFocusSpy.count(), 1);
     QCOMPARE(textEditObject->selectedText(), QString());
-    QTest::mouseRelease(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mouseRelease(&window, Qt::LeftButton, noModifiers, centerPoint);
 
     textEditObject->setFocusOnPress(false);
     QCOMPARE(textEditObject->focusOnPress(), false);
@@ -1183,13 +1183,13 @@ void tst_qquicktextedit::focusOnPress()
 
     // Wait for double click timeout to expire before clicking again.
     QTest::qWait(400);
-    QTest::mousePress(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mousePress(&window, Qt::LeftButton, noModifiers, centerPoint);
     QGuiApplication::processEvents();
     QCOMPARE(textEditObject->hasFocus(), false);
     QCOMPARE(textEditObject->hasActiveFocus(), false);
     QCOMPARE(focusSpy.count(), 2);
     QCOMPARE(activeFocusSpy.count(), 2);
-    QTest::mouseRelease(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mouseRelease(&window, Qt::LeftButton, noModifiers, centerPoint);
 
     textEditObject->setFocusOnPress(true);
     QCOMPARE(textEditObject->focusOnPress(), true);
@@ -1199,14 +1199,14 @@ void tst_qquicktextedit::focusOnPress()
     textEditObject->setProperty("selectOnFocus", true);
 
     QTest::qWait(400);
-    QTest::mousePress(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mousePress(&window, Qt::LeftButton, noModifiers, centerPoint);
     QGuiApplication::processEvents();
     QCOMPARE(textEditObject->hasFocus(), true);
     QCOMPARE(textEditObject->hasActiveFocus(), true);
     QCOMPARE(focusSpy.count(), 3);
     QCOMPARE(activeFocusSpy.count(), 3);
     QCOMPARE(textEditObject->selectedText(), textEditObject->text());
-    QTest::mouseRelease(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mouseRelease(&window, Qt::LeftButton, noModifiers, centerPoint);
 }
 
 void tst_qquicktextedit::selection()
@@ -1352,45 +1352,45 @@ void tst_qquicktextedit::isRightToLeft()
 
 void tst_qquicktextedit::keySelection()
 {
-    QQuickView canvas(testFileUrl("navigation.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("navigation.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextEdit *input = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextEdit *input = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
 
     QVERIFY(input != 0);
     QVERIFY(input->hasActiveFocus());
 
     QSignalSpy spy(input, SIGNAL(selectedTextChanged()));
 
-    simulateKey(&canvas, Qt::Key_Right, Qt::ShiftModifier);
+    simulateKey(&window, Qt::Key_Right, Qt::ShiftModifier);
     QVERIFY(input->hasActiveFocus() == true);
     QCOMPARE(input->selectedText(), QString("a"));
     QCOMPARE(spy.count(), 1);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == true);
     QCOMPARE(input->selectedText(), QString());
     QCOMPARE(spy.count(), 2);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == false);
     QCOMPARE(input->selectedText(), QString());
     QCOMPARE(spy.count(), 2);
 
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == true);
     QCOMPARE(spy.count(), 2);
-    simulateKey(&canvas, Qt::Key_Left, Qt::ShiftModifier);
+    simulateKey(&window, Qt::Key_Left, Qt::ShiftModifier);
     QVERIFY(input->hasActiveFocus() == true);
     QCOMPARE(input->selectedText(), QString("a"));
     QCOMPARE(spy.count(), 3);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == true);
     QCOMPARE(input->selectedText(), QString());
     QCOMPARE(spy.count(), 4);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == false);
     QCOMPARE(input->selectedText(), QString());
     QCOMPARE(spy.count(), 4);
@@ -1808,14 +1808,14 @@ void tst_qquicktextedit::mouseSelection()
     QFETCH(bool, focusOnPress);
     QFETCH(int, clicks);
 
-    QQuickView canvas(QUrl::fromLocalFile(qmlfile));
+    QQuickView window(QUrl::fromLocalFile(qmlfile));
 
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(canvas.rootObject());
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(window.rootObject());
     QVERIFY(textEditObject != 0);
 
     textEditObject->setFocus(focus);
@@ -1825,21 +1825,21 @@ void tst_qquicktextedit::mouseSelection()
     QPoint p1 = textEditObject->positionToRectangle(from).center().toPoint();
     QPoint p2 = textEditObject->positionToRectangle(to).center().toPoint();
     if (clicks == 2)
-        QTest::mouseClick(&canvas, Qt::LeftButton, Qt::NoModifier, p1);
+        QTest::mouseClick(&window, Qt::LeftButton, Qt::NoModifier, p1);
     else if (clicks == 3)
-        QTest::mouseDClick(&canvas, Qt::LeftButton, Qt::NoModifier, p1);
-    QTest::mousePress(&canvas, Qt::LeftButton, Qt::NoModifier, p1);
-    QTest::mouseMove(&canvas, p2);
-    QTest::mouseRelease(&canvas, Qt::LeftButton, Qt::NoModifier, p2);
+        QTest::mouseDClick(&window, Qt::LeftButton, Qt::NoModifier, p1);
+    QTest::mousePress(&window, Qt::LeftButton, Qt::NoModifier, p1);
+    QTest::mouseMove(&window, p2);
+    QTest::mouseRelease(&window, Qt::LeftButton, Qt::NoModifier, p2);
     QTRY_COMPARE(textEditObject->selectedText(), selectedText);
 
     // Clicking and shift to clicking between the same points should select the same text.
     textEditObject->setCursorPosition(0);
     if (clicks > 1)
-        QTest::mouseDClick(&canvas, Qt::LeftButton, Qt::NoModifier, p1);
+        QTest::mouseDClick(&window, Qt::LeftButton, Qt::NoModifier, p1);
     if (clicks != 2)
-        QTest::mouseClick(&canvas, Qt::LeftButton, Qt::NoModifier, p1);
-    QTest::mouseClick(&canvas, Qt::LeftButton, Qt::ShiftModifier, p2);
+        QTest::mouseClick(&window, Qt::LeftButton, Qt::NoModifier, p1);
+    QTest::mouseClick(&window, Qt::LeftButton, Qt::ShiftModifier, p2);
     QTRY_COMPARE(textEditObject->selectedText(), selectedText);
 
     // ### This is to prevent double click detection from carrying over to the next test.
@@ -1850,23 +1850,23 @@ void tst_qquicktextedit::dragMouseSelection()
 {
     QString qmlfile = testFile("mouseselection_true.qml");
 
-    QQuickView canvas(QUrl::fromLocalFile(qmlfile));
+    QQuickView window(QUrl::fromLocalFile(qmlfile));
 
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(canvas.rootObject());
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(window.rootObject());
     QVERIFY(textEditObject != 0);
 
     // press-and-drag-and-release from x1 to x2
     int x1 = 10;
     int x2 = 70;
     int y = QFontMetrics(textEditObject->font()).height() / 2;
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(x1,y));
-    QTest::mouseMove(&canvas, QPoint(x2, y));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(x2,y));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(x1,y));
+    QTest::mouseMove(&window, QPoint(x2, y));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(x2,y));
     QTest::qWait(300);
     QString str1;
     QTRY_VERIFY((str1 = textEditObject->selectedText()).length() > 3);
@@ -1874,9 +1874,9 @@ void tst_qquicktextedit::dragMouseSelection()
     // press and drag the current selection.
     x1 = 40;
     x2 = 100;
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(x1,y));
-    QTest::mouseMove(&canvas, QPoint(x2, y));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(x2,y));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(x1,y));
+    QTest::mouseMove(&window, QPoint(x2, y));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(x2,y));
     QTest::qWait(300);
     QString str2;
     QTRY_VERIFY((str2 = textEditObject->selectedText()).length() > 3);
@@ -1903,23 +1903,23 @@ void tst_qquicktextedit::mouseSelectionMode()
 
     QString text = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
-    QQuickView canvas(QUrl::fromLocalFile(qmlfile));
+    QQuickView window(QUrl::fromLocalFile(qmlfile));
 
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(canvas.rootObject());
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(window.rootObject());
     QVERIFY(textEditObject != 0);
 
     // press-and-drag-and-release from x1 to x2
     int x1 = 10;
     int x2 = 70;
     int y = textEditObject->height()/2;
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(x1,y));
-    QTest::mouseMove(&canvas, QPoint(x2, y));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(x2,y));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(x1,y));
+    QTest::mouseMove(&window, QPoint(x2, y));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(x2,y));
     QString str = textEditObject->selectedText();
     if (selectWords) {
         QTRY_COMPARE(textEditObject->selectedText(), text);
@@ -1931,12 +1931,12 @@ void tst_qquicktextedit::mouseSelectionMode()
 
 void tst_qquicktextedit::inputMethodHints()
 {
-    QQuickView canvas(testFileUrl("inputmethodhints.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
+    QQuickView window(testFileUrl("inputmethodhints.qml"));
+    window.show();
+    window.requestActivateWindow();
 
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(canvas.rootObject());
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextEdit *textEditObject = qobject_cast<QQuickTextEdit *>(window.rootObject());
     QVERIFY(textEditObject != 0);
     QVERIFY(textEditObject->inputMethodHints() & Qt::ImhNoPredictiveText);
     QSignalSpy inputMethodHintSpy(textEditObject, SIGNAL(inputMethodHintsChanged()));
@@ -1970,13 +1970,13 @@ void tst_qquicktextedit::positionAt()
     QFETCH(QQuickTextEdit::HAlignment, horizontalAlignment);
     QFETCH(QQuickTextEdit::VAlignment, verticalAlignment);
 
-    QQuickView canvas(testFileUrl("positionAt.qml"));
-    QVERIFY(canvas.rootObject() != 0);
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("positionAt.qml"));
+    QVERIFY(window.rootObject() != 0);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QQuickTextEdit *texteditObject = qobject_cast<QQuickTextEdit *>(canvas.rootObject());
+    QQuickTextEdit *texteditObject = qobject_cast<QQuickTextEdit *>(window.rootObject());
     QVERIFY(texteditObject != 0);
     texteditObject->setHAlign(horizontalAlignment);
     texteditObject->setVAlign(verticalAlignment);
@@ -2059,13 +2059,13 @@ void tst_qquicktextedit::positionAt()
 
 void tst_qquicktextedit::linkActivated()
 {
-    QQuickView canvas(testFileUrl("linkActivated.qml"));
-    QVERIFY(canvas.rootObject() != 0);
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("linkActivated.qml"));
+    QVERIFY(window.rootObject() != 0);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QQuickTextEdit *texteditObject = qobject_cast<QQuickTextEdit *>(canvas.rootObject());
+    QQuickTextEdit *texteditObject = qobject_cast<QQuickTextEdit *>(window.rootObject());
     QVERIFY(texteditObject != 0);
 
     QSignalSpy spy(texteditObject, SIGNAL(linkActivated(QString)));
@@ -2075,21 +2075,21 @@ void tst_qquicktextedit::linkActivated()
     const QPointF linkPos = texteditObject->positionToRectangle(7).center();
     const QPointF textPos = texteditObject->positionToRectangle(2).center();
 
-    QTest::mouseClick(&canvas, Qt::LeftButton, 0, linkPos.toPoint());
+    QTest::mouseClick(&window, Qt::LeftButton, 0, linkPos.toPoint());
     QTRY_COMPARE(spy.count(), 1);
     QCOMPARE(spy.last()[0].toString(), link);
 
-    QTest::mouseClick(&canvas, Qt::LeftButton, 0, textPos.toPoint());
+    QTest::mouseClick(&window, Qt::LeftButton, 0, textPos.toPoint());
     QTest::qWait(50);
     QCOMPARE(spy.count(), 1);
 
     texteditObject->setReadOnly(true);
 
-    QTest::mouseClick(&canvas, Qt::LeftButton, 0, linkPos.toPoint());
+    QTest::mouseClick(&window, Qt::LeftButton, 0, linkPos.toPoint());
     QTRY_COMPARE(spy.count(), 2);
     QCOMPARE(spy.last()[0].toString(), link);
 
-    QTest::mouseClick(&canvas, Qt::LeftButton, 0, textPos.toPoint());
+    QTest::mouseClick(&window, Qt::LeftButton, 0, textPos.toPoint());
     QTest::qWait(50);
     QCOMPARE(spy.count(), 2);
 }
@@ -2393,35 +2393,35 @@ the extent of the text, then they should ignore the keys.
 */
 void tst_qquicktextedit::navigation()
 {
-    QQuickView canvas(testFileUrl("navigation.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
+    QQuickView window(testFileUrl("navigation.qml"));
+    window.show();
+    window.requestActivateWindow();
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextEdit *input = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextEdit *input = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
 
     QVERIFY(input != 0);
     QTRY_VERIFY(input->hasActiveFocus() == true);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == false);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == true);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == true);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == false);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == true);
 
     // Test left and right navigation works if the TextEdit is empty (QTBUG-25447).
     input->setText(QString());
     QCOMPARE(input->cursorPosition(), 0);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QCOMPARE(input->hasActiveFocus(), false);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QCOMPARE(input->hasActiveFocus(), true);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QCOMPARE(input->hasActiveFocus(), false);
 }
 
@@ -2525,23 +2525,23 @@ void tst_qquicktextedit::canPasteEmpty() {
 
 void tst_qquicktextedit::readOnly()
 {
-    QQuickView canvas(testFileUrl("readOnly.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
+    QQuickView window(testFileUrl("readOnly.qml"));
+    window.show();
+    window.requestActivateWindow();
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextEdit *edit = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextEdit *edit = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
 
     QVERIFY(edit != 0);
     QTRY_VERIFY(edit->hasActiveFocus() == true);
     QVERIFY(edit->isReadOnly() == true);
     QString initial = edit->text();
     for (int k=Qt::Key_0; k<=Qt::Key_Z; k++)
-        simulateKey(&canvas, k);
-    simulateKey(&canvas, Qt::Key_Return);
-    simulateKey(&canvas, Qt::Key_Space);
-    simulateKey(&canvas, Qt::Key_Escape);
+        simulateKey(&window, k);
+    simulateKey(&window, Qt::Key_Return);
+    simulateKey(&window, Qt::Key_Space);
+    simulateKey(&window, Qt::Key_Escape);
     QCOMPARE(edit->text(), initial);
 
     edit->setCursorPosition(3);
@@ -3215,9 +3215,9 @@ void tst_qquicktextedit::inputMethodComposing()
 
 void tst_qquicktextedit::cursorRectangleSize()
 {
-    QQuickView *canvas = new QQuickView(testFileUrl("positionAt.qml"));
-    QVERIFY(canvas->rootObject() != 0);
-    QQuickTextEdit *textEdit = qobject_cast<QQuickTextEdit *>(canvas->rootObject());
+    QQuickView *window = new QQuickView(testFileUrl("positionAt.qml"));
+    QVERIFY(window->rootObject() != 0);
+    QQuickTextEdit *textEdit = qobject_cast<QQuickTextEdit *>(window->rootObject());
 
     // make sure cursor rectangle is not at (0,0)
     textEdit->setX(10);
@@ -3225,9 +3225,9 @@ void tst_qquicktextedit::cursorRectangleSize()
     textEdit->setCursorPosition(3);
     QVERIFY(textEdit != 0);
     textEdit->setFocus(true);
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowActive(canvas);
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowActive(window);
 
     QInputMethodQueryEvent event(Qt::ImCursorRectangle);
     qApp->sendEvent(textEdit, &event);
@@ -3242,14 +3242,14 @@ void tst_qquicktextedit::cursorRectangleSize()
     // item cursor rectangle and positionToRectangle calculations match
     QCOMPARE(cursorRectFromItem, cursorRectFromPositionToRectangle);
 
-    // item-canvas transform and input item transform match
-    QCOMPARE(QQuickItemPrivate::get(textEdit)->itemToCanvasTransform(), qApp->inputMethod()->inputItemTransform());
+    // item-window transform and input item transform match
+    QCOMPARE(QQuickItemPrivate::get(textEdit)->itemToWindowTransform(), qApp->inputMethod()->inputItemTransform());
 
     // input panel cursorRectangle property and tranformed item cursor rectangle match
-    QRectF sceneCursorRect = QQuickItemPrivate::get(textEdit)->itemToCanvasTransform().mapRect(cursorRectFromItem);
+    QRectF sceneCursorRect = QQuickItemPrivate::get(textEdit)->itemToWindowTransform().mapRect(cursorRectFromItem);
     QCOMPARE(sceneCursorRect, qApp->inputMethod()->cursorRectangle());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktextedit::getText_data()
@@ -4081,19 +4081,19 @@ void tst_qquicktextedit::keySequence()
     QQuickTextEdit *textEdit = qobject_cast<QQuickTextEdit*>(textEditComponent.create());
     QVERIFY(textEdit != 0);
 
-    QQuickCanvas canvas;
-    textEdit->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textEdit->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
     QVERIFY(textEdit->hasActiveFocus());
 
-    simulateKey(&canvas, layoutDirection);
+    simulateKey(&window, layoutDirection);
 
     textEdit->select(selectionStart, selectionEnd);
 
-    simulateKeys(&canvas, sequence);
+    simulateKeys(&window, sequence);
 
     QCOMPARE(textEdit->cursorPosition(), cursorPosition);
     QCOMPARE(textEdit->text(), expectedText);
@@ -4244,11 +4244,11 @@ void tst_qquicktextedit::undo()
     QQuickTextEdit *textEdit = qobject_cast<QQuickTextEdit*>(textEditComponent.create());
     QVERIFY(textEdit != 0);
 
-    QQuickCanvas canvas;
-    textEdit->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textEdit->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
     QVERIFY(textEdit->hasActiveFocus());
     QVERIFY(!textEdit->canUndo());
@@ -4271,7 +4271,7 @@ void tst_qquicktextedit::undo()
         }
 
         for (int j = 0; j < insertString.at(i).length(); j++)
-            QTest::keyClick(&canvas, insertString.at(i).at(j).toLatin1());
+            QTest::keyClick(&window, insertString.at(i).at(j).toLatin1());
     }
 
     QCOMPARE(spy.count(), 1);
@@ -4330,11 +4330,11 @@ void tst_qquicktextedit::redo()
     QQuickTextEdit *textEdit = qobject_cast<QQuickTextEdit*>(textEditComponent.create());
     QVERIFY(textEdit != 0);
 
-    QQuickCanvas canvas;
-    textEdit->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textEdit->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textEdit->hasActiveFocus());
 
     QVERIFY(!textEdit->canUndo());
@@ -4348,7 +4348,7 @@ void tst_qquicktextedit::redo()
         if (insertIndex[i] > -1)
             textEdit->setCursorPosition(insertIndex[i]);
         for (int j = 0; j < insertString.at(i).length(); j++)
-            QTest::keyClick(&canvas, insertString.at(i).at(j).toLatin1());
+            QTest::keyClick(&window, insertString.at(i).at(j).toLatin1());
         QVERIFY(textEdit->canUndo());
         QVERIFY(!textEdit->canRedo());
     }
@@ -4523,14 +4523,14 @@ void tst_qquicktextedit::undo_keypressevents()
     QQuickTextEdit *textEdit = qobject_cast<QQuickTextEdit*>(textEditComponent.create());
     QVERIFY(textEdit != 0);
 
-    QQuickCanvas canvas;
-    textEdit->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textEdit->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textEdit->hasActiveFocus());
 
-    simulateKeys(&canvas, keys);
+    simulateKeys(&window, keys);
 
     for (int i = 0; i < expectedString.size(); ++i) {
         QCOMPARE(textEdit->text() , expectedString[i]);
@@ -4611,13 +4611,13 @@ void tst_qquicktextedit::embeddedImages()
 
 void tst_qquicktextedit::emptytags_QTBUG_22058()
 {
-    QQuickView canvas(testFileUrl("qtbug-22058.qml"));
-    QVERIFY(canvas.rootObject() != 0);
+    QQuickView window(testFileUrl("qtbug-22058.qml"));
+    QVERIFY(window.rootObject() != 0);
 
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
-    QQuickTextEdit *input = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(canvas.rootObject()->property("inputField")));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
+    QQuickTextEdit *input = qobject_cast<QQuickTextEdit *>(qvariant_cast<QObject *>(window.rootObject()->property("inputField")));
     QVERIFY(input->hasActiveFocus());
 
     QInputMethodEvent event("", QList<QInputMethodEvent::Attribute>());
diff --git a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
index eec9faf..a4d1920 100644
--- a/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
+++ b/tests/auto/quick/qquicktextinput/tst_qquicktextinput.cpp
@@ -658,12 +658,12 @@ void tst_qquicktextinput::selection()
 
 void tst_qquicktextinput::persistentSelection()
 {
-    QQuickView canvas(testFileUrl("persistentSelection.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("persistentSelection.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(canvas.rootObject());
+    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(window.rootObject());
     QVERIFY(input);
     QVERIFY(input->hasActiveFocus());
 
@@ -1168,23 +1168,23 @@ void tst_qquicktextinput::dragMouseSelection()
 {
     QString qmlfile = testFile("mouseselection_true.qml");
 
-    QQuickView canvas(QUrl::fromLocalFile(qmlfile));
+    QQuickView window(QUrl::fromLocalFile(qmlfile));
 
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextInput *textInputObject = qobject_cast<QQuickTextInput *>(canvas.rootObject());
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextInput *textInputObject = qobject_cast<QQuickTextInput *>(window.rootObject());
     QVERIFY(textInputObject != 0);
 
     // press-and-drag-and-release from x1 to x2
     int x1 = 10;
     int x2 = 70;
     int y = textInputObject->height()/2;
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(x1,y));
-    QTest::mouseMove(&canvas, QPoint(x2, y));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(x2,y));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(x1,y));
+    QTest::mouseMove(&window, QPoint(x2, y));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(x2,y));
     QTest::qWait(100);
     QString str1;
     QVERIFY((str1 = textInputObject->selectedText()).length() > 3);
@@ -1193,9 +1193,9 @@ void tst_qquicktextinput::dragMouseSelection()
     // press and drag the current selection.
     x1 = 40;
     x2 = 100;
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(x1,y));
-    QTest::mouseMove(&canvas, QPoint(x2, y));
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(x2,y));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(x1,y));
+    QTest::mouseMove(&window, QPoint(x2, y));
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(x2,y));
     QTest::qWait(300);
     QString str2 = textInputObject->selectedText();
     QVERIFY(str2.length() > 3);
@@ -1231,14 +1231,14 @@ void tst_qquicktextinput::mouseSelectionMode()
 
     QString text = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 
-    QQuickView canvas(QUrl::fromLocalFile(qmlfile));
+    QQuickView window(QUrl::fromLocalFile(qmlfile));
 
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextInput *textInputObject = qobject_cast<QQuickTextInput *>(canvas.rootObject());
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextInput *textInputObject = qobject_cast<QQuickTextInput *>(window.rootObject());
     QVERIFY(textInputObject != 0);
 
     textInputObject->setFocus(focus);
@@ -1248,9 +1248,9 @@ void tst_qquicktextinput::mouseSelectionMode()
     int x1 = 10;
     int x2 = 70;
     int y = textInputObject->height()/2;
-    QTest::mousePress(&canvas, Qt::LeftButton, 0, QPoint(x1,y));
-    QTest::mouseMove(&canvas, QPoint(x2,y)); // doesn't work
-    QTest::mouseRelease(&canvas, Qt::LeftButton, 0, QPoint(x2,y));
+    QTest::mousePress(&window, Qt::LeftButton, 0, QPoint(x1,y));
+    QTest::mouseMove(&window, QPoint(x2,y)); // doesn't work
+    QTest::mouseRelease(&window, Qt::LeftButton, 0, QPoint(x2,y));
     QTest::qWait(300);
     if (selectWords) {
         QTRY_COMPARE(textInputObject->selectedText(), text);
@@ -1277,15 +1277,15 @@ void tst_qquicktextinput::horizontalAlignment()
     QFETCH(int, hAlign);
     QFETCH(QString, expectfile);
 
-    QQuickView canvas(testFileUrl("horizontalAlignment.qml"));
+    QQuickView window(testFileUrl("horizontalAlignment.qml"));
 
-    canvas.show();
-    QTest::qWaitForWindowShown(&canvas);
+    window.show();
+    QTest::qWaitForWindowShown(&window);
 
-    QObject *ob = canvas.rootObject();
+    QObject *ob = window.rootObject();
     QVERIFY(ob != 0);
     ob->setProperty("horizontalAlignment",hAlign);
-    QImage actual = canvas.grabFrameBuffer();
+    QImage actual = window.grabWindow();
 
     expectfile = createExpectedFileIfNotFound(expectfile, actual);
 
@@ -1300,10 +1300,10 @@ void tst_qquicktextinput::horizontalAlignment_RightToLeft()
     QInputMethodPrivate *inputMethodPrivate = QInputMethodPrivate::get(qApp->inputMethod());
     inputMethodPrivate->testContext = &platformInputContext;
 
-    QQuickView canvas(testFileUrl("horizontalAlignment_RightToLeft.qml"));
-    QQuickTextInput *textInput = canvas.rootObject()->findChild<QQuickTextInput*>("text");
+    QQuickView window(testFileUrl("horizontalAlignment_RightToLeft.qml"));
+    QQuickTextInput *textInput = window.rootObject()->findChild<QQuickTextInput*>("text");
     QVERIFY(textInput != 0);
-    canvas.show();
+    window.show();
 
     const QString rtlText = textInput->text();
 
@@ -1375,8 +1375,8 @@ void tst_qquicktextinput::horizontalAlignment_RightToLeft()
     QCOMPARE(textInput->hAlign(), QQuickTextInput::AlignLeft);
     QCOMPARE(textInput->boundingRect().left(), qreal(0));
 
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textInput->hasActiveFocus());
 
     // If there is no commited text, the preedit text should determine the alignment.
@@ -1410,7 +1410,7 @@ void tst_qquicktextinput::horizontalAlignment_RightToLeft()
     platformInputContext.setInputDirection(Qt::LeftToRight);
     textInput->setText("a");
     platformInputContext.setInputDirection(Qt::RightToLeft);
-    QTest::keyClick(&canvas, Qt::Key_Backspace);
+    QTest::keyClick(&window, Qt::Key_Backspace);
     QVERIFY(textInput->text().isEmpty());
     QCOMPARE(textInput->hAlign(), QQuickTextInput::AlignRight);
     QVERIFY(textInput->boundingRect().right() >= textInput->width() - 1);
@@ -1447,32 +1447,32 @@ void tst_qquicktextinput::horizontalAlignment_RightToLeft()
 
 void tst_qquicktextinput::verticalAlignment()
 {
-    QQuickView canvas(testFileUrl("horizontalAlignment.qml"));
-    QQuickTextInput *textInput = canvas.rootObject()->findChild<QQuickTextInput*>("text");
+    QQuickView window(testFileUrl("horizontalAlignment.qml"));
+    QQuickTextInput *textInput = window.rootObject()->findChild<QQuickTextInput*>("text");
     QVERIFY(textInput != 0);
-    canvas.show();
+    window.show();
 
     QCOMPARE(textInput->vAlign(), QQuickTextInput::AlignTop);
-    QVERIFY(textInput->boundingRect().bottom() < canvas.height() / 2);
-    QVERIFY(textInput->cursorRectangle().bottom() < canvas.height() / 2);
-    QVERIFY(textInput->positionToRectangle(0).bottom() < canvas.height() / 2);
+    QVERIFY(textInput->boundingRect().bottom() < window.height() / 2);
+    QVERIFY(textInput->cursorRectangle().bottom() < window.height() / 2);
+    QVERIFY(textInput->positionToRectangle(0).bottom() < window.height() / 2);
 
     // bottom aligned
     textInput->setVAlign(QQuickTextInput::AlignBottom);
     QCOMPARE(textInput->vAlign(), QQuickTextInput::AlignBottom);
-    QVERIFY(textInput->boundingRect().top() > canvas.height() / 2);
-    QVERIFY(textInput->cursorRectangle().top() > canvas.height() / 2);
-    QVERIFY(textInput->positionToRectangle(0).top() > canvas.height() / 2);
+    QVERIFY(textInput->boundingRect().top() > window.height() / 2);
+    QVERIFY(textInput->cursorRectangle().top() > window.height() / 2);
+    QVERIFY(textInput->positionToRectangle(0).top() > window.height() / 2);
 
     // explicitly center aligned
     textInput->setVAlign(QQuickTextInput::AlignVCenter);
     QCOMPARE(textInput->vAlign(), QQuickTextInput::AlignVCenter);
-    QVERIFY(textInput->boundingRect().top() < canvas.height() / 2);
-    QVERIFY(textInput->boundingRect().bottom() > canvas.height() / 2);
-    QVERIFY(textInput->cursorRectangle().top() < canvas.height() / 2);
-    QVERIFY(textInput->cursorRectangle().bottom() > canvas.height() / 2);
-    QVERIFY(textInput->positionToRectangle(0).top() < canvas.height() / 2);
-    QVERIFY(textInput->positionToRectangle(0).bottom() > canvas.height() / 2);
+    QVERIFY(textInput->boundingRect().top() < window.height() / 2);
+    QVERIFY(textInput->boundingRect().bottom() > window.height() / 2);
+    QVERIFY(textInput->cursorRectangle().top() < window.height() / 2);
+    QVERIFY(textInput->cursorRectangle().bottom() > window.height() / 2);
+    QVERIFY(textInput->positionToRectangle(0).top() < window.height() / 2);
+    QVERIFY(textInput->positionToRectangle(0).bottom() > window.height() / 2);
 }
 
 void tst_qquicktextinput::clipRect()
@@ -1635,13 +1635,13 @@ void tst_qquicktextinput::boundingRect()
 
 void tst_qquicktextinput::positionAt()
 {
-    QQuickView canvas(testFileUrl("positionAt.qml"));
-    QVERIFY(canvas.rootObject() != 0);
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("positionAt.qml"));
+    QVERIFY(window.rootObject() != 0);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QQuickTextInput *textinputObject = qobject_cast<QQuickTextInput *>(canvas.rootObject());
+    QQuickTextInput *textinputObject = qobject_cast<QQuickTextInput *>(window.rootObject());
     QVERIFY(textinputObject != 0);
 
     // Check autoscrolled...
@@ -1725,13 +1725,13 @@ void tst_qquicktextinput::positionAt()
 
 void tst_qquicktextinput::maxLength()
 {
-    QQuickView canvas(testFileUrl("maxLength.qml"));
-    QVERIFY(canvas.rootObject() != 0);
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("maxLength.qml"));
+    QVERIFY(window.rootObject() != 0);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QQuickTextInput *textinputObject = qobject_cast<QQuickTextInput *>(canvas.rootObject());
+    QQuickTextInput *textinputObject = qobject_cast<QQuickTextInput *>(window.rootObject());
     QVERIFY(textinputObject != 0);
     QVERIFY(textinputObject->text().isEmpty());
     QVERIFY(textinputObject->maxLength() == 10);
@@ -1745,9 +1745,9 @@ void tst_qquicktextinput::maxLength()
     QTRY_VERIFY(textinputObject->hasActiveFocus() == true);
     for (int i=0; i<20; i++) {
         QTRY_COMPARE(textinputObject->text().length(), qMin(i,10));
-        //simulateKey(&canvas, Qt::Key_A);
-        QTest::keyPress(&canvas, Qt::Key_A);
-        QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+        //simulateKey(&window, Qt::Key_A);
+        QTest::keyPress(&window, Qt::Key_A);
+        QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
         QTest::qWait(50);
     }
 }
@@ -1756,11 +1756,11 @@ void tst_qquicktextinput::masks()
 {
     //Not a comprehensive test of the possible masks, that's done elsewhere (QLineEdit)
     //QString componentStr = "import QtQuick 2.0\nTextInput {  inputMask: 'HHHHhhhh'; }";
-    QQuickView canvas(testFileUrl("masks.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextInput *textinputObject = qobject_cast<QQuickTextInput *>(canvas.rootObject());
+    QQuickView window(testFileUrl("masks.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextInput *textinputObject = qobject_cast<QQuickTextInput *>(window.rootObject());
     QVERIFY(textinputObject != 0);
     QTRY_VERIFY(textinputObject->hasActiveFocus() == true);
     QVERIFY(textinputObject->text().length() == 0);
@@ -1772,9 +1772,9 @@ void tst_qquicktextinput::masks()
         QCOMPARE(textinputObject->getText(0, qMin(i, 8)), QString(qMin(i, 8), 'a'));
         QCOMPARE(textinputObject->getText(qMin(i, 8), 8), QString(8 - qMin(i, 8), ' '));
         QCOMPARE(i>=4, textinputObject->hasAcceptableInput());
-        //simulateKey(&canvas, Qt::Key_A);
-        QTest::keyPress(&canvas, Qt::Key_A);
-        QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+        //simulateKey(&window, Qt::Key_A);
+        QTest::keyPress(&window, Qt::Key_A);
+        QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
         QTest::qWait(50);
     }
 }
@@ -1787,18 +1787,18 @@ void tst_qquicktextinput::validators()
 
     QLocale::setDefault(QLocale(QStringLiteral("C")));
 
-    QQuickView canvas(testFileUrl("validators.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("validators.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
     QLocale defaultLocale;
     QLocale enLocale("en");
     QLocale deLocale("de_DE");
 
-    QQuickTextInput *intInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("intInput")));
+    QQuickTextInput *intInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("intInput")));
     QVERIFY(intInput);
     QSignalSpy intSpy(intInput, SIGNAL(acceptableInputChanged()));
 
@@ -1817,63 +1817,63 @@ void tst_qquicktextinput::validators()
     QTRY_VERIFY(intInput->hasActiveFocus());
     QCOMPARE(intInput->hasAcceptableInput(), false);
     QCOMPARE(intInput->property("acceptable").toBool(), false);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(intInput->text(), QLatin1String("1"));
     QCOMPARE(intInput->hasAcceptableInput(), false);
     QCOMPARE(intInput->property("acceptable").toBool(), false);
     QCOMPARE(intSpy.count(), 0);
-    QTest::keyPress(&canvas, Qt::Key_2);
-    QTest::keyRelease(&canvas, Qt::Key_2, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_2);
+    QTest::keyRelease(&window, Qt::Key_2, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(intInput->text(), QLatin1String("1"));
     QCOMPARE(intInput->hasAcceptableInput(), false);
     QCOMPARE(intInput->property("acceptable").toBool(), false);
     QCOMPARE(intSpy.count(), 0);
-    QTest::keyPress(&canvas, Qt::Key_Period);
-    QTest::keyRelease(&canvas, Qt::Key_Period, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Period);
+    QTest::keyRelease(&window, Qt::Key_Period, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(intInput->text(), QLatin1String("1"));
     QCOMPARE(intInput->hasAcceptableInput(), false);
-    QTest::keyPress(&canvas, Qt::Key_Comma);
-    QTest::keyRelease(&canvas, Qt::Key_Comma, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Comma);
+    QTest::keyRelease(&window, Qt::Key_Comma, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(intInput->text(), QLatin1String("1,"));
     QCOMPARE(intInput->hasAcceptableInput(), false);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(intInput->text(), QLatin1String("1"));
     QCOMPARE(intInput->hasAcceptableInput(), false);
     intValidator->setLocaleName(deLocale.name());
-    QTest::keyPress(&canvas, Qt::Key_Period);
-    QTest::keyRelease(&canvas, Qt::Key_Period, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Period);
+    QTest::keyRelease(&window, Qt::Key_Period, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(intInput->text(), QLatin1String("1."));
     QCOMPARE(intInput->hasAcceptableInput(), false);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(intInput->text(), QLatin1String("1"));
     QCOMPARE(intInput->hasAcceptableInput(), false);
     intValidator->resetLocaleName();
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QCOMPARE(intInput->text(), QLatin1String("11"));
     QCOMPARE(intInput->hasAcceptableInput(), true);
     QCOMPARE(intInput->property("acceptable").toBool(), true);
     QCOMPARE(intSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_0);
-    QTest::keyRelease(&canvas, Qt::Key_0, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_0);
+    QTest::keyRelease(&window, Qt::Key_0, Qt::NoModifier ,10);
     QTest::qWait(50);
     QCOMPARE(intInput->text(), QLatin1String("11"));
     QCOMPARE(intInput->hasAcceptableInput(), true);
     QCOMPARE(intInput->property("acceptable").toBool(), true);
     QCOMPARE(intSpy.count(), 1);
 
-    QQuickTextInput *dblInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("dblInput")));
+    QQuickTextInput *dblInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("dblInput")));
     QVERIFY(dblInput);
     QSignalSpy dblSpy(dblInput, SIGNAL(acceptableInputChanged()));
 
@@ -1892,81 +1892,81 @@ void tst_qquicktextinput::validators()
     QVERIFY(dblInput->hasActiveFocus() == true);
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("1"));
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
     QCOMPARE(dblSpy.count(), 0);
-    QTest::keyPress(&canvas, Qt::Key_2);
-    QTest::keyRelease(&canvas, Qt::Key_2, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_2);
+    QTest::keyRelease(&window, Qt::Key_2, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
     QCOMPARE(dblInput->property("acceptable").toBool(), true);
     QCOMPARE(dblSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_Comma);
-    QTest::keyRelease(&canvas, Qt::Key_Comma, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Comma);
+    QTest::keyRelease(&window, Qt::Key_Comma, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12,"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12,"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
     dblValidator->setLocaleName(deLocale.name());
     QCOMPARE(dblInput->hasAcceptableInput(), true);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12,1"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12,11"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12,1"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12,"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
     dblValidator->resetLocaleName();
-    QTest::keyPress(&canvas, Qt::Key_Period);
-    QTest::keyRelease(&canvas, Qt::Key_Period, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Period);
+    QTest::keyRelease(&window, Qt::Key_Period, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12."));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
     QCOMPARE(dblInput->property("acceptable").toBool(), true);
     QCOMPARE(dblSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12.1"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
     QCOMPARE(dblInput->property("acceptable").toBool(), true);
     QCOMPARE(dblSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12.11"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
     QCOMPARE(dblInput->property("acceptable").toBool(), true);
     QCOMPARE(dblSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12.11"));
     QCOMPARE(dblInput->hasAcceptableInput(), true);
@@ -1979,50 +1979,50 @@ void tst_qquicktextinput::validators()
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
     QCOMPARE(dblSpy.count(), 2);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12.1"));
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
     QCOMPARE(dblSpy.count(), 2);
     // Once unacceptable input is in anything goes until it reaches an acceptable state again.
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12.11"));
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblSpy.count(), 2);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12.1"));
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
     QCOMPARE(dblSpy.count(), 2);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12."));
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
     QCOMPARE(dblSpy.count(), 2);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("12"));
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
     QCOMPARE(dblSpy.count(), 2);
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
-    QTest::keyRelease(&canvas, Qt::Key_Backspace, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_Backspace);
+    QTest::keyRelease(&window, Qt::Key_Backspace, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(dblInput->text(), QLatin1String("1"));
     QCOMPARE(dblInput->hasAcceptableInput(), false);
     QCOMPARE(dblInput->property("acceptable").toBool(), false);
     QCOMPARE(dblSpy.count(), 2);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QCOMPARE(dblInput->text(), QLatin1String("11"));
     QCOMPARE(dblInput->property("acceptable").toBool(), true);
@@ -2039,72 +2039,72 @@ void tst_qquicktextinput::validators()
     QCOMPARE(dblInput->hasAcceptableInput(), true);
     QCOMPARE(dblSpy.count(), 5);
 
-    QQuickTextInput *strInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("strInput")));
+    QQuickTextInput *strInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("strInput")));
     QVERIFY(strInput);
     QSignalSpy strSpy(strInput, SIGNAL(acceptableInputChanged()));
     strInput->setFocus(true);
     QVERIFY(strInput->hasActiveFocus() == true);
     QCOMPARE(strInput->hasAcceptableInput(), false);
     QCOMPARE(strInput->property("acceptable").toBool(), false);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(strInput->text(), QLatin1String(""));
     QCOMPARE(strInput->hasAcceptableInput(), false);
     QCOMPARE(strInput->property("acceptable").toBool(), false);
     QCOMPARE(strSpy.count(), 0);
-    QTest::keyPress(&canvas, Qt::Key_A);
-    QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_A);
+    QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(strInput->text(), QLatin1String("a"));
     QCOMPARE(strInput->hasAcceptableInput(), false);
     QCOMPARE(strInput->property("acceptable").toBool(), false);
     QCOMPARE(strSpy.count(), 0);
-    QTest::keyPress(&canvas, Qt::Key_A);
-    QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_A);
+    QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(strInput->text(), QLatin1String("aa"));
     QCOMPARE(strInput->hasAcceptableInput(), true);
     QCOMPARE(strInput->property("acceptable").toBool(), true);
     QCOMPARE(strSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_A);
-    QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_A);
+    QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(strInput->text(), QLatin1String("aaa"));
     QCOMPARE(strInput->hasAcceptableInput(), true);
     QCOMPARE(strInput->property("acceptable").toBool(), true);
     QCOMPARE(strSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_A);
-    QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_A);
+    QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(strInput->text(), QLatin1String("aaaa"));
     QCOMPARE(strInput->hasAcceptableInput(), true);
     QCOMPARE(strInput->property("acceptable").toBool(), true);
     QCOMPARE(strSpy.count(), 1);
-    QTest::keyPress(&canvas, Qt::Key_A);
-    QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_A);
+    QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(strInput->text(), QLatin1String("aaaa"));
     QCOMPARE(strInput->hasAcceptableInput(), true);
     QCOMPARE(strInput->property("acceptable").toBool(), true);
     QCOMPARE(strSpy.count(), 1);
 
-    QQuickTextInput *unvalidatedInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("unvalidatedInput")));
+    QQuickTextInput *unvalidatedInput = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("unvalidatedInput")));
     QVERIFY(unvalidatedInput);
     QSignalSpy unvalidatedSpy(unvalidatedInput, SIGNAL(acceptableInputChanged()));
     unvalidatedInput->setFocus(true);
     QVERIFY(unvalidatedInput->hasActiveFocus() == true);
     QCOMPARE(unvalidatedInput->hasAcceptableInput(), true);
     QCOMPARE(unvalidatedInput->property("acceptable").toBool(), true);
-    QTest::keyPress(&canvas, Qt::Key_1);
-    QTest::keyRelease(&canvas, Qt::Key_1, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_1);
+    QTest::keyRelease(&window, Qt::Key_1, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(unvalidatedInput->text(), QLatin1String("1"));
     QCOMPARE(unvalidatedInput->hasAcceptableInput(), true);
     QCOMPARE(unvalidatedInput->property("acceptable").toBool(), true);
     QCOMPARE(unvalidatedSpy.count(), 0);
-    QTest::keyPress(&canvas, Qt::Key_A);
-    QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_A);
+    QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
     QTest::qWait(50);
     QTRY_COMPARE(unvalidatedInput->text(), QLatin1String("1a"));
     QCOMPARE(unvalidatedInput->hasAcceptableInput(), true);
@@ -2114,14 +2114,14 @@ void tst_qquicktextinput::validators()
 
 void tst_qquicktextinput::inputMethods()
 {
-    QQuickView canvas(testFileUrl("inputmethods.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("inputmethods.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
     // test input method hints
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(canvas.rootObject());
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(window.rootObject());
     QVERIFY(input != 0);
     QVERIFY(input->inputMethodHints() & Qt::ImhNoPredictiveText);
     QSignalSpy inputMethodHintSpy(input, SIGNAL(inputMethodHintsChanged()));
@@ -2186,62 +2186,62 @@ the extent of the text, then they should ignore the keys.
 */
 void tst_qquicktextinput::navigation()
 {
-    QQuickView canvas(testFileUrl("navigation.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
+    QQuickView window(testFileUrl("navigation.qml"));
+    window.show();
+    window.requestActivateWindow();
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
 
     QVERIFY(input != 0);
     input->setCursorPosition(0);
     QTRY_VERIFY(input->hasActiveFocus() == true);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == false);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == true);
     //QT-2944: If text is selected, ensure we deselect upon cursor motion
     input->setCursorPosition(input->text().length());
     input->select(0,input->text().length());
     QVERIFY(input->selectionStart() != input->selectionEnd());
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->selectionStart() == input->selectionEnd());
     QVERIFY(input->selectionStart() == input->text().length());
     QVERIFY(input->hasActiveFocus() == true);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == false);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == true);
 
     // Up and Down should NOT do Home/End, even on Mac OS X (QTBUG-10438).
     input->setCursorPosition(2);
     QCOMPARE(input->cursorPosition(),2);
-    simulateKey(&canvas, Qt::Key_Up);
+    simulateKey(&window, Qt::Key_Up);
     QCOMPARE(input->cursorPosition(),2);
-    simulateKey(&canvas, Qt::Key_Down);
+    simulateKey(&window, Qt::Key_Down);
     QCOMPARE(input->cursorPosition(),2);
 
     // Test left and right navigation works if the TextInput is empty (QTBUG-25447).
     input->setText(QString());
     QCOMPARE(input->cursorPosition(), 0);
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QCOMPARE(input->hasActiveFocus(), false);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QCOMPARE(input->hasActiveFocus(), true);
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QCOMPARE(input->hasActiveFocus(), false);
 }
 
 void tst_qquicktextinput::navigation_RTL()
 {
-    QQuickView canvas(testFileUrl("navigation.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
+    QQuickView window(testFileUrl("navigation.qml"));
+    window.show();
+    window.requestActivateWindow();
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
 
     QVERIFY(input != 0);
     const quint16 arabic_str[] = { 0x0638, 0x0643, 0x00646, 0x0647, 0x0633, 0x0638, 0x0643, 0x00646, 0x0647, 0x0633, 0x0647};
@@ -2251,22 +2251,22 @@ void tst_qquicktextinput::navigation_RTL()
     QTRY_VERIFY(input->hasActiveFocus() == true);
 
     // move off
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == false);
 
     // move back
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == true);
 
     input->setCursorPosition(input->text().length());
     QVERIFY(input->hasActiveFocus() == true);
 
     // move off
-    simulateKey(&canvas, Qt::Key_Left);
+    simulateKey(&window, Qt::Key_Left);
     QVERIFY(input->hasActiveFocus() == false);
 
     // move back
-    simulateKey(&canvas, Qt::Key_Right);
+    simulateKey(&window, Qt::Key_Right);
     QVERIFY(input->hasActiveFocus() == true);
 }
 
@@ -2371,30 +2371,30 @@ void tst_qquicktextinput::copyAndPasteKeySequence() {
     QQuickTextInput *textInput = qobject_cast<QQuickTextInput*>(textInputComponent.create());
     QVERIFY(textInput != 0);
 
-    QQuickCanvas canvas;
-    textInput->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textInput->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
     // copy and paste
     QVERIFY(textInput->hasActiveFocus());
     QCOMPARE(textInput->text().length(), 12);
     textInput->select(0, textInput->text().length());
-    simulateKeys(&canvas, QKeySequence::Copy);
+    simulateKeys(&window, QKeySequence::Copy);
     QCOMPARE(textInput->selectedText(), QString("Hello world!"));
     QCOMPARE(textInput->selectedText().length(), 12);
     textInput->setCursorPosition(0);
     QVERIFY(textInput->canPaste());
-    simulateKeys(&canvas, QKeySequence::Paste);
+    simulateKeys(&window, QKeySequence::Paste);
     QCOMPARE(textInput->text(), QString("Hello world!Hello world!"));
     QCOMPARE(textInput->text().length(), 24);
 
     // select all and cut
-    simulateKeys(&canvas, QKeySequence::SelectAll);
-    simulateKeys(&canvas, QKeySequence::Cut);
+    simulateKeys(&window, QKeySequence::SelectAll);
+    simulateKeys(&window, QKeySequence::Cut);
     QCOMPARE(textInput->text().length(), 0);
-    simulateKeys(&canvas, QKeySequence::Paste);
+    simulateKeys(&window, QKeySequence::Paste);
     QCOMPARE(textInput->text(), QString("Hello world!Hello world!"));
     QCOMPARE(textInput->text().length(), 24);
 
@@ -2412,7 +2412,7 @@ void tst_qquicktextinput::copyAndPasteKeySequence() {
         textInput->setEchoMode(echoMode);
         textInput->setText("My password");
         textInput->select(0, textInput->text().length());
-        simulateKeys(&canvas, QKeySequence::Copy);
+        simulateKeys(&window, QKeySequence::Copy);
         if (echoMode == QQuickTextInput::Normal) {
             QVERIFY(!clipboard->text().isEmpty());
             QCOMPARE(clipboard->text(), QString("My password"));
@@ -2919,23 +2919,23 @@ void tst_qquicktextinput::cursorRectangle()
 
 void tst_qquicktextinput::readOnly()
 {
-    QQuickView canvas(testFileUrl("readOnly.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
+    QQuickView window(testFileUrl("readOnly.qml"));
+    window.show();
+    window.requestActivateWindow();
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
 
     QVERIFY(input != 0);
     QTRY_VERIFY(input->hasActiveFocus() == true);
     QVERIFY(input->isReadOnly() == true);
     QString initial = input->text();
     for (int k=Qt::Key_0; k<=Qt::Key_Z; k++)
-        simulateKey(&canvas, k);
-    simulateKey(&canvas, Qt::Key_Return);
-    simulateKey(&canvas, Qt::Key_Space);
-    simulateKey(&canvas, Qt::Key_Escape);
+        simulateKey(&window, k);
+    simulateKey(&window, Qt::Key_Return);
+    simulateKey(&window, Qt::Key_Space);
+    simulateKey(&window, Qt::Key_Escape);
     QCOMPARE(input->text(), initial);
 
     input->setCursorPosition(3);
@@ -2946,14 +2946,14 @@ void tst_qquicktextinput::readOnly()
 
 void tst_qquicktextinput::echoMode()
 {
-    QQuickView canvas(testFileUrl("echoMode.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("echoMode.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
 
     QVERIFY(input != 0);
     QTRY_VERIFY(input->hasActiveFocus() == true);
@@ -2996,8 +2996,8 @@ void tst_qquicktextinput::echoMode()
     QCOMPARE(input->text(), initial);
     QCOMPARE(input->displayText(), QLatin1String("QQQQQQQQ"));
     QCOMPARE(input->inputMethodQuery(Qt::ImSurroundingText).toString(), QLatin1String("QQQQQQQQ"));
-    QTest::keyPress(&canvas, Qt::Key_A);//Clearing previous entry is part of PasswordEchoOnEdit
-    QTest::keyRelease(&canvas, Qt::Key_A, Qt::NoModifier ,10);
+    QTest::keyPress(&window, Qt::Key_A);//Clearing previous entry is part of PasswordEchoOnEdit
+    QTest::keyRelease(&window, Qt::Key_A, Qt::NoModifier ,10);
     QCOMPARE(input->text(), QLatin1String("a"));
     QCOMPARE(input->displayText(), QLatin1String("a"));
     QCOMPARE(input->inputMethodQuery(Qt::ImSurroundingText).toString(), QLatin1String("a"));
@@ -3020,14 +3020,14 @@ void tst_qquicktextinput::passwordEchoDelay()
     int maskDelay = qGuiApp->styleHints()->passwordMaskDelay();
     if (maskDelay <= 0)
         QSKIP("No mask delay in use");
-    QQuickView canvas(testFileUrl("echoMode.qml"));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickView window(testFileUrl("echoMode.qml"));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
-    QVERIFY(canvas.rootObject() != 0);
+    QVERIFY(window.rootObject() != 0);
 
-    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(canvas.rootObject()->property("myInput")));
+    QQuickTextInput *input = qobject_cast<QQuickTextInput *>(qvariant_cast<QObject *>(window.rootObject()->property("myInput")));
     QVERIFY(input);
     QVERIFY(input->hasActiveFocus());
 
@@ -3041,16 +3041,16 @@ void tst_qquicktextinput::passwordEchoDelay()
     input->setText(QString());
     QCOMPARE(input->displayText(), QString());
 
-    QTest::keyPress(&canvas, '0');
-    QTest::keyPress(&canvas, '1');
-    QTest::keyPress(&canvas, '2');
+    QTest::keyPress(&window, '0');
+    QTest::keyPress(&window, '1');
+    QTest::keyPress(&window, '2');
     QCOMPARE(input->displayText(), QString(2, fillChar) + QLatin1Char('2'));
-    QTest::keyPress(&canvas, '3');
-    QTest::keyPress(&canvas, '4');
+    QTest::keyPress(&window, '3');
+    QTest::keyPress(&window, '4');
     QCOMPARE(input->displayText(), QString(4, fillChar) + QLatin1Char('4'));
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
+    QTest::keyPress(&window, Qt::Key_Backspace);
     QCOMPARE(input->displayText(), QString(4, fillChar));
-    QTest::keyPress(&canvas, '4');
+    QTest::keyPress(&window, '4');
     QCOMPARE(input->displayText(), QString(4, fillChar) + QLatin1Char('4'));
     QCOMPARE(input->cursorRectangle().topLeft(), cursor->pos());
 
@@ -3063,7 +3063,7 @@ void tst_qquicktextinput::passwordEchoDelay()
     QCOMPARE(cursorSpy.count(), 1);
     QCOMPARE(input->cursorRectangle().topLeft(), cursor->pos());
 
-    QTest::keyPress(&canvas, '5');
+    QTest::keyPress(&window, '5');
     QCOMPARE(input->displayText(), QString(5, fillChar) + QLatin1Char('5'));
     input->setFocus(false);
     QVERIFY(!input->hasFocus());
@@ -3071,7 +3071,7 @@ void tst_qquicktextinput::passwordEchoDelay()
     input->setFocus(true);
     QTRY_VERIFY(input->hasFocus());
     QCOMPARE(input->displayText(), QString(6, fillChar));
-    QTest::keyPress(&canvas, '6');
+    QTest::keyPress(&window, '6');
     QCOMPARE(input->displayText(), QString(6, fillChar) + QLatin1Char('6'));
 
     QInputMethodEvent ev;
@@ -3081,9 +3081,9 @@ void tst_qquicktextinput::passwordEchoDelay()
 
     input->setCursorPosition(3);
     QCOMPARE(input->displayText(), QString(7, fillChar) + QLatin1Char('7'));
-    QTest::keyPress(&canvas, 'a');
+    QTest::keyPress(&window, 'a');
     QCOMPARE(input->displayText(), QString(3, fillChar) + QLatin1Char('a') + QString(5, fillChar));
-    QTest::keyPress(&canvas, Qt::Key_Backspace);
+    QTest::keyPress(&window, Qt::Key_Backspace);
     QCOMPARE(input->displayText(), QString(8, fillChar));
 }
 
@@ -3124,26 +3124,26 @@ void tst_qquicktextinput::focusOnPress()
     QCOMPARE(textInputObject->focusOnPress(), true);
     QCOMPARE(activeFocusOnPressSpy.count(), 0);
 
-    QQuickCanvas canvas;
-    canvas.resize(100, 50);
-    textInputObject->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    window.resize(100, 50);
+    textInputObject->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
     QCOMPARE(textInputObject->hasFocus(), false);
     QCOMPARE(textInputObject->hasActiveFocus(), false);
 
-    QPoint centerPoint(canvas.width()/2, canvas.height()/2);
+    QPoint centerPoint(window.width()/2, window.height()/2);
     Qt::KeyboardModifiers noModifiers = 0;
-    QTest::mousePress(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mousePress(&window, Qt::LeftButton, noModifiers, centerPoint);
     QGuiApplication::processEvents();
     QCOMPARE(textInputObject->hasFocus(), true);
     QCOMPARE(textInputObject->hasActiveFocus(), true);
     QCOMPARE(focusSpy.count(), 1);
     QCOMPARE(activeFocusSpy.count(), 1);
     QCOMPARE(textInputObject->selectedText(), QString());
-    QTest::mouseRelease(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mouseRelease(&window, Qt::LeftButton, noModifiers, centerPoint);
 
     textInputObject->setFocusOnPress(false);
     QCOMPARE(textInputObject->focusOnPress(), false);
@@ -3157,13 +3157,13 @@ void tst_qquicktextinput::focusOnPress()
 
     // Wait for double click timeout to expire before clicking again.
     QTest::qWait(400);
-    QTest::mousePress(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mousePress(&window, Qt::LeftButton, noModifiers, centerPoint);
     QGuiApplication::processEvents();
     QCOMPARE(textInputObject->hasFocus(), false);
     QCOMPARE(textInputObject->hasActiveFocus(), false);
     QCOMPARE(focusSpy.count(), 2);
     QCOMPARE(activeFocusSpy.count(), 2);
-    QTest::mouseRelease(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mouseRelease(&window, Qt::LeftButton, noModifiers, centerPoint);
 
     textInputObject->setFocusOnPress(true);
     QCOMPARE(textInputObject->focusOnPress(), true);
@@ -3173,14 +3173,14 @@ void tst_qquicktextinput::focusOnPress()
     textInputObject->setProperty("selectOnFocus", true);
 
     QTest::qWait(400);
-    QTest::mousePress(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mousePress(&window, Qt::LeftButton, noModifiers, centerPoint);
     QGuiApplication::processEvents();
     QCOMPARE(textInputObject->hasFocus(), true);
     QCOMPARE(textInputObject->hasActiveFocus(), true);
     QCOMPARE(focusSpy.count(), 3);
     QCOMPARE(activeFocusSpy.count(), 3);
     QCOMPARE(textInputObject->selectedText(), textInputObject->text());
-    QTest::mouseRelease(&canvas, Qt::LeftButton, noModifiers, centerPoint);
+    QTest::mouseRelease(&window, Qt::LeftButton, noModifiers, centerPoint);
 }
 
 void tst_qquicktextinput::openInputPanel()
@@ -3763,9 +3763,9 @@ void tst_qquicktextinput::inputMethodUpdate()
 
 void tst_qquicktextinput::cursorRectangleSize()
 {
-    QQuickView *canvas = new QQuickView(testFileUrl("positionAt.qml"));
-    QVERIFY(canvas->rootObject() != 0);
-    QQuickTextInput *textInput = qobject_cast<QQuickTextInput *>(canvas->rootObject());
+    QQuickView *window = new QQuickView(testFileUrl("positionAt.qml"));
+    QVERIFY(window->rootObject() != 0);
+    QQuickTextInput *textInput = qobject_cast<QQuickTextInput *>(window->rootObject());
 
     // make sure cursor rectangle is not at (0,0)
     textInput->setX(10);
@@ -3773,9 +3773,9 @@ void tst_qquicktextinput::cursorRectangleSize()
     textInput->setCursorPosition(3);
     QVERIFY(textInput != 0);
     textInput->setFocus(true);
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowActive(canvas);
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowActive(window);
     QVERIFY(textInput->hasActiveFocus());
 
     QInputMethodQueryEvent event(Qt::ImCursorRectangle);
@@ -3791,14 +3791,14 @@ void tst_qquicktextinput::cursorRectangleSize()
     // item cursor rectangle and positionToRectangle calculations match
     QCOMPARE(cursorRectFromItem, cursorRectFromPositionToRectangle);
 
-    // item-canvas transform and input item transform match
-    QCOMPARE(QQuickItemPrivate::get(textInput)->itemToCanvasTransform(), qApp->inputMethod()->inputItemTransform());
+    // item-window transform and input item transform match
+    QCOMPARE(QQuickItemPrivate::get(textInput)->itemToWindowTransform(), qApp->inputMethod()->inputItemTransform());
 
     // input panel cursorRectangle property and tranformed item cursor rectangle match
-    QRectF sceneCursorRect = QQuickItemPrivate::get(textInput)->itemToCanvasTransform().mapRect(cursorRectFromItem);
+    QRectF sceneCursorRect = QQuickItemPrivate::get(textInput)->itemToWindowTransform().mapRect(cursorRectFromItem);
     QCOMPARE(sceneCursorRect, qApp->inputMethod()->cursorRectangle());
 
-    delete canvas;
+    delete window;
 }
 
 void tst_qquicktextinput::tripleClickSelectsAll()
@@ -4795,18 +4795,18 @@ void tst_qquicktextinput::keySequence()
     QVERIFY(textInput != 0);
     textInput->setEchoMode(echoMode);
 
-    QQuickCanvas canvas;
-    textInput->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textInput->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textInput->hasActiveFocus());
 
-    simulateKey(&canvas, layoutDirection);
+    simulateKey(&window, layoutDirection);
 
     textInput->select(selectionStart, selectionEnd);
 
-    simulateKeys(&canvas, sequence);
+    simulateKeys(&window, sequence);
 
     QCOMPARE(textInput->cursorPosition(), cursorPosition);
     QCOMPARE(textInput->text(), expectedText);
@@ -4956,11 +4956,11 @@ void tst_qquicktextinput::undo()
     QQuickTextInput *textInput = qobject_cast<QQuickTextInput*>(textInputComponent.create());
     QVERIFY(textInput != 0);
 
-    QQuickCanvas canvas;
-    textInput->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textInput->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textInput->hasActiveFocus());
 
     QVERIFY(!textInput->canUndo());
@@ -4983,7 +4983,7 @@ void tst_qquicktextinput::undo()
         }
 
         for (int j = 0; j < insertString.at(i).length(); j++)
-            QTest::keyClick(&canvas, insertString.at(i).at(j).toLatin1());
+            QTest::keyClick(&window, insertString.at(i).at(j).toLatin1());
     }
 
     QCOMPARE(spy.count(), 1);
@@ -5042,11 +5042,11 @@ void tst_qquicktextinput::redo()
     QQuickTextInput *textInput = qobject_cast<QQuickTextInput*>(textInputComponent.create());
     QVERIFY(textInput != 0);
 
-    QQuickCanvas canvas;
-    textInput->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textInput->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
 
     QVERIFY(textInput->hasActiveFocus());
     QVERIFY(!textInput->canUndo());
@@ -5060,7 +5060,7 @@ void tst_qquicktextinput::redo()
         if (insertIndex[i] > -1)
             textInput->setCursorPosition(insertIndex[i]);
         for (int j = 0; j < insertString.at(i).length(); j++)
-            QTest::keyClick(&canvas, insertString.at(i).at(j).toLatin1());
+            QTest::keyClick(&window, insertString.at(i).at(j).toLatin1());
         QVERIFY(textInput->canUndo());
         QVERIFY(!textInput->canRedo());
     }
@@ -5244,14 +5244,14 @@ void tst_qquicktextinput::undo_keypressevents()
     QQuickTextInput *textInput = qobject_cast<QQuickTextInput*>(textInputComponent.create());
     QVERIFY(textInput != 0);
 
-    QQuickCanvas canvas;
-    textInput->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textInput->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textInput->hasActiveFocus());
 
-    simulateKeys(&canvas, keys);
+    simulateKeys(&window, keys);
 
     for (int i = 0; i < expectedString.size(); ++i) {
         QCOMPARE(textInput->text() , expectedString[i]);
@@ -5264,36 +5264,36 @@ void tst_qquicktextinput::QTBUG_19956()
 {
     QFETCH(QString, url);
 
-    QQuickView canvas(testFileUrl(url));
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextInput *input = qobject_cast<QQuickTextInput*>(canvas.rootObject());
+    QQuickView window(testFileUrl(url));
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextInput *input = qobject_cast<QQuickTextInput*>(window.rootObject());
     QVERIFY(input);
     input->setFocus(true);
     QVERIFY(input->hasActiveFocus());
 
-    QCOMPARE(canvas.rootObject()->property("topvalue").toInt(), 30);
-    QCOMPARE(canvas.rootObject()->property("bottomvalue").toInt(), 10);
-    QCOMPARE(canvas.rootObject()->property("text").toString(), QString("20"));
-    QVERIFY(canvas.rootObject()->property("acceptableInput").toBool());
+    QCOMPARE(window.rootObject()->property("topvalue").toInt(), 30);
+    QCOMPARE(window.rootObject()->property("bottomvalue").toInt(), 10);
+    QCOMPARE(window.rootObject()->property("text").toString(), QString("20"));
+    QVERIFY(window.rootObject()->property("acceptableInput").toBool());
 
-    canvas.rootObject()->setProperty("topvalue", 15);
-    QCOMPARE(canvas.rootObject()->property("topvalue").toInt(), 15);
-    QVERIFY(!canvas.rootObject()->property("acceptableInput").toBool());
+    window.rootObject()->setProperty("topvalue", 15);
+    QCOMPARE(window.rootObject()->property("topvalue").toInt(), 15);
+    QVERIFY(!window.rootObject()->property("acceptableInput").toBool());
 
-    canvas.rootObject()->setProperty("topvalue", 25);
-    QCOMPARE(canvas.rootObject()->property("topvalue").toInt(), 25);
-    QVERIFY(canvas.rootObject()->property("acceptableInput").toBool());
+    window.rootObject()->setProperty("topvalue", 25);
+    QCOMPARE(window.rootObject()->property("topvalue").toInt(), 25);
+    QVERIFY(window.rootObject()->property("acceptableInput").toBool());
 
-    canvas.rootObject()->setProperty("bottomvalue", 21);
-    QCOMPARE(canvas.rootObject()->property("bottomvalue").toInt(), 21);
-    QVERIFY(!canvas.rootObject()->property("acceptableInput").toBool());
+    window.rootObject()->setProperty("bottomvalue", 21);
+    QCOMPARE(window.rootObject()->property("bottomvalue").toInt(), 21);
+    QVERIFY(!window.rootObject()->property("acceptableInput").toBool());
 
-    canvas.rootObject()->setProperty("bottomvalue", 10);
-    QCOMPARE(canvas.rootObject()->property("bottomvalue").toInt(), 10);
-    QVERIFY(canvas.rootObject()->property("acceptableInput").toBool());
+    window.rootObject()->setProperty("bottomvalue", 10);
+    QCOMPARE(window.rootObject()->property("bottomvalue").toInt(), 10);
+    QVERIFY(window.rootObject()->property("acceptableInput").toBool());
 }
 
 void tst_qquicktextinput::QTBUG_19956_regexp()
@@ -5303,28 +5303,28 @@ void tst_qquicktextinput::QTBUG_19956_regexp()
     QString warning = url.toString() + ":11: Unable to assign [undefined] to QRegExp";
     QTest::ignoreMessage(QtWarningMsg, qPrintable(warning));
 
-    QQuickView canvas(url);
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
-    QVERIFY(canvas.rootObject() != 0);
-    QQuickTextInput *input = qobject_cast<QQuickTextInput*>(canvas.rootObject());
+    QQuickView window(url);
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
+    QVERIFY(window.rootObject() != 0);
+    QQuickTextInput *input = qobject_cast<QQuickTextInput*>(window.rootObject());
     QVERIFY(input);
     input->setFocus(true);
     QVERIFY(input->hasActiveFocus());
 
-    canvas.rootObject()->setProperty("regexvalue", QRegExp("abc"));
-    QCOMPARE(canvas.rootObject()->property("regexvalue").toRegExp(), QRegExp("abc"));
-    QCOMPARE(canvas.rootObject()->property("text").toString(), QString("abc"));
-    QVERIFY(canvas.rootObject()->property("acceptableInput").toBool());
+    window.rootObject()->setProperty("regexvalue", QRegExp("abc"));
+    QCOMPARE(window.rootObject()->property("regexvalue").toRegExp(), QRegExp("abc"));
+    QCOMPARE(window.rootObject()->property("text").toString(), QString("abc"));
+    QVERIFY(window.rootObject()->property("acceptableInput").toBool());
 
-    canvas.rootObject()->setProperty("regexvalue", QRegExp("abcd"));
-    QCOMPARE(canvas.rootObject()->property("regexvalue").toRegExp(), QRegExp("abcd"));
-    QVERIFY(!canvas.rootObject()->property("acceptableInput").toBool());
+    window.rootObject()->setProperty("regexvalue", QRegExp("abcd"));
+    QCOMPARE(window.rootObject()->property("regexvalue").toRegExp(), QRegExp("abcd"));
+    QVERIFY(!window.rootObject()->property("acceptableInput").toBool());
 
-    canvas.rootObject()->setProperty("regexvalue", QRegExp("abc"));
-    QCOMPARE(canvas.rootObject()->property("regexvalue").toRegExp(), QRegExp("abc"));
-    QVERIFY(canvas.rootObject()->property("acceptableInput").toBool());
+    window.rootObject()->setProperty("regexvalue", QRegExp("abc"));
+    QCOMPARE(window.rootObject()->property("regexvalue").toRegExp(), QRegExp("abc"));
+    QVERIFY(window.rootObject()->property("acceptableInput").toBool());
 }
 
 void tst_qquicktextinput::implicitSize_data()
@@ -5614,16 +5614,16 @@ void tst_qquicktextinput::setInputMask()
     if (insert_text) {
         textInput->insert(0, input);
     } else {
-        QQuickCanvas canvas;
-        textInput->setParentItem(canvas.rootItem());
-        canvas.show();
-        canvas.requestActivateWindow();
-        QTest::qWaitForWindowActive(&canvas);
+        QQuickWindow window;
+        textInput->setParentItem(window.rootItem());
+        window.show();
+        window.requestActivateWindow();
+        QTest::qWaitForWindowActive(&window);
         QVERIFY(textInput->hasActiveFocus());
 
-        simulateKey(&canvas, Qt::Key_Home);
+        simulateKey(&window, Qt::Key_Home);
         for (int i = 0; i < input.length(); i++)
-            QTest::keyClick(&canvas, input.at(i).toLatin1());
+            QTest::keyClick(&window, input.at(i).toLatin1());
     }
 
     QEXPECT_FAIL( "keys blank=input", "To eat blanks or not? Known issue. Task 43172", Abort);
@@ -5744,14 +5744,14 @@ void tst_qquicktextinput::keypress_inputMask()
     QQuickTextInput *textInput = qobject_cast<QQuickTextInput*>(textInputComponent.create());
     QVERIFY(textInput != 0);
 
-    QQuickCanvas canvas;
-    textInput->setParentItem(canvas.rootItem());
-    canvas.show();
-    canvas.requestActivateWindow();
-    QTest::qWaitForWindowActive(&canvas);
+    QQuickWindow window;
+    textInput->setParentItem(window.rootItem());
+    window.show();
+    window.requestActivateWindow();
+    QTest::qWaitForWindowActive(&window);
     QVERIFY(textInput->hasActiveFocus());
 
-    simulateKeys(&canvas, keys);
+    simulateKeys(&window, keys);
 
     QCOMPARE(textInput->text(), expectedText);
     QCOMPARE(textInput->displayText(), expectedDisplayText);
diff --git a/tests/auto/quick/qquickview/tst_qquickview.cpp b/tests/auto/quick/qquickview/tst_qquickview.cpp
index cb2f5c6..977b867 100644
--- a/tests/auto/quick/qquickview/tst_qquickview.cpp
+++ b/tests/auto/quick/qquickview/tst_qquickview.cpp
@@ -71,120 +71,120 @@ void tst_QQuickView::resizemodeitem()
     QWindow window;
     window.setGeometry(0, 0, 400, 400);
 
-    QQuickView *canvas = new QQuickView(&window);
-    QVERIFY(canvas);
-    canvas->setResizeMode(QQuickView::SizeRootObjectToView);
-    QCOMPARE(QSize(0,0), canvas->initialSize());
-    canvas->setSource(testFileUrl("resizemodeitem.qml"));
-    QQuickItem* item = qobject_cast<QQuickItem*>(canvas->rootObject());
+    QQuickView *view = new QQuickView(&window);
+    QVERIFY(view);
+    view->setResizeMode(QQuickView::SizeRootObjectToView);
+    QCOMPARE(QSize(0,0), view->initialSize());
+    view->setSource(testFileUrl("resizemodeitem.qml"));
+    QQuickItem* item = qobject_cast<QQuickItem*>(view->rootObject());
     QVERIFY(item);
     window.show();
 
-    canvas->show();
+    view->show();
 
     // initial size from root object
     QCOMPARE(item->width(), 200.0);
     QCOMPARE(item->height(), 200.0);
-    QCOMPARE(canvas->size(), QSize(200, 200));
-    QCOMPARE(canvas->size(), canvas->sizeHint());
-    QCOMPARE(canvas->size(), canvas->initialSize());
+    QCOMPARE(view->size(), QSize(200, 200));
+    QCOMPARE(view->size(), view->sizeHint());
+    QCOMPARE(view->size(), view->initialSize());
 
     // size update from view
-    canvas->resize(QSize(80,100));
+    view->resize(QSize(80,100));
 
     QTRY_COMPARE(item->width(), 80.0);
     QCOMPARE(item->height(), 100.0);
-    QCOMPARE(canvas->size(), QSize(80, 100));
-    QCOMPARE(canvas->size(), canvas->sizeHint());
+    QCOMPARE(view->size(), QSize(80, 100));
+    QCOMPARE(view->size(), view->sizeHint());
 
-    canvas->setResizeMode(QQuickView::SizeViewToRootObject);
+    view->setResizeMode(QQuickView::SizeViewToRootObject);
 
     // size update from view disabled
-    canvas->resize(QSize(60,80));
+    view->resize(QSize(60,80));
     QCOMPARE(item->width(), 80.0);
     QCOMPARE(item->height(), 100.0);
     QTest::qWait(50);
-    QCOMPARE(canvas->size(), QSize(60, 80));
+    QCOMPARE(view->size(), QSize(60, 80));
 
     // size update from root object
     item->setWidth(250);
     item->setHeight(350);
     QCOMPARE(item->width(), 250.0);
     QCOMPARE(item->height(), 350.0);
-    QTRY_COMPARE(canvas->size(), QSize(250, 350));
-    QCOMPARE(canvas->size(), QSize(250, 350));
-    QCOMPARE(canvas->size(), canvas->sizeHint());
+    QTRY_COMPARE(view->size(), QSize(250, 350));
+    QCOMPARE(view->size(), QSize(250, 350));
+    QCOMPARE(view->size(), view->sizeHint());
 
-    // reset canvas
+    // reset window
     window.hide();
-    delete canvas;
-    canvas = new QQuickView(&window);
-    QVERIFY(canvas);
-    canvas->setResizeMode(QQuickView::SizeViewToRootObject);
-    canvas->setSource(testFileUrl("resizemodeitem.qml"));
-    item = qobject_cast<QQuickItem*>(canvas->rootObject());
+    delete view;
+    view = new QQuickView(&window);
+    QVERIFY(view);
+    view->setResizeMode(QQuickView::SizeViewToRootObject);
+    view->setSource(testFileUrl("resizemodeitem.qml"));
+    item = qobject_cast<QQuickItem*>(view->rootObject());
     QVERIFY(item);
     window.show();
 
-    canvas->show();
+    view->show();
 
     // initial size for root object
     QCOMPARE(item->width(), 200.0);
     QCOMPARE(item->height(), 200.0);
-    QCOMPARE(canvas->size(), canvas->sizeHint());
-    QCOMPARE(canvas->size(), canvas->initialSize());
+    QCOMPARE(view->size(), view->sizeHint());
+    QCOMPARE(view->size(), view->initialSize());
 
     // size update from root object
     item->setWidth(80);
     item->setHeight(100);
     QCOMPARE(item->width(), 80.0);
     QCOMPARE(item->height(), 100.0);
-    QTRY_COMPARE(canvas->size(), QSize(80, 100));
-    QCOMPARE(canvas->size(), QSize(80, 100));
-    QCOMPARE(canvas->size(), canvas->sizeHint());
+    QTRY_COMPARE(view->size(), QSize(80, 100));
+    QCOMPARE(view->size(), QSize(80, 100));
+    QCOMPARE(view->size(), view->sizeHint());
 
     // size update from root object disabled
-    canvas->setResizeMode(QQuickView::SizeRootObjectToView);
+    view->setResizeMode(QQuickView::SizeRootObjectToView);
     item->setWidth(60);
     item->setHeight(80);
-    QCOMPARE(canvas->width(), 80);
-    QCOMPARE(canvas->height(), 100);
-    QCOMPARE(QSize(item->width(), item->height()), canvas->sizeHint());
+    QCOMPARE(view->width(), 80);
+    QCOMPARE(view->height(), 100);
+    QCOMPARE(QSize(item->width(), item->height()), view->sizeHint());
 
     // size update from view
-    canvas->resize(QSize(200,300));
+    view->resize(QSize(200,300));
     QTest::qWait(50);
     QCOMPARE(item->width(), 200.0);
     QCOMPARE(item->height(), 300.0);
-    QCOMPARE(canvas->size(), QSize(200, 300));
-    QCOMPARE(canvas->size(), canvas->sizeHint());
+    QCOMPARE(view->size(), QSize(200, 300));
+    QCOMPARE(view->size(), view->sizeHint());
 
     window.hide();
-    delete canvas;
+    delete view;
 
     // if we set a specific size for the view then it should keep that size
     // for SizeRootObjectToView mode.
-    canvas = new QQuickView(&window);
-    canvas->resize(300, 300);
-    canvas->setResizeMode(QQuickView::SizeRootObjectToView);
-    QCOMPARE(QSize(0,0), canvas->initialSize());
-    canvas->setSource(testFileUrl("resizemodeitem.qml"));
-    canvas->resize(300, 300);
-    item = qobject_cast<QQuickItem*>(canvas->rootObject());
+    view = new QQuickView(&window);
+    view->resize(300, 300);
+    view->setResizeMode(QQuickView::SizeRootObjectToView);
+    QCOMPARE(QSize(0,0), view->initialSize());
+    view->setSource(testFileUrl("resizemodeitem.qml"));
+    view->resize(300, 300);
+    item = qobject_cast<QQuickItem*>(view->rootObject());
     QVERIFY(item);
     window.show();
 
-    canvas->show();
+    view->show();
     QTest::qWait(50);
 
     // initial size from root object
     QCOMPARE(item->width(), 300.0);
     QCOMPARE(item->height(), 300.0);
-    QCOMPARE(canvas->size(), QSize(300, 300));
-    QCOMPARE(canvas->size(), canvas->sizeHint());
-    QCOMPARE(canvas->initialSize(), QSize(200, 200)); // initial object size
+    QCOMPARE(view->size(), QSize(300, 300));
+    QCOMPARE(view->size(), view->sizeHint());
+    QCOMPARE(view->initialSize(), QSize(200, 200)); // initial object size
 
-    delete canvas;
+    delete view;
 }
 
 static void silentErrorsMsgHandler(QtMsgType, const char *)
@@ -193,14 +193,14 @@ static void silentErrorsMsgHandler(QtMsgType, const char *)
 
 void tst_QQuickView::errors()
 {
-    QQuickView *canvas = new QQuickView;
-    QVERIFY(canvas);
+    QQuickView *view = new QQuickView;
+    QVERIFY(view);
     QtMsgHandler old = qInstallMsgHandler(silentErrorsMsgHandler);
-    canvas->setSource(testFileUrl("error1.qml"));
+    view->setSource(testFileUrl("error1.qml"));
     qInstallMsgHandler(old);
-    QVERIFY(canvas->status() == QQuickView::Error);
-    QVERIFY(canvas->errors().count() == 1);
-    delete canvas;
+    QVERIFY(view->status() == QQuickView::Error);
+    QVERIFY(view->errors().count() == 1);
+    delete view;
 }
 
 void tst_QQuickView::engine()
@@ -208,36 +208,36 @@ void tst_QQuickView::engine()
     QQmlEngine *engine = new QQmlEngine;
     QVERIFY(!engine->incubationController());
 
-    QQuickView *canvas = new QQuickView(engine, 0);
-    QVERIFY(canvas);
-    QVERIFY(engine->incubationController() == canvas->incubationController());
+    QQuickView *view = new QQuickView(engine, 0);
+    QVERIFY(view);
+    QVERIFY(engine->incubationController() == view->incubationController());
 
-    QQuickView *canvas2 = new QQuickView(engine, 0);
-    QVERIFY(canvas);
-    QVERIFY(engine->incubationController() == canvas->incubationController());
-    delete canvas;
+    QQuickView *view2 = new QQuickView(engine, 0);
+    QVERIFY(view);
+    QVERIFY(engine->incubationController() == view->incubationController());
+    delete view;
     QVERIFY(!engine->incubationController());
 
-    engine->setIncubationController(canvas2->incubationController());
-    QVERIFY(engine->incubationController() == canvas2->incubationController());
-    delete canvas2;
+    engine->setIncubationController(view2->incubationController());
+    QVERIFY(engine->incubationController() == view2->incubationController());
+    delete view2;
     QVERIFY(!engine->incubationController());
 
-    QQuickView *canvas3 = new QQuickView;
-    QQuickView *canvas4 = new QQuickView(canvas3->engine(), 0);
+    QQuickView *view3 = new QQuickView;
+    QQuickView *view4 = new QQuickView(view3->engine(), 0);
 
-    QVERIFY(canvas3->engine());
-    QVERIFY(canvas4->engine());
-    QCOMPARE(canvas3->engine(), canvas4->engine());
-    delete canvas3;
-    QVERIFY(!canvas4->engine());
+    QVERIFY(view3->engine());
+    QVERIFY(view4->engine());
+    QCOMPARE(view3->engine(), view4->engine());
+    delete view3;
+    QVERIFY(!view4->engine());
     QTest::ignoreMessage(QtWarningMsg, "QQuickView: invalid qml engine. ");
-    canvas4->setSource(QUrl());
+    view4->setSource(QUrl());
 
-    QCOMPARE(canvas4->status(), QQuickView::Error);
-    QVERIFY(!canvas4->errors().isEmpty());
-    QCOMPARE(canvas4->errors().back().description(), QLatin1String("QQuickView: invalid qml engine."));
-    delete canvas4;
+    QCOMPARE(view4->status(), QQuickView::Error);
+    QVERIFY(!view4->errors().isEmpty());
+    QCOMPARE(view4->errors().back().description(), QLatin1String("QQuickView: invalid qml engine."));
+    delete view4;
 }
 
 QTEST_MAIN(tst_QQuickView)
diff --git a/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp b/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp
index 54871c1..2b04596 100644
--- a/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp
+++ b/tests/auto/quick/qquickvisualdatamodel/tst_qquickvisualdatamodel.cpp
@@ -2646,14 +2646,14 @@ void tst_qquickvisualdatamodel::insert()
     QFETCH(QString, property);
     QFETCH(QStringList, propertyData);
 
-    QQuickCanvas canvas;
+    QQuickWindow window;
 
     QQmlComponent component(&engine);
     component.loadUrl(source);
     QScopedPointer<QObject> object(component.create());
     QQuickListView *listView = qobject_cast<QQuickListView *>(object.data());
     QVERIFY(listView);
-    listView->setParentItem(canvas.rootItem());
+    listView->setParentItem(window.rootItem());
 
     QQuickItem *contentItem = listView->contentItem();
     QVERIFY(contentItem);
@@ -3110,14 +3110,14 @@ void tst_qquickvisualdatamodel::resolve()
     QFETCH(QString, property);
     QFETCH(QStringList, propertyData);
 
-    QQuickCanvas canvas;
+    QQuickWindow window;
 
     QQmlComponent component(&engine);
     component.loadUrl(source);
     QScopedPointer<QObject> object(component.create());
     QQuickListView *listView = qobject_cast<QQuickListView *>(object.data());
     QVERIFY(listView);
-    listView->setParentItem(canvas.rootItem());
+    listView->setParentItem(window.rootItem());
 
     QQuickItem *contentItem = listView->contentItem();
     QVERIFY(contentItem);
@@ -3510,14 +3510,14 @@ void tst_qquickvisualdatamodel::warnings()
     QFETCH(QString, warning);
     QFETCH(int, count);
 
-    QQuickCanvas canvas;
+    QQuickWindow window;
 
     QQmlComponent component(&engine);
     component.loadUrl(source);
     QScopedPointer<QObject> object(component.create());
     QQuickListView *listView = qobject_cast<QQuickListView *>(object.data());
     QVERIFY(listView);
-    listView->setParentItem(canvas.rootItem());
+    listView->setParentItem(window.rootItem());
 
     QQuickItem *contentItem = listView->contentItem();
     QVERIFY(contentItem);
diff --git a/tests/auto/quick/qquickwindow/data/AnimationsWhileHidden.qml b/tests/auto/quick/qquickwindow/data/AnimationsWhileHidden.qml
new file mode 100644
index 0000000..e95b029
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/data/AnimationsWhileHidden.qml
@@ -0,0 +1,17 @@
+import QtQuick 2.0
+import QtQuick.Window 2.0 as Window
+
+Window.Window
+{
+    id: win
+    visible: true
+    width: 250
+    height: 250
+
+    SequentialAnimation {
+        PauseAnimation { duration: 500 }
+        PropertyAction { target: win; property: "visible"; value: true }
+        loops: Animation.Infinite
+        running: true
+    }
+}
diff --git a/tests/auto/quick/qquickwindow/data/Headless.qml b/tests/auto/quick/qquickwindow/data/Headless.qml
new file mode 100644
index 0000000..2e09cb1
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/data/Headless.qml
@@ -0,0 +1,33 @@
+import QtQuick 2.0
+import QtQuick.Window 2.0 as Window
+
+Window.Window {
+
+    width: 300
+    height: 200
+    visible: true
+
+    Text {
+        anchors.left: parent.left
+        anchors.top: parent.top
+        text: "Testing headless mode"
+    }
+
+    Rectangle {
+        anchors.centerIn: parent
+        width: 100
+        height: 50
+        rotation: -30
+        gradient: Gradient {
+            GradientStop { position: 0; color: "lightsteelblue" }
+            GradientStop { position: 1; color: "black" }
+        }
+    }
+
+    Image {
+        source: "colors.png"
+        anchors.bottom: parent.bottom
+        anchors.right: parent.right
+    }
+
+}
diff --git a/tests/auto/quick/qquickwindow/data/colors.png b/tests/auto/quick/qquickwindow/data/colors.png
new file mode 100644
index 0000000..dfb62f3
Binary files /dev/null and b/tests/auto/quick/qquickwindow/data/colors.png differ
diff --git a/tests/auto/quick/qquickwindow/data/focus.qml b/tests/auto/quick/qquickwindow/data/focus.qml
new file mode 100644
index 0000000..901f2fc
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/data/focus.qml
@@ -0,0 +1,11 @@
+import QtQuick 2.0
+import QtQuick.Window 2.0 as Window
+
+Window.Window {
+     Item {
+          objectName: "item1"
+     }
+     Item {
+          objectName: "item2"
+     }
+}
diff --git a/tests/auto/quick/qquickwindow/data/ownershipRootItem.qml b/tests/auto/quick/qquickwindow/data/ownershipRootItem.qml
new file mode 100644
index 0000000..dfc4159
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/data/ownershipRootItem.qml
@@ -0,0 +1,11 @@
+import QtQuick 2.0
+import QtQuick.Window 2.0 as Window
+
+Window.Window {
+RootItemAccessor {
+  id:accessor
+  objectName:"accessor"
+  Component.onCompleted:accessor.rootItem();
+}
+
+}
\ No newline at end of file
diff --git a/tests/auto/quick/qquickwindow/data/window.qml b/tests/auto/quick/qquickwindow/data/window.qml
new file mode 100644
index 0000000..d79d516
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/data/window.qml
@@ -0,0 +1,9 @@
+import QtQuick 2.0
+import QtQuick.Window 2.0 as Window
+
+Window.Window {
+    color: "#00FF00"
+    Item {
+        objectName: "item"
+    }
+}
diff --git a/tests/auto/quick/qquickwindow/qquickwindow.pro b/tests/auto/quick/qquickwindow/qquickwindow.pro
new file mode 100644
index 0000000..8f3ff82
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/qquickwindow.pro
@@ -0,0 +1,17 @@
+CONFIG += testcase
+TARGET = tst_qquickwindow
+SOURCES += tst_qquickwindow.cpp
+
+include (../../shared/util.pri)
+
+macx:CONFIG -= app_bundle
+
+CONFIG += parallel_test
+QT += core-private gui-private qml-private quick-private v8-private testlib
+
+TESTDATA = data/*
+
+OTHER_FILES += \
+    data/AnimationsWhileHidden.qml \
+    data/Headless.qml
+
diff --git a/tests/auto/quick/qquickwindow/tst_qquickwindow.cpp b/tests/auto/quick/qquickwindow/tst_qquickwindow.cpp
new file mode 100644
index 0000000..ebea271
--- /dev/null
+++ b/tests/auto/quick/qquickwindow/tst_qquickwindow.cpp
@@ -0,0 +1,1065 @@
+/****************************************************************************
+**
+** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies).
+** Contact: http://www.qt-project.org/
+**
+** This file is part of the test suite of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser General Public
+** License version 2.1 as published by the Free Software Foundation and
+** appearing in the file LICENSE.LGPL included in the packaging of this
+** file. Please review the following information to ensure the GNU Lesser
+** General Public License version 2.1 requirements will be met:
+** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
+**
+** In addition, as a special exception, Nokia gives you certain additional
+** rights. These rights are described in the Nokia Qt LGPL Exception
+** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU General
+** Public License version 3.0 as published by the Free Software Foundation
+** and appearing in the file LICENSE.GPL included in the packaging of this
+** file. Please review the following information to ensure the GNU General
+** Public License version 3.0 requirements will be met:
+** http://www.gnu.org/copyleft/gpl.html.
+**
+** Other Usage
+** Alternatively, this file may be used in accordance with the terms and
+** conditions contained in a signed written agreement between you and Nokia.
+**
+**
+**
+**
+**
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include <qtest.h>
+#include <QDebug>
+#include <QTouchEvent>
+#include <QtQuick/QQuickItem>
+#include <QtQuick/QQuickWindow>
+#include <QtQml/QQmlEngine>
+#include <QtQml/QQmlComponent>
+#include <QtQuick/private/qquickrectangle_p.h>
+#include "../../shared/util.h"
+#include <QSignalSpy>
+#include <private/qquickwindow_p.h>
+#include <private/qguiapplication_p.h>
+
+struct TouchEventData {
+    QEvent::Type type;
+    QWidget *widget;
+    QWindow *window;
+    Qt::TouchPointStates states;
+    QList<QTouchEvent::TouchPoint> touchPoints;
+};
+
+static QTouchEvent::TouchPoint makeTouchPoint(QQuickItem *item, const QPointF &p, const QPointF &lastPoint = QPointF())
+{
+    QPointF last = lastPoint.isNull() ? p : lastPoint;
+
+    QTouchEvent::TouchPoint tp;
+
+    tp.setPos(p);
+    tp.setLastPos(last);
+    tp.setScenePos(item->mapToScene(p));
+    tp.setLastScenePos(item->mapToScene(last));
+    tp.setScreenPos(item->window()->mapToGlobal(tp.scenePos().toPoint()));
+    tp.setLastScreenPos(item->window()->mapToGlobal(tp.lastScenePos().toPoint()));
+    return tp;
+}
+
+static TouchEventData makeTouchData(QEvent::Type type, QWindow *w, Qt::TouchPointStates states = 0,
+                                    const QList<QTouchEvent::TouchPoint>& touchPoints = QList<QTouchEvent::TouchPoint>())
+{
+    TouchEventData d = { type, 0, w, states, touchPoints };
+    return d;
+}
+static TouchEventData makeTouchData(QEvent::Type type, QWindow *w, Qt::TouchPointStates states, const QTouchEvent::TouchPoint &touchPoint)
+{
+    QList<QTouchEvent::TouchPoint> points;
+    points << touchPoint;
+    return makeTouchData(type, w, states, points);
+}
+
+#define COMPARE_TOUCH_POINTS(tp1, tp2) \
+{ \
+    QCOMPARE(tp1.pos(), tp2.pos()); \
+    QCOMPARE(tp1.lastPos(), tp2.lastPos()); \
+    QCOMPARE(tp1.scenePos(), tp2.scenePos()); \
+    QCOMPARE(tp1.lastScenePos(), tp2.lastScenePos()); \
+    QCOMPARE(tp1.screenPos(), tp2.screenPos()); \
+    QCOMPARE(tp1.lastScreenPos(), tp2.lastScreenPos()); \
+}
+
+#define COMPARE_TOUCH_DATA(d1, d2) \
+{ \
+    QCOMPARE((int)d1.type, (int)d2.type); \
+    QCOMPARE(d1.widget, d2.widget); \
+    QCOMPARE((int)d1.states, (int)d2.states); \
+    QCOMPARE(d1.touchPoints.count(), d2.touchPoints.count()); \
+    for (int i=0; i<d1.touchPoints.count(); i++) { \
+        COMPARE_TOUCH_POINTS(d1.touchPoints[i], d2.touchPoints[i]); \
+    } \
+}
+
+
+class RootItemAccessor : public QQuickItem
+{
+    Q_OBJECT
+public:
+    RootItemAccessor()
+        : m_rootItemDestroyed(false)
+        , m_rootItem(0)
+    {
+    }
+    Q_INVOKABLE QQuickItem *rootItem()
+    {
+        if (!m_rootItem) {
+            QQuickWindowPrivate *c = QQuickWindowPrivate::get(window());
+            m_rootItem = c->rootItem;
+            QObject::connect(m_rootItem, SIGNAL(destroyed()), this, SLOT(rootItemDestroyed()));
+        }
+        return m_rootItem;
+    }
+    bool isRootItemDestroyed() {return m_rootItemDestroyed;}
+public slots:
+    void rootItemDestroyed() {
+        m_rootItemDestroyed = true;
+    }
+
+private:
+    bool m_rootItemDestroyed;
+    QQuickItem *m_rootItem;
+};
+
+class TestTouchItem : public QQuickRectangle
+{
+    Q_OBJECT
+public:
+    TestTouchItem(QQuickItem *parent = 0)
+        : QQuickRectangle(parent), acceptTouchEvents(true), acceptMouseEvents(true),
+          mousePressId(0),
+          spinLoopWhenPressed(false), touchEventCount(0)
+    {
+        border()->setWidth(1);
+        setAcceptedMouseButtons(Qt::LeftButton);
+        setFiltersChildMouseEvents(true);
+    }
+
+    void reset() {
+        acceptTouchEvents = acceptMouseEvents = true;
+        setEnabled(true);
+        setVisible(true);
+
+        lastEvent = makeTouchData(QEvent::None, window(), 0, QList<QTouchEvent::TouchPoint>());//CHECK_VALID
+
+        lastVelocity = lastVelocityFromMouseMove = QVector2D();
+        lastMousePos = QPointF();
+        lastMouseCapabilityFlags = 0;
+    }
+
+    static void clearMousePressCounter()
+    {
+        mousePressNum = mouseMoveNum = mouseReleaseNum = 0;
+    }
+
+    void clearTouchEventCounter()
+    {
+        touchEventCount = 0;
+    }
+
+    bool acceptTouchEvents;
+    bool acceptMouseEvents;
+    TouchEventData lastEvent;
+    int mousePressId;
+    bool spinLoopWhenPressed;
+    int touchEventCount;
+    QVector2D lastVelocity;
+    QVector2D lastVelocityFromMouseMove;
+    QPointF lastMousePos;
+    int lastMouseCapabilityFlags;
+
+    void touchEvent(QTouchEvent *event) {
+        if (!acceptTouchEvents) {
+            event->ignore();
+            return;
+        }
+        ++touchEventCount;
+        lastEvent = makeTouchData(event->type(), event->window(), event->touchPointStates(), event->touchPoints());
+        if (event->device()->capabilities().testFlag(QTouchDevice::Velocity) && !event->touchPoints().isEmpty()) {
+            lastVelocity = event->touchPoints().first().velocity();
+        } else {
+            lastVelocity = QVector2D();
+        }
+        if (spinLoopWhenPressed && event->touchPointStates().testFlag(Qt::TouchPointPressed)) {
+            QCoreApplication::processEvents();
+        }
+    }
+
+    void mousePressEvent(QMouseEvent *e) {
+        if (!acceptMouseEvents) {
+            e->ignore();
+            return;
+        }
+        mousePressId = ++mousePressNum;
+        lastMousePos = e->pos();
+        lastMouseCapabilityFlags = QGuiApplicationPrivate::mouseEventCaps(e);
+    }
+
+    void mouseMoveEvent(QMouseEvent *e) {
+        if (!acceptMouseEvents) {
+            e->ignore();
+            return;
+        }
+        ++mouseMoveNum;
+        lastVelocityFromMouseMove = QGuiApplicationPrivate::mouseEventVelocity(e);
+        lastMouseCapabilityFlags = QGuiApplicationPrivate::mouseEventCaps(e);
+        lastMousePos = e->pos();
+    }
+
+    void mouseReleaseEvent(QMouseEvent *e) {
+        if (!acceptMouseEvents) {
+            e->ignore();
+            return;
+        }
+        ++mouseReleaseNum;
+        lastMousePos = e->pos();
+        lastMouseCapabilityFlags = QGuiApplicationPrivate::mouseEventCaps(e);
+    }
+
+    bool childMouseEventFilter(QQuickItem *, QEvent *event) {
+        // TODO Is it a bug if a QTouchEvent comes here?
+        if (event->type() == QEvent::MouseButtonPress)
+            mousePressId = ++mousePressNum;
+        return false;
+    }
+
+    static int mousePressNum, mouseMoveNum, mouseReleaseNum;
+};
+
+int TestTouchItem::mousePressNum = 0;
+int TestTouchItem::mouseMoveNum = 0;
+int TestTouchItem::mouseReleaseNum = 0;
+
+class ConstantUpdateItem : public QQuickItem
+{
+Q_OBJECT
+public:
+    ConstantUpdateItem(QQuickItem *parent = 0) : QQuickItem(parent), iterations(0) {setFlag(ItemHasContents);}
+
+    int iterations;
+protected:
+    QSGNode* updatePaintNode(QSGNode *, UpdatePaintNodeData *){
+        iterations++;
+        update();
+        return 0;
+    }
+};
+
+class tst_qquickwindow : public QQmlDataTest
+{
+    Q_OBJECT
+public:
+
+private slots:
+    void initTestCase()
+    {
+        QQmlDataTest::initTestCase();
+        touchDevice = new QTouchDevice;
+        touchDevice->setType(QTouchDevice::TouchScreen);
+        QWindowSystemInterface::registerTouchDevice(touchDevice);
+        touchDeviceWithVelocity = new QTouchDevice;
+        touchDeviceWithVelocity->setType(QTouchDevice::TouchScreen);
+        touchDeviceWithVelocity->setCapabilities(QTouchDevice::Position | QTouchDevice::Velocity);
+        QWindowSystemInterface::registerTouchDevice(touchDeviceWithVelocity);
+    }
+
+
+    void constantUpdates();
+    void mouseFiltering();
+    void headless();
+
+    void touchEvent_basic();
+    void touchEvent_propagation();
+    void touchEvent_propagation_data();
+    void touchEvent_cancel();
+    void touchEvent_reentrant();
+    void touchEvent_velocity();
+
+    void mouseFromTouch_basic();
+
+    void clearWindow();
+
+    void qmlCreation();
+    void clearColor();
+
+    void grab();
+    void multipleWindows();
+
+    void animationsWhileHidden();
+
+    void focusObject();
+
+    void ignoreUnhandledMouseEvents();
+
+    void ownershipRootItem();
+private:
+    QTouchDevice *touchDevice;
+    QTouchDevice *touchDeviceWithVelocity;
+};
+
+//If the item calls update inside updatePaintNode, it should schedule another update
+void tst_qquickwindow::constantUpdates()
+{
+    QQuickWindow window;
+    window.resize(250, 250);
+    ConstantUpdateItem item(window.rootItem());
+    window.show();
+    QTRY_VERIFY(item.iterations > 60);
+}
+
+void tst_qquickwindow::touchEvent_basic()
+{
+    TestTouchItem::clearMousePressCounter();
+
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    TestTouchItem *bottomItem = new TestTouchItem(window->rootItem());
+    bottomItem->setObjectName("Bottom Item");
+    bottomItem->setSize(QSizeF(150, 150));
+
+    TestTouchItem *middleItem = new TestTouchItem(bottomItem);
+    middleItem->setObjectName("Middle Item");
+    middleItem->setPos(QPointF(50, 50));
+    middleItem->setSize(QSizeF(150, 150));
+
+    TestTouchItem *topItem = new TestTouchItem(middleItem);
+    topItem->setObjectName("Top Item");
+    topItem->setPos(QPointF(50, 50));
+    topItem->setSize(QSizeF(150, 150));
+
+    QPointF pos(10, 10);
+
+    // press single point
+    QTest::touchEvent(window, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),window);
+    QTest::qWait(50);
+
+    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
+
+    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
+    // At one point this was failing with kwin (KDE window manager) because window->setPos(100, 100)
+    // would put the decorated window at that position rather than the window itself.
+    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed, makeTouchPoint(topItem, pos)));
+    topItem->reset();
+
+    // press multiple points
+    QTest::touchEvent(window, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),window)
+            .press(1, bottomItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
+    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
+    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed, makeTouchPoint(topItem, pos)));
+    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed, makeTouchPoint(bottomItem, pos)));
+    topItem->reset();
+    bottomItem->reset();
+
+    // touch point on top item moves to bottom item, but top item should still receive the event
+    QTest::touchEvent(window, touchDevice).press(0, topItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QTest::touchEvent(window, touchDevice).move(0, bottomItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
+    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchUpdate, window, Qt::TouchPointMoved,
+            makeTouchPoint(topItem, topItem->mapFromItem(bottomItem, pos), pos)));
+    topItem->reset();
+
+    // touch point on bottom item moves to top item, but bottom item should still receive the event
+    QTest::touchEvent(window, touchDevice).press(0, bottomItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QTest::touchEvent(window, touchDevice).move(0, topItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
+    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchUpdate, window, Qt::TouchPointMoved,
+            makeTouchPoint(bottomItem, bottomItem->mapFromItem(topItem, pos), pos)));
+    bottomItem->reset();
+
+    // a single stationary press on an item shouldn't cause an event
+    QTest::touchEvent(window, touchDevice).press(0, topItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QTest::touchEvent(window, touchDevice).stationary(0)
+            .press(1, bottomItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);    // received press only, not stationary
+    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
+    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed, makeTouchPoint(topItem, pos)));
+    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed, makeTouchPoint(bottomItem, pos)));
+    topItem->reset();
+    bottomItem->reset();
+    // cleanup: what is pressed must be released
+    // Otherwise you will get an assertion failure:
+    // ASSERT: "itemForTouchPointId.isEmpty()" in file items/qquickwindow.cpp
+    QTest::touchEvent(window, touchDevice).release(0, pos.toPoint(), window).release(1, pos.toPoint(), window);
+
+    // move touch point from top item to bottom, and release
+    QTest::touchEvent(window, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),window);
+    QTest::qWait(50);
+    QTest::touchEvent(window, touchDevice).release(0, bottomItem->mapToScene(pos).toPoint(),window);
+    QTest::qWait(50);
+    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
+    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchEnd, window, Qt::TouchPointReleased,
+            makeTouchPoint(topItem, topItem->mapFromItem(bottomItem, pos), pos)));
+    topItem->reset();
+
+    // release while another point is pressed
+    QTest::touchEvent(window, touchDevice).press(0, topItem->mapToScene(pos).toPoint(),window)
+            .press(1, bottomItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QTest::touchEvent(window, touchDevice).move(0, bottomItem->mapToScene(pos).toPoint(), window);
+    QTest::qWait(50);
+    QTest::touchEvent(window, touchDevice).release(0, bottomItem->mapToScene(pos).toPoint(), window)
+                             .stationary(1);
+    QTest::qWait(50);
+    QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
+    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
+    COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchEnd, window, Qt::TouchPointReleased,
+            makeTouchPoint(topItem, topItem->mapFromItem(bottomItem, pos))));
+    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed, makeTouchPoint(bottomItem, pos)));
+    topItem->reset();
+    bottomItem->reset();
+
+    delete topItem;
+    delete middleItem;
+    delete bottomItem;
+    delete window;
+}
+
+void tst_qquickwindow::touchEvent_propagation()
+{
+    TestTouchItem::clearMousePressCounter();
+
+    QFETCH(bool, acceptTouchEvents);
+    QFETCH(bool, acceptMouseEvents);
+    QFETCH(bool, enableItem);
+    QFETCH(bool, showItem);
+
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    TestTouchItem *bottomItem = new TestTouchItem(window->rootItem());
+    bottomItem->setObjectName("Bottom Item");
+    bottomItem->setSize(QSizeF(150, 150));
+
+    TestTouchItem *middleItem = new TestTouchItem(bottomItem);
+    middleItem->setObjectName("Middle Item");
+    middleItem->setPos(QPointF(50, 50));
+    middleItem->setSize(QSizeF(150, 150));
+
+    TestTouchItem *topItem = new TestTouchItem(middleItem);
+    topItem->setObjectName("Top Item");
+    topItem->setPos(QPointF(50, 50));
+    topItem->setSize(QSizeF(150, 150));
+
+    QPointF pos(10, 10);
+    QPoint pointInBottomItem = bottomItem->mapToScene(pos).toPoint();  // (10, 10)
+    QPoint pointInMiddleItem = middleItem->mapToScene(pos).toPoint();  // (60, 60) overlaps with bottomItem
+    QPoint pointInTopItem = topItem->mapToScene(pos).toPoint();  // (110, 110) overlaps with bottom & top items
+
+    // disable topItem
+    topItem->acceptTouchEvents = acceptTouchEvents;
+    topItem->acceptMouseEvents = acceptMouseEvents;
+    topItem->setEnabled(enableItem);
+    topItem->setVisible(showItem);
+
+    // single touch to top item, should be received by middle item
+    QTest::touchEvent(window, touchDevice).press(0, pointInTopItem, window);
+    QTest::qWait(50);
+    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
+    QCOMPARE(middleItem->lastEvent.touchPoints.count(), 1);
+    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
+    COMPARE_TOUCH_DATA(middleItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed,
+            makeTouchPoint(middleItem, middleItem->mapFromItem(topItem, pos))));
+
+    // touch top and middle items, middle item should get both events
+    QTest::touchEvent(window, touchDevice).press(0, pointInTopItem, window)
+            .press(1, pointInMiddleItem, window);
+    QTest::qWait(50);
+    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
+    QCOMPARE(middleItem->lastEvent.touchPoints.count(), 2);
+    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
+    COMPARE_TOUCH_DATA(middleItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed,
+           (QList<QTouchEvent::TouchPoint>() << makeTouchPoint(middleItem, middleItem->mapFromItem(topItem, pos))
+                                              << makeTouchPoint(middleItem, pos) )));
+    middleItem->reset();
+
+    // disable middleItem as well
+    middleItem->acceptTouchEvents = acceptTouchEvents;
+    middleItem->acceptMouseEvents = acceptMouseEvents;
+    middleItem->setEnabled(enableItem);
+    middleItem->setVisible(showItem);
+
+    // touch top and middle items, bottom item should get all events
+    QTest::touchEvent(window, touchDevice).press(0, pointInTopItem, window)
+            .press(1, pointInMiddleItem, window);
+    QTest::qWait(50);
+    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
+    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+    QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 2);
+    COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed,
+            (QList<QTouchEvent::TouchPoint>() << makeTouchPoint(bottomItem, bottomItem->mapFromItem(topItem, pos))
+                                              << makeTouchPoint(bottomItem, bottomItem->mapFromItem(middleItem, pos)) )));
+    bottomItem->reset();
+
+    // disable bottom item as well
+    bottomItem->acceptTouchEvents = acceptTouchEvents;
+    bottomItem->setEnabled(enableItem);
+    bottomItem->setVisible(showItem);
+
+    // no events should be received
+    QTest::touchEvent(window, touchDevice).press(0, pointInTopItem, window)
+            .press(1, pointInMiddleItem, window)
+            .press(2, pointInBottomItem, window);
+    QTest::qWait(50);
+    QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
+    QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+    QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
+
+    topItem->reset();
+    middleItem->reset();
+    bottomItem->reset();
+
+    // disable middle item, touch on top item
+    middleItem->acceptTouchEvents = acceptTouchEvents;
+    middleItem->setEnabled(enableItem);
+    middleItem->setVisible(showItem);
+    QTest::touchEvent(window, touchDevice).press(0, pointInTopItem, window);
+    QTest::qWait(50);
+    if (!enableItem || !showItem) {
+        // middle item is disabled or has 0 opacity, bottom item receives the event
+        QVERIFY(topItem->lastEvent.touchPoints.isEmpty());
+        QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+        QCOMPARE(bottomItem->lastEvent.touchPoints.count(), 1);
+        COMPARE_TOUCH_DATA(bottomItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed,
+                makeTouchPoint(bottomItem, bottomItem->mapFromItem(topItem, pos))));
+    } else {
+        // middle item ignores event, sends it to the top item (top-most child)
+        QCOMPARE(topItem->lastEvent.touchPoints.count(), 1);
+        QVERIFY(middleItem->lastEvent.touchPoints.isEmpty());
+        QVERIFY(bottomItem->lastEvent.touchPoints.isEmpty());
+        COMPARE_TOUCH_DATA(topItem->lastEvent, makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed,
+                makeTouchPoint(topItem, pos)));
+    }
+
+    delete topItem;
+    delete middleItem;
+    delete bottomItem;
+    delete window;
+}
+
+void tst_qquickwindow::touchEvent_propagation_data()
+{
+    QTest::addColumn<bool>("acceptTouchEvents");
+    QTest::addColumn<bool>("acceptMouseEvents");
+    QTest::addColumn<bool>("enableItem");
+    QTest::addColumn<bool>("showItem");
+
+    QTest::newRow("disable events") << false << false << true << true;
+    QTest::newRow("disable item") << true << true << false << true;
+    QTest::newRow("hide item") << true << true << true << false;
+}
+
+void tst_qquickwindow::touchEvent_cancel()
+{
+    TestTouchItem::clearMousePressCounter();
+
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    TestTouchItem *item = new TestTouchItem(window->rootItem());
+    item->setPos(QPointF(50, 50));
+    item->setSize(QSizeF(150, 150));
+
+    QPointF pos(10, 10);
+    QTest::touchEvent(window, touchDevice).press(0, item->mapToScene(pos).toPoint(),window);
+    QCoreApplication::processEvents();
+
+    QTRY_COMPARE(item->lastEvent.touchPoints.count(), 1);
+    TouchEventData d = makeTouchData(QEvent::TouchBegin, window, Qt::TouchPointPressed, makeTouchPoint(item,pos));
+    COMPARE_TOUCH_DATA(item->lastEvent, d);
+    item->reset();
+
+    QWindowSystemInterface::handleTouchCancelEvent(0, touchDevice);
+    QCoreApplication::processEvents();
+    d = makeTouchData(QEvent::TouchCancel, window);
+    COMPARE_TOUCH_DATA(item->lastEvent, d);
+
+    delete item;
+    delete window;
+}
+
+void tst_qquickwindow::touchEvent_reentrant()
+{
+    TestTouchItem::clearMousePressCounter();
+
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    TestTouchItem *item = new TestTouchItem(window->rootItem());
+
+    item->spinLoopWhenPressed = true; // will call processEvents() from the touch handler
+
+    item->setPos(QPointF(50, 50));
+    item->setSize(QSizeF(150, 150));
+    QPointF pos(60, 60);
+
+    // None of these should commit from the dtor.
+    QTest::QTouchEventSequence press = QTest::touchEvent(window, touchDevice, false).press(0, pos.toPoint(), window);
+    pos += QPointF(2, 2);
+    QTest::QTouchEventSequence move = QTest::touchEvent(window, touchDevice, false).move(0, pos.toPoint(), window);
+    QTest::QTouchEventSequence release = QTest::touchEvent(window, touchDevice, false).release(0, pos.toPoint(), window);
+
+    // Now commit (i.e. call QWindowSystemInterface::handleTouchEvent), but do not process the events yet.
+    press.commit(false);
+    move.commit(false);
+    release.commit(false);
+
+    QCoreApplication::processEvents();
+
+    QTRY_COMPARE(item->touchEventCount, 3);
+
+    delete item;
+    delete window;
+}
+
+void tst_qquickwindow::touchEvent_velocity()
+{
+    TestTouchItem::clearMousePressCounter();
+
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+    QTest::qWait(10);
+
+    TestTouchItem *item = new TestTouchItem(window->rootItem());
+    item->setPos(QPointF(50, 50));
+    item->setSize(QSizeF(150, 150));
+
+    QList<QWindowSystemInterface::TouchPoint> points;
+    QWindowSystemInterface::TouchPoint tp;
+    tp.id = 1;
+    tp.state = Qt::TouchPointPressed;
+    QPoint pos = window->mapToGlobal(item->mapToScene(QPointF(10, 10)).toPoint());
+    tp.area = QRectF(pos, QSizeF(4, 4));
+    points << tp;
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    points[0].state = Qt::TouchPointMoved;
+    points[0].area.adjust(5, 5, 5, 5);
+    QVector2D velocity(1.5, 2.5);
+    points[0].velocity = velocity;
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    QCoreApplication::processEvents();
+    QCOMPARE(item->touchEventCount, 2);
+    QCOMPARE(item->lastEvent.touchPoints.count(), 1);
+    QCOMPARE(item->lastVelocity, velocity);
+
+    // Now have a transformation on the item and check if velocity and position are transformed accordingly.
+    item->setRotation(90); // clockwise
+    QMatrix4x4 transformMatrix;
+    transformMatrix.rotate(-90, 0, 0, 1); // counterclockwise
+    QVector2D transformedVelocity = transformMatrix.mapVector(velocity).toVector2D();
+    points[0].area.adjust(5, 5, 5, 5);
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    QCoreApplication::processEvents();
+    QCOMPARE(item->lastVelocity, transformedVelocity);
+    QPoint itemLocalPos = item->mapFromScene(window->mapFromGlobal(points[0].area.center().toPoint())).toPoint();
+    QPoint itemLocalPosFromEvent = item->lastEvent.touchPoints[0].pos().toPoint();
+    QCOMPARE(itemLocalPos, itemLocalPosFromEvent);
+
+    points[0].state = Qt::TouchPointReleased;
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    QCoreApplication::processEvents();
+    delete item;
+    delete window;
+}
+
+void tst_qquickwindow::mouseFromTouch_basic()
+{
+    // Turn off accepting touch events with acceptTouchEvents. This
+    // should result in sending mouse events generated from the touch
+    // with the new event propagation system.
+
+    TestTouchItem::clearMousePressCounter();
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+    QTest::qWait(10);
+
+    TestTouchItem *item = new TestTouchItem(window->rootItem());
+    item->setPos(QPointF(50, 50));
+    item->setSize(QSizeF(150, 150));
+    item->acceptTouchEvents = false;
+
+    QList<QWindowSystemInterface::TouchPoint> points;
+    QWindowSystemInterface::TouchPoint tp;
+    tp.id = 1;
+    tp.state = Qt::TouchPointPressed;
+    QPoint pos = window->mapToGlobal(item->mapToScene(QPointF(10, 10)).toPoint());
+    tp.area = QRectF(pos, QSizeF(4, 4));
+    points << tp;
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    points[0].state = Qt::TouchPointMoved;
+    points[0].area.adjust(5, 5, 5, 5);
+    QVector2D velocity(1.5, 2.5);
+    points[0].velocity = velocity;
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    points[0].state = Qt::TouchPointReleased;
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    QCoreApplication::processEvents();
+
+    // The item should have received a mouse press, move, and release.
+    QCOMPARE(item->mousePressNum, 1);
+    QCOMPARE(item->mouseMoveNum, 1);
+    QCOMPARE(item->mouseReleaseNum, 1);
+    QCOMPARE(item->lastMousePos.toPoint(), item->mapFromScene(window->mapFromGlobal(points[0].area.center().toPoint())).toPoint());
+    QCOMPARE(item->lastVelocityFromMouseMove, velocity);
+    QVERIFY((item->lastMouseCapabilityFlags & QTouchDevice::Velocity) != 0);
+
+    // Now the same with a transformation.
+    item->setRotation(90); // clockwise
+    QMatrix4x4 transformMatrix;
+    transformMatrix.rotate(-90, 0, 0, 1); // counterclockwise
+    QVector2D transformedVelocity = transformMatrix.mapVector(velocity).toVector2D();
+    points[0].state = Qt::TouchPointPressed;
+    points[0].velocity = velocity;
+    points[0].area = QRectF(pos, QSizeF(4, 4));
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    points[0].state = Qt::TouchPointMoved;
+    points[0].area.adjust(5, 5, 5, 5);
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    QCoreApplication::processEvents();
+    QCOMPARE(item->lastMousePos.toPoint(), item->mapFromScene(window->mapFromGlobal(points[0].area.center().toPoint())).toPoint());
+    QCOMPARE(item->lastVelocityFromMouseMove, transformedVelocity);
+
+    points[0].state = Qt::TouchPointReleased;
+    QWindowSystemInterface::handleTouchEvent(window, touchDeviceWithVelocity, points);
+    QCoreApplication::processEvents();
+    delete item;
+    delete window;
+}
+
+void tst_qquickwindow::clearWindow()
+{
+    QQuickWindow *window = new QQuickWindow;
+    QQuickItem *item = new QQuickItem;
+    item->setParentItem(window->rootItem());
+
+    QVERIFY(item->window() == window);
+
+    delete window;
+
+    QVERIFY(item->window() == 0);
+
+    delete item;
+}
+
+void tst_qquickwindow::mouseFiltering()
+{
+    TestTouchItem::clearMousePressCounter();
+
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    TestTouchItem *bottomItem = new TestTouchItem(window->rootItem());
+    bottomItem->setObjectName("Bottom Item");
+    bottomItem->setSize(QSizeF(150, 150));
+
+    TestTouchItem *middleItem = new TestTouchItem(bottomItem);
+    middleItem->setObjectName("Middle Item");
+    middleItem->setPos(QPointF(50, 50));
+    middleItem->setSize(QSizeF(150, 150));
+
+    TestTouchItem *topItem = new TestTouchItem(middleItem);
+    topItem->setObjectName("Top Item");
+    topItem->setPos(QPointF(50, 50));
+    topItem->setSize(QSizeF(150, 150));
+
+    QPoint pos(100, 100);
+
+    QTest::mousePress(window, Qt::LeftButton, 0, pos);
+
+    // Mouse filtering propagates down the stack, so the
+    // correct order is
+    // 1. middleItem filters event
+    // 2. bottomItem filters event
+    // 3. topItem receives event
+    QTRY_COMPARE(middleItem->mousePressId, 1);
+    QTRY_COMPARE(bottomItem->mousePressId, 2);
+    QTRY_COMPARE(topItem->mousePressId, 3);
+
+    delete window;
+}
+
+void tst_qquickwindow::qmlCreation()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.loadUrl(testFileUrl("window.qml"));
+    QObject* created = component.create();
+    QVERIFY(created);
+
+    QQuickWindow* window = qobject_cast<QQuickWindow*>(created);
+    QVERIFY(window);
+    QCOMPARE(window->color(), QColor(Qt::green));
+
+    QQuickItem* item = window->findChild<QQuickItem*>("item");
+    QVERIFY(item);
+    QCOMPARE(item->window(), window);
+
+    delete window;
+}
+
+void tst_qquickwindow::clearColor()
+{
+    //::grab examines rendering to make sure it works visually
+    QQuickWindow *window = new QQuickWindow;
+    window->resize(250, 250);
+    window->setPos(100, 100);
+    window->setColor(Qt::blue);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+    QCOMPARE(window->color(), QColor(Qt::blue));
+    delete window;
+}
+
+void tst_qquickwindow::grab()
+{
+    QQuickWindow window;
+    window.setColor(Qt::red);
+
+    window.resize(250, 250);
+    window.show();
+
+    QTest::qWaitForWindowShown(&window);
+
+    QImage content = window.grabWindow();
+    QCOMPARE(content.width(), window.width());
+    QCOMPARE(content.height(), window.height());
+    QCOMPARE((uint) content.convertToFormat(QImage::Format_RGB32).pixel(0, 0), (uint) 0xffff0000);
+}
+
+void tst_qquickwindow::multipleWindows()
+{
+    QList<QQuickWindow *> windows;
+    for (int i=0; i<6; ++i) {
+        QQuickWindow *c = new QQuickWindow();
+        c->setColor(Qt::GlobalColor(Qt::red + i));
+        c->resize(300, 200);
+        c->setPos(100 + i * 30, 100 + i * 20);
+        c->show();
+        windows << c;
+        QVERIFY(c->isVisible());
+    }
+
+    // move them
+    for (int i=0; i<windows.size(); ++i) {
+        QQuickWindow *c = windows.at(i);
+        c->setPos(c->x() - 10, c->y() - 10);
+    }
+
+    // resize them
+    for (int i=0; i<windows.size(); ++i) {
+        QQuickWindow *c = windows.at(i);
+        c->resize(200, 150);
+    }
+
+    qDeleteAll(windows);
+}
+
+void tst_qquickwindow::animationsWhileHidden()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.loadUrl(testFileUrl("AnimationsWhileHidden.qml"));
+    QObject* created = component.create();
+
+    QQuickWindow* window = qobject_cast<QQuickWindow*>(created);
+    QVERIFY(window);
+    QVERIFY(window->isVisible());
+
+    // Now hide the window and verify that it went off screen
+    window->hide();
+    QTest::qWait(10);
+    QVERIFY(!window->isVisible());
+
+    // Running animaiton should cause it to become visible again shortly.
+    QTRY_VERIFY(window->isVisible());
+
+    delete window;
+}
+
+
+void tst_qquickwindow::headless()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.loadUrl(testFileUrl("Headless.qml"));
+    QObject* created = component.create();
+
+    QQuickWindow* window = qobject_cast<QQuickWindow*>(created);
+    QVERIFY(window);
+
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->isVisible());
+
+    QSignalSpy initialized(window, SIGNAL(sceneGraphInitialized()));
+    QSignalSpy invalidated(window, SIGNAL(sceneGraphInvalidated()));
+
+    // Verify that the window is alive and kicking
+    QVERIFY(window->openglContext() != 0);
+
+    // Store the visual result
+    QImage originalContent = window->grabWindow();
+
+    // Hide the window and verify signal emittion and GL context deletion
+    window->hide();
+    window->releaseResources();
+
+    QTRY_COMPARE(invalidated.size(), 1);
+    QVERIFY(window->openglContext() == 0);
+
+    // Destroy the native windowing system buffers
+    window->destroy();
+    QVERIFY(window->handle() == 0);
+
+    // Show and verify that we are back and running
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    QTRY_COMPARE(initialized.size(), 1);
+    QVERIFY(window->openglContext() != 0);
+
+    // Verify that the visual output is the same
+    QImage newContent = window->grabWindow();
+
+    QCOMPARE(originalContent, newContent);
+
+    delete window;
+}
+
+void tst_qquickwindow::focusObject()
+{
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.loadUrl(testFileUrl("focus.qml"));
+    QObject *created = component.create();
+    QVERIFY(created);
+
+    QQuickWindow *window = qobject_cast<QQuickWindow*>(created);
+    QVERIFY(window);
+
+    QQuickItem *item1 = window->findChild<QQuickItem*>("item1");
+    QVERIFY(item1);
+    item1->setFocus(true);
+    QCOMPARE(item1, window->focusObject());
+
+    QQuickItem *item2 = window->findChild<QQuickItem*>("item2");
+    QVERIFY(item2);
+    item2->setFocus(true);
+    QCOMPARE(item2, window->focusObject());
+
+    delete window;
+}
+
+void tst_qquickwindow::ignoreUnhandledMouseEvents()
+{
+    QQuickWindow* window = new QQuickWindow;
+    window->resize(100, 100);
+    window->show();
+    QTest::qWaitForWindowShown(window);
+
+    QQuickItem* item = new QQuickItem;
+    item->setSize(QSizeF(100, 100));
+    item->setParentItem(window->rootItem());
+
+    {
+        QMouseEvent me(QEvent::MouseButtonPress, QPointF(50, 50), Qt::LeftButton, Qt::LeftButton,
+                       Qt::NoModifier);
+        me.setAccepted(true);
+        QVERIFY(QCoreApplication::sendEvent(window, &me));
+        QVERIFY(!me.isAccepted());
+    }
+
+    {
+        QMouseEvent me(QEvent::MouseMove, QPointF(51, 51), Qt::LeftButton, Qt::LeftButton,
+                       Qt::NoModifier);
+        me.setAccepted(true);
+        QVERIFY(QCoreApplication::sendEvent(window, &me));
+        QVERIFY(!me.isAccepted());
+    }
+
+    {
+        QMouseEvent me(QEvent::MouseButtonRelease, QPointF(51, 51), Qt::LeftButton, Qt::LeftButton,
+                       Qt::NoModifier);
+        me.setAccepted(true);
+        QVERIFY(QCoreApplication::sendEvent(window, &me));
+        QVERIFY(!me.isAccepted());
+    }
+
+    delete window;
+}
+
+
+void tst_qquickwindow::ownershipRootItem()
+{
+    qmlRegisterType<RootItemAccessor>("QtQuick", 2, 0, "RootItemAccessor");
+
+    QQmlEngine engine;
+    QQmlComponent component(&engine);
+    component.loadUrl(testFileUrl("ownershipRootItem.qml"));
+    QObject* created = component.create();
+
+    QQuickWindow* window = qobject_cast<QQuickWindow*>(created);
+    QVERIFY(window);
+    QTest::qWaitForWindowShown(window);
+
+    RootItemAccessor* accessor = window->findChild<RootItemAccessor*>("accessor");
+    QVERIFY(accessor);
+    engine.collectGarbage();
+
+    QCoreApplication::sendPostedEvents(0, QEvent::DeferredDelete);
+    QCoreApplication::processEvents();
+    QVERIFY(!accessor->isRootItemDestroyed());
+}
+QTEST_MAIN(tst_qquickwindow)
+
+#include "tst_qquickwindow.moc"
diff --git a/tests/auto/quick/quick.pro b/tests/auto/quick/quick.pro
index aed2ae9..82592a9 100644
--- a/tests/auto/quick/quick.pro
+++ b/tests/auto/quick/quick.pro
@@ -42,7 +42,7 @@ QUICKTESTS =  \
     qquickanimatedimage \
     qquickanimatedsprite \
     qquickborderimage \
-    qquickcanvas \
+    qquickwindow \
     qquickdrag \
     qquickdroparea \
     qquickflickable \
diff --git a/tests/auto/quick/rendernode/tst_rendernode.cpp b/tests/auto/quick/rendernode/tst_rendernode.cpp
index f3832b4..af230f7 100644
--- a/tests/auto/quick/rendernode/tst_rendernode.cpp
+++ b/tests/auto/quick/rendernode/tst_rendernode.cpp
@@ -62,7 +62,7 @@ public:
         view.show();
         QTest::qWaitForWindowShown(&view);
 
-        return view.grabFrameBuffer();
+        return view.grabWindow();
     }
 
 private slots:
diff --git a/tests/auto/quick/shared/viewtestutil.cpp b/tests/auto/quick/shared/viewtestutil.cpp
index 1c4319f..59ebed5 100644
--- a/tests/auto/quick/shared/viewtestutil.cpp
+++ b/tests/auto/quick/shared/viewtestutil.cpp
@@ -74,24 +74,24 @@ static void qquickmodelviewstestutil_move(int from, int to, int n, T *items)
 
 QQuickView *QQuickViewTestUtil::createView()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    return canvas;
+    return window;
 }
 
-void QQuickViewTestUtil::flick(QQuickView *canvas, const QPoint &from, const QPoint &to, int duration)
+void QQuickViewTestUtil::flick(QQuickView *window, const QPoint &from, const QPoint &to, int duration)
 {
     const int pointCount = 5;
     QPoint diff = to - from;
 
     // send press, five equally spaced moves, and release.
-    QTest::mousePress(canvas, Qt::LeftButton, 0, from);
+    QTest::mousePress(window, Qt::LeftButton, 0, from);
 
     for (int i = 0; i < pointCount; ++i)
-        QTest::mouseMove(canvas, from + (i+1)*diff/pointCount, duration / pointCount);
+        QTest::mouseMove(window, from + (i+1)*diff/pointCount, duration / pointCount);
 
-    QTest::mouseRelease(canvas, Qt::LeftButton, 0, to);
+    QTest::mouseRelease(window, Qt::LeftButton, 0, to);
     QTest::qWait(50);
 }
 
diff --git a/tests/auto/quick/shared/viewtestutil.h b/tests/auto/quick/shared/viewtestutil.h
index 10ecd6a..66921a7 100644
--- a/tests/auto/quick/shared/viewtestutil.h
+++ b/tests/auto/quick/shared/viewtestutil.h
@@ -53,7 +53,7 @@ namespace QQuickViewTestUtil
 {
     QQuickView *createView();
 
-    void flick(QQuickView *canvas, const QPoint &from, const QPoint &to, int duration);
+    void flick(QQuickView *window, const QPoint &from, const QPoint &to, int duration);
 
     QList<int> adjustIndexesForAddDisplaced(const QList<int> &indexes, int index, int count);
     QList<int> adjustIndexesForMove(const QList<int> &indexes, int from, int to, int count);
diff --git a/tests/auto/quick/touchmouse/tst_touchmouse.cpp b/tests/auto/quick/touchmouse/tst_touchmouse.cpp
index 7ab9387..cb22160 100644
--- a/tests/auto/quick/touchmouse/tst_touchmouse.cpp
+++ b/tests/auto/quick/touchmouse/tst_touchmouse.cpp
@@ -51,7 +51,7 @@
 #include <QtQuick/private/qquickpincharea_p.h>
 #include <QtQuick/private/qquickflickable_p.h>
 
-#include <private/qquickcanvas_p.h>
+#include <private/qquickwindow_p.h>
 
 #include <QtQml/qqmlengine.h>
 #include <QtQml/qqmlproperty.h>
@@ -166,10 +166,10 @@ private:
 
 QQuickView *tst_TouchMouse::createView()
 {
-    QQuickView *canvas = new QQuickView(0);
-    canvas->setGeometry(0,0,240,320);
+    QQuickView *window = new QQuickView(0);
+    window->setGeometry(0,0,240,320);
 
-    return canvas;
+    return window;
 }
 
 void tst_TouchMouse::initTestCase()
@@ -188,39 +188,39 @@ void tst_TouchMouse::initTestCase()
 
 void tst_TouchMouse::simpleTouchEvent()
 {
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("singleitem.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QTest::qWaitForWindowShown(canvas);
-    QVERIFY(canvas->rootObject() != 0);
+    window->setSource(testFileUrl("singleitem.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QTest::qWaitForWindowShown(window);
+    QVERIFY(window->rootObject() != 0);
 
-    EventItem *eventItem1 = canvas->rootObject()->findChild<EventItem*>("eventItem1");
+    EventItem *eventItem1 = window->rootObject()->findChild<EventItem*>("eventItem1");
     QVERIFY(eventItem1);
 
     // Do not accept touch or mouse
     QPoint p1;
     p1 = QPoint(20, 20);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 1);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     p1 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 1);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 1);
     eventItem1->eventList.clear();
 
     // Accept touch
     eventItem1->acceptTouch = true;
     p1 = QPoint(20, 20);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 1);
     p1 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 3);
     eventItem1->eventList.clear();
 
@@ -232,15 +232,15 @@ void tst_TouchMouse::simpleTouchEvent()
     eventItem1->acceptMouse = true;
     eventItem1->setAcceptedMouseButtons(Qt::LeftButton);
     p1 = QPoint(20, 20);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::MouseButtonPress);
-    QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(canvas);
-    QCOMPARE(canvasPriv->mouseGrabberItem, eventItem1);
+    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(window);
+    QCOMPARE(windowPriv->mouseGrabberItem, eventItem1);
 
     QPoint localPos = eventItem1->mapFromScene(p1).toPoint();
-    QPoint globalPos = canvas->mapToGlobal(p1);
+    QPoint globalPos = window->mapToGlobal(p1);
     QPoint scenePos = p1; // item is at 0,0
     QCOMPARE(eventItem1->eventList.at(0).points.at(0).pos().toPoint(), localPos);
     QCOMPARE(eventItem1->eventList.at(0).points.at(0).scenePos().toPoint(), scenePos);
@@ -249,11 +249,11 @@ void tst_TouchMouse::simpleTouchEvent()
     QCOMPARE(eventItem1->eventList.at(1).mousePosGlobal, globalPos);
 
     p1 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 4);
     QCOMPARE(eventItem1->eventList.at(2).type, QEvent::TouchUpdate);
     QCOMPARE(eventItem1->eventList.at(3).type, QEvent::MouseMove);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 6);
     QCOMPARE(eventItem1->eventList.at(4).type, QEvent::TouchEnd);
     QCOMPARE(eventItem1->eventList.at(5).type, QEvent::MouseButtonRelease);
@@ -267,14 +267,14 @@ void tst_TouchMouse::simpleTouchEvent()
     eventItem1->acceptMouse = false;
     eventItem1->setAcceptedMouseButtons(Qt::LeftButton);
     p1 = QPoint(20, 20);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::MouseButtonPress);
     p1 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
     eventItem1->eventList.clear();
 
@@ -285,32 +285,32 @@ void tst_TouchMouse::simpleTouchEvent()
     eventItem1->acceptTouch = true;
     eventItem1->setAcceptedMouseButtons(Qt::LeftButton);
     p1 = QPoint(20, 20);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 1);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     p1 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::TouchUpdate);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 3);
     QCOMPARE(eventItem1->eventList.at(2).type, QEvent::TouchEnd);
     eventItem1->eventList.clear();
 
-    delete canvas;
+    delete window;
 }
 
 void tst_TouchMouse::eventFilter()
 {
 //    // install event filter on item and see that it can grab events
-//    QQuickView *canvas = createView();
+//    QQuickView *window = createView();
 
-//    canvas->setSource(testFileUrl("singleitem.qml"));
-//    canvas->show();
-//    canvas->requestActivateWindow();
-//    QVERIFY(canvas->rootObject() != 0);
+//    window->setSource(testFileUrl("singleitem.qml"));
+//    window->show();
+//    window->requestActivateWindow();
+//    QVERIFY(window->rootObject() != 0);
 
-//    EventItem *eventItem1 = canvas->rootObject()->findChild<EventItem*>("eventItem1");
+//    EventItem *eventItem1 = window->rootObject()->findChild<EventItem*>("eventItem1");
 //    QVERIFY(eventItem1);
 //    eventItem1->acceptTouch = true;
 
@@ -319,16 +319,16 @@ void tst_TouchMouse::eventFilter()
 //    eventItem1->installEventFilter(filter);
 
 //    QPoint p1 = QPoint(20, 20);
-//    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+//    QTest::touchEvent(window, device).press(0, p1, window);
 //    // QEXPECT_FAIL("", "We do not implement event filters correctly", Abort);
 //    QCOMPARE(eventItem1->eventList.size(), 0);
 //    QCOMPARE(filter->eventList.size(), 1);
-//    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+//    QTest::touchEvent(window, device).release(0, p1, window);
 //    QCOMPARE(eventItem1->eventList.size(), 0);
 //    QCOMPARE(filter->eventList.size(), 2);
 
 //    delete filter;
-//    delete canvas;
+//    delete window;
 }
 
 void tst_TouchMouse::mouse()
@@ -337,31 +337,31 @@ void tst_TouchMouse::mouse()
     //   - eventItem2
 
     QTest::qWait(qApp->styleHints()->mouseDoubleClickInterval() + 10);
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("twoitems.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window->setSource(testFileUrl("twoitems.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    EventItem *eventItem1 = canvas->rootObject()->findChild<EventItem*>("eventItem1");
+    EventItem *eventItem1 = window->rootObject()->findChild<EventItem*>("eventItem1");
     QVERIFY(eventItem1);
-    EventItem *eventItem2 = canvas->rootObject()->findChild<EventItem*>("eventItem2");
+    EventItem *eventItem2 = window->rootObject()->findChild<EventItem*>("eventItem2");
     QVERIFY(eventItem2);
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
     // bottom item likes mouse, top likes touch
     eventItem1->setAcceptedMouseButtons(Qt::LeftButton);
     eventItem1->acceptMouse = true;
     // item 2 doesn't accept anything, thus it sees a touch pass by
     QPoint p1 = QPoint(30, 30);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
 
     QCOMPARE(eventItem1->eventList.size(), 2);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::MouseButtonPress);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_TouchMouse::touchOverMouse()
@@ -369,40 +369,40 @@ void tst_TouchMouse::touchOverMouse()
     // eventItem1
     //   - eventItem2
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("twoitems.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window->setSource(testFileUrl("twoitems.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    EventItem *eventItem1 = canvas->rootObject()->findChild<EventItem*>("eventItem1");
+    EventItem *eventItem1 = window->rootObject()->findChild<EventItem*>("eventItem1");
     QVERIFY(eventItem1);
-    EventItem *eventItem2 = canvas->rootObject()->findChild<EventItem*>("eventItem2");
+    EventItem *eventItem2 = window->rootObject()->findChild<EventItem*>("eventItem2");
     QVERIFY(eventItem2);
 
     // bottom item likes mouse, top likes touch
     eventItem1->setAcceptedMouseButtons(Qt::LeftButton);
     eventItem2->acceptTouch = true;
 
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
     QCOMPARE(eventItem1->eventList.size(), 0);
     QPoint p1 = QPoint(20, 20);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 0);
     QCOMPARE(eventItem2->eventList.size(), 1);
     QCOMPARE(eventItem2->eventList.at(0).type, QEvent::TouchBegin);
     p1 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window);
     QCOMPARE(eventItem2->eventList.size(), 2);
     QCOMPARE(eventItem2->eventList.at(1).type, QEvent::TouchUpdate);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem2->eventList.size(), 3);
     QCOMPARE(eventItem2->eventList.at(2).type, QEvent::TouchEnd);
     eventItem2->eventList.clear();
 
-    delete canvas;
+    delete window;
 }
 
 void tst_TouchMouse::mouseOverTouch()
@@ -410,16 +410,16 @@ void tst_TouchMouse::mouseOverTouch()
     // eventItem1
     //   - eventItem2
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("twoitems.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window->setSource(testFileUrl("twoitems.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    EventItem *eventItem1 = canvas->rootObject()->findChild<EventItem*>("eventItem1");
+    EventItem *eventItem1 = window->rootObject()->findChild<EventItem*>("eventItem1");
     QVERIFY(eventItem1);
-    EventItem *eventItem2 = canvas->rootObject()->findChild<EventItem*>("eventItem2");
+    EventItem *eventItem2 = window->rootObject()->findChild<EventItem*>("eventItem2");
     QVERIFY(eventItem2);
 
     // bottom item likes mouse, top likes touch
@@ -427,11 +427,11 @@ void tst_TouchMouse::mouseOverTouch()
     eventItem2->setAcceptedMouseButtons(Qt::LeftButton);
     eventItem2->acceptMouse = true;
 
-    QTest::qWaitForWindowShown(canvas);
+    QTest::qWaitForWindowShown(window);
 
     QPoint p1 = QPoint(20, 20);
     QTest::qWait(qApp->styleHints()->mouseDoubleClickInterval() + 10);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 0);
     QCOMPARE(eventItem2->eventList.size(), 2);
     QCOMPARE(eventItem2->eventList.at(0).type, QEvent::TouchBegin);
@@ -439,13 +439,13 @@ void tst_TouchMouse::mouseOverTouch()
 
 
 //    p1 += QPoint(10, 0);
-//    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+//    QTest::touchEvent(window, device).move(0, p1, window);
 //    QCOMPARE(eventItem2->eventList.size(), 1);
-//    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+//    QTest::touchEvent(window, device).release(0, p1, window);
 //    QCOMPARE(eventItem2->eventList.size(), 1);
 //    eventItem2->eventList.clear();
 
-    delete canvas;
+    delete window;
 }
 
 void tst_TouchMouse::buttonOnFlickable()
@@ -454,24 +454,24 @@ void tst_TouchMouse::buttonOnFlickable()
     //   - eventItem1 y: 100, height 100
     //   - eventItem2 y: 300, height 100
 
-    QQuickView *canvas = createView();
+    QQuickView *window = createView();
 
-    canvas->setSource(testFileUrl("buttononflickable.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    window->setSource(testFileUrl("buttononflickable.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickFlickable *flickable = canvas->rootObject()->findChild<QQuickFlickable*>("flickable");
+    QQuickFlickable *flickable = window->rootObject()->findChild<QQuickFlickable*>("flickable");
     QVERIFY(flickable);
 
     // should a mouse area button be clickable on top of flickable? yes :)
-    EventItem *eventItem1 = canvas->rootObject()->findChild<EventItem*>("eventItem1");
+    EventItem *eventItem1 = window->rootObject()->findChild<EventItem*>("eventItem1");
     QVERIFY(eventItem1);
     eventItem1->setAcceptedMouseButtons(Qt::LeftButton);
     eventItem1->acceptMouse = true;
 
     // should a touch button be touchable on top of flickable? yes :)
-    EventItem *eventItem2 = canvas->rootObject()->findChild<EventItem*>("eventItem2");
+    EventItem *eventItem2 = window->rootObject()->findChild<EventItem*>("eventItem2");
     QVERIFY(eventItem2);
     QCOMPARE(eventItem2->eventList.size(), 0);
     eventItem2->acceptTouch = true;
@@ -483,11 +483,11 @@ void tst_TouchMouse::buttonOnFlickable()
     // mouse button
     QCOMPARE(eventItem1->eventList.size(), 0);
     QPoint p1 = QPoint(20, 130);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::MouseButtonPress);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 4);
     QCOMPARE(eventItem1->eventList.at(2).type, QEvent::TouchEnd);
     QCOMPARE(eventItem1->eventList.at(3).type, QEvent::MouseButtonRelease);
@@ -495,10 +495,10 @@ void tst_TouchMouse::buttonOnFlickable()
 
     // touch button
     p1 = QPoint(10, 310);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem2->eventList.size(), 1);
     QCOMPARE(eventItem2->eventList.at(0).type, QEvent::TouchBegin);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem2->eventList.size(), 2);
     QCOMPARE(eventItem2->eventList.at(1).type, QEvent::TouchEnd);
     QCOMPARE(eventItem1->eventList.size(), 0);
@@ -509,9 +509,9 @@ void tst_TouchMouse::buttonOnFlickable()
 
     // click above button, no events please
     p1 = QPoint(10, 90);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 0);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 0);
     eventItem1->eventList.clear();
 
@@ -521,36 +521,36 @@ void tst_TouchMouse::buttonOnFlickable()
     // check that flickable moves - mouse button
     QCOMPARE(eventItem1->eventList.size(), 0);
     p1 = QPoint(10, 110);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 2);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::MouseButtonPress);
 
-    QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(canvas);
-    QCOMPARE(canvasPriv->touchMouseId, 0);
-    QCOMPARE(canvasPriv->itemForTouchPointId[0], eventItem1);
-    QCOMPARE(canvasPriv->mouseGrabberItem, eventItem1);
+    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(window);
+    QCOMPARE(windowPriv->touchMouseId, 0);
+    QCOMPARE(windowPriv->itemForTouchPointId[0], eventItem1);
+    QCOMPARE(windowPriv->mouseGrabberItem, eventItem1);
 
     p1 += QPoint(0, -10);
     QPoint p2 = p1 + QPoint(0, -10);
     QPoint p3 = p2 + QPoint(0, -10);
     QTest::qWait(10);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window);
     QTest::qWait(10);
-    QTest::touchEvent(canvas, device).move(0, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p2, window);
     QTest::qWait(10);
-    QTest::touchEvent(canvas, device).move(0, p3, canvas);
+    QTest::touchEvent(window, device).move(0, p3, window);
 
     // we cannot really know when the events get grabbed away
     QVERIFY(eventItem1->eventList.size() >= 4);
     QCOMPARE(eventItem1->eventList.at(2).type, QEvent::TouchUpdate);
     QCOMPARE(eventItem1->eventList.at(3).type, QEvent::MouseMove);
 
-    QCOMPARE(canvasPriv->mouseGrabberItem, flickable);
+    QCOMPARE(windowPriv->mouseGrabberItem, flickable);
     QVERIFY(flickable->isMovingVertically());
 
-    QTest::touchEvent(canvas, device).release(0, p3, canvas);
-    delete canvas;
+    QTest::touchEvent(window, device).release(0, p3, window);
+    delete window;
 }
 
 void tst_TouchMouse::buttonOnTouch()
@@ -563,26 +563,26 @@ void tst_TouchMouse::buttonOnTouch()
     //     - eventItem1 y: 100, height 100
     //     - eventItem2 y: 300, height 100
 
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("buttonontouch.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("buttonontouch.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QVERIFY(pinchArea);
-    QQuickItem *button1 = canvas->rootObject()->findChild<QQuickItem*>("button1");
+    QQuickItem *button1 = window->rootObject()->findChild<QQuickItem*>("button1");
     QVERIFY(button1);
-    EventItem *eventItem1 = canvas->rootObject()->findChild<EventItem*>("eventItem1");
+    EventItem *eventItem1 = window->rootObject()->findChild<EventItem*>("eventItem1");
     QVERIFY(eventItem1);
-    EventItem *eventItem2 = canvas->rootObject()->findChild<EventItem*>("eventItem2");
+    EventItem *eventItem2 = window->rootObject()->findChild<EventItem*>("eventItem2");
     QVERIFY(eventItem2);
 
-    QQuickMultiPointTouchArea *touchArea = canvas->rootObject()->findChild<QQuickMultiPointTouchArea*>("toucharea");
+    QQuickMultiPointTouchArea *touchArea = window->rootObject()->findChild<QQuickMultiPointTouchArea*>("toucharea");
     QVERIFY(touchArea);
-    EventItem *eventItem3 = canvas->rootObject()->findChild<EventItem*>("eventItem3");
+    EventItem *eventItem3 = window->rootObject()->findChild<EventItem*>("eventItem3");
     QVERIFY(eventItem3);
-    EventItem *eventItem4 = canvas->rootObject()->findChild<EventItem*>("eventItem4");
+    EventItem *eventItem4 = window->rootObject()->findChild<EventItem*>("eventItem4");
     QVERIFY(eventItem4);
 
 
@@ -596,8 +596,8 @@ void tst_TouchMouse::buttonOnTouch()
 
     // Normal touch click
     QPoint p1 = QPoint(10, 110);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
-    QTest::touchEvent(canvas, device).release(0, p1, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
+    QTest::touchEvent(window, device).release(0, p1, window);
     QCOMPARE(eventItem1->eventList.size(), 4);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::MouseButtonPress);
@@ -606,7 +606,7 @@ void tst_TouchMouse::buttonOnTouch()
     eventItem1->eventList.clear();
 
     // Normal mouse click
-    QTest::mouseClick(canvas, Qt::LeftButton, 0, p1);
+    QTest::mouseClick(window, Qt::LeftButton, 0, p1);
     QCOMPARE(eventItem1->eventList.size(), 2);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::MouseButtonPress);
     QCOMPARE(eventItem1->eventList.at(1).type, QEvent::MouseButtonRelease);
@@ -617,29 +617,29 @@ void tst_TouchMouse::buttonOnTouch()
     QPoint p2 = QPoint(60, 10);
 
     // Start the events after each other
-    QTest::touchEvent(canvas, device).press(0, p1, canvas);
-    QTest::touchEvent(canvas, device).stationary(0).press(1, p2, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window);
+    QTest::touchEvent(window, device).stationary(0).press(1, p2, window);
 
     QCOMPARE(button1->scale(), 1.0);
 
     // This event seems to be discarded, let's ignore it for now until someone digs into pincharea
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas).move(1, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window).move(1, p2, window);
 
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas).move(1, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window).move(1, p2, window);
 //    QCOMPARE(button1->scale(), 1.5);
     qDebug() << "Button scale: " << button1->scale();
 
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas).move(1, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window).move(1, p2, window);
 //    QCOMPARE(button1->scale(), 2.0);
     qDebug() << "Button scale: " << button1->scale();
 
-    QTest::touchEvent(canvas, device).release(0, p1, canvas).release(1, p2, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window).release(1, p2, window);
 //    QVERIFY(eventItem1->eventList.isEmpty());
 //    QCOMPARE(button1->scale(), 2.0);
     qDebug() << "Button scale: " << button1->scale();
@@ -652,7 +652,7 @@ void tst_TouchMouse::buttonOnTouch()
     button1->setScale(1.0);
     p1 = QPoint(40, 110);
     p2 = QPoint(60, 110);
-    QTest::touchEvent(canvas, device).press(0, p1, canvas).press(1, p2, canvas);
+    QTest::touchEvent(window, device).press(0, p1, window).press(1, p2, window);
     QCOMPARE(button1->scale(), 1.0);
     QCOMPARE(eventItem1->eventList.count(), 2);
     QCOMPARE(eventItem1->eventList.at(0).type, QEvent::TouchBegin);
@@ -661,59 +661,59 @@ void tst_TouchMouse::buttonOnTouch()
     // This event seems to be discarded, let's ignore it for now until someone digs into pincharea
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas).move(1, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window).move(1, p2, window);
 
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas).move(1, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window).move(1, p2, window);
     //QCOMPARE(button1->scale(), 1.5);
     qDebug() << button1->scale();
 
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p1, canvas).move(1, p2, canvas);
+    QTest::touchEvent(window, device).move(0, p1, window).move(1, p2, window);
     qDebug() << button1->scale();
     //QCOMPARE(button1->scale(), 2.0);
 
-    QTest::touchEvent(canvas, device).release(0, p1, canvas).release(1, p2, canvas);
+    QTest::touchEvent(window, device).release(0, p1, window).release(1, p2, window);
 //    QCOMPARE(eventItem1->eventList.size(), 99);
     qDebug() << button1->scale();
     //QCOMPARE(button1->scale(), 2.0);
 
-    delete canvas;
+    delete window;
 }
 
 void tst_TouchMouse::pinchOnFlickable()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("pinchonflickable.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("pinchonflickable.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QVERIFY(pinchArea);
-    QQuickFlickable *flickable = canvas->rootObject()->findChild<QQuickFlickable*>("flickable");
+    QQuickFlickable *flickable = window->rootObject()->findChild<QQuickFlickable*>("flickable");
     QVERIFY(flickable);
-    QQuickItem *rect = canvas->rootObject()->findChild<QQuickItem*>("rect");
+    QQuickItem *rect = window->rootObject()->findChild<QQuickItem*>("rect");
     QVERIFY(rect);
 
     // flickable - single touch point
     QVERIFY(flickable->contentX() == 0.0);
     QPoint p = QPoint(100, 100);
-    QTest::touchEvent(canvas, device).press(0, p, canvas);
+    QTest::touchEvent(window, device).press(0, p, window);
     QCOMPARE(rect->pos(), QPointF(200.0, 200.0));
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
     QTest::qWait(10);
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
     QTest::qWait(10);
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
-    QTest::touchEvent(canvas, device).release(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
+    QTest::touchEvent(window, device).release(0, p, window);
 
     QGuiApplication::processEvents();
     QTest::qWait(10);
@@ -725,61 +725,61 @@ void tst_TouchMouse::pinchOnFlickable()
     QPoint p1 = QPoint(40, 20);
     QPoint p2 = QPoint(60, 20);
 
-    QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
-    pinchSequence.press(0, p1, canvas).commit();
+    QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(window, device);
+    pinchSequence.press(0, p1, window).commit();
     // In order for the stationary point to remember its previous position,
     // we have to reuse the same pinchSequence object.  Otherwise if we let it
     // be destroyed and then start a new sequence, point 0 will default to being
     // stationary at 0, 0, and PinchArea will filter out that touchpoint because
     // it is outside its bounds.
-    pinchSequence.stationary(0).press(1, p2, canvas).commit();
+    pinchSequence.stationary(0).press(1, p2, window).commit();
     p1 -= QPoint(10,10);
     p2 += QPoint(10,10);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     QCOMPARE(rect->scale(), 1.0);
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
-    pinchSequence.release(0, p1, canvas).release(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
+    pinchSequence.release(0, p1, window).release(1, p2, window).commit();
     QVERIFY(rect->scale() > 1.0);
 }
 
 void tst_TouchMouse::flickableOnPinch()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("flickableonpinch.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("flickableonpinch.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QVERIFY(pinchArea);
-    QQuickFlickable *flickable = canvas->rootObject()->findChild<QQuickFlickable*>("flickable");
+    QQuickFlickable *flickable = window->rootObject()->findChild<QQuickFlickable*>("flickable");
     QVERIFY(flickable);
-    QQuickItem *rect = canvas->rootObject()->findChild<QQuickItem*>("rect");
+    QQuickItem *rect = window->rootObject()->findChild<QQuickItem*>("rect");
     QVERIFY(rect);
 
     // flickable - single touch point
     QVERIFY(flickable->contentX() == 0.0);
     QPoint p = QPoint(100, 100);
-    QTest::touchEvent(canvas, device).press(0, p, canvas);
+    QTest::touchEvent(window, device).press(0, p, window);
     QCOMPARE(rect->pos(), QPointF(200.0, 200.0));
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
 
     QTest::qWait(1000);
 
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
-    QTest::touchEvent(canvas, device).release(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
+    QTest::touchEvent(window, device).release(0, p, window);
 
     QTest::qWait(1000);
 
@@ -791,61 +791,61 @@ void tst_TouchMouse::flickableOnPinch()
     // pinch
     QPoint p1 = QPoint(40, 20);
     QPoint p2 = QPoint(60, 20);
-    QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
-    pinchSequence.press(0, p1, canvas).commit();
+    QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(window, device);
+    pinchSequence.press(0, p1, window).commit();
     // In order for the stationary point to remember its previous position,
     // we have to reuse the same pinchSequence object.  Otherwise if we let it
     // be destroyed and then start a new sequence, point 0 will default to being
     // stationary at 0, 0, and PinchArea will filter out that touchpoint because
     // it is outside its bounds.
-    pinchSequence.stationary(0).press(1, p2, canvas).commit();
+    pinchSequence.stationary(0).press(1, p2, window).commit();
     p1 -= QPoint(10,10);
     p2 += QPoint(10,10);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     QCOMPARE(rect->scale(), 1.0);
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
-    pinchSequence.release(0, p1, canvas).release(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
+    pinchSequence.release(0, p1, window).release(1, p2, window).commit();
     QVERIFY(rect->scale() > 1.0);
 }
 
 void tst_TouchMouse::mouseOnFlickableOnPinch()
 {
-    QQuickView *canvas = createView();
-    canvas->setSource(testFileUrl("mouseonflickableonpinch.qml"));
-    canvas->show();
-    canvas->requestActivateWindow();
-    QVERIFY(canvas->rootObject() != 0);
+    QQuickView *window = createView();
+    window->setSource(testFileUrl("mouseonflickableonpinch.qml"));
+    window->show();
+    window->requestActivateWindow();
+    QVERIFY(window->rootObject() != 0);
 
-    QQuickPinchArea *pinchArea = canvas->rootObject()->findChild<QQuickPinchArea*>("pincharea");
+    QQuickPinchArea *pinchArea = window->rootObject()->findChild<QQuickPinchArea*>("pincharea");
     QVERIFY(pinchArea);
-    QQuickFlickable *flickable = canvas->rootObject()->findChild<QQuickFlickable*>("flickable");
+    QQuickFlickable *flickable = window->rootObject()->findChild<QQuickFlickable*>("flickable");
     QVERIFY(flickable);
-    QQuickItem *rect = canvas->rootObject()->findChild<QQuickItem*>("rect");
+    QQuickItem *rect = window->rootObject()->findChild<QQuickItem*>("rect");
     QVERIFY(rect);
 
     // flickable - single touch point
     QVERIFY(flickable->contentX() == 0.0);
     QPoint p = QPoint(100, 100);
-    QTest::touchEvent(canvas, device).press(0, p, canvas);
+    QTest::touchEvent(window, device).press(0, p, window);
     QCOMPARE(rect->pos(), QPointF(200.0, 200.0));
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
 
     QTest::qWait(1000);
 
     p -= QPoint(10, 0);
-    QTest::touchEvent(canvas, device).move(0, p, canvas);
-    QTest::touchEvent(canvas, device).release(0, p, canvas);
+    QTest::touchEvent(window, device).move(0, p, window);
+    QTest::touchEvent(window, device).release(0, p, window);
 
     QTest::qWait(1000);
 
@@ -855,66 +855,66 @@ void tst_TouchMouse::mouseOnFlickableOnPinch()
     // pinch
     QPoint p1 = QPoint(40, 20);
     QPoint p2 = QPoint(60, 20);
-    QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(canvas, device);
-    pinchSequence.press(0, p1, canvas).commit();
+    QTest::QTouchEventSequence pinchSequence = QTest::touchEvent(window, device);
+    pinchSequence.press(0, p1, window).commit();
     // In order for the stationary point to remember its previous position,
     // we have to reuse the same pinchSequence object.  Otherwise if we let it
     // be destroyed and then start a new sequence, point 0 will default to being
     // stationary at 0, 0, and PinchArea will filter out that touchpoint because
     // it is outside its bounds.
-    pinchSequence.stationary(0).press(1, p2, canvas).commit();
+    pinchSequence.stationary(0).press(1, p2, window).commit();
     p1 -= QPoint(10,10);
     p2 += QPoint(10,10);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     QCOMPARE(rect->scale(), 1.0);
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(10, 0);
     p2 += QPoint(10, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
-    pinchSequence.release(0, p1, canvas).release(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
+    pinchSequence.release(0, p1, window).release(1, p2, window).commit();
     QVERIFY(rect->scale() > 1.0);
 
     // PinchArea should steal the event after flicking started
     rect->setScale(1.0);
     flickable->setContentX(0.0);
     p = QPoint(100, 100);
-    pinchSequence.press(0, p, canvas).commit();
+    pinchSequence.press(0, p, window).commit();
     QCOMPARE(rect->pos(), QPointF(200.0, 200.0));
     p -= QPoint(10, 0);
-    pinchSequence.move(0, p, canvas).commit();
+    pinchSequence.move(0, p, window).commit();
     p -= QPoint(10, 0);
-    pinchSequence.move(0, p, canvas).commit();
+    pinchSequence.move(0, p, window).commit();
     QTest::qWait(1000);
     p -= QPoint(10, 0);
-    pinchSequence.move(0, p, canvas).commit();
+    pinchSequence.move(0, p, window).commit();
 
-    QQuickCanvasPrivate *canvasPriv = QQuickCanvasPrivate::get(canvas);
-    QCOMPARE(canvasPriv->mouseGrabberItem, flickable);
-    qDebug() << "Mouse Grabber: " << canvasPriv->mouseGrabberItem << " itemForTouchPointId: " << canvasPriv->itemForTouchPointId;
+    QQuickWindowPrivate *windowPriv = QQuickWindowPrivate::get(window);
+    QCOMPARE(windowPriv->mouseGrabberItem, flickable);
+    qDebug() << "Mouse Grabber: " << windowPriv->mouseGrabberItem << " itemForTouchPointId: " << windowPriv->itemForTouchPointId;
 
     // Add a second finger, this should lead to stealing
     p1 = QPoint(40, 100);
     p2 = QPoint(60, 100);
-    pinchSequence.stationary(0).press(1, p2, canvas).commit();
+    pinchSequence.stationary(0).press(1, p2, window).commit();
     QCOMPARE(rect->scale(), 1.0);
 
     p1 -= QPoint(5, 0);
     p2 += QPoint(5, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(5, 0);
     p2 += QPoint(5, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
     p1 -= QPoint(5, 0);
     p2 += QPoint(5, 0);
-    pinchSequence.move(0, p1, canvas).move(1, p2, canvas).commit();
-    pinchSequence.release(0, p1, canvas).release(1, p2, canvas).commit();
+    pinchSequence.move(0, p1, window).move(1, p2, window).commit();
+    pinchSequence.release(0, p1, window).release(1, p2, window).commit();
     QVERIFY(rect->scale() > 1.0);
-    pinchSequence.release(0, p, canvas).commit();
+    pinchSequence.release(0, p, window).commit();
 }
 
 QTEST_MAIN(tst_TouchMouse)
diff --git a/tools/qmlscene/main.cpp b/tools/qmlscene/main.cpp
index 0aa64ce..f0f262c 100644
--- a/tools/qmlscene/main.cpp
+++ b/tools/qmlscene/main.cpp
@@ -440,7 +440,7 @@ int main(int argc, char ** argv)
                 surfaceFormat.setAlphaBufferSize(8);
                 qxView.setFormat(surfaceFormat);
                 qxView.setClearBeforeRendering(true);
-                qxView.setClearColor(QColor(Qt::transparent));
+                qxView.setColor(QColor(Qt::transparent));
                 qxView.setWindowFlags(Qt::FramelessWindowHint);
             }