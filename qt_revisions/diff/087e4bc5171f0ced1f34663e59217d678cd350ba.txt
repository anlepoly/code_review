diff --git a/configure b/configure
index 5229c2b..f03bd58 100755
--- a/configure
+++ b/configure
@@ -727,7 +727,7 @@ mkdir -p "$outpath/config.tests"
 rm -f "$outpath/config.tests/.qmake.cache"
 cp "$QMAKE_VARS_FILE" "$outpath/config.tests/.qmake.cache"
 
-QMakeVar add styles "cde mac motif fusion plastique cleanlooks windows"
+QMakeVar add styles "mac fusion windows"
 
 # QTDIR may be set and point to an old or system-wide Qt installation
 unset QTDIR
diff --git a/dist/changes-5.0.0 b/dist/changes-5.0.0
index e42c566..8b7f549 100644
--- a/dist/changes-5.0.0
+++ b/dist/changes-5.0.0
@@ -526,6 +526,10 @@ QtGui
 
 QtWidgets
 ---------
+* A new style QFusionStyle has been introduced, while QPlastiqueStyle, QCleanlooksStyle,
+  QCDEStyle and QMotifStyle have been removed. The older styles will be
+  made available to applications as a standalone source package.
+
 * QInputContext removed as well as related getters and setters on QWidget and QApplication.
   Input contexts are now platform specific.
 
diff --git a/src/corelib/global/qconfig-minimal.h b/src/corelib/global/qconfig-minimal.h
index 9c95d12..28cb8fb 100644
--- a/src/corelib/global/qconfig-minimal.h
+++ b/src/corelib/global/qconfig-minimal.h
@@ -376,17 +376,8 @@
 #endif
 
 /* Styles */
-#ifndef QT_NO_STYLE_MOTIF
-#  define QT_NO_STYLE_MOTIF
-#endif
-#ifndef QT_NO_STYLE_CDE
-#  define QT_NO_STYLE_CDE
-#endif
-#ifndef QT_NO_STYLE_CLEANLOOKS
-#  define QT_NO_STYLE_CLEANLOOKS
-#endif
-#ifndef QT_NO_STYLE_PLASTIQUE
-#  define QT_NO_STYLE_PLASTIQUE
+#ifndef QT_NO_STYLE_FUSION
+#  define QT_NO_STYLE_FUSION
 #endif
 #ifndef QT_NO_STYLE_STYLESHEET
 #  define QT_NO_STYLE_STYLESHEET
diff --git a/src/corelib/global/qconfig-small.h b/src/corelib/global/qconfig-small.h
index b3a056b..9d72cd5 100644
--- a/src/corelib/global/qconfig-small.h
+++ b/src/corelib/global/qconfig-small.h
@@ -209,23 +209,14 @@
 #endif
 
 /* Styles */
-#ifndef QT_NO_STYLE_MOTIF
-#  define QT_NO_STYLE_MOTIF
-#endif
-#ifndef QT_NO_STYLE_CDE
-#  define QT_NO_STYLE_CDE
-#endif
-#ifndef QT_NO_STYLE_CLEANLOOKS
-#  define QT_NO_STYLE_CLEANLOOKS
-#endif
-#ifndef QT_NO_STYLE_PLASTIQUE
-#  define QT_NO_STYLE_PLASTIQUE
+#ifndef QT_NO_STYLE_FUSION
+#  define QT_NO_STYLE_FUSION
 #endif
 #ifndef QT_NO_STYLE_STYLESHEET
 #  define QT_NO_STYLE_STYLESHEET
 #endif
-#ifndef QT_NO_STYLE_WINDOWSXP
-#  define QT_NO_STYLE_WINDOWSXP
+#ifndef QT_NO_STYLE_WINDOWSVISTA
+#  define QT_NO_STYLE_WINDOWSVISTA
 #endif
 
 /* Utilities */
diff --git a/src/corelib/global/qfeatures.h b/src/corelib/global/qfeatures.h
index 90ef47c..b4b73a9 100644
--- a/src/corelib/global/qfeatures.h
+++ b/src/corelib/global/qfeatures.h
@@ -396,16 +396,6 @@
 #define QT_NO_SCROLLAREA
 #endif
 
-// QCleanLooksStyle
-#if !defined(QT_NO_STYLE_CLEANLOOKS) && (defined(QT_NO_STYLE_WINDOWS) || defined(QT_NO_IMAGEFORMAT_XPM))
-#define QT_NO_STYLE_CLEANLOOKS
-#endif
-
-// QPlastiqueStyle
-#if !defined(QT_NO_STYLE_PLASTIQUE) && (defined(QT_NO_STYLE_WINDOWS) || defined(QT_NO_IMAGEFORMAT_XPM))
-#define QT_NO_STYLE_PLASTIQUE
-#endif
-
 // QWindowsCEStyle
 #if !defined(QT_NO_STYLE_WINDOWSCE) && (defined(QT_NO_STYLE_WINDOWS) || defined(QT_NO_IMAGEFORMAT_XPM))
 #define QT_NO_STYLE_WINDOWSCE
diff --git a/src/corelib/global/qfeatures.txt b/src/corelib/global/qfeatures.txt
index 3b3af8a..7f31259 100644
--- a/src/corelib/global/qfeatures.txt
+++ b/src/corelib/global/qfeatures.txt
@@ -727,11 +727,11 @@ Requires:
 Name: QWindowsStyle
 SeeAlso: ???
 
-Feature: STYLE_PLASTIQUE
-Description: Supports a widget style similar to the Plastik style available in KDE.
+Feature: STYLE_FUSION
+Description: Supports a modern platform independent widget style.
 Section: Styles
 Requires: STYLE_WINDOWS IMAGEFORMAT_XPM
-Name: QPlastiqueStyle
+Name: QFusionStyle
 SeeAlso: ???
 
 Feature: STYLE_WINDOWSXP
@@ -748,13 +748,6 @@ Requires: STYLE_WINDOWSXP
 Name: QWindowsVistaStyle
 SeeAlso: ???
 
-Feature: STYLE_CLEANLOOKS
-Description: Supports a Gnome CleanLooks-like look and feel.
-Section: Styles
-Requires: STYLE_WINDOWS IMAGEFORMAT_XPM
-Name: QCleanLooksStyle
-SeeAlso: ???
-
 Feature: STYLE_WINDOWSCE
 Description: WindowsCE look and feel
 Section: Styles
diff --git a/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp b/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp
index 2d0139f..d219fbe 100644
--- a/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp
+++ b/src/platformsupport/themes/genericunix/qgenericunixthemes.cpp
@@ -130,7 +130,7 @@ QVariant QGenericUnixTheme::themeHint(ThemeHint hint) const
         return QVariant(true);
     case QPlatformTheme::StyleNames: {
         QStringList styleNames;
-        styleNames << QStringLiteral("Plastique") << QStringLiteral("Windows");
+        styleNames << QStringLiteral("Fusion") << QStringLiteral("Windows");
         return QVariant(styleNames);
     }
     case QPlatformTheme::KeyboardScheme:
@@ -225,7 +225,7 @@ void QKdeTheme::refresh()
     m_toolButtonStyle = Qt::ToolButtonTextBesideIcon;
     m_toolBarIconSize = 0;
     m_styleNames.clear();
-    m_styleNames << QStringLiteral("Oxygen") << QStringLiteral("plastique") << QStringLiteral("windows");
+    m_styleNames << QStringLiteral("Oxygen") << QStringLiteral("fusion") << QStringLiteral("windows");
     m_iconFallbackThemeName = m_iconThemeName = QStringLiteral("oxygen");
 
     // Read settings file.
diff --git a/src/tools/uic/qclass_lib_map.h b/src/tools/uic/qclass_lib_map.h
index e356973..703871c 100644
--- a/src/tools/uic/qclass_lib_map.h
+++ b/src/tools/uic/qclass_lib_map.h
@@ -834,11 +834,9 @@ QT_CLASS_LIB(QTransform, QtGui, qtransform.h)
 QT_CLASS_LIB(QWMatrix, QtGui, qwmatrix.h)
 QT_CLASS_LIB(QKeyEventTransition, QtWidgets, qkeyeventtransition.h)
 QT_CLASS_LIB(QMouseEventTransition, QtWidgets, qmouseeventtransition.h)
-QT_CLASS_LIB(QCleanlooksStyle, QtWidgets, qcleanlooksstyle.h)
 QT_CLASS_LIB(QCommonStyle, QtWidgets, qcommonstyle.h)
 QT_CLASS_LIB(QGtkStyle, QtWidgets, qgtkstyle.h)
 QT_CLASS_LIB(QMacStyle, QtWidgets, qmacstyle_mac.h)
-QT_CLASS_LIB(QPlastiqueStyle, QtWidgets, qplastiquestyle.h)
 QT_CLASS_LIB(QProxyStyle, QtWidgets, qproxystyle.h)
 QT_CLASS_LIB(QStyle, QtWidgets, qstyle.h)
 QT_CLASS_LIB(QStyleFactory, QtWidgets, qstylefactory.h)
diff --git a/src/widgets/kernel/qapplication.cpp b/src/widgets/kernel/qapplication.cpp
index 86a27b2..3e0f803 100644
--- a/src/widgets/kernel/qapplication.cpp
+++ b/src/widgets/kernel/qapplication.cpp
@@ -1212,7 +1212,7 @@ void QApplication::setStyle(QStyle *style)
     Requests a QStyle object for \a style from the QStyleFactory.
 
     The string must be one of the QStyleFactory::keys(), typically one of
-    "windows", "cleanlooks", "plastique", "windowsxp", or "macintosh". Style
+    "windows", "fusion", "windowsxp", or "macintosh". Style
     names are case insensitive.
 
     Returns 0 if an unknown \a style is passed, otherwise the QStyle object
diff --git a/src/widgets/styles/qcleanlooksstyle.cpp b/src/widgets/styles/qcleanlooksstyle.cpp
deleted file mode 100644
index 5b8b5e0..0000000
--- a/src/widgets/styles/qcleanlooksstyle.cpp
+++ /dev/null
@@ -1,4419 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qcleanlooksstyle.h"
-#include "qcleanlooksstyle_p.h"
-
-#if !defined(QT_NO_STYLE_CLEANLOOKS) || defined(QT_PLUGIN)
-
-#include "qwindowsstyle_p.h"
-#include <qcombobox.h>
-#include <qpushbutton.h>
-#include <qpainter.h>
-#include <qdir.h>
-#include <qhash.h>
-#include <qstyleoption.h>
-#include <qapplication.h>
-#include <qmainwindow.h>
-#include <qfont.h>
-#include <qgroupbox.h>
-#include <qprocess.h>
-#include <qpixmapcache.h>
-#include <qdialogbuttonbox.h>
-#include <qscrollbar.h>
-#include <qspinbox.h>
-#include <qslider.h>
-#include <qsplitter.h>
-#include <qprogressbar.h>
-#include <qtoolbar.h>
-#include <qwizard.h>
-#include <qlibrary.h>
-#include <private/qstylehelper_p.h>
-#include <private/qstyleanimation_p.h>
-
-QT_BEGIN_NAMESPACE
-
-using namespace QStyleHelper;
-
-enum Direction {
-    TopDown,
-    FromLeft,
-    BottomUp,
-    FromRight
-};
-
-// from windows style
-static const int windowsItemFrame        =  2; // menu item frame width
-static const int windowsItemHMargin      =  3; // menu item hor text margin
-static const int windowsItemVMargin      =  8; // menu item ver text margin
-static const int windowsRightBorder      = 15; // right border on windows
-
-/* XPM */
-static const char * const dock_widget_close_xpm[] = {
-    "11 13 7 1",
-    " 	c None",
-    ".	c #D5CFCB",
-    "+	c #8F8B88",
-    "@	c #6C6A67",
-    "#	c #ABA6A3",
-    "$	c #B5B0AC",
-    "%	c #A4A09D",
-    "           ",
-    " +@@@@@@@+ ",
-    "+#       #+",
-    "@ $@   @$ @",
-    "@ @@@ @@@ @",
-    "@  @@@@@  @",
-    "@   @@@   @",
-    "@  @@@@@  @",
-    "@ @@@ @@@ @",
-    "@ $@   @$ @",
-    "+%       #+",
-    " +@@@@@@@+ ",
-    "           "};
-
-static const char * const qt_cleanlooks_arrow_down_xpm[] = {
-    "11 7 2 1",
-    " 	c None",
-    "x	c #000000",
-    "           ",
-    "  x     x  ",
-    " xxx   xxx ",
-    "  xxxxxxx  ",
-    "   xxxxx   ",
-    "    xxx    ",
-    "     x     "};
-
-static const char * const qt_cleanlooks_arrow_up_xpm[] = {
-    "11 7 2 1",
-    " 	c None",
-    "x	c #000000",
-    "     x     ",
-    "    xxx    ",
-    "   xxxxx   ",
-    "  xxxxxxx  ",
-    " xxx   xxx ",
-    "  x     x  ",
-    "           "};
-
-static const char * const dock_widget_restore_xpm[] = {
-    "11 13 7 1",
-    " 	c None",
-    ".	c #D5CFCB",
-    "+	c #8F8B88",
-    "@	c #6C6A67",
-    "#	c #ABA6A3",
-    "$	c #B5B0AC",
-    "%	c #A4A09D",
-    "           ",
-    " +@@@@@@@+ ",
-    "+#       #+",
-    "@   #@@@# @",
-    "@   @   @ @",
-    "@ #@@@# @ @",
-    "@ @   @ @ @",
-    "@ @   @@@ @",
-    "@ @   @   @",
-    "@ #@@@#   @",
-    "+%       #+",
-    " +@@@@@@@+ ",
-    "           "};
-
-static const char * const workspace_minimize[] = {
-    "11 13 7 1",
-    " 	c None",
-    ".	c #D5CFCB",
-    "+	c #8F8B88",
-    "@	c #6C6A67",
-    "#	c #ABA6A3",
-    "$	c #B5B0AC",
-    "%	c #A4A09D",
-    "           ",
-    " +@@@@@@@+ ",
-    "+#       #+",
-    "@         @",
-    "@         @",
-    "@         @",
-    "@ @@@@@@@ @",
-    "@ @@@@@@@ @",
-    "@         @",
-    "@         @",
-    "+%       #+",
-    " +@@@@@@@+ ",
-    "           "};
-
-
-static const char * const qt_titlebar_context_help[] = {
-    "10 10 3 1",
-    "  c None",
-    "# c #000000",
-    "+ c #444444",
-    "  +####+  ",
-    " ###  ### ",
-    " ##    ## ",
-    "     +##+ ",
-    "    +##   ",
-    "    ##    ",
-    "    ##    ",
-    "          ",
-    "    ##    ",
-    "    ##    "};
-
-static const char * const qt_cleanlooks_radiobutton[] = {
-    "13 13 9 1",
-    " 	c None",
-    ".	c #ABA094",
-    "+	c #B7ADA0",
-    "@	c #C4BBB2",
-    "#	c #DDD4CD",
-    "$	c #E7E1E0",
-    "%	c #F4EFED",
-    "&	c #FFFAF9",
-    "*	c #FCFEFB",
-    "   #@...@#   ",
-    "  @+@#$$#+@  ",
-    " @+$%%***&@@ ",
-    "#+$%**&&**&+#",
-    "@@$&&******#@",
-    ".#**********.",
-    ".$&******&*&.",
-    ".$*&******&*.",
-    "+#********&#@",
-    "#+*********+#",
-    " @@*******@@ ",
-    "  @+#%*%#+@  ",
-    "   #@...+#   "};
-
-static const char * const qt_cleanlooks_radiobutton_checked[] = {
-    "13 13 20 1",
-    " 	c None",
-    ".	c #A8ABAE",
-    "+	c #596066",
-    "@	c #283138",
-    "#	c #A9ACAF",
-    "$	c #A6A9AB",
-    "%	c #6B7378",
-    "&	c #8C9296",
-    "*	c #A2A6AA",
-    "=	c #61696F",
-    "-	c #596065",
-    ";	c #93989C",
-    ">	c #777E83",
-    ",	c #60686E",
-    "'	c #252D33",
-    ")	c #535B62",
-    "!	c #21292E",
-    "~	c #242B31",
-    "{	c #1F262B",
-    "]	c #41484E",
-    "             ",
-    "             ",
-    "             ",
-    "    .+@+#    ",
-    "   $%&*&=#   ",
-    "   -&;>,'+   ",
-    "   @*>,)!@   ",
-    "   +&,)~{+   ",
-    "   #='!{]#   ",
-    "    #+@+#    ",
-    "             ",
-    "             ",
-    "             "};
-
-
-static const char * const qt_scrollbar_button_arrow_left[] = {
-    "4 7 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "   *",
-    "  **",
-    " ***",
-    "****",
-    " ***",
-    "  **",
-    "   *"};
-
-static const char * const qt_scrollbar_button_arrow_right[] = {
-    "4 7 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "*   ",
-    "**  ",
-    "*** ",
-    "****",
-    "*** ",
-    "**  ",
-    "*   "};
-
-static const char * const qt_scrollbar_button_arrow_up[] = {
-    "7 4 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "   *   ",
-    "  ***  ",
-    " ***** ",
-    "*******"};
-
-static const char * const qt_scrollbar_button_arrow_down[] = {
-    "7 4 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "*******",
-    " ***** ",
-    "  ***  ",
-    "   *   "};
-
-static const char * const qt_spinbox_button_arrow_down[] = {
-    "7 4 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "*******",
-    " ***** ",
-    "  ***  ",
-    "   *   "};
-
-static const char * const qt_spinbox_button_arrow_up[] = {
-    "7 4 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "   *   ",
-    "  ***  ",
-    " ***** ",
-    "*******"};
-
-static const char * const qt_scrollbar_button_left[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    " .++++++++++++++",
-    ".+#############+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    ".+<<<<<<<<<<<<<+",
-    " .++++++++++++++"};
-
-static const char * const qt_scrollbar_button_right[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    "++++++++++++++. ",
-    "+#############+.",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+<<<<<<<<<<<<<+.",
-    "++++++++++++++. "};
-
-static const char * const qt_scrollbar_button_up[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    " .++++++++++++. ",
-    ".+############+.",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+<<<<<<<<<<<<<<+",
-    "++++++++++++++++"};
-
-static const char * const qt_scrollbar_button_down[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    "++++++++++++++++",
-    "+##############+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    ".+<<<<<<<<<<<<+.",
-    " .++++++++++++. "};
-
-static const char * const qt_cleanlooks_menuitem_checkbox_checked[] = {
-    "8 7 6 1",
-    " 	g None",
-    ".	g #959595",
-    "+	g #676767",
-    "@	g #454545",
-    "#	g #1D1D1D",
-    "0	g #101010",
-    "      ..",
-    "     .+ ",
-    "    .+  ",
-    "0  .@   ",
-    "@#++.   ",
-    "  @#    ",
-    "   .    "};
-
-static const char * const qt_cleanlooks_checkbox_checked[] = {
-    "13 13 3 1",
-    " 	c None",
-    ".	c #272D33",
-    "%	c #666666",
-
-    "             ",
-    "          %  ",
-    "         %.  ",
-    "        %.%  ",
-    "       %..   ",
-    "  %.% %..    ",
-    "  %..%..%    ",
-    "   %...%     ",
-    "    %..%     ",
-    "     %.%     ",
-    "      %      ",
-    "             ",
-    "             "};
-
-static void qt_cleanlooks_draw_gradient(QPainter *painter, const QRect &rect, const QColor &gradientStart,
-                                        const QColor &gradientStop, Direction direction = TopDown, QBrush bgBrush = QBrush())
-{
-        int x = rect.center().x();
-        int y = rect.center().y();
-        QLinearGradient *gradient;
-        switch(direction) {
-            case FromLeft:
-                gradient = new QLinearGradient(rect.left(), y, rect.right(), y);
-                break;
-            case FromRight:
-                gradient = new QLinearGradient(rect.right(), y, rect.left(), y);
-                break;
-            case BottomUp:
-                gradient = new QLinearGradient(x, rect.bottom(), x, rect.top());
-                break;
-            case TopDown:
-            default:
-                gradient = new QLinearGradient(x, rect.top(), x, rect.bottom());
-                break;
-        }
-        if (bgBrush.gradient())
-            gradient->setStops(bgBrush.gradient()->stops());
-        else {
-            gradient->setColorAt(0, gradientStart);
-            gradient->setColorAt(1, gradientStop);
-        }
-        painter->fillRect(rect, *gradient);
-        delete gradient;
-}
-
-static void qt_cleanlooks_draw_buttongradient(QPainter *painter, const QRect &rect, const QColor &gradientStart,
-                                                const QColor &gradientMid, const QColor &gradientStop, Direction direction = TopDown,
-                                                QBrush bgBrush = QBrush())
-{
-        int x = rect.center().x();
-        int y = rect.center().y();
-        QLinearGradient *gradient;
-        bool horizontal = false;
-        switch(direction) {
-            case FromLeft:
-                horizontal = true;
-                gradient = new QLinearGradient(rect.left(), y, rect.right(), y);
-                break;
-            case FromRight:
-                horizontal = true;
-                gradient = new QLinearGradient(rect.right(), y, rect.left(), y);
-                break;
-            case BottomUp:
-                gradient = new QLinearGradient(x, rect.bottom(), x, rect.top());
-                break;
-            case TopDown:
-            default:
-                gradient = new QLinearGradient(x, rect.top(), x, rect.bottom());
-                break;
-        }
-        if (bgBrush.gradient())
-            gradient->setStops(bgBrush.gradient()->stops());
-        else {
-            int size = horizontal ? rect.width() : rect.height() ;
-            if (size > 4) {
-                float edge = 4.0/(float)size;
-                gradient->setColorAt(0, gradientStart);
-                gradient->setColorAt(edge, gradientMid.lighter(104));
-                gradient->setColorAt(1.0 - edge, gradientMid.darker(100));
-                gradient->setColorAt(1.0, gradientStop);
-            }
-        }
-        painter->fillRect(rect, *gradient);
-        delete gradient;
-}
-
-static void qt_cleanlooks_draw_mdibutton(QPainter *painter, const QStyleOptionTitleBar *option, const QRect &tmp, bool hover, bool sunken)
-{
-    QColor dark;
-    dark.setHsv(option->palette.button().color().hue(),
-                qMin(255, (int)(option->palette.button().color().saturation()*1.9)),
-                qMin(255, (int)(option->palette.button().color().value()*0.7)));
-
-    QColor highlight = option->palette.highlight().color();
-
-    bool active = (option->titleBarState & QStyle::State_Active);
-    QColor titleBarHighlight(255, 255, 255, 60);
-
-    if (sunken)
-        painter->fillRect(tmp.adjusted(1, 1, -1, -1), option->palette.highlight().color().darker(120));
-    else if (hover)
-        painter->fillRect(tmp.adjusted(1, 1, -1, -1), QColor(255, 255, 255, 20));
-
-    QColor mdiButtonGradientStartColor;
-    QColor mdiButtonGradientStopColor;
-
-    mdiButtonGradientStartColor = QColor(0, 0, 0, 40);
-    mdiButtonGradientStopColor = QColor(255, 255, 255, 60);
-
-    if (sunken)
-        titleBarHighlight = highlight.darker(130);
-
-    QLinearGradient gradient(tmp.center().x(), tmp.top(), tmp.center().x(), tmp.bottom());
-    gradient.setColorAt(0, mdiButtonGradientStartColor);
-    gradient.setColorAt(1, mdiButtonGradientStopColor);
-    QColor mdiButtonBorderColor(active ? option->palette.highlight().color().darker(180): dark.darker(110));
-
-    painter->setPen(QPen(mdiButtonBorderColor, 1));
-    const QLine lines[4] = {
-        QLine(tmp.left() + 2, tmp.top(), tmp.right() - 2, tmp.top()),
-        QLine(tmp.left() + 2, tmp.bottom(), tmp.right() - 2, tmp.bottom()),
-        QLine(tmp.left(), tmp.top() + 2, tmp.left(), tmp.bottom() - 2),
-        QLine(tmp.right(), tmp.top() + 2, tmp.right(), tmp.bottom() - 2)
-    };
-    painter->drawLines(lines, 4);
-    const QPoint points[4] = {
-        QPoint(tmp.left() + 1, tmp.top() + 1),
-        QPoint(tmp.right() - 1, tmp.top() + 1),
-        QPoint(tmp.left() + 1, tmp.bottom() - 1),
-        QPoint(tmp.right() - 1, tmp.bottom() - 1)
-    };
-    painter->drawPoints(points, 4);
-
-    painter->setPen(titleBarHighlight);
-    painter->drawLine(tmp.left() + 2, tmp.top() + 1, tmp.right() - 2, tmp.top() + 1);
-    painter->drawLine(tmp.left() + 1, tmp.top() + 2, tmp.left() + 1, tmp.bottom() - 2);
-
-    painter->setPen(QPen(gradient, 1));
-    painter->drawLine(tmp.right() + 1, tmp.top() + 2, tmp.right() + 1, tmp.bottom() - 2);
-    painter->drawPoint(tmp.right() , tmp.top() + 1);
-
-    painter->drawLine(tmp.left() + 2, tmp.bottom() + 1, tmp.right() - 2, tmp.bottom() + 1);
-    painter->drawPoint(tmp.left() + 1, tmp.bottom());
-    painter->drawPoint(tmp.right() - 1, tmp.bottom());
-    painter->drawPoint(tmp.right() , tmp.bottom() - 1);
-}
-
-/*!
-    \class QCleanlooksStyle
-    \brief The QCleanlooksStyle class provides a widget style similar to the
-    Clearlooks style available in GNOME.
-    \since 4.2
-
-    \inmodule QtWidgets
- 
-    The Cleanlooks style provides a look and feel for widgets
-    that closely resembles the Clearlooks style, introduced by Richard
-    Stellingwerff and Daniel Borgmann.
-
-    \sa {Cleanlooks Style Widget Gallery}, QWindowsXPStyle, QMacStyle, QWindowsStyle,
-        QPlastiqueStyle
-*/
-
-/*!
-    Constructs a QCleanlooksStyle object.
-*/
-QCleanlooksStyle::QCleanlooksStyle() : QWindowsStyle(*new QCleanlooksStylePrivate)
-{
-    setObjectName(QLatin1String("CleanLooks"));
-}
-
-/*!
-    \internal
-
-    Constructs a QCleanlooksStyle object.
-*/
-QCleanlooksStyle::QCleanlooksStyle(QCleanlooksStylePrivate &dd) : QWindowsStyle(dd)
-{
-}
-
-/*!
-    Destroys the QCleanlooksStyle object.
-*/
-QCleanlooksStyle::~QCleanlooksStyle()
-{
-}
-
-/*!
-    \fn void QCleanlooksStyle::drawItemText(QPainter *painter, const QRect &rectangle, int alignment, const QPalette &palette,
-                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
-
-    Draws the given \a text in the specified \a rectangle using the
-    provided \a painter and \a palette.
-
-    Text is drawn using the painter's pen. If an explicit \a textRole
-    is specified, then the text is drawn using the \a palette's color
-    for the specified role.  The \a enabled value indicates whether or
-    not the item is enabled; when reimplementing, this value should
-    influence how the item is drawn.
-
-    The text is aligned and wrapped according to the specified \a
-    alignment.
-
-    \sa Qt::Alignment
-*/
-void QCleanlooksStyle::drawItemText(QPainter *painter, const QRect &rect, int alignment, const QPalette &pal,
-                                    bool enabled, const QString& text, QPalette::ColorRole textRole) const
-{
-    if (text.isEmpty())
-        return;
-
-    QPen savedPen = painter->pen();
-    if (textRole != QPalette::NoRole) {
-        painter->setPen(QPen(pal.brush(textRole), savedPen.widthF()));
-    }
-    if (!enabled) {
-        QPen pen = painter->pen();
-        painter->setPen(pen);
-    }
-    painter->drawText(rect, alignment, text);
-    painter->setPen(savedPen);
-}
-
-static QColor mergedColors(const QColor &colorA, const QColor &colorB, int factor = 50)
-{
-    const int maxFactor = 100;
-    QColor tmp = colorA;
-    tmp.setRed((tmp.red() * factor) / maxFactor + (colorB.red() * (maxFactor - factor)) / maxFactor);
-    tmp.setGreen((tmp.green() * factor) / maxFactor + (colorB.green() * (maxFactor - factor)) / maxFactor);
-    tmp.setBlue((tmp.blue() * factor) / maxFactor + (colorB.blue() * (maxFactor - factor)) / maxFactor);
-    return tmp;
-}
-
-/*!
-    \reimp
-*/
-void QCleanlooksStyle::drawPrimitive(PrimitiveElement elem,
-                        const QStyleOption *option,
-                        QPainter *painter, const QWidget *widget) const
-{
-    Q_ASSERT(option);
-    QRect rect = option->rect;
-    int state = option->state;
-    QColor button = option->palette.button().color();
-    QColor buttonShadow = option->palette.button().color().darker(110);
-    QColor buttonShadowAlpha = buttonShadow;
-    buttonShadowAlpha.setAlpha(128);
-    QColor darkOutline;
-    QColor dark;
-    darkOutline.setHsv(button.hue(),
-                qMin(255, (int)(button.saturation()*3.0)),
-                qMin(255, (int)(button.value()*0.6)));
-    dark.setHsv(button.hue(),
-                qMin(255, (int)(button.saturation()*1.9)),
-                qMin(255, (int)(button.value()*0.7)));
-    QColor tabFrameColor = mergedColors(option->palette.background().color(),
-                                                dark.lighter(135), 60);
-
-    switch(elem) {
-#ifndef QT_NO_TABBAR
-    case PE_FrameTabBarBase:
-        if (const QStyleOptionTabBarBase *tbb
-                = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
-            painter->save();
-            painter->setPen(QPen(darkOutline.lighter(110), 0));
-            switch (tbb->shape) {
-            case QTabBar::RoundedNorth: {
-                QRegion region(tbb->rect);
-                region -= tbb->selectedTabRect;
-                painter->drawLine(tbb->rect.topLeft(), tbb->rect.topRight());
-                painter->setClipRegion(region);
-                painter->setPen(option->palette.light().color());
-                painter->drawLine(tbb->rect.topLeft() + QPoint(0, 1),
-                                  tbb->rect.topRight()  + QPoint(0, 1));
-            }
-                break;
-            case QTabBar::RoundedWest:
-                painter->drawLine(tbb->rect.left(), tbb->rect.top(), tbb->rect.left(), tbb->rect.bottom());
-                break;
-            case QTabBar::RoundedSouth:
-                painter->drawLine(tbb->rect.left(), tbb->rect.bottom(),
-                            tbb->rect.right(), tbb->rect.bottom());
-                break;
-            case QTabBar::RoundedEast:
-                painter->drawLine(tbb->rect.topRight(), tbb->rect.bottomRight());
-                break;
-            case QTabBar::TriangularNorth:
-            case QTabBar::TriangularEast:
-            case QTabBar::TriangularWest:
-            case QTabBar::TriangularSouth:
-                painter->restore();
-                QWindowsStyle::drawPrimitive(elem, option, painter, widget);
-                return;
-            }
-            painter->restore();
-        }
-        return;
-#endif // QT_NO_TABBAR
-    case PE_IndicatorViewItemCheck:
-        {
-            QStyleOptionButton button;
-            button.QStyleOption::operator=(*option);
-            button.state &= ~State_MouseOver;
-            proxy()->drawPrimitive(PE_IndicatorCheckBox, &button, painter, widget);
-        }
-        return;
-    case PE_IndicatorHeaderArrow:
-        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
-            QRect r = header->rect;
-            QImage arrow;
-            if (header->sortIndicator & QStyleOptionHeader::SortUp)
-                arrow = QImage(qt_cleanlooks_arrow_up_xpm);
-            else if (header->sortIndicator & QStyleOptionHeader::SortDown)
-                arrow = QImage(qt_cleanlooks_arrow_down_xpm);
-            if (!arrow.isNull()) {
-                r.setSize(arrow.size());
-                r.moveCenter(header->rect.center());
-                arrow.setColor(1, header->palette.foreground().color().rgba());
-                painter->drawImage(r, arrow);
-            }
-        }
-        break;
-    case PE_IndicatorButtonDropDown:
-        proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
-        break;
-    case PE_IndicatorToolBarSeparator:
-        {
-            QRect rect = option->rect;
-            const int margin = 6;
-            if (option->state & State_Horizontal) {
-                const int offset = rect.width()/2;
-                painter->setPen(QPen(option->palette.background().color().darker(110)));
-                painter->drawLine(rect.bottomLeft().x() + offset,
-                            rect.bottomLeft().y() - margin,
-                            rect.topLeft().x() + offset,
-                            rect.topLeft().y() + margin);
-                painter->setPen(QPen(option->palette.background().color().lighter(110)));
-                painter->drawLine(rect.bottomLeft().x() + offset + 1,
-                            rect.bottomLeft().y() - margin,
-                            rect.topLeft().x() + offset + 1,
-                            rect.topLeft().y() + margin);
-            } else { //Draw vertical separator
-                const int offset = rect.height()/2;
-                painter->setPen(QPen(option->palette.background().color().darker(110)));
-                painter->drawLine(rect.topLeft().x() + margin ,
-                            rect.topLeft().y() + offset,
-                            rect.topRight().x() - margin,
-                            rect.topRight().y() + offset);
-                painter->setPen(QPen(option->palette.background().color().lighter(110)));
-                painter->drawLine(rect.topLeft().x() + margin ,
-                            rect.topLeft().y() + offset + 1,
-                            rect.topRight().x() - margin,
-                            rect.topRight().y() + offset + 1);
-            }
-        }
-        break;
-    case PE_Frame:
-        painter->save();
-        painter->setPen(dark.lighter(108));
-        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
-        painter->restore();
-        break;
-    case PE_FrameMenu:
-        painter->save();
-        {
-            painter->setPen(QPen(darkOutline, 1));
-            painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
-            QColor frameLight = option->palette.background().color().lighter(160);
-            QColor frameShadow = option->palette.background().color().darker(110);
-
-            //paint beveleffect
-            QRect frame = option->rect.adjusted(1, 1, -1, -1);
-            painter->setPen(frameLight);
-            painter->drawLine(frame.topLeft(), frame.bottomLeft());
-            painter->drawLine(frame.topLeft(), frame.topRight());
-
-            painter->setPen(frameShadow);
-            painter->drawLine(frame.topRight(), frame.bottomRight());
-            painter->drawLine(frame.bottomLeft(), frame.bottomRight());
-        }
-        painter->restore();
-        break;
-    case PE_FrameDockWidget:
-
-        painter->save();
-        {
-            QColor softshadow = option->palette.background().color().darker(120);
-
-            QRect rect= option->rect;
-            painter->setPen(softshadow);
-            painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
-            painter->setPen(QPen(option->palette.light(), 0));
-            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1), QPoint(rect.left() + 1, rect.bottom() - 1));
-            painter->setPen(QPen(option->palette.background().color().darker(120), 0));
-            painter->drawLine(QPoint(rect.left() + 1, rect.bottom() - 1), QPoint(rect.right() - 2, rect.bottom() - 1));
-            painter->drawLine(QPoint(rect.right() - 1, rect.top() + 1), QPoint(rect.right() - 1, rect.bottom() - 1));
-
-        }
-        painter->restore();
-        break;
-    case PE_PanelButtonTool:
-        painter->save();
-        if ((option->state & State_Enabled || option->state & State_On) || !(option->state & State_AutoRaise)) {
-            QPen oldPen = painter->pen();
-
-            if (widget && widget->inherits("QDockWidgetTitleButton")) {
-                   if (option->state & State_MouseOver)
-                       proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
-            } else {
-                proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
-            }
-        }
-        painter->restore();
-        break;
-    case PE_IndicatorDockWidgetResizeHandle:
-        {
-            QStyleOption dockWidgetHandle = *option;
-            bool horizontal = option->state & State_Horizontal;
-            if (horizontal)
-                dockWidgetHandle.state &= ~State_Horizontal;
-            else
-                dockWidgetHandle.state |= State_Horizontal;
-            proxy()->drawControl(CE_Splitter, &dockWidgetHandle, painter, widget);
-        }
-        break;
-    case PE_FrameWindow:
-        painter->save();
-        {
-            QRect rect= option->rect;
-            painter->setPen(QPen(dark.darker(150), 0));
-            painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
-            painter->setPen(QPen(option->palette.light(), 0));
-            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
-                              QPoint(rect.left() + 1, rect.bottom() - 1));
-            painter->setPen(QPen(option->palette.background().color().darker(120), 0));
-            painter->drawLine(QPoint(rect.left() + 1, rect.bottom() - 1),
-                              QPoint(rect.right() - 2, rect.bottom() - 1));
-            painter->drawLine(QPoint(rect.right() - 1, rect.top() + 1),
-                              QPoint(rect.right() - 1, rect.bottom() - 1));
-        }
-        painter->restore();
-        break;
-#ifndef QT_NO_LINEEDIT
-    case PE_FrameLineEdit:
-        // fall through
-#endif // QT_NO_LINEEDIT
-        {
-            QPen oldPen = painter->pen();
-            if (option->state & State_Enabled) {
-                painter->setPen(QPen(option->palette.background(), 0));
-                painter->drawRect(rect.adjusted(0, 0, 0, 0));
-                painter->drawRect(rect.adjusted(1, 1, -1, -1));
-            } else {
-                painter->fillRect(rect, option->palette.background());
-            }
-            QRect r = rect.adjusted(0, 1, 0, -1);
-            painter->setPen(buttonShadowAlpha);
-            painter->drawLine(QPoint(r.left() + 2, r.top() - 1), QPoint(r.right() - 2, r.top() - 1));
-            const QPoint points[8] = {
-                QPoint(r.right() - 1, r.top()),
-                QPoint(r.right(), r.top() + 1),
-                QPoint(r.right() - 1, r.bottom()),
-                QPoint(r.right(), r.bottom() - 1),
-                QPoint(r.left() + 1, r.top() ),
-                QPoint(r.left(), r.top() + 1),
-                QPoint(r.left() + 1, r.bottom() ),
-                QPoint(r.left(), r.bottom() - 1)
-            };
-            painter->drawPoints(points, 8);
-            painter->setPen(QPen(option->palette.background().color(), 1));
-            painter->drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
-
-            if (option->state & State_HasFocus) {
-                QColor darkoutline = option->palette.highlight().color().darker(150);
-                QColor innerline = mergedColors(option->palette.highlight().color(), Qt::white);
-                painter->setPen(QPen(innerline, 0));
-                painter->drawRect(rect.adjusted(1, 2, -2, -3));
-                painter->setPen(QPen(darkoutline, 0));
-            }
-            else {
-                QColor highlight = Qt::white;
-                highlight.setAlpha(130);
-                painter->setPen(option->palette.base().color().darker(120));
-                painter->drawLine(QPoint(r.left() + 1, r.top() + 1),
-                                  QPoint(r.right() - 1, r.top() + 1));
-                painter->drawLine(QPoint(r.left() + 1, r.top() + 1),
-                                  QPoint(r.left() + 1, r.bottom() - 1));
-                painter->setPen(option->palette.base().color());
-                painter->drawLine(QPoint(r.right() - 1, r.top() + 1),
-                                  QPoint(r.right() - 1, r.bottom() - 1));
-                painter->setPen(highlight);
-                painter->drawLine(QPoint(r.left() + 1, r.bottom() + 1),
-                                  QPoint(r.right() - 1, r.bottom() + 1));
-                painter->drawPoint(QPoint(r.left(), r.bottom()));
-                painter->drawPoint(QPoint(r.right(), r.bottom() ));
-                painter->setPen(QPen(darkOutline.lighter(115), 1));
-            }
-            painter->drawLine(QPoint(r.left(), r.top() + 2), QPoint(r.left(), r.bottom() - 2));
-            painter->drawLine(QPoint(r.right(), r.top() + 2), QPoint(r.right(), r.bottom() - 2));
-            painter->drawLine(QPoint(r.left() + 2, r.bottom()), QPoint(r.right() - 2, r.bottom()));
-            const QPoint points2[4] = {
-                QPoint(r.right() - 1, r.bottom() - 1),
-                QPoint(r.right() - 1, r.top() + 1),
-                QPoint(r.left() + 1, r.bottom() - 1),
-                QPoint(r.left() + 1, r.top() + 1)
-            };
-            painter->drawPoints(points2, 4);
-            painter->drawLine(QPoint(r.left() + 2, r.top()), QPoint(r.right() - 2, r.top()));
-            painter->setPen(oldPen);
-        }
-        break;
-    case PE_IndicatorCheckBox:
-        painter->save();
-        if (const QStyleOptionButton *checkbox = qstyleoption_cast<const QStyleOptionButton*>(option)) {
-            QRect checkRect;
-            checkRect.setX(rect.left() );
-            checkRect.setY(rect.top() );
-            checkRect.setWidth(rect.width() - 1);
-            checkRect.setHeight(rect.height() - 1);
-            if (state & State_Sunken)
-                painter->setBrush(dark.lighter(130));
-            else
-                painter->setBrush(option->palette.base());
-            painter->setPen(QPen(dark.lighter(110), 0));
-            painter->drawRect(checkRect);
-            if (checkbox->state & (State_On | State_Sunken  | State_NoChange)) {
-                QImage image(qt_cleanlooks_checkbox_checked);
-                QColor fillColor = option->palette.text().color();
-                image.setColor(1, fillColor.rgba()); 
-                fillColor.setAlpha(100);
-                image.setColor(2, fillColor.rgba()); 
-                painter->drawImage(rect, image);
-                if (checkbox->state & State_NoChange) {
-                    QColor bgc = option->palette.background().color();
-                    bgc.setAlpha(127);
-                    painter->fillRect(checkRect.adjusted(1, 1, -1, -1), bgc);
-                }
-            }
-        }
-        painter->restore();
-        break;
-    case PE_IndicatorRadioButton:
-        painter->save();
-        {
-            painter->setRenderHint(QPainter::SmoothPixmapTransform);
-            QRect checkRect = rect.adjusted(0, 0, 0, 0);
-            if (state & (State_On )) {
-                painter->drawImage(rect, QImage(qt_cleanlooks_radiobutton));
-                painter->drawImage(checkRect, QImage(qt_cleanlooks_radiobutton_checked));
-            }
-            else if (state & State_Sunken) {
-                painter->drawImage(rect, QImage(qt_cleanlooks_radiobutton));
-                QColor bgc = buttonShadow;
-                painter->setRenderHint(QPainter::Antialiasing);
-                painter->setBrush(bgc);
-                painter->setPen(Qt::NoPen);
-                painter->drawEllipse(rect.adjusted(1, 1, -1, -1));                }
-            else {
-                painter->drawImage(rect, QImage(qt_cleanlooks_radiobutton));
-            }
-        }
-        painter->restore();
-    break;
-    case PE_IndicatorToolBarHandle:
-        painter->save();
-        if (option->state & State_Horizontal) {
-            for (int i = rect.height()/5; i <= 4*(rect.height()/5) ; ++i) {
-                int y = rect.topLeft().y() + i + 1;
-                int x1 = rect.topLeft().x() + 3;
-                int x2 = rect.topRight().x() - 2;
-
-                if (i % 2 == 0)
-                    painter->setPen(QPen(option->palette.light(), 0));
-                else
-                    painter->setPen(QPen(dark.lighter(110), 0));
-                painter->drawLine(x1, y, x2, y);
-            }
-        }
-        else { //vertical toolbar
-            for (int i = rect.width()/5; i <= 4*(rect.width()/5) ; ++i) {
-                int x = rect.topLeft().x() + i + 1;
-                int y1 = rect.topLeft().y() + 3;
-                int y2 = rect.topLeft().y() + 5;
-
-                if (i % 2 == 0)
-                    painter->setPen(QPen(option->palette.light(), 0));
-                else
-                    painter->setPen(QPen(dark.lighter(110), 0));
-                painter->drawLine(x, y1, x, y2);
-            }
-        }
-        painter->restore();
-        break;
-    case PE_FrameDefaultButton:
-        case PE_FrameFocusRect:
-        if (const QStyleOptionFocusRect *focusFrame = qstyleoption_cast<const QStyleOptionFocusRect *>(option)) {
-            if (!(focusFrame->state & State_KeyboardFocusChange))
-                return;
-            QRect rect = focusFrame->rect;
-            painter->save();
-            painter->setBackgroundMode(Qt::TransparentMode);
-            painter->setBrush(QBrush(dark.darker(120), Qt::Dense4Pattern));
-            painter->setBrushOrigin(rect.topLeft());
-            painter->setPen(Qt::NoPen);
-            const QRect rects[4] = {
-                QRect(rect.left(), rect.top(), rect.width(), 1),    // Top
-                QRect(rect.left(), rect.bottom(), rect.width(), 1), // Bottom
-                QRect(rect.left(), rect.top(), 1, rect.height()),   // Left
-                QRect(rect.right(), rect.top(), 1, rect.height())   // Right
-            };
-            painter->drawRects(rects, 4);
-            painter->restore();
-        }
-        break;
-    case PE_PanelButtonCommand:
-        {
-            bool isDefault = false;
-            bool isFlat = false;
-            bool isDown = (option->state & State_Sunken) || (option->state & State_On);
-            QPen oldPen = painter->pen();
-            QBrush oldBrush = painter->brush();
-            QRect r;
-
-            if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton*>(option)) {
-                isDefault = (button->features & QStyleOptionButton::DefaultButton) && (button->state & State_Enabled);
-                isFlat = (button->features & QStyleOptionButton::Flat);
-            }
-
-            if (isFlat && !isDown) {
-                if (isDefault) {
-                    r = option->rect.adjusted(0, 1, 0, -1);
-                    painter->setPen(QPen(Qt::black, 0));
-                    const QLine lines[4] = {
-                        QLine(QPoint(r.left() + 2, r.top()),
-                              QPoint(r.right() - 2, r.top())),
-                        QLine(QPoint(r.left(), r.top() + 2),
-                              QPoint(r.left(), r.bottom() - 2)),
-                        QLine(QPoint(r.right(), r.top() + 2),
-                              QPoint(r.right(), r.bottom() - 2)),
-                        QLine(QPoint(r.left() + 2, r.bottom()),
-                              QPoint(r.right() - 2, r.bottom()))
-                    };
-                    painter->drawLines(lines, 4);
-                    const QPoint points[4] = {
-                        QPoint(r.right() - 1, r.bottom() - 1),
-                        QPoint(r.right() - 1, r.top() + 1),
-                        QPoint(r.left() + 1, r.bottom() - 1),
-                        QPoint(r.left() + 1, r.top() + 1)
-                    };
-                    painter->drawPoints(points, 4);
-                    painter->setPen(oldPen);
-                }
-                return;
-            }
-
-            BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("pushbutton-%1").arg(isDefault))
-            r = rect.adjusted(0, 1, 0, -1);
-
-            bool isEnabled = (option->state & State_Enabled);
-
-            QColor highlightedGradientStartColor = option->palette.button().color().lighter(107);
-            QColor highlightedGradientMidColor = option->palette.button().color().lighter(105);
-            QColor highlightedGradientStopColor = buttonShadow.lighter(107);
-            QColor gradientStartColor = option->palette.button().color().lighter(108);
-
-            QColor buttonColor = option->palette.button().color();
-            QColor gradientMidColor = option->palette.button().color();
-            QColor gradientStopColor;
-            gradientStopColor.setHsv(buttonColor.hue(),
-                                     qMin(255, (int)(buttonColor.saturation()*1.9)),
-                                     qMin(255, (int)(buttonColor.value()*0.96)));
-
-            QRect gradRect = rect.adjusted(1, 2, -1, -2);
-            // gradient fill
-            QRect innerBorder = r.adjusted(1, 1, -1, 0);
-
-            if (isDown) {
-                QBrush fillColor = gradientStopColor.darker(110);
-                if (option->palette.button().gradient())
-                    fillColor = option->palette.button();
-                p->fillRect(gradRect, fillColor);
-                p->setPen(gradientStopColor.darker(125));
-                p->drawLine(innerBorder.topLeft(), innerBorder.topRight());
-                p->drawLine(innerBorder.topLeft(), innerBorder.bottomLeft());
-            } else {
-                if (isEnabled && option->state & State_MouseOver ) {
-                    qt_cleanlooks_draw_buttongradient(p, gradRect,
-                                                highlightedGradientStartColor,
-                                                highlightedGradientMidColor,
-                                                highlightedGradientStopColor, TopDown, option->palette.button());
-                } else {
-                    qt_cleanlooks_draw_buttongradient(p, gradRect,
-                                                gradientStartColor,
-                                                gradientMidColor,
-                                                gradientStopColor, TopDown, option->palette.button());
-                }
-            }
-
-            bool hasFocus = option->state & State_HasFocus;
-
-            if (!isEnabled)
-                p->setPen(QPen(dark.lighter(115)));
-            else if (isDefault)
-                p->setPen(QPen(Qt::black, 1));
-            else
-                p->setPen(QPen(darkOutline, 1));
-
-            p->drawLine(QPoint(r.left(), r.top() + 2),
-                              QPoint(r.left(), r.bottom() - 2));
-            p->drawLine(QPoint(r.right(), r.top() + 2),
-                              QPoint(r.right(), r.bottom() - 2));
-            p->drawLine(QPoint(r.left() + 2, r.bottom()),
-                              QPoint(r.right() - 2, r.bottom()));
-            const QPoint points[4] = {
-                QPoint(r.right() - 1, r.bottom() - 1),
-                QPoint(r.right() - 1, r.top() + 1),
-                QPoint(r.left() + 1, r.bottom() - 1),
-                QPoint(r.left() + 1, r.top() + 1)
-            };
-            p->drawPoints(points, 4);
-
-            if (!isDefault && !hasFocus && isEnabled)
-                p->setPen(QPen(darkOutline.darker(110), 0));
-
-            p->drawLine(QPoint(r.left() + 2, r.top()),
-                              QPoint(r.right() - 2, r.top()));
-
-            QColor highlight = Qt::white;
-            highlight.setAlpha(110);
-            p->setPen(highlight);
-            p->drawLine(QPoint(r.left() + 1, r.top() + 2),
-                              QPoint(r.left() + 1, r.bottom() - 2));
-            p->drawLine(QPoint(r.left() + 3, r.bottom() + 1),
-                              QPoint(r.right() - 3, r.bottom() + 1));
-
-            QColor topShadow = darkOutline;
-            topShadow.setAlpha(60);
-
-            p->setPen(topShadow);
-            const QPoint points2[8] = {
-                QPoint(r.right(), r.top() + 1),
-                QPoint(r.right() - 1, r.top() ),
-                QPoint(r.right(), r.bottom() - 1),
-                QPoint(r.right() - 1, r.bottom() ),
-                QPoint(r.left() + 1, r.bottom()),
-                QPoint(r.left(), r.bottom() - 1),
-                QPoint(r.left() + 1, r.top()),
-                QPoint(r.left(), r.top() + 1)
-            };
-            p->drawPoints(points2, 8);
-
-            topShadow.setAlpha(30);
-            p->setPen(topShadow);
-
-            p->drawLine(QPoint(r.right() - 1, r.top() + 2),
-                              QPoint(r.right() - 1, r.bottom() - 2));
-            p->drawLine(QPoint(r.left() + 2, r.top() - 1),
-                              QPoint(r.right() - 2, r.top() - 1));
-
-            if (isDefault) {
-                r.adjust(-1, -1, 1, 1);
-                p->setPen(buttonShadowAlpha.darker(120));
-                const QLine lines[4] = {
-                    QLine(r.topLeft() + QPoint(3, 0), r.topRight() - QPoint(3, 0)),
-                    QLine(r.bottomLeft() + QPoint(3, 0), r.bottomRight() - QPoint(3, 0)),
-                    QLine(r.topLeft() + QPoint(0, 3), r.bottomLeft() - QPoint(0, 3)),
-                    QLine(r.topRight() + QPoint(0, 3), r.bottomRight() - QPoint(0, 3))
-                };
-                p->drawLines(lines, 4);
-                const QPoint points3[8] = {
-                    r.topRight() + QPoint(-2, 1),
-                    r.topRight() + QPoint(-1, 2),
-                    r.bottomRight() + QPoint(-1, -2),
-                    r.bottomRight() + QPoint(-2, -1),
-                    r.topLeft() + QPoint(1, 2),
-                    r.topLeft() + QPoint(2, 1),
-                    r.bottomLeft() + QPoint(1, -2),
-                    r.bottomLeft() + QPoint(2, -1)
-                };
-                p->drawPoints(points3, 8);
-            }
-            painter->setPen(oldPen);
-            painter->setBrush(oldBrush);
-            END_STYLE_PIXMAPCACHE
-        }
-        break;
-#ifndef QT_NO_TABBAR
-        case PE_FrameTabWidget:
-            painter->save();
-        {
-            painter->fillRect(option->rect, tabFrameColor);
-        }
-#ifndef QT_NO_TABWIDGET
-        if (const QStyleOptionTabWidgetFrame *twf = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(option)) {
-            QColor borderColor = darkOutline.lighter(110);
-            QColor alphaCornerColor = mergedColors(borderColor, option->palette.background().color());
-
-            int borderThickness = proxy()->pixelMetric(PM_TabBarBaseOverlap, twf, widget);
-            bool reverse = (twf->direction == Qt::RightToLeft);
-            QRect tabBarRect;
-
-            switch (twf->shape) {
-            case QTabBar::RoundedNorth:
-                if (reverse) {
-                    tabBarRect = QRect(twf->rect.right() - twf->leftCornerWidgetSize.width()
-                                       - twf->tabBarSize.width() + 1,
-                                       twf->rect.top(),
-                                       twf->tabBarSize.width(), borderThickness);
-                } else {
-                    tabBarRect = QRect(twf->rect.left() + twf->leftCornerWidgetSize.width(),
-                                       twf->rect.top(),
-                                       twf->tabBarSize.width(), borderThickness);
-                }
-                break ;
-            case QTabBar::RoundedWest:
-                tabBarRect = QRect(twf->rect.left(),
-                                   twf->rect.top() + twf->leftCornerWidgetSize.height(),
-                                   borderThickness,
-                                   twf->tabBarSize.height());
-                tabBarRect = tabBarRect; //adjust
-                break ;
-            case QTabBar::RoundedEast:
-                tabBarRect = QRect(twf->rect.right() - borderThickness + 1,
-                                   twf->rect.top()  + twf->leftCornerWidgetSize.height(),
-                                   0,
-                                   twf->tabBarSize.height());
-                break ;
-            case QTabBar::RoundedSouth:
-                if (reverse) {
-                    tabBarRect = QRect(twf->rect.right() - twf->leftCornerWidgetSize.width() - twf->tabBarSize.width() + 1,
-                                       twf->rect.bottom() + 1,
-                                       twf->tabBarSize.width(),
-                                       borderThickness);
-                } else {
-                    tabBarRect = QRect(twf->rect.left() + twf->leftCornerWidgetSize.width(),
-                                       twf->rect.bottom() + 1,
-                                       twf->tabBarSize.width(),
-                                       borderThickness);
-                }
-                break;
-            default:
-                break;
-            }
-
-            QRegion region(twf->rect);
-            region -= tabBarRect;
-            painter->setClipRegion(region);
-
-            // Outer border
-            QLine leftLine = QLine(twf->rect.topLeft() + QPoint(0, 2), twf->rect.bottomLeft() - QPoint(0, 2));
-            QLine rightLine = QLine(twf->rect.topRight(), twf->rect.bottomRight() - QPoint(0, 2));
-            QLine bottomLine = QLine(twf->rect.bottomLeft() + QPoint(2, 0), twf->rect.bottomRight() - QPoint(2, 0));
-            QLine topLine = QLine(twf->rect.topLeft(), twf->rect.topRight());
-
-            painter->setPen(borderColor);
-            painter->drawLine(topLine);
-
-            // Inner border
-            QLine innerLeftLine = QLine(leftLine.p1() + QPoint(1, 0), leftLine.p2() + QPoint(1, 0));
-            QLine innerRightLine = QLine(rightLine.p1() - QPoint(1, -1), rightLine.p2() - QPoint(1, 0));
-            QLine innerBottomLine = QLine(bottomLine.p1() - QPoint(0, 1), bottomLine.p2() - QPoint(0, 1));
-            QLine innerTopLine = QLine(topLine.p1() + QPoint(0, 1), topLine.p2() + QPoint(-1, 1));
-
-            // Rounded Corner
-            QPoint leftBottomOuterCorner = QPoint(innerLeftLine.p2() + QPoint(0, 1));
-            QPoint leftBottomInnerCorner1 = QPoint(leftLine.p2() + QPoint(0, 1));
-            QPoint leftBottomInnerCorner2 = QPoint(bottomLine.p1() - QPoint(1, 0));
-            QPoint rightBottomOuterCorner = QPoint(innerRightLine.p2() + QPoint(0, 1));
-            QPoint rightBottomInnerCorner1 = QPoint(rightLine.p2() + QPoint(0, 1));
-            QPoint rightBottomInnerCorner2 = QPoint(bottomLine.p2() + QPoint(1, 0));
-            QPoint leftTopOuterCorner = QPoint(innerLeftLine.p1() - QPoint(0, 1));
-            QPoint leftTopInnerCorner1 = QPoint(leftLine.p1() - QPoint(0, 1));
-            QPoint leftTopInnerCorner2 = QPoint(topLine.p1() - QPoint(1, 0));
-
-            painter->setPen(borderColor);
-            painter->drawLine(leftLine);
-            painter->drawLine(rightLine);
-            painter->drawLine(bottomLine);
-            painter->drawPoint(leftBottomOuterCorner);
-            painter->drawPoint(rightBottomOuterCorner);
-            painter->drawPoint(leftTopOuterCorner);
-
-            painter->setPen(option->palette.light().color());
-            painter->drawLine(innerLeftLine);
-            painter->drawLine(innerTopLine);
-
-            painter->setPen(buttonShadowAlpha);
-            painter->drawLine(innerRightLine);
-            painter->drawLine(innerBottomLine);
-
-            painter->setPen(alphaCornerColor);
-            const QPoint points[6] = {
-                leftBottomInnerCorner1,
-                leftBottomInnerCorner2,
-                rightBottomInnerCorner1,
-                rightBottomInnerCorner2,
-                leftTopInnerCorner1,
-                leftTopInnerCorner2
-            };
-            painter->drawPoints(points, 6);
-        }
-#endif // QT_NO_TABWIDGET
-    painter->restore();
-    break ;
-
-    case PE_FrameStatusBarItem:
-        break;
-    case PE_IndicatorTabClose:
-        {
-            Q_D(const QCleanlooksStyle);
-            if (d->tabBarcloseButtonIcon.isNull())
-                d->tabBarcloseButtonIcon = standardIcon(SP_DialogCloseButton, option, widget);
-            if ((option->state & State_Enabled) && (option->state & State_MouseOver))
-                proxy()->drawPrimitive(PE_PanelButtonCommand, option, painter, widget);
-            QPixmap pixmap = d->tabBarcloseButtonIcon.pixmap(QSize(16, 16), QIcon::Normal, QIcon::On);
-            proxy()->drawItemPixmap(painter, option->rect, Qt::AlignCenter, pixmap);
-        }
-        break;
-
-#endif // QT_NO_TABBAR
-    default:
-        QWindowsStyle::drawPrimitive(elem, option, painter, widget);
-        break;
-    }
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::drawControl(ControlElement element, const QStyleOption *option, QPainter *painter,
-                                   const QWidget *widget) const
-{
-    QColor button = option->palette.button().color();
-    QColor dark;
-    dark.setHsv(button.hue(),
-                qMin(255, (int)(button.saturation()*1.9)),
-                qMin(255, (int)(button.value()*0.7)));
-    QColor darkOutline;
-    darkOutline.setHsv(button.hue(),
-                qMin(255, (int)(button.saturation()*2.0)),
-                qMin(255, (int)(button.value()*0.6)));
-    QRect rect = option->rect;
-    QColor shadow = mergedColors(option->palette.background().color().darker(120),
-                                 dark.lighter(130), 60);
-    QColor tabFrameColor = mergedColors(option->palette.background().color(),
-                                                dark.lighter(135), 60);
-
-    QColor highlight = option->palette.highlight().color();
-
-    switch(element) {
-     case CE_RadioButton: //fall through
-     case CE_CheckBox:
-        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
-            bool hover = (btn->state & State_MouseOver && btn->state & State_Enabled);
-            if (hover)
-                painter->fillRect(rect, btn->palette.background().color().lighter(104));
-            QStyleOptionButton copy = *btn;
-            copy.rect.adjust(2, 0, -2, 0);
-            QWindowsStyle::drawControl(element, &copy, painter, widget);
-        }
-        break;
-    case CE_Splitter:
-        painter->save();
-        {
-            // hover appearance
-            QBrush fillColor = option->palette.background().color();
-            if (option->state & State_MouseOver && option->state & State_Enabled)
-                fillColor = fillColor.color().lighter(106);
-
-            painter->fillRect(option->rect, fillColor);
-
-            QColor grooveColor = mergedColors(dark.lighter(110), option->palette.button().color(),40);
-            QColor gripShadow = grooveColor.darker(110);
-            QPalette palette = option->palette;
-            bool vertical = !(option->state & State_Horizontal);
-            QRect scrollBarSlider = option->rect;
-            int gripMargin = 4;
-            //draw grips
-            if (vertical) {
-                for( int i = -20; i< 20 ; i += 2) {
-                    painter->setPen(QPen(gripShadow, 1));
-                    painter->drawLine(
-                        QPoint(scrollBarSlider.center().x() + i ,
-                               scrollBarSlider.top() + gripMargin),
-                        QPoint(scrollBarSlider.center().x() + i,
-                               scrollBarSlider.bottom() - gripMargin));
-                    painter->setPen(QPen(palette.light(), 1));
-                    painter->drawLine(
-                        QPoint(scrollBarSlider.center().x() + i + 1,
-                               scrollBarSlider.top() + gripMargin  ),
-                        QPoint(scrollBarSlider.center().x() + i + 1,
-                               scrollBarSlider.bottom() - gripMargin));
-                }
-            } else {
-                for (int i = -20; i < 20 ; i += 2) {
-                    painter->setPen(QPen(gripShadow, 1));
-                    painter->drawLine(
-                        QPoint(scrollBarSlider.left() + gripMargin ,
-                               scrollBarSlider.center().y()+ i),
-                        QPoint(scrollBarSlider.right() - gripMargin,
-                               scrollBarSlider.center().y()+ i));
-                    painter->setPen(QPen(palette.light(), 1));
-                    painter->drawLine(
-                        QPoint(scrollBarSlider.left() + gripMargin,
-                               scrollBarSlider.center().y() + 1 + i),
-                        QPoint(scrollBarSlider.right() - gripMargin,
-                               scrollBarSlider.center().y() + 1 + i));
-
-                }
-            }
-        }
-        painter->restore();
-        break;
-#ifndef QT_NO_SIZEGRIP
-    case CE_SizeGrip:
-        painter->save();
-        {
-            int x, y, w, h;
-            option->rect.getRect(&x, &y, &w, &h);
-            int sw = qMin(h, w);
-            if (h > w)
-                painter->translate(0, h - w);
-            else
-                painter->translate(w - h, 0);
-
-            int sx = x;
-            int sy = y;
-            int s = 4;
-            if (option->direction == Qt::RightToLeft) {
-                sx = x + sw;
-                for (int i = 0; i < 4; ++i) {
-                    painter->setPen(QPen(option->palette.light().color(), 1));
-                    painter->drawLine(x, sy - 1 , sx + 1, sw);
-                    painter->setPen(QPen(dark.lighter(120), 1));
-                    painter->drawLine(x, sy, sx, sw);
-                    sx -= s;
-                    sy += s;
-                }
-            } else {
-                for (int i = 0; i < 4; ++i) {
-                    painter->setPen(QPen(option->palette.light().color(), 1));
-                    painter->drawLine(sx - 1, sw, sw, sy - 1);
-                    painter->setPen(QPen(dark.lighter(120), 1));
-                    painter->drawLine(sx, sw, sw, sy);
-                    sx += s;
-                    sy += s;
-                }
-            }
-        }
-        painter->restore();
-        break;
-#endif // QT_NO_SIZEGRIP
-#ifndef QT_NO_TOOLBAR
-    case CE_ToolBar:
-        // Reserve the beveled appearance only for mainwindow toolbars
-        if (!(widget && qobject_cast<const QMainWindow*> (widget->parentWidget())))
-            break;
-
-        painter->save();
-        if (const QStyleOptionToolBar *toolbar = qstyleoption_cast<const QStyleOptionToolBar *>(option)) {
-            QRect rect = option->rect;
-
-            bool paintLeftBorder = true;
-            bool paintRightBorder = true;
-            bool paintBottomBorder = true;
-
-            switch (toolbar->toolBarArea) {
-            case Qt::BottomToolBarArea:
-                switch(toolbar->positionOfLine) {
-                case QStyleOptionToolBar::Beginning:
-                case QStyleOptionToolBar::OnlyOne:
-                    paintBottomBorder = false;
-                default:
-                    break;
-                }
-            case Qt::TopToolBarArea:
-                switch (toolbar->positionWithinLine) {
-                case QStyleOptionToolBar::Beginning:
-                    paintLeftBorder = false;
-                    break;
-                case QStyleOptionToolBar::End:
-                    paintRightBorder = false;
-                    break;
-                case QStyleOptionToolBar::OnlyOne:
-                    paintRightBorder = false;
-                    paintLeftBorder = false;
-                default:
-                    break;
-                }
-                if (toolbar->direction == Qt::RightToLeft) { //reverse layout changes the order of Beginning/end
-                    bool tmp = paintLeftBorder;
-                    paintRightBorder=paintLeftBorder;
-                    paintLeftBorder=tmp;
-                }
-                break;
-            case Qt::RightToolBarArea:
-                switch (toolbar->positionOfLine) {
-                case QStyleOptionToolBar::Beginning:
-                case QStyleOptionToolBar::OnlyOne:
-                    paintRightBorder = false;
-                    break;
-                default:
-                    break;
-                }
-                break;
-            case Qt::LeftToolBarArea:
-                switch (toolbar->positionOfLine) {
-                case QStyleOptionToolBar::Beginning:
-                case QStyleOptionToolBar::OnlyOne:
-                    paintLeftBorder = false;
-                    break;
-                default:
-                    break;
-                }
-                break;
-            default:
-                break;
-            }
-
-            QColor light = option->palette.background().color().lighter(110);
-
-            //draw top border
-            painter->setPen(QPen(light));
-            painter->drawLine(rect.topLeft().x(),
-                        rect.topLeft().y(),
-                        rect.topRight().x(),
-                        rect.topRight().y());
-
-            if (paintLeftBorder) {
-                painter->setPen(QPen(light));
-                painter->drawLine(rect.topLeft().x(),
-                            rect.topLeft().y(),
-                            rect.bottomLeft().x(),
-                            rect.bottomLeft().y());
-            }
-
-            if (paintRightBorder) {
-                painter->setPen(QPen(shadow));
-                painter->drawLine(rect.topRight().x(),
-                            rect.topRight().y(),
-                            rect.bottomRight().x(),
-                            rect.bottomRight().y());
-            }
-
-            if (paintBottomBorder) {
-                painter->setPen(QPen(shadow));
-                painter->drawLine(rect.bottomLeft().x(),
-                            rect.bottomLeft().y(),
-                            rect.bottomRight().x(),
-                            rect.bottomRight().y());
-            }
-        }
-        painter->restore();
-        break;
-#endif // QT_NO_TOOLBAR
-#ifndef QT_NO_DOCKWIDGET
-    case CE_DockWidgetTitle:
-        painter->save();
-        if (const QStyleOptionDockWidget *dwOpt = qstyleoption_cast<const QStyleOptionDockWidget *>(option)) {
-            const QStyleOptionDockWidgetV2 *v2
-                = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(dwOpt);
-            bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
-
-            QRect titleRect = subElementRect(SE_DockWidgetTitleBarText, option, widget);
-            if (verticalTitleBar) {
-                QRect rect = dwOpt->rect;
-                QRect r = rect;
-                QSize s = r.size();
-                s.transpose();
-                r.setSize(s);
-                titleRect = QRect(r.left() + rect.bottom()
-                                    - titleRect.bottom(),
-                                r.top() + titleRect.left() - rect.left(),
-                                titleRect.height(), titleRect.width());
-            }
-
-            if (!dwOpt->title.isEmpty()) {
-                QString titleText
-                    = painter->fontMetrics().elidedText(dwOpt->title,
-                                            Qt::ElideRight, titleRect.width());
-                proxy()->drawItemText(painter,
-                             titleRect,
-                             Qt::AlignLeft | Qt::AlignVCenter | Qt::TextShowMnemonic, dwOpt->palette,
-                             dwOpt->state & State_Enabled, titleText,
-                             QPalette::WindowText);
-                }
-        }
-        painter->restore();
-        break;
-#endif // QT_NO_DOCKWIDGET
-    case CE_HeaderSection:
-        painter->save();
-        // Draws the header in tables.
-        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
-            QPixmap cache;
-            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("headersection"), option, option->rect.size());
-            pixmapName += QString::number(- int(header->position));
-            pixmapName += QString::number(- int(header->orientation));
-            QRect r = option->rect;
-            QColor gradientStopColor;
-            QColor gradientStartColor = option->palette.button().color();
-            gradientStopColor.setHsv(gradientStartColor.hue(),
-                                     qMin(255, (int)(gradientStartColor.saturation()*2)),
-                                     qMin(255, (int)(gradientStartColor.value()*0.96)));
-            QLinearGradient gradient(rect.topLeft(), rect.bottomLeft());
-            if (option->palette.background().gradient()) {
-                gradient.setStops(option->palette.background().gradient()->stops());
-            } else {
-                gradient.setColorAt(0, gradientStartColor);
-                gradient.setColorAt(0.8, gradientStartColor);
-                gradient.setColorAt(1, gradientStopColor);
-            }
-            painter->fillRect(r, gradient);
-
-            if (!QPixmapCache::find(pixmapName, cache)) {
-                cache = QPixmap(r.size());
-                cache.fill(Qt::transparent);
-                QRect pixmapRect(0, 0, r.width(), r.height());
-                QPainter cachePainter(&cache);
-                if (header->orientation == Qt::Vertical) {
-                    cachePainter.setPen(QPen(dark));
-                    cachePainter.drawLine(pixmapRect.topRight(), pixmapRect.bottomRight());
-                    if (header->position != QStyleOptionHeader::End) {
-                        cachePainter.setPen(QPen(shadow));
-                        cachePainter.drawLine(pixmapRect.bottomLeft() + QPoint(3, -1), pixmapRect.bottomRight() + QPoint(-3, -1));                                cachePainter.setPen(QPen(option->palette.light().color()));
-                        cachePainter.drawLine(pixmapRect.bottomLeft() + QPoint(3, 0), pixmapRect.bottomRight() + QPoint(-3, 0));                              }
-                } else {
-                    cachePainter.setPen(QPen(dark));
-                    cachePainter.drawLine(pixmapRect.bottomLeft(), pixmapRect.bottomRight());
-                    cachePainter.setPen(QPen(shadow));
-                    cachePainter.drawLine(pixmapRect.topRight() + QPoint(-1, 3), pixmapRect.bottomRight() + QPoint(-1, -3));                                  cachePainter.setPen(QPen(option->palette.light().color()));
-                    cachePainter.drawLine(pixmapRect.topRight() + QPoint(0, 3), pixmapRect.bottomRight() + QPoint(0, -3));                                }
-                cachePainter.end();
-                QPixmapCache::insert(pixmapName, cache);
-            }
-            painter->drawPixmap(r.topLeft(), cache);
-        }
-        painter->restore();
-        break;
-    case CE_ProgressBarGroove:
-        painter->save();
-        {
-            painter->fillRect(rect, option->palette.base());
-            QColor borderColor = dark.lighter(110);
-            painter->setPen(QPen(borderColor, 0));
-            const QLine lines[4] = {
-                QLine(QPoint(rect.left() + 1, rect.top()), QPoint(rect.right() - 1, rect.top())),
-                QLine(QPoint(rect.left() + 1, rect.bottom()), QPoint(rect.right() - 1, rect.bottom())),
-                QLine(QPoint(rect.left(), rect.top() + 1), QPoint(rect.left(), rect.bottom() - 1)),
-                QLine(QPoint(rect.right(), rect.top() + 1), QPoint(rect.right(), rect.bottom() - 1))
-            };
-            painter->drawLines(lines, 4);
-            QColor alphaCorner = mergedColors(borderColor, option->palette.background().color());
-            QColor innerShadow = mergedColors(borderColor, option->palette.base().color());
-
-            //corner smoothing
-            painter->setPen(alphaCorner);
-            const QPoint points[4] = {
-                rect.topRight(),
-                rect.topLeft(),
-                rect.bottomRight(),
-                rect.bottomLeft()
-            };
-            painter->drawPoints(points, 4);
-
-            //inner shadow
-            painter->setPen(innerShadow);
-            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
-                              QPoint(rect.right() - 1, rect.top() + 1));
-            painter->drawLine(QPoint(rect.left() + 1, rect.top() + 1),
-                              QPoint(rect.left() + 1, rect.bottom() + 1));
-
-        }
-        painter->restore();
-        break;
-    case CE_ProgressBarContents:
-        painter->save();
-        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
-            QRect rect = bar->rect;
-            bool vertical = false;
-            bool inverted = false;
-            bool indeterminate = (bar->minimum == 0 && bar->maximum == 0);
-
-            // Get extra style options if version 2
-            if (const QStyleOptionProgressBarV2 *bar2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option)) {
-                vertical = (bar2->orientation == Qt::Vertical);
-                inverted = bar2->invertedAppearance;
-            }
-
-            // If the orientation is vertical, we use a transform to rotate
-            // the progress bar 90 degrees clockwise.  This way we can use the
-            // same rendering code for both orientations.
-            if (vertical) {
-                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
-                QTransform m = QTransform::fromTranslate(rect.height()-1, -1.0);
-                m.rotate(90.0);
-                painter->setTransform(m, true);
-            }
-
-            int maxWidth = rect.width() - 4;
-            int minWidth = 4;
-            qreal progress = qMax(bar->progress, bar->minimum); // workaround for bug in QProgressBar
-            int progressBarWidth = (progress - bar->minimum) * qreal(maxWidth) / qMax(qreal(1.0), qreal(bar->maximum) - bar->minimum);
-            int width = indeterminate ? maxWidth : qMax(minWidth, progressBarWidth);
-
-            bool reverse = (!vertical && (bar->direction == Qt::RightToLeft)) || vertical;
-            if (inverted)
-                reverse = !reverse;
-
-            QRect progressBar;
-            Q_D(const QCleanlooksStyle);
-            if (!indeterminate) {
-                if (!reverse) {
-                    progressBar.setRect(rect.left() + 1, rect.top() + 1, width + 1, rect.height() - 3);
-                } else {
-                    progressBar.setRect(rect.right() - 1 - width, rect.top() + 1, width + 1, rect.height() - 3);
-                }
-                d->stopAnimation(option->styleObject);
-            } else {
-                int slideWidth = ((rect.width() - 4) * 2) / 3;
-                int step = 0;
-                if (QProgressStyleAnimation *animation = qobject_cast<QProgressStyleAnimation*>(d->animation(option->styleObject)))
-                    step = animation->progressStep(slideWidth);
-                else
-                    d->startAnimation(new QProgressStyleAnimation(d->animationFps, option->styleObject));
-                progressBar.setRect(rect.left() + 1 + step, rect.top() + 1,
-                                    slideWidth / 2, rect.height() - 3);
-            }
-            QColor highlight = option->palette.color(QPalette::Normal, QPalette::Highlight);
-            painter->setPen(QPen(highlight.darker(140), 0));
-
-            QColor highlightedGradientStartColor = highlight.lighter(100);
-            QColor highlightedGradientStopColor  = highlight.lighter(130);
-
-            QLinearGradient gradient(rect.topLeft(), QPoint(rect.bottomLeft().x(),
-                                                            rect.bottomLeft().y()*2));
-
-            gradient.setColorAt(0, highlightedGradientStartColor);
-            gradient.setColorAt(1, highlightedGradientStopColor);
-
-            painter->setBrush(gradient);
-            painter->drawRect(progressBar);
-
-            painter->setPen(QPen(highlight.lighter(120), 0));
-            painter->drawLine(QPoint(progressBar.left() + 1, progressBar.top() + 1),
-                              QPoint(progressBar.right(), progressBar.top() + 1));
-            painter->drawLine(QPoint(progressBar.left() + 1, progressBar.top() + 1),
-                              QPoint(progressBar.left() + 1, progressBar.bottom() - 1));
-
-            painter->setPen(QPen(highlightedGradientStartColor, 7.0));//QPen(option->palette.highlight(), 3));
-
-            painter->save();
-            painter->setClipRect(progressBar.adjusted(2, 2, -1, -1));
-            for (int x = progressBar.left() - 32; x < rect.right() ; x+=18) {
-                painter->drawLine(x, progressBar.bottom() + 1, x + 23, progressBar.top() - 2);
-            }
-            painter->restore();
-
-        }
-        painter->restore();
-        break;
-    case CE_MenuBarItem:
-        painter->save();
-        if (const QStyleOptionMenuItem *mbi = qstyleoption_cast<const QStyleOptionMenuItem *>(option))
-        {
-            QStyleOptionMenuItem item = *mbi;
-            item.rect = mbi->rect.adjusted(0, 3, 0, -1);
-            QColor highlightOutline = highlight.darker(125);
-            QLinearGradient gradient(rect.topLeft(), QPoint(rect.bottomLeft().x(), rect.bottomLeft().y()*2));
-
-            if (option->palette.button().gradient()) {
-                gradient.setStops(option->palette.button().gradient()->stops());
-            } else {
-                gradient.setColorAt(0, option->palette.button().color());
-                gradient.setColorAt(1, option->palette.button().color().darker(110));
-            }
-            painter->fillRect(rect, gradient);
-
-            QCommonStyle::drawControl(element, &item, painter, widget);
-
-            bool act = mbi->state & State_Selected && mbi->state & State_Sunken;
-            bool dis = !(mbi->state & State_Enabled);
-
-            QRect r = option->rect;
-            if (act) {
-                qt_cleanlooks_draw_gradient(painter, r.adjusted(1, 1, -1, -1),
-                                            highlight,
-                                            highlightOutline, TopDown,
-                                            option->palette.highlight());
-
-                painter->setPen(QPen(highlightOutline, 0));
-                const QLine lines[4] = {
-                    QLine(QPoint(r.left(), r.top() + 1), QPoint(r.left(), r.bottom())),
-                    QLine(QPoint(r.right(), r.top() + 1), QPoint(r.right(), r.bottom())),
-                    QLine(QPoint(r.left() + 1, r.bottom()), QPoint(r.right() - 1, r.bottom())),
-                    QLine(QPoint(r.left() + 1, r.top()), QPoint(r.right() - 1, r.top()))
-                };
-                painter->drawLines(lines, 4);
-
-                //draw text
-                QPalette::ColorRole textRole = dis ? QPalette::Text : QPalette::HighlightedText;
-                uint alignment = Qt::AlignCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
-                if (!styleHint(SH_UnderlineShortcut, mbi, widget))
-                    alignment |= Qt::TextHideMnemonic;
-                proxy()->drawItemText(painter, item.rect, alignment, mbi->palette, mbi->state & State_Enabled, mbi->text, textRole);
-            }
-
-        }
-        painter->restore();
-        break;
-    case CE_MenuItem:
-        painter->save();
-        // Draws one item in a popup menu.
-        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
-            QColor highlightOutline = highlight.darker(125);
-            QColor menuBackground = option->palette.background().color().lighter(104);
-            QColor borderColor = option->palette.background().color().darker(160);
-            QColor alphaCornerColor;
-
-            if (widget) {
-                // ### backgroundrole/foregroundrole should be part of the style option
-                alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), borderColor);
-            } else {
-                alphaCornerColor = mergedColors(option->palette.background().color(), borderColor);
-            }
-            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
-                painter->fillRect(menuItem->rect, menuBackground);
-                int w = 0;
-                if (!menuItem->text.isEmpty()) {
-                    painter->setFont(menuItem->font);
-                    proxy()->drawItemText(painter, menuItem->rect.adjusted(5, 0, -5, 0), Qt::AlignLeft | Qt::AlignVCenter,
-                                 menuItem->palette, menuItem->state & State_Enabled, menuItem->text,
-                                 QPalette::Text);
-                    w = menuItem->fontMetrics.width(menuItem->text) + 5;
-                }
-                painter->setPen(shadow.lighter(106));
-                bool reverse = menuItem->direction == Qt::RightToLeft;
-                painter->drawLine(menuItem->rect.left() + 5 + (reverse ? 0 : w), menuItem->rect.center().y(),
-                                  menuItem->rect.right() - 5 - (reverse ? w : 0), menuItem->rect.center().y());
-                painter->restore();
-                break;
-            }
-            bool selected = menuItem->state & State_Selected && menuItem->state & State_Enabled;
-            if (selected) {
-                QRect r = option->rect.adjusted(1, 0, -2, -1);
-                qt_cleanlooks_draw_gradient(painter, r, highlight,
-                                            highlightOutline, TopDown,
-                                            highlight);
-                r = r.adjusted(-1, 0, 1, 0);
-                painter->setPen(QPen(highlightOutline, 0));
-                const QLine lines[4] = {
-                    QLine(QPoint(r.left(), r.top() + 1), QPoint(r.left(), r.bottom() - 1)),
-                    QLine(QPoint(r.right(), r.top() + 1), QPoint(r.right(), r.bottom() - 1)),
-                    QLine(QPoint(r.left() + 1, r.bottom()), QPoint(r.right() - 1, r.bottom())),
-                    QLine(QPoint(r.left() + 1, r.top()), QPoint(r.right() - 1, r.top()))
-                };
-                painter->drawLines(lines, 4);
-            } else {
-                painter->fillRect(option->rect, menuBackground);
-            }
-
-            bool checkable = menuItem->checkType != QStyleOptionMenuItem::NotCheckable;
-            bool checked = menuItem->checked;
-            bool sunken = menuItem->state & State_Sunken;
-            bool enabled = menuItem->state & State_Enabled;
-
-            bool ignoreCheckMark = false;
-            int checkcol = qMax(menuItem->maxIconWidth, 20);
-
-#ifndef QT_NO_COMBOBOX
-            if (qobject_cast<const QComboBox*>(widget))
-                ignoreCheckMark = true; //ignore the checkmarks provided by the QComboMenuDelegate
-#endif
-
-            if (!ignoreCheckMark) {
-                // Check
-                QRect checkRect(option->rect.left() + 7, option->rect.center().y() - 6, 13, 13);
-                checkRect = visualRect(menuItem->direction, menuItem->rect, checkRect);
-                if (checkable) {
-                    if (menuItem->checkType & QStyleOptionMenuItem::Exclusive) {
-                        // Radio button
-                        if (checked || sunken) {
-                            painter->setRenderHint(QPainter::Antialiasing);
-                            painter->setPen(Qt::NoPen);
-
-                            QPalette::ColorRole textRole = !enabled ? QPalette::Text:
-                                                        selected ? QPalette::HighlightedText : QPalette::ButtonText;
-                            painter->setBrush(option->palette.brush( option->palette.currentColorGroup(), textRole));
-                            painter->drawEllipse(checkRect.adjusted(4, 4, -4, -4));
-                        }
-                    } else {
-                        // Check box
-                        if (menuItem->icon.isNull()) {
-                            if (checked || sunken) {
-                                QImage image(qt_cleanlooks_menuitem_checkbox_checked);
-                                if (enabled && (menuItem->state & State_Selected)) {
-                                    image.setColor(1, 0x55ffffff);
-                                    image.setColor(2, 0xAAffffff);
-                                    image.setColor(3, 0xBBffffff);
-                                    image.setColor(4, 0xFFffffff);
-                                    image.setColor(5, 0x33ffffff);
-                                } else {
-                                    image.setColor(1, 0x55000000);
-                                    image.setColor(2, 0xAA000000);
-                                    image.setColor(3, 0xBB000000);
-                                    image.setColor(4, 0xFF000000);
-                                    image.setColor(5, 0x33000000);
-                                }
-                                painter->drawImage(QPoint(checkRect.center().x() - image.width() / 2,
-                                                        checkRect.center().y() - image.height() / 2), image);
-                            }
-                        }
-                    }
-                }
-            } else { //ignore checkmark
-                if (menuItem->icon.isNull())
-                    checkcol = 0;
-                else
-                    checkcol = menuItem->maxIconWidth;
-            }
-
-            // Text and icon, ripped from windows style
-            bool dis = !(menuItem->state & State_Enabled);
-            bool act = menuItem->state & State_Selected;
-            const QStyleOption *opt = option;
-            const QStyleOptionMenuItem *menuitem = menuItem;
-
-            QPainter *p = painter;
-            QRect vCheckRect = visualRect(opt->direction, menuitem->rect,
-                                          QRect(menuitem->rect.x(), menuitem->rect.y(),
-                                                checkcol, menuitem->rect.height()));
-            if (!menuItem->icon.isNull()) {
-                QIcon::Mode mode = dis ? QIcon::Disabled : QIcon::Normal;
-                if (act && !dis)
-                    mode = QIcon::Active;
-                QPixmap pixmap;
-
-                int smallIconSize = proxy()->pixelMetric(PM_SmallIconSize, option, widget);
-                QSize iconSize(smallIconSize, smallIconSize);
-#ifndef QT_NO_COMBOBOX
-                if (const QComboBox *combo = qobject_cast<const QComboBox*>(widget))
-                    iconSize = combo->iconSize();
-#endif // QT_NO_COMBOBOX
-                if (checked)
-                    pixmap = menuItem->icon.pixmap(iconSize, mode, QIcon::On);
-                else
-                    pixmap = menuItem->icon.pixmap(iconSize, mode);
-
-                int pixw = pixmap.width();
-                int pixh = pixmap.height();
-
-                QRect pmr(0, 0, pixw, pixh);
-                pmr.moveCenter(vCheckRect.center());
-                painter->setPen(menuItem->palette.text().color());
-                if (checkable && checked) {
-                    QStyleOption opt = *option;
-                    if (act) {
-                        QColor activeColor = mergedColors(option->palette.background().color(),
-                                                        option->palette.highlight().color());
-                        opt.palette.setBrush(QPalette::Button, activeColor);
-                    }
-                    opt.state |= State_Sunken;
-                    opt.rect = vCheckRect;
-                    proxy()->drawPrimitive(PE_PanelButtonCommand, &opt, painter, widget);
-                }
-                painter->drawPixmap(pmr.topLeft(), pixmap);
-            }
-            if (selected) {
-                painter->setPen(menuItem->palette.highlightedText().color());
-            } else {
-                painter->setPen(menuItem->palette.text().color());
-            }
-            int x, y, w, h;
-            menuitem->rect.getRect(&x, &y, &w, &h);
-            int tab = menuitem->tabWidth;
-            QColor discol;
-            if (dis) {
-                discol = menuitem->palette.text().color();
-                p->setPen(discol);
-            }
-            int xm = windowsItemFrame + checkcol + windowsItemHMargin;
-            int xpos = menuitem->rect.x() + xm;
-
-            QRect textRect(xpos, y + windowsItemVMargin, w - xm - windowsRightBorder - tab + 1, h - 2 * windowsItemVMargin);
-            QRect vTextRect = visualRect(opt->direction, menuitem->rect, textRect);
-            QString s = menuitem->text;
-            if (!s.isEmpty()) {                     // draw text
-                p->save();
-                int t = s.indexOf(QLatin1Char('\t'));
-                int text_flags = Qt::AlignVCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
-                if (!styleHint(SH_UnderlineShortcut, menuitem, widget))
-                    text_flags |= Qt::TextHideMnemonic;
-                text_flags |= Qt::AlignLeft;
-                if (t >= 0) {
-                    QRect vShortcutRect = visualRect(opt->direction, menuitem->rect,
-                                                     QRect(textRect.topRight(), QPoint(menuitem->rect.right(), textRect.bottom())));
-                    if (dis && !act && proxy()->styleHint(SH_EtchDisabledText, option, widget)) {
-                        p->setPen(menuitem->palette.light().color());
-                        p->drawText(vShortcutRect.adjusted(1, 1, 1, 1), text_flags, s.mid(t + 1));
-                        p->setPen(discol);
-                    }
-                    p->drawText(vShortcutRect, text_flags, s.mid(t + 1));
-                    s = s.left(t);
-                }
-                QFont font = menuitem->font;
-                // font may not have any "hard" flags set. We override
-                // the point size so that when it is resolved against the device, this font will win.
-                // This is mainly to handle cases where someone sets the font on the window
-                // and then the combo inherits it and passes it onward. At that point the resolve mask
-                // is very, very weak. This makes it stonger.
-                font.setPointSizeF(QFontInfo(menuItem->font).pointSizeF());
-
-                if (menuitem->menuItemType == QStyleOptionMenuItem::DefaultItem)
-                    font.setBold(true);
-
-                p->setFont(font);
-                if (dis && !act && proxy()->styleHint(SH_EtchDisabledText, option, widget)) {
-                    p->setPen(menuitem->palette.light().color());
-                    p->drawText(vTextRect.adjusted(1, 1, 1, 1), text_flags, s.left(t));
-                    p->setPen(discol);
-                }
-                p->drawText(vTextRect, text_flags, s.left(t));
-                p->restore();
-            }
-
-            // Arrow
-            if (menuItem->menuItemType == QStyleOptionMenuItem::SubMenu) {// draw sub menu arrow
-                int dim = (menuItem->rect.height() - 4) / 2;
-                PrimitiveElement arrow;
-                arrow = QApplication::isRightToLeft() ? PE_IndicatorArrowLeft : PE_IndicatorArrowRight;
-                int xpos = menuItem->rect.left() + menuItem->rect.width() - 3 - dim;
-                QRect  vSubMenuRect = visualRect(option->direction, menuItem->rect,
-                                                 QRect(xpos, menuItem->rect.top() + menuItem->rect.height() / 2 - dim / 2, dim, dim));
-                QStyleOptionMenuItem newMI = *menuItem;
-                newMI.rect = vSubMenuRect;
-                newMI.state = !enabled ? State_None : State_Enabled;
-                if (selected)
-                    newMI.palette.setColor(QPalette::ButtonText,
-                                           newMI.palette.highlightedText().color());
-                proxy()->drawPrimitive(arrow, &newMI, painter, widget);
-            }
-        }
-        painter->restore();
-        break;
-    case CE_MenuHMargin:
-    case CE_MenuVMargin:
-        break;
-    case CE_MenuEmptyArea:
-        break;
-    case CE_PushButtonLabel:
-        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(option)) {
-            QRect ir = button->rect;
-            uint tf = Qt::AlignVCenter;
-            if (styleHint(SH_UnderlineShortcut, button, widget))
-                tf |= Qt::TextShowMnemonic;
-            else
-               tf |= Qt::TextHideMnemonic;
-
-            if (!button->icon.isNull()) {
-                //Center both icon and text
-                QPoint point;
-
-                QIcon::Mode mode = button->state & State_Enabled ? QIcon::Normal
-                                                              : QIcon::Disabled;
-                if (mode == QIcon::Normal && button->state & State_HasFocus)
-                    mode = QIcon::Active;
-                QIcon::State state = QIcon::Off;
-                if (button->state & State_On)
-                    state = QIcon::On;
-
-                QPixmap pixmap = button->icon.pixmap(button->iconSize, mode, state);
-                int w = pixmap.width();
-                int h = pixmap.height();
-
-                if (!button->text.isEmpty())
-                    w += button->fontMetrics.boundingRect(option->rect, tf, button->text).width() + 2;
-
-                point = QPoint(ir.x() + ir.width() / 2 - w / 2,
-                               ir.y() + ir.height() / 2 - h / 2);
-
-                if (button->direction == Qt::RightToLeft)
-                    point.rx() += pixmap.width();
-
-                painter->drawPixmap(visualPos(button->direction, button->rect, point), pixmap);
-
-                if (button->direction == Qt::RightToLeft)
-                    ir.translate(-point.x() - 2, 0);
-                else
-                    ir.translate(point.x() + pixmap.width(), 0);
-
-                // left-align text if there is
-                if (!button->text.isEmpty())
-                    tf |= Qt::AlignLeft;
-
-            } else {
-                tf |= Qt::AlignHCenter;
-            }
-
-            if (button->features & QStyleOptionButton::HasMenu)
-                ir = ir.adjusted(0, 0, -proxy()->pixelMetric(PM_MenuButtonIndicator, button, widget), 0);
-            proxy()->drawItemText(painter, ir, tf, button->palette, (button->state & State_Enabled),
-                         button->text, QPalette::ButtonText);
-        }
-        break;
-    case CE_MenuBarEmptyArea:
-        painter->save();
-        {
-            QColor shadow = mergedColors(option->palette.background().color().darker(120),
-                                 dark.lighter(140), 60);
-
-            QLinearGradient gradient(rect.topLeft(), QPoint(rect.bottomLeft().x(), rect.bottomLeft().y()*2));
-            gradient.setColorAt(0, option->palette.button().color());
-            gradient.setColorAt(1, option->palette.button().color().darker(110));
-            painter->fillRect(rect, gradient);
-
-#ifndef QT_NO_MAINWINDOW
-            if (widget && qobject_cast<const QMainWindow *>(widget->parentWidget())) {
-                QPen oldPen = painter->pen();
-                painter->setPen(QPen(shadow));
-                painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
-            }
-#endif // QT_NO_MAINWINDOW
-        }
-        painter->restore();
-        break;
-#ifndef QT_NO_TABBAR
-	case CE_TabBarTabShape:
-        painter->save();
-        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {
-
-            bool rtlHorTabs = (tab->direction == Qt::RightToLeft
-                               && (tab->shape == QTabBar::RoundedNorth
-                                   || tab->shape == QTabBar::RoundedSouth));
-            bool selected = tab->state & State_Selected;
-            bool lastTab = ((!rtlHorTabs && tab->position == QStyleOptionTab::End)
-                            || (rtlHorTabs
-                                && tab->position == QStyleOptionTab::Beginning));
-            bool onlyTab = tab->position == QStyleOptionTab::OnlyOneTab;
-            bool leftCornerWidget = (tab->cornerWidgets & QStyleOptionTab::LeftCornerWidget);
-
-            bool atBeginning = ((tab->position == (tab->direction == Qt::LeftToRight ?
-                                QStyleOptionTab::Beginning : QStyleOptionTab::End)) || onlyTab);
-
-            bool onlyOne = tab->position == QStyleOptionTab::OnlyOneTab;
-            bool previousSelected =
-                ((!rtlHorTabs
-                  && tab->selectedPosition == QStyleOptionTab::PreviousIsSelected)
-                 || (rtlHorTabs
-                     && tab->selectedPosition == QStyleOptionTab::NextIsSelected));
-            bool nextSelected =
-                ((!rtlHorTabs
-                  && tab->selectedPosition == QStyleOptionTab::NextIsSelected)
-                 || (rtlHorTabs
-                     && tab->selectedPosition
-                     == QStyleOptionTab::PreviousIsSelected));
-            int tabBarAlignment = proxy()->styleHint(SH_TabBar_Alignment, tab, widget);
-            bool leftAligned = (!rtlHorTabs && tabBarAlignment == Qt::AlignLeft)
-                               || (rtlHorTabs
-                                   && tabBarAlignment == Qt::AlignRight);
-
-            bool rightAligned = (!rtlHorTabs && tabBarAlignment == Qt::AlignRight)
-                                || (rtlHorTabs
-                                    && tabBarAlignment == Qt::AlignLeft);
-
-            QColor light = tab->palette.light().color();
-
-            QColor background = tab->palette.background().color();
-            int borderThinkness = proxy()->pixelMetric(PM_TabBarBaseOverlap, tab, widget);
-            if (selected)
-                borderThinkness /= 2;
-            QRect r2(option->rect);
-            int x1 = r2.left();
-            int x2 = r2.right();
-            int y1 = r2.top();
-            int y2 = r2.bottom();
-
-            QTransform rotMatrix;
-            bool flip = false;
-            painter->setPen(shadow);
-            QColor activeHighlight = option->palette.color(QPalette::Normal, QPalette::Highlight);
-            switch (tab->shape) {
-            case QTabBar::RoundedNorth:
-                break;
-            case QTabBar::RoundedSouth:
-                rotMatrix.rotate(180);
-                rotMatrix.translate(0, -rect.height() + 1);
-                rotMatrix.scale(-1, 1);
-                painter->setTransform(rotMatrix, true);
-                break;
-            case QTabBar::RoundedWest:
-                rotMatrix.rotate(180 + 90);
-                rotMatrix.scale(-1, 1);
-                flip = true;
-                painter->setTransform(rotMatrix, true);
-                break;
-            case QTabBar::RoundedEast:
-                rotMatrix.rotate(90);
-                rotMatrix.translate(0, - rect.width() + 1);
-                flip = true;
-                painter->setTransform(rotMatrix, true);
-                break;
-            default:
-                painter->restore();
-                QWindowsStyle::drawControl(element, tab, painter, widget);
-                return;
-            }
-
-            if (flip) {
-                QRect tmp = rect;
-                rect = QRect(tmp.y(), tmp.x(), tmp.height(), tmp.width());
-                int temp = x1;
-                x1 = y1;
-                y1 = temp;
-                temp = x2;
-                x2 = y2;
-                y2 = temp;
-            }
-
-            QLinearGradient gradient(rect.topLeft(), rect.bottomLeft());
-            if (option->palette.button().gradient()) {
-                if (selected)
-                    gradient.setStops(option->palette.background().gradient()->stops());
-                else
-                    gradient.setStops(option->palette.background().gradient()->stops());
-            }
-            else if (selected) {
-                gradient.setColorAt(0, option->palette.background().color().lighter(104));
-                gradient.setColorAt(1, tabFrameColor);
-                painter->fillRect(rect.adjusted(0, 2, 0, -1), gradient);
-            } else {
-                y1 += 2;
-                gradient.setColorAt(0, option->palette.background().color());
-                gradient.setColorAt(1, dark.lighter(120));
-                painter->fillRect(rect.adjusted(0, 2, 0, -2), gradient);
-            }
-
-            // Delete border
-            if (selected) {
-                painter->setPen(QPen(activeHighlight, 0));
-                painter->drawLine(x1 + 1, y1 + 1, x2 - 1, y1 + 1);
-                painter->drawLine(x1 , y1 + 2, x2 , y1 + 2);
-            } else {
-                painter->setPen(dark);
-                painter->drawLine(x1, y2 - 1, x2 + 2, y2 - 1 );
-                if (tab->shape == QTabBar::RoundedNorth || tab->shape == QTabBar::RoundedWest) {
-                    painter->setPen(light);
-                    painter->drawLine(x1, y2 , x2, y2 );
-                }
-            }
-            // Left
-            if (atBeginning || selected ) {
-                painter->setPen(light);
-                painter->drawLine(x1 + 1, y1 + 2 + 1, x1 + 1, y2 - ((onlyOne || atBeginning) && selected && leftAligned ? 0 : borderThinkness) - (atBeginning && leftCornerWidget ? 1 : 0));
-                painter->drawPoint(x1 + 1, y1 + 1);
-                painter->setPen(dark);
-                painter->drawLine(x1, y1 + 2, x1, y2 - ((onlyOne || atBeginning)  && leftAligned ? 0 : borderThinkness) - (atBeginning && leftCornerWidget ? 1 : 0));
-            }
-            // Top
-            {
-                int beg = x1 + (previousSelected ? 0 : 2);
-                int end = x2 - (nextSelected ? 0 : 2);
-                painter->setPen(light);
-
-                if (!selected)painter->drawLine(beg - 2, y1 + 1, end, y1 + 1);
-
-                if (selected)
-                    painter->setPen(QPen(activeHighlight.darker(150), 0));
-                else
-                    painter->setPen(darkOutline);
-                painter->drawLine(beg, y1 , end, y1);
-
-                if (atBeginning|| selected) {
-                    painter->drawPoint(beg - 1, y1 + 1);
-                } else if (!atBeginning) {
-                    painter->drawPoint(beg - 1, y1);
-                    painter->drawPoint(beg - 2, y1);
-                    if (!lastTab) {
-                        painter->setPen(dark.lighter(130));
-                        painter->drawPoint(end + 1, y1);
-                        painter->drawPoint(end + 2 , y1);
-                        painter->drawPoint(end + 2, y1 + 1);
-                    }
-                }
-            }
-            // Right
-            if (lastTab || selected || onlyOne || !nextSelected) {
-                painter->setPen(darkOutline);
-                painter->drawLine(x2, y1 + 2, x2, y2 - ((onlyOne || lastTab) && selected && rightAligned ? 0 : borderThinkness));
-                if (selected)
-                    painter->setPen(QPen(activeHighlight.darker(150), 0));
-                else
-                    painter->setPen(darkOutline);
-                painter->drawPoint(x2 - 1, y1 + 1);
-
-                if (selected) {
-                    painter->setPen(background.darker(110));
-                    painter->drawLine(x2 - 1, y1 + 3, x2 - 1, y2 - ((onlyOne || lastTab) && selected && rightAligned ? 0 : borderThinkness));
-                }
-            }
-        }
-        painter->restore();
-        break;
-
-#endif // QT_NO_TABBAR
-    default:
-        QWindowsStyle::drawControl(element,option,painter,widget);
-        break;
-    }
-}
-
-/*!
-  \reimp
-*/
-QPalette QCleanlooksStyle::standardPalette () const
-{
-    QPalette palette = QWindowsStyle::standardPalette();
-    palette.setBrush(QPalette::Active, QPalette::Highlight, QColor(98, 140, 178));
-    palette.setBrush(QPalette::Inactive, QPalette::Highlight, QColor(145, 141, 126));
-    palette.setBrush(QPalette::Disabled, QPalette::Highlight, QColor(145, 141, 126));
-
-    QColor backGround(239, 235, 231);
-
-    QColor light = backGround.lighter(150);
-    QColor base = Qt::white;
-    QColor dark = QColor(170, 156, 143).darker(110);
-    dark = backGround.darker(150);
-    QColor darkDisabled = QColor(209, 200, 191).darker(110);
-
-    //### Find the correct disabled text color
-    palette.setBrush(QPalette::Disabled, QPalette::Text, QColor(190, 190, 190));
-
-    palette.setBrush(QPalette::Window, backGround);
-    palette.setBrush(QPalette::Mid, backGround.darker(130));
-    palette.setBrush(QPalette::Light, light);
-
-    palette.setBrush(QPalette::Active, QPalette::Base, base);
-    palette.setBrush(QPalette::Inactive, QPalette::Base, base);
-    palette.setBrush(QPalette::Disabled, QPalette::Base, backGround);
-
-    palette.setBrush(QPalette::Midlight, palette.mid().color().lighter(110));
-
-    palette.setBrush(QPalette::All, QPalette::Dark, dark);
-    palette.setBrush(QPalette::Disabled, QPalette::Dark, darkDisabled);
-
-    QColor button = backGround;
-
-    palette.setBrush(QPalette::Button, button);
-
-    QColor shadow = dark.darker(135);
-    palette.setBrush(QPalette::Shadow, shadow);
-    palette.setBrush(QPalette::Disabled, QPalette::Shadow, shadow.lighter(150));
-    palette.setBrush(QPalette::HighlightedText, QColor(QRgb(0xffffffff)));
-    return palette;
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
-                                         QPainter *painter, const QWidget *widget) const
-{
-    QColor button = option->palette.button().color();
-    QColor dark;
-    QColor grooveColor;
-    QColor darkOutline;
-    dark.setHsv(button.hue(),
-                qMin(255, (int)(button.saturation()*1.9)),
-                qMin(255, (int)(button.value()*0.7)));
-    grooveColor.setHsv(button.hue(),
-                qMin(255, (int)(button.saturation()*2.6)),
-                qMin(255, (int)(button.value()*0.9)));
-    darkOutline.setHsv(button.hue(),
-                qMin(255, (int)(button.saturation()*3.0)),
-                qMin(255, (int)(button.value()*0.6)));
-
-    QColor alphaCornerColor;
-    if (widget) {
-        // ### backgroundrole/foregroundrole should be part of the style option
-        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), darkOutline);
-    } else {
-        alphaCornerColor = mergedColors(option->palette.background().color(), darkOutline);
-    }
-    QColor gripShadow = grooveColor.darker(110);
-    QColor buttonShadow = option->palette.button().color().darker(110);
-
-    QColor gradientStartColor = option->palette.button().color().lighter(108);
-    QColor gradientStopColor = mergedColors(option->palette.button().color().darker(108), dark.lighter(150), 70);
-
-    QPalette palette = option->palette;
-
-    switch (control) {
-#ifndef QT_NO_SPINBOX
-    case CC_SpinBox:
-        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
-            QPixmap cache;
-            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("spinbox"), spinBox, spinBox->rect.size());
-            if (!QPixmapCache::find(pixmapName, cache)) {
-                cache = QPixmap(spinBox->rect.size());
-                cache.fill(Qt::transparent);
-                QRect pixmapRect(0, 0, spinBox->rect.width(), spinBox->rect.height());
-                QPainter cachePainter(&cache);
-
-                bool isEnabled = (spinBox->state & State_Enabled);
-                //bool focus = isEnabled && (spinBox->state & State_HasFocus);
-                bool hover = isEnabled && (spinBox->state & State_MouseOver);
-                bool sunken = (spinBox->state & State_Sunken);
-                bool upIsActive = (spinBox->activeSubControls == SC_SpinBoxUp);
-                bool downIsActive = (spinBox->activeSubControls == SC_SpinBoxDown);
-
-                QRect rect = pixmapRect;
-                QStyleOptionSpinBox spinBoxCopy = *spinBox;
-                spinBoxCopy.rect = pixmapRect;
-                QRect upRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxUp, widget);
-                QRect downRect = proxy()->subControlRect(CC_SpinBox, &spinBoxCopy, SC_SpinBoxDown, widget);
-
-                int fw = spinBoxCopy.frame ? proxy()->pixelMetric(PM_SpinBoxFrameWidth, &spinBoxCopy, widget) : 0;
-                cachePainter.fillRect(rect.adjusted(1, qMax(fw - 1, 0), -1, -fw),
-                                      option->palette.base());
-
-                QRect r = rect.adjusted(0, 1, 0, -1);
-                if (spinBox->frame) {
-
-                    QColor topShadow = darkOutline;
-                    topShadow.setAlpha(60);
-                    cachePainter.setPen(topShadow);
-
-                    // antialias corners
-                    const QPoint points[8] = {
-                        QPoint(r.right(), r.top() + 1),
-                        QPoint(r.right() - 1, r.top() ),
-                        QPoint(r.right(), r.bottom() - 1),
-                        QPoint(r.right() - 1, r.bottom() ),
-                        QPoint(r.left() + 1, r.bottom()),
-                        QPoint(r.left(), r.bottom() - 1),
-                        QPoint(r.left() + 1, r.top()),
-                        QPoint(r.left(), r.top() + 1)
-                    };
-                    cachePainter.drawPoints(points, 8);
-
-                    // draw frame
-                    topShadow.setAlpha(30);
-                    cachePainter.setPen(topShadow);
-                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() - 1), QPoint(r.right() - 2, r.top() - 1));
-
-                    cachePainter.setPen(QPen(option->palette.background().color(), 1));
-                    cachePainter.drawLine(QPoint(r.left() + 2, r.top() + 1), QPoint(r.right() - 2, r.top() + 1));
-                    QColor highlight = Qt::white;
-                    highlight.setAlpha(130);
-                    cachePainter.setPen(option->palette.base().color().darker(120));
-                    cachePainter.drawLine(QPoint(r.left() + 1, r.top() + 1),
-                                  QPoint(r.right() - 1, r.top() + 1));
-                    cachePainter.drawLine(QPoint(r.left() + 1, r.top() + 1),
-                                  QPoint(r.left() + 1, r.bottom() - 1));
-                    cachePainter.setPen(option->palette.base().color());
-                    cachePainter.drawLine(QPoint(r.right() - 1, r.top() + 1),
-                                  QPoint(r.right() - 1, r.bottom() - 1));
-                    cachePainter.drawLine(QPoint(r.left() + 1, r.bottom() - 1),
-                                  QPoint(r.right() - 1, r.bottom() - 1));
-                    cachePainter.setPen(highlight);
-                    cachePainter.drawLine(QPoint(r.left() + 3, r.bottom() + 1),
-                                  QPoint(r.right() - 3, r.bottom() + 1));
-
-                    cachePainter.setPen(QPen(darkOutline, 1));
-
-                    // top and bottom lines
-                    const QLine lines[4] = {
-                        QLine(QPoint(r.left() + 2, r.bottom()), QPoint(r.right()- 2, r.bottom())),
-                        QLine(QPoint(r.left() + 2, r.top()), QPoint(r.right() - 2, r.top())),
-                        QLine(QPoint(r.right(), r.top() + 2), QPoint(r.right(), r.bottom() - 2)),
-                        QLine(QPoint(r.left(), r.top() + 2), QPoint(r.left(), r.bottom() - 2))
-                    };
-                    cachePainter.drawLines(lines, 4);
-                }
-
-                    // gradients
-                    qt_cleanlooks_draw_gradient(&cachePainter, upRect,
-                                            gradientStartColor.darker(106),
-                                            gradientStopColor, TopDown, option->palette.button());
-                    qt_cleanlooks_draw_gradient(&cachePainter, downRect.adjusted(0, 0, 0, 1),
-                                            gradientStartColor.darker(106),
-                                            gradientStopColor, TopDown, option->palette.button());
-                if (isEnabled) {
-                    if(upIsActive) {
-                        if (sunken) {
-                            cachePainter.fillRect(upRect.adjusted(1, 0, 0, 0), gradientStopColor.darker(110));
-                        } else if (hover) {
-                            qt_cleanlooks_draw_gradient(&cachePainter, upRect.adjusted(1, 0, 0, 0),
-                                                    gradientStartColor.lighter(110),
-                                                    gradientStopColor.lighter(110), TopDown, option->palette.button());
-                        }
-                    }
-                    if(downIsActive) {
-                        if (sunken) {
-                            cachePainter.fillRect(downRect.adjusted(1, 0, 0, 1), gradientStopColor.darker(110));
-
-                        } else if (hover) {
-                                qt_cleanlooks_draw_gradient(&cachePainter, downRect.adjusted(1, 0, 0, 1),
-                                                        gradientStartColor.lighter(110),
-                                                        gradientStopColor.lighter(110), TopDown, option->palette.button());
-                        }
-                    }
-                }
-
-                if (spinBox->frame) {
-                    // rounded corners
-                    const QPoint points[4] = {
-                        QPoint(r.left() + 1, r.bottom() - 1),
-                        QPoint(r.left() + 1, r.top() + 1),
-                        QPoint(r.right() - 1, r.bottom() - 1),
-                        QPoint(r.right() - 1, r.top() + 1)
-                    };
-                    cachePainter.drawPoints(points, 4);
-
-                    if (option->state & State_HasFocus) {
-                        QColor darkoutline = option->palette.highlight().color().darker(150);
-                        QColor innerline = mergedColors(option->palette.highlight().color(), Qt::white);
-                        cachePainter.setPen(QPen(innerline, 0));
-                        if (spinBox->direction == Qt::LeftToRight) {
-                            cachePainter.drawRect(rect.adjusted(1, 2, -3 -downRect.width(), -3));
-                            cachePainter.setPen(QPen(darkoutline, 0));
-                            const QLine lines[4] = {
-                                QLine(QPoint(r.left() + 2, r.bottom()), QPoint(r.right()- downRect.width() - 1, r.bottom())),
-                                QLine(QPoint(r.left() + 2, r.top()), QPoint(r.right() - downRect.width() - 1, r.top())),
-                                QLine(QPoint(r.right() - downRect.width() - 1, r.top() + 1), QPoint(r.right()- downRect.width() - 1, r.bottom() - 1)),
-                                QLine(QPoint(r.left(), r.top() + 2), QPoint(r.left(), r.bottom() - 2))
-                            };
-                            cachePainter.drawLines(lines, 4);
-                            cachePainter.drawPoint(QPoint(r.left() + 1, r.bottom() - 1));
-                            cachePainter.drawPoint(QPoint(r.left() + 1, r.top() + 1));
-                            cachePainter.drawLine(QPoint(r.left(), r.top() + 2), QPoint(r.left(), r.bottom() - 2));
-                        } else {
-                            cachePainter.drawRect(rect.adjusted(downRect.width() + 2, 2, -2, -3));
-                            cachePainter.setPen(QPen(darkoutline, 0));
-                            cachePainter.drawLine(QPoint(r.left() + downRect.width(), r.bottom()), QPoint(r.right()- 2 - 1, r.bottom()));
-                            cachePainter.drawLine(QPoint(r.left() + downRect.width(), r.top()), QPoint(r.right() - 2 - 1, r.top()));
-
-                            cachePainter.drawLine(QPoint(r.right(), r.top() + 2), QPoint(r.right(), r.bottom() - 2));
-                            cachePainter.drawPoint(QPoint(r.right() - 1, r.bottom() - 1));
-                            cachePainter.drawPoint(QPoint(r.right() - 1, r.top() + 1));
-                            cachePainter.drawLine(QPoint(r.left() + downRect.width() + 1, r.top()),
-                                                  QPoint(r.left() + downRect.width() + 1, r.bottom()));
-                        }
-                    }
-                }
-
-                // outline the up/down buttons
-                cachePainter.setPen(darkOutline);
-                QColor light = option->palette.light().color().lighter();
-
-                if (spinBox->direction == Qt::RightToLeft) {
-                    cachePainter.drawLine(upRect.right(), upRect.top() - 1, upRect.right(), downRect.bottom() + 1);
-                    cachePainter.setPen(light);
-                    cachePainter.drawLine(upRect.right() - 1, upRect.top() + 3, upRect.right() - 1, downRect.bottom() );
-                } else {
-                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.left(), downRect.bottom() + 1);
-                    cachePainter.setPen(light);
-                    cachePainter.drawLine(upRect.left() + 1, upRect.top() , upRect.left() + 1, downRect.bottom() );
-                }
-                if (upIsActive && sunken) {
-                    cachePainter.setPen(gradientStopColor.darker(130));
-                    cachePainter.drawLine(upRect.left() + 1, upRect.top(), upRect.left() + 1, upRect.bottom());
-                    cachePainter.drawLine(upRect.left(), upRect.top() - 1, upRect.right(), upRect.top() - 1);
-                } else {
-                    cachePainter.setPen(light);
-                    cachePainter.drawLine(upRect.topLeft() + QPoint(1, -1), upRect.topRight() + QPoint(-1, -1));
-                    cachePainter.setPen(darkOutline);
-                    cachePainter.drawLine(upRect.bottomLeft(), upRect.bottomRight());
-                }
-                if (downIsActive && sunken) {
-                    cachePainter.setPen(gradientStopColor.darker(130));
-                    cachePainter.drawLine(downRect.left() + 1, downRect.top(), downRect.left() + 1, downRect.bottom() + 1);
-                    cachePainter.drawLine(downRect.left(), downRect.top(), downRect.right(), downRect.top());
-                    cachePainter.setPen(gradientStopColor.darker(110));
-                    cachePainter.drawLine(downRect.left(), downRect.bottom() + 1, downRect.right(), downRect.bottom() + 1);
-                } else {
-                    cachePainter.setPen(light);
-                    cachePainter.drawLine(downRect.topLeft() + QPoint(2,0), downRect.topRight());
-                }
-
-                if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
-                    int centerX = upRect.center().x();
-                    int centerY = upRect.center().y();
-                    cachePainter.setPen(spinBox->palette.foreground().color());
-
-                    // plus/minus
-                    if (spinBox->activeSubControls == SC_SpinBoxUp && sunken) {
-                        cachePainter.drawLine(1 + centerX - 2, 1 + centerY, 1 + centerX + 2, 1 + centerY);
-                        cachePainter.drawLine(1 + centerX, 1 + centerY - 2, 1 + centerX, 1 + centerY + 2);
-                    } else {
-                        cachePainter.drawLine(centerX - 2, centerY, centerX + 2, centerY);
-                        cachePainter.drawLine(centerX, centerY - 2, centerX, centerY + 2);
-                    }
-
-                    centerX = downRect.center().x();
-                    centerY = downRect.center().y();
-                    if (spinBox->activeSubControls == SC_SpinBoxDown && sunken) {
-                        cachePainter.drawLine(1 + centerX - 2, 1 + centerY, 1 + centerX + 2, 1 + centerY);
-                    } else {
-                        cachePainter.drawLine(centerX - 2, centerY, centerX + 2, centerY);
-                    }
-                } else if (spinBox->buttonSymbols == QAbstractSpinBox::UpDownArrows){
-                    // arrows
-                    QImage upArrow(qt_spinbox_button_arrow_up);
-                    upArrow.setColor(1, spinBox->palette.foreground().color().rgba());
-
-                    cachePainter.drawImage(upRect.center().x() - upArrow.width() / 2,
-                                            upRect.center().y() - upArrow.height() / 2,
-                                            upArrow);
-
-                    QImage downArrow(qt_spinbox_button_arrow_down);
-                    downArrow.setColor(1, spinBox->palette.foreground().color().rgba());
-
-                    cachePainter.drawImage(downRect.center().x() - downArrow.width() / 2,
-                                            downRect.center().y() - downArrow.height() / 2 + 1,
-                                            downArrow);
-                }
-
-                QColor disabledColor = option->palette.background().color();
-                disabledColor.setAlpha(150);
-                if (!(spinBox->stepEnabled & QAbstractSpinBox::StepUpEnabled))
-                    cachePainter.fillRect(upRect.adjusted(1, 0, 0, 0), disabledColor);
-                if (!(spinBox->stepEnabled & QAbstractSpinBox::StepDownEnabled)) {
-                    cachePainter.fillRect(downRect.adjusted(1, 0, 0, 0), disabledColor);
-                }
-                cachePainter.end();
-                QPixmapCache::insert(pixmapName, cache);
-            }
-            painter->drawPixmap(spinBox->rect.topLeft(), cache);
-        }
-        break;
-#endif // QT_NO_SPINBOX
-    case CC_TitleBar:
-        painter->save();
-        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
-            const int buttonMargin = 5;
-            bool active = (titleBar->titleBarState & State_Active);
-            QRect fullRect = titleBar->rect;
-            QPalette palette = option->palette;
-            QColor highlight = option->palette.highlight().color();
-
-            QColor titleBarFrameBorder(active ? highlight.darker(180): dark.darker(110));
-            QColor titleBarHighlight(active ? highlight.lighter(120): palette.background().color().lighter(120));
-            QColor textColor(active ? 0xffffff : 0xff000000);
-            QColor textAlphaColor(active ? 0xffffff : 0xff000000 );
-
-            {
-                // Fill title bar gradient
-                QColor titlebarColor = QColor(active ? highlight: palette.background().color());
-                QLinearGradient gradient(option->rect.center().x(), option->rect.top(),
-                                         option->rect.center().x(), option->rect.bottom());
-
-                gradient.setColorAt(0, titlebarColor.lighter(114));
-                gradient.setColorAt(0.5, titlebarColor.lighter(102));
-                gradient.setColorAt(0.51, titlebarColor.darker(104));
-                gradient.setColorAt(1, titlebarColor);
-                painter->fillRect(option->rect.adjusted(1, 1, -1, 0), gradient);
-
-                // Frame and rounded corners
-                painter->setPen(titleBarFrameBorder);
-
-                // top outline
-                painter->drawLine(fullRect.left() + 5, fullRect.top(), fullRect.right() - 5, fullRect.top());
-                painter->drawLine(fullRect.left(), fullRect.top() + 4, fullRect.left(), fullRect.bottom());
-                const QPoint points[5] = {
-                    QPoint(fullRect.left() + 4, fullRect.top() + 1),
-                    QPoint(fullRect.left() + 3, fullRect.top() + 1),
-                    QPoint(fullRect.left() + 2, fullRect.top() + 2),
-                    QPoint(fullRect.left() + 1, fullRect.top() + 3),
-                    QPoint(fullRect.left() + 1, fullRect.top() + 4)
-                };
-                painter->drawPoints(points, 5);
-
-                painter->drawLine(fullRect.right(), fullRect.top() + 4, fullRect.right(), fullRect.bottom());
-                const QPoint points2[5] = {
-                    QPoint(fullRect.right() - 3, fullRect.top() + 1),
-                    QPoint(fullRect.right() - 4, fullRect.top() + 1),
-                    QPoint(fullRect.right() - 2, fullRect.top() + 2),
-                    QPoint(fullRect.right() - 1, fullRect.top() + 3),
-                    QPoint(fullRect.right() - 1, fullRect.top() + 4)
-                };
-                painter->drawPoints(points2, 5);
-
-                // draw bottomline
-                painter->drawLine(fullRect.right(), fullRect.bottom(), fullRect.left(), fullRect.bottom());
-
-                // top highlight
-                painter->setPen(titleBarHighlight);
-                painter->drawLine(fullRect.left() + 6, fullRect.top() + 1, fullRect.right() - 6, fullRect.top() + 1);
-            }
-            // draw title
-            QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
-            QFont font = painter->font();
-            font.setBold(true);
-            painter->setFont(font);
-            painter->setPen(active? (titleBar->palette.text().color().lighter(120)) :
-                                     titleBar->palette.text().color() );
-            // Note workspace also does elliding but it does not use the correct font
-            QString title = QFontMetrics(font).elidedText(titleBar->text, Qt::ElideRight, textRect.width() - 14);
-            painter->drawText(textRect.adjusted(1, 1, 1, 1), title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
-            painter->setPen(Qt::white);
-            if (active)
-                painter->drawText(textRect, title, QTextOption(Qt::AlignHCenter | Qt::AlignVCenter));
-            // min button
-            if ((titleBar->subControls & SC_TitleBarMinButton) && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
-                !(titleBar->titleBarState& Qt::WindowMinimized)) {
-                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
-                if (minButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
-                    qt_cleanlooks_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
-                    QRect minButtonIconRect = minButtonRect.adjusted(buttonMargin ,buttonMargin , -buttonMargin, -buttonMargin);
-                    painter->setPen(textColor);
-                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 3,
-                                    minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 3);
-                    painter->drawLine(minButtonIconRect.center().x() - 2, minButtonIconRect.center().y() + 4,
-                                    minButtonIconRect.center().x() + 3, minButtonIconRect.center().y() + 4);
-                    painter->setPen(textAlphaColor);
-                    painter->drawLine(minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 3,
-                                    minButtonIconRect.center().x() - 3, minButtonIconRect.center().y() + 4);
-                    painter->drawLine(minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 3,
-                                    minButtonIconRect.center().x() + 4, minButtonIconRect.center().y() + 4);
-                }
-            }
-            // max button
-            if ((titleBar->subControls & SC_TitleBarMaxButton) && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
-                !(titleBar->titleBarState & Qt::WindowMaximized)) {
-                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
-                if (maxButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
-                    qt_cleanlooks_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
-
-                    QRect maxButtonIconRect = maxButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
-
-                    painter->setPen(textColor);
-                    painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
-                    painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
-                                    maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
-                    painter->setPen(textAlphaColor);
-                    const QPoint points[4] = {
-                        maxButtonIconRect.topLeft(),
-                        maxButtonIconRect.topRight(),
-                        maxButtonIconRect.bottomLeft(),
-                        maxButtonIconRect.bottomRight()
-                    };
-                    painter->drawPoints(points, 4);
-                }
-            }
-
-            // close button
-            if ((titleBar->subControls & SC_TitleBarCloseButton) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
-                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
-                if (closeButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
-                    qt_cleanlooks_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
-                    QRect closeIconRect = closeButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
-                    painter->setPen(textAlphaColor);
-                    const QLine lines[4] = {
-                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
-                              closeIconRect.right(), closeIconRect.bottom() - 1),
-                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
-                              closeIconRect.right() - 1, closeIconRect.bottom()),
-                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
-                              closeIconRect.left(), closeIconRect.bottom() - 1),
-                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
-                              closeIconRect.left() + 1, closeIconRect.bottom())
-                    };
-                    painter->drawLines(lines, 4);
-                    const QPoint points[4] = {
-                        closeIconRect.topLeft(),
-                        closeIconRect.topRight(),
-                        closeIconRect.bottomLeft(),
-                        closeIconRect.bottomRight()
-                    };
-                    painter->drawPoints(points, 4);
-
-                    painter->setPen(textColor);
-                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
-                                    closeIconRect.right() - 1, closeIconRect.bottom() - 1);
-                    painter->drawLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
-                                    closeIconRect.right() - 1, closeIconRect.top() + 1);
-                }
-            }
-
-            // normalize button
-            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
-               (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
-               (titleBar->titleBarState & Qt::WindowMinimized)) ||
-               ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
-               (titleBar->titleBarState & Qt::WindowMaximized)))) {
-                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
-                if (normalButtonRect.isValid()) {
-
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
-                    QRect normalButtonIconRect = normalButtonRect.adjusted(buttonMargin, buttonMargin, -buttonMargin, -buttonMargin);
-                    qt_cleanlooks_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
-
-                    QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
-                    painter->setPen(textColor);
-                    painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
-                    painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
-                                    frontWindowRect.right() - 1, frontWindowRect.top() + 1);
-                    painter->setPen(textAlphaColor);
-                    const QPoint points[4] = {
-                        frontWindowRect.topLeft(),
-                        frontWindowRect.topRight(),
-                        frontWindowRect.bottomLeft(),
-                        frontWindowRect.bottomRight()
-                    };
-                    painter->drawPoints(points, 4);
-
-                    QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
-                    QRegion clipRegion = backWindowRect;
-                    clipRegion -= frontWindowRect;
-                    painter->save();
-                    painter->setClipRegion(clipRegion);
-                    painter->setPen(textColor);
-                    painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
-                    painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
-                                    backWindowRect.right() - 1, backWindowRect.top() + 1);
-                    painter->setPen(textAlphaColor);
-                    const QPoint points2[4] = {
-                        backWindowRect.topLeft(),
-                        backWindowRect.topRight(),
-                        backWindowRect.bottomLeft(),
-                        backWindowRect.bottomRight()
-                    };
-                    painter->drawPoints(points2, 4);
-                    painter->restore();
-                }
-            }
-
-            // context help button
-            if (titleBar->subControls & SC_TitleBarContextHelpButton
-                && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
-                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
-                if (contextHelpButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
-                    qt_cleanlooks_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
-
-                    QColor blend;
-                    QImage image(qt_titlebar_context_help);
-                    QColor alpha = textColor;
-                    alpha.setAlpha(128);
-                    image.setColor(1, textColor.rgba());
-                    image.setColor(2, alpha.rgba());
-                    painter->setRenderHint(QPainter::SmoothPixmapTransform);
-                    painter->drawImage(contextHelpButtonRect.adjusted(4, 4, -4, -4), image);
-                }
-            }
-
-            // shade button
-            if (titleBar->subControls & SC_TitleBarShadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
-                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
-                if (shadeButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
-                    qt_cleanlooks_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
-                    QImage image(qt_scrollbar_button_arrow_up);
-                    image.setColor(1, textColor.rgba());
-                    painter->drawImage(shadeButtonRect.adjusted(5, 7, -5, -7), image);
-                }
-            }
-
-            // unshade button
-            if (titleBar->subControls & SC_TitleBarUnshadeButton && (titleBar->titleBarFlags & Qt::WindowShadeButtonHint)) {
-                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
-                if (unshadeButtonRect.isValid()) {
-                    bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
-                    bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
-                    qt_cleanlooks_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
-                    QImage image(qt_scrollbar_button_arrow_down);
-                    image.setColor(1, textColor.rgba());
-                    painter->drawImage(unshadeButtonRect.adjusted(5, 7, -5, -7), image);
-                }
-            }
-
-            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
-                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
-                if (iconRect.isValid()) {
-                    if (!titleBar->icon.isNull()) {
-                        titleBar->icon.paint(painter, iconRect);
-                    } else {
-                        QStyleOption tool(0);
-                        tool.palette = titleBar->palette;
-                        QPixmap pm = standardIcon(SP_TitleBarMenuButton, &tool, widget).pixmap(16, 16);
-                        tool.rect = iconRect;
-                        painter->save();
-                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
-                        painter->restore();
-                    }
-                }
-            }
-        }
-        painter->restore();
-        break;
-#ifndef QT_NO_SCROLLBAR
-    case CC_ScrollBar:
-        painter->save();
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            bool isEnabled = scrollBar->state & State_Enabled;
-            bool reverse = scrollBar->direction == Qt::RightToLeft;
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            bool sunken = scrollBar->state & State_Sunken;
-
-            painter->fillRect(option->rect, option->palette.background());
-
-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
-            QRect scrollBarSlider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
-            QRect grooveRect = proxy()->subControlRect(control, scrollBar, SC_ScrollBarGroove, widget);
-
-            // paint groove
-            if (scrollBar->subControls & SC_ScrollBarGroove) {
-                painter->setBrush(grooveColor);
-                painter->setPen(Qt::NoPen);
-                if (horizontal) {
-                    painter->drawRect(grooveRect);
-                    painter->setPen(darkOutline);
-                    painter->drawLine(grooveRect.topLeft(), grooveRect.topRight());
-                    painter->drawLine(grooveRect.bottomLeft(), grooveRect.bottomRight());
-                } else {
-                    painter->drawRect(grooveRect);
-                    painter->setPen(darkOutline);
-                    painter->drawLine(grooveRect.topLeft(), grooveRect.bottomLeft());
-                    painter->drawLine(grooveRect.topRight(), grooveRect.bottomRight());
-                }
-            }
-            //paint slider
-            if (scrollBar->subControls & SC_ScrollBarSlider) {
-                QRect pixmapRect = scrollBarSlider;
-                if (horizontal)
-                    pixmapRect.adjust(-1, 0, 0, -1);
-                else
-                    pixmapRect.adjust(0, -1, -1, 0);
-
-                if (isEnabled) {
-                    QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                             pixmapRect.center().x(), pixmapRect.bottom());
-                    if (!horizontal)
-                        gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
-                                                   pixmapRect.right(), pixmapRect.center().y());
-
-                    if (option->palette.button().gradient()) {
-                        gradient.setStops(option->palette.button().gradient()->stops());
-                    } else {
-                        if (sunken || (option->state & State_MouseOver &&
-                            (scrollBar->activeSubControls & SC_ScrollBarSlider))) {
-                            gradient.setColorAt(0, gradientStartColor.lighter(110));
-                            gradient.setColorAt(1, gradientStopColor.lighter(110));
-                        } else {
-                            gradient.setColorAt(0, gradientStartColor);
-                            gradient.setColorAt(1, gradientStopColor);
-                        }
-                    }
-                    painter->setPen(QPen(darkOutline, 0));
-                    painter->setBrush(gradient);
-                    painter->drawRect(pixmapRect);
-
-
-                    //calculate offsets used by highlight and shadow
-                    int yoffset, xoffset;
-                    if (option->state & State_Horizontal) {
-                        xoffset = 0;
-                        yoffset = 1;
-                    } else {
-                        xoffset = 1;
-                        yoffset = 0;
-                    }
-                    //draw slider highlights
-                    painter->setPen(QPen(gradientStopColor, 0));
-                    painter->drawLine(scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.bottom() - yoffset,
-                                      scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.bottom() - yoffset);
-                    painter->drawLine(scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.top() + yoffset,
-                                      scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.bottom() - yoffset);
-
-                    //draw slider shadow
-                    painter->setPen(QPen(gradientStartColor, 0));
-                    painter->drawLine(scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.top() + yoffset,
-                                      scrollBarSlider.right() - xoffset,
-                                      scrollBarSlider.top() + yoffset);
-                    painter->drawLine(scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.top() + yoffset,
-                                      scrollBarSlider.left() + xoffset,
-                                      scrollBarSlider.bottom() - yoffset);
-                } else {
-                    QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                             pixmapRect.center().x(), pixmapRect.bottom());
-                    if (!horizontal) {
-                        gradient = QLinearGradient(pixmapRect.left(), pixmapRect.center().y(),
-                                                   pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    if (sunken) {
-                        gradient.setColorAt(0, gradientStartColor.lighter(110));
-                        gradient.setColorAt(1, gradientStopColor.lighter(110));
-                    } else {
-                        gradient.setColorAt(0, gradientStartColor);
-                        gradient.setColorAt(1, gradientStopColor);
-                    }
-                    painter->setPen(darkOutline);
-                    painter->setBrush(gradient);
-                    painter->drawRect(pixmapRect);
-                }
-                int gripMargin = 4;
-                //draw grips
-                if (horizontal) {
-                    for (int i = -3; i< 6 ; i += 3) {
-                        painter->setPen(QPen(gripShadow, 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.center().x() + i ,
-                                   scrollBarSlider.top() + gripMargin),
-                            QPoint(scrollBarSlider.center().x() + i,
-                                   scrollBarSlider.bottom() - gripMargin));
-                        painter->setPen(QPen(palette.light(), 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.center().x() + i + 1,
-                                   scrollBarSlider.top() + gripMargin  ),
-                            QPoint(scrollBarSlider.center().x() + i + 1,
-                                   scrollBarSlider.bottom() - gripMargin));
-                    }
-                } else {
-                    for (int i = -3; i < 6 ; i += 3) {
-                        painter->setPen(QPen(gripShadow, 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.left() + gripMargin ,
-                                   scrollBarSlider.center().y()+ i),
-                            QPoint(scrollBarSlider.right() - gripMargin,
-                                   scrollBarSlider.center().y()+ i));
-                        painter->setPen(QPen(palette.light(), 1));
-                        painter->drawLine(
-                            QPoint(scrollBarSlider.left() + gripMargin,
-                                   scrollBarSlider.center().y() + 1 + i),
-                            QPoint(scrollBarSlider.right() - gripMargin,
-                                   scrollBarSlider.center().y() + 1 + i));
-                    }
-                }
-            }
-
-            // The SubLine (up/left) buttons
-            if (scrollBar->subControls & SC_ScrollBarSubLine) {
-                //int scrollBarExtent = proxy()->pixelMetric(PM_ScrollBarExtent, option, widget);
-                QRect pixmapRect = scrollBarSubLine;
-                if (isEnabled ) {
-                    QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
-                    // Gradients
-                    if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
-                        qt_cleanlooks_draw_gradient(painter,
-                                                    QRect(fillRect),
-                                                    gradientStopColor.darker(120),
-                                                    gradientStopColor.darker(120),
-                                                    horizontal ? TopDown : FromLeft, option->palette.button());
-                    } else {
-                        qt_cleanlooks_draw_gradient(painter,
-                                                    QRect(fillRect),
-                                                    gradientStartColor.lighter(105),
-                                                    gradientStopColor,
-                                                    horizontal ? TopDown : FromLeft, option->palette.button());
-                    }
-                }
-                // Details
-                QImage subButton;
-                if (horizontal) {
-                    subButton = QImage(reverse ? qt_scrollbar_button_right : qt_scrollbar_button_left);
-                } else {
-                    subButton = QImage(qt_scrollbar_button_up);
-                }
-                subButton.setColor(1, alphaCornerColor.rgba());
-                subButton.setColor(2, darkOutline.rgba());
-                if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
-                    subButton.setColor(3, gradientStopColor.darker(140).rgba());
-                    subButton.setColor(4, gradientStopColor.darker(120).rgba());
-                } else {
-                    subButton.setColor(3, gradientStartColor.lighter(105).rgba());
-                    subButton.setColor(4, gradientStopColor.rgba());
-                }
-                subButton.setColor(5, scrollBar->palette.text().color().rgba());
-                painter->drawImage(pixmapRect, subButton);
-
-                // Arrows
-                PrimitiveElement arrow;
-                if (option->state & State_Horizontal)
-                    arrow = option->direction == Qt::LeftToRight ? PE_IndicatorArrowLeft: PE_IndicatorArrowRight;
-                else
-                    arrow = PE_IndicatorArrowUp;
-                QStyleOption arrowOpt = *option;
-                arrowOpt.rect = scrollBarSubLine.adjusted(3, 3, -2, -2);
-                proxy()->drawPrimitive(arrow, &arrowOpt, painter, widget);
-
-
-                // The AddLine (down/right) button
-                if (scrollBar->subControls & SC_ScrollBarAddLine) {
-                    QString addLinePixmapName = QStyleHelper::uniqueName(QLatin1String("scrollbar_addline"), option, QSize(16, 16));
-                    QRect pixmapRect = scrollBarAddLine;
-                    if (isEnabled) {
-                        QRect fillRect = pixmapRect.adjusted(1, 1, -1, -1);
-                        // Gradients
-                        if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
-                            qt_cleanlooks_draw_gradient(painter,
-                                                        fillRect,
-                                                        gradientStopColor.darker(120),
-                                                        gradientStopColor.darker(120),
-                                                        horizontal ? TopDown: FromLeft, option->palette.button());
-                        } else {
-                            qt_cleanlooks_draw_gradient(painter,
-                                                        fillRect,
-                                                        gradientStartColor.lighter(105),
-                                                        gradientStopColor,
-                                                        horizontal ? TopDown : FromLeft, option->palette.button());
-                        }
-                    }
-                    // Details
-                    QImage addButton;
-                    if (horizontal) {
-                        addButton = QImage(reverse ? qt_scrollbar_button_left : qt_scrollbar_button_right);
-                    } else {
-                        addButton = QImage(qt_scrollbar_button_down);
-                    }
-                    addButton.setColor(1, alphaCornerColor.rgba());
-                    addButton.setColor(2, darkOutline.rgba());
-                    if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
-                        addButton.setColor(3, gradientStopColor.darker(140).rgba());
-                        addButton.setColor(4, gradientStopColor.darker(120).rgba());
-                    } else {
-                        addButton.setColor(3, gradientStartColor.lighter(105).rgba());
-                        addButton.setColor(4, gradientStopColor.rgba());
-                    }
-                    addButton.setColor(5, scrollBar->palette.text().color().rgba());
-                    painter->drawImage(pixmapRect, addButton);
-
-                    PrimitiveElement arrow;
-                    if (option->state & State_Horizontal)
-                        arrow = option->direction == Qt::LeftToRight ? PE_IndicatorArrowRight : PE_IndicatorArrowLeft;
-                    else
-                        arrow = PE_IndicatorArrowDown;
-
-                    QStyleOption arrowOpt = *option;
-                    arrowOpt.rect = scrollBarAddLine.adjusted(3, 3, -2, -2);
-                    proxy()->drawPrimitive(arrow, &arrowOpt, painter, widget);
-                }
-            }
-        }
-        painter->restore();
-        break;;
-#endif // QT_NO_SCROLLBAR
-#ifndef QT_NO_COMBOBOX
-    case CC_ComboBox:
-        painter->save();
-        if (const QStyleOptionComboBox *comboBox = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
-            bool sunken = comboBox->state & State_On; // play dead, if combobox has no items
-            bool isEnabled = (comboBox->state & State_Enabled);
-            bool focus = isEnabled && (comboBox->state & State_HasFocus);
-            QPixmap cache;
-            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("combobox"), option, comboBox->rect.size());
-            if (sunken)
-                pixmapName += QLatin1String("-sunken");
-            if (comboBox->editable)
-                pixmapName += QLatin1String("-editable");
-            if (isEnabled)
-                pixmapName += QLatin1String("-enabled");
-
-            if (!QPixmapCache::find(pixmapName, cache)) {
-                cache = QPixmap(comboBox->rect.size());
-                cache.fill(Qt::transparent);
-                QPainter cachePainter(&cache);
-                QRect pixmapRect(0, 0, comboBox->rect.width(), comboBox->rect.height());
-                QStyleOptionComboBox comboBoxCopy = *comboBox;
-                comboBoxCopy.rect = pixmapRect;
-
-                QRect rect = pixmapRect;
-                QRect downArrowRect = proxy()->subControlRect(CC_ComboBox, &comboBoxCopy,
-                                                     SC_ComboBoxArrow, widget);
-                QRect editRect = proxy()->subControlRect(CC_ComboBox, &comboBoxCopy,
-                                                     SC_ComboBoxEditField, widget);
-                // Draw a push button
-                if (comboBox->editable) {
-                    QStyleOptionFrame  buttonOption;
-                    buttonOption.QStyleOption::operator=(*comboBox);
-                    buttonOption.rect = rect;
-                    buttonOption.state = comboBox->state & (State_Enabled | State_MouseOver);
-
-                    if (sunken) {
-                        buttonOption.state |= State_Sunken;
-                        buttonOption.state &= ~State_MouseOver;
-                    }
-
-                    proxy()->drawPrimitive(PE_PanelButtonCommand, &buttonOption, &cachePainter, widget);
-
-                    //remove shadow from left side of edit field when pressed:
-                    if (comboBox->direction != Qt::RightToLeft)
-                        cachePainter.fillRect(editRect.left() - 1, editRect.top() + 1, editRect.left(),
-                        editRect.bottom() - 3, option->palette.base());
-
-                    cachePainter.setPen(dark.lighter(110));
-                    if (!sunken) {
-                        int borderSize = 2;
-                        if (comboBox->direction == Qt::RightToLeft) {
-                            cachePainter.drawLine(QPoint(downArrowRect.right() - 1, downArrowRect.top() + borderSize ),
-                                                  QPoint(downArrowRect.right() - 1, downArrowRect.bottom() - borderSize));
-                            cachePainter.setPen(option->palette.light().color());
-                            cachePainter.drawLine(QPoint(downArrowRect.right(), downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.right(), downArrowRect.bottom() - borderSize));
-                        } else {
-                            cachePainter.drawLine(QPoint(downArrowRect.left() , downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.left() , downArrowRect.bottom() - borderSize));
-                            cachePainter.setPen(option->palette.light().color());
-                            cachePainter.drawLine(QPoint(downArrowRect.left() + 1, downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.left() + 1, downArrowRect.bottom() - borderSize));
-                        }
-                    } else {
-                        if (comboBox->direction == Qt::RightToLeft) {
-                            cachePainter.drawLine(QPoint(downArrowRect.right(), downArrowRect.top() + 2),
-                                                  QPoint(downArrowRect.right(), downArrowRect.bottom() - 2));
-
-                        } else {
-                            cachePainter.drawLine(QPoint(downArrowRect.left(), downArrowRect.top() + 2),
-                                                  QPoint(downArrowRect.left(), downArrowRect.bottom() - 2));
-                        }
-                    }
-                } else {
-                    QStyleOptionButton buttonOption;
-                    buttonOption.QStyleOption::operator=(*comboBox);
-                    buttonOption.rect = rect;
-                    buttonOption.state = comboBox->state & (State_Enabled | State_MouseOver);
-                    if (sunken) {
-                        buttonOption.state |= State_Sunken;
-                        buttonOption.state &= ~State_MouseOver;
-                    }
-                    proxy()->drawPrimitive(PE_PanelButtonCommand, &buttonOption, &cachePainter, widget);
-
-                    cachePainter.setPen(buttonShadow.darker(102));
-                    int borderSize = 4;
-
-                    if (!sunken) {
-                        if (comboBox->direction == Qt::RightToLeft) {
-                            cachePainter.drawLine(QPoint(downArrowRect.right() + 1, downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.right() + 1, downArrowRect.bottom() - borderSize));
-                            cachePainter.setPen(option->palette.light().color());
-                            cachePainter.drawLine(QPoint(downArrowRect.right(), downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.right(), downArrowRect.bottom() - borderSize));
-                        } else {
-                            cachePainter.drawLine(QPoint(downArrowRect.left() - 1, downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.left() - 1, downArrowRect.bottom() - borderSize));
-                            cachePainter.setPen(option->palette.light().color());
-                            cachePainter.drawLine(QPoint(downArrowRect.left() , downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.left() , downArrowRect.bottom() - borderSize));
-                        }
-                    } else {
-                        cachePainter.setPen(dark.lighter(110));
-                        if (comboBox->direction == Qt::RightToLeft) {
-                            cachePainter.drawLine(QPoint(downArrowRect.right() + 1, downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.right() + 1, downArrowRect.bottom() - borderSize));
-
-                        } else {
-                            cachePainter.drawLine(QPoint(downArrowRect.left() - 1, downArrowRect.top() + borderSize),
-                                                  QPoint(downArrowRect.left() - 1, downArrowRect.bottom() - borderSize));
-                        }
-                    }
-                }
-
-
-                if (comboBox->subControls & SC_ComboBoxArrow) {
-                    if (comboBox->editable) {
-                        // Draw the down arrow
-                        QImage downArrow(qt_cleanlooks_arrow_down_xpm);
-                        downArrow.setColor(1, comboBox->palette.foreground().color().rgba());
-                        cachePainter.drawImage(downArrowRect.center().x() - downArrow.width() / 2,
-                                               downArrowRect.center().y() - downArrow.height() / 2 + 1, downArrow);
-                    } else {
-                        // Draw the up/down arrow
-                        QImage upArrow(qt_scrollbar_button_arrow_up);
-                        upArrow.setColor(1, comboBox->palette.foreground().color().rgba());
-                        QImage downArrow(qt_scrollbar_button_arrow_down);
-                        downArrow.setColor(1, comboBox->palette.foreground().color().rgba());
-                        cachePainter.drawImage(downArrowRect.center().x() - downArrow.width() / 2,
-                                               downArrowRect.center().y() - upArrow.height() - 1 , upArrow);
-                        cachePainter.drawImage(downArrowRect.center().x() - downArrow.width() / 2,
-                                               downArrowRect.center().y()  + 2, downArrow);
-                    }
-                }
-                // Draw the focus rect
-                if (focus && !comboBox->editable
-                    && ((option->state & State_KeyboardFocusChange) || styleHint(SH_UnderlineShortcut, option, widget))) {
-                    QStyleOptionFocusRect focus;
-                    focus.rect = proxy()->subControlRect(CC_ComboBox, &comboBoxCopy, SC_ComboBoxEditField, widget)
-                                 .adjusted(0, 2, option->direction == Qt::RightToLeft ? 1 : -1, -2);
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &focus, &cachePainter, widget);
-                }
-                cachePainter.end();
-                QPixmapCache::insert(pixmapName, cache);
-            }
-            painter->drawPixmap(comboBox->rect.topLeft(), cache);
-        }
-        painter->restore();
-        break;
-#endif // QT_NO_COMBOBOX
-#ifndef QT_NO_GROUPBOX
-    case CC_GroupBox:
-        painter->save();
-        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
-            QRect textRect = proxy()->subControlRect(CC_GroupBox, groupBox, SC_GroupBoxLabel, widget);
-            QRect checkBoxRect = proxy()->subControlRect(CC_GroupBox, groupBox, SC_GroupBoxCheckBox, widget);
-            bool flat = groupBox->features & QStyleOptionFrameV2::Flat;
-
-            if(!flat) {
-                if (groupBox->subControls & QStyle::SC_GroupBoxFrame) {
-                    QStyleOptionFrameV2 frame;
-                    frame.QStyleOption::operator=(*groupBox);
-                    frame.features = groupBox->features;
-                    frame.lineWidth = groupBox->lineWidth;
-                    frame.midLineWidth = groupBox->midLineWidth;
-                    frame.rect = proxy()->subControlRect(CC_GroupBox, option, SC_GroupBoxFrame, widget);
-
-                    painter->save();
-                    QRegion region(groupBox->rect);
-                    bool ltr = groupBox->direction == Qt::LeftToRight;
-                    region -= checkBoxRect.united(textRect).adjusted(ltr ? -4 : 0, 0, ltr ? 0 : 4, 0);
-                    if (!groupBox->text.isEmpty() ||  groupBox->subControls & SC_GroupBoxCheckBox)
-                        painter->setClipRegion(region);
-                    frame.palette.setBrush(QPalette::Dark, option->palette.mid().color().lighter(110));
-                    proxy()->drawPrimitive(PE_FrameGroupBox, &frame, painter);
-                    painter->restore();
-                }
-            }
-            // Draw title
-            if ((groupBox->subControls & QStyle::SC_GroupBoxLabel) && !groupBox->text.isEmpty()) {
-                if (!groupBox->text.isEmpty()) {
-                    QColor textColor = groupBox->textColor;
-                    if (textColor.isValid())
-                        painter->setPen(textColor);
-                    int alignment = int(groupBox->textAlignment);
-                    if (!styleHint(QStyle::SH_UnderlineShortcut, option, widget))
-                        alignment |= Qt::TextHideMnemonic;
-                    if (flat) {
-                        QFont font = painter->font();
-                        font.setBold(true);
-                        painter->setFont(font);
-                        if (groupBox->subControls & SC_GroupBoxCheckBox) {
-                            textRect.adjust(checkBoxRect.right() + 4, 0, checkBoxRect.right() + 4, 0);
-                        }
-                    }
-                    painter->drawText(textRect, Qt::TextShowMnemonic | Qt::AlignLeft| alignment, groupBox->text);
-                }
-            }
-            if (groupBox->subControls & SC_GroupBoxCheckBox) {
-                QStyleOptionButton box;
-                box.QStyleOption::operator=(*groupBox);
-                box.rect = checkBoxRect;
-                proxy()->drawPrimitive(PE_IndicatorCheckBox, &box, painter, widget);
-            }
-        }
-        painter->restore();
-        break;
-#endif // QT_NO_GROUPBOX
-#ifndef QT_NO_SLIDER
-    case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect groove = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
-
-            bool horizontal = slider->orientation == Qt::Horizontal;
-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
-            QColor activeHighlight = option->palette.color(QPalette::Normal, QPalette::Highlight);
-            QPixmap cache;
-
-            QBrush oldBrush = painter->brush();
-            QPen oldPen = painter->pen();
-
-            QColor shadowAlpha(Qt::black);
-            shadowAlpha.setAlpha(10);
-            QColor highlightAlpha(Qt::white);
-            highlightAlpha.setAlpha(80);
-
-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
-                QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_groove"), option, groove.size());
-                QRect pixmapRect(0, 0, groove.width(), groove.height());
-
-                // draw background groove
-                if (!QPixmapCache::find(groovePixmapName, cache)) {
-                    cache = QPixmap(pixmapRect.size());
-                    cache.fill(Qt::transparent);
-                    QPainter groovePainter(&cache);
-
-                    groovePainter.setPen(shadowAlpha);
-                    groovePainter.drawLine(1, 0, groove.width(), 0);
-                    groovePainter.drawLine(0, 0, 0, groove.height() - 1);
-
-                    groovePainter.setPen(highlightAlpha);
-                    groovePainter.drawLine(1, groove.height() - 1, groove.width() - 1, groove.height() - 1);
-                    groovePainter.drawLine(groove.width() - 1, 1, groove.width() - 1, groove.height() - 1);
-                    QLinearGradient gradient;
-                    if (horizontal) {
-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
-                    }
-                    else {
-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    groovePainter.setPen(QPen(darkOutline.darker(110), 0));
-                    gradient.setColorAt(0, grooveColor.darker(110));//dark.lighter(120));
-                    gradient.setColorAt(1, grooveColor.lighter(110));//palette.button().color().darker(115));
-                    groovePainter.setBrush(gradient);
-                    groovePainter.drawRect(pixmapRect.adjusted(1, 1, -2, -2));
-                    groovePainter.end();
-                    QPixmapCache::insert(groovePixmapName, cache);
-                }
-                painter->drawPixmap(groove.topLeft(), cache);
-
-                // draw blue groove highlight
-                QRect clipRect;
-                groovePixmapName += QLatin1String("_blue");
-                if (!QPixmapCache::find(groovePixmapName, cache)) {
-                    cache = QPixmap(pixmapRect.size());
-                    cache.fill(Qt::transparent);
-                    QPainter groovePainter(&cache);
-                    QLinearGradient gradient;
-                    if (horizontal) {
-                        gradient.setStart(pixmapRect.center().x(), pixmapRect.top());
-                        gradient.setFinalStop(pixmapRect.center().x(), pixmapRect.bottom());
-                    }
-                    else {
-                        gradient.setStart(pixmapRect.left(), pixmapRect.center().y());
-                        gradient.setFinalStop(pixmapRect.right(), pixmapRect.center().y());
-                    }
-                    groovePainter.setPen(QPen(activeHighlight.darker(150), 0));
-                    gradient.setColorAt(0, activeHighlight.darker(120));
-                    gradient.setColorAt(1, activeHighlight.lighter(160));
-                    groovePainter.setBrush(gradient);
-                    groovePainter.drawRect(pixmapRect.adjusted(1, 1, -2, -2));
-                    groovePainter.end();
-                    QPixmapCache::insert(groovePixmapName, cache);
-                }
-                if (horizontal) {
-                    if (slider->upsideDown)
-                        clipRect = QRect(handle.right(), groove.top(), groove.right() - handle.right(), groove.height());
-                    else
-                        clipRect = QRect(groove.left(), groove.top(), handle.left(), groove.height());
-                } else {
-                    if (slider->upsideDown)
-                        clipRect = QRect(groove.left(), handle.bottom(), groove.width(), groove.height() - handle.bottom());
-                    else
-                        clipRect = QRect(groove.left(), groove.top(), groove.width(), handle.top() - groove.top());
-                }
-                painter->save();
-                painter->setClipRect(clipRect.adjusted(0, 0, 1, 1));
-                painter->drawPixmap(groove.topLeft(), cache);
-                painter->restore();
-            }
-
-            // draw handle
-            if ((option->subControls & SC_SliderHandle) ) {
-                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
-                if (!QPixmapCache::find(handlePixmapName, cache)) {
-                    cache = QPixmap(handle.size());
-                    cache.fill(Qt::transparent);
-                    QRect pixmapRect(0, 0, handle.width(), handle.height());
-                    QPainter handlePainter(&cache);
-
-                    QColor gradientStartColor = mergedColors(option->palette.button().color().lighter(155),
-                                                             dark.lighter(155), 50);
-                    QColor gradientStopColor = gradientStartColor.darker(108);
-                    QRect gradRect = pixmapRect.adjusted(2, 2, -2, -2);
-
-                    QColor gradientBgStartColor = gradientStartColor;
-                    QColor gradientBgStopColor = gradientStopColor;
-
-                    QColor outline = option->state & State_Enabled ? dark : dark.lighter(130);
-                    if (option->state & State_Enabled && option->activeSubControls & SC_SliderHandle) {
-                        gradientBgStartColor = option->palette.highlight().color().lighter(180);
-                        gradientBgStopColor = option->palette.highlight().color().lighter(110);
-                        outline = option->palette.highlight().color().darker(130);
-                    }
-
-                    // gradient fill
-                    QRect r = pixmapRect.adjusted(1, 1, -1, -1);
-
-                    qt_cleanlooks_draw_gradient(&handlePainter, gradRect,
-                                                gradientBgStartColor,
-                                                gradientBgStopColor,
-                                                horizontal ? TopDown : FromLeft, option->palette.button());
-
-                    handlePainter.setPen(QPen(outline.darker(110), 1));
-                    handlePainter.drawLine(QPoint(r.left(), r.top() + 3), QPoint(r.left(), r.bottom() - 3));
-                    handlePainter.drawLine(QPoint(r.right(), r.top() + 3), QPoint(r.right(), r.bottom() - 3));
-                    handlePainter.drawLine(QPoint(r.left() + 3, r.bottom()), QPoint(r.right() - 3, r.bottom()));
-
-                    handlePainter.save();
-                    handlePainter.setRenderHint(QPainter::Antialiasing);
-                    handlePainter.translate(0.5, 0.5);
-                    const QLine lines[4] = {
-                        QLine(QPoint(r.left(), r.bottom() - 2), QPoint(r.left() + 2, r.bottom())),
-                        QLine(QPoint(r.left(), r.top() + 2), QPoint(r.left() + 2, r.top())),
-                        QLine(QPoint(r.right(), r.bottom() - 2), QPoint(r.right() - 2, r.bottom())),
-                        QLine(QPoint(r.right(), r.top() + 2), QPoint(r.right() - 2, r.top()))
-                    };
-                    handlePainter.drawLines(lines, 4);
-                    handlePainter.restore();;
-                    handlePainter.setPen(QPen(outline.darker(130), 1));
-                    handlePainter.drawLine(QPoint(r.left() + 3, r.top()), QPoint(r.right() - 3, r.top()));
-                    QColor cornerAlpha = outline.darker(120);
-                    cornerAlpha.setAlpha(80);
-
-                    handlePainter.setPen(cornerAlpha);
-                    if (horizontal) {
-                        handlePainter.drawLine(QPoint(r.left() + 6, r.top()), QPoint(r.left() + 6, r.bottom()));
-                        handlePainter.drawLine(QPoint(r.right() - 6, r.top()), QPoint(r.right() - 6, r.bottom()));
-                    } else {
-                        handlePainter.drawLine(QPoint(r.left(), r.top() + 6), QPoint(r.right(), r.top() + 6));
-                        handlePainter.drawLine(QPoint(r.left(), r.bottom() - 6), QPoint(r.right(), r.bottom() - 6));
-                    }
-
-                    //handle shadow
-                    handlePainter.setPen(shadowAlpha);
-                    handlePainter.drawLine(QPoint(r.left() + 2, r.bottom() + 1), QPoint(r.right() - 2, r.bottom() + 1));
-                    handlePainter.drawLine(QPoint(r.right() + 1, r.bottom() - 3), QPoint(r.right() + 1, r.top() + 4));
-                    handlePainter.drawLine(QPoint(r.right() - 1, r.bottom()), QPoint(r.right() + 1, r.bottom() - 2));
-
-                    qt_cleanlooks_draw_gradient(&handlePainter, horizontal ?
-                        gradRect.adjusted(6, 0, -6, 0) : gradRect.adjusted(0, 6, 0, -6),
-                        gradientStartColor,
-                        gradientStopColor.darker(106),
-                        horizontal ? TopDown : FromLeft,
-                        option->palette.button());
-
-                    //draw grips
-                    for (int i = -3; i< 6 ; i += 3) {
-                        for (int j = -3; j< 6 ; j += 3) {
-                            handlePainter.fillRect(r.center().x() + i, r.center().y() + j, 2, 2, highlightAlpha);
-                            handlePainter.setPen(gripShadow);
-                            handlePainter.drawPoint(r.center().x() + i, r.center().y() + j );
-                        }
-                    }
-                    handlePainter.end();
-                    QPixmapCache::insert(handlePixmapName, cache);
-                }
-
-                painter->drawPixmap(handle.topLeft(), cache);
-
-                if (slider->state & State_HasFocus) {
-                    QStyleOptionFocusRect fropt;
-                    fropt.QStyleOption::operator=(*slider);
-                    fropt.rect = slider->rect;
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
-                }
-            }
-            if (option->subControls & SC_SliderTickmarks) {
-                painter->setPen(darkOutline);
-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                        0, available) < 3)
-                        interval = slider->pageStep;
-                }
-                if (interval <= 0)
-                    interval = 1;
-
-                int v = slider->minimum;
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                    v_, (horizontal
-                                                        ? slider->rect.width()
-                                                        : slider->rect.height()) - len,
-                                                    slider->upsideDown) + len / 2;
-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
-
-                    if (horizontal) {
-                        if (ticksAbove) {
-                            painter->drawLine(pos, slider->rect.top() + extra,
-                                pos, slider->rect.top() + tickSize);
-                        }
-                        if (ticksBelow) {
-                            painter->drawLine(pos, slider->rect.bottom() - extra,
-                                            pos, slider->rect.bottom() - tickSize);
-                        }
-                    } else {
-                        if (ticksAbove) {
-                            painter->drawLine(slider->rect.left() + extra, pos,
-                                            slider->rect.left() + tickSize, pos);
-                        }
-                        if (ticksBelow) {
-                            painter->drawLine(slider->rect.right() - extra, pos,
-                                            slider->rect.right() - tickSize, pos);
-                        }
-                    }
-                    // in the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-            }
-            painter->setBrush(oldBrush);
-            painter->setPen(oldPen);
-        }
-        break;
-#endif // QT_NO_SLIDER
-#ifndef QT_NO_DIAL
-    case CC_Dial:
-        if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
-            QStyleHelper::drawDial(dial, painter);
-        break;
-#endif // QT_NO_DIAL
-        default:
-            QWindowsStyle::drawComplexControl(control, option, painter, widget);
-        break;
-    }
-}
-
-/*!
-  \reimp
-*/
-int QCleanlooksStyle::pixelMetric(PixelMetric metric, const QStyleOption *option, const QWidget *widget) const
-{
-    int ret = -1;
-    switch (metric) {
-    case PM_ToolTipLabelFrameWidth:
-        ret = 2;
-        break;
-    case PM_ButtonDefaultIndicator:
-        ret = 0;
-        break;
-    case PM_ButtonShiftHorizontal:
-    case PM_ButtonShiftVertical:
-        ret = 0;
-        break;
-    case PM_MessageBoxIconSize:
-        ret = 48;
-        break;
-    case PM_ListViewIconSize:
-        ret = 24;
-        break;
-    case PM_DialogButtonsSeparator:
-    case PM_SplitterWidth:
-        ret = 6;
-        break;
-    case PM_ScrollBarSliderMin:
-        ret = 26;
-        break;
-    case PM_MenuPanelWidth: //menu framewidth
-        ret = 2;
-        break;
-    case PM_TitleBarHeight:
-        ret = 24;
-        break;
-    case PM_ScrollBarExtent:
-        ret = 15;
-        break;
-    case PM_SliderThickness:
-        ret = 15;
-        break;
-    case PM_SliderLength:
-        ret = 27;
-        break;
-    case PM_DockWidgetTitleMargin:
-        ret = 1;
-        break;
-    case PM_MenuBarVMargin:
-        ret = 1;
-        break;
-    case PM_DefaultFrameWidth:
-        ret = 2;
-        break;
-    case PM_SpinBoxFrameWidth:
-        ret = 3;
-        break;
-    case PM_MenuBarItemSpacing:
-        ret = 6;
-        break;
-    case PM_MenuBarHMargin:
-        ret = 0;
-        break;
-    case PM_ToolBarHandleExtent:
-        ret = 9;
-        break;
-    case PM_ToolBarItemSpacing:
-        ret = 2;
-        break;
-    case PM_ToolBarFrameWidth:
-        ret = 0;
-        break;
-    case PM_ToolBarItemMargin:
-        ret = 1;
-        break;
-    case PM_SmallIconSize:
-        ret = 16;
-        break;
-    case PM_ButtonIconSize:
-        ret = 24;
-        break;
-    case PM_MenuVMargin:
-    case PM_MenuHMargin:
-        ret = 0;
-        break;
-    case PM_DockWidgetTitleBarButtonMargin:
-        ret = 4;
-        break;
-    case PM_MaximumDragDistance:
-        return -1;
-    case PM_TabCloseIndicatorWidth:
-    case PM_TabCloseIndicatorHeight:
-        return 20;
-    default:
-        break;
-    }
-
-    return ret != -1 ? ret : QWindowsStyle::pixelMetric(metric, option, widget);
-}
-
-/*!
-  \reimp
-*/
-QSize QCleanlooksStyle::sizeFromContents(ContentsType type, const QStyleOption *option,
-                                        const QSize &size, const QWidget *widget) const
-{
-    QSize newSize = QWindowsStyle::sizeFromContents(type, option, size, widget);
-    switch (type) {
-    case CT_PushButton:
-        if (const QStyleOptionButton *btn = qstyleoption_cast<const QStyleOptionButton *>(option)) {
-            if (!btn->text.isEmpty() && newSize.width() < 80)
-                newSize.setWidth(80);
-            if (!btn->icon.isNull() && btn->iconSize.height() > 16)
-                newSize -= QSize(0, 2);
-            newSize += QSize(0, 1);
-        }
-        break;
-#ifndef QT_NO_GROUPBOX
-    case CT_GroupBox:
-        // Since we use a bold font we have to recalculate base width
-        if (const QGroupBox *gb = qobject_cast<const QGroupBox*>(widget)) {
-            QFont font = gb->font();
-            font.setBold(true);
-            QFontMetrics metrics(font);
-            int baseWidth = metrics.width(gb->title()) + metrics.width(QLatin1Char(' '));
-            if (gb->isCheckable()) {
-                baseWidth += proxy()->pixelMetric(QStyle::PM_IndicatorWidth, option, widget);
-                baseWidth += proxy()->pixelMetric(QStyle::PM_CheckBoxLabelSpacing, option, widget);
-            }
-            newSize.setWidth(qMax(baseWidth, newSize.width()));
-        }
-        newSize += QSize(0, 1);
-        break;
-#endif //QT_NO_GROUPBOX
-    case CT_RadioButton:
-    case CT_CheckBox:
-        newSize += QSize(0, 1);
-        break;
-    case CT_ToolButton:
-#ifndef QT_NO_TOOLBAR
-        if (widget && qobject_cast<QToolBar *>(widget->parentWidget()))
-            newSize += QSize(4, 6);
-#endif // QT_NO_TOOLBAR
-        break;
-    case CT_SpinBox:
-        newSize += QSize(0, -2);
-        break;
-    case CT_ComboBox:
-        newSize += QSize(2, 4);
-        break;
-    case CT_LineEdit:
-        newSize += QSize(0, 4);
-        break;
-    case CT_MenuBarItem:
-	    newSize += QSize(0, 2);
-	    break;
-    case CT_MenuItem:
-        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
-            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
-                if (!menuItem->text.isEmpty()) {
-                    newSize.setHeight(menuItem->fontMetrics.height());
-                }
-            }
-#ifndef QT_NO_COMBOBOX
-            else if (!menuItem->icon.isNull()) {
-                if (const QComboBox *combo = qobject_cast<const QComboBox*>(widget)) {
-                    newSize.setHeight(qMax(combo->iconSize().height() + 2, newSize.height()));
-                }
-            }
-#endif // QT_NO_COMBOBOX
-        }
-        break;
-    case CT_SizeGrip:
-	    newSize += QSize(4, 4);
-	break;
-    case CT_MdiControls:
-        if (const QStyleOptionComplex *styleOpt = qstyleoption_cast<const QStyleOptionComplex *>(option)) {
-            int width = 0;
-            if (styleOpt->subControls & SC_MdiMinButton)
-                width += 19 + 1;
-            if (styleOpt->subControls & SC_MdiNormalButton)
-                width += 19 + 1;
-            if (styleOpt->subControls & SC_MdiCloseButton)
-                width += 19 + 1;
-            newSize = QSize(width, 19);
-        } else {
-            newSize = QSize(60, 19);
-        }
-        break;
-    default:
-        break;
-    }
-    return newSize;
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::polish(QApplication *app)
-{
-    QWindowsStyle::polish(app);
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::polish(QWidget *widget)
-{
-    QWindowsStyle::polish(widget);
-    if (qobject_cast<QAbstractButton*>(widget)
-#ifndef QT_NO_COMBOBOX
-        || qobject_cast<QComboBox *>(widget)
-#endif
-#ifndef QT_NO_PROGRESSBAR
-        || qobject_cast<QProgressBar *>(widget)
-#endif
-#ifndef QT_NO_SCROLLBAR
-        || qobject_cast<QScrollBar *>(widget)
-#endif
-#ifndef QT_NO_SPLITTER
-        || qobject_cast<QSplitterHandle *>(widget)
-#endif
-        || qobject_cast<QAbstractSlider *>(widget)
-#ifndef QT_NO_SPINBOX
-        || qobject_cast<QAbstractSpinBox *>(widget)
-#endif
-        || (widget->inherits("QDockSeparator"))
-        || (widget->inherits("QDockWidgetSeparator"))
-        ) {
-        widget->setAttribute(Qt::WA_Hover, true);
-    }
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::polish(QPalette &pal)
-{
-    QWindowsStyle::polish(pal);
-    //this is a workaround for some themes such as Human, where the contrast
-    //between text and background is too low.
-    QColor highlight = pal.highlight().color();
-    QColor highlightText = pal.highlightedText().color();
-    if (qAbs(qGray(highlight.rgb()) - qGray(highlightText.rgb())) < 150) {
-        if (qGray(highlightText.rgb()) < 128)
-            pal.setBrush(QPalette::Highlight, highlight.lighter(145));
-    }
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::unpolish(QWidget *widget)
-{
-    QWindowsStyle::unpolish(widget);
-    if (qobject_cast<QAbstractButton*>(widget)
-#ifndef QT_NO_COMBOBOX
-        || qobject_cast<QComboBox *>(widget)
-#endif
-#ifndef QT_NO_PROGRESSBAR
-        || qobject_cast<QProgressBar *>(widget)
-#endif
-#ifndef QT_NO_SCROLLBAR
-        || qobject_cast<QScrollBar *>(widget)
-#endif
-#ifndef QT_NO_SPLITTER
-        || qobject_cast<QSplitterHandle *>(widget)
-#endif
-        || qobject_cast<QAbstractSlider *>(widget)
-#ifndef QT_NO_SPINBOX
-        || qobject_cast<QAbstractSpinBox *>(widget)
-#endif
-        || (widget->inherits("QDockSeparator"))
-        || (widget->inherits("QDockWidgetSeparator"))
-        ) {
-        widget->setAttribute(Qt::WA_Hover, false);
-    }
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::unpolish(QApplication *app)
-{
-    QWindowsStyle::unpolish(app);
-}
-
-/*!
-  \reimp
-*/
-QRect QCleanlooksStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
-                                       SubControl subControl, const QWidget *widget) const
-{
-    QRect rect = QWindowsStyle::subControlRect(control, option, subControl, widget);
-
-    switch (control) {
-#ifndef QT_NO_SLIDER
-    case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-            switch (subControl) {
-            case SC_SliderHandle: {
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderLength));
-                    int centerY = slider->rect.center().y() - rect.height() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerY += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerY -= tickSize;
-                    rect.moveTop(centerY);
-                } else {
-                    rect.setWidth(proxy()->pixelMetric(PM_SliderThickness));
-                    rect.setHeight(proxy()->pixelMetric(PM_SliderLength));
-                    int centerX = slider->rect.center().x() - rect.width() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerX += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerX -= tickSize;
-                    rect.moveLeft(centerX);
-                }
-            }
-                break;
-            case SC_SliderGroove: {
-                QPoint grooveCenter = slider->rect.center();
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(7);
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.ry() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.ry() -= tickSize;
-                } else {
-                    rect.setWidth(7);
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.rx() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.rx() -= tickSize;
-                }
-                rect.moveCenter(grooveCenter);
-                break;
-            }
-            default:
-                break;
-            }
-        }
-        break;
-#endif // QT_NO_SLIDER
-    case CC_ScrollBar:
-        break;
-#ifndef QT_NO_SPINBOX
-    case CC_SpinBox:
-        if (const QStyleOptionSpinBox *spinbox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
-            QSize bs;
-            int center = spinbox->rect.height() / 2;
-            int fw = spinbox->frame ? proxy()->pixelMetric(PM_SpinBoxFrameWidth, spinbox, widget) : 0;
-            int y = fw;
-            bs.setHeight(qMax(8, spinbox->rect.height()/2 - y));
-            bs.setWidth(15);
-            int x, lx, rx;
-            x = spinbox->rect.width() - y - bs.width() + 2;
-            lx = fw;
-            rx = x - fw;
-            switch (subControl) {
-            case SC_SpinBoxUp:
-                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
-                    return QRect();
-                rect = QRect(x, fw, bs.width(), center - fw);
-                break;
-            case SC_SpinBoxDown:
-                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons)
-                    return QRect();
-
-                rect = QRect(x, center, bs.width(), spinbox->rect.bottom() - center - fw + 1);
-                break;
-            case SC_SpinBoxEditField:
-                if (spinbox->buttonSymbols == QAbstractSpinBox::NoButtons) {
-                    rect = QRect(lx, fw, spinbox->rect.width() - 2*fw, spinbox->rect.height() - 2*fw);
-                } else {
-                    rect = QRect(lx, fw, rx - qMax(fw - 1, 0), spinbox->rect.height() - 2*fw);
-                }
-                break;
-            case SC_SpinBoxFrame:
-                rect = spinbox->rect;
-            default:
-                break;
-            }
-            rect = visualRect(spinbox->direction, spinbox->rect, rect);
-        }
-        break;
-#endif // Qt_NO_SPINBOX
-#ifndef QT_NO_GROUPBOX
-    case CC_GroupBox:
-        if (const QStyleOptionGroupBox *groupBox = qstyleoption_cast<const QStyleOptionGroupBox *>(option)) {
-            int topMargin = 0;
-            int topHeight = 0;
-            int verticalAlignment = proxy()->styleHint(SH_GroupBox_TextLabelVerticalAlignment, groupBox, widget);
-            bool flat = groupBox->features & QStyleOptionFrameV2::Flat;
-            if (!groupBox->text.isEmpty()) {
-                topHeight = groupBox->fontMetrics.height();
-                if (verticalAlignment & Qt::AlignVCenter)
-                    topMargin = topHeight / 2;
-                else if (verticalAlignment & Qt::AlignTop)
-                    topMargin = topHeight;
-            }
-            QRect frameRect = groupBox->rect;
-            frameRect.setTop(topMargin);
-            if (subControl == SC_GroupBoxFrame) {
-                return rect;
-            }
-            else if (subControl == SC_GroupBoxContents) {
-                if( flat ) {
-                    int margin = 0;
-                    int leftMarginExtension = 16;
-                    rect = frameRect.adjusted(leftMarginExtension + margin, margin + topHeight, -margin, -margin);
-                }
-                break;
-            }
-            if(flat) {
-                if (const QGroupBox *groupBoxWidget = qobject_cast<const QGroupBox *>(widget)) {
-                    //Prepare metrics for a bold font
-                    QFont font = widget->font();
-                    font.setBold(true);
-                    QFontMetrics fontMetrics(font);
-
-                    QSize textRect = fontMetrics.boundingRect(groupBoxWidget->title()).size() + QSize(2, 2);
-                    if (subControl == SC_GroupBoxCheckBox) {
-                        int indicatorWidth = proxy()->pixelMetric(PM_IndicatorWidth, option, widget);
-                        int indicatorHeight = proxy()->pixelMetric(PM_IndicatorHeight, option, widget);
-                        rect.setWidth(indicatorWidth);
-                        rect.setHeight(indicatorHeight);
-                        rect.moveTop((fontMetrics.height() - indicatorHeight) / 2 + 2);
-                    } else if (subControl == SC_GroupBoxLabel) {
-                        rect.setSize(textRect);
-                    }
-                }
-            }
-        }
-        return rect;
-#ifndef QT_NO_COMBOBOX
-    case CC_ComboBox:
-        switch (subControl) {
-        case SC_ComboBoxArrow:
-            rect = visualRect(option->direction, option->rect, rect);
-            rect.setRect(rect.right() - 18, rect.top() - 2,
-                         19, rect.height() + 4);
-            rect = visualRect(option->direction, option->rect, rect);
-            break;
-        case SC_ComboBoxEditField: {
-            int frameWidth = proxy()->pixelMetric(PM_DefaultFrameWidth);
-            rect = visualRect(option->direction, option->rect, rect);
-            rect.setRect(option->rect.left() + frameWidth, option->rect.top() + frameWidth,
-                         option->rect.width() - 19 - 2 * frameWidth,
-                         option->rect.height() - 2 * frameWidth);
-            if (const QStyleOptionComboBox *box = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
-                if (!box->editable) {
-                    rect.adjust(2, 0, 0, 0);
-                    if (box->state & (State_Sunken | State_On))
-                        rect.translate(1, 1);
-                }
-            }
-            rect = visualRect(option->direction, option->rect, rect);
-            break;
-        }
-        default:
-            break;
-        }
-        break;
-#endif // QT_NO_COMBOBOX
-#endif //QT_NO_GROUPBOX
-        case CC_TitleBar:
-        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
-            SubControl sc = subControl;
-            QRect &ret = rect;
-            const int indent = 3;
-            const int controlTopMargin = 3;
-            const int controlBottomMargin = 3;
-            const int controlWidthMargin = 2;
-            const int controlHeight = tb->rect.height() - controlTopMargin - controlBottomMargin ;
-            const int delta = controlHeight + controlWidthMargin;
-            int offset = 0;
-
-            bool isMinimized = tb->titleBarState & Qt::WindowMinimized;
-            bool isMaximized = tb->titleBarState & Qt::WindowMaximized;
-
-            switch (sc) {
-            case SC_TitleBarLabel:
-                if (tb->titleBarFlags & (Qt::WindowTitleHint | Qt::WindowSystemMenuHint)) {
-                    ret = tb->rect;
-                    if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
-                        ret.adjust(delta, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowMinimizeButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowMaximizeButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowShadeButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                }
-                break;
-            case SC_TitleBarContextHelpButton:
-                if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
-                    offset += delta;
-            case SC_TitleBarMinButton:
-                if (!isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarMinButton)
-                    break;
-            case SC_TitleBarNormalButton:
-                if (isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
-                    offset += delta;
-                else if (isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarNormalButton)
-                    break;
-            case SC_TitleBarMaxButton:
-                if (!isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarMaxButton)
-                    break;
-            case SC_TitleBarShadeButton:
-                if (!isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarShadeButton)
-                    break;
-            case SC_TitleBarUnshadeButton:
-                if (isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarUnshadeButton)
-                    break;
-            case SC_TitleBarCloseButton:
-                if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
-                    offset += delta;
-                else if (sc == SC_TitleBarCloseButton)
-                    break;
-                ret.setRect(tb->rect.right() - indent - offset, tb->rect.top() + controlTopMargin,
-                            controlHeight, controlHeight);
-                break;
-            case SC_TitleBarSysMenu:
-                if (tb->titleBarFlags & Qt::WindowSystemMenuHint) {
-                    ret.setRect(tb->rect.left() + controlWidthMargin + indent, tb->rect.top() + controlTopMargin,
-                                controlHeight, controlHeight);
-                }
-                break;
-            default:
-                break;
-            }
-            ret = visualRect(tb->direction, tb->rect, ret);
-        }
-        break;
-    default:
-        break;
-    }
-
-    return rect;
-}
-
-
-/*!
-  \reimp
-*/
-QRect QCleanlooksStyle::itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const
-{
-    return QWindowsStyle::itemPixmapRect(r, flags, pixmap);
-}
-
-/*!
-  \reimp
-*/
-void QCleanlooksStyle::drawItemPixmap(QPainter *painter, const QRect &rect,
-                            int alignment, const QPixmap &pixmap) const
-{
-    QWindowsStyle::drawItemPixmap(painter, rect, alignment, pixmap);
-}
-
-/*!
-  \reimp
-*/
-QStyle::SubControl QCleanlooksStyle::hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
-                              const QPoint &pt, const QWidget *w) const
-{
-    return QWindowsStyle::hitTestComplexControl(cc, opt, pt, w);
-}
-
-/*!
-  \reimp
-*/
-QPixmap QCleanlooksStyle::generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
-                                        const QStyleOption *opt) const
-{
-    return QWindowsStyle::generatedIconPixmap(iconMode, pixmap, opt);
-}
-
-/*!
-  \reimp
-*/
-int QCleanlooksStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,
-                               QStyleHintReturn *returnData) const
-{
-    int ret = 0;
-    switch (hint) {
-    case SH_ScrollBar_MiddleClickAbsolutePosition:
-        ret = true;
-        break;
-    case SH_EtchDisabledText:
-        ret = 1;
-        break;
-    case SH_Menu_AllowActiveAndDisabled:
-        ret = false;
-        break;
-    case SH_MainWindow_SpaceBelowMenuBar:
-        ret = 0;
-        break;
-    case SH_MenuBar_MouseTracking:
-        ret = 1;
-        break;
-    case SH_TitleBar_AutoRaise:
-        ret = 1;
-        break;
-    case SH_TitleBar_NoBorder:
-        ret = 1;
-        break;
-    case SH_ItemView_ShowDecorationSelected:
-        ret = true;
-        break;
-    case SH_Table_GridLineColor:
-        if (option) {
-            ret = option->palette.background().color().darker(120).rgb();
-            break;
-        }
-    case SH_ComboBox_Popup:
-        if (const QStyleOptionComboBox *cmb = qstyleoption_cast<const QStyleOptionComboBox *>(option))
-            ret = !cmb->editable;
-        else
-            ret = 0;
-        break;
-    case SH_WindowFrame_Mask:
-        ret = 1;
-        if (QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask *>(returnData)) {
-            //left rounded corner
-            mask->region = option->rect;
-            mask->region -= QRect(option->rect.left(), option->rect.top(), 5, 1);
-            mask->region -= QRect(option->rect.left(), option->rect.top() + 1, 3, 1);
-            mask->region -= QRect(option->rect.left(), option->rect.top() + 2, 2, 1);
-            mask->region -= QRect(option->rect.left(), option->rect.top() + 3, 1, 2);
-
-            //right rounded corner
-            mask->region -= QRect(option->rect.right() - 4, option->rect.top(), 5, 1);
-            mask->region -= QRect(option->rect.right() - 2, option->rect.top() + 1, 3, 1);
-            mask->region -= QRect(option->rect.right() - 1, option->rect.top() + 2, 2, 1);
-            mask->region -= QRect(option->rect.right() , option->rect.top() + 3, 1, 2);
-        }
-        break;
-    case SH_MessageBox_TextInteractionFlags:
-        ret = Qt::TextSelectableByMouse | Qt::LinksAccessibleByMouse;
-        break;
-    case SH_DialogButtonBox_ButtonsHaveIcons:
-        ret = false;
-        break;
-    case SH_MessageBox_CenterButtons:
-        ret = false;
-        break;
-#ifndef QT_NO_WIZARD
-    case SH_WizardStyle:
-        ret = QWizard::ClassicStyle;
-        break;
-#endif
-    case SH_ItemView_ArrowKeysNavigateIntoChildren:
-        ret = false;
-        break;
-    case SH_Menu_SubMenuPopupDelay:
-        ret = 225; // default from GtkMenu
-        break;
-    default:
-        ret = QWindowsStyle::styleHint(hint, option, widget, returnData);
-        break;
-    }
-    return ret;
-}
-
-/*! \reimp */
-QRect QCleanlooksStyle::subElementRect(SubElement sr, const QStyleOption *opt, const QWidget *w) const
-{
-    QRect r = QWindowsStyle::subElementRect(sr, opt, w);
-    switch (sr) {
-    case SE_PushButtonFocusRect:
-        r.adjust(0, 1, 0, -1);
-        break;
-    case SE_DockWidgetTitleBarText: {
-        const QStyleOptionDockWidgetV2 *v2
-            = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(opt);
-        bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
-        if (verticalTitleBar) {
-            r.adjust(0, 0, 0, -4);
-        } else {
-            if (opt->direction == Qt::LeftToRight)
-                r.adjust(4, 0, 0, 0);
-            else
-                r.adjust(0, 0, -4, 0);
-        }
-
-        break;
-    }
-    case SE_ProgressBarContents:
-        r = subElementRect(SE_ProgressBarGroove, opt, w);
-        break;
-    default:
-        break;
-    }
-    return r;
-}
-
-/*!
-    \reimp
-*/
-QIcon QCleanlooksStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption *option,
-                                     const QWidget *widget) const
-{
-    return QWindowsStyle::standardIcon(standardIcon, option, widget);
-}
-
-/*!
- \reimp
- */
-QPixmap QCleanlooksStyle::standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
-                                      const QWidget *widget) const
-{
-    QPixmap pixmap;
-
-#ifndef QT_NO_IMAGEFORMAT_XPM
-    switch (standardPixmap) {
-    case SP_TitleBarNormalButton:
-        return QPixmap((const char **)dock_widget_restore_xpm);
-    case SP_TitleBarMinButton:
-        return QPixmap((const char **)workspace_minimize);
-    case SP_TitleBarCloseButton:
-    case SP_DockWidgetCloseButton:
-        return QPixmap((const char **)dock_widget_close_xpm);
-
-    default:
-        break;
-    }
-#endif //QT_NO_IMAGEFORMAT_XPM
-
-    return QWindowsStyle::standardPixmap(standardPixmap, opt, widget);
-}
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_STYLE_CLEANLOOKS || QT_PLUGIN
diff --git a/src/widgets/styles/qcleanlooksstyle.h b/src/widgets/styles/qcleanlooksstyle.h
deleted file mode 100644
index 7e19032..0000000
--- a/src/widgets/styles/qcleanlooksstyle.h
+++ /dev/null
@@ -1,111 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCLEANLOOKSSTYLE_H
-#define QCLEANLOOKSSTYLE_H
-
-#include <QtWidgets/qwindowsstyle.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-#if !defined(QT_NO_STYLE_CLEANLOOKS)
-
-class QCleanlooksStylePrivate;
-class Q_WIDGETS_EXPORT QCleanlooksStyle : public QWindowsStyle
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QCleanlooksStyle)
-
-public:
-    QCleanlooksStyle();
-    ~QCleanlooksStyle();
-
-    QPalette standardPalette () const;
-    void drawPrimitive(PrimitiveElement elem,
-                        const QStyleOption *option,
-                        QPainter *painter, const QWidget *widget = 0) const;
-    void drawControl(ControlElement ce, const QStyleOption *option, QPainter *painter,
-                                const QWidget *widget) const;
-    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;
-    void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
-                            QPainter *painter, const QWidget *widget) const;
-    QRect subElementRect(SubElement r, const QStyleOption *opt, const QWidget *widget = 0) const;
-    QSize sizeFromContents(ContentsType type, const QStyleOption *option,
-                           const QSize &size, const QWidget *widget) const;
-    SubControl hitTestComplexControl(ComplexControl cc, const QStyleOptionComplex *opt,
-                               const QPoint &pt, const QWidget *w = 0) const;
-    QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
-                         SubControl sc, const QWidget *widget) const;
-    QPixmap generatedIconPixmap(QIcon::Mode iconMode, const QPixmap &pixmap,
-                                        const QStyleOption *opt) const;
-    int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
-                  QStyleHintReturn *returnData = 0) const;
-    QRect itemPixmapRect(const QRect &r, int flags, const QPixmap &pixmap) const;
-    QIcon standardIcon(StandardPixmap standardIcon, const QStyleOption *option = 0,
-                       const QWidget *widget = 0) const;
-    QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
-                           const QWidget *widget = 0) const;
-    void drawItemPixmap(QPainter *painter, const QRect &rect,
-                        int alignment, const QPixmap &pixmap) const;
-    void drawItemText(QPainter *painter, const QRect &rect,
-                              int flags, const QPalette &pal, bool enabled,
-                              const QString &text, QPalette::ColorRole textRole = QPalette::NoRole) const;
-    void polish(QWidget *widget);
-    void polish(QApplication *app);
-    void polish(QPalette &pal);
-    void unpolish(QWidget *widget);
-    void unpolish(QApplication *app);
-
-protected:
-    QCleanlooksStyle(QCleanlooksStylePrivate &dd);
-
-};
-
-#endif // QT_NO_STYLE_CLEANLOOKS
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QCLEANLOOKSSTYLE_H
diff --git a/src/widgets/styles/qcleanlooksstyle_p.h b/src/widgets/styles/qcleanlooksstyle_p.h
deleted file mode 100644
index 5a6bef5..0000000
--- a/src/widgets/styles/qcleanlooksstyle_p.h
+++ /dev/null
@@ -1,79 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QCLEANLOOKSSTYLE_P_H
-#define QCLEANLOOKSSTYLE_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists for the convenience
-// of qapplication_*.cpp, qwidget*.cpp and qfiledialog.cpp.  This header
-// file may change from version to version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "qwindowsstyle.h"
-#include "qwindowsstyle_p.h"
-
-#ifndef QT_NO_STYLE_CLEANLOOKS
-
-QT_BEGIN_NAMESPACE
-
-class QCleanlooksStylePrivate : public QWindowsStylePrivate
-{
-    Q_DECLARE_PUBLIC(QCleanlooksStyle)
-public:
-    QCleanlooksStylePrivate()
-        : QWindowsStylePrivate() {
-    }
-
-    ~QCleanlooksStylePrivate() {
-    }
-};
-
-QT_END_NAMESPACE
-
-#endif // QT_NO_STYLE_CLEANLOOKS
-
-#endif //QCLEANLOOKSSTYLE_P_H
diff --git a/src/widgets/styles/qfusionstyle.cpp b/src/widgets/styles/qfusionstyle.cpp
index 3fc4cd0..8e52a4b 100644
--- a/src/widgets/styles/qfusionstyle.cpp
+++ b/src/widgets/styles/qfusionstyle.cpp
@@ -350,7 +350,7 @@ QFusionStylePrivate::QFusionStylePrivate()
     The Fusion style provides a custom look and feel that is not
     tied to a particular platform.
     //{Fusion Style Widget Gallery}
-    \sa QWindowsXPStyle, QMacStyle, QCommonStyle, QPlastiqueStyle
+    \sa QWindowsStyle, QWindowsVistaStyle, QMacStyle, QCommonStyle
 */
 
 /*!
@@ -3024,7 +3024,7 @@ QSize QFusionStyle::sizeFromContents(ContentsType type, const QStyleOption *opti
         newSize += QSize(2, 2);
         break;
     case CT_SpinBox:
-        newSize += QSize(0, -2);
+        newSize += QSize(0, -3);
         break;
     case CT_ComboBox:
         newSize += QSize(2, 4);
@@ -3478,7 +3478,7 @@ int QFusionStyle::styleHint(StyleHint hint, const QStyleOption *option, const QW
         return 0;
 
     case SH_Table_GridLineColor:
-        return option->palette.background().color().darker(120).rgb();
+        return option ? option->palette.background().color().darker(120).rgb() : 0;
 
     case SH_MessageBox_TextInteractionFlags:
         return Qt::TextSelectableByMouse | Qt::LinksAccessibleByMouse;
diff --git a/src/widgets/styles/qgtkstyle.cpp b/src/widgets/styles/qgtkstyle.cpp
index e9701f9..4a7f972 100644
--- a/src/widgets/styles/qgtkstyle.cpp
+++ b/src/widgets/styles/qgtkstyle.cpp
@@ -277,8 +277,7 @@ static GdkColor fromQColor(const QColor &color)
     Note: The style requires GTK+ version 2.10 or later.
           The Qt3-based "Qt" GTK+ theme engine will not work with QGtkStyle.
 
-    \sa {Cleanlooks Style Widget Gallery}, QWindowsXPStyle, QMacStyle, QWindowsStyle,
-        QPlastiqueStyle, QCleanlooksStyle
+    \sa QWindowsXPStyle, QMacStyle, QWindowsStyle, QFusionStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qmacstyle.qdoc b/src/widgets/styles/qmacstyle.qdoc
index e419f73..001f45b 100644
--- a/src/widgets/styles/qmacstyle.qdoc
+++ b/src/widgets/styles/qmacstyle.qdoc
@@ -81,7 +81,7 @@
     documentation.
 
     \image qmacstyle.png
-    \sa QWindowsXPStyle, QWindowsStyle, QPlastiqueStyle
+    \sa QWindowsXPStyle, QWindowsStyle, QFusionStyle
 */
 
 
diff --git a/src/widgets/styles/qplastiquestyle.cpp b/src/widgets/styles/qplastiquestyle.cpp
deleted file mode 100644
index 449783f..0000000
--- a/src/widgets/styles/qplastiquestyle.cpp
+++ /dev/null
@@ -1,5843 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "qplastiquestyle.h"
-
-#if !defined(QT_NO_STYLE_PLASTIQUE) || defined(QT_PLUGIN)
-
-static const bool AnimateBusyProgressBar = true;
-static const bool AnimateProgressBar = false;
-// #define QPlastique_MaskButtons
-static const int ProgressBarFps = 25;
-static const int blueFrameWidth =  2;  // with of line edit focus frame
-
-#include "qwindowsstyle_p.h"
-#include <qapplication.h>
-#include <qbitmap.h>
-#include <qabstractitemview.h>
-#include <qcheckbox.h>
-#include <qcombobox.h>
-#include <qdebug.h>
-#include <qdialogbuttonbox.h>
-#include <qformlayout.h>
-#include <qgroupbox.h>
-#include <qimage.h>
-#include <qlineedit.h>
-#include <qmainwindow.h>
-#include <qmenu.h>
-#include <qmenubar.h>
-#include <qpainter.h>
-#include <qpaintengine.h>
-#include <qpainterpath.h>
-#include <qpalette.h>
-#include <qpen.h>
-#include <qpixmap.h>
-#include <qpixmapcache.h>
-#include <qprogressbar.h>
-#include <qpushbutton.h>
-#include <qradiobutton.h>
-#include <qscrollbar.h>
-#include <qspinbox.h>
-#include <qsplitter.h>
-#include <qstyleoption.h>
-#include <qtextedit.h>
-#include <qtoolbar.h>
-#include <qtoolbox.h>
-#include <qtoolbutton.h>
-#include <qprocess.h>
-#include <qvarlengtharray.h>
-#include <limits.h>
-#include <private/qstylehelper_p.h>
-#include <qpa/qplatformtheme.h>
-#include <private/qguiapplication_p.h>
-#include <private/qstyleanimation_p.h>
-
-QT_BEGIN_NAMESPACE
-
-// from windows style
-static const int windowsItemFrame        =  2; // menu item frame width
-static const int windowsSepHeight        =  2; // separator item height
-static const int windowsItemHMargin      =  3; // menu item hor text margin
-static const int windowsItemVMargin      =  2; // menu item ver text margin
-static const int windowsArrowHMargin     =  6; // arrow horizontal margin
-static const int windowsTabSpacing       = 12; // space between text and tab
-static const int windowsRightBorder      = 15; // right border on windows
-static const int windowsCheckMarkWidth   = 12; // checkmarks width on windows
-
-static const char * const qt_plastique_slider_verticalhandle[] = {
-    "15 11 6 1",
-    "   c None",
-    "+  c #979797",
-    "@  c #C9C9C9",
-    "$  c #C1C1C1",
-    "b  c None",
-    "d  c None",
-    " $++++++++$    ",
-    "$+bbbbbbbb+$   ",
-    "+b $$      +$  ",
-    "+b $@       +$ ",
-    "+b           +$",
-    "+b           d+",
-    "+b          d+$",
-    "+b $$      d+$ ",
-    "+b $@     d+$  ",
-    "$+dddddddd+$   ",
-    " $++++++++$    "};
-
-static const char * const qt_plastique_slider_verticalhandle_left[] = {
-    "15 11 6 1",
-    "   c None",
-    "+  c #979797",
-    "@  c #C9C9C9",
-    "$  c #C1C1C1",
-    "b  c None",
-    "d  c None",
-    "    $++++++++$ ",
-    "   $+bbbbbbbb+$",
-    "  $+b     $$ d+",
-    " $+b      $@ d+",
-    "$+b          d+",
-    "+b           d+",
-    "$+           d+",
-    " $+       $$ d+",
-    "  $+      $@ d+",
-    "   $+dddddddd+$",
-    "    $++++++++$ "};
-
-static const char * const qt_plastique_slider_horizontalhandle[] = {
-    "11 15 6 1",
-    "   c None",
-    "+  c #979797",
-    "@  c #C9C9C9",
-    "$  c #C1C1C1",
-    "b  c None",
-    "d  c None",
-    " $+++++++$ ",
-    "$+bbbbbbb+$",
-    "+b       d+",
-    "+b$$   $$d+",
-    "+b$@   $@d+",
-    "+b       d+",
-    "+b       d+",
-    "+b       d+",
-    "+b       d+",
-    "+b       d+",
-    "$+      d+$",
-    " $+    d+$ ",
-    "  $+  d+$  ",
-    "   $+d+$   ",
-    "    $+$    "};
-
-static const char * const qt_plastique_slider_horizontalhandle_up[] = {
-    "11 15 6 1",
-    "   c None",
-    "+  c #979797",
-    "@  c #C9C9C9",
-    "$  c #C1C1C1",
-    "b  c None",
-    "d  c None",
-    "    $+$    ",
-    "   $+b+$   ",
-    "  $+b  +$  ",
-    " $+b    +$ ",
-    "$+b      +$",
-    "+b       d+",
-    "+b       d+",
-    "+b       d+",
-    "+b       d+",
-    "+b       d+",
-    "+b$$   $$d+",
-    "+b$@   $@d+",
-    "+b       d+",
-    "$+ddddddd+$",
-    " $+++++++$ "};
-
-static const char * const qt_scrollbar_button_arrow_left[] = {
-    "4 7 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "   *",
-    "  **",
-    " ***",
-    "****",
-    " ***",
-    "  **",
-    "   *"};
-
-static const char * const qt_scrollbar_button_arrow_right[] = {
-    "4 7 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "*   ",
-    "**  ",
-    "*** ",
-    "****",
-    "*** ",
-    "**  ",
-    "*   "};
-
-static const char * const qt_scrollbar_button_arrow_up[] = {
-    "7 4 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "   *   ",
-    "  ***  ",
-    " ***** ",
-    "*******"};
-
-static const char * const qt_scrollbar_button_arrow_down[] = {
-    "7 4 2 1",
-    "   c None",
-    "*  c #BFBFBF",
-    "*******",
-    " ***** ",
-    "  ***  ",
-    "   *   "};
-
-static const char * const qt_scrollbar_button_left[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    " .+++++++++++++.",
-    ".+#############+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    ".+<<<<<<<<<<<<<+",
-    " .+++++++++++++."};
-
-static const char * const qt_scrollbar_button_right[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    ".+++++++++++++. ",
-    "+#############+.",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+<<<<<<<<<<<<<+.",
-    ".+++++++++++++. "};
-
-static const char * const qt_scrollbar_button_up[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    " .++++++++++++. ",
-    ".+############+.",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+<<<<<<<<<<<<<<+",
-    ".++++++++++++++."};
-
-static const char * const qt_scrollbar_button_down[] = {
-    "16 16 6 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "#  c #FAFAFA",
-    "<  c #FAFAFA",
-    "*  c #FAFAFA",
-    "++++++++++++++++",
-    "+##############+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    "+#            <+",
-    ".+<<<<<<<<<<<<+.",
-    " .++++++++++++. "};
-
-static const char * const qt_scrollbar_slider_pattern_vertical[] = {
-    "10 18 3 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "..  ..  ..",
-    ".+  .+  .+",
-    "          ",
-    "          ",
-    "..  ..  ..",
-    ".+  .+  .+",
-    "          ",
-    "          ",
-    "..  ..  ..",
-    ".+  .+  .+",
-    "          ",
-    "          ",
-    "..  ..  ..",
-    ".+  .+  .+",
-    "          ",
-    "          ",
-    "..  ..  ..",
-    ".+  .+  .+"};
-
-static const char * const qt_scrollbar_slider_pattern_horizontal[] = {
-    "18 10 3 1",
-    "   c None",
-    ".  c #BFBFBF",
-    "+  c #979797",
-    "..  ..  ..  ..  ..",
-    ".+  .+  .+  .+  .+",
-    "                  ",
-    "                  ",
-    "..  ..  ..  ..  ..",
-    ".+  .+  .+  .+  .+",
-    "                  ",
-    "                  ",
-    "..  ..  ..  ..  ..",
-    ".+  .+  .+  .+  .+"};
-
-static const char * const qt_toolbarhandle[] = {
-    "6 6 4 1",
-    "       c None",
-    ".      c #C5C5C5",
-    "+      c #EEEEEE",
-    "@      c #FAFAFA",
-    "..    ",
-    ".+@   ",
-    " @@   ",
-    "   .. ",
-    "   .+@",
-    "    @@"};
-
-static const char * const qt_simple_toolbarhandle[] = {
-    "3 3 4 1",
-    "       c None",
-    ".      c #C5C5C5",
-    "+      c #EEEEEE",
-    "@      c #FAFAFA",
-    ".. ",
-    ".+@",
-    " @@"};
-
-static const char * const qt_titlebar_context_help[] = {
-"27 27 5 1",
-"  c None",
-". c #0A0C12",
-"+ c #1B202D",
-"@ c #293144",
-"# c #3C435D",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"           +@##@+          ",
-"         .@@@.+@@..        ",
-"         .##+  +@@+.       ",
-"         .##@  @#@+.       ",
-"         ....  +@+..       ",
-"            .@+@@..        ",
-"            +#@@+          ",
-"            .##.           ",
-"            .++.           ",
-"            .++.           ",
-"            +##+           ",
-"            .@@.           ",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"                           ",
-"                           "};
-
-static QLinearGradient qMapGradientToRect(const QLinearGradient &gradient, const QRectF &rect)
-{
-    QLinearGradient tmpGrad(rect.center().x(), rect.top(),
-                            rect.center().x(), rect.bottom());
-    tmpGrad.setStops(gradient.stops());
-    return tmpGrad;
-}
-
-static QBrush qMapBrushToRect(const QBrush &brush, const QRectF &rect)
-{
-    if (!brush.gradient())
-        return brush;
-
-    // ### Ugly assumption that it's a linear gradient
-    QBrush tmp(qMapGradientToRect(*static_cast<const QLinearGradient *>(brush.gradient()), rect));
-    return tmp;
-}
-
-static void qBrushSetAlphaF(QBrush *brush, qreal alpha)
-{
-    if (const QGradient *gradient = brush->gradient()) {
-        // Use the gradient. Call QColor::setAlphaF() on all color stops.
-        QGradientStops stops = gradient->stops();
-        QMutableVectorIterator<QGradientStop> it(stops);
-        QColor tmpColor;
-        while (it.hasNext()) {
-            it.next();
-            tmpColor = it.value().second;
-            tmpColor.setAlphaF(alpha * tmpColor.alphaF());
-            it.setValue(QPair<qreal, QColor>(it.value().first, tmpColor));
-        }
-
-        switch (gradient->type()) {
-        case QGradient::RadialGradient: {
-            QRadialGradient grad = *static_cast<const QRadialGradient *>(gradient);
-            grad.setStops(stops);
-            *brush = QBrush(grad);
-            break;
-        }
-        case QGradient::ConicalGradient: {
-            QConicalGradient grad = *static_cast<const QConicalGradient *>(gradient);
-            grad.setStops(stops);
-            *brush = QBrush(grad);
-            break;
-        }
-        default:
-            qWarning("QPlastiqueStyle::qBrushLight() - unknown gradient type"
-                     " - falling back to QLinearGradient");
-        case QGradient::LinearGradient: {
-            QLinearGradient grad = *static_cast<const QLinearGradient *>(gradient);
-            grad.setStops(stops);
-            *brush = QBrush(grad);
-            break;
-        }
-        }
-    } else if (!brush->texture().isNull()) {
-        // Modify the texture - ridiculously expensive.
-        QPixmap texture = brush->texture();
-        QPixmap pixmap;
-        QString name = QLatin1String("qbrushtexture-alpha")
-                       % HexString<qreal>(alpha)
-                       % HexString<qint64>(texture.cacheKey());
-        if (!QPixmapCache::find(name, pixmap)) {
-            QImage image = texture.toImage();
-            QRgb *rgb = reinterpret_cast<QRgb *>(image.bits());
-            int pixels = image.width() * image.height();
-            QColor tmpColor;
-            while (pixels--) {
-                tmpColor.setRgb(*rgb);
-                tmpColor.setAlphaF(alpha * tmpColor.alphaF());
-                *rgb++ = tmpColor.rgba();
-            }
-            pixmap = QPixmap::fromImage(image);
-            QPixmapCache::insert(name, pixmap);
-        }
-        brush->setTexture(pixmap);
-    } else {
-        // Use the color
-        QColor tmpColor = brush->color();
-        tmpColor.setAlphaF(alpha * tmpColor.alphaF());
-        brush->setColor(tmpColor);
-    }
-}
-
-static QBrush qBrushLight(QBrush brush, int light)
-{
-    if (const QGradient *gradient = brush.gradient()) {
-        // Use the gradient. Call QColor::lighter() on all color stops.
-        QGradientStops stops = gradient->stops();
-        QMutableVectorIterator<QGradientStop> it(stops);
-        while (it.hasNext()) {
-            it.next();
-            it.setValue(QPair<qreal, QColor>(it.value().first, it.value().second.lighter(light)));
-        }
-
-        switch (gradient->type()) {
-        case QGradient::RadialGradient: {
-            QRadialGradient grad = *static_cast<const QRadialGradient *>(gradient);
-            grad.setStops(stops);
-            brush = QBrush(grad);
-            break;
-        }
-        case QGradient::ConicalGradient: {
-            QConicalGradient grad = *static_cast<const QConicalGradient *>(gradient);
-            grad.setStops(stops);
-            brush = QBrush(grad);
-            break;
-        }
-        default:
-            qWarning("QPlastiqueStyle::qBrushLight() - unknown gradient type"
-                     " - falling back to QLinearGradient");
-        case QGradient::LinearGradient: {
-            QLinearGradient grad = *static_cast<const QLinearGradient *>(gradient);
-            grad.setStops(stops);
-            brush = QBrush(grad);
-            break;
-        }
-        }
-    } else if (!brush.texture().isNull()) {
-        // Modify the texture - ridiculously expensive.
-        QPixmap texture = brush.texture();
-        QPixmap pixmap;
-        QString name = QLatin1String("qbrushtexture-light")
-                       % HexString<int>(light)
-                       % HexString<qint64>(texture.cacheKey());
-
-        if (!QPixmapCache::find(name, pixmap)) {
-            QImage image = texture.toImage();
-            QRgb *rgb = reinterpret_cast<QRgb *>(image.bits());
-            int pixels = image.width() * image.height();
-            QColor tmpColor;
-            while (pixels--) {
-                tmpColor.setRgb(*rgb);
-                *rgb++ = tmpColor.lighter(light).rgba();
-            }
-            pixmap = QPixmap::fromImage(image);
-            QPixmapCache::insert(name, pixmap);
-        }
-        brush.setTexture(pixmap);
-    } else {
-        // Use the color
-        brush.setColor(brush.color().lighter(light));
-    }
-    return brush;
-}
-
-static QBrush qBrushDark(QBrush brush, int dark)
-{
-    if (const QGradient *gradient = brush.gradient()) {
-        // Use the gradient. Call QColor::darker() on all color stops.
-        QGradientStops stops = gradient->stops();
-        QMutableVectorIterator<QGradientStop> it(stops);
-        while (it.hasNext()) {
-            it.next();
-            it.setValue(QPair<qreal, QColor>(it.value().first, it.value().second.darker(dark)));
-        }
-
-        switch (gradient->type()) {
-        case QGradient::RadialGradient: {
-            QRadialGradient grad = *static_cast<const QRadialGradient *>(gradient);
-            grad.setStops(stops);
-            brush = QBrush(grad);
-            break;
-        }
-        case QGradient::ConicalGradient: {
-            QConicalGradient grad = *static_cast<const QConicalGradient *>(gradient);
-            grad.setStops(stops);
-            brush = QBrush(grad);
-            break;
-        }
-        default:
-            qWarning("QPlastiqueStyle::qBrushDark() - unknown gradient type"
-                     " - falling back to QLinearGradient");
-        case QGradient::LinearGradient: {
-            QLinearGradient grad = *static_cast<const QLinearGradient *>(gradient);
-            grad.setStops(stops);
-            brush = QBrush(grad);
-            break;
-        }
-        }
-    } else if (!brush.texture().isNull()) {
-        // Modify the texture - ridiculously expensive.
-        QPixmap texture = brush.texture();
-        QPixmap pixmap;
-        QString name = QLatin1String("qbrushtexture-dark")
-                       % HexString<int>(dark)
-                       % HexString<qint64>(texture.cacheKey());
-
-        if (!QPixmapCache::find(name, pixmap)) {
-            QImage image = texture.toImage();
-            QRgb *rgb = reinterpret_cast<QRgb *>(image.bits());
-            int pixels = image.width() * image.height();
-            QColor tmpColor;
-            while (pixels--) {
-                tmpColor.setRgb(*rgb);
-                *rgb++ = tmpColor.darker(dark).rgba();
-            }
-            pixmap = QPixmap::fromImage(image);
-            QPixmapCache::insert(name, pixmap);
-        }
-        brush.setTexture(pixmap);
-    } else {
-        // Use the color
-        brush.setColor(brush.color().darker(dark));
-    }
-    return brush;
-}
-
-/*
-    Draws a rounded frame using the provided brush for 1, and adds 0.5 alpha
-    for 0.
-
-     0111111110
-    01        10
-    1          1
-    1          1
-    1          1
-    01        10
-     0111111110
-*/
-static void qt_plastique_draw_frame(QPainter *painter, const QRect &rect, const QStyleOption *option,
-                                    QFrame::Shadow shadow = QFrame::Plain)
-{
-    QPen oldPen = painter->pen();
-    QBrush border;
-    QBrush corner;
-    QBrush innerTopLeft;
-    QBrush innerBottomRight;
-
-    if (shadow != QFrame::Plain && (option->state & QStyle::State_HasFocus)) {
-        border = option->palette.highlight();
-        qBrushSetAlphaF(&border, qreal(0.8));
-        corner = option->palette.highlight();
-        qBrushSetAlphaF(&corner, 0.5);
-        innerTopLeft = qBrushDark(option->palette.highlight(), 125);
-        innerBottomRight = option->palette.highlight();
-        qBrushSetAlphaF(&innerBottomRight, qreal(0.65));
-    } else {
-        border = option->palette.shadow();
-        qBrushSetAlphaF(&border, qreal(0.4));
-        corner = option->palette.shadow();
-        qBrushSetAlphaF(&corner, 0.25);
-        innerTopLeft = option->palette.shadow();
-        innerBottomRight = option->palette.shadow();
-        if (shadow == QFrame::Sunken) {
-            qBrushSetAlphaF(&innerTopLeft, qreal(0.23));
-            qBrushSetAlphaF(&innerBottomRight, qreal(0.075));
-        } else {
-            qBrushSetAlphaF(&innerTopLeft, qreal(0.075));
-            qBrushSetAlphaF(&innerBottomRight, qreal(0.23));
-        }
-    }
-
-    QLine lines[4];
-    QPoint points[8];
-
-    // Opaque corner lines
-    painter->setPen(QPen(border, 0));
-    lines[0] = QLine(rect.left() + 2, rect.top(), rect.right() - 2, rect.top());
-    lines[1] = QLine(rect.left() + 2, rect.bottom(), rect.right() - 2, rect.bottom());
-    lines[2] = QLine(rect.left(), rect.top() + 2, rect.left(), rect.bottom() - 2);
-    lines[3] = QLine(rect.right(), rect.top() + 2, rect.right(), rect.bottom() - 2);
-    painter->drawLines(lines, 4);
-
-    // Opaque corner dots
-    points[0] = QPoint(rect.left() + 1, rect.top() + 1);
-    points[1] = QPoint(rect.left() + 1, rect.bottom() - 1);
-    points[2] = QPoint(rect.right() - 1, rect.top() + 1);
-    points[3] = QPoint(rect.right() - 1, rect.bottom() - 1);
-    painter->drawPoints(points, 4);
-
-    // Shaded corner dots
-    painter->setPen(QPen(corner, 0));
-    points[0] = QPoint(rect.left(), rect.top() + 1);
-    points[1] = QPoint(rect.left(), rect.bottom() - 1);
-    points[2] = QPoint(rect.left() + 1, rect.top());
-    points[3] = QPoint(rect.left() + 1, rect.bottom());
-    points[4] = QPoint(rect.right(), rect.top() + 1);
-    points[5] = QPoint(rect.right(), rect.bottom() - 1);
-    points[6] = QPoint(rect.right() - 1, rect.top());
-    points[7] = QPoint(rect.right() - 1, rect.bottom());
-    painter->drawPoints(points, 8);
-
-    // Shadows
-    if (shadow != QFrame::Plain) {
-        painter->setPen(QPen(innerTopLeft, 0));
-        lines[0] = QLine(rect.left() + 2, rect.top() + 1, rect.right() - 2, rect.top() + 1);
-        lines[1] = QLine(rect.left() + 1, rect.top() + 2, rect.left() + 1, rect.bottom() - 2);
-        painter->drawLines(lines, 2);
-        painter->setPen(QPen(innerBottomRight, 0));
-        lines[0] = QLine(rect.left() + 2, rect.bottom() - 1, rect.right() - 2, rect.bottom() - 1);
-        lines[1] = QLine(rect.right() - 1, rect.top() + 2, rect.right() - 1, rect.bottom() - 2);
-        painter->drawLines(lines, 2);
-    }
-
-    painter->setPen(oldPen);
-}
-
-static QColor mergedColors(const QColor &colorA, const QColor &colorB, int factor = 50)
-{
-    const int maxFactor = 100;
-    QColor tmp = colorA;
-    tmp.setRed((tmp.red() * factor) / maxFactor + (colorB.red() * (maxFactor - factor)) / maxFactor);
-    tmp.setGreen((tmp.green() * factor) / maxFactor + (colorB.green() * (maxFactor - factor)) / maxFactor);
-    tmp.setBlue((tmp.blue() * factor) / maxFactor + (colorB.blue() * (maxFactor - factor)) / maxFactor);
-    return tmp;
-}
-
-static void qt_plastique_draw_gradient(QPainter *painter, const QRect &rect, const QColor &gradientStart,
-                                       const QColor &gradientStop)
-{
-    QString gradientName = QLatin1String("qplastique-g")
-                   % HexString<int>(rect.width())
-                   % HexString<int>(rect.height())
-                   % HexString<QRgb>(gradientStart.rgba())
-                   % HexString<QRgb>(gradientStop.rgba());
-
-    QPixmap cache;
-    QPainter *p = painter;
-    QRect r = rect;
-
-    bool doPixmapCache = painter->deviceTransform().isIdentity()
-	&& painter->worldMatrix().isIdentity();
-    if (doPixmapCache && QPixmapCache::find(gradientName, cache)) {
-        painter->drawPixmap(rect, cache);
-    } else {
-        if (doPixmapCache) {
-            cache = QPixmap(rect.size());
-            cache.fill(Qt::transparent);
-            p = new QPainter(&cache);
-	    r = QRect(0, 0, rect.width(), rect.height());
-        }
-
-        int x = r.center().x();
-        QLinearGradient gradient(x, r.top(), x, r.bottom());
-        gradient.setColorAt(0, gradientStart);
-        gradient.setColorAt(1, gradientStop);
-        p->fillRect(r, gradient);
-
-        if (doPixmapCache) {
-	    p->end();
-	    delete p;
-	    painter->drawPixmap(rect, cache);
-            QPixmapCache::insert(gradientName, cache);
-	}
-    }
-}
-
-static void qt_plastique_drawFrame(QPainter *painter, const QStyleOption *option, const QWidget *widget)
-{
-    QRect rect = option->rect;
-    QPen oldPen = painter->pen();
-
-    QColor borderColor = option->palette.background().color().darker(178);
-    QColor gradientStartColor = option->palette.button().color().lighter(104);
-    QColor gradientStopColor = option->palette.button().color().darker(105);
-    QColor alphaCornerColor;
-    if (widget) {
-        // ### backgroundrole/foregroundrole should be part of the style option
-        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), borderColor);
-    } else {
-        alphaCornerColor = mergedColors(option->palette.background().color(), borderColor);
-    }
-
-    QLine lines[4];
-    QPoint points[8];
-
-    // outline / border
-    painter->setPen(borderColor);
-    lines[0] = QLine(rect.left() + 2, rect.top(), rect.right() - 2, rect.top());
-    lines[1] = QLine(rect.left() + 2, rect.bottom(), rect.right() - 2, rect.bottom());
-    lines[2] = QLine(rect.left(), rect.top() + 2, rect.left(), rect.bottom() - 2);
-    lines[3] = QLine(rect.right(), rect.top() + 2, rect.right(), rect.bottom() - 2);
-    painter->drawLines(lines, 4);
-
-    points[0] = QPoint(rect.left() + 1, rect.top() + 1);
-    points[1] = QPoint(rect.right() - 1, rect.top() + 1);
-    points[2] = QPoint(rect.left() + 1, rect.bottom() - 1);
-    points[3] = QPoint(rect.right() - 1, rect.bottom() - 1);
-    painter->drawPoints(points, 4);
-
-    painter->setPen(alphaCornerColor);
-
-    points[0] = QPoint(rect.left() + 1, rect.top());
-    points[1] = QPoint(rect.right() - 1, rect.top());
-    points[2] = QPoint(rect.left() + 1, rect.bottom());
-    points[3] = QPoint(rect.right() - 1, rect.bottom());
-    points[4] = QPoint(rect.left(), rect.top() + 1);
-    points[5] = QPoint(rect.right(), rect.top() + 1);
-    points[6] = QPoint(rect.left(), rect.bottom() - 1);
-    points[7] = QPoint(rect.right(), rect.bottom() - 1);
-    painter->drawPoints(points, 8);
-
-    // inner border
-    if ((option->state & QStyle::State_Sunken) || (option->state & QStyle::State_On))
-        painter->setPen(option->palette.button().color().darker(118));
-    else
-        painter->setPen(gradientStartColor);
-
-    lines[0] = QLine(rect.left() + 2, rect.top() + 1, rect.right() - 2, option->rect.top() + 1);
-    lines[1] = QLine(rect.left() + 1, rect.top() + 2, rect.left() + 1, option->rect.bottom() - 2);
-    painter->drawLines(lines, 2);
-
-    if ((option->state & QStyle::State_Sunken) || (option->state & QStyle::State_On))
-        painter->setPen(option->palette.button().color().darker(110));
-    else
-        painter->setPen(gradientStopColor.darker(102));
-
-    lines[0] = QLine(rect.left() + 2, rect.bottom() - 1, rect.right() - 2, rect.bottom() - 1);
-    lines[1] = QLine(rect.right() - 1, rect.top() + 2, rect.right() - 1, rect.bottom() - 2);
-    painter->drawLines(lines, 2);
-
-    painter->setPen(oldPen);
-}
-
-static void qt_plastique_drawShadedPanel(QPainter *painter, const QStyleOption *option, bool base,
-                                         const QWidget *widget)
-{
-    QRect rect = option->rect;
-    QPen oldPen = painter->pen();
-
-    QColor gradientStartColor = option->palette.button().color().lighter(104);
-    QColor gradientStopColor = option->palette.button().color().darker(105);
-
-    // gradient fill
-    if ((option->state & QStyle::State_Enabled) || !(option->state & QStyle::State_AutoRaise)) {
-        if ((option->state & QStyle::State_Sunken) || (option->state & QStyle::State_On)) {
-            qt_plastique_draw_gradient(painter, rect.adjusted(1, 1, -1, -1),
-                                       option->palette.button().color().darker(114),
-                                       option->palette.button().color().darker(106));
-        } else {
-            qt_plastique_draw_gradient(painter, rect.adjusted(1, 1, -1, -1),
-                                       base ? option->palette.background().color().lighter(105) : gradientStartColor,
-                                       base ? option->palette.background().color().darker(102) : gradientStopColor);
-        }
-    }
-
-    qt_plastique_drawFrame(painter, option, widget);
-
-    painter->setPen(oldPen);
-}
-
-static void qt_plastique_draw_mdibutton(QPainter *painter, const QStyleOptionTitleBar *option, const QRect &tmp, bool hover, bool sunken)
-{
-    if (tmp.isNull())
-        return;
-    bool active = (option->titleBarState & QStyle::State_Active);
-
-    // ### use palette colors instead
-    QColor mdiButtonGradientStartColor;
-    QColor mdiButtonGradientStopColor;
-    if (active) {
-        mdiButtonGradientStartColor = QColor((hover || sunken) ? 0x7d8bb1 : 0x55689a);
-        mdiButtonGradientStopColor = QColor((hover || sunken) ? 0x939ebe : 0x7381ab);
-    } else {
-        mdiButtonGradientStartColor = QColor((hover || sunken) ? 0x9e9e9e : 0x818181);
-        mdiButtonGradientStopColor = QColor((hover || sunken) ? 0xababab : 0x929292);
-    }
-
-    qt_plastique_draw_gradient(painter, tmp.adjusted(1, 1, -1, -1),
-                               mdiButtonGradientStartColor, mdiButtonGradientStopColor);
-
-    QColor mdiButtonBorderColor;
-    if (active) {
-        mdiButtonBorderColor = (hover || sunken) ? QColor(0x627097) : QColor(0x324577);
-    } else {
-        mdiButtonBorderColor = (hover || sunken) ? QColor(0x838383) : QColor(0x5e5e5e);
-    }
-    painter->setPen(QPen(mdiButtonBorderColor, 1));
-
-    const QLine lines[4] = {
-        QLine(tmp.left() + 2, tmp.top(), tmp.right() - 2, tmp.top()),
-        QLine(tmp.left() + 2, tmp.bottom(), tmp.right() - 2, tmp.bottom()),
-        QLine(tmp.left(), tmp.top() + 2, tmp.left(), tmp.bottom() - 2),
-        QLine(tmp.right(), tmp.top() + 2, tmp.right(), tmp.bottom() - 2) };
-    painter->drawLines(lines, 4);
-
-    const QPoint points[4] = {
-        QPoint(tmp.left() + 1, tmp.top() + 1),
-        QPoint(tmp.right() - 1, tmp.top() + 1),
-        QPoint(tmp.left() + 1, tmp.bottom() - 1),
-        QPoint(tmp.right() - 1, tmp.bottom() - 1) };
-    painter->drawPoints(points, 4);
-}
-
-#ifndef QT_NO_DOCKWIDGET
-static QString elliditide(const QString &text, const QFontMetrics &fontMetrics, const QRect &rect, int *textWidth = 0)
-{
-    // Chop and insert ellide into title if text is too wide
-    QString title = text;
-    int width = textWidth ? *textWidth : fontMetrics.width(text);
-    QString ellipsis = QLatin1String("...");
-    if (width > rect.width()) {
-        QString leftHalf = title.left(title.size() / 2);
-        QString rightHalf = title.mid(leftHalf.size() + 1);
-        while (!leftHalf.isEmpty() && !rightHalf.isEmpty()) {
-            leftHalf.chop(1);
-            int width = fontMetrics.width(leftHalf + ellipsis + rightHalf);
-            if (width < rect.width()) {
-                title = leftHalf + ellipsis + rightHalf;
-                break;
-            }
-            rightHalf.remove(0, 1);
-            width = fontMetrics.width(leftHalf + ellipsis + rightHalf);
-            if (width < rect.width()) {
-                title = leftHalf + ellipsis + rightHalf;
-                break;
-            }
-        }
-    }
-    if (textWidth)
-        *textWidth = width;
-    return title;
-}
-#endif
-
-#if !defined(QT_NO_DOCKWIDGET) || !defined(QT_NO_SPLITTER)
-static void qt_plastique_draw_handle(QPainter *painter, const QStyleOption *option,
-                                     const QRect &rect, Qt::Orientation orientation,
-                                     const QWidget *widget)
-{
-    QColor borderColor = option->palette.background().color().darker(178);
-    QColor alphaCornerColor;
-    if (widget) {
-        // ### backgroundrole/foregroundrole should be part of the style option
-        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), borderColor);
-    } else {
-        alphaCornerColor = mergedColors(option->palette.background().color(), borderColor);
-    }
-    QImage handle(qt_simple_toolbarhandle);
-    alphaCornerColor.setAlpha(170);
-    handle.setColor(1, alphaCornerColor.rgba());
-    handle.setColor(2, mergedColors(alphaCornerColor, option->palette.light().color()).rgba());
-    handle.setColor(3, option->palette.light().color().rgba());
-
-    const int spacing = 2;
-
-    if (orientation == Qt::Vertical) {
-        int nchunks = rect.width() / (handle.width() + spacing);
-        for (int i = 0; i < nchunks; ++i)
-            painter->drawImage(QPoint(rect.left() + i * (handle.width() + spacing), rect.top()), handle);
-    } else {
-        int nchunks = rect.height() / (handle.height() + spacing);
-        for (int i = 0; i < nchunks; ++i)
-            painter->drawImage(QPoint(rect.left(), rect.top() + i * (handle.height() + spacing)), handle);
-    }
-}
-#endif
-
-class QPlastiqueStylePrivate : public QWindowsStylePrivate
-{
-    Q_DECLARE_PUBLIC(QPlastiqueStyle)
-public:
-    QPlastiqueStylePrivate();
-    virtual ~QPlastiqueStylePrivate();
-    void drawPartialFrame(QPainter *painter, const QStyleOptionComplex *option,
-                          const QRect &rect, const QWidget *widget) const;
-};
-
-/*!
-  \internal
- */
-QPlastiqueStylePrivate::QPlastiqueStylePrivate() :
-    QWindowsStylePrivate()
-{
-}
-
-/*!
-  \internal
- */
-QPlastiqueStylePrivate::~QPlastiqueStylePrivate()
-{
-}
-
-/*!
-    \class QPlastiqueStyle
-    \brief The QPlastiqueStyle class provides a widget style similar to the
-    Plastik style available in KDE.
-
-    \inmodule QtWidgets
- 
-    The Plastique style provides a default look and feel for widgets on X11
-    that closely resembles the Plastik style, introduced by Sandro Giessl in
-    KDE 3.2.
-
-    \image qplastiquestyle.png
-    \sa QWindowsXPStyle, QMacStyle, QWindowsStyle
-*/
-
-/*!
-    Constructs a QPlastiqueStyle object.
-*/
-QPlastiqueStyle::QPlastiqueStyle()
-    : QWindowsStyle(*new QPlastiqueStylePrivate)
-{
-    setObjectName(QLatin1String("Plastique"));
-}
-
-/*!
-    Destructs the QPlastiqueStyle object.
-*/
-QPlastiqueStyle::~QPlastiqueStyle()
-{
-}
-
-/*
-    Used by spin- and combo box.
-    Draws a rounded frame around rect but omits the right hand edge
-*/
-void QPlastiqueStylePrivate::drawPartialFrame(QPainter *painter, const QStyleOptionComplex *option,
-                                              const QRect &rect, const QWidget *widget) const
-{
-    Q_Q(const QPlastiqueStyle);
-    bool reverse = option->direction == Qt::RightToLeft;
-    QStyleOptionFrame frameOpt;
-#ifndef QT_NO_LINEEDIT
-    if (QLineEdit *lineedit = widget->findChild<QLineEdit *>())
-        frameOpt.initFrom(lineedit);
-#else
-    Q_UNUSED(widget)
-#endif // QT_NO_LINEEDIT
-
-    frameOpt.rect = rect;
-    painter->save();
-    frameOpt.rect.adjust(-blueFrameWidth + (reverse ? 1 : 0), -blueFrameWidth,
-                          blueFrameWidth + (reverse ? 0 : -1), blueFrameWidth);
-    painter->setClipRect(frameOpt.rect);
-    frameOpt.rect.adjust(reverse ? -2 : 0, 0, reverse ? 0 : 2, 0);
-    frameOpt.lineWidth = q->pixelMetric(QStyle::PM_DefaultFrameWidth);
-    frameOpt.midLineWidth = 0;
-    frameOpt.state = option->state | QStyle::State_Sunken;
-    frameOpt.palette = option->palette;
-    q->drawPrimitive(QStyle::PE_PanelLineEdit, &frameOpt, painter, widget);
-    painter->restore();
-
-    // Draw a two pixel highlight on the flat edge
-    if (option->state & QStyle::State_HasFocus) {
-        painter->setPen(QPen(option->palette.highlight(), 0));
-        QBrush focusBorder = option->palette.highlight();
-        qBrushSetAlphaF(&focusBorder, qreal(0.65));
-        if (!reverse) {
-            painter->drawLine(rect.topRight()    + QPoint(1, -1),
-                              rect.bottomRight() + QPoint(1, 1));
-            painter->setPen(QPen(focusBorder, 0));
-            painter->drawLine(rect.topRight(),
-                              rect.bottomRight());
-        }
-        else {
-            painter->drawLine(rect.topLeft()    + QPoint(-1, -1),
-                              rect.bottomLeft() + QPoint(-1, 1));
-            painter->setPen(QPen(focusBorder, 0));
-            painter->drawLine(rect.topLeft(),
-                              rect.bottomLeft());
-        }
-    }
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::drawPrimitive(PrimitiveElement element, const QStyleOption *option,
-                                    QPainter *painter, const QWidget *widget) const
-{
-    Q_ASSERT(option);
-
-    QColor borderColor = option->palette.background().color().darker(178);
-    QColor alphaCornerColor;
-    if (widget) {
-        // ### backgroundrole/foregroundrole should be part of the style option
-        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), borderColor);
-    } else {
-        alphaCornerColor = mergedColors(option->palette.background().color(), borderColor);
-    }
-    QColor alphaTextColor = mergedColors(option->palette.background().color(), option->palette.text().color());
-
-    switch (element) {
-    case PE_IndicatorButtonDropDown:
-        proxy()->drawPrimitive(PE_PanelButtonTool, option, painter, widget);
-        break;
-    case PE_FrameDefaultButton: {
-        if (!(option->state & QStyle::State_Enabled))
-            break;
-        painter->setPen(QPen(QColor(0, 0, 0, 127), 0));
-        const QLine lines[4] = {
-            QLine(option->rect.left() + 2, option->rect.top(),
-                  option->rect.right() - 2, option->rect.top()),
-            QLine(option->rect.left() + 2, option->rect.bottom(),
-                  option->rect.right() - 2, option->rect.bottom()),
-            QLine(option->rect.left(), option->rect.top() + 2,
-                  option->rect.left(), option->rect.bottom() - 2),
-            QLine(option->rect.right(), option->rect.top() + 2,
-                  option->rect.right(), option->rect.bottom() - 2) };
-        painter->drawLines(lines, 4);
-
-        QPoint points[8];
-        points[0] = QPoint(option->rect.left() + 1, option->rect.top() + 1);
-        points[1] = QPoint(option->rect.right() - 1, option->rect.top() + 1);
-        points[2] = QPoint(option->rect.left() + 1, option->rect.bottom() - 1);
-        points[3] = QPoint(option->rect.right() - 1, option->rect.bottom() - 1);
-        painter->drawPoints(points, 4);
-
-        painter->setPen(QPen(QColor(0, 0, 0, 63), 0));
-        points[0] = QPoint(option->rect.left() + 1, option->rect.top());
-        points[1] = QPoint(option->rect.right() - 1, option->rect.top());
-        points[2] = QPoint(option->rect.left(), option->rect.top() + 1);
-        points[3] = QPoint(option->rect.right(), option->rect.top() + 1);
-        points[4] = QPoint(option->rect.left() + 1, option->rect.bottom());
-        points[5] = QPoint(option->rect.right() - 1, option->rect.bottom());
-        points[6] = QPoint(option->rect.left(), option->rect.bottom() - 1);
-        points[7] = QPoint(option->rect.right(), option->rect.bottom() - 1);
-        painter->drawPoints(points, 8);
-
-        break;
-    }
-#ifndef QT_NO_TABWIDGET
-    case PE_FrameTabWidget:
-        if (const QStyleOptionTabWidgetFrame *twf = qstyleoption_cast<const QStyleOptionTabWidgetFrame *>(option)) {
-            if (twf->shape != QTabBar::RoundedNorth && twf->shape != QTabBar::RoundedWest &&
-                twf->shape != QTabBar::RoundedSouth && twf->shape != QTabBar::RoundedEast) {
-                QWindowsStyle::drawPrimitive(element, option, painter, widget);
-                break;
-            }
-
-            int borderThickness = proxy()->pixelMetric(PM_TabBarBaseOverlap, twf, widget);
-            bool reverse = (twf->direction == Qt::RightToLeft);
-
-            painter->save();
-
-            // Start by filling the contents of the tab widget frame (which is
-            // actually a panel).
-            painter->fillRect(option->rect.adjusted(1, 1, -1, -1), option->palette.window());
-
-            QRect tabBarRect;
-            switch (twf->shape) {
-            case QTabBar::RoundedNorth:
-                if (reverse)
-                    tabBarRect = QRect(twf->rect.right() - twf->leftCornerWidgetSize.width() - twf->tabBarSize.width() + 1, twf->rect.top(), twf->tabBarSize.width(), borderThickness);
-                else
-                    tabBarRect = QRect(twf->rect.left() + twf->leftCornerWidgetSize.width(), twf->rect.top(), twf->tabBarSize.width(), borderThickness);
-                break ;
-            case QTabBar::RoundedWest:
-                tabBarRect = QRect(twf->rect.left(), twf->rect.top() + twf->leftCornerWidgetSize.height(), borderThickness, twf->tabBarSize.height());
-                break ;
-            case QTabBar::RoundedEast:
-                tabBarRect = QRect(twf->rect.right() - borderThickness + 1, twf->rect.top()  + twf->leftCornerWidgetSize.height(),
-                                   borderThickness, twf->tabBarSize.height());
-                break ;
-            case QTabBar::RoundedSouth:
-                if (reverse)
-                    tabBarRect = QRect(twf->rect.right() - twf->leftCornerWidgetSize.width() - twf->tabBarSize.width() + 1,
-                                       twf->rect.bottom() - borderThickness + 1, twf->tabBarSize.width(), borderThickness);
-                else
-                    tabBarRect = QRect(twf->rect.left() + twf->leftCornerWidgetSize.width(),
-                                       twf->rect.bottom() - borderThickness + 1, twf->tabBarSize.width(), borderThickness);
-                break ;
-            default:
-                break;
-            }
-
-            QRegion region(twf->rect);
-            region -= tabBarRect;
-            painter->setClipRegion(region);
-
-            // Outer border
-            QLine leftLine = QLine(twf->rect.topLeft() + QPoint(0, 2), twf->rect.bottomLeft() - QPoint(0, 2));
-            QLine rightLine = QLine(twf->rect.topRight() + QPoint(0, 2), twf->rect.bottomRight() - QPoint(0, 2));
-            QLine bottomLine = QLine(twf->rect.bottomLeft() + QPoint(2, 0), twf->rect.bottomRight() - QPoint(2, 0));
-            QLine topLine = QLine(twf->rect.topLeft() + QPoint(2, 0), twf->rect.topRight() - QPoint(2, 0));
-
-            QBrush border = option->palette.shadow();
-            qBrushSetAlphaF(&border, qreal(0.4));
-            painter->setPen(QPen(border, 0));
-
-            QVarLengthArray<QLine, 4> lines;
-            QVarLengthArray<QPoint, 8> points;
-
-            lines.append(topLine);
-
-            // Inner border
-            QLine innerLeftLine = QLine(leftLine.p1() + QPoint(1, 0), leftLine.p2() + QPoint(1, 0));
-            QLine innerRightLine = QLine(rightLine.p1() - QPoint(1, 0), rightLine.p2() - QPoint(1, 0));
-            QLine innerBottomLine = QLine(bottomLine.p1() - QPoint(0, 1), bottomLine.p2() - QPoint(0, 1));
-            QLine innerTopLine = QLine(topLine.p1() + QPoint(0, 1), topLine.p2() + QPoint(0, 1));
-
-            // Rounded Corner
-            QPoint leftBottomOuterCorner = QPoint(innerLeftLine.p2() + QPoint(0, 1));
-            QPoint leftBottomInnerCorner1 = QPoint(leftLine.p2() + QPoint(0, 1));
-            QPoint leftBottomInnerCorner2 = QPoint(bottomLine.p1() - QPoint(1, 0));
-            QPoint rightBottomOuterCorner = QPoint(innerRightLine.p2() + QPoint(0, 1));
-            QPoint rightBottomInnerCorner1 = QPoint(rightLine.p2() + QPoint(0, 1));
-            QPoint rightBottomInnerCorner2 = QPoint(bottomLine.p2() + QPoint(1, 0));
-            QPoint rightTopOuterCorner = QPoint(innerRightLine.p1() - QPoint(0, 1));
-            QPoint rightTopInnerCorner1 = QPoint(rightLine.p1() - QPoint(0, 1));
-            QPoint rightTopInnerCorner2 = QPoint(topLine.p2() + QPoint(1, 0));
-            QPoint leftTopOuterCorner = QPoint(innerLeftLine.p1() - QPoint(0, 1));
-            QPoint leftTopInnerCorner1 = QPoint(leftLine.p1() - QPoint(0, 1));
-            QPoint leftTopInnerCorner2 = QPoint(topLine.p1() - QPoint(1, 0));
-
-            lines.append(leftLine);
-            lines.append(rightLine);
-            lines.append(bottomLine);
-
-            painter->drawLines(lines.constData(), lines.size());
-            lines.clear();
-
-            points.append(leftBottomOuterCorner);
-            points.append(rightBottomOuterCorner);
-            points.append(rightTopOuterCorner);
-            points.append(leftTopOuterCorner);
-
-            painter->drawPoints(points.constData(), points.size());
-            points.clear();
-
-            QBrush innerTopLeft = option->palette.shadow();
-            qBrushSetAlphaF(&innerTopLeft, qreal(0.075));
-            painter->setPen(QPen(innerTopLeft, 0));
-
-            lines.append(innerLeftLine);
-            lines.append(innerTopLine);
-            painter->drawLines(lines.constData(), lines.size());
-            lines.clear();
-
-            QBrush innerBottomRight = option->palette.shadow();
-            qBrushSetAlphaF(&innerBottomRight, qreal(0.23));
-            painter->setPen(QPen(innerBottomRight, 0));
-            lines.append(innerRightLine);
-            lines.append(innerBottomLine);
-            painter->drawLines(lines.constData(), lines.size());
-            lines.clear();
-
-            QBrush corner = option->palette.shadow();
-            qBrushSetAlphaF(&corner, 0.25);
-            painter->setPen(QPen(corner, 0));
-            points.append(leftBottomInnerCorner1);
-            points.append(leftBottomInnerCorner2);
-            points.append(rightBottomInnerCorner1);
-            points.append(rightBottomInnerCorner2);
-            points.append(rightTopInnerCorner1);
-            points.append(rightTopInnerCorner2);
-            points.append(leftTopInnerCorner1);
-            points.append(leftTopInnerCorner2);
-            painter->drawPoints(points.constData(), points.size());
-            points.clear();
-
-            painter->restore();
-        }
-        break ;
-#endif // QT_NO_TABWIDGET
-#ifndef QT_NO_TABBAR
-    case PE_FrameTabBarBase:
-        if (const QStyleOptionTabBarBase *tbb = qstyleoption_cast<const QStyleOptionTabBarBase *>(option)) {
-            if (tbb->shape != QTabBar::RoundedNorth && tbb->shape != QTabBar::RoundedWest &&
-                tbb->shape != QTabBar::RoundedSouth && tbb->shape != QTabBar::RoundedEast) {
-                QWindowsStyle::drawPrimitive(element, option, painter, widget);
-                break;
-            }
-
-            painter->save();
-
-            QRegion region(tbb->rect);
-            region -= tbb->tabBarRect;
-            painter->setClipRegion(region);
-
-            QLine topLine = QLine(tbb->rect.bottomLeft() - QPoint(0, 1), tbb->rect.bottomRight() - QPoint(0, 1));
-            QLine bottomLine = QLine(tbb->rect.bottomLeft(), tbb->rect.bottomRight());
-
-            QBrush border = option->palette.shadow();
-            qBrushSetAlphaF(&border, qreal(0.4));
-            QBrush innerTopLeft = option->palette.shadow();
-            qBrushSetAlphaF(&innerTopLeft, qreal(0.075));
-            QBrush innerBottomRight = option->palette.shadow();
-            qBrushSetAlphaF(&innerBottomRight, qreal(0.23));
-            QBrush corner = option->palette.shadow();
-            qBrushSetAlphaF(&corner, 0.25);
-
-            if (tbb->shape == QTabBar::RoundedSouth)
-                painter->setPen(QPen(corner, 0));
-            else
-                painter->setPen(QPen(border, 0));
-            painter->drawLine(topLine);
-
-            if (tbb->shape != QTabBar::RoundedSouth)
-                painter->setPen(QPen(innerTopLeft, 0));
-            else
-                painter->setPen(QPen(border, 0));
-            painter->drawLine(bottomLine);
-
-            painter->restore();
-        }
-        break ;
-#endif // QT_NO_TABBAR
-#ifndef QT_NO_GROUPBOX
-    case PE_FrameGroupBox:
-        if (const QStyleOptionFrame *frame = qstyleoption_cast<const QStyleOptionFrame *>(option)) {
-            QStyleOptionFrameV2 frameV2(*frame);
-            if (frameV2.features & QStyleOptionFrameV2::Flat) {
-                QPen oldPen = painter->pen();
-                painter->setPen(borderColor);
-                painter->drawLine(frameV2.rect.topLeft(), frameV2.rect.topRight());
-                painter->setPen(oldPen);
-            } else {
-                frameV2.state &= ~(State_Sunken | State_HasFocus);
-                proxy()->drawPrimitive(PE_Frame, &frameV2, painter, widget);
-            }
-        }
-        break;
-#endif // QT_NO_GROUPBOX
-    case PE_Frame: {
-        QFrame::Shadow shadow = QFrame::Plain;
-        if (option->state & State_Sunken)
-            shadow = QFrame::Sunken;
-        else if (option->state & State_Raised)
-            shadow = QFrame::Raised;
-        qt_plastique_draw_frame(painter, option->rect, option, shadow);
-        break;
-    }
-#ifndef QT_NO_LINEEDIT
-    case PE_FrameLineEdit:
-        qt_plastique_draw_frame(painter, option->rect, option, QFrame::Sunken);
-        break;
-    case PE_PanelLineEdit:
-        if (const QStyleOptionFrame *lineEdit = qstyleoption_cast<const QStyleOptionFrame *>(option)) {
-            // Panel of a line edit inside combo box or spin box is drawn in CC_ComboBox and CC_SpinBox
-            if (widget) {
-#ifndef QT_NO_SPINBOX
-                // Spinbox doesn't need a separate palette for the lineedit
-                if (qobject_cast<const QAbstractSpinBox *>(widget->parentWidget()))
-                    break;
-#endif
-            }
-
-            painter->save();
-
-            // Fill the line edit insides
-            QRect filledRect = lineEdit->rect.adjusted(1, 1, -1, -1);
-            QBrush baseBrush = qMapBrushToRect(lineEdit->palette.base(), filledRect);
-            painter->setBrushOrigin(filledRect.topLeft());
-            painter->fillRect(filledRect.adjusted(1, 1, -1, -1), baseBrush);
-
-            painter->setPen(QPen(baseBrush, 0));
-            const QLine lines[4] = {
-                QLine(filledRect.left(), filledRect.top() + 1,
-                      filledRect.left(), filledRect.bottom() - 1),
-                QLine(filledRect.right(), filledRect.top() + 1,
-                      filledRect.right(), filledRect.bottom() - 1),
-                QLine(filledRect.left() + 1, filledRect.top(),
-                      filledRect.right() - 1, filledRect.top()),
-                QLine(filledRect.left() + 1, filledRect.bottom(),
-                      filledRect.right() - 1, filledRect.bottom()) };
-            painter->drawLines(lines, 4);
-
-            if (lineEdit->lineWidth != 0)
-                qt_plastique_draw_frame(painter, option->rect, option, QFrame::Sunken);
-
-            painter->restore();
-            break;
-        }
-#endif // QT_NO_LINEEDIT
-    case PE_FrameDockWidget:
-    case PE_FrameMenu:
-    case PE_FrameStatusBarItem: {
-        // Draws the frame around a popup menu.
-        QPen oldPen = painter->pen();
-        painter->setPen(borderColor);
-        painter->drawRect(option->rect.adjusted(0, 0, -1, -1));
-        painter->setPen(alphaCornerColor);
-        const QPoint points[4] = {
-            QPoint(option->rect.topLeft()),
-            QPoint(option->rect.topRight()),
-            QPoint(option->rect.bottomLeft()),
-            QPoint(option->rect.bottomRight()) };
-        painter->drawPoints(points, 4);
-        painter->setPen(oldPen);
-        break;
-    }
-#ifndef QT_NO_MAINWINDOW
-    case PE_PanelMenuBar:
-        if ((widget && qobject_cast<const QMainWindow *>(widget->parentWidget()))
-            ) {
-            // Draws the light line above and the dark line below menu bars and
-            // tool bars.
-            QPen oldPen = painter->pen();
-            if (element == PE_PanelMenuBar || (option->state & State_Horizontal)) {
-                painter->setPen(alphaCornerColor);
-                painter->drawLine(option->rect.left(), option->rect.bottom(),
-                                  option->rect.right(), option->rect.bottom());
-                painter->setPen(option->palette.background().color().lighter(104));
-                painter->drawLine(option->rect.left(), option->rect.top(),
-                                  option->rect.right(), option->rect.top());
-            } else {
-                painter->setPen(option->palette.background().color().lighter(104));
-                painter->drawLine(option->rect.left(), option->rect.top(),
-                                  option->rect.left(), option->rect.bottom());
-                painter->setPen(alphaCornerColor);
-                painter->drawLine(option->rect.right(), option->rect.top(),
-                                  option->rect.right(), option->rect.bottom());
-            }
-            painter->setPen(oldPen);
-        }
-        break;
-#endif // QT_NO_MAINWINDOW
-    case PE_IndicatorHeaderArrow: {
-        bool usedAntialiasing = painter->renderHints() & QPainter::Antialiasing;
-        if (!usedAntialiasing)
-            painter->setRenderHint(QPainter::Antialiasing);
-        QWindowsStyle::drawPrimitive(element, option, painter, widget);
-        if (!usedAntialiasing)
-            painter->setRenderHint(QPainter::Antialiasing, false);
-        break;
-    }
-    case PE_PanelButtonTool:
-        // Draws a tool button (f.ex., in QToolBar and QTabBar)
-        if ((option->state & State_Enabled || option->state & State_On) || !(option->state & State_AutoRaise))
-            qt_plastique_drawShadedPanel(painter, option, true, widget);
-        break;
-#ifndef QT_NO_TOOLBAR
-    case PE_IndicatorToolBarHandle: {
-        QPixmap cache;
-        QRect rect = option->rect;
-        QString pixmapName = QStyleHelper::uniqueName(QLatin1String("toolbarhandle"), option, rect.size());
-        if (!QPixmapCache::find(pixmapName, cache)) {
-            cache = QPixmap(rect.size());
-            cache.fill(Qt::transparent);
-            QPainter cachePainter(&cache);
-            QRect cacheRect(QPoint(0, 0), rect.size());
-            if (widget)
-                cachePainter.fillRect(cacheRect, option->palette.brush(widget->backgroundRole()));
-            else
-                cachePainter.fillRect(cacheRect, option->palette.background());
-
-            QImage handle(qt_toolbarhandle);
-            alphaCornerColor.setAlpha(170);
-            handle.setColor(1, alphaCornerColor.rgba());
-            handle.setColor(2, mergedColors(alphaCornerColor, option->palette.light().color()).rgba());
-            handle.setColor(3, option->palette.light().color().rgba());
-
-            if (option->state & State_Horizontal) {
-                int nchunks = cacheRect.height() / handle.height();
-                int indent = (cacheRect.height() - (nchunks * handle.height())) / 2;
-                for (int i = 0; i < nchunks; ++i)
-                    cachePainter.drawImage(QPoint(cacheRect.left() + 3, cacheRect.top() + indent + i * handle.height()),
-                                           handle);
-            } else {
-                int nchunks = cacheRect.width() / handle.width();
-                int indent = (cacheRect.width() - (nchunks * handle.width())) / 2;
-                for (int i = 0; i < nchunks; ++i)
-                    cachePainter.drawImage(QPoint(cacheRect.left() + indent + i * handle.width(), cacheRect.top() + 3),
-                                           handle);
-            }
-            cachePainter.end();
-            QPixmapCache::insert(pixmapName, cache);
-        }
-        painter->drawPixmap(rect.topLeft(), cache);
-        break;
-    }
-    case PE_IndicatorToolBarSeparator: {
-        QPen oldPen = painter->pen();
-        painter->setPen(alphaCornerColor);
-        if (option->state & State_Horizontal) {
-            painter->drawLine(option->rect.left(), option->rect.top() + 1, option->rect.left(), option->rect.bottom() - 2);
-            painter->setPen(option->palette.base().color());
-            painter->drawLine(option->rect.right(), option->rect.top() + 1, option->rect.right(), option->rect.bottom() - 2);
-        } else {
-            painter->drawLine(option->rect.left() + 1, option->rect.top(), option->rect.right() - 2, option->rect.top());
-            painter->setPen(option->palette.base().color());
-            painter->drawLine(option->rect.left() + 1, option->rect.bottom(), option->rect.right() - 2, option->rect.bottom());
-        }
-        painter->setPen(oldPen);
-        break;
-    }
-#endif // QT_NO_TOOLBAR
-    case PE_PanelButtonCommand:
-        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(option)) {
-            bool sunken = (button->state & State_Sunken) || (button->state & State_On);
-            if ((button->features & QStyleOptionButton::Flat) && !sunken)
-                break;
-
-            bool defaultButton = (button->features & (QStyleOptionButton::DefaultButton
-                                                      | QStyleOptionButton::AutoDefaultButton));
-
-            BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("pushbutton-%1").arg(defaultButton))
-
-            QPen oldPen = p->pen();
-            bool hover = (button->state & State_Enabled) && (button->state & State_MouseOver);
-
-            // Give the painter a different brush origin for sunken buttons
-            if (sunken) {
-                // ### No such function
-                // p->setPenOrigin(rect.left() + 1, rect.top() + 1);
-                p->setBrushOrigin(rect.left() + 1, rect.top() + 1);
-            }
-
-            // Draw border
-            qt_plastique_draw_frame(p, rect, option);
-
-            // Fill the panel
-            QRectF fillRect = rect.adjusted(2, 2, -2, -2);
-
-            // Button colors
-            QBrush alphaCornerBrush = qMapBrushToRect(qBrushDark(option->palette.button(), 165), rect);
-            qBrushSetAlphaF(&alphaCornerBrush, 0.5);
-            QBrush buttonGradientBrush;
-            QBrush leftLineGradientBrush;
-            QBrush rightLineGradientBrush;
-            QBrush sunkenButtonGradientBrush;
-            QBrush sunkenLeftLineGradientBrush;
-            QBrush sunkenRightLineGradientBrush;
-            QBrush buttonBrush = qMapBrushToRect(option->palette.button(), rect);
-            if (buttonBrush.gradient() || !buttonBrush.texture().isNull()) {
-                buttonGradientBrush = buttonBrush;
-                sunkenButtonGradientBrush = qBrushDark(buttonBrush, 108);
-                leftLineGradientBrush = qBrushLight(buttonBrush, 105);
-                rightLineGradientBrush = qBrushDark(buttonBrush, 105);
-                sunkenLeftLineGradientBrush = qBrushDark(buttonBrush, 110);
-                sunkenRightLineGradientBrush = qBrushDark(buttonBrush, 106);
-            } else {
-                // Generate gradients
-                QLinearGradient buttonGradient(rect.topLeft(), rect.bottomLeft());
-                if (hover) {
-                    buttonGradient.setColorAt(0.0, mergedColors(option->palette.highlight().color(),
-                                                                buttonBrush.color().lighter(104), 6));
-                    buttonGradient.setColorAt(1.0, mergedColors(option->palette.highlight().color(),
-                                                                buttonBrush.color().darker(110), 6));
-                } else {
-                    buttonGradient.setColorAt(0.0, buttonBrush.color().lighter(104));
-                    buttonGradient.setColorAt(1.0, buttonBrush.color().darker(110));
-                }
-                buttonGradientBrush = QBrush(buttonGradient);
-
-                QLinearGradient buttonGradient2(rect.topLeft(), rect.bottomLeft());
-                buttonGradient2.setColorAt(0.0, buttonBrush.color().darker(113));
-                buttonGradient2.setColorAt(1.0, buttonBrush.color().darker(103));
-                sunkenButtonGradientBrush = QBrush(buttonGradient2);
-
-                QLinearGradient buttonGradient3(rect.topLeft(), rect.bottomLeft());
-                buttonGradient3.setColorAt(0.0, buttonBrush.color().lighter(105));
-                buttonGradient3.setColorAt(1.0, buttonBrush.color());
-                leftLineGradientBrush = QBrush(buttonGradient3);
-
-                QLinearGradient buttonGradient4(rect.topLeft(), rect.bottomLeft());
-                buttonGradient4.setColorAt(0.0, buttonBrush.color());
-                buttonGradient4.setColorAt(1.0, buttonBrush.color().darker(110));
-                rightLineGradientBrush = QBrush(buttonGradient4);
-
-                QLinearGradient buttonGradient5(rect.topLeft(), rect.bottomLeft());
-                buttonGradient5.setColorAt(0.0, buttonBrush.color().darker(113));
-                buttonGradient5.setColorAt(1.0, buttonBrush.color().darker(107));
-                sunkenLeftLineGradientBrush = QBrush(buttonGradient5);
-
-                QLinearGradient buttonGradient6(rect.topLeft(), rect.bottomLeft());
-                buttonGradient6.setColorAt(0.0, buttonBrush.color().darker(108));
-                buttonGradient6.setColorAt(1.0, buttonBrush.color().darker(103));
-                sunkenRightLineGradientBrush = QBrush(buttonGradient6);
-            }
-
-            // Main fill
-            p->fillRect(fillRect,
-                              qMapBrushToRect(sunken ? sunkenButtonGradientBrush
-                                              : buttonGradientBrush, rect));
-
-            // Top line
-            p->setPen(QPen(qBrushLight(qMapBrushToRect(sunken ? sunkenButtonGradientBrush
-                                            : buttonGradientBrush, rect), 105), 0));
-            p->drawLine(QPointF(rect.left() + 2, rect.top() + 1),
-                              QPointF(rect.right() - 2, rect.top() + 1));
-
-            // Bottom line
-            p->setPen(QPen(qBrushDark(qMapBrushToRect(sunken ? sunkenButtonGradientBrush
-                                            : buttonGradientBrush, rect), 105), 0));
-            p->drawLine(QPointF(rect.left() + 2, rect.bottom() - 1),
-                              QPointF(rect.right() - 2, rect.bottom() - 1));
-
-            // Left line
-            p->setPen(QPen(qMapBrushToRect(sunken ? sunkenLeftLineGradientBrush
-                                                 : leftLineGradientBrush, rect), 1));
-            p->drawLine(QPointF(rect.left() + 1, rect.top() + 2),
-                              QPointF(rect.left() + 1, rect.bottom() - 2));
-
-            // Right line
-            p->setPen(QPen(qMapBrushToRect(sunken ? sunkenRightLineGradientBrush
-                                                 : rightLineGradientBrush, rect), 1));
-            p->drawLine(QPointF(rect.right() - 1, rect.top() + 2),
-                              QPointF(rect.right() - 1, rect.bottom() - 2));
-
-            // Hovering
-            if (hover && !sunken) {
-                QBrush hover = qMapBrushToRect(option->palette.highlight(), rect);
-                QBrush hoverOuter = hover;
-                qBrushSetAlphaF(&hoverOuter, qreal(0.7));
-
-                QLine lines[2];
-
-                p->setPen(QPen(hoverOuter, 0));
-                lines[0] = QLine(rect.left() + 1, rect.top() + 1, rect.right() - 1, rect.top() + 1);
-                lines[1] = QLine(rect.left() + 1, rect.bottom() - 1, rect.right() - 1, rect.bottom() - 1);
-                p->drawLines(lines, 2);
-
-                QBrush hoverInner = hover;
-                qBrushSetAlphaF(&hoverInner, qreal(0.45));
-                p->setPen(QPen(hoverInner, 0));
-                lines[0] = QLine(rect.left() + 1, rect.top() + 2, rect.right() - 1, rect.top() + 2);
-                lines[1] = QLine(rect.left() + 1, rect.bottom() - 2, rect.right() - 1, rect.bottom() - 2);
-                p->drawLines(lines, 2);
-
-                QBrush hoverSide = hover;
-                qBrushSetAlphaF(&hoverSide, qreal(0.075));
-                p->setPen(QPen(hoverSide, 0));
-                lines[0] = QLine(rect.left() + 1, rect.top() + 2, rect.left() + 1, rect.bottom() - 2);
-                lines[1] = QLine(rect.right() - 1, rect.top() + 2, rect.right() - 1, rect.bottom() - 2);
-                p->drawLines(lines, 2);
-            }
-
-            p->setPen(oldPen);
-
-            END_STYLE_PIXMAPCACHE
-        }
-        break;
-    case PE_IndicatorCheckBox:
-        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(option)) {
-            BEGIN_STYLE_PIXMAPCACHE(QLatin1String("checkbox"))
-
-            p->save();
-
-            // Outline
-            QBrush border = option->palette.shadow();
-            qBrushSetAlphaF(&border, qreal(0.4));
-            p->setPen(QPen(border, 0));
-            const QLine lines[4] = {
-                QLine(rect.left() + 1, rect.top(), rect.right() - 1, rect.top()),
-                QLine(rect.left() + 1, rect.bottom(), rect.right() - 1, rect.bottom()),
-                QLine(rect.left(), rect.top() + 1, rect.left(), rect.bottom() - 1),
-                QLine(rect.right(), rect.top() + 1, rect.right(), rect.bottom() - 1) };
-            p->drawLines(lines, 4);
-
-            QBrush corner = option->palette.shadow();
-            qBrushSetAlphaF(&corner, qreal(0.2));
-            p->setPen(QPen(corner, 0));
-            const QPoint points[4] = {
-                rect.topLeft(), rect.topRight(),
-                rect.bottomLeft(), rect.bottomRight() };
-            p->drawPoints(points, 4);
-
-            // Fill
-            QBrush baseBrush = qMapBrushToRect(button->palette.base(), rect);
-            if (!baseBrush.gradient() && baseBrush.texture().isNull()) {
-                QLinearGradient gradient(rect.center().x(), rect.top(), rect.center().x(), rect.bottom());
-                gradient.setColorAt(0, baseBrush.color());
-                gradient.setColorAt(1, baseBrush.color().darker(105));
-                baseBrush = gradient;
-            }
-            p->fillRect(rect.adjusted(1, 1, -1, -1), baseBrush);
-
-            // Hover
-            if ((button->state & State_Enabled) && (button->state & State_MouseOver)) {
-                QBrush pen = qMapBrushToRect(button->palette.highlight(), rect);
-                qBrushSetAlphaF(&pen, qreal(0.8));
-                p->setPen(QPen(pen, 0));
-                p->drawRect(rect.adjusted(1, 1, -2, -2));
-                qBrushSetAlphaF(&pen, 0.5);
-                p->setPen(QPen(pen, 0));
-                p->drawRect(rect.adjusted(2, 2, -3, -3));
-
-                qBrushSetAlphaF(&pen, qreal(0.2));
-                p->setBrush(pen);
-                p->drawRect(rect.adjusted(2, 2, -3, -3));
-            }
-
-            // Indicator
-            bool on = button->state & State_On;
-            bool sunken = button->state & State_Sunken;
-            bool unchanged = button->state & State_NoChange;
-            bool enabled = button->state & State_Enabled;
-            if (on || (enabled && sunken) || unchanged) {
-                p->setRenderHint(QPainter::Antialiasing);
-                QBrush pointBrush = qMapBrushToRect(button->palette.text(), rect);
-                if (sunken)
-                    qBrushSetAlphaF(&pointBrush, qreal(0.5));
-                else if (unchanged)
-                    qBrushSetAlphaF(&pointBrush, qreal(0.3));
-                p->setPen(QPen(pointBrush, 3));
-                const QLine lines[2] = {
-                    QLine(rect.left() + 4, rect.top() + 4, rect.right() - 3, rect.bottom() - 3),
-                    QLine(rect.right() - 3, rect.top() + 4, rect.left() + 4, rect.bottom() - 3) };
-                p->drawLines(lines, 2);
-            }
-
-            p->restore();
-            END_STYLE_PIXMAPCACHE
-        }
-        break;
-    case PE_IndicatorRadioButton:
-        if (const QStyleOptionButton *button = qstyleoption_cast<const QStyleOptionButton *>(option)) {
-            BEGIN_STYLE_PIXMAPCACHE(QLatin1String("radiobutton"))
-
-            p->save();
-            p->setRenderHint(QPainter::Antialiasing);
-
-            // The the filled ellipse
-            QBrush border = qMapBrushToRect(option->palette.shadow(), rect);
-            qBrushSetAlphaF(&border, qreal(0.51));
-            p->setPen(QPen(border, 0));
-
-            QBrush baseBrush = qMapBrushToRect(button->palette.base(), rect);
-            if (!baseBrush.gradient() && baseBrush.texture().isNull()) {
-                QLinearGradient gradient(rect.center().x(), rect.top(), rect.center().x(), rect.bottom());
-                gradient.setColorAt(0, baseBrush.color());
-                gradient.setColorAt(1, baseBrush.color().darker(105));
-                baseBrush = gradient;
-            }
-            p->setBrush(baseBrush);
-            p->drawEllipse(QRectF(rect).adjusted(1, 1, -1, -1));
-
-            // Hover
-            if ((button->state & State_Enabled) && (button->state & State_MouseOver)) {
-                QBrush pen = qMapBrushToRect(button->palette.highlight(), rect);
-                qBrushSetAlphaF(&pen, qreal(0.8));
-                p->setPen(QPen(pen, 0));
-                qBrushSetAlphaF(&pen, qreal(0.2));
-                p->setBrush(pen);
-                p->drawEllipse(QRectF(rect).adjusted(2, 2, -2, -2));
-            }
-
-            // Indicator
-            bool on = button->state & State_On;
-            bool sunken = button->state & State_Sunken;
-            bool enabled = button->state & State_Enabled;
-            if (on || (enabled && sunken)) {
-                p->setPen(Qt::NoPen);
-                QBrush pointBrush = qMapBrushToRect(button->palette.text(), rect);
-                if (sunken)
-                    qBrushSetAlphaF(&pointBrush, 0.5);
-                p->setBrush(pointBrush);
-                p->drawEllipse(QRectF(rect).adjusted(3, 3, -3, -3));
-            }
-
-            p->restore();
-            END_STYLE_PIXMAPCACHE
-        }
-        break;
-#ifndef QT_NO_DOCKWIDGET
-    case PE_IndicatorDockWidgetResizeHandle:
-        if ((option->state & State_Enabled) && (option->state & State_MouseOver))
-            painter->fillRect(option->rect, QColor(255, 255, 255, 128));
-        if (option->state & State_Horizontal) {
-            int width = option->rect.width() / 3;
-            QRect rect(option->rect.center().x() - width / 2,
-                       option->rect.top() + (option->rect.height() / 2) - 1, width, 3);
-            qt_plastique_draw_handle(painter, option, rect, Qt::Vertical, widget);
-        } else {
-            int height = option->rect.height() / 3;
-            QRect rect(option->rect.left() + (option->rect.width() / 2 - 1),
-                       option->rect.center().y() - height / 2, 3, height);
-            qt_plastique_draw_handle(painter, option, rect, Qt::Horizontal, widget);
-        }
-        break;
-#endif // QT_NO_DOCKWIDGET
-    case PE_IndicatorViewItemCheck: {
-        QStyleOptionButton button;
-        button.QStyleOption::operator=(*option);
-        button.state &= ~State_MouseOver;
-        proxy()->drawPrimitive(PE_IndicatorCheckBox, &button, painter, widget);
-        break;
-    }
-    case PE_FrameWindow: {
-        painter->save();
-        bool active = (option->state & State_Active);
-        int titleBarStop = option->rect.top() + proxy()->pixelMetric(PM_TitleBarHeight, option, widget);
-
-        QPalette palette = option->palette;
-        if (!active)
-            palette.setCurrentColorGroup(QPalette::Disabled);
-
-        // Frame and rounded corners
-        painter->setPen(mergedColors(palette.highlight().color(), Qt::black, 50));
-
-        QLine lines[3];
-        QPoint points[4];
-
-        // bottom border line
-        lines[0] = QLine(option->rect.left() + 1, option->rect.bottom(), option->rect.right() - 1, option->rect.bottom());
-
-        // bottom left and right side border lines
-        lines[1] = QLine(option->rect.left(), titleBarStop, option->rect.left(), option->rect.bottom() - 1);
-        lines[2] = QLine(option->rect.right(), titleBarStop, option->rect.right(), option->rect.bottom() - 1);
-        painter->drawLines(lines, 3);
-        points[0] = QPoint(option->rect.left() + 1, option->rect.bottom() - 1);
-        points[1] = QPoint(option->rect.right() - 1, option->rect.bottom() - 1);
-        painter->drawPoints(points, 2);
-
-
-        // alpha corners
-        painter->setPen(mergedColors(palette.highlight().color(), palette.background().color(), 55));
-        points[0] = QPoint(option->rect.left() + 2, option->rect.bottom() - 1);
-        points[1] = QPoint(option->rect.left() + 1, option->rect.bottom() - 2);
-        points[2] = QPoint(option->rect.right() - 2, option->rect.bottom() - 1);
-        points[3] = QPoint(option->rect.right() - 1, option->rect.bottom() - 2);
-        painter->drawPoints(points, 4);
-
-
-        // upper and lower left inner
-        painter->setPen(active ? mergedColors(palette.highlight().color(), palette.background().color()) : palette.background().color().darker(120));
-        painter->drawLine(option->rect.left() + 1, titleBarStop, option->rect.left() + 1, option->rect.bottom() - 2);
-
-
-        painter->setPen(active ? mergedColors(palette.highlight().color(), palette.background().color(), 57) : palette.background().color().darker(130));
-        lines[0] = QLine(option->rect.right() - 1, titleBarStop, option->rect.right() - 1, option->rect.bottom() - 2);
-        lines[1] = QLine(option->rect.left() + 1, option->rect.bottom() - 1, option->rect.right() - 1, option->rect.bottom() - 1);
-        painter->drawLines(lines, 2);
-
-        painter->restore();
-    }
-        break;
-    case PE_IndicatorBranch: {
-        int mid_h = option->rect.x() + option->rect.width() / 2;
-        int mid_v = option->rect.y() + option->rect.height() / 2;
-        int bef_h = mid_h;
-        int bef_v = mid_v;
-        int aft_h = mid_h;
-        int aft_v = mid_v;
-        QBrush brush(option->palette.dark().color(), Qt::Dense4Pattern);
-        if (option->state & State_Item) {
-            if (option->direction == Qt::RightToLeft)
-                painter->fillRect(option->rect.left(), mid_v, bef_h - option->rect.left(), 1, brush);
-            else
-                painter->fillRect(aft_h, mid_v, option->rect.right() - aft_h + 1, 1, brush);
-        }
-        if (option->state & State_Sibling)
-            painter->fillRect(mid_h, aft_v, 1, option->rect.bottom() - aft_v + 1, brush);
-        if (option->state & (State_Open | State_Children | State_Item | State_Sibling))
-            painter->fillRect(mid_h, option->rect.y(), 1, bef_v - option->rect.y(), brush);
-
-        if (option->state & State_Children) {
-            painter->save();
-            QPoint center = option->rect.center();
-            // border
-            QRect fullRect(center.x() - 4, center.y() - 4, 9, 9);
-            painter->setPen(borderColor);
-
-            const QLine lines[4] = {
-                QLine(fullRect.left() + 1, fullRect.top(),
-                      fullRect.right() - 1, fullRect.top()),
-                QLine(fullRect.left() + 1, fullRect.bottom(),
-                      fullRect.right() - 1, fullRect.bottom()),
-                QLine(fullRect.left(), fullRect.top() + 1,
-                      fullRect.left(), fullRect.bottom() - 1),
-                QLine(fullRect.right(), fullRect.top() + 1,
-                      fullRect.right(), fullRect.bottom() - 1) };
-            painter->drawLines(lines, 4);
-
-            // "antialiased" corners
-            painter->setPen(alphaCornerColor);
-            const QPoint points[4] = {
-                fullRect.topLeft(),
-                fullRect.topRight(),
-                fullRect.bottomLeft(),
-                fullRect.bottomRight() };
-            painter->drawPoints(points, 4);
-
-            // fill
-            QRect adjustedRect = fullRect;
-            QRect gradientRect(adjustedRect.left() + 1, adjustedRect.top() + 1,
-                               adjustedRect.right() - adjustedRect.left() - 1,
-                               adjustedRect.bottom() - adjustedRect.top() - 1);
-            if (option->palette.base().style() == Qt::SolidPattern) {
-                QColor baseGradientStartColor = option->palette.base().color().darker(101);
-                QColor baseGradientStopColor = option->palette.base().color().darker(106);
-                qt_plastique_draw_gradient(painter, gradientRect, baseGradientStartColor, baseGradientStopColor);
-            } else {
-                painter->fillRect(gradientRect, option->palette.base());
-            }
-            // draw "+" or "-"
-            painter->setPen(alphaTextColor);
-            painter->drawLine(center.x() - 2, center.y(), center.x() + 2, center.y());
-            if (!(option->state & State_Open))
-                painter->drawLine(center.x(), center.y() - 2, center.x(), center.y() + 2);
-            painter->restore();
-        }
-    }
-        break;
-    default:
-        QWindowsStyle::drawPrimitive(element, option, painter, widget);
-        break;
-    }
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::drawControl(ControlElement element, const QStyleOption *option,
-                                  QPainter *painter, const QWidget *widget) const
-{
-    QColor borderColor = option->palette.background().color().darker(178);
-    QColor alphaCornerColor;
-    if (widget) {
-        // ### backgroundrole/foregroundrole should be part of the style option
-        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), borderColor);
-    } else {
-        alphaCornerColor = mergedColors(option->palette.background().color(), borderColor);
-    }
-
-    QColor gradientStartColor = option->palette.button().color().lighter(104);
-    QColor gradientStopColor = option->palette.button().color().darker(105);
-
-    QColor highlightedGradientStartColor = option->palette.button().color().lighter(101);
-    QColor highlightedGradientStopColor = mergedColors(option->palette.button().color(), option->palette.highlight().color(), 85);
-
-    QColor lightShadowGradientStartColor = highlightedGradientStartColor.lighter(105);
-    QColor lightShadowGradientStopColor = highlightedGradientStopColor.lighter(105);
-
-    QColor highlightedDarkInnerBorderColor = mergedColors(option->palette.button().color(), option->palette.highlight().color(), 35);
-    QColor highlightedLightInnerBorderColor = mergedColors(option->palette.button().color(), option->palette.highlight().color(), 58);
-
-    QColor alphaInnerColor = mergedColors(highlightedDarkInnerBorderColor, option->palette.base().color());
-
-    switch (element) {
-#ifndef QT_NO_TABBAR
-    case CE_TabBarTabShape:
-        if (const QStyleOptionTab *tab = qstyleoption_cast<const QStyleOptionTab *>(option)) {
-
-            if (tab->shape != QTabBar::RoundedNorth && tab->shape != QTabBar::RoundedWest &&
-                tab->shape != QTabBar::RoundedSouth && tab->shape != QTabBar::RoundedEast) {
-                QWindowsStyle::drawControl(element, option, painter, widget);
-                break;
-            }
-
-            painter->save();
-
-            // Set up some convenience variables
-            bool disabled = !(tab->state & State_Enabled);
-            bool onlyTab = tab->position == QStyleOptionTab::OnlyOneTab;
-            bool selected = tab->state & State_Selected;
-            bool mouseOver = (tab->state & State_MouseOver) && !selected && !disabled;
-            bool previousSelected = tab->selectedPosition == QStyleOptionTab::PreviousIsSelected;
-            bool nextSelected = tab->selectedPosition == QStyleOptionTab::NextIsSelected;
-            bool leftCornerWidget = (tab->cornerWidgets & QStyleOptionTab::LeftCornerWidget);
-            bool reverse = (tab->direction == Qt::RightToLeft);
-
-            int lowerTop = selected ? 0 : 3; // to make the selected tab bigger than the rest
-            bool atEnd = (tab->position == QStyleOptionTab::End) || onlyTab;
-            bool atBeginning = ((tab->position == QStyleOptionTab::Beginning) || onlyTab)
-                               && !leftCornerWidget;
-            bool reverseShadow = false;
-
-            int borderThickness = proxy()->pixelMetric(PM_TabBarBaseOverlap, tab, widget);
-            int marginLeft = 0;
-            if ((atBeginning && !selected) || (selected && leftCornerWidget && ((tab->position == QStyleOptionTab::Beginning) || onlyTab))) {
-                marginLeft = 1;
-            }
-
-            // I've set the names based on the natural coordinate system. Vectors are used to rotate everything
-            // if the orientation of the tab bare is different than north.
-            {
-                // Coordinates of corners of rectangle for transformation
-                QPoint topLeft;
-                QPoint topRight;
-                QPoint bottomLeft;
-                QPoint bottomRight;
-
-                // Fill with normalized vectors in the direction of the coordinate system
-                // (down and right should be complement of up and left, or it will look odd)
-                QPoint vectorUp;
-                QPoint vectorDown;
-                QPoint vectorLeft;
-                QPoint vectorRight;
-
-                QBrush border = option->palette.shadow();
-                qBrushSetAlphaF(&border, qreal(0.4));
-                QBrush innerTopLeft = option->palette.shadow();
-                qBrushSetAlphaF(&innerTopLeft, qreal(0.075));
-                QBrush innerBottomRight = option->palette.shadow();
-                qBrushSetAlphaF(&innerBottomRight, qreal(0.23));
-                QBrush corner = option->palette.shadow();
-                qBrushSetAlphaF(&corner, qreal(0.25));
-
-                QBrush baseColor1;
-                QBrush baseColor2;
-
-                switch (tab->shape) {
-                case QTabBar::RoundedNorth:
-                    vectorUp = QPoint(0, -1);
-                    vectorDown = QPoint(0, 1);
-
-                    if (reverse) {
-                        vectorLeft = QPoint(1, 0);
-                        vectorRight = QPoint(-1, 0);
-                        reverseShadow = true;
-                    } else {
-                        vectorLeft = QPoint(-1, 0);
-                        vectorRight = QPoint(1, 0);
-                    }
-
-                    if (reverse) {
-                        topLeft = tab->rect.topRight();
-                        topRight = tab->rect.topLeft();
-                        bottomLeft = tab->rect.bottomRight();
-                        bottomRight = tab->rect.bottomLeft();
-                    } else {
-                        topLeft = tab->rect.topLeft();
-                        topRight = tab->rect.topRight();
-                        bottomLeft = tab->rect.bottomLeft();
-                        bottomRight = tab->rect.bottomRight();
-                    }
-
-
-                    baseColor1 = border;
-                    baseColor2 = innerTopLeft;
-                    break ;
-                case QTabBar::RoundedWest:
-                    vectorUp = QPoint(-1, 0);
-                    vectorDown = QPoint(1, 0);
-                    vectorLeft = QPoint(0, -1);
-                    vectorRight = QPoint(0, 1);
-
-                    topLeft = tab->rect.topLeft();
-                    topRight = tab->rect.bottomLeft();
-                    bottomLeft = tab->rect.topRight();
-                    bottomRight = tab->rect.bottomRight();
-
-                    baseColor1 = border;
-                    baseColor2 = innerTopLeft;
-                    break ;
-                case QTabBar::RoundedEast:
-                    vectorUp = QPoint(1, 0);
-                    vectorDown = QPoint(-1, 0);
-                    vectorLeft = QPoint(0, -1);
-                    vectorRight = QPoint(0, 1);
-
-                    topLeft = tab->rect.topRight();
-                    topRight = tab->rect.bottomRight();
-                    bottomLeft = tab->rect.topLeft();
-                    bottomRight = tab->rect.bottomLeft();
-
-                    baseColor1 = border;
-                    baseColor2 = innerBottomRight;
-                    break ;
-                case QTabBar::RoundedSouth:
-                    vectorUp = QPoint(0, 1);
-                    vectorDown = QPoint(0, -1);
-
-                    if (reverse) {
-                        vectorLeft = QPoint(1, 0);
-                        vectorRight = QPoint(-1, 0);
-                        reverseShadow = true;
-
-                        topLeft = tab->rect.bottomRight();
-                        topRight = tab->rect.bottomLeft();
-                        bottomLeft = tab->rect.topRight();
-                        bottomRight = tab->rect.topLeft();
-                    } else {
-                        vectorLeft = QPoint(-1, 0);
-                        vectorRight = QPoint(1, 0);
-
-                        topLeft = tab->rect.bottomLeft();
-                        topRight = tab->rect.bottomRight();
-                        bottomLeft = tab->rect.topLeft();
-                        bottomRight = tab->rect.topRight();
-                    }
-
-                    baseColor1 = border;
-                    baseColor2 = innerBottomRight;
-                    break ;
-                default:
-                    break;
-                }
-
-                // Make the tab smaller when it's at the end, so that we are able to draw the corner
-                if (atEnd) {
-                    topRight += vectorLeft;
-                    bottomRight += vectorLeft;
-                }
-
-                {
-                    // Outer border
-                    QLine topLine;
-                    {
-                        QPoint adjustTopLineLeft = (vectorRight * (marginLeft + (previousSelected ? 0 : 1))) +
-                                                   (vectorDown * lowerTop);
-                        QPoint adjustTopLineRight = (vectorDown * lowerTop);
-                        if (atBeginning || selected)
-                            adjustTopLineLeft += vectorRight;
-                        if (atEnd || selected)
-                            adjustTopLineRight += 2 * vectorLeft;
-
-                        topLine = QLine(topLeft + adjustTopLineLeft, topRight + adjustTopLineRight);
-                    }
-
-                    QLine leftLine;
-                    {
-                        QPoint adjustLeftLineTop = (vectorRight * marginLeft) + (vectorDown * (lowerTop + 1));
-                        QPoint adjustLeftLineBottom = (vectorRight * marginLeft) + (vectorUp * borderThickness);
-                        if (atBeginning || selected)
-                            adjustLeftLineTop += vectorDown; // Make place for rounded corner
-                        if (atBeginning && selected)
-                            adjustLeftLineBottom += borderThickness * vectorDown;
-                        else if (selected)
-                            adjustLeftLineBottom += vectorUp;
-
-                        leftLine = QLine(topLeft + adjustLeftLineTop, bottomLeft + adjustLeftLineBottom);
-                    }
-
-                    QLine rightLine;
-                    {
-                        QPoint adjustRightLineTop = vectorDown * (2 + lowerTop);
-                        QPoint adjustRightLineBottom = vectorUp * borderThickness;
-                        if (selected)
-                            adjustRightLineBottom += vectorUp;
-
-                        rightLine = QLine(topRight + adjustRightLineTop, bottomRight + adjustRightLineBottom);
-                    }
-
-                    // Background
-                    QPoint startPoint = topLine.p1() + vectorDown + vectorLeft;
-                    if (mouseOver)
-                        startPoint += vectorDown;
-                    QPoint endPoint = rightLine.p2();
-
-                    if (tab->state & State_Enabled) {
-                        QRect fillRect = QRect(startPoint, endPoint).normalized();
-                        if (fillRect.isValid()) {
-                            if (selected) {
-                                fillRect = QRect(startPoint, endPoint + vectorLeft + vectorDown * 3).normalized();
-                                painter->fillRect(fillRect, option->palette.window());
-
-                                // Connect to the base
-                                painter->setPen(QPen(option->palette.window(), 0));
-                                QVarLengthArray<QPoint, 6> points;
-                                points.append(rightLine.p2() + vectorDown);
-                                points.append(rightLine.p2() + vectorDown + vectorDown);
-                                points.append(rightLine.p2() + vectorDown + vectorDown + vectorRight);
-                                if (tab->position != QStyleOptionTab::Beginning) {
-                                    points.append(leftLine.p2() + vectorDown);
-                                    points.append(leftLine.p2() + vectorDown + vectorDown);
-                                    points.append(leftLine.p2() + vectorDown + vectorDown + vectorLeft);
-                                }
-                                painter->drawPoints(points.constData(), points.size());
-                            } else {
-                                QBrush buttonGradientBrush;
-                                QBrush buttonBrush = qMapBrushToRect(option->palette.button(), fillRect);
-                                if (buttonBrush.gradient() || !buttonBrush.texture().isNull()) {
-                                    buttonGradientBrush = buttonBrush;
-                                } else {
-                                    // Generate gradients
-                                    QLinearGradient buttonGradient(fillRect.topLeft(), fillRect.bottomLeft());
-                                    buttonGradient.setColorAt(0.0, buttonBrush.color().lighter(104));
-                                    buttonGradient.setColorAt(1.0, buttonBrush.color().darker(110));
-                                    buttonGradientBrush = QBrush(buttonGradient);
-                                }
-
-                                painter->fillRect(fillRect, buttonGradientBrush);
-                            }
-                        }
-                    }
-
-                    QPoint rightCornerDot = topRight + vectorLeft + (lowerTop + 1)*vectorDown;
-                    QPoint leftCornerDot = topLeft + (marginLeft + 1)*vectorRight + (lowerTop + 1)*vectorDown;
-                    QPoint bottomRightConnectToBase = rightLine.p2() + vectorRight + vectorDown;
-                    QPoint bottomLeftConnectToBase = leftLine.p2() + vectorLeft + vectorDown;
-
-                    painter->setPen(QPen(border, 0));
-
-                    QVarLengthArray<QLine, 3> lines;
-                    QVarLengthArray<QPoint, 7> points;
-
-                    lines.append(topLine);
-
-                    if (mouseOver) {
-                        painter->drawLines(lines.constData(), lines.count());
-                        lines.clear();
-
-                        QLine secondHoverLine = QLine(topLine.p1() + vectorDown * 2 + vectorLeft, topLine.p2() + vectorDown * 2 + vectorRight);
-                        painter->setPen(highlightedLightInnerBorderColor);
-                        painter->drawLine(secondHoverLine);
-                    }
-
-                    if (mouseOver)
-                        painter->setPen(QPen(border, 0));
-
-                    if (!previousSelected)
-                        lines.append(leftLine);
-                    if (atEnd || selected) {
-                        lines.append(rightLine);
-                        points.append(rightCornerDot);
-                    }
-                    if (atBeginning || selected)
-                        points.append(leftCornerDot);
-                    if (selected) {
-                        points.append(bottomRightConnectToBase);
-                        points.append(bottomLeftConnectToBase);
-                    }
-                    if (lines.size() > 0) {
-                        painter->drawLines(lines.constData(), lines.size());
-                        lines.clear();
-                    }
-                    if (points.size() > 0) {
-                        painter->drawPoints(points.constData(), points.size());
-                        points.clear();
-                    }
-
-                    // Antialiasing
-                    painter->setPen(QPen(corner, 0));
-                    if (atBeginning || selected)
-                        points.append(topLine.p1() + vectorLeft);
-                    if (!previousSelected)
-                        points.append(leftLine.p1() + vectorUp);
-                    if (atEnd || selected) {
-                        points.append(topLine.p2() + vectorRight);
-                        points.append(rightLine.p1() + vectorUp);
-                    }
-
-                    if (selected) {
-                        points.append(bottomRightConnectToBase + vectorLeft);
-                        if (!atBeginning) {
-                            points.append(bottomLeftConnectToBase + vectorRight);
-
-                            if (((tab->position == QStyleOptionTab::Beginning) || onlyTab) && leftCornerWidget) {
-                                // A special case: When the first tab is selected and
-                                // has a left corner widget, it needs to do more work
-                                // to connect to the base
-                                QPoint p1 = bottomLeftConnectToBase + vectorDown;
-
-                                points.append(p1);
-                            }
-                        }
-                    }
-                    if (points.size() > 0) {
-                        painter->drawPoints(points.constData(), points.size());
-                        points.clear();
-                    }
-
-                    // Inner border
-                    QLine innerTopLine = QLine(topLine.p1() + vectorDown, topLine.p2() + vectorDown);
-                    if (!selected) {
-                        QLinearGradient topLineGradient(innerTopLine.p1(),innerTopLine.p2());
-                        topLineGradient.setColorAt(0, lightShadowGradientStartColor);
-                        topLineGradient.setColorAt(1, lightShadowGradientStopColor);
-                        painter->setPen(QPen(mouseOver ? QBrush(highlightedDarkInnerBorderColor) : QBrush(topLineGradient), 1));
-                    } else {
-                        painter->setPen(QPen(innerTopLeft, 0));
-                    }
-                    painter->drawLine(innerTopLine);
-
-                    QLine innerLeftLine = QLine(leftLine.p1() + vectorRight + vectorDown, leftLine.p2() + vectorRight);
-                    QLine innerRightLine = QLine(rightLine.p1() + vectorLeft + vectorDown, rightLine.p2() + vectorLeft);
-
-                    if (selected) {
-                        innerRightLine = QLine(innerRightLine.p1() + vectorUp, innerRightLine.p2());
-                        innerLeftLine = QLine(innerLeftLine.p1() + vectorUp, innerLeftLine.p2());
-                    }
-
-                    if (selected || atBeginning) {
-                        QBrush leftLineGradientBrush;
-                        QRect rect = QRect(innerLeftLine.p1(), innerLeftLine.p2()).normalized();
-                        QBrush buttonBrush = qMapBrushToRect(option->palette.button(), rect);
-                        if (buttonBrush.gradient() || !buttonBrush.texture().isNull()) {
-                            leftLineGradientBrush = qBrushLight(buttonBrush, 105);
-                        } else {
-                            QLinearGradient buttonGradient3(rect.topLeft(), rect.bottomLeft());
-                            buttonGradient3.setColorAt(0.0, buttonBrush.color().lighter(105));
-                            buttonGradient3.setColorAt(1.0, buttonBrush.color());
-                            leftLineGradientBrush = QBrush(buttonGradient3);
-                        }
-
-                        if (!selected)
-                            painter->setPen(QPen(leftLineGradientBrush, 0));
-
-                        // Assume the sun is on the same side in Right-To-Left layouts and draw the
-                        // light shadow on the left side always (the right line is on the left side in
-                        // reverse layouts for north and south)
-                        if (reverseShadow)
-                            painter->drawLine(innerRightLine);
-                        else
-                            painter->drawLine(innerLeftLine);
-                    }
-
-                    if (atEnd || selected) {
-                        if (!selected) {
-                            QBrush rightLineGradientBrush;
-                            QRect rect = QRect(innerRightLine.p1(), innerRightLine.p2()).normalized();
-                            QBrush buttonBrush = qMapBrushToRect(option->palette.button(), rect);
-                            if (buttonBrush.gradient() || !buttonBrush.texture().isNull()) {
-                                rightLineGradientBrush = qBrushDark(buttonBrush, 105);
-                            } else {
-                                QLinearGradient buttonGradient4(rect.topLeft(), rect.bottomLeft());
-                                buttonGradient4.setColorAt(0.0, buttonBrush.color());
-                                buttonGradient4.setColorAt(1.0, buttonBrush.color().darker(110));
-                                rightLineGradientBrush = QBrush(buttonGradient4);
-                            }
-
-                            painter->setPen(QPen(rightLineGradientBrush, 0));
-                        } else {
-                            painter->setPen(QPen(innerBottomRight, 0));
-                        }
-
-                        if (reverseShadow)
-                            painter->drawLine(innerLeftLine);
-                        else
-                            painter->drawLine(innerRightLine);
-                    }
-
-
-                    // Base
-                    QLine baseLine = QLine(bottomLeft + marginLeft * 2 * vectorRight, bottomRight);
-                    {
-
-                        QPoint adjustedLeft;
-                        QPoint adjustedRight;
-
-                        if (atEnd && !selected) {
-                            baseLine = QLine(baseLine.p1(), baseLine.p2() + vectorRight);
-                        }
-
-                        if (nextSelected) {
-                            adjustedRight += vectorLeft;
-                            baseLine = QLine(baseLine.p1(), baseLine.p2() + vectorLeft);
-                        }
-                        if (previousSelected) {
-                            adjustedLeft += vectorRight;
-                            baseLine = QLine(baseLine.p1() + vectorRight, baseLine.p2());
-                        }
-                        if (atBeginning)
-                            adjustedLeft += vectorRight;
-
-                        painter->setPen(QPen(baseColor2, 0));
-                        if (!selected)
-                            painter->drawLine(baseLine);
-
-                        if (atEnd && !selected)
-                            painter->drawPoint(baseLine.p2() + vectorRight);
-
-                        if (atBeginning && !selected)
-                            adjustedLeft = vectorRight;
-                        else
-                            adjustedLeft = QPoint(0, 0);
-                        painter->setPen(QPen(baseColor1, 0));
-                        if (!selected)
-                            painter->drawLine(bottomLeft + vectorUp + adjustedLeft, baseLine.p2() + vectorUp);
-
-                        QPoint endPoint = bottomRight + vectorUp;
-                        if (atEnd && !selected)
-                            painter->drawPoint(endPoint);
-
-                        // For drawing a lower left "fake" corner on the base when the first tab is unselected
-                        if (atBeginning && !selected) {
-                            painter->drawPoint(baseLine.p1() + vectorLeft);
-                        }
-
-                        painter->setPen(QPen(corner, 0));
-                        if (nextSelected)
-                            painter->drawPoint(endPoint);
-                        else if (selected)
-                            painter->drawPoint(endPoint + vectorRight);
-
-                        // For drawing a lower left "fake" corner on the base when the first tab is unselected
-                        if (atBeginning && !selected) {
-                            painter->drawPoint(baseLine.p1() + 2 * vectorLeft);
-                        }
-                    }
-                }
-            }
-
-            // Yay we're done
-
-            painter->restore();
-        }
-        break;
-#endif // QT_NO_TABBAR
-
-    case CE_ProgressBarGroove:
-        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
-            QRect rect = bar->rect;
-            QPen oldPen = painter->pen();
-
-            QLine lines[4];
-
-            // outline
-            painter->setPen(borderColor);
-            lines[0] = QLine(rect.left() + 2, rect.top(), rect.right() - 2, rect.top());
-            lines[1] = QLine(rect.left() + 2, rect.bottom(), rect.right() - 2, rect.bottom());
-            lines[2] = QLine(rect.left(), rect.top() + 2, rect.left(), rect.bottom() - 2);
-            lines[3] = QLine(rect.right(), rect.top() + 2, rect.right(), rect.bottom() - 2);
-            painter->drawLines(lines, 4);
-
-            QPoint points[8];
-            points[0] = QPoint(rect.left() + 1, rect.top() + 1);
-            points[1] = QPoint(rect.right() - 1, rect.top() + 1);
-            points[2] = QPoint(rect.left() + 1, rect.bottom() - 1);
-            points[3] = QPoint(rect.right() - 1, rect.bottom() - 1);
-            painter->drawPoints(points, 4);
-
-            // alpha corners
-            painter->setPen(alphaCornerColor);
-            points[0] = QPoint(rect.left(), rect.top() + 1);
-            points[1] = QPoint(rect.left() + 1, rect.top());
-            points[2] = QPoint(rect.right(), rect.top() + 1);
-            points[3] = QPoint(rect.right() - 1, rect.top());
-            points[4] = QPoint(rect.left(), rect.bottom() - 1);
-            points[5] = QPoint(rect.left() + 1, rect.bottom());
-            points[6] = QPoint(rect.right(), rect.bottom() - 1);
-            points[7] = QPoint(rect.right() - 1, rect.bottom());
-            painter->drawPoints(points, 8);
-
-            // inner outline, north-west
-            painter->setPen(gradientStartColor.darker(105));
-            lines[0] = QLine(rect.left() + 2, rect.top() + 1, rect.right() - 2, rect.top() + 1);
-            lines[1] = QLine(rect.left() + 1, rect.top() + 2, rect.left() + 1, rect.bottom() - 2);
-            painter->drawLines(lines, 2);
-
-            // base of the groove
-            painter->setPen(QPen());
-            painter->fillRect(rect.adjusted(2, 2, -2, -1), QBrush(bar->palette.base().color()));
-            painter->setPen(bar->palette.base().color());
-            painter->drawLine(rect.right() - 1, rect.top() + 2, rect.right() - 1, rect.bottom() - 2);
-
-            painter->setPen(oldPen);
-        }
-        break;
-    case CE_ProgressBarLabel:
-        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
-            // The busy indicator doesn't draw a label
-            if (bar->minimum == 0 && bar->maximum == 0)
-                return;
-
-            painter->save();
-
-            QRect rect = bar->rect;
-            QRect leftRect;
-
-            QFont font;
-            font.setBold(true);
-            painter->setFont(font);
-            painter->setPen(bar->palette.text().color());
-
-            bool vertical = false;
-            bool inverted = false;
-            bool bottomToTop = false;
-            // Get extra style options if version 2
-            if (const QStyleOptionProgressBarV2 *bar2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option)) {
-                vertical = (bar2->orientation == Qt::Vertical);
-                inverted = bar2->invertedAppearance;
-                bottomToTop = bar2->bottomToTop;
-            }
-
-            if (vertical) {
-                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
-                QTransform m;
-                if (bottomToTop) {
-                    m.translate(0.0, rect.width());
-                    m.rotate(-90);
-                } else {
-                    m.translate(rect.height(), 0.0);
-                    m.rotate(90);
-                }
-                painter->setTransform(m, true);
-            }
-
-            int progressIndicatorPos = (bar->progress - qreal(bar->minimum)) / qMax(qreal(1.0), qreal(bar->maximum) - bar->minimum) * rect.width();
-
-            bool flip = (!vertical && (((bar->direction == Qt::RightToLeft) && !inverted)
-                                       || ((bar->direction == Qt::LeftToRight) && inverted))) || (vertical && ((!inverted && !bottomToTop) || (inverted && bottomToTop)));
-            if (flip) {
-                int indicatorPos = rect.width() - progressIndicatorPos;
-                if (indicatorPos >= 0 && indicatorPos <= rect.width()) {
-                    painter->setPen(bar->palette.base().color());
-                    leftRect = QRect(rect.left(), rect.top(), indicatorPos, rect.height());
-                } else if (indicatorPos > rect.width()) {
-                    painter->setPen(bar->palette.text().color());
-                } else {
-                    painter->setPen(bar->palette.base().color());
-                }
-            } else {
-                if (progressIndicatorPos >= 0 && progressIndicatorPos <= rect.width()) {
-                    leftRect = QRect(rect.left(), rect.top(), progressIndicatorPos, rect.height());
-                } else if (progressIndicatorPos > rect.width()) {
-                    painter->setPen(bar->palette.base().color());
-                } else {
-                    painter->setPen(bar->palette.text().color());
-                }
-            }
-
-            QRegion rightRect = rect;
-            rightRect = rightRect.subtracted(leftRect);
-            painter->setClipRegion(rightRect);
-            painter->drawText(rect, bar->text, QTextOption(Qt::AlignAbsolute | Qt::AlignHCenter | Qt::AlignVCenter));
-            if (!leftRect.isNull()) {
-                painter->setPen(flip ? bar->palette.text().color() : bar->palette.base().color());
-                painter->setClipRect(leftRect);
-                painter->drawText(rect, bar->text, QTextOption(Qt::AlignAbsolute | Qt::AlignHCenter | Qt::AlignVCenter));
-            }
-
-            painter->restore();
-        }
-        break;
-    case CE_ProgressBarContents:
-        if (const QStyleOptionProgressBar *bar = qstyleoption_cast<const QStyleOptionProgressBar *>(option)) {
-            Q_D(const QPlastiqueStyle);
-            QRect rect = bar->rect;
-            bool vertical = false;
-            bool inverted = false;
-            bool indeterminate = (bar->minimum == 0 && bar->maximum == 0);
-            if (!indeterminate && bar->progress == -1)
-                break;
-
-            painter->save();
-
-            // Get extra style options if version 2
-            if (const QStyleOptionProgressBarV2 *bar2 = qstyleoption_cast<const QStyleOptionProgressBarV2 *>(option)) {
-                vertical = (bar2->orientation == Qt::Vertical);
-                inverted = bar2->invertedAppearance;
-            }
-
-            // If the orientation is vertical, we use a transform to rotate
-            // the progress bar 90 degrees clockwise.  This way we can use the
-            // same rendering code for both orientations.
-            if (vertical) {
-                rect = QRect(rect.left(), rect.top(), rect.height(), rect.width()); // flip width and height
-                QTransform m = QTransform::fromTranslate(rect.height()-1, 0);
-                m.rotate(90.0);
-                painter->setTransform(m, true);
-            }
-
-            int maxWidth = rect.width() - 4;
-            int minWidth = 4;
-            qint64 progress = qMax<qint64>(bar->progress, bar->minimum); // workaround for bug in QProgressBar
-            double vc6_workaround = ((progress - qint64(bar->minimum)) / qMax(double(1.0), double(qint64(bar->maximum) - qint64(bar->minimum))) * maxWidth);
-            int width = indeterminate ? maxWidth : qMax(int(vc6_workaround), minWidth);
-            bool reverse = (!vertical && (bar->direction == Qt::RightToLeft)) || vertical;
-            if (inverted)
-                reverse = !reverse;
-
-            QRect progressBar;
-            if (!indeterminate) {
-                if (!reverse) {
-                    progressBar.setRect(rect.left() + 2, rect.top() + 2, width, rect.height() - 4);
-                } else {
-                    progressBar.setRect(rect.right() - 1 - width, rect.top() + 2, width, rect.height() - 4);
-                }
-                d->stopAnimation(option->styleObject);
-            } else {
-                int slideWidth = ((rect.width() - 4) * 2) / 3;
-                int step = 0;
-                if (QProgressStyleAnimation *animation = qobject_cast<QProgressStyleAnimation*>(d->animation(option->styleObject)))
-                    step = animation->progressStep(slideWidth);
-                else
-                    d->startAnimation(new QProgressStyleAnimation(d->animationFps, option->styleObject));
-                progressBar.setRect(rect.left() + 2 + step, rect.top() + 2,
-                                    slideWidth / 2, rect.height() - 4);
-            }
-
-            // outline
-            painter->setPen(highlightedDarkInnerBorderColor);
-
-            QVarLengthArray<QLine, 4> lines;
-            QVarLengthArray<QPoint, 8> points;
-            if (!reverse) {
-                if (width == minWidth) {
-                    points.append(QPoint(progressBar.left() + 1, progressBar.top()));
-                    points.append(QPoint(progressBar.left() + 1, progressBar.bottom()));
-                } else {
-                    if (indeterminate) {
-                        lines.append(QLine(progressBar.left() + 2, progressBar.top(),
-                                           progressBar.right() - 2, progressBar.top()));
-                        lines.append(QLine(progressBar.left() + 2, progressBar.bottom(),
-                                           progressBar.right() - 2, progressBar.bottom()));
-                    } else {
-                        lines.append(QLine(progressBar.left() + 1, progressBar.top(),
-                                           progressBar.right() - 2, progressBar.top()));
-                        lines.append(QLine(progressBar.left() + 1, progressBar.bottom(),
-                                           progressBar.right() - 2, progressBar.bottom()));
-                    }
-                }
-
-                if (indeterminate) {
-                    lines.append(QLine(progressBar.left(), progressBar.top() + 2,
-                                       progressBar.left(), progressBar.bottom() - 2));
-                } else {
-                    lines.append(QLine(progressBar.left(), progressBar.top() + 1,
-                                       progressBar.left(), progressBar.bottom() - 1));
-                }
-                lines.append(QLine(progressBar.right(), progressBar.top() + 2,
-                                   progressBar.right(), progressBar.bottom() - 2));
-            } else {
-                if (width == minWidth) {
-                    points.append(QPoint(progressBar.right() - 1, progressBar.top()));
-                    points.append(QPoint(progressBar.right() - 1, progressBar.bottom()));
-                } else {
-                    if (indeterminate) {
-                        lines.append(QLine(progressBar.right() - 2, progressBar.top(),
-                                           progressBar.left() + 2, progressBar.top()));
-                        lines.append(QLine(progressBar.right() - 2, progressBar.bottom(),
-                                           progressBar.left() + 2, progressBar.bottom()));
-                    } else {
-                        lines.append(QLine(progressBar.right() - 1, progressBar.top(),
-                                           progressBar.left() + 2, progressBar.top()));
-                        lines.append(QLine(progressBar.right() - 1, progressBar.bottom(),
-                                           progressBar.left() + 2, progressBar.bottom()));
-                    }
-                }
-                if (indeterminate) {
-                    lines.append(QLine(progressBar.right(), progressBar.top() + 2,
-                                       progressBar.right(), progressBar.bottom() - 2));
-                } else {
-                    lines.append(QLine(progressBar.right(), progressBar.top() + 1,
-                                       progressBar.right(), progressBar.bottom() - 1));
-                }
-                lines.append(QLine(progressBar.left(), progressBar.top() + 2,
-                                   progressBar.left(), progressBar.bottom() - 2));
-            }
-
-            if (points.size() > 0) {
-                painter->drawPoints(points.constData(), points.size());
-                points.clear();
-            }
-            painter->drawLines(lines.constData(), lines.size());
-            lines.clear();
-
-            // alpha corners
-            painter->setPen(alphaInnerColor);
-            if (!reverse) {
-                if (indeterminate) {
-                    points.append(QPoint(progressBar.left() + 1, progressBar.top()));
-                    points.append(QPoint(progressBar.left(), progressBar.top() + 1));
-                    points.append(QPoint(progressBar.left() + 1, progressBar.bottom()));
-                    points.append(QPoint(progressBar.left(), progressBar.bottom() - 1));
-                } else {
-                    points.append(QPoint(progressBar.left(), progressBar.top()));
-                    points.append(QPoint(progressBar.left(), progressBar.bottom()));
-                }
-                points.append(QPoint(progressBar.right() - 1, progressBar.top()));
-                points.append(QPoint(progressBar.right(), progressBar.top() + 1));
-                points.append(QPoint(progressBar.right() - 1, progressBar.bottom()));
-                points.append(QPoint(progressBar.right(), progressBar.bottom() - 1));
-            } else {
-                if (indeterminate) {
-                    points.append(QPoint(progressBar.right() - 1, progressBar.top()));
-                    points.append(QPoint(progressBar.right(), progressBar.top() + 1));
-                    points.append(QPoint(progressBar.right() - 1, progressBar.bottom()));
-                    points.append(QPoint(progressBar.right(), progressBar.bottom() - 1));
-                } else {
-                    points.append(QPoint(progressBar.right(), progressBar.top()));
-                    points.append(QPoint(progressBar.right(), progressBar.bottom()));
-                }
-                points.append(QPoint(progressBar.left() + 1, progressBar.top()));
-                points.append(QPoint(progressBar.left(), progressBar.top() + 1));
-                points.append(QPoint(progressBar.left() + 1, progressBar.bottom()));
-                points.append(QPoint(progressBar.left(), progressBar.bottom() - 1));
-            }
-
-            painter->drawPoints(points.constData(), points.size());
-            points.clear();
-
-            // contents
-            painter->setPen(QPen());
-
-            QString progressBarName = QStyleHelper::uniqueName(QLatin1String("progressBarContents"),
-                                                 option, rect.size());
-            QPixmap cache;
-            if (!QPixmapCache::find(progressBarName, cache) && rect.height() > 7) {
-                QSize size = rect.size();
-                cache = QPixmap(QSize(size.width() - 6 + 30, size.height() - 6));
-                cache.fill(Qt::white);
-                QPainter cachePainter(&cache);
-                QRect pixmapRect(0, 0, cache.width(), cache.height());
-
-                int leftEdge = 0;
-                bool flip = false;
-                while (leftEdge < cache.width() + 1) {
-                    QColor rectColor = option->palette.highlight().color();
-                    QColor lineColor = option->palette.highlight().color();
-                    if (flip) {
-                        flip = false;
-                        rectColor = rectColor.lighter(105);
-                        lineColor = lineColor.lighter(105);
-                    } else {
-                        flip = true;
-                    }
-
-                    cachePainter.setPen(lineColor);
-                    const QLine cacheLines[2] = {
-                        QLine(pixmapRect.left() + leftEdge - 1, pixmapRect.top(),
-                              pixmapRect.left() + leftEdge + 9, pixmapRect.top()),
-                        QLine(pixmapRect.left() + leftEdge - 1, pixmapRect.bottom(),
-                              pixmapRect.left() + leftEdge + 9, pixmapRect.bottom()) };
-                    cachePainter.drawLines(cacheLines, 2);
-                    cachePainter.fillRect(QRect(pixmapRect.left() + leftEdge, pixmapRect.top(),
-                                                10, pixmapRect.height()), rectColor);
-
-                    leftEdge += 10;
-                }
-
-                QPixmapCache::insert(progressBarName, cache);
-            }
-            painter->setClipRect(progressBar.adjusted(1, 0, -1, -1));
-
-            if (!vertical)
-                progressBar.adjust(0, 1, 0, 1);
-            if (!indeterminate) {
-                int step = 0;
-                if (AnimateProgressBar || (indeterminate && AnimateBusyProgressBar)) {
-                    if (QProgressStyleAnimation *animation = qobject_cast<QProgressStyleAnimation*>(d->animation(widget)))
-                        step = animation->animationStep() % 20;
-                }
-                if (reverse)
-                    painter->drawPixmap(progressBar.left() - 25 + step, progressBar.top(), cache);
-                else
-                    painter->drawPixmap(progressBar.left() - 25 - step + width % 20, progressBar.top(), cache);
-            } else {
-                painter->drawPixmap(progressBar.left(), progressBar.top(), cache);
-            }
-
-            painter->restore();
-        }
-        break;
-
-    case CE_HeaderSection:
-        // Draws the header in tables.
-        if (const QStyleOptionHeader *header = qstyleoption_cast<const QStyleOptionHeader *>(option)) {
-            QPixmap cache;
-            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("headersection"), option, option->rect.size());
-            pixmapName += QString::number(- int(header->position));
-            pixmapName += QString::number(- int(header->orientation));
-
-            if (!QPixmapCache::find(pixmapName, cache)) {
-                cache = QPixmap(option->rect.size());
-                cache.fill(Qt::white);
-                QRect pixmapRect(0, 0, option->rect.width(), option->rect.height());
-                QPainter cachePainter(&cache);
-
-                bool sunken = (header->state & State_Enabled) && (header->state & State_Sunken);
-
-                QColor headerGradientStart = sunken ? option->palette.background().color().darker(114) : gradientStartColor;
-                QColor headerGradientStop = sunken ? option->palette.background().color().darker(106) : gradientStopColor;
-
-                QColor lightLine = sunken ? option->palette.background().color().darker(118) : gradientStartColor;
-                QColor darkLine = sunken ? option->palette.background().color().darker(110) : gradientStopColor.darker(105);
-
-                qt_plastique_draw_gradient(&cachePainter, pixmapRect,
-                                           headerGradientStart, headerGradientStop);
-
-                cachePainter.setPen(borderColor);
-                cachePainter.drawRect(pixmapRect.adjusted(0, 0, -1, -1));
-                cachePainter.setPen(alphaCornerColor);
-
-                const QPoint points[4] = {
-                    pixmapRect.topLeft(), pixmapRect.topRight(),
-                    pixmapRect.bottomLeft(), pixmapRect.bottomRight() };
-                cachePainter.drawPoints(points, 4);
-
-                QLine lines[2];
-
-                // inner lines
-                cachePainter.setPen(lightLine);
-                lines[0] = QLine(pixmapRect.left() + 2, pixmapRect.top() + 1,
-                                 pixmapRect.right() - 2, pixmapRect.top() + 1);
-                lines[1] = QLine(pixmapRect.left() + 1, pixmapRect.top() + 2,
-                                 pixmapRect.left() + 1, pixmapRect.bottom() - 2);
-                cachePainter.drawLines(lines, 2);
-
-                cachePainter.setPen(darkLine);
-                lines[0] = QLine(pixmapRect.left() + 2, pixmapRect.bottom() - 1,
-                                 pixmapRect.right() - 2, pixmapRect.bottom() - 1);
-                lines[1] = QLine(pixmapRect.right() - 1, pixmapRect.bottom() - 2,
-                                 pixmapRect.right() - 1, pixmapRect.top() + 2);
-                cachePainter.drawLines(lines, 2);
-
-                cachePainter.end();
-                QPixmapCache::insert(pixmapName, cache);
-            }
-            painter->drawPixmap(option->rect.topLeft(), cache);
-
-        }
-        break;
-#ifndef QT_NO_MENU
-    case CE_MenuItem:
-        // Draws one item in a popup menu.
-        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
-            painter->save();
-            QBrush textBrush;
-            if (option->palette.resolve() & (1 << QPalette::ButtonText))
-                textBrush = option->palette.buttonText();
-            else
-                textBrush = option->palette.windowText(); // KDE uses windowText rather than buttonText for menus
-
-            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator) {
-                painter->fillRect(menuItem->rect, option->palette.background().color().lighter(103));
-
-                int w = 0;
-                if (!menuItem->text.isEmpty()) {
-                    painter->setFont(menuItem->font);
-                    proxy()->drawItemText(painter, menuItem->rect.adjusted(5, 0, -5, 0), Qt::AlignLeft | Qt::AlignVCenter,
-                                 menuItem->palette, menuItem->state & State_Enabled, menuItem->text,
-                                 QPalette::Text);
-                    w = menuItem->fontMetrics.width(menuItem->text) + 5;
-                }
-
-                painter->setPen(alphaCornerColor);
-                bool reverse = menuItem->direction == Qt::RightToLeft;
-                painter->drawLine(menuItem->rect.left() + 5 + (reverse ? 0 : w), menuItem->rect.center().y(),
-                                  menuItem->rect.right() - 5 - (reverse ? w : 0), menuItem->rect.center().y());
-
-                painter->restore();
-                break;
-            }
-
-            bool selected = menuItem->state & State_Selected;
-            bool checkable = menuItem->checkType != QStyleOptionMenuItem::NotCheckable;
-            bool checked = menuItem->checked;
-
-            if (selected) {
-                qt_plastique_draw_gradient(painter, menuItem->rect,
-                                           option->palette.highlight().color().lighter(105),
-                                           option->palette.highlight().color().darker(110));
-
-                painter->setPen(option->palette.highlight().color().lighter(110));
-                painter->drawLine(option->rect.topLeft(), option->rect.topRight());
-                painter->setPen(option->palette.highlight().color().darker(115));
-                painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
-            } else {
-                painter->fillRect(option->rect, option->palette.background().color().lighter(103));
-            }
-
-            // Check
-            QRect checkRect(option->rect.left() + 7, option->rect.center().y() - 6, 13, 13);
-            checkRect = visualRect(menuItem->direction, menuItem->rect, checkRect);
-            if (checkable) {
-                if ((menuItem->checkType & QStyleOptionMenuItem::Exclusive) && menuItem->icon.isNull()) {
-                    QStyleOptionButton button;
-                    button.rect = checkRect;
-                    button.state = menuItem->state;
-                    if (checked)
-                        button.state |= State_On;
-                    button.palette = menuItem->palette;
-                    proxy()->drawPrimitive(PE_IndicatorRadioButton, &button, painter, widget);
-                } else {
-                    if (menuItem->icon.isNull()) {
-                        QStyleOptionButton button;
-                        button.rect = checkRect;
-                        button.state = menuItem->state;
-                        if (checked)
-                            button.state |= State_On;
-                        button.palette = menuItem->palette;
-                        proxy()->drawPrimitive(PE_IndicatorCheckBox, &button, painter, widget);
-                    } else if (checked) {
-                        int iconSize = qMax(menuItem->maxIconWidth, 20);
-                        QRect sunkenRect(option->rect.left() + 1,
-                                         option->rect.top() + (option->rect.height() - iconSize) / 2 + 1,
-                                         iconSize, iconSize);
-                        sunkenRect = visualRect(menuItem->direction, menuItem->rect, sunkenRect);
-
-                        QStyleOption opt = *option;
-                        opt.state |= State_Sunken;
-                        opt.rect = sunkenRect;
-                        qt_plastique_drawShadedPanel(painter, &opt, false, widget);
-                    }
-                }
-            }
-
-            // Text and icon, ripped from windows style
-            bool dis = !(menuItem->state & State_Enabled);
-            bool act = menuItem->state & State_Selected;
-            const QStyleOption *opt = option;
-            const QStyleOptionMenuItem *menuitem = menuItem;
-            int checkcol = qMax(menuitem->maxIconWidth, 20);
-            QPainter *p = painter;
-            QRect vCheckRect = visualRect(opt->direction, menuitem->rect,
-                                          QRect(menuitem->rect.x(), menuitem->rect.y(),
-                                                checkcol, menuitem->rect.height()));
-            if (!menuItem->icon.isNull()) {
-                QIcon::Mode mode = dis ? QIcon::Disabled : QIcon::Normal;
-                if (act && !dis)
-                    mode = QIcon::Active;
-                QPixmap pixmap;
-                if (checked)
-                    pixmap = menuItem->icon.pixmap(pixelMetric(PM_SmallIconSize, option, widget), mode, QIcon::On);
-                else
-                    pixmap = menuItem->icon.pixmap(pixelMetric(PM_SmallIconSize, option, widget), mode);
-                int pixw = pixmap.width();
-                int pixh = pixmap.height();
-
-                QRect pmr(0, 0, pixw, pixh);
-                pmr.moveCenter(vCheckRect.center());
-                painter->setPen(textBrush.color());
-                if (checkable && checked)
-                    painter->drawPixmap(QPoint(pmr.left() + 1, pmr.top() + 1), pixmap);
-                else
-                    painter->drawPixmap(pmr.topLeft(), pixmap);
-            }
-
-            if (selected) {
-                painter->setPen(menuItem->palette.highlightedText().color());
-            } else {
-                painter->setPen(textBrush.color());
-            }
-            int x, y, w, h;
-            menuitem->rect.getRect(&x, &y, &w, &h);
-            int tab = menuitem->tabWidth;
-            QColor discol;
-            if (dis) {
-                discol = textBrush.color();
-                p->setPen(discol);
-            }
-            int xm = windowsItemFrame + checkcol + windowsItemHMargin;
-            int xpos = menuitem->rect.x() + xm;
-            QRect textRect(xpos, y + windowsItemVMargin, w - xm - windowsRightBorder - tab + 1, h - 2 * windowsItemVMargin);
-            QRect vTextRect = visualRect(opt->direction, menuitem->rect, textRect);
-            QString s = menuitem->text;
-            if (!s.isEmpty()) {                     // draw text
-                p->save();
-                int t = s.indexOf(QLatin1Char('\t'));
-                int text_flags = Qt::AlignVCenter | Qt::TextShowMnemonic | Qt::TextDontClip | Qt::TextSingleLine;
-                if (!styleHint(SH_UnderlineShortcut, menuitem, widget))
-                    text_flags |= Qt::TextHideMnemonic;
-                text_flags |= Qt::AlignLeft;
-                if (t >= 0) {
-                    QRect vShortcutRect = visualRect(opt->direction, menuitem->rect,
-                        QRect(textRect.topRight(), QPoint(menuitem->rect.right(), textRect.bottom())));
-                    if (dis && !act && styleHint(SH_EtchDisabledText, option, widget)) {
-                        p->setPen(menuitem->palette.light().color());
-                        p->drawText(vShortcutRect.adjusted(1,1,1,1), text_flags, s.mid(t + 1));
-                        p->setPen(discol);
-                    }
-                    p->drawText(vShortcutRect, text_flags, s.mid(t + 1));
-                    s = s.left(t);
-                }
-                QFont font = menuitem->font;
-                if (menuitem->menuItemType == QStyleOptionMenuItem::DefaultItem)
-                    font.setBold(true);
-                p->setFont(font);
-                if (dis && !act && styleHint(SH_EtchDisabledText, option, widget)) {
-                    p->setPen(menuitem->palette.light().color());
-                    p->drawText(vTextRect.adjusted(1,1,1,1), text_flags, s.left(t));
-                    p->setPen(discol);
-                }
-                p->drawText(vTextRect, text_flags, s.left(t));
-                p->restore();
-            }
-
-            // Arrow
-            if (menuItem->menuItemType == QStyleOptionMenuItem::SubMenu) {// draw sub menu arrow
-                int dim = (menuItem->rect.height() - 4) / 2;
-                PrimitiveElement arrow;
-                arrow = (opt->direction == Qt::RightToLeft) ? PE_IndicatorArrowLeft : PE_IndicatorArrowRight;
-                int xpos = menuItem->rect.left() + menuItem->rect.width() - 6 - 2 - dim;
-                QRect  vSubMenuRect = visualRect(option->direction, menuItem->rect,
-                                                 QRect(xpos, menuItem->rect.top() + menuItem->rect.height() / 2 - dim / 2, dim, dim));
-                QStyleOptionMenuItem newMI = *menuItem;
-                newMI.rect = vSubMenuRect;
-                newMI.state = option->state & State_Enabled;
-                if (selected)
-                    newMI.palette.setColor(QPalette::ButtonText,
-                                           newMI.palette.highlightedText().color());
-                else
-                    newMI.palette.setColor(QPalette::ButtonText, textBrush.color());
-                proxy()->drawPrimitive(arrow, &newMI, painter, widget);
-            }
-
-            painter->restore();
-        }
-        break;
-#endif // QT_NO_MENU
-#ifndef QT_NO_MENUBAR
-    case CE_MenuBarItem:
-        // Draws a menu bar item; File, Edit, Help etc..
-        if ((option->state & State_Selected)) {
-            QPixmap cache;
-            QString pixmapName = QStyleHelper::uniqueName(QLatin1String("menubaritem"), option, option->rect.size());
-            if (!QPixmapCache::find(pixmapName, cache)) {
-                cache = QPixmap(option->rect.size());
-                cache.fill(Qt::white);
-                QRect pixmapRect(0, 0, option->rect.width(), option->rect.height());
-                QPainter cachePainter(&cache);
-
-                QRect rect = pixmapRect;
-
-                // gradient fill
-                if ((option->state & QStyle::State_Sunken) || (option->state & QStyle::State_On)) {
-                    qt_plastique_draw_gradient(&cachePainter, rect.adjusted(1, 1, -1, -1),
-                                               option->palette.button().color().darker(114),
-                                               option->palette.button().color().darker(106));
-                } else {
-                    qt_plastique_draw_gradient(&cachePainter, rect.adjusted(1, 1, -1, -1),
-                                               option->palette.background().color().lighter(105),
-                                               option->palette.background().color().darker(102));
-                }
-
-                // outer border and corners
-                cachePainter.setPen(borderColor);
-                cachePainter.drawRect(rect.adjusted(0, 0, -1, -1));
-                cachePainter.setPen(alphaCornerColor);
-
-                const QPoint points[4] = {
-                    rect.topLeft(),
-                    rect.topRight(),
-                    rect.bottomLeft(),
-                    rect.bottomRight() };
-                cachePainter.drawPoints(points, 4);
-
-                // inner border
-                if ((option->state & QStyle::State_Sunken) || (option->state & QStyle::State_On))
-                    cachePainter.setPen(option->palette.button().color().darker(118));
-                else
-                    cachePainter.setPen(gradientStartColor);
-
-                QLine lines[2];
-                lines[0] = QLine(rect.left() + 1, rect.top() + 1, rect.right() - 1, rect.top() + 1);
-                lines[1] = QLine(rect.left() + 1, rect.top() + 2, rect.left() + 1, rect.bottom() - 2);
-                cachePainter.drawLines(lines, 2);
-
-                if ((option->state & QStyle::State_Sunken) || (option->state & QStyle::State_On))
-                    cachePainter.setPen(option->palette.button().color().darker(114));
-                else
-                    cachePainter.setPen(gradientStopColor.darker(102));
-                lines[0] = QLine(rect.left() + 1, rect.bottom() - 1, rect.right() - 1, rect.bottom() - 1);
-                lines[1] = QLine(rect.right() - 1, rect.top() + 1, rect.right() - 1, rect.bottom() - 2);
-                cachePainter.drawLines(lines, 2);
-                cachePainter.end();
-                QPixmapCache::insert(pixmapName, cache);
-            }
-            painter->drawPixmap(option->rect.topLeft(), cache);
-        } else {
-            painter->fillRect(option->rect, option->palette.background());
-        }
-
-        if (const QStyleOptionMenuItem *mbi = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
-            QStyleOptionMenuItem newMI = *mbi;
-            if (!(option->palette.resolve() & (1 << QPalette::ButtonText))) //KDE uses windowText rather than buttonText for menus
-                newMI.palette.setColor(QPalette::ButtonText, newMI.palette.windowText().color());
-            QCommonStyle::drawControl(element, &newMI, painter, widget);
-        }
-        break;
-
-#ifndef QT_NO_MAINWINDOW
-    case CE_MenuBarEmptyArea:
-        if (widget && qobject_cast<const QMainWindow *>(widget->parentWidget())) {
-            painter->fillRect(option->rect, option->palette.window());
-            QPen oldPen = painter->pen();
-            painter->setPen(QPen(option->palette.dark().color()));
-            painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
-            painter->setPen(oldPen);
-        }
-        break;
-#endif // QT_NO_MAINWINDOW
-
-#endif // QT_NO_MENUBAR
-
-#ifndef QT_NO_TOOLBOX
-    case CE_ToolBoxTabShape:
-        if (const QStyleOptionToolBox *toolBox = qstyleoption_cast<const QStyleOptionToolBox *>(option)) {
-            painter->save();
-
-            int width = toolBox->rect.width();
-            int diag = toolBox->rect.height() - 2;
-
-            // The essential points
-            QPoint rightMost;
-            QPoint rightEdge;
-            QPoint leftEdge;
-            QPoint leftMost;
-            QPoint leftOne;
-            QPoint rightOne;
-            QPoint upOne(0, -1);
-            QPoint downOne(0, 1);
-
-            if (toolBox->direction != Qt::RightToLeft) {
-                rightMost = QPoint(toolBox->rect.right(), toolBox->rect.bottom() - 2);
-                rightEdge = QPoint(toolBox->rect.right() - width / 10, toolBox->rect.bottom() - 2);
-                leftEdge = QPoint(toolBox->rect.right() - width / 10 - diag, toolBox->rect.top());
-                leftMost = QPoint(toolBox->rect.left(), toolBox->rect.top());
-                leftOne = QPoint(-1, 0);
-                rightOne = QPoint(1, 0);
-            } else {
-                rightMost = QPoint(toolBox->rect.left(), toolBox->rect.bottom() - 2);
-                rightEdge = QPoint(toolBox->rect.left() + width / 10, toolBox->rect.bottom() - 2);
-                leftEdge = QPoint(toolBox->rect.left() + width / 10 + diag, toolBox->rect.top());
-                leftMost = QPoint(toolBox->rect.right(), toolBox->rect.top());
-                leftOne = QPoint(1, 0);
-                rightOne = QPoint(-1, 0);
-            }
-
-            QLine lines[3];
-
-            // Draw the outline
-            painter->setPen(borderColor);
-            lines[0] = QLine(rightMost, rightEdge);
-            lines[1] = QLine(rightEdge + leftOne, leftEdge);
-            lines[2] = QLine(leftEdge + leftOne, leftMost);
-            painter->drawLines(lines, 3);
-            painter->setPen(toolBox->palette.base().color());
-            lines[0] = QLine(rightMost + downOne, rightEdge + downOne);
-            lines[1] = QLine(rightEdge + leftOne + downOne, leftEdge + downOne);
-            lines[2] = QLine(leftEdge + leftOne + downOne, leftMost + downOne);
-            painter->drawLines(lines, 3);
-
-            painter->restore();
-        }
-        break;
-#endif // QT_NO_TOOLBOX
-#ifndef QT_NO_SPLITTER
-    case CE_Splitter:
-        if ((option->state & State_Enabled) && (option->state & State_MouseOver))
-            painter->fillRect(option->rect, QColor(255, 255, 255, 128));
-        if (option->state & State_Horizontal) {
-            int height = option->rect.height() / 3;
-            QRect rect(option->rect.left() + (option->rect.width() / 2 - 1),
-                       option->rect.center().y() - height / 2, 3, height);
-            qt_plastique_draw_handle(painter, option, rect, Qt::Horizontal, widget);
-        } else {
-            int width = option->rect.width() / 3;
-            QRect rect(option->rect.center().x() - width / 2,
-                       option->rect.top() + (option->rect.height() / 2) - 1, width, 3);
-            qt_plastique_draw_handle(painter, option, rect, Qt::Vertical, widget);
-        }
-        break;
-#endif // QT_NO_SPLITTER
-#ifndef QT_NO_DOCKWIDGET
-    case CE_DockWidgetTitle:
-        if (const QStyleOptionDockWidget *dockWidget = qstyleoption_cast<const QStyleOptionDockWidget *>(option)) {
-            painter->save();
-
-            const QStyleOptionDockWidgetV2 *v2
-                = qstyleoption_cast<const QStyleOptionDockWidgetV2*>(dockWidget);
-            bool verticalTitleBar = v2 == 0 ? false : v2->verticalTitleBar;
-
-            // Find text width and title rect
-            int textWidth = option->fontMetrics.width(dockWidget->title);
-            int margin = 4;
-            QRect titleRect = subElementRect(SE_DockWidgetTitleBarText, option, widget);
-            QRect rect = dockWidget->rect;
-
-            if (verticalTitleBar) {
-                QRect r = rect;
-                QSize s = r.size();
-                s.transpose();
-                r.setSize(s);
-
-                titleRect = QRect(r.left() + rect.bottom()
-                                    - titleRect.bottom(),
-                                r.top() + titleRect.left() - rect.left(),
-                                titleRect.height(), titleRect.width());
-
-                painter->translate(r.left(), r.top() + r.width());
-                painter->rotate(-90);
-                painter->translate(-r.left(), -r.top());
-
-                rect = r;
-            }
-
-            // Chop and insert ellide into title if text is too wide
-            QString title = elliditide(dockWidget->title, dockWidget->fontMetrics, titleRect, &textWidth);
-
-            // Draw the toolbar handle pattern to the left and right of the text
-            QImage handle(qt_toolbarhandle);
-            alphaCornerColor.setAlpha(170);
-            handle.setColor(1, alphaCornerColor.rgba());
-            handle.setColor(2, mergedColors(alphaCornerColor, option->palette.light().color()).rgba());
-            handle.setColor(3, option->palette.light().color().rgba());
-
-            if (title.isEmpty()) {
-                // Joint handle if there's no title
-                QRect r;
-                    r.setRect(titleRect.left(), titleRect.top(), titleRect.width(), titleRect.bottom());
-                    int nchunks = (r.width() / handle.width()) - 1;
-                    int indent = (r.width() - (nchunks * handle.width())) / 2;
-                    for (int i = 0; i < nchunks; ++i) {
-                        painter->drawImage(QPoint(r.left() + indent + i * handle.width(),
-                                                r.center().y() - handle.height() / 2),
-                                        handle);
-                    }
-            } else {
-                // Handle pattern to the left of the title
-                QRect leftSide(titleRect.left(), titleRect.top(),
-                               titleRect.width() / 2 - textWidth / 2 - margin, titleRect.bottom());
-                int nchunks = leftSide.width() / handle.width();
-                int indent = (leftSide.width() - (nchunks * handle.width())) / 2;
-                for (int i = 0; i < nchunks; ++i) {
-                    painter->drawImage(QPoint(leftSide.left() + indent
-                                                + i * handle.width(),
-                                              leftSide.center().y()
-                                                - handle.height() / 2),
-                                       handle);
-                }
-
-                // Handle pattern to the right of the title
-                QRect rightSide = titleRect.adjusted(titleRect.width() / 2 + textWidth / 2 + margin, 0, 0, 0);
-                nchunks = rightSide.width() / handle.width();
-                indent = (rightSide.width() - (nchunks * handle.width())) / 2;
-                for (int j = 0; j < nchunks; ++j) {
-                    painter->drawImage(QPoint(rightSide.left() + indent + j * handle.width(),
-                                              rightSide.center().y() - handle.height() / 2),
-                                       handle);
-                }
-            }
-
-            // Draw the text centered
-            QFont font = painter->font();
-            font.setPointSize(QFontInfo(font).pointSize() - 1);
-            painter->setFont(font);
-            painter->setPen(dockWidget->palette.windowText().color());
-            painter->drawText(titleRect,
-                              int(Qt::AlignHCenter | Qt::AlignVCenter | Qt::TextShowMnemonic),
-                              title);
-
-            painter->restore();
-        }
-
-        break;
-#endif // QT_NO_DOCKWIDGET
-#ifndef QT_NO_TOOLBAR
-    case CE_ToolBar:
-        if (const QStyleOptionToolBar *toolBar = qstyleoption_cast<const QStyleOptionToolBar *>(option)) {
-            // Draws the light line above and the dark line below menu bars and
-            // tool bars.
-            QPen oldPen = painter->pen();
-            if (toolBar->toolBarArea == Qt::TopToolBarArea) {
-                if (toolBar->positionOfLine == QStyleOptionToolBar::End
-                    || toolBar->positionOfLine == QStyleOptionToolBar::OnlyOne) {
-                    // The end and onlyone top toolbar lines draw a double
-                    // line at the bottom to blend with the central
-                    // widget.
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.left(), option->rect.bottom() - 1,
-                                      option->rect.right(), option->rect.bottom() - 1);
-                } else {
-                    // All others draw a single dark line at the bottom.
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
-                }
-                // All top toolbar lines draw a light line at the top.
-                painter->setPen(option->palette.background().color().lighter(104));
-                painter->drawLine(option->rect.topLeft(), option->rect.topRight());
-            } else if (toolBar->toolBarArea == Qt::BottomToolBarArea) {
-                if (toolBar->positionOfLine == QStyleOptionToolBar::End
-                    || toolBar->positionOfLine == QStyleOptionToolBar::Middle) {
-                    // The end and middle bottom tool bar lines draw a dark
-                    // line at the bottom.
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
-                }
-                if (toolBar->positionOfLine == QStyleOptionToolBar::Beginning
-                    || toolBar->positionOfLine == QStyleOptionToolBar::OnlyOne) {
-                    // The beginning and only one tool bar lines draw a
-                    // double line at the bottom to blend with the
-                    // status bar.
-                    // ### The styleoption could contain whether the
-                    // main window has a menu bar and a status bar, and
-                    // possibly dock widgets.
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.left(), option->rect.bottom() - 1,
-                                      option->rect.right(), option->rect.bottom() - 1);
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.bottomLeft(), option->rect.bottomRight());
-                }
-                if (toolBar->positionOfLine == QStyleOptionToolBar::End) {
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.topLeft(), option->rect.topRight());
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.left(), option->rect.top() + 1,
-                                      option->rect.right(), option->rect.top() + 1);
-
-                } else {
-                    // All other bottom toolbars draw a light line at the top.
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.topLeft(), option->rect.topRight());
-                }
-            }
-            if (toolBar->toolBarArea == Qt::LeftToolBarArea) {
-                if (toolBar->positionOfLine == QStyleOptionToolBar::Middle
-                    || toolBar->positionOfLine == QStyleOptionToolBar::End) {
-                    // The middle and left end toolbar lines draw a light
-                    // line to the left.
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.topLeft(), option->rect.bottomLeft());
-                }
-                if (toolBar->positionOfLine == QStyleOptionToolBar::End) {
-                    // All other left toolbar lines draw a dark line to the right
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.right() - 1, option->rect.top(),
-                                      option->rect.right() - 1, option->rect.bottom());
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.topRight(), option->rect.bottomRight());
-                } else {
-                    // All other left toolbar lines draw a dark line to the right
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.topRight(), option->rect.bottomRight());
-                }
-            } else if (toolBar->toolBarArea == Qt::RightToolBarArea) {
-                if (toolBar->positionOfLine == QStyleOptionToolBar::Middle
-                    || toolBar->positionOfLine == QStyleOptionToolBar::End) {
-                    // Right middle and end toolbar lines draw the dark right line
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.topRight(), option->rect.bottomRight());
-                }
-                if (toolBar->positionOfLine == QStyleOptionToolBar::End
-                    || toolBar->positionOfLine == QStyleOptionToolBar::OnlyOne) {
-                    // The right end and single toolbar draws the dark
-                    // line on its left edge
-                    painter->setPen(alphaCornerColor);
-                    painter->drawLine(option->rect.topLeft(), option->rect.bottomLeft());
-                    // And a light line next to it
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.left() + 1, option->rect.top(),
-                                      option->rect.left() + 1, option->rect.bottom());
-                } else {
-                    // Other right toolbars draw a light line on its left edge
-                    painter->setPen(option->palette.background().color().lighter(104));
-                    painter->drawLine(option->rect.topLeft(), option->rect.bottomLeft());
-                }
-            }
-            painter->setPen(oldPen);
-        }
-        break;
-#endif // QT_NO_TOOLBAR
-#ifndef QT_NO_SCROLLBAR
-    case CE_ScrollBarAddLine:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            bool reverse = scrollBar->direction == Qt::RightToLeft;
-            bool sunken = scrollBar->state & State_Sunken;
-
-            QString addLinePixmapName = QStyleHelper::uniqueName(QLatin1String("scrollbar_addline"), option, option->rect.size());
-            QPixmap cache;
-            if (!QPixmapCache::find(addLinePixmapName, cache)) {
-                cache = QPixmap(option->rect.size());
-                cache.fill(Qt::white);
-                QRect pixmapRect(0, 0, cache.width(), cache.height());
-                QPainter addLinePainter(&cache);
-                addLinePainter.fillRect(pixmapRect, option->palette.background());
-
-                if (option->state & State_Enabled) {
-                    // Gradient
-                    QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top() + 2,
-                                             pixmapRect.center().x(), pixmapRect.bottom() - 2);
-                    if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
-                        gradient.setColorAt(0, gradientStopColor);
-                        gradient.setColorAt(1, gradientStopColor);
-                    } else {
-                        gradient.setColorAt(0, gradientStartColor.lighter(105));
-                        gradient.setColorAt(1, gradientStopColor);
-                    }
-                    addLinePainter.fillRect(pixmapRect.left() + 2, pixmapRect.top() + 2,
-                                            pixmapRect.right() - 3, pixmapRect.bottom() - 3,
-                                            gradient);
-                }
-
-                // Details
-                QImage addButton;
-                if (horizontal) {
-                    addButton = QImage(reverse ? qt_scrollbar_button_left : qt_scrollbar_button_right);
-                } else {
-                    addButton = QImage(qt_scrollbar_button_down);
-                }
-                addButton.setColor(1, alphaCornerColor.rgba());
-                addButton.setColor(2, borderColor.rgba());
-                if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken) {
-                    addButton.setColor(3, gradientStopColor.rgba());
-                    addButton.setColor(4, gradientStopColor.rgba());
-                } else {
-                    addButton.setColor(3, gradientStartColor.lighter(105).rgba());
-                    addButton.setColor(4, gradientStopColor.rgba());
-                }
-                addButton.setColor(5, scrollBar->palette.text().color().rgba());
-                addLinePainter.drawImage(pixmapRect, addButton);
-
-                // Arrow
-                if (horizontal) {
-                    QImage arrow(reverse ? qt_scrollbar_button_arrow_left : qt_scrollbar_button_arrow_right);
-                    arrow.setColor(1, scrollBar->palette.foreground().color().rgba());
-
-                    if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken)
-                        addLinePainter.translate(1, 1);
-                    addLinePainter.drawImage(QPoint(pixmapRect.center().x() - 2, pixmapRect.center().y() - 3), arrow);
-                } else {
-                    QImage arrow(qt_scrollbar_button_arrow_down);
-                    arrow.setColor(1, scrollBar->palette.foreground().color().rgba());
-
-                    if ((scrollBar->activeSubControls & SC_ScrollBarAddLine) && sunken)
-                        addLinePainter.translate(1, 1);
-                    addLinePainter.drawImage(QPoint(pixmapRect.center().x() - 3, pixmapRect.center().y() - 2), arrow);
-                }
-                addLinePainter.end();
-                QPixmapCache::insert(addLinePixmapName, cache);
-            }
-            painter->drawPixmap(option->rect.topLeft(), cache);
-        }
-        break;
-    case CE_ScrollBarSubPage:
-    case CE_ScrollBarAddPage:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            bool sunken = scrollBar->state & State_Sunken;
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-
-            QString groovePixmapName = QStyleHelper::uniqueName(QLatin1String("scrollbar_groove"), option, option->rect.size());
-            if (sunken)
-                groovePixmapName += QLatin1String("-sunken");
-            if (element == CE_ScrollBarAddPage)
-                groovePixmapName += QLatin1String("-addpage");
-
-            QPixmap cache;
-            if (!QPixmapCache::find(groovePixmapName, cache)) {
-                cache = QPixmap(option->rect.size());
-                cache.fill(option->palette.background().color());
-                QPainter groovePainter(&cache);
-                QRect pixmapRect = QRect(0, 0, option->rect.width(), option->rect.height());
-                QColor color = scrollBar->palette.base().color().darker(sunken ? 125 : 100);
-                groovePainter.setBrushOrigin((element == CE_ScrollBarAddPage) ? pixmapRect.width() : 0,
-                                             (element == CE_ScrollBarAddPage) ? pixmapRect.height() : 0);
-                groovePainter.fillRect(pixmapRect, QBrush(color, Qt::Dense4Pattern));
-
-                QColor edgeColor = scrollBar->palette.base().color().darker(125);
-                if (horizontal) {
-                    groovePainter.setBrushOrigin((element == CE_ScrollBarAddPage) ? pixmapRect.width() : 1, 0);
-                    groovePainter.fillRect(QRect(pixmapRect.topLeft(), QSize(pixmapRect.width(), 1)),
-                                           QBrush(edgeColor, Qt::Dense4Pattern));
-                    groovePainter.fillRect(QRect(pixmapRect.bottomLeft(), QSize(pixmapRect.width(), 1)),
-                                           QBrush(edgeColor, Qt::Dense4Pattern));
-                } else {
-                    groovePainter.setBrushOrigin(0, (element == CE_ScrollBarAddPage) ? pixmapRect.height() : 1);
-                    groovePainter.fillRect(QRect(pixmapRect.topLeft(), QSize(1, pixmapRect.height())),
-                                           QBrush(edgeColor, Qt::Dense4Pattern));
-                    groovePainter.fillRect(QRect(pixmapRect.topRight(), QSize(1, pixmapRect.height())),
-                                           QBrush(edgeColor, Qt::Dense4Pattern));
-                }
-
-                groovePainter.end();
-                QPixmapCache::insert(groovePixmapName, cache);
-            }
-            painter->drawPixmap(option->rect.topLeft(), cache);
-        }
-        break;
-    case CE_ScrollBarSubLine:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect scrollBarSubLine = scrollBar->rect;
-
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            bool isEnabled = scrollBar->state & State_Enabled;
-            bool reverse = scrollBar->direction == Qt::RightToLeft;
-            bool sunken = scrollBar->state & State_Sunken;
-
-            // The SubLine (up/left) buttons
-            QRect button1;
-            QRect button2;
-            int scrollBarExtent = proxy()->pixelMetric(PM_ScrollBarExtent, option, widget);
-            if (horizontal) {
-                button1.setRect(scrollBarSubLine.left(), scrollBarSubLine.top(), scrollBarExtent, scrollBarSubLine.height());
-                button2.setRect(scrollBarSubLine.right() - (scrollBarExtent - 1), scrollBarSubLine.top(), scrollBarExtent, scrollBarSubLine.height());
-            } else {
-                button1.setRect(scrollBarSubLine.left(), scrollBarSubLine.top(), scrollBarSubLine.width(), scrollBarExtent);
-                button2.setRect(scrollBarSubLine.left(), scrollBarSubLine.bottom() - (scrollBarExtent - 1), scrollBarSubLine.width(), scrollBarExtent);
-            }
-
-            QString subLinePixmapName = QStyleHelper::uniqueName(QLatin1String("scrollbar_subline"), option, button1.size());
-            QPixmap cache;
-            if (!QPixmapCache::find(subLinePixmapName, cache)) {
-                cache = QPixmap(button1.size());
-                cache.fill(Qt::white);
-                QRect pixmapRect(0, 0, cache.width(), cache.height());
-                QPainter subLinePainter(&cache);
-                subLinePainter.fillRect(pixmapRect, option->palette.background());
-
-                if (isEnabled) {
-                    // Gradients
-                    if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
-                        qt_plastique_draw_gradient(&subLinePainter,
-                                                   QRect(pixmapRect.left() + 2, pixmapRect.top() + 2,
-                                                         pixmapRect.right() - 3, pixmapRect.bottom() - 3),
-                                                   gradientStopColor,
-                                                   gradientStopColor);
-                    } else {
-                        qt_plastique_draw_gradient(&subLinePainter,
-                                                   QRect(pixmapRect.left() + 2, pixmapRect.top() + 2,
-                                                         pixmapRect.right() - 3, pixmapRect.bottom() - 3),
-                                                   gradientStartColor.lighter(105),
-                                                   gradientStopColor);
-                    }
-                }
-
-                // Details
-                QImage subButton;
-                if (horizontal) {
-                    subButton = QImage(reverse ? qt_scrollbar_button_right : qt_scrollbar_button_left);
-                } else {
-                    subButton = QImage(qt_scrollbar_button_up);
-                }
-                subButton.setColor(1, alphaCornerColor.rgba());
-                subButton.setColor(2, borderColor.rgba());
-                if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken) {
-                    subButton.setColor(3, gradientStopColor.rgba());
-                    subButton.setColor(4, gradientStopColor.rgba());
-                } else {
-                    subButton.setColor(3, gradientStartColor.lighter(105).rgba());
-                    subButton.setColor(4, gradientStopColor.rgba());
-                }
-                subButton.setColor(5, scrollBar->palette.text().color().rgba());
-                subLinePainter.drawImage(pixmapRect, subButton);
-
-                // Arrows
-                if (horizontal) {
-                    QImage arrow(reverse ? qt_scrollbar_button_arrow_right : qt_scrollbar_button_arrow_left);
-                    arrow.setColor(1, scrollBar->palette.foreground().color().rgba());
-
-                    if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken)
-                        subLinePainter.translate(1, 1);
-                    subLinePainter.drawImage(QPoint(pixmapRect.center().x() - 2, pixmapRect.center().y() - 3), arrow);
-                } else {
-                    QImage arrow(qt_scrollbar_button_arrow_up);
-                    arrow.setColor(1, scrollBar->palette.foreground().color().rgba());
-
-                    if ((scrollBar->activeSubControls & SC_ScrollBarSubLine) && sunken)
-                        subLinePainter.translate(1, 1);
-                    subLinePainter.drawImage(QPoint(pixmapRect.center().x() - 3, pixmapRect.center().y() - 2), arrow);
-                }
-                subLinePainter.end();
-                QPixmapCache::insert(subLinePixmapName, cache);
-            }
-            painter->drawPixmap(button1.topLeft(), cache);
-            painter->drawPixmap(button2.topLeft(), cache);
-        }
-        break;
-    case CE_ScrollBarSlider:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            bool horizontal = scrollBar->orientation == Qt::Horizontal;
-            bool isEnabled = scrollBar->state & State_Enabled;
-
-            // The slider
-            if (option->rect.isValid()) {
-                QString sliderPixmapName = QStyleHelper::uniqueName(QLatin1String("scrollbar_slider"), option, option->rect.size());
-                if (horizontal)
-                    sliderPixmapName += QLatin1String("-horizontal");
-
-                QPixmap cache;
-                if (!QPixmapCache::find(sliderPixmapName, cache)) {
-                    cache = QPixmap(option->rect.size());
-                    cache.fill(Qt::white);
-                    QRect pixmapRect(0, 0, cache.width(), cache.height());
-                    QPainter sliderPainter(&cache);
-                    bool sunken = (scrollBar->state & State_Sunken);
-
-                    if (isEnabled) {
-                        QLinearGradient gradient(pixmapRect.left(), pixmapRect.center().y(),
-                                                 pixmapRect.right(), pixmapRect.center().y());
-                        if (horizontal)
-                            gradient = QLinearGradient(pixmapRect.center().x(), pixmapRect.top(),
-                                                 pixmapRect.center().x(), pixmapRect.bottom());
-
-                        if (sunken) {
-                            gradient.setColorAt(0, gradientStartColor.lighter(110));
-                            gradient.setColorAt(1, gradientStopColor.lighter(105));
-                        } else {
-                            gradient.setColorAt(0, gradientStartColor.lighter(105));
-                            gradient.setColorAt(1, gradientStopColor);
-                        }
-                        sliderPainter.fillRect(pixmapRect.adjusted(2, 2, -2, -2), gradient);
-                    } else {
-                        sliderPainter.fillRect(pixmapRect.adjusted(2, 2, -2, -2), option->palette.background());
-                    }
-
-                    sliderPainter.setPen(borderColor);
-                    sliderPainter.drawRect(pixmapRect.adjusted(0, 0, -1, -1));
-                    sliderPainter.setPen(alphaCornerColor);
-                    QPoint points[4] = {
-                        QPoint(pixmapRect.left(), pixmapRect.top()),
-                        QPoint(pixmapRect.left(), pixmapRect.bottom()),
-                        QPoint(pixmapRect.right(), pixmapRect.top()),
-                        QPoint(pixmapRect.right(), pixmapRect.bottom()) };
-                    sliderPainter.drawPoints(points, 4);
-
-                    QLine lines[2];
-                    sliderPainter.setPen(sunken ? gradientStartColor.lighter(110) : gradientStartColor.lighter(105));
-                    lines[0] = QLine(pixmapRect.left() + 1, pixmapRect.top() + 1,
-                                     pixmapRect.right() - 1, pixmapRect.top() + 1);
-                    lines[1] = QLine(pixmapRect.left() + 1, pixmapRect.top() + 2,
-                                     pixmapRect.left() + 1, pixmapRect.bottom() - 2);
-                    sliderPainter.drawLines(lines, 2);
-
-                    sliderPainter.setPen(sunken ? gradientStopColor.lighter(105) : gradientStopColor);
-                    lines[0] = QLine(pixmapRect.left() + 1, pixmapRect.bottom() - 1,
-                                     pixmapRect.right() - 1, pixmapRect.bottom() - 1);
-                    lines[1] = QLine(pixmapRect.right() - 1, pixmapRect.top() + 2,
-                                     pixmapRect.right() - 1, pixmapRect.bottom() - 1);
-                    sliderPainter.drawLines(lines, 2);
-
-                    int sliderMinLength = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollBar, widget);
-                    if ((horizontal && scrollBar->rect.width() > sliderMinLength)
-                        || (!horizontal && scrollBar->rect.height() > sliderMinLength)) {
-                        QImage pattern(horizontal ? qt_scrollbar_slider_pattern_horizontal
-                                       : qt_scrollbar_slider_pattern_vertical);
-                        pattern.setColor(1, alphaCornerColor.rgba());
-                        pattern.setColor(2, (sunken ? gradientStartColor.lighter(110) : gradientStartColor.lighter(105)).rgba());
-
-                        if (horizontal) {
-                            sliderPainter.drawImage(pixmapRect.center().x() - pattern.width() / 2 + 1,
-                                                    pixmapRect.center().y() - 4,
-                                                    pattern);
-                        } else {
-                            sliderPainter.drawImage(pixmapRect.center().x() - 4,
-                                                    pixmapRect.center().y() - pattern.height() / 2 + 1,
-                                                    pattern);
-                        }
-                    }
-                    sliderPainter.end();
-                    // insert the slider into the cache
-                    QPixmapCache::insert(sliderPixmapName, cache);
-                }
-                painter->drawPixmap(option->rect.topLeft(), cache);
-            }
-        }
-        break;
-#endif
-#ifndef QT_NO_COMBOBOX
-    case CE_ComboBoxLabel:
-        if (const QStyleOptionComboBox *comboBox = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
-            painter->save();
-            if (!comboBox->editable) {
-                // Plastique's non-editable combo box is drawn as a button, so
-                // we need the label to be drawn using ButtonText where it
-                // would usually use Text.
-                painter->setPen(QPen(comboBox->palette.buttonText(), 0));
-                QWindowsStyle::drawControl(element, option, painter, widget);
-            } else if (!comboBox->currentIcon.isNull()) {
-                {
-                    QRect editRect = proxy()->subControlRect(CC_ComboBox, comboBox, SC_ComboBoxEditField, widget);
-                    if (comboBox->direction == Qt::RightToLeft)
-                        editRect.adjust(0, 2, -2, -2);
-                    else
-                        editRect.adjust(2, 2, 0, -2);
-                    painter->save();
-                    painter->setClipRect(editRect);
-                    if (!comboBox->currentIcon.isNull()) {
-                        QIcon::Mode mode = comboBox->state & State_Enabled ? QIcon::Normal
-                                           : QIcon::Disabled;
-                        QPixmap pixmap = comboBox->currentIcon.pixmap(comboBox->iconSize, mode);
-                        QRect iconRect(editRect);
-                        iconRect.setWidth(comboBox->iconSize.width() + 5);
-                        iconRect = alignedRect(comboBox->direction,
-                                               Qt::AlignLeft | Qt::AlignVCenter,
-                                               iconRect.size(), editRect);
-                        painter->fillRect(iconRect, option->palette.brush(QPalette::Base));
-                        proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pixmap);
-                    }
-                    painter->restore();
-                }
-            } else {
-                QWindowsStyle::drawControl(element, option, painter, widget);
-            }
-
-            painter->restore();
-        }
-        break;
-#endif
-    default:
-        QWindowsStyle::drawControl(element, option, painter, widget);
-        break;
-    }
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
-                                         QPainter *painter, const QWidget *widget) const
-{
-    QColor borderColor = option->palette.background().color().darker(178);
-    QColor alphaCornerColor;
-   if (widget) {
-        // ### backgroundrole/foregroundrole should be part of the style option
-        alphaCornerColor = mergedColors(option->palette.color(widget->backgroundRole()), borderColor);
-    } else {
-        alphaCornerColor = mergedColors(option->palette.background().color(), borderColor);
-    }
-    QColor gradientStartColor = option->palette.button().color().lighter(104);
-    QColor gradientStopColor = option->palette.button().color().darker(105);
-
-    switch (control) {
-#ifndef QT_NO_SLIDER
-    case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect grooveRegion = proxy()->subControlRect(CC_Slider, option, SC_SliderGroove, widget);
-            QRect handle = proxy()->subControlRect(CC_Slider, option, SC_SliderHandle, widget);
-            bool horizontal = slider->orientation == Qt::Horizontal;
-            bool ticksAbove = slider->tickPosition & QSlider::TicksAbove;
-            bool ticksBelow = slider->tickPosition & QSlider::TicksBelow;
-
-            QRect groove;
-            //The clickable region is 5 px wider than the visible groove for improved usability
-            if (grooveRegion.isValid())
-                groove = horizontal ? grooveRegion.adjusted(0, 5, 0, -5) : grooveRegion.adjusted(5, 0, -5, 0);
-
-
-            QPixmap cache;
-
-            if ((option->subControls & SC_SliderGroove) && groove.isValid()) {
-                BEGIN_STYLE_PIXMAPCACHE(QString::fromLatin1("slider_groove-%0-%1").arg(ticksAbove).arg(ticksBelow))
-                p->fillRect(groove, option->palette.background());
-
-                rect = groove;
-                rect.moveTo(groove.left() - option->rect.left(), groove.top() - option->rect.top());
-
-                // draw groove
-                if (horizontal) {
-                    p->setPen(borderColor);
-                    const QLine lines[4] = {
-                        QLine(rect.left() + 1, rect.top(),
-                              rect.right() - 1, rect.top()),
-                        QLine(rect.left() + 1, rect.bottom(),
-                              rect.right() - 1, rect.bottom()),
-                        QLine(rect.left(), rect.top() + 1,
-                              rect.left(), rect.bottom() - 1),
-                        QLine(rect.right(), rect.top() + 1,
-                              rect.right(), rect.bottom() - 1) };
-                    p->drawLines(lines, 4);
-
-                    p->setPen(alphaCornerColor);
-                    const QPoint points[4] = {
-                        QPoint(rect.left(), rect.top()),
-                        QPoint(rect.left(), rect.bottom()),
-                        QPoint(rect.right(), rect.top()),
-                        QPoint(rect.right(), rect.bottom()) };
-                    p->drawPoints(points, 4);
-                } else {
-                    p->setPen(borderColor);
-                    const QLine lines[4] = {
-                        QLine(rect.left() + 1, rect.top(),
-                              rect.right() - 1, rect.top()),
-                        QLine(rect.left() + 1, rect.bottom(),
-                              rect.right() - 1, rect.bottom()),
-                        QLine(rect.left(), rect.top() + 1,
-                              rect.left(), rect.bottom() - 1),
-                        QLine(rect.right(), rect.top() + 1,
-                              rect.right(), rect.bottom() - 1) };
-                    p->drawLines(lines, 4);
-
-                    p->setPen(alphaCornerColor);
-                    const QPoint points[4] = {
-                        QPoint(rect.left(), rect.top()),
-                        QPoint(rect.right(), rect.top()),
-                        QPoint(rect.left(), rect.bottom()),
-                        QPoint(rect.right(), rect.bottom()) };
-                    p->drawPoints(points, 4);
-                }
-                END_STYLE_PIXMAPCACHE
-            }
-
-            if ((option->subControls & SC_SliderHandle) && handle.isValid()) {
-                QString handlePixmapName = QStyleHelper::uniqueName(QLatin1String("slider_handle"), option, handle.size());
-                if (ticksAbove && !ticksBelow)
-                    handlePixmapName += QLatin1String("-flipped");
-                if ((option->activeSubControls & SC_SliderHandle) && (option->state & State_Sunken))
-                    handlePixmapName += QLatin1String("-sunken");
-
-                if (!QPixmapCache::find(handlePixmapName, cache)) {
-                    cache = QPixmap(handle.size());
-                    cache.fill(Qt::transparent);
-                    QRect pixmapRect(0, 0, handle.width(), handle.height());
-                    QPainter handlePainter(&cache);
-
-                    // draw handle
-                    if (horizontal) {
-                        QPainterPath path;
-                        if (ticksAbove && !ticksBelow) {
-                            path.moveTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom() - 10));
-                            path.lineTo(QPoint(pixmapRect.right() - 5, pixmapRect.bottom() - 14));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom() - 10));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
-                        } else {
-                            path.moveTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 10));
-                            path.lineTo(QPoint(pixmapRect.right() - 5, pixmapRect.top() + 14));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 10));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                        }
-                        if (slider->state & State_Enabled) {
-                            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                                     pixmapRect.center().x(), pixmapRect.bottom());
-                            if ((option->activeSubControls & SC_SliderHandle) && (option->state & State_Sunken)) {
-                                gradient.setColorAt(0, gradientStartColor.lighter(110));
-                                gradient.setColorAt(1, gradientStopColor.lighter(110));
-                            } else {
-                                gradient.setColorAt(0, gradientStartColor);
-                                gradient.setColorAt(1, gradientStopColor);
-                            }
-                            handlePainter.fillPath(path, gradient);
-                        } else {
-                            handlePainter.fillPath(path, slider->palette.background());
-                        }
-                    } else {
-                        QPainterPath path;
-                        if (ticksAbove && !ticksBelow) {
-                            path.moveTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right() - 10, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.right() - 14, pixmapRect.top() + 5));
-                            path.lineTo(QPoint(pixmapRect.right() - 10, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.right(), pixmapRect.top() + 1));
-                        } else {
-                            path.moveTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.left() + 10, pixmapRect.top() + 1));
-                            path.lineTo(QPoint(pixmapRect.left() + 14, pixmapRect.top() + 5));
-                            path.lineTo(QPoint(pixmapRect.left() + 10, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.bottom()));
-                            path.lineTo(QPoint(pixmapRect.left() + 1, pixmapRect.top() + 1));
-                        }
-                        if (slider->state & State_Enabled) {
-                            QLinearGradient gradient(pixmapRect.center().x(), pixmapRect.top(),
-                                                     pixmapRect.center().x(), pixmapRect.bottom());
-                            gradient.setColorAt(0, gradientStartColor);
-                            gradient.setColorAt(1, gradientStopColor);
-                            handlePainter.fillPath(path, gradient);
-                        } else {
-                            handlePainter.fillPath(path, slider->palette.background());
-                        }
-                    }
-
-                    QImage image;
-                    if (horizontal) {
-                        image = QImage((ticksAbove && !ticksBelow) ? qt_plastique_slider_horizontalhandle_up : qt_plastique_slider_horizontalhandle);
-                    } else {
-                        image = QImage((ticksAbove && !ticksBelow) ? qt_plastique_slider_verticalhandle_left : qt_plastique_slider_verticalhandle);
-                    }
-
-                    image.setColor(1, borderColor.rgba());
-                    image.setColor(2, gradientStartColor.rgba());
-                    image.setColor(3, alphaCornerColor.rgba());
-                    if (option->state & State_Enabled) {
-                        image.setColor(4, 0x80ffffff);
-                        image.setColor(5, 0x25000000);
-                    }
-                    handlePainter.drawImage(pixmapRect, image);
-                    handlePainter.end();
-                    QPixmapCache::insert(handlePixmapName, cache);
-                }
-
-                painter->drawPixmap(handle.topLeft(), cache);
-
-                if (slider->state & State_HasFocus) {
-                    QStyleOptionFocusRect fropt;
-                    fropt.QStyleOption::operator=(*slider);
-                    fropt.rect = subElementRect(SE_SliderFocusRect, slider, widget);
-                    proxy()->drawPrimitive(PE_FrameFocusRect, &fropt, painter, widget);
-                }
-            }
-
-            if (option->subControls & SC_SliderTickmarks) {
-                QPen oldPen = painter->pen();
-                painter->setPen(borderColor);
-                int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-                int available = proxy()->pixelMetric(PM_SliderSpaceAvailable, slider, widget);
-                int interval = slider->tickInterval;
-                if (interval <= 0) {
-                    interval = slider->singleStep;
-                    if (QStyle::sliderPositionFromValue(slider->minimum, slider->maximum, interval,
-                                                        available)
-                        - QStyle::sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                          0, available) < 3)
-                        interval = slider->pageStep;
-                }
-                if (interval <= 0)
-                    interval = 1;
-
-                int v = slider->minimum;
-                int len = proxy()->pixelMetric(PM_SliderLength, slider, widget);
-                QVarLengthArray<QLine, 32> lines;
-                while (v <= slider->maximum + 1) {
-                    if (v == slider->maximum + 1 && interval == 1)
-                        break;
-                    const int v_ = qMin(v, slider->maximum);
-                    int pos = sliderPositionFromValue(slider->minimum, slider->maximum,
-                                                      v_, (horizontal
-                                                          ? slider->rect.width()
-                                                          : slider->rect.height()) - len,
-                                                      slider->upsideDown) + len / 2;
-
-                    int extra = 2 - ((v_ == slider->minimum || v_ == slider->maximum) ? 1 : 0);
-
-                    if (horizontal) {
-                        if (ticksAbove) {
-                            lines.append(QLine(pos, slider->rect.top() + extra,
-                                               pos, slider->rect.top() + tickSize));
-                        }
-                        if (ticksBelow) {
-                            lines.append(QLine(pos, slider->rect.bottom() - extra,
-                                               pos, slider->rect.bottom() - tickSize));
-                        }
-                    } else {
-                        if (ticksAbove) {
-                            lines.append(QLine(slider->rect.left() + extra, pos,
-                                               slider->rect.left() + tickSize, pos));
-                        }
-                        if (ticksBelow) {
-                            lines.append(QLine(slider->rect.right() - extra, pos,
-                                               slider->rect.right() - tickSize, pos));
-                        }
-                    }
-
-                    // in the case where maximum is max int
-                    int nextInterval = v + interval;
-                    if (nextInterval < v)
-                        break;
-                    v = nextInterval;
-                }
-                painter->drawLines(lines.constData(), lines.size());
-                painter->setPen(oldPen);
-            }
-        }
-        break;
-#endif // QT_NO_SLIDER
-#ifndef QT_NO_SPINBOX
-    case CC_SpinBox:
-        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
-            painter->save();
-            bool upSunken = (spinBox->activeSubControls & SC_SpinBoxUp) && (spinBox->state & (State_Sunken | State_On));
-            bool downSunken = (spinBox->activeSubControls & SC_SpinBoxDown) && (spinBox->state & (State_Sunken | State_On));
-            bool reverse = (spinBox->direction == Qt::RightToLeft);
-
-            // Rects
-            QRect upRect = proxy()->subControlRect(CC_SpinBox, option, SC_SpinBoxUp, widget);
-            QRect downRect = proxy()->subControlRect(CC_SpinBox, option, SC_SpinBoxDown, widget);
-            QRect buttonRect = upRect | downRect;
-
-            // Brushes
-            QBrush corner = qMapBrushToRect(option->palette.shadow(), buttonRect);
-            qBrushSetAlphaF(&corner, qreal(0.25));
-            QBrush border = qMapBrushToRect(option->palette.shadow(), buttonRect);
-            qBrushSetAlphaF(&border, qreal(0.4));
-
-            QVarLengthArray<QPoint, 4> points;
-
-            Q_D(const QPlastiqueStyle);
-            if (spinBox->buttonSymbols == QAbstractSpinBox::NoButtons) {
-                QRect filledRect = option->rect.adjusted(1, 1, -1, -1);
-                QBrush baseBrush = qMapBrushToRect(option->palette.base(), filledRect);
-                painter->setBrushOrigin(filledRect.topLeft());
-                painter->fillRect(filledRect.adjusted(1, 1, -1, -1), baseBrush);
-                qt_plastique_draw_frame(painter, option->rect, option, QFrame::Sunken);        
-            } else {
-                d->drawPartialFrame(painter,
-                                    option,
-                                    proxy()->subControlRect(CC_SpinBox, spinBox, SC_SpinBoxEditField, widget),
-                                    widget);
-            }
-            // Paint buttons
-            if (spinBox->buttonSymbols == QAbstractSpinBox::NoButtons) {
-                painter->restore();
-                break;
-            }
-            // Button outlines
-            painter->setPen(QPen(border, 0));
-            if (!reverse)
-                painter->drawLine(buttonRect.topLeft() + QPoint(0, 1), buttonRect.bottomLeft() + QPoint(0, -1));
-            else
-                painter->drawLine(buttonRect.topRight() + QPoint(0, -1), buttonRect.bottomRight() + QPoint(0, 1));
-
-            if (!reverse) {
-                const QLine lines[4] = {
-                    QLine(upRect.left(), upRect.top(), upRect.right() - 2, upRect.top()),
-                    QLine(upRect.left() + 1, upRect.bottom(), upRect.right() - 1, upRect.bottom()),
-                    QLine(downRect.left(), downRect.bottom(), downRect.right() - 2, downRect.bottom()),
-                    QLine(buttonRect.right(), buttonRect.top() + 2, buttonRect.right(), buttonRect.bottom() - 2) };
-                painter->drawLines(lines, 4);
-
-                points.append(QPoint(upRect.right() - 1, upRect.top() + 1));
-                points.append(QPoint(downRect.right() - 1, downRect.bottom() - 1));
-                painter->drawPoints(points.constData(), points.size());
-                points.clear();
-                painter->setPen(QPen(corner, 0));
-                points.append(QPoint(upRect.right() - 1, upRect.top()));
-                points.append(QPoint(upRect.right(), upRect.top() + 1));
-                points.append(QPoint(upRect.right(), downRect.bottom() - 1));
-                points.append(QPoint(upRect.right() - 1, downRect.bottom()));
-            } else {
-                const QLine lines[4] = {
-                    QLine(upRect.right(), upRect.top(), upRect.left() + 2, upRect.top()),
-                    QLine(upRect.right() - 1, upRect.bottom(), upRect.left() + 1, upRect.bottom()),
-                    QLine(downRect.right(), downRect.bottom(), downRect.left() + 2, downRect.bottom()),
-                    QLine(buttonRect.left(), buttonRect.top() + 2, buttonRect.left(), buttonRect.bottom() - 2) };
-                painter->drawLines(lines, 4);
-
-                points.append(QPoint(upRect.left() + 1, upRect.top() + 1));
-                points.append(QPoint(downRect.left() + 1, downRect.bottom() - 1));
-                painter->drawPoints(points.constData(), points.size());
-                points.clear();
-                painter->setPen(QPen(corner, 0));
-                points.append(QPoint(upRect.left() + 1, upRect.top()));
-                points.append(QPoint(upRect.left(), upRect.top() + 1));
-                points.append(QPoint(upRect.left(), downRect.bottom() - 1));
-                points.append(QPoint(upRect.left() + 1, downRect.bottom()));
-            }
-            painter->drawPoints(points.constData(), points.size());
-            points.clear();
-
-            // Button colors
-            QBrush buttonGradientBrush;
-            QBrush leftLineGradientBrush;
-            QBrush rightLineGradientBrush;
-            QBrush sunkenButtonGradientBrush;
-            QBrush sunkenLeftLineGradientBrush;
-            QBrush sunkenRightLineGradientBrush;
-            QBrush buttonBrush = qMapBrushToRect(option->palette.button(), buttonRect);
-            if (buttonBrush.gradient() || !buttonBrush.texture().isNull()) {
-                buttonGradientBrush = buttonBrush;
-                sunkenButtonGradientBrush = qBrushDark(buttonBrush, 108);
-                leftLineGradientBrush = qBrushLight(buttonBrush, 105);
-                rightLineGradientBrush = qBrushDark(buttonBrush, 105);
-                sunkenLeftLineGradientBrush = qBrushDark(buttonBrush, 110);
-                sunkenRightLineGradientBrush = qBrushDark(buttonBrush, 106);
-            } else {
-                // Generate gradients
-                QLinearGradient buttonGradient(buttonRect.topLeft(), buttonRect.bottomLeft());
-                buttonGradient.setColorAt(0.0, buttonBrush.color().lighter(104));
-                buttonGradient.setColorAt(1.0, buttonBrush.color().darker(110));
-                buttonGradientBrush = QBrush(buttonGradient);
-
-                QLinearGradient buttonGradient2(buttonRect.topLeft(), buttonRect.bottomLeft());
-                buttonGradient2.setColorAt(0.0, buttonBrush.color().darker(113));
-               buttonGradient2.setColorAt(1.0, buttonBrush.color().darker(103));
-                sunkenButtonGradientBrush = QBrush(buttonGradient2);
-
-                QLinearGradient buttonGradient3(buttonRect.topLeft(), buttonRect.bottomLeft());
-                buttonGradient3.setColorAt(0.0, buttonBrush.color().lighter(105));
-                buttonGradient3.setColorAt(1.0, buttonBrush.color());
-                leftLineGradientBrush = QBrush(buttonGradient3);
-
-                QLinearGradient buttonGradient4(buttonRect.topLeft(), buttonRect.bottomLeft());
-                buttonGradient4.setColorAt(0.0, buttonBrush.color());
-                buttonGradient4.setColorAt(1.0, buttonBrush.color().darker(110));
-                rightLineGradientBrush = QBrush(buttonGradient4);
-
-                QLinearGradient buttonGradient5(buttonRect.topLeft(), buttonRect.bottomLeft());
-                buttonGradient5.setColorAt(0.0, buttonBrush.color().darker(113));
-                buttonGradient5.setColorAt(1.0, buttonBrush.color().darker(107));
-                sunkenLeftLineGradientBrush = QBrush(buttonGradient5);
-
-                QLinearGradient buttonGradient6(buttonRect.topLeft(), buttonRect.bottomLeft());
-                buttonGradient6.setColorAt(0.0, buttonBrush.color().darker(108));
-                buttonGradient6.setColorAt(1.0, buttonBrush.color().darker(103));
-                sunkenRightLineGradientBrush = QBrush(buttonGradient6);
-            }
-
-            // Main fill
-            painter->fillRect(upRect.adjusted(2, 2, -2, -2),
-                              qMapBrushToRect(upSunken ? sunkenButtonGradientBrush
-                                              : buttonGradientBrush, upRect));
-            painter->fillRect(downRect.adjusted(2, 2, -2, -2),
-                              qMapBrushToRect(downSunken ? sunkenButtonGradientBrush
-                                              : buttonGradientBrush, downRect));
-
-            // Top line
-            painter->setPen(QPen(qBrushLight(qMapBrushToRect(upSunken ? sunkenButtonGradientBrush
-                                                             : buttonGradientBrush, upRect), 105), 0));
-            if (!reverse) {
-                painter->drawLine(upRect.left() + 1, upRect.top() + 1,
-                                  upRect.right() - 2, upRect.top() + 1);
-            } else {
-                painter->drawLine(upRect.right() - 1, upRect.top() + 1,
-                                  upRect.left() + 2, upRect.top() + 1);
-            }
-            painter->setPen(QPen(qBrushLight(qMapBrushToRect(downSunken ? sunkenButtonGradientBrush
-                                                             : buttonGradientBrush, downRect), 105), 0));
-            if (!reverse) {
-                painter->drawLine(downRect.left() + 1, downRect.top() + 1,
-                                  downRect.right() - 1, downRect.top() + 1);
-            } else {
-                painter->drawLine(downRect.right() - 1, downRect.top() + 1,
-                                  downRect.left() + 1, downRect.top() + 1);
-            }
-
-            // Left line
-            painter->setPen(QPen(qMapBrushToRect(upSunken ? sunkenLeftLineGradientBrush
-                                                 : leftLineGradientBrush, upRect), 1));
-            if (!reverse) {
-                painter->drawLine(upRect.left() + 1, upRect.top() + 2,
-                                  upRect.left() + 1, upRect.bottom() - 1);
-            } else {
-                painter->drawLine(upRect.left() + 1, upRect.top() + 2,
-                                  upRect.left() + 1, upRect.bottom() - 1);
-            }
-            painter->setPen(QPen(qMapBrushToRect(downSunken ? sunkenLeftLineGradientBrush
-                                                 : leftLineGradientBrush, downRect), 1));
-            if (!reverse) {
-                painter->drawLine(downRect.left() + 1, downRect.top() + 2,
-                                  downRect.left() + 1, downRect.bottom() - 1);
-            } else {
-                painter->drawLine(downRect.left() + 1, downRect.top() + 1,
-                                  downRect.left() + 1, downRect.bottom() - 2);
-            }
-
-            // Bottom line
-            painter->setPen(QPen(qBrushDark(qMapBrushToRect(upSunken ? sunkenButtonGradientBrush
-                                                            : buttonGradientBrush, upRect), 105), 0));
-            if (!reverse) {
-                painter->drawLine(upRect.left() + 2, upRect.bottom() - 1,
-                                  upRect.right() - 1, upRect.bottom() - 1);
-            } else {
-                painter->drawLine(upRect.right() - 2, upRect.bottom() - 1,
-                                  upRect.left() + 1, upRect.bottom() - 1);
-            }
-            painter->setPen(QPen(qBrushDark(qMapBrushToRect(downSunken ? sunkenButtonGradientBrush
-                                                            : buttonGradientBrush, downRect), 105), 0));
-            if (!reverse) {
-                painter->drawLine(downRect.left() + 2, downRect.bottom() - 1,
-                                  downRect.right() - 2, downRect.bottom() - 1);
-            } else {
-                painter->drawLine(downRect.right() - 2, downRect.bottom() - 1,
-                                  downRect.left() + 2, downRect.bottom() - 1);
-            }
-
-            // Right line
-            painter->setPen(QPen(qMapBrushToRect(upSunken ? sunkenRightLineGradientBrush
-                                                 : rightLineGradientBrush, upRect), 1));
-            if (!reverse) {
-                painter->drawLine(upRect.right() - 1, upRect.top() + 2,
-                                  upRect.right() - 1, upRect.bottom() - 1);
-            } else {
-                painter->drawLine(upRect.right() - 1, upRect.top() + 2,
-                                  upRect.right() - 1, upRect.bottom() - 1);
-            }
-            painter->setPen(QPen(qMapBrushToRect(downSunken ? sunkenRightLineGradientBrush
-                                                 : rightLineGradientBrush, downRect), 1));
-            if (!reverse) {
-                painter->drawLine(downRect.right() - 1, downRect.top() + 1,
-                                  downRect.right() - 1, downRect.bottom() - 2);
-            } else {
-                painter->drawLine(downRect.right() - 1, downRect.top() + 2,
-                                  downRect.right() - 1, downRect.bottom() - 1);
-            }
-
-            QBrush indicatorBrush = qMapBrushToRect(option->palette.buttonText(), buttonRect);
-            painter->setPen(QPen(indicatorBrush, 0));
-            if (spinBox->buttonSymbols == QAbstractSpinBox::PlusMinus) {
-                QPoint center;
-                if (spinBox->subControls & SC_SpinBoxUp) {
-                    // .......
-                    // ...X...
-                    // ...X...
-                    // .XXXXX.
-                    // ...X...
-                    // ...X...
-                    // .......
-                    center = upRect.center();
-                    if (upSunken) {
-                        ++center.rx();
-                        ++center.ry();
-                    }
-                    painter->drawLine(center.x(), center.y() - 2, center.x(), center.y() + 2);
-                    painter->drawLine(center.x() - 2, center.y(), center.x() + 2, center.y());
-                }
-                if (spinBox->subControls & SC_SpinBoxDown) {
-                    // .......
-                    // .......
-                    // .......
-                    // .XXXXX.
-                    // .......
-                    // .......
-                    // .......
-                    center = downRect.center();
-                    if (downSunken) {
-                        ++center.rx();
-                        ++center.ry();
-                    }
-                    painter->drawLine(center.x() - 2, center.y(), center.x() + 2, center.y());
-                }
-            } else {
-                int offset;
-                int centerX;
-                if (spinBox->subControls & SC_SpinBoxUp) {
-                    // ...........
-                    // .....X.....
-                    // ....XXX....
-                    // ...XXXXX...
-                    // ..XXXXXXX..
-                    // ...........
-                    offset = upSunken ? 1 : 0;
-                    QRect upArrowRect(upRect.center().x() - 3 + offset, upRect.center().y() - 2 + offset, 7, 4);
-                    centerX = upArrowRect.center().x();
-                    painter->drawPoint(centerX, upArrowRect.top());
-                    const QLine lines[3] = {
-                        QLine(centerX - 1, upArrowRect.top() + 1, centerX + 1, upArrowRect.top() + 1),
-                        QLine(centerX - 2, upArrowRect.top() + 2, centerX + 2, upArrowRect.top() + 2),
-                        QLine(centerX - 3, upArrowRect.top() + 3, centerX + 3, upArrowRect.top() + 3) };
-                    painter->drawLines(lines, 3);
-                }
-                if (spinBox->subControls & SC_SpinBoxDown) {
-                    // ...........
-                    // ..XXXXXXX..
-                    // ...XXXXX...
-                    // ....XXX....
-                    // .....X.....
-                    // ...........
-                    offset = downSunken ? 1 : 0;
-                    QRect downArrowRect(downRect.center().x() - 3 + offset, downRect.center().y() - 2 + offset + 1, 7, 4);
-                    centerX = downArrowRect.center().x();
-                    const QLine lines[3] = {
-                        QLine(centerX - 3, downArrowRect.top(), centerX + 3, downArrowRect.top()),
-                        QLine(centerX - 2, downArrowRect.top() + 1, centerX + 2, downArrowRect.top() + 1),
-                        QLine(centerX - 1, downArrowRect.top() + 2, centerX + 1, downArrowRect.top() + 2) };
-                    painter->drawLines(lines, 3);
-                    painter->drawPoint(centerX, downArrowRect.top() + 3);
-                }
-            }
-            painter->restore();
-        }
-        break;
-#endif // QT_NO_SPINBOX
-#ifndef QT_NO_COMBOBOX
-    case CC_ComboBox:
-        if (const QStyleOptionComboBox *comboBox = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
-            bool sunken = comboBox->state & State_On; // play dead if combobox has no items
-            bool reverse = comboBox->direction == Qt::RightToLeft;
-            int menuButtonWidth = 16;
-            int xoffset = sunken ? (reverse ? -1 : 1) : 0;
-            int yoffset = sunken ? 1 : 0;
-            QRect rect = comboBox->rect;
-            QPen oldPen = painter->pen();
-
-            // Fill
-            if (comboBox->editable) {
-                // Button colors
-                QBrush alphaCornerBrush = qBrushDark(option->palette.button(), 165);
-                qBrushSetAlphaF(&alphaCornerBrush, 0.5);
-                QBrush buttonGradientBrush;
-                QBrush leftLineGradientBrush;
-                QBrush rightLineGradientBrush;
-                QBrush sunkenButtonGradientBrush;
-                QBrush sunkenLeftLineGradientBrush;
-                QBrush sunkenRightLineGradientBrush;
-                QBrush button = option->palette.button();
-                if (button.gradient() || !button.texture().isNull()) {
-                    buttonGradientBrush = button;
-                    sunkenButtonGradientBrush = qBrushDark(button, 108);
-                    leftLineGradientBrush = qBrushLight(button, 105);
-                    rightLineGradientBrush = qBrushDark(button, 105);
-                    sunkenLeftLineGradientBrush = qBrushDark(button, 110);
-                    sunkenRightLineGradientBrush = qBrushDark(button, 106);
-                } else {
-                    // Generate gradients
-                    QLinearGradient buttonGradient(option->rect.topLeft(), option->rect.bottomLeft());
-                    buttonGradient.setColorAt(0.0, button.color().lighter(104));
-                    buttonGradient.setColorAt(1.0, button.color().darker(110));
-                    buttonGradientBrush = QBrush(buttonGradient);
-
-                    QLinearGradient buttonGradient2(option->rect.topLeft(), option->rect.bottomLeft());
-                    buttonGradient2.setColorAt(0.0, button.color().darker(113));
-                    buttonGradient2.setColorAt(1.0, button.color().darker(103));
-                    sunkenButtonGradientBrush = QBrush(buttonGradient2);
-
-                    QLinearGradient buttonGradient3(option->rect.topLeft(), option->rect.bottomLeft());
-                    buttonGradient3.setColorAt(0.0, button.color().lighter(105));
-                    buttonGradient3.setColorAt(1.0, button.color());
-                    leftLineGradientBrush = QBrush(buttonGradient3);
-
-                    QLinearGradient buttonGradient4(option->rect.topLeft(), option->rect.bottomLeft());
-                    buttonGradient4.setColorAt(0.0, button.color());
-                    buttonGradient4.setColorAt(1.0, button.color().darker(110));
-                    rightLineGradientBrush = QBrush(buttonGradient4);
-
-                    QLinearGradient buttonGradient5(option->rect.topLeft(), option->rect.bottomLeft());
-                    buttonGradient5.setColorAt(0.0, button.color().darker(113));
-                    buttonGradient5.setColorAt(1.0, button.color().darker(107));
-                    sunkenLeftLineGradientBrush = QBrush(buttonGradient5);
-
-                    QLinearGradient buttonGradient6(option->rect.topLeft(), option->rect.bottomLeft());
-                    buttonGradient6.setColorAt(0.0, button.color().darker(108));
-                    buttonGradient6.setColorAt(1.0, button.color().darker(103));
-                    sunkenRightLineGradientBrush = QBrush(buttonGradient6);
-                }
-
-                // ComboBox starts with a lineedit in place already.
-                QRect buttonRect;
-                if (!reverse) {
-                    buttonRect.setRect(rect.right() - menuButtonWidth, rect.top(), menuButtonWidth + 1, rect.height());
-                } else {
-                    buttonRect.setRect(rect.left(), rect.top(), menuButtonWidth + 1, rect.height());
-                }
-
-                Q_D(const QPlastiqueStyle);
-                d->drawPartialFrame(painter,
-                                option,
-                                proxy()->subControlRect(CC_ComboBox, option, SC_ComboBoxEditField, widget),
-                                widget);
-
-                QBrush border = qMapBrushToRect(option->palette.shadow(), buttonRect);
-                qBrushSetAlphaF(&border, qreal(0.4));
-                painter->setPen(QPen(border, 0));
-                if (!reverse)
-                    painter->drawLine(buttonRect.topLeft() + QPoint(0, 1), buttonRect.bottomLeft() + QPoint(0, -1));
-                else
-                    painter->drawLine(buttonRect.topRight() + QPoint(0, -1), buttonRect.bottomRight() + QPoint(0, 1));
-
-                // Outline the button border
-                if (!reverse) {
-                    const QLine lines[3] = {
-                        QLine(buttonRect.left(), buttonRect.top(),
-                              buttonRect.right() - 2, buttonRect.top()),
-                        QLine(buttonRect.right(), buttonRect.top() + 2,
-                              buttonRect.right(), buttonRect.bottom() - 2),
-                        QLine(buttonRect.left(), buttonRect.bottom(),
-                              buttonRect.right() - 2, buttonRect.bottom()) };
-                    painter->drawLines(lines, 3);
-                    {
-                        const QPoint points[2] = {
-                            QPoint(buttonRect.right() - 1, buttonRect.top() + 1),
-                            QPoint(buttonRect.right() - 1, buttonRect.bottom() - 1) };
-                        painter->drawPoints(points, 2);
-                    }
-
-                    QBrush corner = qMapBrushToRect(option->palette.shadow(), buttonRect);
-                    qBrushSetAlphaF(&corner, qreal(0.16));
-                    painter->setPen(QPen(corner, 0));
-                    {
-                        const QPoint points[4] = {
-                            QPoint(buttonRect.right() - 1, buttonRect.top()),
-                            QPoint(buttonRect.right() - 1, buttonRect.bottom()),
-                            QPoint(buttonRect.right(), buttonRect.top() + 1),
-                            QPoint(buttonRect.right(), buttonRect.bottom() - 1) };
-                        painter->drawPoints(points, 4);
-                    }
-                } else {
-                    const QLine lines[3] = {
-                        QLine(buttonRect.right(), buttonRect.top(),
-                              buttonRect.left() + 2, buttonRect.top()),
-                        QLine(buttonRect.left(), buttonRect.top() + 2,
-                              buttonRect.left(), buttonRect.bottom() - 2),
-                        QLine(buttonRect.right(), buttonRect.bottom(),
-                              buttonRect.left() + 2, buttonRect.bottom()) };
-                    painter->drawLines(lines, 3);
-                    {
-                        const QPoint points[2] = {
-                            QPoint(buttonRect.left() + 1, buttonRect.top() + 1),
-                            QPoint(buttonRect.left() + 1, buttonRect.bottom() - 1) };
-                        painter->drawPoints(points, 2);
-                    }
-
-                    QBrush corner = qMapBrushToRect(option->palette.shadow(), buttonRect);
-                    qBrushSetAlphaF(&corner, qreal(0.16));
-                    painter->setPen(QPen(corner, 0));
-                    {
-                        const QPoint points[4] = {
-                            QPoint(buttonRect.left() + 1, buttonRect.top()),
-                            QPoint(buttonRect.left() + 1, buttonRect.bottom()),
-                            QPoint(buttonRect.left(), buttonRect.top() + 1),
-                            QPoint(buttonRect.left(), buttonRect.bottom() - 1) };
-                        painter->drawPoints(points, 4);
-                    }
-                }
-
-                QRect fillRect = buttonRect.adjusted(2, 2, -2, -2);
-                // Main fill
-                painter->fillRect(fillRect,
-                                  qMapBrushToRect(sunken ? sunkenButtonGradientBrush
-                                                  : buttonGradientBrush, option->rect));
-
-                // Top line
-                painter->setPen(QPen(qBrushLight(qMapBrushToRect(sunken ? sunkenButtonGradientBrush
-                                                                 : buttonGradientBrush, option->rect), 105), 0));
-                if (!reverse) {
-                    painter->drawLine(QPointF(buttonRect.left() + 1, buttonRect.top() + 1),
-                                      QPointF(buttonRect.right() - 2, buttonRect.top() + 1));
-                } else {
-                    painter->drawLine(QPointF(buttonRect.right() - 1, buttonRect.top() + 1),
-                                      QPointF(buttonRect.left() + 2, buttonRect.top() + 1));
-                }
-
-                // Bottom line
-                painter->setPen(QPen(qBrushDark(qMapBrushToRect(sunken ? sunkenButtonGradientBrush
-                                                                : buttonGradientBrush, option->rect), 105), 0));
-                if (!reverse) {
-                    painter->drawLine(QPointF(buttonRect.left() + 1, buttonRect.bottom() - 1),
-                                      QPointF(buttonRect.right() - 2, buttonRect.bottom() - 1));
-                } else {
-                    painter->drawLine(QPointF(buttonRect.right() - 1, buttonRect.bottom() - 1),
-                                      QPointF(buttonRect.left() + 2, buttonRect.bottom() - 1));
-                }
-
-                // Left line
-                painter->setPen(QPen(qMapBrushToRect(sunken ? sunkenLeftLineGradientBrush
-                                                     : leftLineGradientBrush, option->rect), 1));
-                if (!reverse) {
-                    painter->drawLine(QPointF(buttonRect.left() + 1, buttonRect.top() + 2),
-                                      QPointF(buttonRect.left() + 1, buttonRect.bottom() - 2));
-                } else {
-                    painter->drawLine(QPointF(buttonRect.left() + 1, buttonRect.top() + 2),
-                                      QPointF(buttonRect.left() + 1, buttonRect.bottom() - 2));
-                }
-
-                // Right line
-                painter->setPen(QPen(qMapBrushToRect(sunken ? sunkenRightLineGradientBrush
-                                                     : rightLineGradientBrush, option->rect), 1));
-                if (!reverse) {
-                    painter->drawLine(QPointF(buttonRect.right() - 1, buttonRect.top() + 2),
-                                      QPointF(buttonRect.right() - 1, buttonRect.bottom() - 2));
-                } else {
-                    painter->drawLine(QPointF(buttonRect.right() - 1, buttonRect.top() + 2),
-                                      QPointF(buttonRect.right() - 1, buttonRect.bottom() - 2));
-                }
-            } else {
-                // Start with a standard panel button fill
-                QStyleOptionButton buttonOption;
-                buttonOption.QStyleOption::operator=(*comboBox);
-                if (!sunken) {
-                    buttonOption.state &= ~State_Sunken;
-                }
-                proxy()->drawPrimitive(PE_PanelButtonCommand, &buttonOption, painter, widget);
-
-                // Draw the menu button separator line
-                QBrush border = qMapBrushToRect(option->palette.shadow(), rect);
-                qBrushSetAlphaF(&border, qreal(0.35));
-                painter->setPen(QPen(border, 0));
-                if (!reverse) {
-                    painter->drawLine(rect.right() - menuButtonWidth + xoffset, rect.top() + 1,
-                                      rect.right() - menuButtonWidth + xoffset, rect.bottom() - 1);
-                } else {
-                    painter->drawLine(rect.left() + menuButtonWidth + xoffset, rect.top() + 1,
-                                      rect.left() + menuButtonWidth + xoffset, rect.bottom() - 1);
-                }
-            }
-
-            // Draw the little arrow
-            if (comboBox->subControls & SC_ComboBoxArrow) {
-                int left = !reverse ? rect.right() - menuButtonWidth : rect.left();
-                int right = !reverse ? rect.right() : rect.left() + menuButtonWidth;
-                QRect arrowRect((left + right) / 2 - 3 + xoffset,
-                                rect.center().y() - 1 + yoffset, 7, 4);
-                painter->setPen(QPen(qMapBrushToRect(option->palette.buttonText(), rect), 0));
-                const QLine lines[3] = {
-                    QLine(arrowRect.topLeft(), arrowRect.topRight()),
-                    QLine(arrowRect.left() + 1, arrowRect.top() + 1,
-                          arrowRect.right() - 1, arrowRect.top() + 1),
-                    QLine(arrowRect.left() + 2, arrowRect.top() + 2,
-                          arrowRect.right() - 2, arrowRect.top() + 2) };
-                painter->drawLines(lines, 3);
-                painter->drawPoint(arrowRect.center().x(), arrowRect.bottom());
-            }
-
-            // Draw the focus rect
-            if ((option->state & State_HasFocus) && !comboBox->editable
-                && ((option->state & State_KeyboardFocusChange) || styleHint(SH_UnderlineShortcut, option, widget))) {
-                QStyleOptionFocusRect focus;
-                focus.rect = proxy()->subControlRect(CC_ComboBox, option, SC_ComboBoxEditField, widget)
-                             .adjusted(-2, 0, 2, 0);
-                proxy()->drawPrimitive(PE_FrameFocusRect, &focus, painter, widget);
-            }
-
-            painter->setPen(oldPen);
-        }
-        break;
-#endif // QT_NO_COMBOBOX
-    case CC_TitleBar:
-        if (const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
-            painter->save();
-            bool active = (titleBar->titleBarState & State_Active);
-            QRect fullRect = titleBar->rect;
-
-            // ### use palette colors instead
-            QColor titleBarGradientStart(active ? 0x3b508a : 0x6e6e6e);
-            QColor titleBarGradientStop(active ? 0x5d6e9e : 0x818181);
-            QColor titleBarFrameBorder(0x393939);
-            QColor titleBarAlphaCorner(active ? 0x4b5e7f : 0x6a6a6a);
-            QColor titleBarInnerTopLine(active ? 0x8e98ba : 0xa4a4a4);
-            QColor titleBarInnerInnerTopLine(active ? 0x57699b : 0x808080);
-            QColor leftCorner(active ? 0x6f7ea8 : 0x8e8e8e);
-            QColor rightCorner(active ? 0x44537d : 0x676767);
-            QColor textColor(active ? 0x282e40 : 0x282e40);
-            QColor textAlphaColor(active ? 0x3f4862 : 0x3f4862);
-
-
-            {
-                // Fill title bar gradient
-                qt_plastique_draw_gradient(painter, option->rect.adjusted(1, 1, -1, 0),
-                                           titleBarGradientStart,
-                                           titleBarGradientStop);
-
-                // Frame and rounded corners
-                painter->setPen(titleBarFrameBorder);
-
-                // top border line
-                {
-                    const QLine lines[3] = {
-                        QLine(fullRect.left() + 2, fullRect.top(), fullRect.right() - 2, fullRect.top()),
-                        QLine(fullRect.left(), fullRect.top() + 2, fullRect.left(), fullRect.bottom()),
-                        QLine(fullRect.right(), fullRect.top() + 2, fullRect.right(), fullRect.bottom()) };
-                    painter->drawLines(lines, 3);
-                    const QPoint points[2] = {
-                        QPoint(fullRect.left() + 1, fullRect.top() + 1),
-                        QPoint(fullRect.right() - 1, fullRect.top() + 1) };
-                    painter->drawPoints(points, 2);
-                }
-
-                // alpha corners
-                painter->setPen(titleBarAlphaCorner);
-                {
-                    const QPoint points[4] = {
-                        QPoint(fullRect.left() + 2, fullRect.top() + 1),
-                        QPoint(fullRect.left() + 1, fullRect.top() + 2),
-                        QPoint(fullRect.right() - 2, fullRect.top() + 1),
-                        QPoint(fullRect.right() - 1, fullRect.top() + 2) };
-                    painter->drawPoints(points, 4);
-                }
-
-                // inner top line
-                painter->setPen(titleBarInnerTopLine);
-                painter->drawLine(fullRect.left() + 3, fullRect.top() + 1, fullRect.right() - 3, fullRect.top() + 1);
-
-                // inner inner top line
-                painter->setPen(titleBarInnerInnerTopLine);
-                painter->drawLine(fullRect.left() + 2, fullRect.top() + 2, fullRect.right() - 2, fullRect.top() + 2);
-
-                // left and right inner
-                painter->setPen(leftCorner);
-                painter->drawLine(fullRect.left() + 1, fullRect.top() + 3, fullRect.left() + 1, fullRect.bottom());
-                painter->setPen(rightCorner);
-                painter->drawLine(fullRect.right() - 1, fullRect.top() + 3, fullRect.right() - 1, fullRect.bottom());
-
-                if (titleBar->titleBarState & Qt::WindowMinimized) {
-                    painter->setPen(titleBarFrameBorder);
-                    painter->drawLine(fullRect.left() + 2, fullRect.bottom(), fullRect.right() - 2, fullRect.bottom());
-                    {
-                        const QPoint points[2] = {
-                            QPoint(fullRect.left() + 1, fullRect.bottom() - 1),
-                            QPoint(fullRect.right() - 1, fullRect.bottom() - 1) };
-                        painter->drawPoints(points, 2);
-                    }
-                    painter->setPen(rightCorner);
-                    painter->drawLine(fullRect.left() + 2, fullRect.bottom() - 1, fullRect.right() - 2, fullRect.bottom() - 1);
-                    painter->setPen(titleBarAlphaCorner);
-                    {
-                        const QPoint points[4] = {
-                            QPoint(fullRect.left() + 1, fullRect.bottom() - 2),
-                            QPoint(fullRect.left() + 2, fullRect.bottom() - 1),
-                            QPoint(fullRect.right() - 1, fullRect.bottom() - 2),
-                            QPoint(fullRect.right() - 2, fullRect.bottom() - 1) };
-                        painter->drawPoints(points, 4);
-                    }
-                }
-                // draw title
-                QRect textRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarLabel, widget);
-
-                QFont font = painter->font();
-                font.setBold(true);
-                painter->setFont(font);
-                painter->setPen(titleBar->palette.text().color());
-
-                // Attempt to align left if there is not enough room for the title
-                // text. Otherwise, align center. QWorkspace does elliding for us,
-                // and it doesn't know about the bold title, so we need to work
-                // around some of the width mismatches.
-                bool tooWide = (QFontMetrics(font).width(titleBar->text) > textRect.width());
-                QTextOption option((tooWide ? Qt::AlignLeft : Qt::AlignHCenter) | Qt::AlignVCenter);
-                option.setWrapMode(QTextOption::NoWrap);
-
-                painter->drawText(textRect.adjusted(1, 1, 1, 1), titleBar->text, option);
-                painter->setPen(titleBar->palette.highlightedText().color());
-                painter->drawText(textRect, titleBar->text, option);
-            }
-
-            // min button
-            if ((titleBar->subControls & SC_TitleBarMinButton)
-                    && (titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint)
-                    && !(titleBar->titleBarState & Qt::WindowMinimized)) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarMinButton) && (titleBar->state & State_Sunken);
-
-                QRect minButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMinButton, widget);
-                qt_plastique_draw_mdibutton(painter, titleBar, minButtonRect, hover, sunken);
-
-                int xoffset = minButtonRect.width() / 3;
-                int yoffset = minButtonRect.height() / 3;
-
-                QRect minButtonIconRect(minButtonRect.left() + xoffset, minButtonRect.top() + yoffset,
-                                        minButtonRect.width() - xoffset * 2, minButtonRect.height() - yoffset * 2);
-
-                painter->setPen(textColor);
-                {
-                    const QLine lines[2] = {
-                        QLine(minButtonIconRect.center().x() - 2,
-                              minButtonIconRect.center().y() + 3,
-                              minButtonIconRect.center().x() + 3,
-                              minButtonIconRect.center().y() + 3),
-                        QLine(minButtonIconRect.center().x() - 2,
-                              minButtonIconRect.center().y() + 4,
-                              minButtonIconRect.center().x() + 3,
-                              minButtonIconRect.center().y() + 4) };
-                    painter->drawLines(lines, 2);
-                }
-                painter->setPen(textAlphaColor);
-                {
-                    const QLine lines[2] = {
-                        QLine(minButtonIconRect.center().x() - 3,
-                              minButtonIconRect.center().y() + 3,
-                              minButtonIconRect.center().x() - 3,
-                              minButtonIconRect.center().y() + 4),
-                        QLine(minButtonIconRect.center().x() + 4,
-                              minButtonIconRect.center().y() + 3,
-                              minButtonIconRect.center().x() + 4,
-                              minButtonIconRect.center().y() + 4) };
-                    painter->drawLines(lines, 2);
-                }
-            }
-
-            // max button
-            if ((titleBar->subControls & SC_TitleBarMaxButton)
-                    && (titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint)
-                    && !(titleBar->titleBarState & Qt::WindowMaximized)) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarMaxButton) && (titleBar->state & State_Sunken);
-
-                QRect maxButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarMaxButton, widget);
-                qt_plastique_draw_mdibutton(painter, titleBar, maxButtonRect, hover, sunken);
-
-                int xoffset = maxButtonRect.width() / 3;
-                int yoffset = maxButtonRect.height() / 3;
-
-                QRect maxButtonIconRect(maxButtonRect.left() + xoffset, maxButtonRect.top() + yoffset,
-                                        maxButtonRect.width() - xoffset * 2, maxButtonRect.height() - yoffset * 2);
-
-                painter->setPen(textColor);
-                painter->drawRect(maxButtonIconRect.adjusted(0, 0, -1, -1));
-                painter->drawLine(maxButtonIconRect.left() + 1, maxButtonIconRect.top() + 1,
-                                  maxButtonIconRect.right() - 1, maxButtonIconRect.top() + 1);
-                painter->setPen(textAlphaColor);
-                const QPoint points[4] = {
-                    maxButtonIconRect.topLeft(), maxButtonIconRect.topRight(),
-                    maxButtonIconRect.bottomLeft(), maxButtonIconRect.bottomRight() };
-                painter->drawPoints(points, 4);
-            }
-
-            // close button
-            if (titleBar->subControls & SC_TitleBarCloseButton && titleBar->titleBarFlags & Qt::WindowSystemMenuHint) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarCloseButton) && (titleBar->state & State_Sunken);
-
-                QRect closeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarCloseButton, widget);
-                qt_plastique_draw_mdibutton(painter, titleBar, closeButtonRect, hover, sunken);
-
-                int xoffset = closeButtonRect.width() / 3;
-                int yoffset = closeButtonRect.height() / 3;
-
-                QRect closeIconRect(closeButtonRect.left() + xoffset, closeButtonRect.top() + yoffset,
-                                    closeButtonRect.width() - xoffset * 2, closeButtonRect.height() - yoffset * 2);
-
-                painter->setPen(textAlphaColor);
-                {
-                    const QLine lines[4] = {
-                        QLine(closeIconRect.left() + 1, closeIconRect.top(),
-                              closeIconRect.right(), closeIconRect.bottom() - 1),
-                        QLine(closeIconRect.left(), closeIconRect.top() + 1,
-                              closeIconRect.right() - 1, closeIconRect.bottom()),
-                        QLine(closeIconRect.right() - 1, closeIconRect.top(),
-                              closeIconRect.left(), closeIconRect.bottom() - 1),
-                        QLine(closeIconRect.right(), closeIconRect.top() + 1,
-                              closeIconRect.left() + 1, closeIconRect.bottom()) };
-                    painter->drawLines(lines, 4);
-                    const QPoint points[4] = {
-                        closeIconRect.topLeft(), closeIconRect.topRight(),
-                        closeIconRect.bottomLeft(), closeIconRect.bottomRight() };
-                    painter->drawPoints(points, 4);
-                }
-                painter->setPen(textColor);
-                {
-                    const QLine lines[2] = {
-                        QLine(closeIconRect.left() + 1, closeIconRect.top() + 1,
-                              closeIconRect.right() - 1, closeIconRect.bottom() - 1),
-                        QLine(closeIconRect.left() + 1, closeIconRect.bottom() - 1,
-                              closeIconRect.right() - 1, closeIconRect.top() + 1) };
-                    painter->drawLines(lines, 2);
-                }
-            }
-
-            // normalize button
-            if ((titleBar->subControls & SC_TitleBarNormalButton) &&
-                (((titleBar->titleBarFlags & Qt::WindowMinimizeButtonHint) &&
-                 (titleBar->titleBarState & Qt::WindowMinimized)) ||
-                 ((titleBar->titleBarFlags & Qt::WindowMaximizeButtonHint) &&
-                  (titleBar->titleBarState & Qt::WindowMaximized)))) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarNormalButton) && (titleBar->state & State_Sunken);
-
-                QRect normalButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarNormalButton, widget);
-                qt_plastique_draw_mdibutton(painter, titleBar, normalButtonRect, hover, sunken);
-                int xoffset = int(normalButtonRect.width() / 3.5);
-                int yoffset = int(normalButtonRect.height() / 3.5);
-
-                QRect normalButtonIconRect(normalButtonRect.left() + xoffset, normalButtonRect.top() + yoffset,
-                                           normalButtonRect.width() - xoffset * 2, normalButtonRect.height() - yoffset * 2);
-
-                QRect frontWindowRect = normalButtonIconRect.adjusted(0, 3, -3, 0);
-                painter->setPen(textColor);
-                painter->drawRect(frontWindowRect.adjusted(0, 0, -1, -1));
-                painter->drawLine(frontWindowRect.left() + 1, frontWindowRect.top() + 1,
-                                  frontWindowRect.right() - 1, frontWindowRect.top() + 1);
-                painter->setPen(textAlphaColor);
-                {
-                    const QPoint points[4] = {
-                        frontWindowRect.topLeft(), frontWindowRect.topRight(),
-                        frontWindowRect.bottomLeft(), frontWindowRect.bottomRight() };
-                    painter->drawPoints(points, 4);
-                }
-
-                QRect backWindowRect = normalButtonIconRect.adjusted(3, 0, 0, -3);
-                QRegion clipRegion = backWindowRect;
-                clipRegion -= frontWindowRect;
-                painter->save();
-                painter->setClipRegion(clipRegion);
-                painter->setPen(textColor);
-                painter->drawRect(backWindowRect.adjusted(0, 0, -1, -1));
-                painter->drawLine(backWindowRect.left() + 1, backWindowRect.top() + 1,
-                                  backWindowRect.right() - 1, backWindowRect.top() + 1);
-                painter->setPen(textAlphaColor);
-                {
-                    const QPoint points[4] = {
-                        backWindowRect.topLeft(), backWindowRect.topRight(),
-                        backWindowRect.bottomLeft(), backWindowRect.bottomRight() };
-                    painter->drawPoints(points, 4);
-                }
-                painter->restore();
-            }
-
-            // context help button
-            if (titleBar->subControls & SC_TitleBarContextHelpButton
-                && (titleBar->titleBarFlags & Qt::WindowContextHelpButtonHint)) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarContextHelpButton) && (titleBar->state & State_Sunken);
-
-                QRect contextHelpButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarContextHelpButton, widget);
-
-                qt_plastique_draw_mdibutton(painter, titleBar, contextHelpButtonRect, hover, sunken);
-
-                QColor blend;
-                // ### Use palette colors
-                if (active) {
-                    blend = mergedColors(QColor(hover ? 0x7d8bb1 : 0x55689a),
-                                         QColor(hover ? 0x939ebe : 0x7381ab));
-                } else {
-                    blend = mergedColors(QColor(hover ? 0x9e9e9e : 0x818181),
-                                         QColor(hover ? 0xababab : 0x929292));
-                }
-                QImage image(qt_titlebar_context_help);
-                image.setColor(4, textColor.rgba());
-                image.setColor(3, mergedColors(blend, textColor, 30).rgba());
-                image.setColor(2, mergedColors(blend, textColor, 70).rgba());
-                image.setColor(1, mergedColors(blend, textColor, 90).rgba());
-
-                painter->drawImage(contextHelpButtonRect, image);
-            }
-
-            // shade button
-            if (titleBar->subControls & SC_TitleBarShadeButton) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarShadeButton) && (titleBar->state & State_Sunken);
-
-                QRect shadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarShadeButton, widget);
-                qt_plastique_draw_mdibutton(painter, titleBar, shadeButtonRect, hover, sunken);
-
-                int xoffset = shadeButtonRect.width() / 3;
-                int yoffset = shadeButtonRect.height() / 3;
-
-                QRect shadeButtonIconRect(shadeButtonRect.left() + xoffset, shadeButtonRect.top() + yoffset,
-                                          shadeButtonRect.width() - xoffset * 2, shadeButtonRect.height() - yoffset * 2);
-
-                QPainterPath path(shadeButtonIconRect.bottomLeft());
-                path.lineTo(shadeButtonIconRect.center().x(), shadeButtonIconRect.bottom() - shadeButtonIconRect.height() / 2);
-                path.lineTo(shadeButtonIconRect.bottomRight());
-                path.lineTo(shadeButtonIconRect.bottomLeft());
-
-                painter->setPen(textAlphaColor);
-                painter->setBrush(textColor);
-                painter->drawPath(path);
-            }
-
-            // unshade button
-            if (titleBar->subControls & SC_TitleBarUnshadeButton) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarUnshadeButton) && (titleBar->state & State_Sunken);
-
-                QRect unshadeButtonRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarUnshadeButton, widget);
-                qt_plastique_draw_mdibutton(painter, titleBar, unshadeButtonRect, hover, sunken);
-
-                int xoffset = unshadeButtonRect.width() / 3;
-                int yoffset = unshadeButtonRect.height() / 3;
-
-                QRect unshadeButtonIconRect(unshadeButtonRect.left() + xoffset, unshadeButtonRect.top() + yoffset,
-                                          unshadeButtonRect.width() - xoffset * 2, unshadeButtonRect.height() - yoffset * 2);
-
-                int midY = unshadeButtonIconRect.bottom() - unshadeButtonIconRect.height() / 2;
-                QPainterPath path(QPoint(unshadeButtonIconRect.left(), midY));
-                path.lineTo(unshadeButtonIconRect.right(), midY);
-                path.lineTo(unshadeButtonIconRect.center().x(), unshadeButtonIconRect.bottom());
-                path.lineTo(unshadeButtonIconRect.left(), midY);
-
-                painter->setPen(textAlphaColor);
-                painter->setBrush(textColor);
-                painter->drawPath(path);
-            }
-
-            // from qwindowsstyle.cpp
-            if ((titleBar->subControls & SC_TitleBarSysMenu) && (titleBar->titleBarFlags & Qt::WindowSystemMenuHint)) {
-                bool hover = (titleBar->activeSubControls & SC_TitleBarSysMenu) && (titleBar->state & State_MouseOver);
-                bool sunken = (titleBar->activeSubControls & SC_TitleBarSysMenu) && (titleBar->state & State_Sunken);
-
-                QRect iconRect = proxy()->subControlRect(CC_TitleBar, titleBar, SC_TitleBarSysMenu, widget);
-                if (hover)
-                    qt_plastique_draw_mdibutton(painter, titleBar, iconRect, hover, sunken);
-
-                if (!titleBar->icon.isNull()) {
-                    titleBar->icon.paint(painter, iconRect);
-                } else {
-                    QStyleOption tool(0);
-                    tool.palette = titleBar->palette;
-                    QPixmap pm = standardPixmap(SP_TitleBarMenuButton, &tool, widget);
-                    tool.rect = iconRect;
-                    painter->save();
-                    proxy()->drawItemPixmap(painter, iconRect, Qt::AlignCenter, pm);
-                    painter->restore();
-                }
-            }
-            painter->restore();
-        }
-        break;
-#ifndef QT_NO_DIAL
-    case CC_Dial:
-        if (const QStyleOptionSlider *dial = qstyleoption_cast<const QStyleOptionSlider *>(option))
-            QStyleHelper::drawDial(dial, painter);
-        break;
-#endif // QT_NO_DIAL
-    default:
-        QWindowsStyle::drawComplexControl(control, option, painter, widget);
-        break;
-    }
-}
-
-/*!
-  \reimp
-*/
-QSize QPlastiqueStyle::sizeFromContents(ContentsType type, const QStyleOption *option,
-                                        const QSize &size, const QWidget *widget) const
-{
-    QSize newSize = QWindowsStyle::sizeFromContents(type, option, size, widget);
-
-    switch (type) {
-    case CT_RadioButton:
-        ++newSize.rheight();
-        ++newSize.rwidth();
-        break;
-#ifndef QT_NO_SLIDER
-    case CT_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-            if (slider->tickPosition & QSlider::TicksBelow) {
-                if (slider->orientation == Qt::Horizontal)
-                    newSize.rheight() += tickSize;
-                else
-                    newSize.rwidth() += tickSize;
-            }
-            if (slider->tickPosition & QSlider::TicksAbove) {
-                if (slider->orientation == Qt::Horizontal)
-                    newSize.rheight() += tickSize;
-                else
-                    newSize.rwidth() += tickSize;
-            }
-        }
-        break;
-#endif // QT_NO_SLIDER
-#ifndef QT_NO_SCROLLBAR
-    case CT_ScrollBar:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int scrollBarExtent = proxy()->pixelMetric(PM_ScrollBarExtent, option, widget);
-            int scrollBarSliderMinimum = proxy()->pixelMetric(PM_ScrollBarSliderMin, option, widget);
-            if (scrollBar->orientation == Qt::Horizontal) {
-                newSize = QSize(scrollBarExtent * 3 + scrollBarSliderMinimum, scrollBarExtent);
-            } else {
-                newSize = QSize(scrollBarExtent, scrollBarExtent * 3 + scrollBarSliderMinimum);
-            }
-        }
-        break;
-#endif // QT_NO_SCROLLBAR
-#ifndef QT_NO_SPINBOX
-    case CT_SpinBox:
-        // Make sure the size is odd
-        newSize.setHeight(sizeFromContents(CT_LineEdit, option, size, widget).height());
-        newSize.rheight() -= ((1 - newSize.rheight()) & 1);
-        break;
-#endif
-#ifndef QT_NO_TOOLBUTTON
-    case CT_ToolButton:
-        newSize.rheight() += 3;
-        newSize.rwidth() += 3;
-        break;
-#endif
-#ifndef QT_NO_COMBOBOX
-    case CT_ComboBox:
-        newSize = sizeFromContents(CT_PushButton, option, size, widget);
-        newSize.rwidth() += 30; // Make room for drop-down indicator
-        newSize.rheight() += 4;
-        break;
-#endif
-    case CT_MenuItem:
-        if (const QStyleOptionMenuItem *menuItem = qstyleoption_cast<const QStyleOptionMenuItem *>(option)) {
-            if (menuItem->menuItemType == QStyleOptionMenuItem::Separator)
-                newSize.setHeight(menuItem->text.isEmpty() ? 2 : menuItem->fontMetrics.height());
-        }
-        break;
-    case CT_MenuBarItem:
-        newSize.setHeight(newSize.height());
-        break;
-    default:
-        break;
-    }
-
-    return newSize;
-}
-
-/*!
-  \reimp
-*/
-QRect QPlastiqueStyle::subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const
-{
-    QRect rect;
-    switch (element) {
-    case SE_RadioButtonIndicator:
-        rect = visualRect(option->direction, option->rect,
-                          QWindowsStyle::subElementRect(element, option, widget)).adjusted(0, 0, 1, 1);
-        break;
-    case SE_ProgressBarLabel:
-    case SE_ProgressBarContents:
-    case SE_ProgressBarGroove:
-        return option->rect;
-    default:
-        return QWindowsStyle::subElementRect(element, option, widget);
-    }
-
-    return visualRect(option->direction, option->rect, rect);
-}
-
-/*!
-  \reimp
-*/
-QRect QPlastiqueStyle::subControlRect(ComplexControl control, const QStyleOptionComplex *option,
-                                      SubControl subControl, const QWidget *widget) const
-{
-    QRect rect = QWindowsStyle::subControlRect(control, option, subControl, widget);
-
-    switch (control) {
-#ifndef QT_NO_SLIDER
-    case CC_Slider:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int tickSize = proxy()->pixelMetric(PM_SliderTickmarkOffset, option, widget);
-
-            switch (subControl) {
-            case SC_SliderHandle:
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setWidth(11);
-                    rect.setHeight(15);
-                    int centerY = slider->rect.center().y() - rect.height() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerY += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerY -= tickSize;
-                    rect.moveTop(centerY);
-                } else {
-                    rect.setWidth(15);
-                    rect.setHeight(11);
-                    int centerX = slider->rect.center().x() - rect.width() / 2;
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        centerX += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        centerX -= tickSize;
-                    rect.moveLeft(centerX);
-                }
-                break;
-            case SC_SliderGroove: {
-                QPoint grooveCenter = slider->rect.center();
-                if (slider->orientation == Qt::Horizontal) {
-                    rect.setHeight(14);
-                    --grooveCenter.ry();
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.ry() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.ry() -= tickSize;
-                } else {
-                    rect.setWidth(14);
-                    --grooveCenter.rx();
-                    if (slider->tickPosition & QSlider::TicksAbove)
-                        grooveCenter.rx() += tickSize;
-                    if (slider->tickPosition & QSlider::TicksBelow)
-                        grooveCenter.rx() -= tickSize;
-                }
-                rect.moveCenter(grooveCenter);
-                break;
-            }
-            default:
-                break;
-            }
-        }
-        break;
-#endif // QT_NO_SLIDER
-#ifndef QT_NO_SCROLLBAR
-    case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int scrollBarExtent = proxy()->pixelMetric(PM_ScrollBarExtent, scrollBar, widget);
-            int sliderMaxLength = ((scrollBar->orientation == Qt::Horizontal) ?
-                                   scrollBar->rect.width() : scrollBar->rect.height()) - (scrollBarExtent * 3);
-            int sliderMinLength = proxy()->pixelMetric(PM_ScrollBarSliderMin, scrollBar, widget);
-            int sliderLength;
-
-            // calculate slider length
-            if (scrollBar->maximum != scrollBar->minimum) {
-                uint valueRange = scrollBar->maximum - scrollBar->minimum;
-                sliderLength = (scrollBar->pageStep * sliderMaxLength) / (valueRange + scrollBar->pageStep);
-
-                if (sliderLength < sliderMinLength || valueRange > INT_MAX / 2)
-                    sliderLength = sliderMinLength;
-                if (sliderLength > sliderMaxLength)
-                    sliderLength = sliderMaxLength;
-            } else {
-                sliderLength = sliderMaxLength;
-            }
-
-            int sliderStart = scrollBarExtent + sliderPositionFromValue(scrollBar->minimum,
-                                                           scrollBar->maximum,
-                                                           scrollBar->sliderPosition,
-                                                           sliderMaxLength - sliderLength,
-                                                           scrollBar->upsideDown);
-
-            QRect scrollBarRect = scrollBar->rect;
-
-            switch (subControl) {
-            case SC_ScrollBarSubLine: // top/left button
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.top(), scrollBarRect.width() - scrollBarExtent, scrollBarRect.height());
-                } else {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.top(), scrollBarRect.width(), scrollBarRect.height() - scrollBarExtent);
-                }
-                break;
-            case SC_ScrollBarAddLine: // bottom/right button
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(scrollBarRect.right() - (scrollBarExtent - 1), scrollBarRect.top(), scrollBarExtent, scrollBarRect.height());
-                } else {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.bottom() - (scrollBarExtent - 1), scrollBarRect.width(), scrollBarExtent);
-                }
-                break;
-            case SC_ScrollBarSubPage:
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(scrollBarRect.left() + scrollBarExtent, scrollBarRect.top(),
-                                 sliderStart - (scrollBarRect.left() + scrollBarExtent), scrollBarRect.height());
-                } else {
-                    rect.setRect(scrollBarRect.left(), scrollBarRect.top() + scrollBarExtent,
-                                 scrollBarRect.width(), sliderStart - (scrollBarRect.left() + scrollBarExtent));
-                }
-                break;
-            case SC_ScrollBarAddPage:
-                if (scrollBar->orientation == Qt::Horizontal)
-                    rect.setRect(sliderStart + sliderLength, 0,
-                                 sliderMaxLength - sliderStart - sliderLength + scrollBarExtent, scrollBarRect.height());
-                else
-                    rect.setRect(0, sliderStart + sliderLength,
-                                 scrollBarRect.width(), sliderMaxLength - sliderStart - sliderLength + scrollBarExtent);
-                break;
-            case SC_ScrollBarGroove:
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect = scrollBarRect.adjusted(scrollBarExtent, 0, -2 * scrollBarExtent, 0);
-                } else {
-                    rect = scrollBarRect.adjusted(0, scrollBarExtent, 0, -2 * scrollBarExtent);
-                }
-                break;
-            case SC_ScrollBarSlider:
-                if (scrollBar->orientation == Qt::Horizontal) {
-                    rect.setRect(sliderStart, 0, sliderLength, scrollBarRect.height());
-                } else {
-                    rect.setRect(0, sliderStart, scrollBarRect.width(), sliderLength);
-                }
-                break;
-            default:
-                break;
-            }
-            rect = visualRect(scrollBar->direction, scrollBarRect, rect);
-        }
-        break;
-#endif // QT_NO_SCROLLBAR
-#ifndef QT_NO_SPINBOX
-    case CC_SpinBox:
-        if (const QStyleOptionSpinBox *spinBox = qstyleoption_cast<const QStyleOptionSpinBox *>(option)) {
-            int center = spinBox->rect.height() / 2;
-            switch (subControl) {
-            case SC_SpinBoxUp:
-                if (spinBox->buttonSymbols == QAbstractSpinBox::NoButtons)
-                    return QRect();
-                rect = visualRect(spinBox->direction, spinBox->rect, rect);
-                rect.setRect(spinBox->rect.right() - 16, spinBox->rect.top(), 17, center + 1);
-                rect = visualRect(spinBox->direction, spinBox->rect, rect);
-                break;
-            case SC_SpinBoxDown:
-                if (spinBox->buttonSymbols == QAbstractSpinBox::NoButtons)
-                    return QRect();
-                rect = visualRect(spinBox->direction, spinBox->rect, rect);
-                rect.setRect(spinBox->rect.right() - 16, spinBox->rect.top() + center, 17, spinBox->rect.height() - center);
-                rect = visualRect(spinBox->direction, spinBox->rect, rect);
-                break;
-            case SC_SpinBoxEditField:
-                if (spinBox->buttonSymbols != QAbstractSpinBox::NoButtons) {
-                    rect = spinBox->rect.adjusted(0, 0, -16, 0);
-                } else {
-                    rect = spinBox->rect;
-                }
-                rect.adjust(blueFrameWidth, blueFrameWidth, -blueFrameWidth, -blueFrameWidth);
-                rect = visualRect(spinBox->direction, spinBox->rect, rect);
-                break;
-            default:
-                break;
-            }
-        }
-        break;
-#endif // QT_NO_SPINBOX
-#ifndef QT_NO_COMBOBOX
-    case CC_ComboBox:
-        switch (subControl) {
-        case SC_ComboBoxArrow:
-            rect = visualRect(option->direction, option->rect, rect);
-            rect.setRect(rect.right() - 17, rect.top() - 2,
-                         19, rect.height() + 4);
-            rect = visualRect(option->direction, option->rect, rect);
-            break;
-        case SC_ComboBoxEditField: {
-            if (const QStyleOptionComboBox *box = qstyleoption_cast<const QStyleOptionComboBox *>(option)) {
-                int frameWidth = proxy()->pixelMetric(PM_DefaultFrameWidth);
-                rect = visualRect(option->direction, option->rect, rect);
-
-                if (box->editable) {
-                    rect = box->rect.adjusted(blueFrameWidth, blueFrameWidth, -blueFrameWidth, -blueFrameWidth);
-                    rect.setRight(rect.right() - 16); // Overlaps the combobox button by 2 pixels
-                } else {
-                    rect.setRect(option->rect.left() + frameWidth, option->rect.top() + frameWidth,
-                                 option->rect.width() - 16 - 2 * frameWidth,
-                                 option->rect.height() - 2 * frameWidth);
-                    rect.setLeft(rect.left() + 2);
-                    rect.setRight(rect.right() - 2);
-                    if (box->state & (State_Sunken | State_On))
-                        rect.translate(1, 1);
-                }
-                rect = visualRect(option->direction, option->rect, rect);
-            }
-            break;
-        }
-        default:
-            break;
-        }
-        break;
-#endif // QT_NO_COMBOBOX
-    case CC_TitleBar:
-        if (const QStyleOptionTitleBar *tb = qstyleoption_cast<const QStyleOptionTitleBar *>(option)) {
-            SubControl sc = subControl;
-            QRect &ret = rect;
-            const int indent = 3;
-            const int controlTopMargin = 4;
-            const int controlBottomMargin = 3;
-            const int controlWidthMargin = 1;
-            const int controlHeight = tb->rect.height() - controlTopMargin - controlBottomMargin;
-            const int delta = controlHeight + controlWidthMargin;
-            int offset = 0;
-
-            bool isMinimized = tb->titleBarState & Qt::WindowMinimized;
-            bool isMaximized = tb->titleBarState & Qt::WindowMaximized;
-
-            switch (sc) {
-            case SC_TitleBarLabel:
-                if (tb->titleBarFlags & (Qt::WindowTitleHint | Qt::WindowSystemMenuHint)) {
-                    ret = tb->rect;
-                    if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
-                        ret.adjust(delta, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowMinimizeButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowMaximizeButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowShadeButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                    if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
-                        ret.adjust(0, 0, -delta, 0);
-                    ret.adjusted(indent, 0, -indent, 0);
-                }
-                break;
-            case SC_TitleBarContextHelpButton:
-                if (tb->titleBarFlags & Qt::WindowContextHelpButtonHint)
-                    offset += delta;
-            case SC_TitleBarMinButton:
-                if (!isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarMinButton)
-                    break;
-            case SC_TitleBarNormalButton:
-                if (isMinimized && (tb->titleBarFlags & Qt::WindowMinimizeButtonHint))
-                    offset += delta;
-                else if (isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarNormalButton)
-                    break;
-            case SC_TitleBarMaxButton:
-                if (!isMaximized && (tb->titleBarFlags & Qt::WindowMaximizeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarMaxButton)
-                    break;
-            case SC_TitleBarShadeButton:
-                if (!isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarShadeButton)
-                    break;
-            case SC_TitleBarUnshadeButton:
-                if (isMinimized && (tb->titleBarFlags & Qt::WindowShadeButtonHint))
-                    offset += delta;
-                else if (sc == SC_TitleBarUnshadeButton)
-                    break;
-            case SC_TitleBarCloseButton:
-                if (tb->titleBarFlags & Qt::WindowSystemMenuHint)
-                    offset += delta;
-                else if (sc == SC_TitleBarCloseButton)
-                    break;
-                ret.setRect(tb->rect.right() - indent - offset, tb->rect.top() + controlTopMargin,
-                            controlHeight, controlHeight);
-                break;
-            case SC_TitleBarSysMenu:
-                if (tb->titleBarFlags & Qt::WindowSystemMenuHint) {
-                    ret.setRect(tb->rect.left() + controlWidthMargin + indent, tb->rect.top() + controlTopMargin,
-                                controlHeight, controlHeight);
-                }
-                break;
-            default:
-                break;
-            }
-            ret = visualRect(tb->direction, tb->rect, ret);
-        }
-        break;
-    default:
-        break;
-    }
-
-    return rect;
-}
-
-/*!
-  \reimp
-*/
-int QPlastiqueStyle::styleHint(StyleHint hint, const QStyleOption *option, const QWidget *widget,
-                               QStyleHintReturn *returnData) const
-{
-    int ret = 0;
-    switch (hint) {
-    case SH_WindowFrame_Mask:
-        ret = 1;
-        if (QStyleHintReturnMask *mask = qstyleoption_cast<QStyleHintReturnMask *>(returnData)) {
-            mask->region = option->rect;
-            mask->region -= QRect(option->rect.left(), option->rect.top(), 2, 1);
-            mask->region -= QRect(option->rect.right() - 1, option->rect.top(), 2, 1);
-            mask->region -= QRect(option->rect.left(), option->rect.top() + 1, 1, 1);
-            mask->region -= QRect(option->rect.right(), option->rect.top() + 1, 1, 1);
-
-            const QStyleOptionTitleBar *titleBar = qstyleoption_cast<const QStyleOptionTitleBar *>(option);
-            if (titleBar && (titleBar->titleBarState & Qt::WindowMinimized)) {
-                mask->region -= QRect(option->rect.left(), option->rect.bottom(), 2, 1);
-                mask->region -= QRect(option->rect.right() - 1, option->rect.bottom(), 2, 1);
-                mask->region -= QRect(option->rect.left(), option->rect.bottom() - 1, 1, 1);
-                mask->region -= QRect(option->rect.right(), option->rect.bottom() - 1, 1, 1);
-            } else {
-                mask->region -= QRect(option->rect.bottomLeft(), QSize(1, 1));
-                mask->region -= QRect(option->rect.bottomRight(), QSize(1, 1));
-            }
-        }
-        break;
-    case SH_TitleBar_NoBorder:
-        ret = 1;
-        break;
-    case SH_TitleBar_AutoRaise:
-        ret = 1;
-        break;
-    case SH_ItemView_ShowDecorationSelected:
-        ret = true;
-        break;
-    case SH_ToolBox_SelectedPageTitleBold:
-    case SH_ScrollBar_MiddleClickAbsolutePosition:
-        ret = true;
-        break;
-    case SH_MainWindow_SpaceBelowMenuBar:
-        ret = 0;
-        break;
-    case SH_FormLayoutWrapPolicy:
-        ret = QFormLayout::DontWrapRows;
-        break;
-    case SH_FormLayoutFieldGrowthPolicy:
-        ret = QFormLayout::ExpandingFieldsGrow;
-        break;
-    case SH_FormLayoutFormAlignment:
-        ret = Qt::AlignLeft | Qt::AlignTop;
-        break;
-    case SH_FormLayoutLabelAlignment:
-        ret = Qt::AlignRight;
-        break;
-    case SH_MessageBox_TextInteractionFlags:
-        ret = Qt::TextSelectableByMouse | Qt::LinksAccessibleByMouse;
-        break;
-    case SH_LineEdit_PasswordCharacter:
-        ret = QCommonStyle::styleHint(hint, option, widget, returnData);
-        break;
-    case SH_ItemView_ArrowKeysNavigateIntoChildren:
-        ret = true;
-        break;
-    case SH_Menu_SubMenuPopupDelay:
-        ret = 96; // from Plastik
-        break;
-    case SH_DialogButtonBox_ButtonsHaveIcons:
-        if (const QPlatformTheme *theme = QGuiApplicationPrivate::platformTheme())
-            ret = theme->themeHint(QPlatformTheme::DialogButtonBoxButtonsHaveIcons).toBool();
-        else
-            ret = true;
-        break;
-#ifndef Q_OS_WIN
-    case SH_Menu_AllowActiveAndDisabled:
-        ret = false;
-        break;
-#endif
-    default:
-        ret = QWindowsStyle::styleHint(hint, option, widget, returnData);
-        break;
-    }
-    return ret;
-}
-
-/*!
-  \reimp
-*/
-QStyle::SubControl QPlastiqueStyle::hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option,
-                                                          const QPoint &pos, const QWidget *widget) const
-{
-    SubControl ret = SC_None;
-    switch (control) {
-#ifndef QT_NO_SCROLLBAR
-    case CC_ScrollBar:
-        if (const QStyleOptionSlider *scrollBar = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            QRect slider = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSlider, widget);
-            if (slider.contains(pos)) {
-                ret = SC_ScrollBarSlider;
-                break;
-            }
-
-            QRect scrollBarAddLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddLine, widget);
-            if (scrollBarAddLine.contains(pos)) {
-                ret = SC_ScrollBarAddLine;
-                break;
-            }
-
-            QRect scrollBarSubPage = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubPage, widget);
-            if (scrollBarSubPage.contains(pos)) {
-                ret = SC_ScrollBarSubPage;
-                break;
-            }
-
-            QRect scrollBarAddPage = proxy()->subControlRect(control, scrollBar, SC_ScrollBarAddPage, widget);
-            if (scrollBarAddPage.contains(pos)) {
-                ret = SC_ScrollBarAddPage;
-                break;
-            }
-
-            QRect scrollBarSubLine = proxy()->subControlRect(control, scrollBar, SC_ScrollBarSubLine, widget);
-            if (scrollBarSubLine.contains(pos)) {
-                ret = SC_ScrollBarSubLine;
-                break;
-            }
-        }
-        break;
-#endif // QT_NO_SCROLLBAR
-    default:
-        break;
-    }
-
-    return ret != SC_None ? ret : QWindowsStyle::hitTestComplexControl(control, option, pos, widget);
-}
-
-/*!
-  \reimp
-*/
-int QPlastiqueStyle::pixelMetric(PixelMetric metric, const QStyleOption *option, const QWidget *widget) const
-{
-    int ret = -1;
-    switch (metric) {
-    case PM_MenuVMargin:
-    case PM_MenuHMargin:
-        ret = 0;
-        break;
-    case PM_ButtonShiftHorizontal:
-    case PM_ButtonShiftVertical:
-        ret = 1;
-        break;
-    case PM_ButtonDefaultIndicator:
-        ret = 0;
-        break;
-#ifndef QT_NO_SLIDER
-    case PM_SliderThickness:
-        ret = 15;
-        break;
-    case PM_SliderLength:
-    case PM_SliderControlThickness:
-        ret = 11;
-        break;
-    case PM_SliderTickmarkOffset:
-        ret = 5;
-        break;
-    case PM_SliderSpaceAvailable:
-        if (const QStyleOptionSlider *slider = qstyleoption_cast<const QStyleOptionSlider *>(option)) {
-            int size = 15;
-            if (slider->tickPosition & QSlider::TicksBelow)
-                ++size;
-            if (slider->tickPosition & QSlider::TicksAbove)
-                ++size;
-            ret = size;
-            break;
-        }
-#endif // QT_NO_SLIDER
-    case PM_ScrollBarExtent:
-        ret = 16;
-        break;
-    case PM_ScrollBarSliderMin:
-        ret = 26;
-        break;
-    case PM_ProgressBarChunkWidth:
-        ret = 1;
-        break;
-    case PM_MenuBarItemSpacing:
-        ret = 3;
-        break;
-    case PM_MenuBarVMargin:
-        ret = 2;
-        break;
-    case PM_MenuBarHMargin:
-        ret = 0;
-        break;
-    case PM_MenuBarPanelWidth:
-        ret = 1;
-        break;
-    case PM_ToolBarHandleExtent:
-        ret = 9;
-        break;
-    case PM_ToolBarSeparatorExtent:
-        ret = 2;
-        break;
-    case PM_ToolBarItemSpacing:
-        ret = 1;
-        break;
-    case PM_ToolBarItemMargin:
-        ret = 1;
-        break;
-    case PM_ToolBarFrameWidth:
-        ret = 2;
-        break;
-    case PM_SplitterWidth:
-        ret = 6;
-        break;
-    case PM_DockWidgetSeparatorExtent:
-        ret = 6;
-        break;
-    case PM_DockWidgetHandleExtent:
-        ret = 20;
-        break;
-    case PM_DefaultFrameWidth:
-#ifndef QT_NO_MENU
-        if (qobject_cast<const QMenu *>(widget)) {
-            ret = 1;
-            break;
-        }
-#endif
-        ret = 2;
-        break;
-    case PM_MdiSubWindowFrameWidth:
-        ret = 4;
-        break;
-    case PM_TitleBarHeight:
-        ret = qMax(widget ? widget->fontMetrics().height() :
-                   (option ? option->fontMetrics.height() : 0), 30);
-        break;
-    case PM_MaximumDragDistance:
-        return -1;
-    case PM_DockWidgetTitleMargin:
-        return 2;
-    case PM_LayoutHorizontalSpacing:
-    case PM_LayoutVerticalSpacing:
-        return -1;  // rely on layoutHorizontalSpacing()
-    case PM_LayoutLeftMargin:
-    case PM_LayoutTopMargin:
-    case PM_LayoutRightMargin:
-    case PM_LayoutBottomMargin:
-        {
-            bool isWindow = false;
-            if (option) {
-                isWindow = (option->state & State_Window);
-            } else if (widget) {
-                isWindow = widget->isWindow();
-            }
-
-            if (isWindow) {
-                ret = 11;
-            } else {
-                ret = 9;
-            }
-        }
-    default:
-        break;
-    }
-
-    return ret != -1 ? ret : QWindowsStyle::pixelMetric(metric, option, widget);
-}
-
-/*!
-  \reimp
-*/
-QPalette QPlastiqueStyle::standardPalette() const
-{
-    QPalette palette;
-
-    palette.setBrush(QPalette::Disabled, QPalette::WindowText, QColor(QRgb(0xff808080)));
-    palette.setBrush(QPalette::Disabled, QPalette::Button, QColor(QRgb(0xffdddfe4)));
-    palette.setBrush(QPalette::Disabled, QPalette::Light, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Disabled, QPalette::Midlight, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Disabled, QPalette::Dark, QColor(QRgb(0xff555555)));
-    palette.setBrush(QPalette::Disabled, QPalette::Mid, QColor(QRgb(0xffc7c7c7)));
-    palette.setBrush(QPalette::Disabled, QPalette::Text, QColor(QRgb(0xffc7c7c7)));
-    palette.setBrush(QPalette::Disabled, QPalette::BrightText, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Disabled, QPalette::ButtonText, QColor(QRgb(0xff808080)));
-    palette.setBrush(QPalette::Disabled, QPalette::Base, QColor(QRgb(0xffefefef)));
-    palette.setBrush(QPalette::Disabled, QPalette::AlternateBase, palette.color(QPalette::Disabled, QPalette::Base).darker(110));
-    palette.setBrush(QPalette::Disabled, QPalette::Window, QColor(QRgb(0xffefefef)));
-    palette.setBrush(QPalette::Disabled, QPalette::Shadow, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Disabled, QPalette::Highlight, QColor(QRgb(0xff567594)));
-    palette.setBrush(QPalette::Disabled, QPalette::HighlightedText, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Disabled, QPalette::Link, QColor(QRgb(0xff0000ee)));
-    palette.setBrush(QPalette::Disabled, QPalette::LinkVisited, QColor(QRgb(0xff52188b)));
-    palette.setBrush(QPalette::Active, QPalette::WindowText, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Active, QPalette::Button, QColor(QRgb(0xffdddfe4)));
-    palette.setBrush(QPalette::Active, QPalette::Light, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Active, QPalette::Midlight, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Active, QPalette::Dark, QColor(QRgb(0xff555555)));
-    palette.setBrush(QPalette::Active, QPalette::Mid, QColor(QRgb(0xffc7c7c7)));
-    palette.setBrush(QPalette::Active, QPalette::Text, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Active, QPalette::BrightText, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Active, QPalette::ButtonText, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Active, QPalette::Base, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Active, QPalette::AlternateBase, palette.color(QPalette::Active, QPalette::Base).darker(110));
-    palette.setBrush(QPalette::Active, QPalette::Window, QColor(QRgb(0xffefefef)));
-    palette.setBrush(QPalette::Active, QPalette::Shadow, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Active, QPalette::Highlight, QColor(QRgb(0xff678db2)));
-    palette.setBrush(QPalette::Active, QPalette::HighlightedText, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Active, QPalette::Link, QColor(QRgb(0xff0000ee)));
-    palette.setBrush(QPalette::Active, QPalette::LinkVisited, QColor(QRgb(0xff52188b)));
-    palette.setBrush(QPalette::Inactive, QPalette::WindowText, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Inactive, QPalette::Button, QColor(QRgb(0xffdddfe4)));
-    palette.setBrush(QPalette::Inactive, QPalette::Light, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Inactive, QPalette::Midlight, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Inactive, QPalette::Dark, QColor(QRgb(0xff555555)));
-    palette.setBrush(QPalette::Inactive, QPalette::Mid, QColor(QRgb(0xffc7c7c7)));
-    palette.setBrush(QPalette::Inactive, QPalette::Text, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Inactive, QPalette::BrightText, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Inactive, QPalette::ButtonText, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Inactive, QPalette::Base, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Inactive, QPalette::AlternateBase, palette.color(QPalette::Inactive, QPalette::Base).darker(110));
-    palette.setBrush(QPalette::Inactive, QPalette::Window, QColor(QRgb(0xffefefef)));
-    palette.setBrush(QPalette::Inactive, QPalette::Shadow, QColor(QRgb(0xff000000)));
-    palette.setBrush(QPalette::Inactive, QPalette::Highlight, QColor(QRgb(0xff678db2)));
-    palette.setBrush(QPalette::Inactive, QPalette::HighlightedText, QColor(QRgb(0xffffffff)));
-    palette.setBrush(QPalette::Inactive, QPalette::Link, QColor(QRgb(0xff0000ee)));
-    palette.setBrush(QPalette::Inactive, QPalette::LinkVisited, QColor(QRgb(0xff52188b)));
-    return palette;
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::polish(QWidget *widget)
-{
-    if (qobject_cast<QPushButton *>(widget)
-#ifndef QT_NO_COMBOBOX
-        || qobject_cast<QComboBox *>(widget)
-#endif
-#ifndef QT_NO_SPINBOX
-        || qobject_cast<QAbstractSpinBox *>(widget)
-#endif
-        || qobject_cast<QCheckBox *>(widget)
-#ifndef QT_NO_GROUPBOX
-        || qobject_cast<QGroupBox *>(widget)
-#endif
-        || qobject_cast<QRadioButton *>(widget)
-#ifndef QT_NO_SPLITTER
-        || qobject_cast<QSplitterHandle *>(widget)
-#endif
-#ifndef QT_NO_TABBAR
-        || qobject_cast<QTabBar *>(widget)
-#endif
-        ) {
-        widget->setAttribute(Qt::WA_Hover);
-    }
-
-    if (widget->inherits("QDockSeparator")
-        || widget->inherits("QDockWidgetSeparator")) {
-        widget->setAttribute(Qt::WA_Hover);
-    }
-
-    if (false // to simplify the #ifdefs
-#ifndef QT_NO_MENUBAR
-        || qobject_cast<QMenuBar *>(widget)
-#endif
-#ifndef QT_NO_TOOLBAR
-        || qobject_cast<QToolBar *>(widget)
-        || (widget && qobject_cast<QToolBar *>(widget->parent()))
-#endif
-        ) {
-        widget->setBackgroundRole(QPalette::Window);
-    }
-
-#if defined QPlastique_MaskButtons
-    if (qobject_cast<QPushButton *>(widget) || qobject_cast<QToolButton *>(widget))
-        widget->installEventFilter(this);
-#endif
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::unpolish(QWidget *widget)
-{
-    if (qobject_cast<QPushButton *>(widget)
-#ifndef QT_NO_COMBOBOX
-        || qobject_cast<QComboBox *>(widget)
-#endif
-#ifndef QT_NO_SPINBOX
-        || qobject_cast<QAbstractSpinBox *>(widget)
-#endif
-        || qobject_cast<QCheckBox *>(widget)
-#ifndef QT_NO_GROUPBOX
-        || qobject_cast<QGroupBox *>(widget)
-#endif
-#ifndef QT_NO_SPLITTER
-        || qobject_cast<QSplitterHandle *>(widget)
-#endif
-#ifndef QT_NO_TABBAR
-        || qobject_cast<QTabBar *>(widget)
-#endif
-        || qobject_cast<QRadioButton *>(widget)) {
-        widget->setAttribute(Qt::WA_Hover, false);
-    }
-
-    if (widget->inherits("QDockSeparator")
-        || widget->inherits("QDockWidgetSeparator")) {
-        widget->setAttribute(Qt::WA_Hover, false);
-    }
-
-    if (false // to simplify the #ifdefs
-#ifndef QT_NO_MENUBAR
-        || qobject_cast<QMenuBar *>(widget)
-#endif
-#ifndef QT_NO_TOOLBOX
-        || qobject_cast<QToolBox *>(widget)
-#endif
-#ifndef QT_NO_TOOLBAR
-        || qobject_cast<QToolBar *>(widget)
-        || (widget && qobject_cast<QToolBar *>(widget->parent()))
-#endif
-        ) {
-        widget->setBackgroundRole(QPalette::Button);
-    }
-
-#if defined QPlastique_MaskButtons
-    if (qobject_cast<QPushButton *>(widget) || qobject_cast<QToolButton *>(widget))
-        widget->removeEventFilter(this);
-#endif
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::polish(QApplication *app)
-{
-    QWindowsStyle::polish(app);
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::polish(QPalette &pal)
-{
-    QWindowsStyle::polish(pal);
-#ifdef Q_WS_MAC
-    pal.setBrush(QPalette::Shadow, Qt::black);
-#endif
-}
-
-/*!
-  \reimp
-*/
-void QPlastiqueStyle::unpolish(QApplication *app)
-{
-    QWindowsStyle::unpolish(app);
-}
-
-/*!
-    \reimp
-*/
-QIcon QPlastiqueStyle::standardIcon(StandardPixmap standardIcon, const QStyleOption *option,
-                                    const QWidget *widget) const
-{
-    return QWindowsStyle::standardIcon(standardIcon, option, widget);
-}
-
-/*!
-    \reimp
-*/
-QPixmap QPlastiqueStyle::standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
-                                        const QWidget *widget) const
-{
-    return QWindowsStyle::standardPixmap(standardPixmap, opt, widget);
-}
-
-// this works as long as we have at most 16 different control types
-#define CT1(c) CT2(c, c)
-#define CT2(c1, c2) (((uint)c1 << 16) | (uint)c2)
-
-/*!
-    \reimp
-*/
-int QPlastiqueStyle::layoutSpacing(QSizePolicy::ControlType control1,
-                                   QSizePolicy::ControlType control2,
-                                   Qt::Orientation orientation,
-                                   const QStyleOption * /* option */,
-                                   const QWidget * /* widget */) const
-{
-    const int ButtonMask = QSizePolicy::ButtonBox | QSizePolicy::PushButton;
-
-    if (control2 == QSizePolicy::ButtonBox)
-        return 11;
-
-    if ((control1 | control2) & ButtonMask)
-        return (orientation == Qt::Horizontal) ? 10 : 9;
-
-    switch (CT2(control1, control2)) {
-    case CT1(QSizePolicy::Label):
-    case CT2(QSizePolicy::Label, QSizePolicy::DefaultType):
-    case CT2(QSizePolicy::Label, QSizePolicy::CheckBox):
-    case CT2(QSizePolicy::Label, QSizePolicy::ComboBox):
-    case CT2(QSizePolicy::Label, QSizePolicy::LineEdit):
-    case CT2(QSizePolicy::Label, QSizePolicy::RadioButton):
-    case CT2(QSizePolicy::Label, QSizePolicy::Slider):
-    case CT2(QSizePolicy::Label, QSizePolicy::SpinBox):
-    case CT2(QSizePolicy::Label, QSizePolicy::ToolButton):
-        return 5;
-    case CT2(QSizePolicy::CheckBox, QSizePolicy::RadioButton):
-    case CT2(QSizePolicy::RadioButton, QSizePolicy::CheckBox):
-    case CT1(QSizePolicy::CheckBox):
-        if (orientation == Qt::Vertical)
-            return 2;
-    case CT1(QSizePolicy::RadioButton):
-        if (orientation == Qt::Vertical)
-            return 1;
-    }
-
-    if (orientation == Qt::Horizontal
-            && (control2 & (QSizePolicy::CheckBox | QSizePolicy::RadioButton)))
-        return 8;
-
-    if ((control1 | control2) & (QSizePolicy::Frame
-                                 | QSizePolicy::GroupBox
-                                 | QSizePolicy::TabWidget)) {
-        return 11;
-    }
-
-    if ((control1 | control2) & (QSizePolicy::Line | QSizePolicy::Slider
-                                 | QSizePolicy::LineEdit | QSizePolicy::ComboBox
-                                 | QSizePolicy::SpinBox))
-        return 7;
-
-    return 6;
-}
-
-/*!
-    \reimp
-*/
-bool QPlastiqueStyle::eventFilter(QObject *watched, QEvent *event)
-{
-#if defined QPlastique_MaskButtons
-    switch (event->type()) {
-    case QEvent::Resize:
-        if (qobject_cast<QPushButton *>(watched) || qobject_cast<QToolButton *>(watched)) {
-            QWidget *widget = qobject_cast<QWidget *>(watched);
-            QRect rect = widget->rect();
-            QRegion region(rect);
-            region -= QRect(rect.left(), rect.top(), 2, 1);
-            region -= QRect(rect.left(), rect.top() + 1, 1, 1);
-            region -= QRect(rect.left(), rect.bottom(), 2, 1);
-            region -= QRect(rect.left(), rect.bottom() - 1, 1, 1);
-            region -= QRect(rect.right() - 1, rect.top(), 2, 1);
-            region -= QRect(rect.right(), rect.top() + 1, 1, 1);
-            region -= QRect(rect.right() - 1, rect.bottom(), 2, 1);
-            region -= QRect(rect.right(), rect.bottom() - 1, 1, 1);
-            widget->setMask(region);
-        }
-        break;
-    default:
-        break;
-    }
-#endif
-
-    return QWindowsStyle::eventFilter(watched, event);
-}
-
-QT_END_NAMESPACE
-
-#endif // !defined(QT_NO_STYLE_PLASTIQUE) || defined(QT_PLUGIN)
diff --git a/src/widgets/styles/qplastiquestyle.h b/src/widgets/styles/qplastiquestyle.h
deleted file mode 100644
index bda686e..0000000
--- a/src/widgets/styles/qplastiquestyle.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/****************************************************************************
-**
-** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies).
-** Contact: http://www.qt-project.org/legal
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and Digia.  For licensing terms and
-** conditions see http://qt.digia.com/licensing.  For further information
-** use the contact form at http://qt.digia.com/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 2.1 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU Lesser General Public License version 2.1 requirements
-** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
-**
-** In addition, as a special exception, Digia gives you certain additional
-** rights.  These rights are described in the Digia Qt LGPL Exception
-** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 3.0 as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL included in the
-** packaging of this file.  Please review the following information to
-** ensure the GNU General Public License version 3.0 requirements will be
-** met: http://www.gnu.org/copyleft/gpl.html.
-**
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef QPLASTIQUESTYLE_H
-#define QPLASTIQUESTYLE_H
-
-#include <QtWidgets/qwindowsstyle.h>
-
-QT_BEGIN_HEADER
-
-QT_BEGIN_NAMESPACE
-
-
-#if !defined(QT_NO_STYLE_PLASTIQUE)
-
-class QPlastiqueStylePrivate;
-class Q_WIDGETS_EXPORT QPlastiqueStyle : public QWindowsStyle
-{
-    Q_OBJECT
-    Q_DECLARE_PRIVATE(QPlastiqueStyle)
-public:
-    QPlastiqueStyle();
-    ~QPlastiqueStyle();
-
-    void drawPrimitive(PrimitiveElement element, const QStyleOption *option,
-                       QPainter *painter, const QWidget *widget = 0) const;
-    void drawControl(ControlElement element, const QStyleOption *option,
-                     QPainter *painter, const QWidget *widget) const;
-    void drawComplexControl(ComplexControl control, const QStyleOptionComplex *option,
-                            QPainter *painter, const QWidget *widget) const;
-    QSize sizeFromContents(ContentsType type, const QStyleOption *option,
-                           const QSize &size, const QWidget *widget) const;
-
-    QRect subElementRect(SubElement element, const QStyleOption *option, const QWidget *widget) const;
-    QRect subControlRect(ComplexControl cc, const QStyleOptionComplex *opt,
-                         SubControl sc, const QWidget *widget) const;
-
-    int styleHint(StyleHint hint, const QStyleOption *option = 0, const QWidget *widget = 0,
-                  QStyleHintReturn *returnData = 0) const;
-    SubControl hitTestComplexControl(ComplexControl control, const QStyleOptionComplex *option,
-                                     const QPoint &pos, const QWidget *widget = 0) const;
-
-    int pixelMetric(PixelMetric metric, const QStyleOption *option = 0, const QWidget *widget = 0) const;
-
-    QPixmap standardPixmap(StandardPixmap standardPixmap, const QStyleOption *opt,
-                           const QWidget *widget = 0) const;
-    
-    void polish(QWidget *widget);
-    void polish(QApplication *app);
-    void polish(QPalette &pal);
-    void unpolish(QWidget *widget);
-    void unpolish(QApplication *app);
-
-    QPalette standardPalette() const;
-
-    QIcon standardIcon(StandardPixmap standardIcon, const QStyleOption *opt = 0,
-                       const QWidget *widget = 0) const;
-    int layoutSpacing(QSizePolicy::ControlType control1,
-                      QSizePolicy::ControlType control2,
-                      Qt::Orientation orientation,
-                      const QStyleOption *option = 0,
-                      const QWidget *widget = 0) const;
-
-protected:
-    bool eventFilter(QObject *watched, QEvent *event);
-
-private:
-    Q_DISABLE_COPY(QPlastiqueStyle)
-    void *reserved;
-};
-
-#endif // QT_NO_STYLE_PLASTIQUE
-
-QT_END_NAMESPACE
-
-QT_END_HEADER
-
-#endif // QPLASTIQUESTYLE_H
diff --git a/src/widgets/styles/qstylefactory.cpp b/src/widgets/styles/qstylefactory.cpp
index 8f4f014..378448f 100644
--- a/src/widgets/styles/qstylefactory.cpp
+++ b/src/widgets/styles/qstylefactory.cpp
@@ -46,12 +46,6 @@
 
 #include "qapplication.h"
 #include "qwindowsstyle.h"
-#ifndef QT_NO_STYLE_PLASTIQUE
-#include "qplastiquestyle.h"
-#endif
-#ifndef QT_NO_STYLE_CLEANLOOKS
-#include "qcleanlooksstyle.h"
-#endif
 #ifndef QT_NO_STYLE_FUSION
 #include "qfusionstyle.h"
 #endif
@@ -96,9 +90,9 @@ Q_GLOBAL_STATIC_WITH_ARGS(QFactoryLoader, loader,
     plugin (see QStylePlugin).
 
     The valid keys can be retrieved using the keys()
-    function. Typically they include "windows",
-    "plastique" and "cleanlooks".  Depending on the platform,
-    "windowsxp", "windowsvista" and "macintosh" may be available.
+    function. Typically they include "windows" and "fusion".
+    Depending on the platform, "windowsxp", "windowsvista", "gtk"
+    and "macintosh" may be available.
     Note that keys are case insensitive.
 
     \sa QStyle
@@ -144,21 +138,11 @@ QStyle *QStyleFactory::create(const QString& key)
         ret = new QWindowsVistaStyle;
     else
 #endif
-#ifndef QT_NO_STYLE_PLASTIQUE
-    if (style == QLatin1String("plastique"))
-        ret = new QPlastiqueStyle;
-    else
-#endif
 #ifndef QT_NO_STYLE_FUSION
     if (style == QLatin1String("fusion"))
         ret = new QFusionStyle;
     else
 #endif
-#ifndef QT_NO_STYLE_CLEANLOOKS
-    if (style == QLatin1String("cleanlooks"))
-        ret = new QCleanlooksStyle;
-    else
-#endif
 #ifndef QT_NO_STYLE_GTK
     if (style == QLatin1String("gtk") || style == QLatin1String("gtk+"))
         ret = new QGtkStyle;
@@ -222,10 +206,6 @@ QStringList QStyleFactory::keys()
         (QSysInfo::WindowsVersion >= QSysInfo::WV_VISTA && (QSysInfo::WindowsVersion & QSysInfo::WV_NT_based)))
         list << QLatin1String("WindowsVista");
 #endif
-#ifndef QT_NO_STYLE_PLASTIQUE
-    if (!list.contains(QLatin1String("Plastique")))
-        list << QLatin1String("Plastique");
-#endif
 #ifndef QT_NO_STYLE_GTK
     if (!list.contains(QLatin1String("GTK+")))
         list << QLatin1String("GTK+");
@@ -234,10 +214,6 @@ QStringList QStyleFactory::keys()
     if (!list.contains(QLatin1String("Fusion")))
         list << QLatin1String("Fusion");
 #endif
-#ifndef QT_NO_STYLE_CLEANLOOKS
-    if (!list.contains(QLatin1String("Cleanlooks")))
-        list << QLatin1String("Cleanlooks");
-#endif
 #ifndef QT_NO_STYLE_MAC
     QString mstyle = QLatin1String("Macintosh");
 # ifdef Q_WS_MAC
diff --git a/src/widgets/styles/qstylesheetstyle.cpp b/src/widgets/styles/qstylesheetstyle.cpp
index 4abedb0..1c4cad7 100644
--- a/src/widgets/styles/qstylesheetstyle.cpp
+++ b/src/widgets/styles/qstylesheetstyle.cpp
@@ -54,7 +54,7 @@
 #include <qlineedit.h>
 #include <qwindowsstyle.h>
 #include <qcombobox.h>
-#include <qplastiquestyle.h>
+#include <qwindowsstyle.h>
 #include "private/qcssparser_p.h"
 #include "private/qmath_p.h"
 #include <qabstractscrollarea.h>
diff --git a/src/widgets/styles/qstylesheetstyle_default.cpp b/src/widgets/styles/qstylesheetstyle_default.cpp
index 843e4ad..58dbb1b 100644
--- a/src/widgets/styles/qstylesheetstyle_default.cpp
+++ b/src/widgets/styles/qstylesheetstyle_default.cpp
@@ -335,11 +335,12 @@ StyleSheet QStyleSheetStyle::getDefaultStyleSheet() const
     }
 
     /*QComboBox[style="QPlastiqueStyle"][readOnly="true"],
+    QComboBox[style="QFusionStyle"][readOnly="true"],
     QComboBox[style="QCleanlooksStyle"][readOnly="true"]
     {
         -qt-background-role: button;
     }*/
-    if (baseStyle()->inherits("QPlastiqueStyle")  || baseStyle()->inherits("QCleanlooksStyle"))
+    if (baseStyle()->inherits("QPlastiqueStyle")  || baseStyle()->inherits("QCleanlooksStyle") || baseStyle()->inherits("QFusionStyle"))
     {
         SET_ELEMENT_NAME(QLatin1String("QComboBox"));
         ADD_ATTRIBUTE_SELECTOR(QLatin1String("readOnly"), QLatin1String("true"), AttributeSelector::MatchEqual);
diff --git a/src/widgets/styles/qwindowsstyle.cpp b/src/widgets/styles/qwindowsstyle.cpp
index 301a7ac..6a20f5e 100644
--- a/src/widgets/styles/qwindowsstyle.cpp
+++ b/src/widgets/styles/qwindowsstyle.cpp
@@ -204,7 +204,7 @@ bool QWindowsStyle::eventFilter(QObject *o, QEvent *e)
     This style is Qt's default GUI style on Windows.
 
     \image qwindowsstyle.png
-    \sa QWindowsXPStyle, QMacStyle, QPlastiqueStyle
+    \sa QWindowsVistaStyle, QMacStyle, QFusionStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qwindowsvistastyle.cpp b/src/widgets/styles/qwindowsvistastyle.cpp
index d8bf692..d58e76e 100644
--- a/src/widgets/styles/qwindowsvistastyle.cpp
+++ b/src/widgets/styles/qwindowsvistastyle.cpp
@@ -154,7 +154,7 @@ bool QWindowsVistaStylePrivate::useVista()
   \warning This style is only available on the Windows Vista platform
   because it makes use of Windows Vista's style engine.
 
-  \sa QMacStyle, QWindowsXPStyle, QPlastiqueStyle, QCleanlooksStyle
+  \sa QMacStyle, QWindowsXPStyle, QFusionStyle
 */
 
 /*!
diff --git a/src/widgets/styles/qwindowsxpstyle.cpp b/src/widgets/styles/qwindowsxpstyle.cpp
index c7517c6..67e5118 100644
--- a/src/widgets/styles/qwindowsxpstyle.cpp
+++ b/src/widgets/styles/qwindowsxpstyle.cpp
@@ -1170,7 +1170,7 @@ void QWindowsXPStylePrivate::drawBackgroundThruNativeBuffer(XPThemeData &themeDa
     sizeFromContents(), are documented here.
 
     \image qwindowsxpstyle.png
-    \sa QMacStyle, QWindowsStyle, QPlastiqueStyle
+    \sa QMacStyle, QWindowsStyle, QFusionStyle
 */
 
 /*!
diff --git a/src/widgets/styles/styles.pri b/src/widgets/styles/styles.pri
index 1aae0d8..9c5a790 100644
--- a/src/widgets/styles/styles.pri
+++ b/src/widgets/styles/styles.pri
@@ -37,7 +37,7 @@ wince* {
 }
 
 contains( styles, all ) {
-    styles = mac windows windowsxp windowsvista
+    styles = fusion mac windows windowsxp windowsvista
 }
 
 !macx-*|ios:styles -= mac
@@ -65,6 +65,14 @@ contains( styles, mac ) {
     DEFINES += QT_NO_STYLE_MAC
 }
 
+contains( styles, windows ) {
+    HEADERS += styles/qwindowsstyle.h
+    SOURCES += styles/qwindowsstyle.cpp
+    DEFINES += QT_STYLE_WINDOWS
+} else {
+    DEFINES += QT_NO_STYLE_WINDOWS
+}
+
 contains( styles, windowsvista ) {
     HEADERS += styles/qwindowsvistastyle.h
     HEADERS += styles/qwindowsvistastyle_p.h
@@ -72,7 +80,7 @@ contains( styles, windowsvista ) {
     !contains( styles, windowsxp ) {
         message( windowsvista requires windowsxp )
         styles += windowsxp
-        DEFINES+= QT_STYLE_WINDOWSXP
+        DEFINES += QT_STYLE_WINDOWSXP
     }
 } else {
     DEFINES += QT_NO_STYLE_WINDOWSVISTA
@@ -83,25 +91,13 @@ contains( styles, windowsxp ) {
     SOURCES += styles/qwindowsxpstyle.cpp
     !contains( styles, windows ) {
         message( windowsxp requires windows )
-        styles += windows
-        DEFINES+= QT_STYLE_WINDOWS
+        styles  += windows
+        DEFINES += QT_STYLE_WINDOWS
     }
 } else {
     DEFINES += QT_NO_STYLE_WINDOWSXP
 }
 
-contains( styles, plastique ) {
-    HEADERS += styles/qplastiquestyle.h
-    SOURCES += styles/qplastiquestyle.cpp
-    !contains( styles, windows ) {
-        message( plastique requires windows )
-        styles += windows
-        DEFINES+= QT_STYLE_WINDOWS
-    }
-} else {
-    DEFINES += QT_NO_STYLE_PLASTIQUE
-}
-
 contains( styles, gtk ) {
         HEADERS += styles/qgtkstyle.h
         HEADERS += styles/qgtkpainter_p.h
@@ -109,45 +105,17 @@ contains( styles, gtk ) {
         SOURCES += styles/qgtkstyle.cpp
         SOURCES += styles/qgtkpainter.cpp
         SOURCES += styles/qgtkstyle_p.cpp
-    !contains( styles, cleanlooks ) {
-        styles += cleanlooks
-        DEFINES+= QT_STYLE_CLEANLOOKS
-    }
 } else {
     DEFINES += QT_NO_STYLE_GTK
 }
-
-contains( styles, cleanlooks ) {
-        HEADERS += styles/qcleanlooksstyle.h
-        HEADERS += styles/qcleanlooksstyle_p.h
-        SOURCES += styles/qcleanlooksstyle.cpp
-    !contains( styles, windows ) {
-        styles += windows
-        DEFINES+= QT_STYLE_WINDOWS
-    }
-} else {
-    DEFINES += QT_NO_STYLE_CLEANLOOKS
-}
-
 contains( styles, fusion ) {
         HEADERS += styles/qfusionstyle.h
         HEADERS += styles/qfusionstyle_p.h
         SOURCES += styles/qfusionstyle.cpp
-    !contains( styles, windows ) {
-        styles += windows
-        DEFINES+= QT_STYLE_WINDOWS
-    }
 } else {
     DEFINES += QT_NO_STYLE_FUSION
 }
 
-contains( styles, windows ) {
-    HEADERS += styles/qwindowsstyle.h
-    SOURCES += styles/qwindowsstyle.cpp
-} else {
-    DEFINES += QT_NO_STYLE_WINDOWS
-}
-
 contains( styles, windowsce ) {
     HEADERS += styles/qwindowscestyle.h
     SOURCES += styles/qwindowscestyle.cpp
diff --git a/src/widgets/widgets/qmenubar.cpp b/src/widgets/widgets/qmenubar.cpp
index 516c8b9..e53dc2c 100644
--- a/src/widgets/widgets/qmenubar.cpp
+++ b/src/widgets/widgets/qmenubar.cpp
@@ -623,17 +623,6 @@ void QMenuBar::initStyleOption(QStyleOptionMenuItem *option, const QAction *acti
     for items in the menu bar are only shown when the \uicontrol{Alt} key is
     pressed.
 
-    \table
-
-    \row \li \inlineimage plastique-menubar.png A menu bar shown in the
-    Plastique widget style.
-
-    \li The \l{QPlastiqueStyle}{Plastique widget style}, like most
-    other styles, handles the \uicontrol{Help} menu in the same way as it
-    handles any other menu.
-
-    \endtable
-
     \section1 QMenuBar on Mac OS X
 
     QMenuBar on Mac OS X is a wrapper for using the system-wide menu bar.
diff --git a/tests/auto/other/qaccessibilitylinux/tst_qaccessibilitylinux.cpp b/tests/auto/other/qaccessibilitylinux/tst_qaccessibilitylinux.cpp
index ea13af0..783ffc7 100644
--- a/tests/auto/other/qaccessibilitylinux/tst_qaccessibilitylinux.cpp
+++ b/tests/auto/other/qaccessibilitylinux/tst_qaccessibilitylinux.cpp
@@ -164,8 +164,8 @@ QDBusInterface *tst_QtAtSpi::getInterface(const QString &path, const QString &in
 void tst_QtAtSpi::initTestCase()
 {
     // Oxygen style creates many extra items, it's simply unusable here
-    qDebug() << "Using plastique style...";
-    qApp->setStyle("plastique");
+    qDebug() << "Using fusion style...";
+    qApp->setStyle("fusion");
     qApp->setApplicationName("tst_QtAtSpi app");
     dbus = DBusConnection();
 
diff --git a/tests/auto/widgets/dialogs/qmessagebox/tst_qmessagebox.cpp b/tests/auto/widgets/dialogs/qmessagebox/tst_qmessagebox.cpp
index 17b574f..cd52977 100644
--- a/tests/auto/widgets/dialogs/qmessagebox/tst_qmessagebox.cpp
+++ b/tests/auto/widgets/dialogs/qmessagebox/tst_qmessagebox.cpp
@@ -53,9 +53,6 @@
 #if defined(Q_OS_MAC) && !defined(QT_NO_STYLE_MAC)
 #include <QMacStyle>
 #endif
-#if !defined(QT_NO_STYLE_CLEANLOOKS)
-#include <QCleanlooksStyle>
-#endif
 
 #define CONVENIENCE_FUNC_SYMS(func) \
     { \
diff --git a/tests/auto/widgets/dialogs/qwizard/tst_qwizard.cpp b/tests/auto/widgets/dialogs/qwizard/tst_qwizard.cpp
index 99404bc..60163f5 100644
--- a/tests/auto/widgets/dialogs/qwizard/tst_qwizard.cpp
+++ b/tests/auto/widgets/dialogs/qwizard/tst_qwizard.cpp
@@ -50,8 +50,7 @@
 #include <QToolButton>
 #include <QVBoxLayout>
 #include <QWizard>
-#include <QStyle>
-#include <QPlastiqueStyle>
+#include <QWindowsStyle>
 #include <QTreeWidget>
 
 static QImage grabWidget(QWidget *window)
@@ -104,7 +103,6 @@ private slots:
     void sideWidget();
 
     // task-specific tests below me:
-    void task161660_buttonSpacing();
     void task177716_disableCommitButton();
     void task183550_stretchFactor();
     void task161658_alignments();
@@ -2400,23 +2398,6 @@ void tst_QWizard::sideWidget()
     QVERIFY(wizard.sideWidget() == 0);
 }
 
-void tst_QWizard::task161660_buttonSpacing()
-{
-#ifndef QT_NO_STYLE_PLASTIQUE
-    QString origStyle = QApplication::style()->objectName();
-    QApplication::setStyle(new QPlastiqueStyle);
-    QWizard wizard;
-    wizard.addPage(new QWizardPage);
-    wizard.show();
-    const QAbstractButton *finishButton = wizard.button(QWizard::FinishButton);
-    const QAbstractButton *cancelButton = wizard.button(QWizard::CancelButton);
-    const int spacing = cancelButton->geometry().left() - finishButton->geometry().right() - 1;
-    QCOMPARE(spacing, wizard.style()->layoutSpacing(
-                 QSizePolicy::PushButton, QSizePolicy::PushButton, Qt::Horizontal));
-    QApplication::setStyle(origStyle);
-#endif
-}
-
 class task177716_CommitPage : public QWizardPage
 {
     Q_OBJECT
diff --git a/tests/auto/widgets/graphicsview/qgraphicslinearlayout/tst_qgraphicslinearlayout.cpp b/tests/auto/widgets/graphicsview/qgraphicslinearlayout/tst_qgraphicslinearlayout.cpp
index d39c65a..d69ea1d 100644
--- a/tests/auto/widgets/graphicsview/qgraphicslinearlayout/tst_qgraphicslinearlayout.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicslinearlayout/tst_qgraphicslinearlayout.cpp
@@ -47,7 +47,7 @@
 #include <qgraphicsscene.h>
 #include <qgraphicsview.h>
 #include <qapplication.h>
-#include <qplastiquestyle.h>
+#include <qwindowsstyle.h>
 
 class tst_QGraphicsLinearLayout : public QObject {
 Q_OBJECT
@@ -152,11 +152,7 @@ void tst_QGraphicsLinearLayout::initTestCase()
 {
     // since the style will influence the results, we have to ensure
     // that the tests are run using the same style on all platforms
-#if defined (Q_OS_WINCE)
     QApplication::setStyle(new QWindowsStyle);
-#else
-    QApplication::setStyle(new QPlastiqueStyle);
-#endif
 }
 
 // This will be called after the last test function is executed.
diff --git a/tests/auto/widgets/graphicsview/qgraphicsproxywidget/tst_qgraphicsproxywidget.cpp b/tests/auto/widgets/graphicsview/qgraphicsproxywidget/tst_qgraphicsproxywidget.cpp
index 883c47b..7a25697 100644
--- a/tests/auto/widgets/graphicsview/qgraphicsproxywidget/tst_qgraphicsproxywidget.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicsproxywidget/tst_qgraphicsproxywidget.cpp
@@ -434,8 +434,8 @@ void tst_QGraphicsProxyWidget::setWidget()
 #endif
     widget->setPalette(QPalette(Qt::magenta));
     widget->setLayoutDirection(Qt::RightToLeft);
-    QCleanlooksStyle cleanlooksStyle;
-    widget->setStyle(&cleanlooksStyle);
+    QFusionStyle fusionStyle;
+    widget->setStyle(&fusionStyle);
     widget->setFont(QFont("Times"));
     widget->setVisible(true);
     QApplication::setActiveWindow(widget);
diff --git a/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp b/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp
index d2b7001..57b7d08 100644
--- a/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicsview/tst_qgraphicsview.cpp
@@ -55,9 +55,6 @@
 #if !defined(QT_NO_STYLE_WINDOWS)
 #include <QtWidgets/QWindowsStyle>
 #endif
-#if !defined(QT_NO_STYLE_PLASTIQUE)
-#include <QtWidgets/QPlastiqueStyle>
-#endif
 #include <QtGui/QPainterPath>
 #include <QtWidgets/QRubberBand>
 #include <QtWidgets/QScrollBar>
@@ -2770,16 +2767,10 @@ void tst_QGraphicsView::scrollBarRanges()
     view.setFrameStyle(useStyledPanel ? QFrame::StyledPanel : QFrame::NoFrame);
 
     if (useMotif) {
-#if !defined(QT_NO_STYLE_WINDOWS)
         view.setStyle(new FauxMotifStyle);
-#else
-        QSKIP("No Windows style compiled.");
-#endif
     } else {
-#if defined(Q_OS_WINCE)
+#if !defined(QT_NO_STYLE_WINDOWS)
         view.setStyle(new QWindowsStyle);
-#elif !defined(QT_NO_STYLE_PLASTIQUE)
-        view.setStyle(new QPlastiqueStyle);
 #endif
     }
     view.setStyleSheet(" "); // enables style propagation ;-)
@@ -3291,9 +3282,7 @@ void tst_QGraphicsView::scrollAfterResize_data()
     QTest::addColumn<QTransform>("x2");
     QTest::addColumn<QTransform>("x3");
 
-#if !defined(QT_NO_STYLE_PLASTIQUE)
-    QPlastiqueStyle style;
-#elif !defined(QT_NO_STYLE_WINDOWS)
+#if !defined(QT_NO_STYLE_WINDOWS)
     QWindowsStyle style;
 #else
     QCommonStyle style;
@@ -3322,9 +3311,7 @@ void tst_QGraphicsView::scrollAfterResize()
     QFETCH(QTransform, x2);
     QFETCH(QTransform, x3);
 
-#if !defined(QT_NO_STYLE_PLASTIQUE)
-    QPlastiqueStyle style;
-#elif !defined(QT_NO_STYLE_WINDOWS)
+#if !defined(QT_NO_STYLE_WINDOWS)
     QWindowsStyle style;
 #else
     QCommonStyle style;
diff --git a/tests/auto/widgets/graphicsview/qgraphicswidget/tst_qgraphicswidget.cpp b/tests/auto/widgets/graphicsview/qgraphicswidget/tst_qgraphicswidget.cpp
index 1987a37..03814bc 100644
--- a/tests/auto/widgets/graphicsview/qgraphicswidget/tst_qgraphicswidget.cpp
+++ b/tests/auto/widgets/graphicsview/qgraphicswidget/tst_qgraphicswidget.cpp
@@ -47,11 +47,13 @@
 #include <qgraphicsview.h>
 #include <qstyleoption.h>
 #include <qgraphicslinearlayout.h>
-#include <qcleanlooksstyle.h>
 #include <qlineedit.h>
 #include <qboxlayout.h>
 #include <qaction.h>
 #include <qwidgetaction.h>
+#ifndef Q_NO_STYLE_FUSION
+#include <qfusionstyle.h>
+#endif
 
 #include "../../../qtest-config.h"
 
@@ -1397,21 +1399,22 @@ void tst_QGraphicsWidget::setStyle_data()
 {
     QTest::addColumn<QString>("style");
     QTest::newRow("null") << "";
-    QTest::newRow("cleanlooks") << "QCleanlooksStyle";
+    QTest::newRow("fusion") << "QFusionStyle";
 }
 
 // void setStyle(QStyle* style) public
 void tst_QGraphicsWidget::setStyle()
 {
+#ifndef Q_NO_STYLE_FUSION
     SubQGraphicsWidget widget;
-    QCleanlooksStyle cleanlooksStyle;
+    QFusionStyle fusionStyle;
 
     int oldEventCounts = widget.eventCount;
 
     QFETCH(QString, style);
-    if (style == "QCleanlooksStyle") {
-        widget.setStyle(&cleanlooksStyle);
-        QCOMPARE(widget.style(), static_cast<QStyle*>(&cleanlooksStyle));
+    if (style == "QFusionStyle") {
+        widget.setStyle(&fusionStyle);
+        QCOMPARE(widget.style(), static_cast<QStyle*>(&fusionStyle));
     } else {
         widget.setStyle(0);
         QVERIFY(widget.style() != (QStyle *)0);
@@ -1421,6 +1424,7 @@ void tst_QGraphicsWidget::setStyle()
 
     // cleanup
     widget.setStyle(0);
+#endif
 }
 
 void tst_QGraphicsWidget::setTabOrder_data()
diff --git a/tests/auto/widgets/itemviews/qlistview/tst_qlistview.cpp b/tests/auto/widgets/itemviews/qlistview/tst_qlistview.cpp
index 9f3cd0a..8458ca7 100644
--- a/tests/auto/widgets/itemviews/qlistview/tst_qlistview.cpp
+++ b/tests/auto/widgets/itemviews/qlistview/tst_qlistview.cpp
@@ -55,6 +55,11 @@
 #include <QtWidgets/QScrollBar>
 #include <QtWidgets/QDialog>
 #include <QtWidgets/QStyledItemDelegate>
+
+#if !defined(QT_NO_STYLE_WINDOWS)
+#include <qwindowsstyle.h>
+#endif // QT_NO_STYLE_WINDOWS
+
 #if defined(Q_OS_WIN) || defined(Q_OS_WINCE)
 #  include <windows.h>
 #  include <QtGui/QGuiApplication>
@@ -2190,6 +2195,11 @@ void tst_QListView::taskQTBUG_21804_hiddenItemsAndScrollingWithKeys()
 
     // create listview
     QListView lv;
+#if !defined(QT_NO_STYLE_WINDOWS)
+    // The test fails on Fusion style
+    // See https://bugreports.qt-project.org/browse/QTBUG-27675
+    lv.setStyle(new QWindowsStyle());
+#endif
     lv.setFlow(static_cast<QListView::Flow>(flow));
     lv.setSpacing(spacing);
     lv.setModel(&model);
diff --git a/tests/auto/widgets/kernel/qformlayout/tst_qformlayout.cpp b/tests/auto/widgets/kernel/qformlayout/tst_qformlayout.cpp
index 6ebeea2..ade2140 100644
--- a/tests/auto/widgets/kernel/qformlayout/tst_qformlayout.cpp
+++ b/tests/auto/widgets/kernel/qformlayout/tst_qformlayout.cpp
@@ -50,7 +50,6 @@
 #include <QtWidgets/QLabel>
 #include <QtWidgets/QLineEdit>
 #include <QtWidgets/QPushButton>
-#include <QtWidgets/QPlastiqueStyle>
 #include <QtWidgets/QWindowsStyle>
 #include <QStyleFactory>
 
@@ -403,7 +402,7 @@ void tst_QFormLayout::setFormStyle()
     QFormLayout layout;
     widget.setLayout(&layout);
 
-#ifndef QT_NO_STYLE_PLASTIQUE
+#if 0 // QT_NO_STYLE_PLASTIQUE
     widget.setStyle(new QPlastiqueStyle());
 
     QVERIFY(layout.labelAlignment() == Qt::AlignRight);
diff --git a/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp b/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp
index 6bbcc4d..1bb87b1 100644
--- a/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp
+++ b/tests/auto/widgets/styles/qstyle/tst_qstyle.cpp
@@ -55,7 +55,6 @@
 #include <qtoolbutton.h>
 #include <qtoolbar.h>
 
-#include <qplastiquestyle.h>
 #include <qwindowsstyle.h>
 #include <qcommonstyle.h>
 #include <qproxystyle.h>
@@ -72,7 +71,9 @@
 #include <qmdiarea.h>
 #include <qscrollarea.h>
 
-#include <QCleanlooksStyle>
+#ifndef Q_NO_STYLE_FUSION
+#include <qfusionstyle.h>
+#endif
 
 #ifdef Q_OS_MAC
 #include <QMacStyle>
@@ -116,27 +117,24 @@ private:
 private slots:
     void drawItemPixmap();
     void initTestCase();
+    void cleanup();
     void cleanupTestCase();
     void init();
-    void cleanup();
-#ifndef QT_NO_STYLE_PLASTIQUE
-    void testPlastiqueStyle();
+#ifndef QT_NO_STYLE_FUSION
+    void testFusionStyle();
 #endif
     void testWindowsStyle();
 #ifndef QT_NO_STYLE_WINDOWSXP
     void testWindowsXPStyle();
 #endif
     void testWindowsVistaStyle();
-#ifndef QT_NO_STYLE_CLEANLOOKS
-    void testCleanlooksStyle();
-#endif
     void testMacStyle();
     void testWindowsCEStyle();
     void testWindowsMobileStyle();
     void testStyleFactory();
     void testProxyStyle();
     void pixelMetric();
-#if !defined(QT_NO_STYLE_PLASTIQUE) && !defined(QT_NO_STYLE_WINDOWS)
+#if !defined(QT_NO_STYLE_WINDOWS)
     void progressBarChangeStyle();
 #endif
     void defaultFont();
@@ -187,11 +185,8 @@ void tst_QStyle::cleanupTestCase()
 void tst_QStyle::testStyleFactory()
 {
     QStringList keys = QStyleFactory::keys();
-#ifndef QT_NO_STYLE_CLEANLOOKS
-    QVERIFY(keys.contains("Cleanlooks"));
-#endif
-#ifndef QT_NO_STYLE_PLASTIQUE
-    QVERIFY(keys.contains("Plastique"));
+#ifndef QT_NO_STYLE_FUSION
+    QVERIFY(keys.contains("Fusion"));
 #endif
 #ifndef QT_NO_STYLE_WINDOWS
     QVERIFY(keys.contains("Windows"));
@@ -366,21 +361,12 @@ bool tst_QStyle::testScrollBarSubControls(QStyle* style)
     return true;
 }
 
-#ifndef QT_NO_STYLE_PLASTIQUE
-void tst_QStyle::testPlastiqueStyle()
+#ifndef QT_NO_STYLE_FUSION
+void tst_QStyle::testFusionStyle()
 {
-    QPlastiqueStyle pstyle;
-    QVERIFY(testAllFunctions(&pstyle));
-    lineUpLayoutTest(&pstyle);
-}
-#endif
-
-#ifndef QT_NO_STYLE_CLEANLOOKS
-void tst_QStyle::testCleanlooksStyle()
-{
-    QCleanlooksStyle cstyle;
-    QVERIFY(testAllFunctions(&cstyle));
-    lineUpLayoutTest(&cstyle);
+    QFusionStyle fstyle;
+    QVERIFY(testAllFunctions(&fstyle));
+    lineUpLayoutTest(&fstyle);
 }
 #endif
 
@@ -653,14 +639,14 @@ void tst_QStyle::pixelMetric()
     delete style;
 }
 
-#if !defined(QT_NO_STYLE_PLASTIQUE) && !defined(QT_NO_STYLE_WINDOWS)
+#if !defined(QT_NO_STYLE_WINDOWS)
 void tst_QStyle::progressBarChangeStyle()
 {
     //test a crashing situation (task 143530)
     //where changing the styles and deleting a progressbar would crash
 
     QWindowsStyle style1;
-    QPlastiqueStyle style2;
+    QFusionStyle style2;
 
     QProgressBar *progress=new QProgressBar;
     progress->setStyle(&style1);
diff --git a/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp b/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp
index 4b2125a..29846d6 100644
--- a/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp
+++ b/tests/auto/widgets/styles/qstylesheetstyle/tst_qstylesheetstyle.cpp
@@ -44,7 +44,7 @@
 #include <QtTest/QtTest>
 #include <QtDebug>
 #include <QMetaObject>
-#include <QPlastiqueStyle>
+#include <QFusionStyle>
 
 #include <private/qstylesheetstyle_p.h>
 
@@ -1589,7 +1589,7 @@ class ChangeEventWidget : public QWidget
             static bool recurse = false;
             if (!recurse) {
                 recurse = true;
-                QStyle *style = new QPlastiqueStyle;
+                QStyle *style = new QFusionStyle
                 style->setParent(this);
                 setStyle(style);
                 recurse = false;
diff --git a/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp b/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp
index bd16085..11e9a9d 100644
--- a/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp
+++ b/tests/auto/widgets/widgets/qcombobox/tst_qcombobox.cpp
@@ -72,8 +72,8 @@
 #include <qstringlist.h>
 #include <qvalidator.h>
 #include <qcompleter.h>
-#ifndef QT_NO_STYLE_CLEANLOOKS
-#include <qcleanlooksstyle.h>
+#ifndef QT_NO_STYLE_FUSION
+#include <qfusionstyle.h>
 #endif
 #include <qabstractitemview.h>
 #include <qstyleditemdelegate.h>
@@ -133,7 +133,7 @@ private slots:
     void itemListPosition();
     void separatorItem_data();
     void separatorItem();
-#ifndef QT_NO_STYLE_CLEANLOOKS
+#ifndef QT_NO_STYLE_FUSION
     void task190351_layout();
     void task191329_size();
 #endif
@@ -1942,12 +1942,12 @@ void tst_QComboBox::separatorItem()
     }
 }
 
-// This test requires the Cleanlooks style
-#ifndef QT_NO_STYLE_CLEANLOOKS
+// This test requires the Fusionstyle
+#ifndef QT_NO_STYLE_FUSION
 void tst_QComboBox::task190351_layout()
 {
     const QString oldStyle = QApplication::style()->objectName();
-    QApplication::setStyle(new QCleanlooksStyle);
+    QApplication::setStyle(new QFusionStyle);
 
     QComboBox listCombo;
     QListWidget *list = new QListWidget();
@@ -2007,12 +2007,12 @@ void tst_QComboBox::task166349_setEditableOnReturn()
     QCOMPARE(QLatin1String("two1"), comboBox.itemText(comboBox.count() - 1));
 }
 
-// This test requires the Cleanlooks style.
-#ifndef QT_NO_STYLE_CLEANLOOKS
+// This test requires the Fusion style.
+#ifndef QT_NO_STYLE_FUSION
 void tst_QComboBox::task191329_size()
 {
     const QString oldStyle = QApplication::style()->objectName();
-    QApplication::setStyle(new QCleanlooksStyle);
+    QApplication::setStyle(new QFusionStyle);
 
     QComboBox tableCombo;
     int rows;
diff --git a/tests/auto/widgets/widgets/qprogressbar/tst_qprogressbar.cpp b/tests/auto/widgets/widgets/qprogressbar/tst_qprogressbar.cpp
index 013d522..7024da9 100644
--- a/tests/auto/widgets/widgets/qprogressbar/tst_qprogressbar.cpp
+++ b/tests/auto/widgets/widgets/qprogressbar/tst_qprogressbar.cpp
@@ -299,10 +299,8 @@ void tst_QProgressBar::task245201_testChangeStyleAndDelete_data()
     QTest::addColumn<QString>("style1_str");
     QTest::addColumn<QString>("style2_str");
 
-    QTest::newRow("plastique-windows") << QString::fromLatin1("plastique") << QString::fromLatin1("windows");
-    QTest::newRow("mlotif-windows") << QString::fromLatin1("motif") << QString::fromLatin1("windows");
-    QTest::newRow("cleanlooks-cde") << QString::fromLatin1("cleanlooks") << QString::fromLatin1("cde");
-    QTest::newRow("gtk-plastique") << QString::fromLatin1("gtk") << QString::fromLatin1("plastique");
+    QTest::newRow("fusion-windows") << QString::fromLatin1("fusion") << QString::fromLatin1("windows");
+    QTest::newRow("gtk-fusion") << QString::fromLatin1("gtk") << QString::fromLatin1("fusion");
 }
 
 void tst_QProgressBar::task245201_testChangeStyleAndDelete()
diff --git a/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp b/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp
index 30cc6a4..9d16393 100644
--- a/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp
+++ b/tests/auto/widgets/widgets/qpushbutton/tst_qpushbutton.cpp
@@ -564,17 +564,14 @@ void tst_QPushButton::sizeHint_data()
 #if !defined(QT_NO_STYLE_WINDOWS)
     QTest::newRow("windows") << QString::fromLatin1("windows");
 #endif
-#if !defined(QT_NO_STYLE_CLEANLOOKS)
-    QTest::newRow("cleanlooks") << QString::fromLatin1("cleanlooks");
-#endif
 #if !defined(QT_NO_STYLE_GTK)
     QTest::newRow("gtk") << QString::fromLatin1("gtk");
 #endif
 #if defined(Q_OS_MAC) && !defined(QT_NO_STYLE_MAC)
     QTest::newRow("mac") << QString::fromLatin1("mac");
 #endif
-#if !defined(QT_NO_STYLE_PLASTIQUE)
-    QTest::newRow("plastique") << QString::fromLatin1("plastique");
+#if !defined(QT_NO_STYLE_FUSION)
+    QTest::newRow("fusion") << QString::fromLatin1("fusion");
 #endif
 #if defined(Q_OS_WIN) && !defined(QT_NO_STYLE_WINDOWSXP)
     QTest::newRow("windowsxp") << QString::fromLatin1("windowsxp");
diff --git a/tools/configure/configureapp.cpp b/tools/configure/configureapp.cpp
index 0d4d6d4..8cf559e 100644
--- a/tools/configure/configureapp.cpp
+++ b/tools/configure/configureapp.cpp
@@ -307,8 +307,6 @@ Configure::Configure(int& argc, char** argv)
     dictionary[ "STYLE_WINDOWS" ]   = "yes";
     dictionary[ "STYLE_WINDOWSXP" ] = "auto";
     dictionary[ "STYLE_WINDOWSVISTA" ] = "auto";
-    dictionary[ "STYLE_PLASTIQUE" ] = "yes";
-    dictionary[ "STYLE_CLEANLOOKS" ]= "yes";
     dictionary[ "STYLE_FUSION" ]    = "yes";
     dictionary[ "STYLE_WINDOWSCE" ] = "no";
     dictionary[ "STYLE_WINDOWSMOBILE" ] = "no";
@@ -639,16 +637,6 @@ void Configure::parseCmdLine()
         else if (configCmdLine.at(i) == "-no-style-windowsvista")
             dictionary[ "STYLE_WINDOWSVISTA" ] = "no";
 
-        else if (configCmdLine.at(i) == "-qt-style-plastique")
-            dictionary[ "STYLE_PLASTIQUE" ] = "yes";
-        else if (configCmdLine.at(i) == "-no-style-plastique")
-            dictionary[ "STYLE_PLASTIQUE" ] = "no";
-
-        else if (configCmdLine.at(i) == "-qt-style-cleanlooks")
-            dictionary[ "STYLE_CLEANLOOKS" ] = "yes";
-        else if (configCmdLine.at(i) == "-no-style-cleanlooks")
-            dictionary[ "STYLE_CLEANLOOKS" ] = "no";
-
         else if (configCmdLine.at(i) == "-qt-style-fusion")
             dictionary[ "STYLE_FUSION" ] = "yes";
         else if (configCmdLine.at(i) == "-no-style-fusion")
@@ -1485,8 +1473,6 @@ void Configure::applySpecSpecifics()
     if (dictionary[ "XQMAKESPEC" ].startsWith("wince")) {
         dictionary[ "STYLE_WINDOWSXP" ]     = "no";
         dictionary[ "STYLE_WINDOWSVISTA" ]  = "no";
-        dictionary[ "STYLE_PLASTIQUE" ]     = "no";
-        dictionary[ "STYLE_CLEANLOOKS" ]    = "no";
         dictionary[ "STYLE_FUSION" ]        = "no";
         dictionary[ "STYLE_WINDOWSCE" ]     = "yes";
         dictionary[ "STYLE_WINDOWSMOBILE" ] = "yes";
@@ -1797,8 +1783,6 @@ bool Configure::displayHelp()
         desc("STYLE_WINDOWS", "yes", "",                "  windows", ' ');
         desc("STYLE_WINDOWSXP", "auto", "",             "  windowsxp", ' ');
         desc("STYLE_WINDOWSVISTA", "auto", "",          "  windowsvista", ' ');
-        desc("STYLE_PLASTIQUE", "yes", "",              "  plastique", ' ');
-        desc("STYLE_CLEANLOOKS", "yes", "",             "  cleanlooks", ' ');
         desc("STYLE_FUSION", "yes", "",                 "  fusion", ' ');
         desc("STYLE_WINDOWSCE", "yes", "",              "  windowsce", ' ');
         desc("STYLE_WINDOWSMOBILE" , "yes", "",         "  windowsmobile\n", ' ');
@@ -2375,12 +2359,6 @@ void Configure::generateOutputVars()
     if (dictionary[ "STYLE_WINDOWS" ] == "yes")
         qmakeStyles += "windows";
 
-    if (dictionary[ "STYLE_PLASTIQUE" ] == "yes")
-        qmakeStyles += "plastique";
-
-    if (dictionary[ "STYLE_CLEANLOOKS" ] == "yes")
-        qmakeStyles += "cleanlooks";
-
     if (dictionary[ "STYLE_FUSION" ] == "yes")
         qmakeStyles += "fusion";
 
@@ -3162,8 +3140,6 @@ void Configure::generateConfigfiles()
 
         QStringList qconfigList;
         if (dictionary["STYLE_WINDOWS"] != "yes")     qconfigList += "QT_NO_STYLE_WINDOWS";
-        if (dictionary["STYLE_PLASTIQUE"] != "yes")   qconfigList += "QT_NO_STYLE_PLASTIQUE";
-        if (dictionary["STYLE_CLEANLOOKS"] != "yes")   qconfigList += "QT_NO_STYLE_CLEANLOOKS";
         if (dictionary["STYLE_FUSION"] != "yes")       qconfigList += "QT_NO_STYLE_FUSION";
         if (dictionary["STYLE_WINDOWSXP"] != "yes" && dictionary["STYLE_WINDOWSVISTA"] != "yes")
             qconfigList += "QT_NO_STYLE_WINDOWSXP";
@@ -3366,8 +3342,6 @@ void Configure::displayConfig()
     sout << "    Windows................." << dictionary[ "STYLE_WINDOWS" ] << endl;
     sout << "    Windows XP.............." << dictionary[ "STYLE_WINDOWSXP" ] << endl;
     sout << "    Windows Vista..........." << dictionary[ "STYLE_WINDOWSVISTA" ] << endl;
-    sout << "    Plastique..............." << dictionary[ "STYLE_PLASTIQUE" ] << endl;
-    sout << "    Cleanlooks.............." << dictionary[ "STYLE_CLEANLOOKS" ] << endl;
     sout << "    Fusion.................." << dictionary[ "STYLE_FUSION" ] << endl;
     sout << "    Windows CE.............." << dictionary[ "STYLE_WINDOWSCE" ] << endl;
     sout << "    Windows Mobile.........." << dictionary[ "STYLE_WINDOWSMOBILE" ] << endl << endl;