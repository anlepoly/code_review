diff --git a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp b/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
index 015b3ad..b695805 100644
--- a/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
+++ b/src/corelib/concurrent/qtconcurrentiteratekernel.cpp
@@ -108,16 +108,11 @@ static qint64 getticks()
     return (ts.tv_sec * 1000000000) + ts.tv_nsec;
 #else
 
-#ifdef Q_OS_SYMBIAN
-    return clock();
-#else
     // no clock_gettime(), fall back to wall time
     struct timeval tv;
     gettimeofday(&tv, 0);
     return (tv.tv_sec * 1000000) + tv.tv_usec;
 #endif
-
-#endif
 }
 
 #elif defined(Q_OS_WIN)
diff --git a/src/corelib/global/qglobal.cpp b/src/corelib/global/qglobal.cpp
index dfd198b..75bc1ec 100644
--- a/src/corelib/global/qglobal.cpp
+++ b/src/corelib/global/qglobal.cpp
@@ -1370,13 +1370,6 @@ bool qSharedBuild()
  */
 
 /*!
-  \macro Q_OS_SYMBIAN
-  \relates <QtGlobal>
-
-  Defined on Symbian.
- */
-
-/*!
   \macro QT_DISABLE_DEPRECATED_BEFORE
   \relates <QtGlobal>
 
diff --git a/src/corelib/global/qglobal.h b/src/corelib/global/qglobal.h
index 7c85ff0..2e6f6c3 100644
--- a/src/corelib/global/qglobal.h
+++ b/src/corelib/global/qglobal.h
@@ -152,7 +152,6 @@ namespace QT_NAMESPACE {}
    The operating system, must be one of: (Q_OS_x)
 
      DARWIN   - Darwin OS (synonym for Q_OS_MAC)
-     SYMBIAN  - Symbian
      MSDOS    - MS-DOS and Windows
      OS2      - OS/2
      OS2EMX   - XFree86 on OS/2 (not PM)
@@ -191,10 +190,6 @@ namespace QT_NAMESPACE {}
 #  else
 #    define Q_OS_DARWIN32
 #  endif
-#elif defined(__SYMBIAN32__) || defined(SYMBIAN)
-#  define Q_OS_SYMBIAN
-#  define Q_NO_POSIX_SIGNALS
-#  define QT_NO_GETIFADDRS
 #elif defined(__CYGWIN__)
 #  define Q_OS_CYGWIN
 #elif !defined(SAG_COM) && (defined(WIN64) || defined(_WIN64) || defined(__WIN64__))
@@ -342,9 +337,7 @@ namespace QT_NAMESPACE {}
      HIGHC    - MetaWare High C/C++
      PGI      - Portland Group C++
      GHS      - Green Hills Optimizing C++ Compilers
-     GCCE     - GCCE (Symbian GCCE builds)
      RVCT     - ARM Realview Compiler Suite
-     NOKIAX86 - Nokia x86 (Symbian WINSCW builds)
      CLANG    - C++ front-end for the LLVM compiler
 
 
@@ -402,14 +395,6 @@ namespace QT_NAMESPACE {}
 #elif defined(__WATCOMC__)
 #  define Q_CC_WAT
 
-/* Symbian GCCE */
-#elif defined(__GCCE__)
-#  define Q_CC_GCCE
-#  define QT_VISIBILITY_AVAILABLE
-#  if defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__)
-#    define QT_HAVE_ARMV6
-#  endif
-
 /* ARM Realview Compiler Suite
    RVCT compiler also defines __EDG__ and __GNUC__ (if --gnu flag is given),
    so check for it before that */
@@ -901,7 +886,7 @@ typedef quint64 qulonglong;
 #ifndef QT_POINTER_SIZE
 #  if defined(Q_OS_WIN64)
 #   define QT_POINTER_SIZE 8
-#  elif defined(Q_OS_WIN32) || defined(Q_OS_WINCE) || defined(Q_OS_SYMBIAN)
+#  elif defined(Q_OS_WIN32) || defined(Q_OS_WINCE)
 #   define QT_POINTER_SIZE 4
 #  endif
 #endif
diff --git a/src/corelib/io/qdir.cpp b/src/corelib/io/qdir.cpp
index b031313..e09c133 100644
--- a/src/corelib/io/qdir.cpp
+++ b/src/corelib/io/qdir.cpp
@@ -70,7 +70,7 @@ QT_BEGIN_NAMESPACE
 
 static QString driveSpec(const QString &path)
 {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     if (path.size() < 2)
         return QString();
     char c = path.at(0).toAscii();
@@ -162,7 +162,7 @@ inline void QDirPrivate::setPath(const QString &path)
     QString p = QDir::fromNativeSeparators(path);
     if (p.endsWith(QLatin1Char('/'))
             && p.length() > 1
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
         && (!(p.length() == 3 && p.at(1).unicode() == ':' && p.at(0).isLetter()))
 #endif
     ) {
@@ -736,8 +736,6 @@ QString QDir::relativeFilePath(const QString &fileName) const
     if (fileDrive.toLower() != dirDrive.toLower()
         || (file.startsWith(QLatin1String("//"))
         && !dir.startsWith(QLatin1String("//"))))
-#elif defined(Q_OS_SYMBIAN)
-    if (fileDrive.toLower() != dirDrive.toLower())
 #else
     if (fileDrive != dirDrive)
 #endif
@@ -753,7 +751,7 @@ QString QDir::relativeFilePath(const QString &fileName) const
 
     int i = 0;
     while (i < dirElts.size() && i < fileElts.size() &&
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
            dirElts.at(i).toLower() == fileElts.at(i).toLower())
 #else
            dirElts.at(i) == fileElts.at(i))
@@ -789,7 +787,7 @@ QString QDir::relativeFilePath(const QString &fileName) const
 */
 QString QDir::toNativeSeparators(const QString &pathName)
 {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     int i = pathName.indexOf(QLatin1Char('/'));
     if (i != -1) {
         QString n(pathName);
@@ -822,7 +820,7 @@ QString QDir::toNativeSeparators(const QString &pathName)
 */
 QString QDir::fromNativeSeparators(const QString &pathName)
 {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     int i = pathName.indexOf(QLatin1Char('\\'));
     if (i != -1) {
         QString n(pathName);
@@ -1802,7 +1800,7 @@ QFileInfoList QDir::drives()
 */
 QChar QDir::separator()
 {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     return QLatin1Char('\\');
 #else
     return QLatin1Char('/');
@@ -1882,7 +1880,7 @@ QString QDir::currentPath()
 
     Under non-Windows operating systems the \c HOME environment
     variable is used if it exists, otherwise the path returned by the
-    rootPath(). On Symbian always the same as the path returned by the rootPath().
+    rootPath().
 
     \sa home(), currentPath(), rootPath(), tempPath()
 */
@@ -1937,8 +1935,7 @@ QString QDir::tempPath()
     Returns the absolute path of the root directory.
 
     For Unix operating systems this returns "/". For Windows file
-    systems this normally returns "c:/". On Symbian this typically returns
-    "c:/data", i.e. the same as native PathInfo::PhoneMemoryRootPath().
+    systems this normally returns "c:/".
 
     \sa root(), drives(), currentPath(), homePath(), tempPath()
 */
@@ -2070,7 +2067,7 @@ QString QDir::cleanPath(const QString &path)
                     levels++;
                 }
             } else if (last != -1 && iwrite - last == 1) {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
                 eaten = (iwrite > 2);
 #else
                 eaten = true;
@@ -2105,7 +2102,7 @@ QString QDir::cleanPath(const QString &path)
     QString ret = (used == len ? name : QString(out, used));
     // Strip away last slash except for root directories
     if (ret.length() > 1 && ret.endsWith(QLatin1Char('/'))) {
-#if defined (Q_OS_WIN) || defined (Q_OS_SYMBIAN)
+#if defined (Q_OS_WIN)
         if (!(ret.length() == 3 && ret.at(1) == QLatin1Char(':')))
 #endif
             ret.chop(1);
diff --git a/src/corelib/io/qfile.cpp b/src/corelib/io/qfile.cpp
index dd7c5fc..d7308c7 100644
--- a/src/corelib/io/qfile.cpp
+++ b/src/corelib/io/qfile.cpp
@@ -66,8 +66,6 @@ static QByteArray locale_encode(const QString &f)
 #if defined(Q_OS_DARWIN)
     // Mac always expects UTF-8... and decomposed...
     return f.normalized(QString::NormalizationForm_D).toUtf8();
-#elif defined(Q_OS_SYMBIAN)
-    return f.toUtf8();
 #else
     return f.toLocal8Bit();
 #endif
@@ -78,8 +76,6 @@ static QString locale_decode(const QByteArray &f)
 #if defined(Q_OS_DARWIN)
     // Mac always gives us UTF-8 and decomposed, we want that composed...
     return QString::fromUtf8(f).normalized(QString::NormalizationForm_C);
-#elif defined(Q_OS_SYMBIAN)
-    return QString::fromUtf8(f);
 #else
     return QString::fromLocal8Bit(f);
 #endif
@@ -134,23 +130,6 @@ QFilePrivate::openExternalFile(int flags, FILE *fh, QFile::FileHandleFlags handl
 #endif
 }
 
-#ifdef Q_OS_SYMBIAN
-bool QFilePrivate::openExternalFile(int flags, const RFile &f, QFile::FileHandleFlags handleFlags)
-{
-#ifdef QT_NO_FSFILEENGINE
-    Q_UNUSED(flags);
-    Q_UNUSED(fh);
-    return false;
-#else
-    delete fileEngine;
-    fileEngine = 0;
-    QFSFileEngine *fe = new QFSFileEngine;
-    fileEngine = fe;
-    return fe->open(QIODevice::OpenMode(flags), f, handleFlags);
-#endif
-}
-#endif
-
 inline bool QFilePrivate::ensureFlushed() const
 {
     // This function ensures that the write buffer has been flushed (const
@@ -815,9 +794,6 @@ QFile::rename(const QString &oldName, const QString &newName)
 
     \note To create a valid link on Windows, \a linkName must have a \c{.lnk} file extension.
 
-    \note On Symbian, no link is created and false is returned if fileName()
-    currently specifies a directory.
-
     \sa setFileName()
 */
 
@@ -1019,14 +995,8 @@ bool QFile::open(OpenMode mode)
         return false;
     }
 
-#ifdef Q_OS_SYMBIAN
-    // For symbian, the unbuffered flag is used to control write-behind cache behaviour
-    if (fileEngine()->open(mode))
-#else
     // QIODevice provides the buffering, so there's no need to request it from the file engine.
-    if (fileEngine()->open(mode | QIODevice::Unbuffered))
-#endif
-    {
+    if (fileEngine()->open(mode | QIODevice::Unbuffered)) {
         QIODevice::open(mode);
         if (mode & Append)
             seek(size());
@@ -1247,63 +1217,6 @@ bool QFile::open(int fd, OpenMode mode, FileHandleFlags handleFlags)
     return false;
 }
 
-#ifdef Q_OS_SYMBIAN
-/*!
-    \overload
-
-    Opens the existing file object \a f in the given \a mode.
-    Returns true if successful; otherwise returns false.
-
-    When a QFile is opened using this function, behaviour of close() is
-    controlled by the AutoCloseHandle flag.
-    If AutoCloseHandle is specified, and this function succeeds,
-    then calling close() closes the adopted handle.
-    Otherwise, close() does not actually close the file, but only flushes it.
-
-    \warning If the file handle is adopted from another process,
-             you may not be able to use this QFile with a QFileInfo.
-
-    \sa close()
-*/
-bool QFile::open(const RFile &f, OpenMode mode, FileHandleFlags handleFlags)
-{
-    Q_D(QFile);
-    if (isOpen()) {
-        qWarning("QFile::open: File (%s) already open", qPrintable(fileName()));
-        return false;
-    }
-    if (mode & Append)
-        mode |= WriteOnly;
-    unsetError();
-    if ((mode & (ReadOnly | WriteOnly)) == 0) {
-        qWarning("QFile::open: File access not specified");
-        return false;
-    }
-    if (d->openExternalFile(mode, f, handleFlags)) {
-        bool ok = QIODevice::open(mode);
-        if (ok) {
-            if (mode & Append) {
-                ok = seek(size());
-            } else {
-                qint64 pos = 0;
-                TInt err;
-#ifdef SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-                err = static_cast<const RFile64&>(f).Seek(ESeekCurrent, pos);
-#else
-                TInt pos32 = 0;
-                err = f.Seek(ESeekCurrent, pos32);
-                pos = pos32;
-#endif
-                ok = ok && (err == KErrNone);
-                ok = ok && seek(pos);
-            }
-        }
-        return ok;
-    }
-    return false;
-}
-#endif
-
 /*!
   Returns the file handle of the file.
 
diff --git a/src/corelib/io/qfile.h b/src/corelib/io/qfile.h
index e6a11de..bc278cf 100644
--- a/src/corelib/io/qfile.h
+++ b/src/corelib/io/qfile.h
@@ -45,9 +45,6 @@
 #include <QtCore/qiodevice.h>
 #include <QtCore/qstring.h>
 #include <stdio.h>
-#ifdef Q_OS_SYMBIAN
-#include <f32file.h>
-#endif
 
 #ifdef open
 #error qfile.h must be included before any header file that defines open
@@ -150,9 +147,6 @@ public:
     bool open(OpenMode flags);
     bool open(FILE *f, OpenMode flags);
     bool open(int fd, OpenMode flags);
-#ifdef Q_OS_SYMBIAN
-    bool open(const RFile &f, OpenMode flags, FileHandleFlags handleFlags = DontCloseHandle);
-#endif
     bool open(FILE *f, OpenMode ioFlags, FileHandleFlags handleFlags);
     bool open(int fd, OpenMode ioFlags, FileHandleFlags handleFlags);
     virtual void close();
diff --git a/src/corelib/io/qfile_p.h b/src/corelib/io/qfile_p.h
index 513abc4..b932627 100644
--- a/src/corelib/io/qfile_p.h
+++ b/src/corelib/io/qfile_p.h
@@ -69,9 +69,6 @@ protected:
 
     bool openExternalFile(int flags, int fd, QFile::FileHandleFlags handleFlags);
     bool openExternalFile(int flags, FILE *fh, QFile::FileHandleFlags handleFlags);
-#ifdef Q_OS_SYMBIAN
-    bool openExternalFile(int flags, const RFile& f, QFile::FileHandleFlags handleFlags);
-#endif
 
     QString fileName;
     mutable QAbstractFileEngine *fileEngine;
diff --git a/src/corelib/io/qfileinfo.cpp b/src/corelib/io/qfileinfo.cpp
index 08a95a0..7277a7a 100644
--- a/src/corelib/io/qfileinfo.cpp
+++ b/src/corelib/io/qfileinfo.cpp
@@ -1019,7 +1019,7 @@ bool QFileInfo::isRoot() const
         return true;
     if (d->fileEngine == 0) {
         if (d->fileEntry.isRoot()) {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN) 
+#if defined(Q_OS_WIN)
             //the path is a drive root, but the drive may not exist
             //for backward compatibility, return true only if the drive exists
             if (!d->cache_enabled || !d->metaData.hasFlags(QFileSystemMetaData::ExistsAttribute))
diff --git a/src/corelib/io/qfilesystemengine.cpp b/src/corelib/io/qfilesystemengine.cpp
index e55a59d..21436c1 100644
--- a/src/corelib/io/qfilesystemengine.cpp
+++ b/src/corelib/io/qfilesystemengine.cpp
@@ -84,15 +84,7 @@ QString QFileSystemEngine::slowCanonicalized(const QString &path)
 #endif
         separatorPos = tmpPath.indexOf(slash, separatorPos + 1);
         QString prefix = separatorPos == -1 ? tmpPath : tmpPath.left(separatorPos);
-        if (
-#ifdef Q_OS_SYMBIAN
-            // Symbian doesn't support directory symlinks, so do not check for link unless we
-            // are handling the last path element. This not only slightly improves performance,
-            // but also saves us from lot of unnecessary platform security check failures
-            // when dealing with files under *:/private directories.
-            separatorPos == -1 &&
-#endif
-            !nonSymlinks.contains(prefix)) {
+        if (!nonSymlinks.contains(prefix)) {
             fi.setFile(prefix);
             if (fi.isSymLink()) {
                 QString target = fi.symLinkTarget();
@@ -276,20 +268,16 @@ void QFileSystemMetaData::fillFromStatBuf(const QT_STATBUF &statBuffer)
 #endif
 
     // Times
-#ifdef Q_OS_SYMBIAN
-    modificationTime_ = qt_symbian_time_t_To_TTime(statBuffer.st_mtime);
-#else
     creationTime_ = statBuffer.st_ctime ? statBuffer.st_ctime : statBuffer.st_mtime;
     modificationTime_ = statBuffer.st_mtime;
     accessTime_ = statBuffer.st_atime;
     userId_ = statBuffer.st_uid;
     groupId_ = statBuffer.st_gid;
-#endif
 }
 
 void QFileSystemMetaData::fillFromDirEnt(const QT_DIRENT &entry)
 {
-#if defined(_DIRENT_HAVE_D_TYPE) || defined(Q_OS_BSD4) || defined(Q_OS_SYMBIAN)
+#if defined(_DIRENT_HAVE_D_TYPE) || defined(Q_OS_BSD4)
     // BSD4 includes Mac OS X
 
     // ### This will clear all entry flags and knownFlagsMask
@@ -357,11 +345,7 @@ void QFileSystemMetaData::fillFromDirEnt(const QT_DIRENT &entry)
 //static
 QString QFileSystemEngine::resolveUserName(const QFileSystemEntry &entry, QFileSystemMetaData &metaData)
 {
-#if defined (Q_OS_SYMBIAN)
-    Q_UNUSED(entry);
-    Q_UNUSED(metaData);
-    return QString();
-#elif defined(Q_OS_WIN)
+#if defined(Q_OS_WIN)
     Q_UNUSED(metaData);
     return QFileSystemEngine::owner(entry, QAbstractFileEngine::OwnerUser);
 #else //(Q_OS_UNIX)
@@ -374,11 +358,7 @@ QString QFileSystemEngine::resolveUserName(const QFileSystemEntry &entry, QFileS
 //static
 QString QFileSystemEngine::resolveGroupName(const QFileSystemEntry &entry, QFileSystemMetaData &metaData)
 {
-#if defined (Q_OS_SYMBIAN)
-    Q_UNUSED(entry);
-    Q_UNUSED(metaData);
-    return QString();
-#elif defined(Q_OS_WIN)
+#if defined(Q_OS_WIN)
     Q_UNUSED(metaData);
     return QFileSystemEngine::owner(entry, QAbstractFileEngine::OwnerGroup);
 #else //(Q_OS_UNIX)
diff --git a/src/corelib/io/qfilesystemengine_p.h b/src/corelib/io/qfilesystemengine_p.h
index ee17d86..6d60d77 100644
--- a/src/corelib/io/qfilesystemengine_p.h
+++ b/src/corelib/io/qfilesystemengine_p.h
@@ -71,7 +71,7 @@ public:
     static QString resolveUserName(const QFileSystemEntry &entry, QFileSystemMetaData &data);
     static QString resolveGroupName(const QFileSystemEntry &entry, QFileSystemMetaData &data);
 
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX)
     static QString resolveUserName(uint userId);
     static QString resolveGroupName(uint groupId);
 #endif
diff --git a/src/corelib/io/qfilesystementry.cpp b/src/corelib/io/qfilesystementry.cpp
index da4f574..46881a1 100644
--- a/src/corelib/io/qfilesystementry.cpp
+++ b/src/corelib/io/qfilesystementry.cpp
@@ -176,7 +176,7 @@ void QFileSystemEntry::resolveNativeFilePath() const
 QString QFileSystemEntry::fileName() const
 {
     findLastSeparator();
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     if (m_lastSeparator == -1 && m_filePath.length() >= 2 && m_filePath.at(1) == QLatin1Char(':'))
         return m_filePath.mid(2);
 #endif
@@ -187,7 +187,7 @@ QString QFileSystemEntry::path() const
 {
     findLastSeparator();
     if (m_lastSeparator == -1) {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
         if (m_filePath.length() >= 2 && m_filePath.at(1) == QLatin1Char(':'))
             return m_filePath.left(2);
 #endif
@@ -195,7 +195,7 @@ QString QFileSystemEntry::path() const
     }
     if (m_lastSeparator == 0)
         return QString(QLatin1Char('/'));
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     if (m_lastSeparator == 2 && m_filePath.at(1) == QLatin1Char(':'))
         return m_filePath.left(m_lastSeparator + 1);
 #endif
@@ -205,7 +205,7 @@ QString QFileSystemEntry::path() const
 QString QFileSystemEntry::baseName() const
 {
     findFileNameSeparators();
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     if (m_lastSeparator == -1 && m_filePath.length() >= 2 && m_filePath.at(1) == QLatin1Char(':'))
         return m_filePath.mid(2);
 #endif
@@ -221,7 +221,7 @@ QString QFileSystemEntry::baseName() const
 QString QFileSystemEntry::completeBaseName() const
 {
     findFileNameSeparators();
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     if (m_lastSeparator == -1 && m_filePath.length() >= 2 && m_filePath.at(1) == QLatin1Char(':'))
         return m_filePath.mid(2);
 #endif
@@ -253,7 +253,7 @@ QString QFileSystemEntry::completeSuffix() const
     return m_filePath.mid(qMax((qint16)0, m_lastSeparator) + m_firstDotInFileName + 1);
 }
 
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
 bool QFileSystemEntry::isRelative() const
 {
     resolveFilePath();
@@ -266,9 +266,7 @@ bool QFileSystemEntry::isAbsolute() const
     resolveFilePath();
     return (!m_filePath.isEmpty() && ((m_filePath.length() >= 3
                                        && (m_filePath[0].isLetter() && m_filePath[1].unicode() == ':' && m_filePath[2].unicode() == '/'))
-#ifdef Q_OS_WIN
                                       || (m_filePath.length() >= 2 && (m_filePath.at(0) == QLatin1Char('/') && m_filePath.at(1) == QLatin1Char('/')))
-#endif
                                       ));
 }
 #else
@@ -284,7 +282,7 @@ bool QFileSystemEntry::isAbsolute() const
 }
 #endif
 
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
 bool QFileSystemEntry::isDriveRoot() const
 {
     resolveFilePath();
@@ -298,12 +296,10 @@ bool QFileSystemEntry::isRoot() const
 {
     resolveFilePath();
     if (m_filePath == QLatin1String("/")
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
-            || isDriveRoot()
 #if defined(Q_OS_WIN)
+            || isDriveRoot()
             || isUncRoot(m_filePath)
 #endif
-#endif
             )
         return true;
 
diff --git a/src/corelib/io/qfilesystementry_p.h b/src/corelib/io/qfilesystementry_p.h
index c7292ab..4b99d65 100644
--- a/src/corelib/io/qfilesystementry_p.h
+++ b/src/corelib/io/qfilesystementry_p.h
@@ -56,7 +56,7 @@
 #include <QtCore/qstring.h>
 #include <QtCore/qbytearray.h>
 
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
 #define QFILESYSTEMENTRY_NATIVE_PATH_IS_UTF16
 #endif
 
@@ -93,7 +93,7 @@ public:
     bool isRelative() const;
     bool isClean() const;
 
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     bool isDriveRoot() const;
 #endif
     bool isRoot() const;
diff --git a/src/corelib/io/qfilesystemiterator_p.h b/src/corelib/io/qfilesystemiterator_p.h
index b2ae0d1..5c249d6 100644
--- a/src/corelib/io/qfilesystemiterator_p.h
+++ b/src/corelib/io/qfilesystemiterator_p.h
@@ -65,10 +65,7 @@
 #include <QtCore/private/qfilesystemmetadata_p.h>
 
 // Platform-specific headers
-#if defined(Q_OS_WIN)
-#elif defined (Q_OS_SYMBIAN)
-#include <f32file.h>
-#else
+#if !defined(Q_OS_WIN)
 #include <QtCore/qscopedpointer.h>
 #endif
 
@@ -95,11 +92,6 @@ private:
     bool uncFallback;
     int uncShareIndex;
     bool onlyDirs;
-#elif defined (Q_OS_SYMBIAN)
-    RDir dirHandle;
-    TEntryArray entries;
-    TInt lastError;
-    TInt entryIndex;
 #else
     QT_DIR *dir;
     QT_DIRENT *dirEntry;
diff --git a/src/corelib/io/qfilesystemmetadata_p.h b/src/corelib/io/qfilesystemmetadata_p.h
index b7749a3..ea981f0 100644
--- a/src/corelib/io/qfilesystemmetadata_p.h
+++ b/src/corelib/io/qfilesystemmetadata_p.h
@@ -63,9 +63,6 @@
 #ifndef IO_REPARSE_TAG_SYMLINK
 #define IO_REPARSE_TAG_SYMLINK (0xA000000CL)
 #endif
-#elif defined(Q_OS_SYMBIAN)
-#include <f32file.h>
-#include <QtCore/private/qdatetime_p.h>
 #endif
 
 QT_BEGIN_NAMESPACE
@@ -99,11 +96,7 @@ public:
         Permissions         = OtherPermissions | GroupPermissions | UserPermissions | OwnerPermissions,
 
         // Type
-#ifdef Q_OS_SYMBIAN
-        LinkType            = 0,
-#else
         LinkType            = 0x00010000,
-#endif
         FileType            = 0x00020000,
         DirectoryType       = 0x00040000,
 #if defined(Q_OS_MAC) && !defined(QT_NO_CORESERVICES)
@@ -154,12 +147,6 @@ public:
                             | QFileSystemMetaData::Times
                             | QFileSystemMetaData::OwnerIds,
 
-        SymbianTEntryFlags  = QFileSystemMetaData::Permissions
-                            | QFileSystemMetaData::FileType
-                            | QFileSystemMetaData::DirectoryType
-                            | QFileSystemMetaData::SequentialType
-                            | QFileSystemMetaData::Attributes
-                            | QFileSystemMetaData::Times,
 #if defined(Q_OS_WIN)
         WinStatFlags        = QFileSystemMetaData::FileType
                             | QFileSystemMetaData::DirectoryType
@@ -227,10 +214,6 @@ public:
     void fillFromStatBuf(const QT_STATBUF &statBuffer);
     void fillFromDirEnt(const QT_DIRENT &statBuffer);
 #endif
-#ifdef Q_OS_SYMBIAN
-    void fillFromTEntry(const TEntry& entry);
-    void fillFromVolumeInfo(const TVolumeInfo& info);
-#endif
 
 #if defined(Q_OS_WIN)
     inline void fillFromFileAttribute(DWORD fileAttribute, bool isDriveRoot = false);
@@ -251,8 +234,6 @@ private:
     FILETIME creationTime_;
     FILETIME lastAccessTime_;
     FILETIME lastWriteTime_;
-#elif defined(Q_OS_SYMBIAN)
-    TTime modificationTime_;
 #else
     time_t creationTime_;
     time_t modificationTime_;
@@ -274,7 +255,7 @@ inline bool QFileSystemMetaData::isBundle() const                   { return fal
 inline bool QFileSystemMetaData::isAlias() const                    { return false; }
 #endif
 
-#if (defined(Q_OS_UNIX) && !defined (Q_OS_SYMBIAN)) || defined (Q_OS_WIN)
+#if defined(Q_OS_UNIX) || defined (Q_OS_WIN)
 inline QDateTime QFileSystemMetaData::fileTime(QAbstractFileEngine::FileTime time) const
 {
     switch (time) {
@@ -292,7 +273,7 @@ inline QDateTime QFileSystemMetaData::fileTime(QAbstractFileEngine::FileTime tim
 }
 #endif
 
-#if defined(Q_OS_UNIX) && !defined (Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX)
 inline QDateTime QFileSystemMetaData::creationTime() const          { return QDateTime::fromTime_t(creationTime_); }
 inline QDateTime QFileSystemMetaData::modificationTime() const      { return QDateTime::fromTime_t(modificationTime_); }
 inline QDateTime QFileSystemMetaData::accessTime() const            { return QDateTime::fromTime_t(accessTime_); }
@@ -309,25 +290,6 @@ inline uint QFileSystemMetaData::ownerId(QAbstractFileEngine::FileOwner owner) c
 }
 #endif
 
-#ifdef Q_OS_SYMBIAN
-inline QDateTime QFileSystemMetaData::creationTime() const          { return modificationTime(); }
-inline QDateTime QFileSystemMetaData::modificationTime() const      { return qt_symbian_TTime_To_QDateTime(modificationTime_); }
-inline QDateTime QFileSystemMetaData::accessTime() const            { return modificationTime(); }
-
-inline QDateTime QFileSystemMetaData::fileTime(QAbstractFileEngine::FileTime time) const
-{
-    Q_UNUSED(time);
-    return modificationTime();
-}
-inline uint QFileSystemMetaData::userId() const                     { return (uint) -2; }
-inline uint QFileSystemMetaData::groupId() const                    { return (uint) -2; }
-inline uint QFileSystemMetaData::ownerId(QAbstractFileEngine::FileOwner owner) const
-{
-    Q_UNUSED(owner);
-    return (uint) -2;
-}
-#endif
-
 #if defined(Q_OS_WIN)
 inline uint QFileSystemMetaData::userId() const                     { return (uint) -2; }
 inline uint QFileSystemMetaData::groupId() const                    { return (uint) -2; }
diff --git a/src/corelib/io/qfsfileengine.cpp b/src/corelib/io/qfsfileengine.cpp
index c82f2b8..4bf2e53 100644
--- a/src/corelib/io/qfsfileengine.cpp
+++ b/src/corelib/io/qfsfileengine.cpp
@@ -120,9 +120,6 @@ void QFSFileEnginePrivate::init()
     openMode = QIODevice::NotOpen;
     fd = -1;
     fh = 0;
-#ifdef Q_OS_SYMBIAN
-    fileHandleForMaps = -1;
-#endif
     lastIOCommand = IOFlushCommand;
     lastFlushFailed = false;
     closeFileHandle = false;
@@ -365,12 +362,7 @@ bool QFSFileEngine::close()
 bool QFSFileEnginePrivate::closeFdFh()
 {
     Q_Q(QFSFileEngine);
-    if (fd == -1 && !fh
-#ifdef Q_OS_SYMBIAN
-        && !symbianFile.SubSessionHandle()
-        && fileHandleForMaps == -1
-#endif
-        )
+    if (fd == -1 && !fh)
         return false;
 
     // Flush the file if it's buffered, and if the last flush didn't fail.
@@ -378,24 +370,10 @@ bool QFSFileEnginePrivate::closeFdFh()
     bool closed = true;
     tried_stat = 0;
 
-#ifdef Q_OS_SYMBIAN
-    // Map handle is always owned by us so always close it
-    if (fileHandleForMaps >= 0) {
-        QT_CLOSE(fileHandleForMaps);
-        fileHandleForMaps = -1;
-    }
-#endif
-
     // Close the file if we created the handle.
     if (closeFileHandle) {
         int ret;
         do {
-#ifdef Q_OS_SYMBIAN
-            if (symbianFile.SubSessionHandle()) {
-                symbianFile.Close();
-                ret = 0;
-            } else
-#endif
             if (fh) {
                 // Close buffered file.
                 ret = fclose(fh) != 0 ? -1 : 0;
diff --git a/src/corelib/io/qfsfileengine.h b/src/corelib/io/qfsfileengine.h
index dc087a3..63659e7 100644
--- a/src/corelib/io/qfsfileengine.h
+++ b/src/corelib/io/qfsfileengine.h
@@ -43,9 +43,6 @@
 #define QFSFILEENGINE_H
 
 #include <QtCore/qabstractfileengine.h>
-#ifdef Q_OS_SYMBIAN
-#include <f32file.h>
-#endif
 
 #ifndef QT_NO_FSFILEENGINE
 
@@ -105,9 +102,6 @@ public:
     bool open(QIODevice::OpenMode flags, int fd);
     bool open(QIODevice::OpenMode flags, int fd, QFile::FileHandleFlags handleFlags);
     bool open(QIODevice::OpenMode flags, FILE *fh, QFile::FileHandleFlags handleFlags);
-#ifdef Q_OS_SYMBIAN
-    bool open(QIODevice::OpenMode flags, const RFile &f, QFile::FileHandleFlags handleFlags);
-#endif
     static bool setCurrentPath(const QString &path);
     static QString currentPath(const QString &path = QString());
     static QString homePath();
diff --git a/src/corelib/io/qfsfileengine_p.h b/src/corelib/io/qfsfileengine_p.h
index 88865e9..c06f662 100644
--- a/src/corelib/io/qfsfileengine_p.h
+++ b/src/corelib/io/qfsfileengine_p.h
@@ -60,10 +60,6 @@
 #include <QtCore/private/qfilesystemmetadata_p.h>
 #include <qhash.h>
 
-#ifdef Q_OS_SYMBIAN
-#include <f32file.h>
-#endif
-
 #ifndef QT_NO_FSFILEENGINE
 
 QT_BEGIN_NAMESPACE
@@ -117,31 +113,6 @@ public:
     mutable QFileSystemMetaData metaData;
 
     FILE *fh;
-#ifdef Q_OS_SYMBIAN
-#ifdef  SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-    RFile64 symbianFile;
-    TInt64 symbianFilePos;
-#else
-    RFile symbianFile;
-    
-    /**
-     * The cursor position in the underlying file.  This differs
-     * from devicePos because the latter is updated on calls to
-     * writeData, even if no data was physically transferred to
-     * the file, but instead stored in the write buffer.
-     * 
-     * iFilePos is updated on calls to RFile::Read and
-     * RFile::Write.  It is also updated on calls to seek() but
-     * RFile::Seek is not called when that happens because
-     * Symbian supports positioned reads and writes, saving a file
-     * server call, and because Symbian does not support seeking
-     * past the end of a file.  
-     */
-    TInt symbianFilePos;
-#endif
-    mutable int fileHandleForMaps;
-    int getMapHandle();
-#endif
 
 #ifdef Q_OS_WIN
     HANDLE fileHandle;
diff --git a/src/corelib/io/qfsfileengine_unix.cpp b/src/corelib/io/qfsfileengine_unix.cpp
index fd4694d..805c4b5 100644
--- a/src/corelib/io/qfsfileengine_unix.cpp
+++ b/src/corelib/io/qfsfileengine_unix.cpp
@@ -56,12 +56,6 @@
 #include <sys/mman.h>
 #include <stdlib.h>
 #include <limits.h>
-#if defined(Q_OS_SYMBIAN)
-# include <sys/syslimits.h>
-# include <f32file.h>
-# include <pathinfo.h>
-# include "private/qcore_symbian_p.h"
-#endif
 #include <errno.h>
 #if !defined(QWS) && defined(Q_OS_MAC)
 # include <private/qcore_mac_p.h>
@@ -69,23 +63,6 @@
 
 QT_BEGIN_NAMESPACE
 
-#if defined(Q_OS_SYMBIAN)
-/*!
-    \internal
-
-    Returns true if supplied path is a relative path
-*/
-static bool isRelativePathSymbian(const QString& fileName)
-{
-    return !(fileName.startsWith(QLatin1Char('/'))
-             || (fileName.length() >= 2
-             && ((fileName.at(0).isLetter() && fileName.at(1) == QLatin1Char(':'))
-             || (fileName.at(0) == QLatin1Char('/') && fileName.at(1) == QLatin1Char('/')))));
-}
-
-#endif
-
-#ifndef Q_OS_SYMBIAN
 /*!
     \internal
 
@@ -125,7 +102,6 @@ static inline QByteArray openModeToFopenMode(QIODevice::OpenMode flags, const QF
 
     return mode;
 }
-#endif
 
 /*!
     \internal
@@ -155,7 +131,6 @@ static inline int openModeToOpenFlags(QIODevice::OpenMode mode)
     return oflags;
 }
 
-#ifndef Q_OS_SYMBIAN
 /*!
     \internal
 
@@ -166,151 +141,7 @@ static inline bool setCloseOnExec(int fd)
 {
     return fd != -1 && fcntl(fd, F_SETFD, FD_CLOEXEC) != -1;
 }
-#endif
 
-#ifdef Q_OS_SYMBIAN
-/*!
-    \internal
-*/
-bool QFSFileEnginePrivate::nativeOpen(QIODevice::OpenMode openMode)
-{
-    Q_Q(QFSFileEngine);
-	
-	fh = 0;
-	fd = -1;
-
-    QString fn(QFileSystemEngine::absoluteName(fileEntry).nativeFilePath());
-    RFs& fs = qt_s60GetRFs();
-
-    TUint symbianMode = 0;
-
-    if(openMode & QIODevice::ReadOnly)
-        symbianMode |= EFileRead;
-    if(openMode & QIODevice::WriteOnly)
-        symbianMode |= EFileWrite;
-    if(openMode & QIODevice::Text)
-        symbianMode |= EFileStreamText;
-
-    // pre Symbian 9.4, file I/O is always unbuffered, and the enum values don't exist
-    if(QSysInfo::symbianVersion() >= QSysInfo::SV_9_4) {
-        if (openMode & QFile::Unbuffered) {
-            if (openMode & QIODevice::WriteOnly)
-                symbianMode |= 0x00001000; //EFileWriteDirectIO;
-            // ### Unbuffered read is not used, because it prevents file open in /resource
-            // ### and has no obvious benefits
-        } else {
-            if (openMode & QIODevice::WriteOnly)
-                symbianMode |= 0x00000800; //EFileWriteBuffered;
-            // use implementation defaults for read buffering
-        }
-    }
-
-    // Until Qt supports file sharing, we can't support EFileShareReadersOrWriters safely,
-    // but Qt does this on other platforms and autotests rely on it.
-    // The reason is that Unix locks are only advisory - the application needs to test the
-    // lock after opening the file. Symbian and Windows locks are mandatory - opening a
-    // locked file will fail.
-    symbianMode |= EFileShareReadersOrWriters;
-
-    TInt r;
-    //note QIODevice::Truncate only has meaning for read/write access
-    //write-only files are always truncated unless append is specified
-    //reference openModeToOpenFlags in qfsfileengine_unix.cpp
-    if ((openMode & QIODevice::Truncate) || (!(openMode & QIODevice::ReadOnly) && !(openMode & QIODevice::Append))) {
-        r = symbianFile.Replace(fs, qt_QString2TPtrC(fn), symbianMode);
-    } else {
-        r = symbianFile.Open(fs, qt_QString2TPtrC(fn), symbianMode);
-        if (r == KErrNotFound && (openMode & QIODevice::WriteOnly)) {
-            r = symbianFile.Create(fs, qt_QString2TPtrC(fn), symbianMode);
-        }
-    }
-
-    if (r == KErrNone) {
-#ifdef SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-        TInt64 size;
-#else
-        TInt size;
-#endif
-        r = symbianFile.Size(size);
-        if (r==KErrNone) {
-            if (openMode & QIODevice::Append)
-                symbianFilePos = size;
-            else
-                symbianFilePos = 0;
-            //TODO: port this (QFileSystemMetaData in open?)
-            //cachedSize = size;
-        }
-    }
-
-    if (r != KErrNone) {
-        q->setError(QFile::OpenError, QSystemError(r, QSystemError::NativeError).toString());
-        symbianFile.Close();
-        return false;
-    }
-
-    closeFileHandle = true;
-    return true;
-}
-
-bool QFSFileEngine::open(QIODevice::OpenMode openMode, const RFile &file, QFile::FileHandleFlags handleFlags)
-{
-    Q_D(QFSFileEngine);
-
-    // Append implies WriteOnly.
-    if (openMode & QFile::Append)
-        openMode |= QFile::WriteOnly;
-
-    // WriteOnly implies Truncate if neither ReadOnly nor Append are sent.
-    if ((openMode & QFile::WriteOnly) && !(openMode & (QFile::ReadOnly | QFile::Append)))
-        openMode |= QFile::Truncate;
-
-    d->openMode = openMode;
-    d->lastFlushFailed = false;
-    d->closeFileHandle = (handleFlags & QFile::AutoCloseHandle);
-    d->fileEntry.clear();
-    d->fh = 0;
-    d->fd = -1;
-    d->tried_stat = 0;
-
-#ifdef SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-    //RFile64 adds only functions to RFile, no data members
-    d->symbianFile = static_cast<const RFile64&>(file);
-#else
-    d->symbianFile = file;
-#endif
-    TInt ret;
-    d->symbianFilePos = 0;
-    if (openMode & QFile::Append) {
-        // Seek to the end when in Append mode.
-        ret = d->symbianFile.Size(d->symbianFilePos);
-    } else {
-        // Seek to current otherwise
-        ret = d->symbianFile.Seek(ESeekCurrent, d->symbianFilePos);
-    }
-
-    if (ret != KErrNone) {
-        setError(QFile::OpenError, QSystemError(ret, QSystemError::NativeError).toString());
-
-        d->openMode = QIODevice::NotOpen;
-#ifdef SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-        d->symbianFile = RFile64();
-#else
-        d->symbianFile = RFile();
-#endif
-        return false;
-    }
-
-    // Extract filename (best effort)
-    TFileName fn;
-    TInt err = d->symbianFile.FullName(fn);
-    if (err == KErrNone)
-        d->fileEntry = QFileSystemEntry(qt_TDesC2QString(fn), QFileSystemEntry::FromNativePath());
-    else
-        d->fileEntry.clear();
-
-    return true;
-}
-#else
 /*!
     \internal
 */
@@ -407,7 +238,6 @@ bool QFSFileEnginePrivate::nativeOpen(QIODevice::OpenMode openMode)
     closeFileHandle = true;
     return true;
 }
-#endif
 
 /*!
     \internal
@@ -423,10 +253,6 @@ bool QFSFileEnginePrivate::nativeClose()
 */
 bool QFSFileEnginePrivate::nativeFlush()
 {
-#ifdef Q_OS_SYMBIAN
-    if (symbianFile.SubSessionHandle())
-        return (KErrNone == symbianFile.Flush());
-#endif
     return fh ? flushFh() : fd != -1;
 }
 
@@ -437,24 +263,6 @@ qint64 QFSFileEnginePrivate::nativeRead(char *data, qint64 len)
 {
     Q_Q(QFSFileEngine);
 
-#ifdef Q_OS_SYMBIAN
-    if (symbianFile.SubSessionHandle()) {
-        if(len > KMaxTInt) {
-            //this check is more likely to catch a corrupt length, since it isn't possible to allocate 2GB buffers (yet..)
-            q->setError(QFile::ReadError, QLatin1String("Maximum 2GB in single read on this platform"));
-            return -1;
-        }
-        TPtr8 ptr(reinterpret_cast<TUint8*>(data), static_cast<TInt>(len));
-        TInt r = symbianFile.Read(symbianFilePos, ptr);
-        if (r != KErrNone)
-        {
-            q->setError(QFile::ReadError, QSystemError(r, QSystemError::NativeError).toString());
-            return -1;
-        }
-        symbianFilePos += ptr.Length();
-        return qint64(ptr.Length());
-    }
-#endif
     if (fh && nativeIsSequential()) {
         size_t readBytes = 0;
         int oldFlags = fcntl(QT_FILENO(fh), F_GETFL);
@@ -522,40 +330,6 @@ qint64 QFSFileEnginePrivate::nativeReadLine(char *data, qint64 maxlen)
 */
 qint64 QFSFileEnginePrivate::nativeWrite(const char *data, qint64 len)
 {
-#ifdef Q_OS_SYMBIAN
-    Q_Q(QFSFileEngine);
-    if (symbianFile.SubSessionHandle()) {
-        if(len > KMaxTInt) {
-            //this check is more likely to catch a corrupt length, since it isn't possible to allocate 2GB buffers (yet..)
-            q->setError(QFile::WriteError, QLatin1String("Maximum 2GB in single write on this platform"));
-            return -1;
-        }
-        const TPtrC8 ptr(reinterpret_cast<const TUint8*>(data), static_cast<TInt>(len));
-#ifdef SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-        TInt64 eofpos = 0;
-#else
-        TInt eofpos = 0;
-#endif
-        //The end of file position is not cached because QFile is read/write sharable, therefore another
-        //process may have altered the file size.
-        TInt r = symbianFile.Seek(ESeekEnd, eofpos);
-        if (r == KErrNone && symbianFilePos > eofpos) {
-            //seek position is beyond end of file so file needs to be extended before write.
-            //note that SetSize does not zero-initialise (c.f. posix lseek)
-            r = symbianFile.SetSize(symbianFilePos);
-        }
-        if (r == KErrNone) {
-            //write to specific position in the file (i.e. use our own cursor rather than calling seek)
-            r = symbianFile.Write(symbianFilePos, ptr);
-        }
-        if (r != KErrNone) {
-            q->setError(QFile::WriteError, QSystemError(r, QSystemError::NativeError).toString());
-            return -1;
-        }
-        symbianFilePos += len;
-        return len;
-    }
-#endif
     return writeFdFh(data, len);
 }
 
@@ -564,12 +338,6 @@ qint64 QFSFileEnginePrivate::nativeWrite(const char *data, qint64 len)
 */
 qint64 QFSFileEnginePrivate::nativePos() const
 {
-#ifdef Q_OS_SYMBIAN
-    const Q_Q(QFSFileEngine);
-    if (symbianFile.SubSessionHandle()) {
-        return symbianFilePos;
-    }
-#endif
     return posFdFh();
 }
 
@@ -578,19 +346,6 @@ qint64 QFSFileEnginePrivate::nativePos() const
 */
 bool QFSFileEnginePrivate::nativeSeek(qint64 pos)
 {
-#ifdef Q_OS_SYMBIAN
-    Q_Q(QFSFileEngine);
-    if (symbianFile.SubSessionHandle()) {
-#ifndef SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-        if(pos > KMaxTInt) {
-            q->setError(QFile::PositionError, QLatin1String("Maximum 2GB file position on this platform"));
-            return false;
-        }
-#endif
-        symbianFilePos = pos;
-        return true;
-    }
-#endif
     return seekFdFh(pos);
 }
 
@@ -602,31 +357,11 @@ int QFSFileEnginePrivate::nativeHandle() const
     return fh ? fileno(fh) : fd;
 }
 
-#ifdef Q_OS_SYMBIAN
-int QFSFileEnginePrivate::getMapHandle()
-{
-    if (symbianFile.SubSessionHandle()) {
-        // Symbian file handle can't be used for open C mmap() so open the file with open C as well.
-        if (fileHandleForMaps < 0) {
-            int flags = openModeToOpenFlags(openMode);
-            flags &= ~(O_CREAT | O_TRUNC);
-            fileHandleForMaps = ::wopen((wchar_t*)(fileEntry.nativeFilePath().utf16()), flags, 0666);
-        }
-        return fileHandleForMaps;
-    }
-    return nativeHandle();
-}
-#endif
-
 /*!
     \internal
 */
 bool QFSFileEnginePrivate::nativeIsSequential() const
 {
-#ifdef Q_OS_SYMBIAN
-    if (symbianFile.SubSessionHandle())
-        return false;
-#endif
     return isSequentialFdFh();
 }
 
@@ -679,22 +414,6 @@ bool QFSFileEngine::link(const QString &newName)
 
 qint64 QFSFileEnginePrivate::nativeSize() const
 {
-#ifdef Q_OS_SYMBIAN
-    const Q_Q(QFSFileEngine);
-    if (symbianFile.SubSessionHandle()) {
-#ifdef SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-        qint64 size;
-#else
-        TInt size;
-#endif
-        TInt err = symbianFile.Size(size);
-        if(err != KErrNone) {
-            const_cast<QFSFileEngine*>(q)->setError(QFile::PositionError, QSystemError(err, QSystemError::NativeError).toString());
-            return 0;
-        }
-        return size;
-    }
-#endif
     return sizeFdFh();
 }
 
@@ -710,11 +429,7 @@ bool QFSFileEngine::rmdir(const QString &name, bool recurseParentDirectories) co
 
 bool QFSFileEngine::caseSensitive() const
 {
-#if defined(Q_OS_SYMBIAN)
-    return false;
-#else
     return true;
-#endif
 }
 
 bool QFSFileEngine::setCurrentPath(const QString &path)
@@ -745,25 +460,7 @@ QString QFSFileEngine::tempPath()
 QFileInfoList QFSFileEngine::drives()
 {
     QFileInfoList ret;
-#if defined(Q_OS_SYMBIAN)
-    TDriveList driveList;
-    RFs rfs = qt_s60GetRFs();
-    TInt err = rfs.DriveList(driveList);
-    if (err == KErrNone) {
-        char driveName[] = "A:/";
-
-        for (char i = 0; i < KMaxDrives; i++) {
-            if (driveList[i]) {
-                driveName[0] = 'A' + i;
-                ret.append(QFileInfo(QLatin1String(driveName)));
-            }
-        }
-    } else {
-        qWarning("QFSFileEngine::drives: Getting drives failed");
-    }
-#else
     ret.append(QFileInfo(rootPath()));
-#endif
     return ret;
 }
 
@@ -900,11 +597,7 @@ QString QFSFileEngine::fileName(FileName file) const
 bool QFSFileEngine::isRelativePath() const
 {
     Q_D(const QFSFileEngine);
-#if defined(Q_OS_SYMBIAN)
-    return isRelativePathSymbian(d->fileEntry.filePath());
-#else
     return d->fileEntry.filePath().length() ? d->fileEntry.filePath()[0] != QLatin1Char('/') : true;
-#endif
 }
 
 uint QFSFileEngine::ownerId(FileOwner own) const
@@ -920,13 +613,9 @@ uint QFSFileEngine::ownerId(FileOwner own) const
 
 QString QFSFileEngine::owner(FileOwner own) const
 {
-#ifndef Q_OS_SYMBIAN
     if (own == OwnerUser)
         return QFileSystemEngine::resolveUserName(ownerId(own));
     return QFileSystemEngine::resolveGroupName(ownerId(own));
-#else
-    return QString();
-#endif
 }
 
 bool QFSFileEngine::setPermissions(uint perms)
@@ -940,44 +629,6 @@ bool QFSFileEngine::setPermissions(uint perms)
     return true;
 }
 
-#ifdef Q_OS_SYMBIAN
-bool QFSFileEngine::setSize(qint64 size)
-{
-    Q_D(QFSFileEngine);
-    bool ret = false;
-    TInt err = KErrNone;
-    if (d->symbianFile.SubSessionHandle()) {
-        TInt err = d->symbianFile.SetSize(size);
-        ret = (err == KErrNone);
-        if (ret && d->symbianFilePos > size)
-            d->symbianFilePos = size;
-    }
-    else if (d->fd != -1)
-        ret = QT_FTRUNCATE(d->fd, size) == 0;
-    else if (d->fh)
-        ret = QT_FTRUNCATE(QT_FILENO(d->fh), size) == 0;
-    else {
-        RFile tmp;
-        QString symbianFilename(d->fileEntry.nativeFilePath());
-        err = tmp.Open(qt_s60GetRFs(), qt_QString2TPtrC(symbianFilename), EFileWrite);
-        if (err == KErrNone)
-        {
-            err = tmp.SetSize(size);
-            tmp.Close();
-        }
-        ret = (err == KErrNone);
-    }
-    if (!ret) {
-        QSystemError error;
-        if (err)
-            error = QSystemError(err, QSystemError::NativeError);
-        else
-            error = QSystemError(errno, QSystemError::StandardLibraryError);
-        setError(QFile::ResizeError, error.toString());
-    }
-    return ret;
-}
-#else
 bool QFSFileEngine::setSize(qint64 size)
 {
     Q_D(QFSFileEngine);
@@ -992,7 +643,6 @@ bool QFSFileEngine::setSize(qint64 size)
         setError(QFile::ResizeError, qt_error_string(errno));
     return ret;
 }
-#endif
 
 QDateTime QFSFileEngine::fileTime(FileTime time) const
 {
@@ -1045,19 +695,8 @@ uchar *QFSFileEnginePrivate::map(qint64 offset, qint64 size, QFile::MemoryMapFla
     QT_OFF_T realOffset = QT_OFF_T(offset);
     realOffset &= ~(QT_OFF_T(pageSize - 1));
 
-#ifdef Q_OS_SYMBIAN
-    void *mapAddress;
-    TRAPD(err,     mapAddress = QT_MMAP((void*)0, realSize,
-                   access, MAP_SHARED, getMapHandle(), realOffset));
-    if (err != KErrNone) {
-        qWarning("OpenC bug: leave from mmap %d", err);
-        mapAddress = MAP_FAILED;
-        errno = EINVAL;
-    }
-#else
     void *mapAddress = QT_MMAP((void*)0, realSize,
                    access, MAP_SHARED, nativeHandle(), realOffset);
-#endif
     if (MAP_FAILED != mapAddress) {
         uchar *address = extra + static_cast<uchar*>(mapAddress);
         maps[address] = QPair<int,size_t>(extra, realSize);
diff --git a/src/corelib/io/qiodevice.cpp b/src/corelib/io/qiodevice.cpp
index 57db52f..0ad1a91 100644
--- a/src/corelib/io/qiodevice.cpp
+++ b/src/corelib/io/qiodevice.cpp
@@ -1088,15 +1088,6 @@ qint64 QIODevice::readLine(char *data, qint64 maxSize)
         if (readSoFar)
             debugBinaryString(data, int(readSoFar));
 #endif
-#if defined(Q_OS_SYMBIAN)
-        // Open C fgets strips '\r' but readSoFar gets returned as if it was still there
-        if ((d->openMode & Text) &&
-            readSoFar > 1 &&
-            data[readSoFar - 1] == '\0' &&
-            data[readSoFar - 2] == '\n') {
-            --readSoFar;
-        }
-#endif
         if (readSoFar && data[readSoFar - 1] == '\n') {
             if (d->openMode & Text) {
                 // QRingBuffer::readLine() isn't Text aware.
@@ -1135,12 +1126,6 @@ qint64 QIODevice::readLine(char *data, qint64 maxSize)
     data[readSoFar] = '\0';
 
     if (d->openMode & Text) {
-#if defined(Q_OS_SYMBIAN)
-        // Open C fgets strips '\r' but readSoFar gets returned as if it was still there
-        if (readSoFar > 1 && data[readSoFar - 1] == '\0' && data[readSoFar - 2] == '\n') {
-            --readSoFar;
-        }
-#endif
         if (readSoFar > 1 && data[readSoFar - 1] == '\n' && data[readSoFar - 2] == '\r') {
             data[readSoFar - 2] = '\n';
             data[readSoFar - 1] = '\0';
diff --git a/src/corelib/io/qprocess.cpp b/src/corelib/io/qprocess.cpp
index f8e924b..0a0097c 100644
--- a/src/corelib/io/qprocess.cpp
+++ b/src/corelib/io/qprocess.cpp
@@ -97,10 +97,6 @@ QT_END_NAMESPACE
 #include <qwineventnotifier.h>
 #endif
 
-#ifdef Q_OS_SYMBIAN
-#include <e32std.h>
-#endif
-
 #ifndef QT_NO_PROCESS
 
 QT_BEGIN_NAMESPACE
@@ -473,7 +469,7 @@ void QProcessPrivate::Channel::clear()
     used as an input source for QXmlReader, or for generating data to
     be uploaded using QNetworkAccessManager.
 
-    \note On Windows CE and Symbian, reading and writing to a process
+    \note On Windows CE, reading and writing to a process
     is not supported.
 
     When the process exits, QProcess reenters the \l NotRunning state
@@ -524,10 +520,6 @@ void QProcessPrivate::Channel::clear()
     setWorkingDirectory(). By default, processes are run in the
     current working directory of the calling process.
 
-    \note On Symbian, setting environment or working directory
-    is not supported. The working directory will always be the private
-    directory of the running process.
-
     \section1 Synchronous Process API
 
     QProcess provides a set of functions which allow it to be used
@@ -564,16 +556,6 @@ void QProcessPrivate::Channel::clear()
     interpreter itself (\c{cmd.exe} on some Windows systems), and ask
     the interpreter to execute the desired command.
 
-    \section1 Symbian Platform Security Requirements
-
-    On Symbian, processes which use the functions kill() or terminate()
-    must have the \c PowerMgmt platform security capability. If the client
-    process lacks this capability, these functions will fail.
-
-    Platform security capabilities are added via the
-    \l{qmake-variable-reference.html#target-capability}{TARGET.CAPABILITY}
-    qmake variable.
-
     \sa QBuffer, QFile, QTcpSocket
 */
 
@@ -780,10 +762,6 @@ QProcessPrivate::QProcessPrivate()
 #ifdef Q_OS_UNIX
     serial = 0;
 #endif
-#ifdef Q_OS_SYMBIAN
-    symbianProcess = NULL;
-    processLaunched = false;
-#endif
 }
 
 /*! \internal
@@ -858,13 +836,6 @@ void QProcessPrivate::cleanup()
 #ifdef Q_OS_UNIX
     serial = 0;
 #endif
-#ifdef Q_OS_SYMBIAN
-    if (symbianProcess) {
-        symbianProcess->Close();
-        delete symbianProcess;
-        symbianProcess = NULL;
-    }
-#endif
 }
 
 /*! \internal
@@ -1400,15 +1371,14 @@ void QProcess::setStandardOutputProcess(QProcess *destination)
     dto->stdinChannel.pipeFrom(dfrom);
 }
 
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
 
 /*!
     \since 4.7
 
     Returns the additional native command line arguments for the program.
 
-    \note This function is available only on the Windows and Symbian
-    platforms.
+    \note This function is available only on the Windows platform.
 
     \sa setNativeArguments()
 */
@@ -1431,8 +1401,7 @@ QString QProcess::nativeArguments() const
     string which is \e appended to the string composed from the usual
     argument list, with a delimiting space.
 
-    \note This function is available only on the Windows and Symbian
-    platforms.
+    \note This function is available only on the Windows platform.
 
     \sa nativeArguments()
 */
@@ -1464,10 +1433,6 @@ QString QProcess::workingDirectory() const
     process in this directory. The default behavior is to start the
     process in the working directory of the calling process.
 
-    \note The working directory setting is ignored on Symbian;
-    the private directory of the process is considered its working
-    directory.
-
     \sa workingDirectory(), start()
 */
 void QProcess::setWorkingDirectory(const QString &dir)
@@ -1613,7 +1578,7 @@ void QProcess::setEnvironment(const QStringList &environment)
     using setEnvironment() or setEnvironmentHash(). If no environment
     has been set, the environment of the calling process will be used.
 
-    \note The environment settings are ignored on Windows CE and Symbian,
+    \note The environment settings are ignored on Windows CE,
     as there is no concept of an environment.
 
     \sa processEnvironment(), setEnvironment(), systemEnvironment()
@@ -2079,13 +2044,6 @@ void QProcess::start(const QString &program, OpenMode mode)
     event loop does not handle the WM_CLOSE message, can only be terminated by
     calling kill().
 
-    On Symbian, this function requires platform security capability
-    \c PowerMgmt. If absent, the process will panic with KERN-EXEC 46.
-
-    \note Terminating running processes from other processes will typically
-    cause a panic in Symbian due to platform security.
-
-    \sa {Symbian Platform Security Requirements}
     \sa kill()
 */
 void QProcess::terminate()
@@ -2100,13 +2058,6 @@ void QProcess::terminate()
     On Windows, kill() uses TerminateProcess, and on Unix and Mac OS X, the
     SIGKILL signal is sent to the process.
 
-    On Symbian, this function requires platform security capability
-    \c PowerMgmt. If absent, the process will panic with KERN-EXEC 46.
-
-    \note Killing running processes from other processes will typically
-    cause a panic in Symbian due to platform security.
-
-    \sa {Symbian Platform Security Requirements}
     \sa terminate()
 */
 void QProcess::kill()
@@ -2259,7 +2210,7 @@ QT_BEGIN_INCLUDE_NAMESPACE
 #if defined(Q_OS_MAC) && !defined(QT_NO_CORESERVICES)
 # include <crt_externs.h>
 # define environ (*_NSGetEnviron())
-#elif defined(Q_OS_WINCE) || defined(Q_OS_SYMBIAN) || (defined(Q_OS_MAC) && defined(QT_NO_CORESERVICES))
+#elif defined(Q_OS_WINCE) || (defined(Q_OS_MAC) && defined(QT_NO_CORESERVICES))
   static char *qt_empty_environ[] = { 0 };
 #define environ qt_empty_environ
 #elif !defined(Q_OS_WIN)
@@ -2320,7 +2271,7 @@ QStringList QProcess::systemEnvironment()
     \relates QProcess
 
     Typedef for the identifiers used to represent processes on the underlying
-    platform. On Unix and Symbian, this corresponds to \l qint64; on Windows, it
+    platform. On Unix, this corresponds to \l qint64; on Windows, it
     corresponds to \c{_PROCESS_INFORMATION*}.
 
     \sa QProcess::pid()
diff --git a/src/corelib/io/qprocess.h b/src/corelib/io/qprocess.h
index fa11c73..f5203fb 100644
--- a/src/corelib/io/qprocess.h
+++ b/src/corelib/io/qprocess.h
@@ -151,7 +151,7 @@ public:
     void setStandardErrorFile(const QString &fileName, OpenMode mode = Truncate);
     void setStandardOutputProcess(QProcess *destination);
 
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     QString nativeArguments() const;
     void setNativeArguments(const QString &arguments);
 #endif
diff --git a/src/corelib/io/qprocess_p.h b/src/corelib/io/qprocess_p.h
index 571e039..236e716 100644
--- a/src/corelib/io/qprocess_p.h
+++ b/src/corelib/io/qprocess_p.h
@@ -78,9 +78,6 @@ class QWindowsPipeReader;
 class QWindowsPipeWriter;
 class QWinEventNotifier;
 class QTimer;
-#if defined(Q_OS_SYMBIAN)
-class RProcess;
-#endif
 
 #ifdef Q_OS_WIN
 class QProcEnvKey : public QString
@@ -280,7 +277,7 @@ public:
 
     QString program;
     QStringList arguments;
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
     QString nativeArguments;
 #endif
     QProcessEnvironment environment;
@@ -307,7 +304,7 @@ public:
 #endif
 
     void startProcess();
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX)
     void execChild(const char *workingDirectory, char **path, char **argv, char **envp);
 #endif
     bool processStarted();
@@ -348,11 +345,6 @@ public:
 #ifdef Q_OS_UNIX
     static void initializeProcessManager();
 #endif
-
-#ifdef Q_OS_SYMBIAN
-    bool processLaunched;
-    RProcess* symbianProcess;
-#endif
 };
 
 QT_END_NAMESPACE
diff --git a/src/corelib/io/qresource.cpp b/src/corelib/io/qresource.cpp
index d38423a..e46ab26 100644
--- a/src/corelib/io/qresource.cpp
+++ b/src/corelib/io/qresource.cpp
@@ -928,7 +928,7 @@ public:
     }
 };
 
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN) && !defined (Q_OS_NACL) && !defined(Q_OS_INTEGRITY)
+#if defined(Q_OS_UNIX) && !defined (Q_OS_NACL) && !defined(Q_OS_INTEGRITY)
 #define QT_USE_MMAP
 #endif
 
diff --git a/src/corelib/io/qstandardpaths.cpp b/src/corelib/io/qstandardpaths.cpp
index 2ddb778..78bf6c7 100644
--- a/src/corelib/io/qstandardpaths.cpp
+++ b/src/corelib/io/qstandardpaths.cpp
@@ -105,12 +105,6 @@ QT_BEGIN_NAMESPACE
 
     \note The storage location returned can be a directory that does not exist; i.e., it
     may need to be created by the system or the user.
-
-    \note On Symbian OS, ApplicationsLocation always point /sys/bin folder on the same drive
-    with executable. FontsLocation always points to folder on ROM drive. Symbian OS does not
-    have desktop concept, DesktopLocation returns same path as DocumentsLocation.
-    Rest of the standard locations point to folder on same drive with executable, except
-    that if executable is in ROM the folder from C drive is returned.
 */
 
 
@@ -232,7 +226,7 @@ QString QStandardPaths::findExecutable(const QString &executableName, const QStr
     QStringList searchPaths = paths;
     if (paths.isEmpty()) {
         QByteArray pEnv = qgetenv("PATH");
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
         const QLatin1Char pathSep(';');
 #else
         const QLatin1Char pathSep(':');
diff --git a/src/corelib/io/qtemporaryfile.cpp b/src/corelib/io/qtemporaryfile.cpp
index f05371e..b80ba6e 100644
--- a/src/corelib/io/qtemporaryfile.cpp
+++ b/src/corelib/io/qtemporaryfile.cpp
@@ -49,11 +49,7 @@
 #include "private/qsystemerror_p.h"
 #include "private/qfilesystemengine_p.h"
 
-#if defined(Q_OS_SYMBIAN)
-#include "private/qcore_symbian_p.h"
-#endif
-
-#if !defined(Q_OS_WIN) && !defined(Q_OS_SYMBIAN)
+#if !defined(Q_OS_WIN)
 #include "private/qcore_unix_p.h"       // overrides QT_OPEN
 #include <errno.h>
 #endif
@@ -64,7 +60,7 @@
 
 QT_BEGIN_NAMESPACE
 
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
 typedef ushort Char;
 
 static inline Char Latin1Char(char ch)
@@ -72,15 +68,7 @@ static inline Char Latin1Char(char ch)
     return ushort(uchar(ch));
 }
 
-# ifdef Q_OS_WIN
 typedef HANDLE NativeFileHandle;
-# else // Q_OS_SYMBIAN
-#  ifdef  SYMBIAN_ENABLE_64_BIT_FILE_SERVER_API
-typedef RFile64 NativeFileHandle;
-#  else
-typedef RFile NativeFileHandle;
-#  endif
-# endif
 
 #else // POSIX
 typedef char Char;
@@ -161,10 +149,6 @@ static bool createFileFromTemplate(NativeFileHandle &file,
         }
     }
 
-#ifdef Q_OS_SYMBIAN
-    RFs& fs = qt_s60GetRFs();
-#endif
-
     for (;;) {
         // Atomically create file and obtain handle
 #if defined(Q_OS_WIN)
@@ -181,17 +165,6 @@ static bool createFileFromTemplate(NativeFileHandle &file,
             error = QSystemError(err, QSystemError::NativeError);
             return false;
         }
-#elif defined(Q_OS_SYMBIAN)
-        TInt err = file.Create(fs, qt_QString2TPtrC(path),
-                EFileRead | EFileWrite | EFileShareReadersOrWriters);
-
-        if (err == KErrNone)
-            return true;
-
-        if (err != KErrAlreadyExists) {
-            error = QSystemError(err, QSystemError::NativeError);
-            return false;
-        }
 #else // POSIX
         file = QT_OPEN(path.constData(),
                 QT_OPEN_CREAT | O_EXCL | QT_OPEN_RDWR | QT_OPEN_LARGEFILE,
@@ -283,9 +256,6 @@ bool QTemporaryFileEngine::isReallyOpen()
     Q_D(QFSFileEngine);
 
     if (!((0 == d->fh) && (-1 == d->fd)
-#if defined (Q_OS_SYMBIAN)
-                && (0 == d->symbianFile.SubSessionHandle())
-#endif
 #if defined Q_OS_WIN
                 && (INVALID_HANDLE_VALUE == d->fileHandle)
 #endif
@@ -377,8 +347,6 @@ bool QTemporaryFileEngine::open(QIODevice::OpenMode openMode)
     QSystemError error;
 #if defined(Q_OS_WIN)
     NativeFileHandle &file = d->fileHandle;
-#elif defined(Q_OS_SYMBIAN)
-    NativeFileHandle &file = d->symbianFile;
 #else // POSIX
     NativeFileHandle &file = d->fd;
 #endif
diff --git a/src/corelib/kernel/qcore_unix_p.h b/src/corelib/kernel/qcore_unix_p.h
index d2e1691..6ec8e26 100644
--- a/src/corelib/kernel/qcore_unix_p.h
+++ b/src/corelib/kernel/qcore_unix_p.h
@@ -274,9 +274,8 @@ static inline int qt_safe_close(int fd)
 #undef QT_CLOSE
 #define QT_CLOSE qt_safe_close
 
-// - Open C does not (yet?) implement these on Symbian OS
 // - VxWorks doesn't have processes
-#if !defined(Q_OS_SYMBIAN) && !defined(Q_OS_VXWORKS)
+#if !defined(Q_OS_VXWORKS)
 static inline int qt_safe_execve(const char *filename, char *const argv[],
                                  char *const envp[])
 {
@@ -298,16 +297,13 @@ static inline int qt_safe_execvp(const char *file, char *const argv[])
     EINTR_LOOP(ret, ::execvp(file, argv));
     return ret;
 }
-#endif
 
-#ifndef Q_OS_VXWORKS // no processes on VxWorks
 static inline pid_t qt_safe_waitpid(pid_t pid, int *status, int options)
 {
     register int ret;
     EINTR_LOOP(ret, ::waitpid(pid, status, options));
     return ret;
 }
-
 #endif // Q_OS_VXWORKS
 
 #if !defined(_POSIX_MONOTONIC_CLOCK)
diff --git a/src/corelib/kernel/qcoreapplication.cpp b/src/corelib/kernel/qcoreapplication.cpp
index 223d786..58cccfa 100644
--- a/src/corelib/kernel/qcoreapplication.cpp
+++ b/src/corelib/kernel/qcoreapplication.cpp
@@ -66,15 +66,7 @@
 #include <private/qfunctions_p.h>
 #include <private/qlocale_p.h>
 
-#ifdef Q_OS_SYMBIAN
-#  include <exception>
-#  include <f32file.h>
-#  include <e32ldr.h>
-#  include "qeventdispatcher_symbian_p.h"
-#  include "private/qcore_symbian_p.h"
-#  include "private/qfilesystemengine_p.h"
-#  include <apacmdln.h>
-#elif defined(Q_OS_UNIX)
+#if defined(Q_OS_UNIX)
 #  if !defined(QT_NO_GLIB)
 #    include "qeventdispatcher_glib_p.h"
 #  endif
@@ -116,62 +108,6 @@ private:
     QMutex *mtx;
 };
 
-#ifdef Q_OS_SYMBIAN
-typedef TDriveNumber (*SystemDriveFunc)(RFs&);
-static SystemDriveFunc PtrGetSystemDrive = 0;
-static CApaCommandLine* apaCommandLine = 0;
-static char *apaTail = 0;
-static QVector<char *> *apaArgv = 0;
-
-static void qt_cleanup_apa_cmd_line()
-{
-    delete apaCommandLine;
-    apaCommandLine = 0;
-    delete apaArgv;
-    apaArgv = 0;
-    delete apaTail;
-    apaTail = 0;
-}
-
-static inline void qt_init_symbian_apa_arguments(int &argc, char **&argv)
-{
-    // If app is launched via CApaCommandLine::StartApp(), normal arguments only contain
-    // application name.
-    if (argc == 1) {
-        CApaCommandLine* commandLine = QCoreApplicationPrivate::symbianCommandLine();
-        if(commandLine) {
-            TPtrC8 apaCmdLine = commandLine->TailEnd();
-            int tailLen = apaCmdLine.Length();
-            if (tailLen) {
-                apaTail = reinterpret_cast<char *>(malloc(tailLen + 1));
-                qMemCopy(apaTail, reinterpret_cast<const char *>(apaCmdLine.Ptr()), tailLen);
-                apaTail[tailLen] = '\0';
-                apaArgv = new QVector<char *>(8);
-                // Reuse windows command line parsing
-                *apaArgv = qWinCmdLine<char>(apaTail, tailLen, argc);
-                apaArgv->insert(0, argv[0]);
-                argc++;
-                argv = apaArgv->data();
-            }
-        }
-    }
-}
-
-CApaCommandLine* QCoreApplicationPrivate::symbianCommandLine()
-{
-    // Getting of Apa command line needs to be static as it can only be called successfully
-	// once per process.
-    if (!apaCommandLine) {
-        TInt err = CApaCommandLine::GetCommandLineFromProcessEnvironment(apaCommandLine);
-        if (err == KErrNone) {
-            qAddPostRoutine(qt_cleanup_apa_cmd_line);
-        }
-    }
-    return apaCommandLine;
-}
-
-#endif
-
 #if defined(Q_OS_WIN) || defined(Q_OS_MAC)
 extern QString qAppFileName();
 #endif
@@ -347,10 +283,6 @@ QCoreApplicationPrivate::QCoreApplicationPrivate(int &aargc, char **aargv, uint
     }
     QCoreApplicationPrivate::is_app_closing = false;
 
-#ifdef Q_OS_SYMBIAN
-    qt_init_symbian_apa_arguments(argc, argv);
-#endif
-
 #ifdef Q_OS_UNIX
     qt_application_thread_id = QThread::currentThreadId();
 #endif
@@ -393,9 +325,7 @@ void QCoreApplicationPrivate::cleanupThreadData()
 void QCoreApplicationPrivate::createEventDispatcher()
 {
     Q_Q(QCoreApplication);
-#if defined(Q_OS_SYMBIAN)
-    eventDispatcher = new QEventDispatcherSymbian(q);
-#elif defined(Q_OS_UNIX)
+#if defined(Q_OS_UNIX)
 #  if !defined(QT_NO_GLIB)
     if (qgetenv("QT_NO_GLIB").isEmpty() && QEventDispatcherGlib::versionSupported())
         eventDispatcher = new QEventDispatcherGlib(q);
@@ -443,11 +373,6 @@ void QCoreApplicationPrivate::checkReceiverThread(QObject *receiver)
     Q_UNUSED(currentThread);
     Q_UNUSED(thr);
 }
-#elif defined(Q_OS_SYMBIAN) && defined (QT_NO_DEBUG)
-// no implementation in release builds, but keep the symbol present
-void QCoreApplicationPrivate::checkReceiverThread(QObject * /* receiver */)
-{
-}
 #endif
 
 void QCoreApplicationPrivate::appendApplicationPathToLibraryPaths()
@@ -455,17 +380,10 @@ void QCoreApplicationPrivate::appendApplicationPathToLibraryPaths()
 #if !defined(QT_NO_LIBRARY) && !defined(QT_NO_SETTINGS)
     QStringList *app_libpaths = coreappdata()->app_libpaths;
     Q_ASSERT(app_libpaths);
-# if defined(Q_OS_SYMBIAN)
-    QString app_location( QCoreApplication::applicationDirPath() );
-    // File existence check for application's private dir requires additional '\' or
-    // platform security will not allow it.
-    if (app_location !=  QLibraryInfo::location(QLibraryInfo::PluginsPath) && QFile::exists(app_location + QLatin1Char('\\')) && !app_libpaths->contains(app_location))
-# else
     QString app_location( QCoreApplication::applicationFilePath() );
     app_location.truncate(app_location.lastIndexOf(QLatin1Char('/')));
     app_location = QDir(app_location).canonicalPath();
     if (QFile::exists(app_location) && !app_libpaths->contains(app_location))
-# endif
         app_libpaths->append(app_location);
 #endif
 }
@@ -607,17 +525,6 @@ QCoreApplication::QCoreApplication(int &argc, char **argv, int _internal)
 {
     init();
     QCoreApplicationPrivate::eventDispatcher->startingUp();
-#if defined(Q_OS_SYMBIAN)
-#ifndef QT_NO_LIBRARY
-    // Refresh factoryloader, as text codecs are requested during lib path
-    // resolving process and won't be therefore properly loaded.
-    // Unknown if this is symbian specific issue.
-    QFactoryLoader::refreshAll();
-#endif
-#ifndef QT_NO_SYSTEMLOCALE
-    d_func()->symbianInit();
-#endif
-#endif //Q_OS_SYMBIAN
 }
 
 
@@ -634,12 +541,6 @@ void QCoreApplication::init()
     Q_ASSERT_X(!self, "QCoreApplication", "there should be only one application object");
     QCoreApplication::self = this;
 
-#ifdef Q_OS_SYMBIAN
-    //ensure temp and working directories exist
-    QFileSystemEngine::createDirectory(QFileSystemEntry(QFileSystemEngine::tempPath()), true);
-    QFileSystemEngine::createDirectory(QFileSystemEntry(QFileSystemEngine::currentPath()), true);
-#endif
-
 #ifndef QT_NO_THREAD
     QThread::initialize();
 #endif
@@ -678,15 +579,6 @@ void QCoreApplication::init()
     qt_startup_hook();
 }
 
-#if defined(Q_OS_SYMBIAN) && !defined(QT_NO_SYSTEMLOCALE)
-void QCoreApplicationPrivate::symbianInit()
-{
-    if (!environmentChangeNotifier)
-        environmentChangeNotifier.reset(new QEnvironmentChangeNotifier);
-}
-#endif
-
-
 /*!
     Destroys the QCoreApplication object.
 */
@@ -1819,11 +1711,6 @@ bool QCoreApplicationPrivate::isTranslatorInstalled(QTranslator *translator)
     function also assumes that the current directory has not been
     changed by the application.
 
-    In Symbian this function will return the application private directory,
-    not the path to executable itself, as those are always in \c {/sys/bin}.
-    If the application is in a read only drive, i.e. ROM, then the private path
-    on the system drive will be returned.
-
     \sa applicationFilePath()
 */
 QString QCoreApplication::applicationDirPath()
@@ -1835,49 +1722,7 @@ QString QCoreApplication::applicationDirPath()
 
     QCoreApplicationPrivate *d = self->d_func();
     if (d->cachedApplicationDirPath.isNull())
-#if defined(Q_OS_SYMBIAN)
-    {
-        QString appPath;
-        RFs& fs = qt_s60GetRFs();
-        TChar driveChar;
-        QChar qDriveChar;
-        driveChar = (RProcess().FileName())[0];
-
-        //Check if the process is installed in a read only drive (typically ROM),
-        //and use the system drive (typically C:) if so.
-        TInt drive;
-        TDriveInfo driveInfo;
-        TInt err = fs.CharToDrive(driveChar, drive);
-        if (err == KErrNone) {
-            err = fs.Drive(driveInfo, drive);
-        }
-        if (err != KErrNone || (driveInfo.iDriveAtt & KDriveAttRom) || (driveInfo.iMediaAtt
-            & KMediaAttWriteProtected)) {
-            if(!PtrGetSystemDrive)
-                PtrGetSystemDrive = reinterpret_cast<SystemDriveFunc>(qt_resolveS60PluginFunc(S60Plugin_GetSystemDrive));
-            Q_ASSERT(PtrGetSystemDrive);
-            drive = PtrGetSystemDrive(fs);
-            fs.DriveToChar(drive, driveChar);
-        }
-
-        qDriveChar = QChar(QLatin1Char(driveChar)).toUpper();
-
-        TFileName privatePath;
-        fs.PrivatePath(privatePath);
-        appPath = qt_TDesC2QString(privatePath);
-        appPath.prepend(QLatin1Char(':')).prepend(qDriveChar);
-
-        // Create the appPath if it doesn't exist. Non-existing appPath will cause
-        // Platform Security violations later on if the app doesn't have AllFiles capability.
-        err = fs.CreatePrivatePath(drive);
-        if (err != KErrNone)
-            qWarning("QCoreApplication::applicationDirPath: Failed to create private path.");
-
-        d->cachedApplicationDirPath = QFileInfo(appPath).path();
-    }
-#else
         d->cachedApplicationDirPath = QFileInfo(applicationFilePath()).path();
-#endif
     return d->cachedApplicationDirPath;
 }
 
@@ -1918,20 +1763,7 @@ QString QCoreApplication::applicationFilePath()
         return d->cachedApplicationFilePath;
     }
 #endif
-#if defined(Q_OS_SYMBIAN)
-    QString appPath;
-    RProcess proc;
-    TInt err = proc.Open(proc.Id());
-    if (err == KErrNone) {
-        TFileName procName = proc.FileName();
-        appPath.append(QString(reinterpret_cast<const QChar*>(procName.Ptr()), procName.Length()));
-        proc.Close();
-    }
-
-    d->cachedApplicationFilePath = appPath;
-    return d->cachedApplicationFilePath;
-
-#elif defined( Q_OS_UNIX )
+#if defined( Q_OS_UNIX )
 #  ifdef Q_OS_LINUX
     // Try looking for a /proc/<pid>/exe symlink first which points to
     // the absolute path of the executable
@@ -2045,12 +1877,6 @@ char **QCoreApplication::argv()
     As a result of this, the string given by arguments().at(0) might not be
     the program name on Windows, depending on how the application was started.
 
-    For Symbian applications started with \c RApaLsSession::StartApp one can specify
-    arguments using \c CApaCommandLine::SetTailEndL function. Such arguments are only
-    available via this method; they will not be passed to \c main function. Also note
-    that only 8-bit string data set with \c CApaCommandLine::SetTailEndL is supported
-    by this function.
-
     \sa applicationFilePath()
 */
 
@@ -2229,34 +2055,12 @@ QStringList QCoreApplication::libraryPaths()
     if (!coreappdata()->app_libpaths) {
         QStringList *app_libpaths = coreappdata()->app_libpaths = new QStringList;
         QString installPathPlugins =  QLibraryInfo::location(QLibraryInfo::PluginsPath);
-#if defined(Q_OS_SYMBIAN)
-        // Add existing path on all drives for relative PluginsPath in Symbian
-        if (installPathPlugins.at(1) != QChar(QLatin1Char(':'))) {
-            QString tempPath = installPathPlugins;
-            if (tempPath.at(tempPath.length() - 1) != QDir::separator()) {
-                tempPath += QDir::separator();
-            }
-            RFs& fs = qt_s60GetRFs();
-            TPtrC tempPathPtr(reinterpret_cast<const TText*> (tempPath.constData()));
-            TFindFile finder(fs);
-            TInt err = finder.FindByDir(tempPathPtr, tempPathPtr);
-            while (err == KErrNone) {
-                QString foundDir(reinterpret_cast<const QChar *>(finder.File().Ptr()),
-                                 finder.File().Length());
-                foundDir = QDir(foundDir).canonicalPath();
-                if (!app_libpaths->contains(foundDir))
-                    app_libpaths->append(foundDir);
-                err = finder.Find();
-            }
-        }
-#else
         if (QFile::exists(installPathPlugins)) {
             // Make sure we convert from backslashes to slashes.
             installPathPlugins = QDir(installPathPlugins).canonicalPath();
             if (!app_libpaths->contains(installPathPlugins))
                 app_libpaths->append(installPathPlugins);
         }
-#endif
 
         // If QCoreApplication is not yet instantiated,
         // make sure we add the application path when we construct the QCoreApplication
@@ -2264,7 +2068,7 @@ QStringList QCoreApplication::libraryPaths()
 
         const QByteArray libPathEnv = qgetenv("QT_PLUGIN_PATH");
         if (!libPathEnv.isEmpty()) {
-#if defined(Q_OS_WIN) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN)
             QLatin1Char pathSep(';');
 #else
             QLatin1Char pathSep(':');
@@ -2290,10 +2094,6 @@ QStringList QCoreApplication::libraryPaths()
     \a paths. All existing paths will be deleted and the path list
     will consist of the paths given in \a paths.
 
-    In Symbian this function is only useful for setting paths for
-    finding Qt extension plugin stubs, since the OS can only
-    load libraries from the \c{/sys/bin} directory.
-
     \sa libraryPaths(), addLibraryPath(), removeLibraryPath(), QLibrary
  */
 void QCoreApplication::setLibraryPaths(const QStringList &paths)
@@ -2316,10 +2116,6 @@ void QCoreApplication::setLibraryPaths(const QStringList &paths)
   is \c INSTALL/plugins, where \c INSTALL is the directory where Qt was
   installed.
 
-  In Symbian this function is only useful for adding paths for
-  finding Qt extension plugin stubs, since the OS can only
-  load libraries from the \c{/sys/bin} directory.
-
   \sa removeLibraryPath(), libraryPaths(), setLibraryPaths()
  */
 void QCoreApplication::addLibraryPath(const QString &path)
diff --git a/src/corelib/kernel/qcoreapplication.h b/src/corelib/kernel/qcoreapplication.h
index b4e407a..7512028 100644
--- a/src/corelib/kernel/qcoreapplication.h
+++ b/src/corelib/kernel/qcoreapplication.h
@@ -156,7 +156,7 @@ public:
     virtual bool winEventFilter(MSG *message, long *result);
 #endif
 
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX)
     static void watchUnixSignal(int signal, bool watch);
 #endif
 
diff --git a/src/corelib/kernel/qcoreapplication_p.h b/src/corelib/kernel/qcoreapplication_p.h
index 48a1ac6..b5b6c0d 100644
--- a/src/corelib/kernel/qcoreapplication_p.h
+++ b/src/corelib/kernel/qcoreapplication_p.h
@@ -58,20 +58,10 @@
 #include "QtCore/qsettings.h"
 #include "private/qobject_p.h"
 
-#ifdef Q_OS_SYMBIAN
-#include <f32file.h>
-#endif
-
 QT_BEGIN_NAMESPACE
 
 typedef QList<QTranslator*> QTranslatorList;
 
-#if defined(Q_OS_SYMBIAN)
-#  if !defined(QT_NO_SYSTEMLOCALE)
-class QEnvironmentChangeNotifier;
-#  endif
-class CApaCommandLine;
-#endif
 class QAbstractEventDispatcher;
 
 class Q_CORE_EXPORT QCoreApplicationPrivate : public QObjectPrivate
@@ -104,7 +94,7 @@ public:
     static bool checkInstance(const char *method);
     static void sendPostedEvents(QObject *receiver, int event_type, QThreadData *data);
 
-#if !defined (QT_NO_DEBUG) || defined (QT_MAC_FRAMEWORK_BUILD) || defined (Q_OS_SYMBIAN)
+#if !defined (QT_NO_DEBUG) || defined (QT_MAC_FRAMEWORK_BUILD)
     void checkReceiverThread(QObject *receiver);
 #endif
     int &argc;
@@ -124,13 +114,6 @@ public:
     bool threadData_clean;
     QString cachedApplicationDirPath;
     QString cachedApplicationFilePath;
-#if defined(Q_OS_SYMBIAN)
-#  if !defined(QT_NO_SYSTEMLOCALE)
-    QScopedPointer<QEnvironmentChangeNotifier> environmentChangeNotifier;
-    void symbianInit();
-#  endif
-    static CApaCommandLine* symbianCommandLine();
-#endif
 
     static bool isTranslatorInstalled(QTranslator *translator);
 
diff --git a/src/corelib/kernel/qcorecmdlineargs_p.h b/src/corelib/kernel/qcorecmdlineargs_p.h
index d872778..70e41ac 100644
--- a/src/corelib/kernel/qcorecmdlineargs_p.h
+++ b/src/corelib/kernel/qcorecmdlineargs_p.h
@@ -58,7 +58,7 @@
 
 QT_BEGIN_NAMESPACE
 
-#if defined(Q_OS_WIN32) || defined(Q_OS_WINCE) || defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_WIN32) || defined(Q_OS_WINCE)
 
 QT_BEGIN_INCLUDE_NAMESPACE
 #include "QtCore/qvector.h"
@@ -154,7 +154,7 @@ static inline QStringList qCmdLineArgs(int argc, char *argv[])
     return qWinCmdArgs(cmdLine);
 }
 #endif
-#else  // !Q_OS_WIN || !Q_OS_SYMBIAN
+#else  // !Q_OS_WIN
 
 static inline QStringList qCmdLineArgs(int argc, char *argv[])
 {
@@ -164,7 +164,7 @@ static inline QStringList qCmdLineArgs(int argc, char *argv[])
     return args;
 }
 
-#endif // Q_OS_WIN || Q_OS_SYMBIAN
+#endif // Q_OS_WIN
 
 QT_END_NAMESPACE
 
diff --git a/src/corelib/kernel/qmetatype.h b/src/corelib/kernel/qmetatype.h
index ceaf9eb..fd5c5f3 100644
--- a/src/corelib/kernel/qmetatype.h
+++ b/src/corelib/kernel/qmetatype.h
@@ -194,7 +194,7 @@ public:
 // This logic must match the one in qglobal.h
 #if defined(QT_COORD_TYPE)
         QReal = 0,
-#elif defined(QT_NO_FPU) || defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE) || defined(QT_ARCH_SYMBIAN)
+#elif defined(QT_NO_FPU) || defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)
         QReal = Float,
 #else
         QReal = Double,
diff --git a/src/corelib/kernel/qsharedmemory.cpp b/src/corelib/kernel/qsharedmemory.cpp
index e294151..9ffa350 100644
--- a/src/corelib/kernel/qsharedmemory.cpp
+++ b/src/corelib/kernel/qsharedmemory.cpp
@@ -44,9 +44,6 @@
 #include "qsystemsemaphore.h"
 #include <qdir.h>
 #include <qcryptographichash.h>
-#ifdef Q_OS_SYMBIAN
-#include <e32const.h>
-#endif
 #include <qdebug.h>
 
 QT_BEGIN_NAMESPACE
@@ -59,7 +56,6 @@ QT_BEGIN_NAMESPACE
     the subset that the win/unix kernel allows.
 
     On Unix this will be a file name
-    On Symbian key will be truncated to 80 characters
   */
 QString
 QSharedMemoryPrivate::makePlatformSafeKey(const QString &key,
@@ -78,8 +74,6 @@ QSharedMemoryPrivate::makePlatformSafeKey(const QString &key,
     result.append(QLatin1String(hex));
 #ifdef Q_OS_WIN
     return result;
-#elif defined(Q_OS_SYMBIAN)
-    return result.left(KMaxKernelName);
 #else
     return QDir::tempPath() + QLatin1Char('/') + result;
 #endif
@@ -121,14 +115,6 @@ QSharedMemoryPrivate::makePlatformSafeKey(const QString &key,
   process. This means that QSharedMemory should not be used across
   multiple threads in the same process in HP-UX.
 
-  \o Symbian: QSharedMemory does not "own" the shared memory segment.
-  When all threads or processes that have an instance of QSharedMemory
-  attached to a particular shared memory segment have either destroyed
-  their instance of QSharedMemory or exited, the Symbian kernel
-  releases the shared memory segment automatically.
-  Also, access to a shared memory segment cannot be limited to read-only
-  in Symbian.
-
   \endlist
 
   Remember to lock the shared memory with lock() before reading from
diff --git a/src/corelib/kernel/qsharedmemory_p.h b/src/corelib/kernel/qsharedmemory_p.h
index b063309..4fd83fc 100644
--- a/src/corelib/kernel/qsharedmemory_p.h
+++ b/src/corelib/kernel/qsharedmemory_p.h
@@ -71,9 +71,6 @@ namespace QSharedMemoryPrivate
 
 #ifdef Q_OS_WIN
 #include <qt_windows.h>
-#elif defined(Q_OS_SYMBIAN)
-#include <e32std.h>
-#include <sys/types.h>
 #else
 #include <sys/sem.h>
 #endif
@@ -144,11 +141,7 @@ public:
     bool attach(QSharedMemory::AccessMode mode);
     bool detach();
 
-#ifdef Q_OS_SYMBIAN
-    void setErrorString(const QString &function, TInt errorCode);
-#else
     void setErrorString(const QString &function);
-#endif
 
 #ifndef QT_NO_SYSTEMSEMAPHORE
     bool tryLocker(QSharedMemoryLocker *locker, const QString function) {
@@ -164,8 +157,6 @@ public:
 private:
 #ifdef Q_OS_WIN
     HANDLE hand;
-#elif defined(Q_OS_SYMBIAN)
-    RChunk chunk;
 #else
     key_t unix_key;
 #endif
diff --git a/src/corelib/kernel/qsystemerror.cpp b/src/corelib/kernel/qsystemerror.cpp
index 11f7389..774c9b9 100644
--- a/src/corelib/kernel/qsystemerror.cpp
+++ b/src/corelib/kernel/qsystemerror.cpp
@@ -141,76 +141,12 @@ static QString standardLibraryErrorString(int errorCode)
     return ret.trimmed();
 }
 
-#ifdef Q_OS_SYMBIAN
-static QString symbianErrorString(int errorCode)
-{
-    switch (errorCode) {
-    case KErrNotFound:
-        return QLatin1String("not found");
-    case KErrCancel:
-        return QLatin1String("cancelled");
-    case KErrNoMemory:
-        return QLatin1String("out of memory");
-    case KErrNotSupported:
-        return QLatin1String("not supported");
-    case KErrBadHandle:
-        return QLatin1String("bad handle"); //KERN-EXEC 0 panic is more likely
-    case KErrAlreadyExists:
-        return QLatin1String("already exists");
-    case KErrPathNotFound:
-        return QLatin1String("path not found");
-    case KErrInUse:
-        return QLatin1String("in use");
-    case KErrNotReady:
-        return QLatin1String("not ready (e.g. FS dismounted, network down)");
-    case KErrCorrupt:
-        return QLatin1String("corrupt");
-    case KErrAccessDenied:
-        return QLatin1String("access denied");
-    case KErrLocked:
-        return QLatin1String("locked");
-    case KErrWrite:
-        return QLatin1String("incomplete write error");
-    case KErrDisMounted:
-        return QLatin1String("file system dismounted during operation"); //i.e. a forcible dismount was done while we had files open
-    case KErrEof:
-        return QLatin1String("end of file");
-    case KErrDiskFull:
-        return QLatin1String("no space in file system");
-    case KErrBadName:
-        return QLatin1String("invalid filename");
-    case KErrTimedOut:
-        return QLatin1String("timed out");
-    case KErrBadDescriptor:
-        return QLatin1String("bad descriptor (passed address on stack to async call?)");
-    case KErrAbort:
-        return QLatin1String("aborted");
-    case KErrTooBig:
-        return QLatin1String("too big"); //e.g. trying to open a >2GB file with 32 bit API
-    case KErrBadPower:
-        return QLatin1String("insufficient power");
-    case KErrDirFull:
-        return QLatin1String("no space in directory table");
-    case KErrHardwareNotAvailable:
-        return QLatin1String("hardware not available");
-    case KErrSessionClosed:
-        return QLatin1String("session closed");
-    case KErrPermissionDenied:
-        return QLatin1String("permission denied");
-    default:
-        return QString(QLatin1String("symbian error %1")).arg(errorCode);
-    }    
-}
-#endif
-
 QString QSystemError::toString()
 {
     switch(errorScope) {
     case NativeError:
 #if defined (Q_OS_WIN)
         return windowsErrorString(errorCode);
-#elif defined (Q_OS_SYMBIAN)
-        return symbianErrorString(errorCode);
 #else
         //unix: fall through as native and standard library are the same
 #endif
diff --git a/src/corelib/kernel/qsystemsemaphore.cpp b/src/corelib/kernel/qsystemsemaphore.cpp
index eab0c32..d0a6783 100644
--- a/src/corelib/kernel/qsystemsemaphore.cpp
+++ b/src/corelib/kernel/qsystemsemaphore.cpp
@@ -123,10 +123,6 @@ QT_BEGIN_NAMESPACE
   resource and then exits without releasing it, Unix will release that
   resource.
 
-  \o Symbian: QSystemSemaphore behaves the same as Windows semaphores.
-  In other words, the operating system owns the semaphore and ignores
-  QSystemSemaphore::AccessMode.
-
   \endlist
 
   \sa QSharedMemory, QSemaphore
@@ -151,7 +147,7 @@ QT_BEGIN_NAMESPACE
   creates a new semaphore for that key and sets its resource count to
   \a initialValue.
 
-  In Windows and in Symbian, \a mode is ignored, and the system always tries to
+  In Windows, \a mode is ignored, and the system always tries to
   create a semaphore for the specified \a key. If the system does not
   already have a semaphore identified as \a key, it creates the
   semaphore and sets its resource count to \a initialValue. But if the
@@ -201,7 +197,7 @@ QSystemSemaphore::~QSystemSemaphore()
   enable handling the problem in Unix implementations of semaphores
   that survive a crash. In Unix, when a semaphore survives a crash, we
   need a way to force it to reset its resource count, when the system
-  reuses the semaphore. In Windows and in Symbian, where semaphores can't survive a
+  reuses the semaphore. In Windows, where semaphores can't survive a
   crash, this enum has no effect.
 
   \value Open If the semaphore already exists, its initial resource
@@ -214,7 +210,7 @@ QSystemSemaphore::~QSystemSemaphore()
   This value should be passed to the constructor, when the first
   semaphore for a particular key is constructed and you know that if
   the semaphore already exists it could only be because of a crash. In
-  Windows and in Symbian, where a semaphore can't survive a crash, Create and Open
+  Windows, where a semaphore can't survive a crash, Create and Open
   have the same behavior.
 */
 
@@ -234,7 +230,7 @@ void QSystemSemaphore::setKey(const QString &key, int initialValue, AccessMode m
         return;
     d->error = NoError;
     d->errorString = QString();
-#if !defined(Q_OS_WIN) && !defined(Q_OS_SYMBIAN)
+#if !defined(Q_OS_WIN)
     // optimization to not destroy/create the file & semaphore
     if (key == d->key && mode == Create && d->createdSemaphore && d->createdFile) {
         d->initialValue = initialValue;
diff --git a/src/corelib/kernel/qsystemsemaphore_p.h b/src/corelib/kernel/qsystemsemaphore_p.h
index 88e1964..1066522 100644
--- a/src/corelib/kernel/qsystemsemaphore_p.h
+++ b/src/corelib/kernel/qsystemsemaphore_p.h
@@ -62,10 +62,6 @@
 #   include <sys/types.h>
 #endif
 
-#ifdef Q_OS_SYMBIAN
-class RSemaphore;
-#endif
-
 QT_BEGIN_NAMESPACE
 
 class QSystemSemaphorePrivate
@@ -82,9 +78,6 @@ public:
 #ifdef Q_OS_WIN
     HANDLE handle(QSystemSemaphore::AccessMode mode = QSystemSemaphore::Open);
     void setErrorString(const QString &function);
-#elif defined(Q_OS_SYMBIAN)
-    int handle(QSystemSemaphore::AccessMode mode = QSystemSemaphore::Open);
-    void setErrorString(const QString &function,int err = 0);
 #else
     key_t handle(QSystemSemaphore::AccessMode mode = QSystemSemaphore::Open);
     void setErrorString(const QString &function);
@@ -98,8 +91,6 @@ public:
 #ifdef Q_OS_WIN
     HANDLE semaphore;
     HANDLE semaphoreLock;
-#elif defined(Q_OS_SYMBIAN)
-    RSemaphore semaphore;
 #else
     int semaphore;
     bool createdFile;
diff --git a/src/corelib/kernel/qtranslator.cpp b/src/corelib/kernel/qtranslator.cpp
index 6fa7407..a11bcb2 100644
--- a/src/corelib/kernel/qtranslator.cpp
+++ b/src/corelib/kernel/qtranslator.cpp
@@ -58,7 +58,7 @@
 #include "qtranslator_p.h"
 #include "qlocale.h"
 
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN) && !defined(Q_OS_INTEGRITY)
+#if defined(Q_OS_UNIX) && !defined(Q_OS_INTEGRITY)
 #define QT_USE_MMAP
 #include "private/qcore_unix_p.h"
 #endif
@@ -518,7 +518,7 @@ static QString find_translation(const QLocale & locale,
     // see http://www.unicode.org/reports/tr35/#LanguageMatching for inspiration
 
     QStringList languages = locale.uiLanguages();
-#if defined(Q_OS_UNIX) && !defined(Q_OS_SYMBIAN)
+#if defined(Q_OS_UNIX)
     for (int i = languages.size()-1; i >= 0; --i) {
         QString lang = languages.at(i);
         QString lowerLang = lang.toLower();